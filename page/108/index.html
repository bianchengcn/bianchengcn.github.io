<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9487144a3c548f952478e2fd58244e11/" rel="bookmark">
			字节北京23k和拼多多上海28K，我该怎么选？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知乎上收到一位网友的求助：
前端，北京字节23k和拼多多月薪28K，我该选哪个好？
问题挺有意思的，北京字节VS上海拼多多，两份offer该怎么选？
我们找工作是为了什么？多数人首选就是钱。话说，2022年互联网依旧是高薪的行业！是不是也给了很多想入行的小伙伴一些信心呢？你是不是也想有这样的纠结，
黑马程序员现在开设的8大精品学科，便是在培养所需的互联网高薪必备人才。
在没有附加条件的情况下，这两份工作到底怎么选？那肯定就是看钱多的。一份工作28k，另一个23k，这傻子一眼都能看出来，一年下来多6万呢，你说你会选哪个？如果是以前，我会毫不犹豫劝该职场人选拼多多，但现在的话，绝对倾向于字节跳动。
但字节修改了工作制后，28K的工资一定就比23k高吗？作为一个职场自媒体，就来带大家算两笔账。给大家分析分析。
去年7月9日晚间，字节跳动发出全员邮件，邮件里只写了两句话：
“我们将于2021年8月1日起取消隔周周日工作的安排，请大家做好相应调整。8月开始有需求的团队和个人，可以通过系统提交加班申请。”
也就是说，工作制从以前的996VS11116变成了现在的995VS11116。
首先，对比两边薪资到底谁高，日薪说了算。 出来打工选offer，我们首先要考虑“投入产出比”。
两份工作都是前端开发，也就是工作内容这是相同的，字节双休，拼多多是单休。现在的职场人不用考虑，多数都会去选择单休，因为外出打工的孤独感外加工具人没任何兴趣爱好，所以都宁愿多赚点钱也不要那一天的休假，一年下来还多赚60000。
就知乎这个问题，笔者在前提条件不足的情况下，给该职场人先设一个前提。比如：两份工作内容和强度差不多，不算节假日几倍工资的情况下，我们来算一算在字节跟拼多多的日薪。
字节跳动：
按一个月上班22天计算，双休的日薪为1045元。
拼多多：
按一个月上班26天计算，单休的日薪为1076元。
从日薪的角度算下来，都是上一天班，在字节跟拼多多薪资差不了几块钱。可能有人会说了，如果取消前提条件再加加班费算下来，拼多多的工资肯定拿得多呀。
也不一定！
就两家来说，不管是995还是11116，周末加班虽然都是双倍工资，但如果是单休那一天，周六的工资是不算加班时常的，都含在你的基础薪资里。而换成双休制，在字节加班四个周六，加班费=1045×2×4=8360元。
还有一种情况，在字节跟拼多多都不加班，在拼多多看上去11116是挣得多点，对不对？表面看没有问题，从总收入来说，是这样的。但是你愿意为了5000块，每个月多上4-6天班吗？
其次，我们算工资还得算工作成本。 前面笔者说过，选择这两份offer，要算“投入产出比”。
每天的薪资这是产出，投入是什么呢？笔者在这里说的投入，就是我们每天工作的成本，比如交通费、饭食、通讯、工作时间、技能等等。前面也说过，前提条件都一样，最好比较，但这里的差别就是多了周6这一天。所以这里的投入差别就在周六的这一天。
周六不上班的同学，虽然没有通勤费了，但是时间自由。女生还好点，出去消费、逛街、看电影，男生多数就是刷短视频、玩王者，确实比上班产生的消费要高。当然，也有聪明的同学用来做副业、进修或者读书。
而周六上班的，遇上好公司，不说赚多少了，加上隐性成本，甚至连饭钱都能省。
这里也要举个例子：有家庭的，周六我要带孩子出去玩，少说1-2百吧。带老婆出去吃饭，还要花钱，也要2-3百。而在拼多多加班，不但不花钱，还赚1076元。而没家庭、没爱好的，就是死宅，你让他闲在那十平方的出租屋内，难受不难受？
所以，这样算下来，到底是上班好，还是休息好？
这也就是为什么，字节那么多人即使不喜欢大小周，还闹着要加班的原因，当然，这也是互联网内卷的重要原因之一。
低头做事，也要抬头看路 互联网从来没有蠢人，但是不少人只懂得低头做事，没有抬头看路。笔者以上的分析，这都是基于在没有任何外界因素的情况下。但如果未来拼多多被劳动局按在地上摩擦，被强行取消11116工作制的话，那就是另一个故事了。
最后：
希望现在的职场人都别把自己搞成一个职场机器！虽然我们都是社会人，但不代表一切事情都要向钱看齐，我们需要交际、需要娱乐、需要学习，任何事，并不一定非要唯利是图。
周末，单身汪多去参与参与户外活动，培养一个兴趣爱好，多与朋友聚会，即使你去超市转转也比你窝在家里玩游戏强啊！有家庭的，多陪陪家人，带孩子去玩玩，虽然会花钱，但亲情、爱情、生活这都是用钱所买不到的。
挣钱虽然是我们的责任，是对家庭的负责，但钱真不是万能的。所以希望大家在考虑薪资的同时，还要多考虑一下其他需求。我们牺牲的这些需求，是否和收获成正比。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa272bc985e375233d9ff1fe5d056eb7/" rel="bookmark">
			C盘爆满怎么办？手把手教你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C盘爆满怎么办？手把手教你 应用程序方面 Space Sniff
这个仅2M的应用可以检测你各个磁盘驱动器的大小情况,让你更好的了解你各个磁盘文件夹占用情况。对不需要的文件夹进行清除。官网下载地址:http://www.uderzo.it/main_products/space_sniffer/index.htmlDism ++
它可以让你清除电脑中的缓存文件，容量也仅为几M，主要是它的空间回收功能相当给力。它会自动筛选出C盘用不道德文件。默认清除就好。我每次都是关机前清除的。官网下载地址:https://github.com/Chuyu-Team/Dism-Multi-language/blob/master/README.mdGeek
它可以彻底卸载你电脑的应用程序，值得注意的是，它也可以卸载应用程序在电脑上的注册表。防止软件卸载卸载后"死灰复燃"。官网下载地址:https://geekuninstaller.com/ 后面是我整理的安装包，大家自取https://wwb.lanzouj.com/ikz6d05s41ih
密码:djrc
⚠️ C盘的文件名为system、windows、AMD64、drivers、program data这些的文件都不要删除，否则后果你懂的😏😏😏
转移社交软件缓存文件的保存路径 以QQ和微信为例，
关闭系统休眠文件 按住win+r,输入cmd,回车确定。输入
powercfg/h off 转移系统新文件的保存位置 按住win+i,选择系统选项，点击存储，下拉点击更改新内容的保存位置，更改除C盘外的其它盘符(容量尽可能大)，如下所示：
使用系统自带的清理缓存 按住win+x,输入磁盘清理,打开它,选择C盘,清理内容。
大家还有什么方法，欢迎在评论区讨论留言。同时希望大家能点个🧡，非常感谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c59972660002c70792872d2275a0fd/" rel="bookmark">
			使用Token进行身份验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、作为计算机术语时，是“令牌”的意思 token是计算机术语：令牌，令牌是一种能够控制站点占有媒体的特殊帧，以区别数据帧及其他控制帧。token其实说的更通俗点可以叫暗号，在一些数据传输之前，要先进行暗号的核对，不同的暗号被授权不同的数据操作。基于 Token 的身份验证方法
使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：
1.客户端使用用户名跟密码请求登录
2.服务端收到请求，去验证用户名与密码
3.验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
4.客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里
5.客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
6.服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据
二、定义 token：服务端生成的一串字符串，可以解决频繁登录的问题它作为客户端进行请求的一个令牌：
第一次登录后，服务器生成一个token返回给客户端；客户端只需要带上token来请求数据即可，无需再次带上用户名和密码；可以有效减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。
三、token的组成部分 token分为三部分来定义： 1 .表头：Header是一个json对象，存储元数据 { "alg":"HS256", "typ":"JWT" } alg:是签名的算法名称（algorithm），默认是HMAC SHA）; type属性表示这个令牌（token）的类型（type),JWT令牌统一写成JWT。 2.负载：Payload是一个json对象。存放传递的数据，数据分为Public和Private。 Public是JWT中规定的一些字段，可以自己选择使用。 iss（issuer):签发人 exp（expiration time):过期时间 sub(subject):该JWT所面向的用户 aud(audience):受众，接受该JWT的一方 nbf(not before):生效时间 iat(Issued At):签发时间 jti(JWT ID):编号 Private是自己定义的字段 { “role":经理， "name":张凡， "id":23455 } Play默认是没有加密的，以上数据都是明文传输的，所以最好不要存放敏感数据。前两部分数据都是json对象使用的是base64URL编码，翻译为字符串。
3.Signature：签名。签名是对Header和Payload两部分的签名，目的是为了防止数据被篡改 HMACSHA256（ base64UrlEncoder(header)+"."+ base64UrlENcode(paylosd), secret) 签名算法：先指定一个secret密匙，把base64URL的header,base64RL的payload和secret秘匙 使用HNAC SHA256生成签名字符串。
最后把三个部分的拼成一个字符串，每个部分之间用点（.)分隔，就可以返回给用户。
四、token 使用 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77c59972660002c70792872d2275a0fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/778ec126599cab0339c5e90e7b8ee34d/" rel="bookmark">
			DUF:Deep Video Super-Resolution Network Using Dynamic Upsampling Filters ...阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DUF:Deep Video Super-Resolution Network Using Dynamic Upsampling Filters Without Explicit Motion Compensation
DUF：无需显式运动补偿的动态上采样滤波器的深视频超分辨率网络
论文：https://openaccess.thecvf.com/content_cvpr_2018/papers/Jo_Deep_Video_Super-Resolution_CVPR_2018_paper.pdf
代码：https://github.com/yhjo09/VSR-DUF
个人复现(pytorch)：GitHub - gedulding/VSR_DUF_pytorch: According to the author's paper and code, it is converted to pytorch implementation. This code can be used as the basis for reproducing this paper. And the code content can be used as a template
本篇笔记主要对整篇论文从头到尾进行阅读分析，本文内容有点多，主要是对不同部分的总结以及图例解释，如果只对模型原理部分有兴趣，可直接观看第四部分。
本文为了详细说明各图、公式在各组件中的情况，所以对原文图片、公式做了切割和拼接，保证该内容是在该组件中生效的。
目录
（1）摘要
（2）引言
（3）相关工作
（4）本文方法介绍
（4.1）动态上采样filter
（4.2）残差学习
（4.3）网络结构的设计
（4.4）时间增强
（5）实验
（5.1）学习运动的可视化：
（5.1.1）合成运动测试
（5.1.2）滤波器是否有效测试
（5.1.3）动态上采样滤波器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/778ec126599cab0339c5e90e7b8ee34d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a3561528890a912b46887c519f32fb1/" rel="bookmark">
			tensorflow kears转pb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 model = tf.keras.models.Model() function = _saving_utils.trace_model_call(model) concrete_func = function.get_concrete_function() frozen_func = convert_variables_to_constants_v2( concrete_func, lower_control_flow=False) input_shape = {"input_1" : [1，640，640，3]} _set_tensor_shapes(frozen_func.inputs, input_shape) frozen_func.graph.as_graph_def() tf.io.write_graph(graph_or_graph_def=frozen_func.graph, logdir="./frozen_models", name="model.pb", as_text=False) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f70983f7d134e2b16b2fb8a55f4b536/" rel="bookmark">
			魔塔类游戏实现源码及关卡生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《魔塔》》是一种策略类的固定数值RPG游戏。 本篇主要讨论红塔游戏，侧重于路线的寻找。 一般RPG类游戏可以使用脚本语言来编写任务剧情，这样可以使得剧情更复杂和灵活多变，这同样适用于魔塔游戏。但是为了自动生成关卡的目的，还是使用数据驱动的方法来实现游戏逻辑，这样方便编写搜索算法。
游戏关卡的设计一般可以使用编辑器来编辑，编辑器很好实现，但要设计一个耐玩的关卡似乎不太简单，后面会做一些自动生成的尝试。 参考“魔塔吧”，网站WDMOTA
在讨论自动生成关卡之前，先来复刻一版现成的魔塔游戏。这里选择胖老鼠的21层魔塔，
这一版魔塔相对简单：楼层数少、迷宫不复杂、没有坑人的机关、商店不会涨价，因此更容易编写自动生成的算法。
游戏剧情
前来拯救公主的勇者在魔塔醒来后遇到了仙子，仙子告诉他他被魔塔的小怪打晕了，是自己将他救了出来。仙子让勇者去找一个十字架，这样仙子可以把自己的力量借给勇者。仙子给了勇者三把钥匙后，勇者就出发了。
勇者在4层找到了一个小偷，小偷答应帮助勇者，于是勇者请求小偷为自己开2层的门，小偷答应了，并告诉勇者如果找到了镶有红宝石的铁榔头，他可以为勇者打开18层的路。
勇者在16层遇见了魔王和神秘老人（若在规定时间内未到达16层，则老人不会出现），神秘老人将神秘宝物交给勇者，让他交给仙子。仙子告诉勇者这个宝物叫“灵智障灵之杖”，勇者现在拿着的是“冰之灵杖”。灵杖总共有三把，另外两把是“心之灵杖”和“炎之灵杖”，三灵杖是封印地下层的血影的钥匙。
勇者回到16层打败魔王，然后将12层的榔头交给4层的小偷，18层救公主的通道打开了。公主说勇者必须杀死恶魔自己才愿意走，与公主对话后通往19层的楼梯开启。
勇者在19层击败冥灵魔王，冥灵魔王逃到21层。勇者来到20层后，发现没有上楼的楼梯了，之后将7层的十字架交给仙子，仙子将勇者所有能力值提高1/3。
勇者来到21层击败了冥灵魔王，来到22层找到仙子，仙子让勇者找齐另外两个灵杖。勇者收集三个魔杖后与仙子对话，然后从23层的花门进入地下层杀死血影。（若未带着三个权杖与仙子对话，则地下层出现的怪物是魔龙，正常情况下无法击败）打败血影后，勇者救出公主离开魔塔。 自动生成关卡的思路：
方案一
1，先生成迷宫。
2，摆放楼梯、门、怪物、NPC、商店等。一般每层两个楼梯（可连通），若干层一个商店，若干层一对商人，每层一到两个NPC就可以了，怪物的分布等级低的出现在较低楼层。
3，最后摆放道具。通过摆放奖励道具来控制引导行进路线的复杂性，因为直接往后走是无法通关的，玩家必须按一定顺序获取道具，才能保证最后通关。
4，通过算法给生成的关卡评分，如果不够好则重新生成，或许也可以试试用遗传算法对关卡做一些改动。
如何判别一个关卡的好坏：
1，对关卡进行搜索模拟角色行进路线，路线不能太简单，如果有很多的道具都没有走到直接就通关了，无疑是一个很糟的关卡。
2，路线必须要可以走到底，不能是一个不可完成的关卡。
3，游戏需要一定难度，即玩家如果选择的路线不对会出现卡关，玩家行走的路线要有一定的曲折。
搜索算法：
将生成的地图变成稀疏图的结构以便于搜索。 商店节点要挂上所出售的商品节点，NPC节点要挂上奖励的物品节点。图的变动搜索，根据角色属性不同，图节点之间的路径是否可通也是不断变化的。
//搜索深度太大，和地图上所有非空节点数差不多，有的节点还要访问多次。深度可能达到数千。
//随着步数的深入，可选的下一步节点集迅速增大， 这已经是一个np难题了。 大约是不可能完成的任务，必须做优化处理。
//在访问并清除一个节点时将其邻节点加入前锋边，在搜索失败回退时要同时回退n个邻节点。 //剪枝方法，当节点集中出现奖励物品时，可以优先访问。当商店节点打通后，会优先频繁访问商店。采用分阶段的方法减少搜索深度，避免出现太大的节点集。
方案二，直接算法生成，避免耗时的搜索算法。先生成路径，先考虑最简单的情况，一张大图，没有楼梯口（楼梯口可以最后将大图切割成小的楼层时再添加），也先不考虑npc和商店。
定好主角在每个阶段的属性值，根据属性值是可以倒推出怪物和奖励道具的。
//先生成迷宫大地图，分割路径为一段段的小胡同，计算胡同邻接关系，使用随机算法遍历胡同，根据遍历顺序生成到达胡同末端时的战力值，
//因为战力值的限制，玩家游戏时只能按照遍历顺序清关，否则会卡关失败
//然后根据起点和终点战力值在每条胡同上布置怪物和奖励
另外对于魔塔游戏一般会有一些漏洞。尽快到达商店是玩家主选策略，因为打通商店后玩家就可以及时更新自身属性了，这样优势累积越来越大。到了后期主角属性可以相差很大，平衡已经不太好控制了。所以可以考虑分阶段规整角色属性，使得累积优势变小，重新开始新阶段的关卡。
数据配置：
怪物
id112001,"史莱姆", "monster_01.png",life50, force20, defend1, money1, exp1,	id112002,"中史莱姆", "monster_02.png",life70, force15, defend2, money2, exp1,	id112003,"大史莱姆", "monster_03.png",life200, force35, defend10, money5, exp3,	id112004,"史莱姆王", "monster_04.png",life700, force250, defend125, money32, exp30,	id112005,"小蝙蝠", "monster_05.png",life100, force20, defend5, money3, exp2,	id112006,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f70983f7d134e2b16b2fb8a55f4b536/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe3940e0f7a39ad3209b227549334646/" rel="bookmark">
			敢为人先，华为不惧C语言开发仓颉汉语编程，中文编程迎来新生态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，华为不惜投入巨资开发名为“仓颉（jié）”的中文编程语言，如此执着这是为何？
对此不少网友颇为质疑，毕竟C语言、Java，乃至如日中天的python才是程序员常用的编程语言。
“汉语编程只是玩具”的观点一度充斥在网络，让程序员放下便捷的国外编程语言，转投汉语编程，不符合实际且意义不大。
真的如此吗？
敢为人先，总需有担当 长期以来国内计算机行业工作者总离不开C语言、Java、python，软件开发几乎都建立在英文编程基础上，不得不承认主流编程语言的高效与便捷，可长而久之，国内计算机行业生态将会深度依赖。
拿来主义固然安逸，可国产芯片因技术封锁无法量产的痛，已成为我们难以忘却的伤疤，技术只有牢牢掌握在自己手上才是硬道理。
试想某一天计算机行业生态突发改变，C语言、Java等均不再无条件使用，固化已久的软件行业该何去何从？
华为此次开发“仓颉”中文编程语言，称得上立足现在放眼未来，这是华为的担当。
仓颉造字的神话传说，不少人略有耳闻，华为将这款中文编程语言命名为“仓颉”，颇有寓意。
国外科技巨头，纷纷入局 对于新的编程语言开发，国外巨头从未停止，例如，苹果的Swift、微软低代码语言power platform、谷歌低代码语言Quick Builder。
国外科技企业已然洞察，自主研发的编程语言将会与自身产品更加契合，从而大幅度降低产品开发周期，提高企业工作效率。
国内中文编程，遍地开花 华为此次研发仓颉中文编程语言，不仅是前人种树后人乘凉的事，而且对于构建国内计算机行业生态意义深远，毕竟打造出属于国人自己的、可靠的编程语言，可以降低开发难度，提高开发效率，实属有备无患。
事实上华为并非国内第一家开发中文编程语言，早在20年前，国人吴涛先生就研发出符合中国人思维的中文编程语言——易语言，它易学易用，适合国情，为降低编程门槛与学习难度作出巨大贡献。
时至今日国内中文编程语言发展越发迅猛，可谓遍地开花，硕果累累，相关领域的软件公司接近上百家，其中不乏黑马。
例如，一家名为“云表平台”的纯中文编程语言工具，发展已超10年，通过它搭建的系统已惠及企业超过10万家。
云表平台创建人张军先生，师出金山软件公司，曾深度参与WPS的研发，因而云表平台的操作与WPS一样简单，纯中文的搭建界面，会画表格，即可完成软件的开发。
传统开发语言Java与python诚然很优秀，不过云表平台作为国人自行开发的中文编程语言，更懂得国人操作思维，它已完全摆脱代码的枷锁，实现“纯中文”的软件开发方式，快学易上手，让0编程基础的小白，只需拖拉拽即可完成工作中常用软件的搭建，例如，OA、CRM、进销存、工资管理系统等。
一门优秀的中文编程语言，首先是开放与包容的，云表丰富的OpenApi接口，让它可以与金蝶、钉钉、企业微信等第三方软件进行对接，实现互惠共赢。
可喜的是，云表平台不仅能搭建轻量软件，它还能搭建出复杂的工业级应用，已开发的系统包括，ERP、WMS、MES、PLM、财务管理系统、工程管理系统等，国内不少企业已在普及使用云表中文编程语言，例如，中铁集团、许继电气、恒逸集团、诚威科技、风华集团等龙头企业都在深度使用。
从易语言的开拓到华为仓颉、云表平台的遍地开花，中文编程语言在不断优化，相比如火如荼的Java、C语言，汉语编程可能只是星星之火，对此我们需要给予更多支持与理解，有担当才能敢为人先，期待出现更多优秀汉语编程语言，让我们为改善国内软件生态的前行者，点赞与转发！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e64fd2a3aa4d0dbf930a9890084806/" rel="bookmark">
			亚马逊云科技助力Grepay构建安全稳定的全球支付通道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Grepay作为一家全球数字支付解决方案服务商，一直致力于为跨境外贸、数字游戏、教育培训等互联网B2B(C)商业模式提供一站式支付解决方案及相关增值服务内容。目前已为全球超过510家商户提供了优质的跨境支付服务，每日处理订单量超20万笔。
Grepay通过提供安全、合规、对开发人员友好的API轻松集成与聚合全球各国的本地化支付，为中国企业海外项目提供轻松便捷的全球支付解决方案。面对持续攀升的交易量和越来越激烈的市场竞争，Grepay需要持续优化全球支付解决方案，构建一个具备全球化服务能力的支付平台，但这对一个初创企业来说需要突破多重技术挑战：
● 如何构建一个覆盖全球不同区域市场的技术底座，灵活高效进行全球业务部署？
● 如何满足不同的国家和地区的行业标准化的合规需求以及本地化的数据驻留与隐私保护规定？
● 如何有效抵御支付中可能出现的各类欺诈性交易，提升交易的安全性，降低交易风险？
为提供更可靠安全的全球支付体系，提升自身的行业竞争力，Grepay选择与亚马逊云科技合作，并在亚马逊云科技合作伙伴网宿科技的帮助下，快速完成了多项云上业务部署：
● 构建符合金融行业监管要求的可信赖云服务
亚马逊云科技拥有PCI DSS 1级服务提供商认证，能够以安全、合规的方式存储、处理或传输数据，保证Grepay的安全管理计划能全面符合行业标准。
● 基础设施全球分布，低延迟高安全
亚马逊云科技在全球26个区域拥有84个可用区，并且提供了一致的技术架构和服务。借助于广泛覆盖的基础设施以及从Amazon EC2计算实例到Amazon Relational Database Service (Amazon RDS)数据库服务、机器学习与大数据风控的相关服务，Grepay将支付业务部署在离客户更近的区域，既满足各国对于监管与数据驻留的要求，又以更低的网络延迟帮助商户快速处理支付交易。
● 专业的技术支持与服务
网宿科技在CDN、安全与性能、云原生及云服务领域具有丰富的客户服务经验，在Grepay支付业务的云上部署与海外发展中能够提供完备的技术支持。
Grepay在网宿科技的帮助下，快速在亚马逊云科技平台上构建了全球数字支付解决方案，帮助电子商务、游戏、社交、金融服务等多个领域的客户实现全球跨币种收款，也给企业带来了多方面的成效：
● 海外业务的快速扩张
亚马逊云科技遍布全球的云基础设施所提供的区域覆盖能力，让Grepay将支付业务拓展至印度、阿联酋、巴基斯坦、美国、墨西哥与巴西等国家。
● 弹性算力，提升业务处理能力
亚马逊云科技强大的弹性算力支撑，让Grepay每天可轻松处理来自全球的20余万笔订单，为超过500家的注册商的跨境业务提供本地化支付和收款体验。
● 高安全性，让支付更安心
通过整合亚马逊云科技所提供的Amazon SageMaker机器学习与Amazon Kinesis流数据分析服务，Grepay也提升了支付平台对于欺诈和非法交易的识别能力，从而更有效的防止非法交易给支付平台和商户造成的损失，保护消费者权益并增强用户对于Grepay的信赖。
● 持续创新，成为用户的运营好帮手
在网宿科技的技术团队支持下，Grepay将支付平台中融合了更多的托管服务，持续优化业务，让用户借助订单查询、数据导出、数据概览等功能，为客户快速分析当前的支付趋势和用户行为，以便及时调整销售策略，提高收益。
未来，Grepay还将与亚马逊云科技和网宿科技开展更加深入的合作，在市场资源、技术经验、解决方案等多领域共享资源，不断打磨金融科技产品与服务，为更多的中国企业出海提供技术赋能，帮助中国企业打开全球市场。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133336c29d667b9e689b0ffee5c7529c/" rel="bookmark">
			MapReduce 论文阅读笔记 MapReduce 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文：
MapReduce: Simplified Data Processing on Large Clusters
Jeffrey Dean and Sanjay Ghemawat
Google
https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf
MapReduce 是一种分布式系统中处理大数据方法。他提出是在 2004， jeff dean 和 Sanjay Ghemawat 的作品，和 GFS、BigTable 并列 Google 分布式系统的三驾马车。后面，基于 mapreduce 的框架由于种种问题已经很少使用了（2014 Google I/O），但是 map reduce 的思想（感觉也是人很自然想到的分治思想）不过时。
mapreduce 框架淘汰的原因是，对于简单的操作，map reduce 的严格框架方便了下层，但是上层写协同的处理时候必须很复杂。而底层的实现上仍然涉及很多部署和运维、整体的性能优化等问题，并不是写一个 map + reduce 函数就能成功了。结果就是，反而这层隔离抽象又好像没有了，仍然需要技术团队根据不同的业务数据特征折腾不同的性能优化和配置（属于是超参数）。
未来的层次抽象可能希望集中上层业务注意力到写 OLAP 的 DML 上，分布式的 HTAP、OLAP 数据库负责搞定下层的各种脏活（spanner/f1）？
整体论文看了我好久，而且最后感觉我自己的笔记好像也没做到什么。但是在读论文之前看别人的笔记或者简略的话我又感觉不知道他在说什么，缺失了某种上下文信息。
看完论文之后再看别人的笔记，好像的确是这么回事，而且比我打的精美多了。
看来看的细节的东西确实有用，变成某种常识了。但是又不能直接一上来就给你丢几个概念，这样是去掉了分析法的过程，只剩下综合法不知道他怎么来的，最近用不同的材料复习数学也有同感。
以后可以直接找别人写好的笔记，自己只是读一遍过理解细节之后，这样效率可能高一点，因为其实笔记也做不了什么，反而分心，利用前人的笔记其实均摊下来别人写笔记的花费也分摊了。不过对一些细节没弄懂的地方，思考和阅读其他资料的过程是不能丢掉的了。
更新：后来想了一下，原论文没有 motivation 和 background，所以以问题的形式存在的笔记效果会好一点，因为这样强迫你去回答要点，而不是含糊的暧昧跳过。所以回来补充以下关键的一些点。我的一句话总结就是，map - shuffle - reduce = select - group by - aggregation。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/133336c29d667b9e689b0ffee5c7529c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6920b9c8329ebb4fb8d80bacd69472a4/" rel="bookmark">
			Unity可视化编程Visual Scripting学习笔记4：跟随鼠标旋转（2D）（封装方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总览
主脚本图（跟随鼠标旋转脚本图）；
计算角度脚本图。
1.获取当前鼠标坐标并转化为世界坐标。
2.获取对象的坐标。
3.有了两者坐标后我们便可以计算对象旋转多少度时可以面向鼠标位置，这时我们来创建一个新的脚本图来进行计算工作。
4.我们输入的参数是两个坐标，所以添加两个Data Inputs命名为Pos1和Pos2；我们需要其输出一个角度，所以添加一个Data Outputs命名为Angle；
Trigget Inputs和Trigget Outputs就是下图中的两个绿色箭头（具体作用还没研究好）；
用到的公式大家可以倒推一下，就是用了反三角函数。
5.计算角度脚本图画好后我们去主脚本图中调用
6.设置对象以Z轴为轴旋转计算出的角度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2b409e13a28f4f780bbd2ad2487e1f1/" rel="bookmark">
			接口自动化之各种某盘的资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		都是永久链接，要的直接下。
jmeter 用作处理json数据的json.jar包
链接: https://pan.baidu.com/s/1kV8lBd41GJu8-7LxODgufA?pwd=iztm 提取码: iztm
fiddler安装包及导出为jmeter格式的插件.zip
链接: https://pan.baidu.com/s/1EhbI3u3ATZiS5r79vqJ2Mg?pwd=94z9 提取码: 94z9
ant安装包
链接: https://pan.baidu.com/s/1ONq65L33OlTOK4qBtSamHQ?pwd=7yvg 提取码: 7yvg
jmeter 安装包
链接: https://pan.baidu.com/s/176lc5FmpSX-ekfPY-jdgUg?pwd=bwz8 提取码: bwz8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b8527f70e7b9a4082591863f95b020/" rel="bookmark">
			Unity可视化编程Visual Scripting学习笔记1：添加ScriptGraph（挂脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		窗口位置
创建Script Graph 就相当于创建脚本
给物体添加Script Graph 相当于挂脚本
1、给物体添加Script Machine组件
2、将创建的Script Graph拖入Script Machine组件的Graph栏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5badfc704f55d0f2a499d6b09feb881/" rel="bookmark">
			Vue 路由的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 路由的理解路由的基本使用一些注意点嵌套路由 路由的理解 生活中的路由：
vue-router的理解：
vue 的一个插件库，专门用来实现SPA应用(single page web application)
对SPA应用的理解：
1.单页Web应用(single page web application，SPA)
2.整个应用只有一个完整的页面
3.点击页面中的导航链接不会刷新页面，只会做页面的局部更新
4.数据需要通过ajax请求获取
什么是路由?
1.—个路由就是一组映射关系 (key - value)
2. key 为路径, value 可能是 function 或 component
路由分类
1.后端路由：
1)理解：value 是 function，用于处理客户端提交的请求
2)工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据
2.前端路由：
1)理解：value 是 component，用于展示页面内容
2)工作过程：当浏览器的路径改变时，对应的组件就会显示
路由的基本使用 我们需要完成一个功能，点击左侧导航切换右侧内容，页面如下：
前提：布局编写
我们之前在 public 下新建了 css 文件夹，并放入了 bootstrap.css，并在 index.html 中进行了引入：
&lt;link rel="stylesheet" href="&lt;%= BASE_URL %&gt;css/bootstrap.css"&gt; 在 App.vue 中编写布局：
&lt;template&gt; &lt;div&gt; &lt;div class="row"&gt; &lt;div class="col-xs-offset-2 col-xs-8"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5badfc704f55d0f2a499d6b09feb881/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c7c7c45cd3a5a8f9a54ec23d80d38db/" rel="bookmark">
			TypeScript 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeScript 学习笔记 参考：王红元老师的Vue3课程 TypeScript引入 JavaScript缺点：没有类型检测 // 当前foo函数, 在被其他地方调用时, 没有做任何的参数校验 // 1&gt; 没有对类型进行校验 // 2&gt; 没有对是否传入参数进行校验 function foo(message) { if (message) { console.log(message.length); } } foo("Hello World"); foo("你好啊,李银河"); foo(123) foo() // 永远执行不到 console.log("渲染界面成千上万行的JavaScript代码需要执行, 去渲染界面") TypeScript是拥有类型的JavaScript超集，它可以编译成普通、干净、完整的JavaScript代码。不仅仅增加了类型约束，而且包括一些语法的扩展，比如枚举类型（Enum）、元组类型（Tuple）等。官网：TypeScript: JavaScript With Syntax For Types.安装环境： # 安装命令 npm install typescript -g # 查看版本 tsc --version 示例： let message: string = 'hello typescript' function foo(payload: string) { console.log(payload.length) } // foo(123) //报错 foo("aaa") export { } //ts默认全局作用域，加上export说明这是个模块 使用ts-node 安装ts-node npm install ts-node -g 另外ts-node需要依赖 tslib 和 @types/node 两个包： npm install tslib @types/node -g 可以直接通过 ts-node 来运行TypeScript的代码： ts-node math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c7c7c45cd3a5a8f9a54ec23d80d38db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e93a3238f2fdb4d48a2a01aaa95bf7/" rel="bookmark">
			如何正确地计算神经网络模型的推理时间【含代码，以pytorch为例】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言原理异步执行GPU预热解决方法 代码参考资料 前言 无论是做学术还是做工程项目，实际推理时间(inference time)总是我们衡量一个模型好坏的重要参照指标。目前已经也有很多博客在介绍如何计算一个神经网络模型的推理时间，但是写得都比较"粗糙"，在看了一些国内外的博客后，对这个问题有了一些总结性的经验，故写下这篇博客。
原理 某些博客直接将python程序的测速方式用到神经网络模型的测速中来（使用time.time计时），这忽略了深度学习问题的特殊性（在GPU上进行推理）。直接使用这种方式进行测速会忽略两个关键问题，导致测出来的速度不准：① 异步执行；② GPU预热。
下文中，我们先介绍不同的问题以及其原理，然后提出解决办法。
异步执行 在深度学习模型推理过程中，我们通常会将模型部署在GPU上，运行过程会涉及到cpu与gpu两种不同设备，而目前深度学习基本都是采用异步执行的方式（具体来说，就是在GPU调用某个函数时，它会在指定的设备上进行排队，不会占用其他的设备资源，从而完成并行计算）。
图片来自参考链接[1]
这种机制能够加快模型的推理速度，但这会使得计算推理时间变得麻烦，因为通常python程序使用time进行计时，这是在CPU端运行的，有可能存在GPU端的程序还没有运行完，但这边已经停止这一轮次的计时了，导致最终得到的结果不准确。
GPU预热 目前的GPU设备在不同的状态下会启用不同的工作模式，如果一台GPU在未使用的情况下，会处于低功耗状态（会关闭许多硬件，包括内存子系统、内部子系统、计算核等）。
如果此时将模型部署在上面并进行推理时，会触发GPU的一系列初始化，这会浪费较多的时间在GPU预热阶段，导致时间测量不准确。计算出来的推理速度也无法反映真正使用场景下的速度(持续模式)。
解决方法 为了解决异步执行的问题，使用pytorch自带的torch.cuda.synchronize()，它会将异步模式转换成同步模式，只有在当前轮次的GPU推理完成之后才停止计时，并且使用torch.cuda.Event来跟踪GPU程序并进行更新；
torch.cuda.Event和torch.cuda.synchronize()的官方文档说明
为了解决GPU预热的问题，我们可以在进行实际测量前运行一些示例，完成GPU的预热。
代码 完整测速代码如下所示，以torchvision自带的resnet101为例。
import torch from torchvision.models.resnet import resnet101 iterations = 300 # 重复计算的轮次 model = resnet101() device = torch.device("cuda:0") model.to(device) random_input = torch.randn(1, 3, 224, 224).to(device) starter, ender = torch.cuda.Event(enable_timing=True), torch.cuda.Event(enable_timing=True) # GPU预热 for _ in range(50): _ = model(random_input) # 测速 times = torch.zeros(iterations) # 存储每轮iteration的时间 with torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10e93a3238f2fdb4d48a2a01aaa95bf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae259da605d9203d5fe2e06adeb93b1/" rel="bookmark">
			AMBA5 AXI和ACE协议技术规范中文版-第A4章 事务属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第A4章 事务属性 本章描述了决定一个事务应该如何被系统组件，如缓存、缓冲区和内存控制器处理的属性。它包括以下部分：
在A4-62页的事务类型和属性在A4-63页的AXI3内存属性信号在A4-64页的对AXI4内存属性信号的更改在A4-69页的内存类型在A4-73页的内存不匹配属性在A4-74页的事务缓冲区在A4-75页的访问权限在A4-76页的遗留问题在A4-77页的用例 A4.1 事务类型和属性 分为以下两种：
内存slave
内存slave需要正确的处理所有的事务类型。
外设slave
外设slave有一个实现定义IMPLEMENTATION DEFINED的访问方法。通常，访问方法是在组件数据表中定义的，该数据表描述了slave正确处理的事务类型。
根据协议，任何对不属于实现定义IMPLEMENTATION DEFINED访问方法的外设slave访问都必须完成。但是，当进行这样的访问时，并不要求外设slave继续正确地操作。它只需要以符合协议的方式继续完成进一步的事务。
注意
为了防止系统死锁，需要兼容所有事务类型的完成，但是，不需要外设slave继续正确操作。因为外设slave只需要为定义的访问方法正确工作，它可以有一个简化的接口信号集。
AXI协议定义了一组支持内存和外围设备slave的事务属性。ARCACHE和AWCACHE信号指定事务属性。他们控制:事务在系统中如何处理任何系统级缓存如何处理事务
在此规范中，术语AxCACHE统指ARCHCHE和AWCHACHE。
以下部分描述了事务属性：在A4-63页的AXI3内存属性信号在A4-64页的对AXI4内存属性信号的更改 A4.2 AXI3 内存属性信号 在AXI3中，AxCACHE[3:0]信号指定了事务的缓冲，缓存和分配属性。
AxCACHE编码如表A4-1所示。
AxCACHE[0], Bufferable (B) bit
当此bit生效时，互联或任何组件可以延迟任意个周期数到达它最终的目的地。
注意
通常，缓冲属性只与写有关。
AxCACHE[1], Cacheable © bit
当此bit无效时，禁止事务的分配。
当此bit生效时：
允许事务的分配。RA和WA提供额外的提示信息。在最终目的地事务的特征不必与源头事务特征相匹配。
对写，这意味着几个不同的写可以被合并在一起。
对于读取，这意味着可以预取某个位置的内容，或者可以将单个读取的值用于多个读取事务。
AxCACHE[2], Read-Allocate (RA) bit
当此bit生效时，推荐但是不强制事务的读分配。如果C bit无效，RA bit必须不能生效。
AxCACHE[3], Write-Allocate (WA) bit
当此bit生效时，推荐但是不强制事务的写分配。如果C bit 无效，WA bit必须不能生效。 A4.3 AXI4对内存属性信号的更改 AXI4对AXI3内存属性信号做了以下更改:
AxCACHE[1]bit被重新命名为可修改的bit。排序需求是为不可修改事务定义的。读分配和写分配的含义被更新。 A4.3.1 AxCACHE[1],可修改的 在AXI中，AxCACHE[1] bit是可修改位。当为高时，可修改表明事务的特征是可修改的。当可修改位为低时，事务时不可修改的。
注意
AxCACHE[1]位从Cacheable位重命名为Modifiable位，以便更好地描述所需的功能。实际功能没有改变。
以下部分描述了可修改事务和不可修改事务的属性。
不可修改的事务
通过设定AxCACHE[1]为低，表示不可修改的事务。
不可修改事务必须不能被拆分为多个事务或与其他事务合并。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ae259da605d9203d5fe2e06adeb93b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995dbe99782a87cca9cb1c77bd202b7c/" rel="bookmark">
			利用idea将外部的jar包导入到自己的工程中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用idea将外部的jar包导入到自己的工程中 首先我我们要知道自己想要导入的的jar包存放的位置，一般建议将这些包都存放在一个文件夹中以便使用。
确定好文件的位置之后我们就要进入idea进行更改。
进入idea之后，我们点开左上角的File，然后选择Project Structure (或者使用快捷键 ：Ctrl+Alt+Shift+s)。
之后会进入到下面这个界面，我们选择Proj Settings下面的Modules。
进入到Modules页面后，点击右上角的绿色的加号。
然后点击1 JARs or dire或者2 Library，进行添加
然后找到自己的jar所在的位置，选择之后点ok
确定之后在Moudels界面将刚添加进来的那个勾到，然后点Apply，再点击Ok即可。
这时我们就将外部的jar包导入成功了。
在类中很明显已经可以调用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0260e698243332f6770453794e9a57a0/" rel="bookmark">
			Windows卓越性能概念以及如何打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows卓越性能 什么是卓越性能？ （1）. 顾名思义“卓越性能就是指微软为了更好的让配置和系统结合达到高性能状态，推出的“卓越性能模式”，如果你喜欢玩游戏，那么这个模式可以帮助到将CPU一直保持鸡血状态。但是卓越性能会增加供电负担和更多的散热
2 除了卓越性能还有什么其他电源计划？
1 打开控制面板
2.点击硬件和声音
3.点击电源选项
4.隐藏的附加计划即可发现视窗（Windows）提供的电源计划
正文：如何开启卓越性能 1.进入win10系统点击左下方搜索（如果没有搜索那就按键盘上的WIN键和S）“powershell“，鼠标右击”Windows Powershell“以管理员权限运行。
2.Win11：右键开始键点击Windows终端（管理员） 如图所示：
3.然后会弹出一个窗口如图所示：
4.然后输入以下代码：
powercfg -duplicatescheme e9a42b02-d5df-448d-aa00-03f14749eb61
5.输入完成后power shell 会弹出这个窗口：
如果显示这个就代表已经成功开启了卓越性能
2. 设置卓越性能 和上文打开控制面板一样如图所示：
LAST：最后在重启一下电脑就好了
感谢阅读本文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50b1d7cc47f1c77aa6b2124f3ec1b46/" rel="bookmark">
			EXCEL中怎样提取部分特定的文本？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先打开Excel电子表格，并在a1单元格中输入用于演示提取部分特定文字的数据。
在b1单元格中使用函数“MID”进行指定部分文本的提取操作，该函数中的参数分别为源数据单元格，截取位置，截取长度。
3
函数输入完成后，单击回车可以看到已经得到想要的姓名了，同样的使用该函数对其他部分特定文字进行提取即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a017cc0456e50dc4bb18c7c8e17851/" rel="bookmark">
			有效的括号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
示例 1：
输入：s = "()" 输出：true class Solution { public boolean isValid(String s) { int n = s.length(); if(n%2 == 1){ //如果长度不是偶数，那肯定不是有效字符串 return false; } Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); //创建栈 for(int i=0;i&lt;n;i++){ char c = s.charAt(i); //charAt(i) 函数是获取字符串中i位置的字符 if(c=='(' || c =='[' || c=='{'){ //入栈 stack.push(c); }else{ if(stack.isEmpty()){ //为了排除'}('的情况 return false; } char top = stack.pop(); //出栈 if(c ==')' &amp;&amp; top !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6a017cc0456e50dc4bb18c7c8e17851/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/107/">«</a>
	<span class="pagination__item pagination__item--current">108/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/109/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>