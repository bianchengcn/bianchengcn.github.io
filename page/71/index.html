<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b20caaee65963dd4b51baabe72a840/" rel="bookmark">
			【史上最全面esp32教程】oled显示篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言介绍及库下载基础使用引脚的连接使用函数 总结 前言 本节课主要讲的是OLED的基础使用。使用的oled为0.96寸，128*64。
大家的其他型号也是可以用的。
提示：以下是本篇文章正文内容，下面案例可供参考
介绍及库下载 oled的简介：
OLED英文全名Organic Light-Emitting Diode，又可称为「有机发光二极体」或是「有机电雷射显示」。
OLED有着色彩鲜艳、功耗低的优点，它的显示技术具有自发光的特性，透过非常薄的有机材料涂层和玻璃基板，当有电流通过时，这些有机材料就会发光，不仅显示屏幕可视角度大，因为少了LED背光，耗电能够降低。还有一个很大的特性，在荧幕应用设计上，它可以弯曲，因此能够用来设计的范围更广，如曲面屏幕、屏幕下指纹辨识等。
OLED英文全名Organic Light-Emitting Diode，又可称为「有机发光二极体」或是「有机电雷射显示」。
OLED有着色彩鲜艳、功耗低的优点，它的显示技术具有自发光的特性，透过非常薄的有机材料涂层和玻璃基板，当有电流通过时，这些有机材料就会发光，不仅显示屏幕可视角度大，因为少了LED背光，耗电能够降低。还有一个很大的特性，在荧幕应用设计上，它可以弯曲，因此能够用来设计的范围更广，如曲面屏幕、屏幕下指纹辨识等。
闪屏:
因OLED的调光方式，导致可能出现闪屏的现象，闪屏指的是屏幕以低频率闪烁，虽然视觉上看不出闪烁，看久了可能会产生视觉疲劳的现象，但这部分因人而异，有些人感觉不出来。
esp oled下载链接
提取码：0000
下载完后，进入arduino—&gt;项目—&gt;包含库-----&gt;添加zip库，把上面的放入，不需要解压。
基础使用 引脚的连接 我们可以看到OLED有4个，1个GND,1个VCC,还有最重要的SDA和SCL，SDA和SCL就是用来传输数据的，在这里，我的SDA和SCL为19，18pin脚
使用函数 使用oled需要包含如下头文件：
#include &lt;Wire.h&gt; #include "SSD1306Wire.h" oled对象的定义：
//OLED引脚定义 #define SDA 19 #define SCL 18 SSD1306Wire display(0x3c, SDA, SCL); 初始化oled：
display.init(); 垂直翻转屏幕(把屏幕显示倒转180°)：
display.flipScreenVertically(); 设置字体大小：
display.setFont(ArialMT_Plain_24);//最后的数字是字体的大小 显示字符串:
display.drawString(x, y, "Hello World"); 在每次绘制完后都要调用显示函数：
display.display(); 然后就会显示到屏幕上了。
显示hello world在屏幕上：
display.init();//初始化UI display.flipScreenVertically();//垂直翻转屏幕设置 display.setFont(ArialMT_Plain_24);//设置字体大小 display.drawString(0, 0, "Hello World");//显示 display.display();//将缓存数据写入到显示器 设置字符串对齐：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b20caaee65963dd4b51baabe72a840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88eb70373e66d41bde6b760647194c29/" rel="bookmark">
			vue自定义指令——input输入类型限制（数字、浮点、整数、英文等），解决中文输入法双向绑定失效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 版本更新 前言一、基本步骤二、代码实现1.input.js2.install.js(注册文件)3.全局注册4.页面调用 三、使用说明四、npm安装指令插件 版本更新 2023.3.23——修复浮点型输入0问题
前言 实现一个vue自定义指令——输入框（input,el-input）输入内容类型限制，解决中文输入法双向绑定失效问题，多种类型支持，数字类型，浮点类型、英文类型、整数类型、四则运算等
一、基本步骤 以element,el-input组件为例：
1.在自定义指钩子函数bind或inserted通过querySelector找到输入框（input标签）dom对象
2.监听input的onkeyup事件，获取输入值，校验并替换输入值，限制输入类型，重新给输入框设值
3.通过compositionstart和compositionend事件设置锁定标识，解决中文输入法双向绑定失效问题
二、代码实现 1.input.js 代码如下：
export default { bind(el, binding, vnode) { const input = el.querySelector('.el-input__inner') || el.querySelector('.el-textarea__inner') || el; input.addEventListener('compositionstart', () =&gt; { vnode.locking = true//解决中文输入双向绑定失效 }) input.addEventListener('compositionend', () =&gt; { vnode.locking = false//解决中文输入双向绑定失效 input.dispatchEvent(new Event('input')) }) //输入监听处理 input.onkeyup = () =&gt; { if (vnode.locking) { return; } // v-input.num if (binding.modifiers.num) {//只能输入数字（开头可以多个0） onlyNum(input); } //v-input.num_point else if (binding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88eb70373e66d41bde6b760647194c29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154392f36711cf4947950723a37192cf/" rel="bookmark">
			plt.title()多个变量用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		plt.title('数值是{}字体是{}应用为{}'.format(数值,字体 , 应用 )）
一个{}对应一个变量，变量用，隔开
plt.title('气体为{}截面高度{}m的超压分布图'.format(qiti,ii), fontsize=15) #实例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89790c6fb188c504bb6ecfa4190a0a57/" rel="bookmark">
			MATLAB小实例：读取Excel表格中多个Sheet的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1描述：用MATLAB读取Excel表格中多个Sheet中一组数据。
temp=xlsread('D:\Desktop\shuju.xlsx',1,'C2:C673') %%1为sheet1 问题2描述：用MATLAB读取Excel表格中多个Sheet的数据，并将这些数据按行拆分为多组。
1. 程序 clear clc % 读取一个Excel表格中多个Sheet中的数据 % sheet中的数据按要求分为多组 % Author：凯鲁嘎吉 - 博客园 http://www.cnblogs.com/kailugaji/ num=7; A = cell(num,1); for i=1:num Temp=xlsread('\kailugaji.xlsx',['Sheet', num2str(i)]); % 读取每个Sheet中的数据 % 按个人需求划分数据为两组，如果只提取数据，不分组，写成: A{i}=Temp; A{i, 1}=Temp(1:10, :); % 第一组 A{i, 2}=Temp(11:20, :); % 第二组 end % A{i, j}：第i个Sheet，第j组数据 % 例如，读取第3个Sheet第2组数据： format short A{3, 2} 2.结果 ans = 0.3327 0.2594 0.7826 0.0974 0.6867 0.5687 0.9438 0.5880 0.9188 0.5819 0.5249 0.9542 0.9853 0.5008 0.6961 0.1088 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89790c6fb188c504bb6ecfa4190a0a57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/493c5b069d47e0d77dea600877b4ad63/" rel="bookmark">
			虚拟化技术KVM和XEN概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟化，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。
虚拟化核心思想是提高硬件资源的利用率，通过在系统中加入一个虚拟化层，将下层资源池化后，向上层操作系统提供一个预期一致的服务器硬件环境，并允许不同操作系统的虚拟机互相隔离且并发运行在一台物理机上。
现在主流的虚拟化技术主要是XEN和KVM，而且这两种虚拟化技术都是开源免费的。
目前国内的云厂商基本已经使用KVM虚拟化方案了。KVM拥有更好的生态，更多的开源支持。而XEN诞生时间较长，是目前最成熟的虚拟化技术。
XEN 第一步，XEN的定义。
XEN是Linux下的虚拟化解决方案，XEN的实现是基于支持XEN功能的kernel，在XEN控制下的kernel，称之为Domain 0，使用kernel启动的机器可以使用Qemu软件，虚拟出多个系统。
XEN包含三个基本组件：Hypervisor、Domain 0、Domain U。
其中Hypervisor运行在硬件之上，承载所有的操作系统，提供CPU和内存调度的作用。
Domain 0是管理员，相当于一个大管家，主要负责IO虚拟化。
Domain U则是真正的XEN中的虚拟客户机，而Domain U又分为两类：一类全虚拟客户机，一类半虚拟客户机，后者是运行在经过修改的操作系统之上。
第二步，XEN的特点。
1）XEN无需特殊硬件支持，就能达到高性能的虚拟化。
操作系统必须进行显式地修改（“移植”）才可以在XEN上运行。
2）XEN采用的是混合模型。
从技术上讲，XEN可以装在系统上，也可以装在裸机上。
3）XEN能够控制虚拟机，并给多个客户机分配资源。
XEN是一个外部的Hypervisor程序（虚拟机管理程序）。
4）XEN属于硬件虚拟化（硬件提供结构支持帮助创建虚拟机监视并允许客户机操作系统独立运行）。XEN同时支持全虚拟化和半虚拟化。
全虚拟化：虚拟机完整地模拟了底层硬件，linux系统直接内核支持，不需要对操作系统进行修改。简单来讲，虚拟机以为自己运行在硬件上。
半虚拟化：虚拟机能够感知是运行在Hypervisor（虚拟机器监视器）之中，且为了支持Hypervisor，需要对操作系统进行专门的更改。
5）XEN支持非中断的动态迁移，可以允许动态工作负载平衡和例行维护而几乎没有任何宕机时间。
第三步，XEN的优缺点。
1）优点。
XEN是开源免费的虚拟化软件。
XEN具有更好的处理性能（接近于本地处理）。
XEN支持一个客体虚拟机的数量呈线性增长，可以支持30个以上工作负载同时运行。
XEN是业界最快速、最安全的虚拟化软件。
XEN提供了大量的功能，可以满足各种各样的需求。
XEN出现得更早，也更成熟。
2）缺点。
XEN工作环境的补丁包不能够和Linux内核兼容，因此想要使用XEN，就必须对内核补丁。
XEN版本更新，需要重新编译整个内核，而且稍有不慎，系统就会崩溃。
XEN将会使Linux内核的负担越来越重，因为XEN没有整合到Linux中，XEN只是一个安装在Linux内核下层的产品。
XEN的I/O性能较弱。
XEN操作复杂，因为操作系统必须进行显式地修改（“移植”）才可以在XEN上运行。
XEN维护成本较高，因为XEN必须有个单独的内核，而原有的Linux内核是作为模块加载的。
KVM 第一步，KVM的定义。
KVM是基于Linux环境的全虚拟化的解决方案，是轻量级的虚拟化管理程序模块（模块主要来自Linux内核）。KVM的虚拟化需要硬件支持，如具有VT功能的Intel CPU和具有AMD-V功能的AMD CPU，KVM只能在具有虚拟化支持的CPU上运行。KVM并不是一个完善的模拟器，而只是一个提供虚拟化功能的内核插件，具体的模拟器工作是借助Qemu工具来完成。
KVM主要两个部分组成：KVM驱动和Qemu。
KVM驱动直接被集成到linux系统（Intel-VT或AMD-V）中，主要负责虚拟机创建、CPU和内存的分配等等。
Qemu是用于模拟虚拟机的用户空间组件，提供I/O设备模型，访问外设的途径。
第二步，KVM的特点。
1）KVM需要硬件支持虚拟化扩展（Intel VT 或AMD-V）。
KVM由一个载入时内核模块kvm.ko（提供核心虚拟化基础设施）和一个处理器特殊模块kvm-intel.ko或kvm-amd.ko组成，在上层需要修改过的Qemu。
2）KVM对处理器有着特殊的要求。
# 在安装前检查一下机器是否与KVM兼容
命令：egrep -c '(vmx|svm)' /proc/cpuinfo
若结果返回0，则表示不支持KVM；若结果返回1，则表示支持KVM。
3）KVM没有提供官方的管理界面，但有大量第三方工具可以管理KVM域。
Red Hat的virt-manager（RHEV-M）是使用最多的，它提供了一个简单但高效的图形界面。
4）KVM是Linux内核的一部分, 可使用通常的Linux调度器和内存管理，这使得KVM更小且更容易地使用。KVM在Linux内核内部部署，可以很容易控制虚拟化进程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/493c5b069d47e0d77dea600877b4ad63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b160d21061831ab48a02cee81a9c65/" rel="bookmark">
			通过字符设备驱动分布操作进行6个灯的操作（ioctl）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头文件：
#ifndef __MYLED_H__ #define __MYLED_H__ typedef struct { volatile unsigned int MODER; // 0x00 volatile unsigned int OTYPER; // 0x04 volatile unsigned int OSPEEDR; // 0x08 volatile unsigned int PUPDR; // 0x0C volatile unsigned int IDR; // 0x10 volatile unsigned int ODR; // 0x14 volatile unsigned int BSRR; // 0x18 volatile unsigned int LCKR; // 0x1C volatile unsigned int AFRL; // 0x20 volatile unsigned int AFRH; // 0x24 volatile unsigned int BRR; // 0x28 volatile unsigned int res; volatile unsigned int SECCFGR; // 0x30 }gpio_t; //GPIOE基地址 #define PHY_GPIOE_ADDR 0x50006000 #define PHY_GPIOF_ADDR 0x50007000 #define PHY_GPIOZ_ADDR 0x54004000 //RCC基地址：0x50000A28 #define PHY_RCC_LED1 0x50000A28 #define PHY_RCC_LED4 0x50000210 #define LED_ON _IOW('a',1,int) #define LED_OFF _IOW('a',0,int) enum{ LED1, LED2, LED3, LED4, LED5, LED6, }; #endif 内核文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b160d21061831ab48a02cee81a9c65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee71c17f17f3f1bc8bcc7abdeed5e681/" rel="bookmark">
			MySQL进阶-索引（复习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2. 索引 2.1 索引概述 2.1.1 介绍 索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。
2.1.2 演示 表结构及其数据如下：
假如我们要执行的SQL语句为 ：
select * from user where age = 45; 1). 无索引情况
在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很 低。
2). 有索引情况
如果我们针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建 立一个二叉树的索引结构。
此时我们在进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。
备注： 这里我们只是假设索引的结构是二叉树，介绍一下索引的大概原理，只是一个示意图，并 不是索引的真实结构，索引的真实结构，后面会详细介绍。
2.1.3 特点 优势劣势提高数据检索的效率，降低数据库的IO成本索引列也是要占用空间的。通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE，DELETE时，效率降低。 2.2 索引结构 2.2.1 概述 MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：
索引结构概述B+Tree索引最常见的索引类型，大部分引擎都支持 B+ 树索引Hash索引底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询R-tree(空间索引）空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少Full-text(全文索引)是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES 上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持 情况。
索引InnoDBMyISAMMemoryB+tree索引支持支持支持Hash索引不支持不支持支持R-tree索引不支持支持不支持Full-text5.6版本以后支持支持不支持 注意： 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。
2.2.2 二叉树 假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：
如果主键是顺序插入的，则会形成一个单向链表，结构如下：
所以，如果选择二叉树作为索引结构，会存在以下缺点：
顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢。 此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数 据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:
但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：
大数据量情况下，层级较深，检索速度慢。 所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree，那么什么是 B+Tree呢？在详解B+Tree之前，先来介绍一个B-Tree。
2.2.3 B-Tree B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。 以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee71c17f17f3f1bc8bcc7abdeed5e681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbfa95e2f4f2e7c72995a02bd2ffcd81/" rel="bookmark">
			将visio图粘贴到word，无视觉差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果采用直接复制粘贴方式将绘制的Visio图插入到word中就会导致视觉直观看起来字体大小有差异，尽管在Visio中将字体调整为10.5Pt也会导致视觉上有明显的差异感。
若直接截图粘贴到word会导致无法从word里修改。
采取先复制整体的visio图，然后点击word左上角粘贴的下三角
点击选择性粘贴
会出现如下界面
选择 Microsoft Visio绘图对象，就可以将visio图复制到word中啦，而且会比直接复制粘贴的效果好很多哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/390f6b38a23e1e4649ee0e12707772f2/" rel="bookmark">
			MyBatis使用＜collection＞实现一对多关联后映射成一个List＜String＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现有两张表
数据源表：data_source（主键data_source_id）
数据源品牌标签表：data_source_brand （data_source_id, brand）
两张表是一对多的关系，一个数据源可以有多个品牌标签
期望结果： 查询一个数据源的时候，以List&lt;String&gt;的形式带出品牌标签brand
{ "updateBy": "admin", "updateTime": "2023-03-22 10:21:39", "dataSourceId": 15, "brandList": [ "CD01", "CD02" ] } MyBatis配置如下：
&lt;resultMap type="DataSource" id="DataSourceResult"&gt; &lt;id property="dataSourceId" column="data_source_id" /&gt; &lt;result property="updateBy" column="update_by" /&gt; &lt;result property="updateTime" column="update_time" /&gt; &lt;collection property="brandList" ofType="java.lang.String" javaType="list"&gt; &lt;result column="sub_brand" /&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;sql id="selectDataSourceVo"&gt; select s.data_source_id, s.update_by, s.update_time, c.brand as sub_brand from data_source s left join data_source_brand c on s.data_source_id = c.data_source_id &lt;/sql&gt; &lt;select id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/390f6b38a23e1e4649ee0e12707772f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35259e3c07b4732aa5bfbcaf778a0833/" rel="bookmark">
			VS2019安装与基本使用（c、c&#43;&#43;开发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步、下载VS2019 （Visual Studio: 面向软件开发人员和 Teams 的 IDE 和代码编辑器）
网盘地址：链接：https://pan.baidu.com/s/1ItOhtXOvHf2WySUBXpIWvQ 提取码：09c6 第二步、双击.exe文件进行安装 选择使用c++的桌面开发：
更改位置：选择别的盘，不要安装在c盘
点击安装：
第三步、启动VS2019 不会自动创建图标，在搜索栏查找即可，也可发送到桌面。
第一次进入，会有一个主题选择，笔者选择的是黑色主题，如下：
点击创建新项目：
选择空项目或者控制台应用（非空），点击下一步：
建议勾选解决方案和项目放在同一目录中（可选项），点击创建：
项目文件说明（.vc是隐藏文件）： 1、.sln文件：工程文件。可以用VS直接打开；
2、.vcxproj：项目文件。
其他两个是户配置文件
第四步、创建c或c++程序 运行第一个c程序，hello_world:
VS2019一些基本操作： 1、调节字体大小：ctrl+滚轮
2、选择字体或颜色：
工具---&gt;选项----&gt;字体和颜色
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49306d821f4a96de9189990ebff34516/" rel="bookmark">
			Web开发课程实验（一）：使用ASP的基本数据交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验内容：asp与前端html的基本数据交互。
具体要求：利用windows自带的IIS作服务器，写一个html，再写一个asp，通过两种方式提交数据到asp并展示（html表单submit和ajax提交）。
吐槽一下：笔者基本处于零基础状态，此前只有一点点用nodejs写实验作业的经历，这个东西摸索了半天才做完。在网上搜了不少asp教程看得云里雾里，上来就抛各种名词，看了俩小时没明白最基本的疑问，那就是这个东西整体是长什么样的，在我期望进行的操作中发生了什么事情，笔者认为这是作为小白（暂时的）首先要弄清楚的。当然跟着一个教程慢慢来是肯定会明白的啦，不过最好能让这个“明白”发生在开始的时候。
前置：html, javascript, jQuery。纯前端部分没什么门槛。
0.整体结构 好，先来说一下上面的疑问。
html文件干嘛的？展示出来的实际页面。
asp文件干嘛的？后端脚本，可以生成html。
这个东西它做出来长啥样呢？就俩文件，一个是html，上面是表单，用户可以输入信息然后点上面的提交按钮；一个是asp脚本，它在后端运行，当接收到前端的数据后它就能搓出来（专业一点叫渲染）一个html文件发过去，我们说的所谓asp页面，其实是asp生成的html，这个生成过程是“动态”的，而不是说你在浏览器访问xxx.asp的时候这个页面能实时动态变化，你看到的其实是静态的已经固定的html页面。
咱们在服务器上配置要运行的项目，然后写好的asp相当于一直在后台运行着。
现在用户输入了我们的服务器地址，服务器给他一个默认页面（可以在IIS中设置默认文件），这个就是咱们的register.html。
用户输入了注册信息，然后点了提交。
在服务器上保持运行的asp脚本接到数据了，asp里面的代码运行一下，搓出来一个html发了过去。于是用户那边看到了反馈回来的由asp生成的html。
1.html文件 html的部分懒得细说，不明白的直接去w3school的教程看看，熟悉各种元素就手到擒来了。
稍微说一下head里面js的部分：
第7行是引用外部的jQuery.js，不然后面没法用jQuery。check_data是校验合法性用的，校验不通过就return一个false回来sendinf是提交用的函数，跟button的点击事件绑定，先check_data，通过了再提交sendinf_ajax是拿ajax提交，上面的是拿form表单自带的submit方法提交ajax不会主动给你跳转，要手动把后端返回的东西拿过来通过document.write覆写当前页面，也就是success里的部分 直接放代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;注册页&lt;/title&gt; &lt;script src="https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js"&gt;&lt;/script&gt; &lt;style&gt; form { margin-left: 10px; margin-top: 10px; } &lt;/style&gt; &lt;script&gt; function check_data() { let usn = $("#user").val(); let pwd = $("#pwd").val(); if (usn.length&gt;20) { alert("用户名长度不得超过20"); return false; } if (/\W/.test(pwd)) { alert("密码不得包含字母、数字及下划线以外的字符"); return false; } if (pwd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49306d821f4a96de9189990ebff34516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4593756e9e9254ac5324a3cfe492e0/" rel="bookmark">
			reGeorg正向代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理
reGeorg主要是把内网服务器的端口通过 http/https 隧道转发到本机，形成一个隧道。用于目标服务器在内网或做了端口策略的情况下连接目标服务器内部开放端口。它利用 webshell 建立一个 socks 代理进行内网穿透，服务器必须支持 aspx、php 或 jsp 这些 web 程序中的一种。
reGeorg由服务端和客户端两部分组成。服务端有php、aspx、asph、jsp、node.js等多个版本，客户端则由python编写。其工作原理可简单描述为python客户端在本地监听一个端口，提供socks服务，并将数据通过http/https协议发送到服务端上，并从服务端上用socket实现转发
我们所使用的是客户端，在目标服务器上getshell后，上传的是对应的服务端。
下载地址
GitHub - sensepost/reGeorg: The successor to reDuh, pwn a bastion webserver and create SOCKS proxies through the DMZ. Pivot and pwn.
测试环境
攻击机:
python2.7(reGeorg不支持python3)
安装对应的库 pip install urllib3
跳板机: php 5.2.17
开始测试
环境配置好之后，使用reGeorg-master&gt;python reGeorgSocksProxy.py -h查看能否运行
接下来需要在跳板机上面安装对应的服务端，上传tunnel.php或tunnel.nosocket.php
由于已经成功getshell并且跳板机的环境是php，因此可以直接上传服务端
访问跳板机，出现这一行字说明已经成功上传并且解析，然后使用客户端去连接服务端，并且建立一个提供socks代理的端口
这里设置的端口就是提供socks服务的端口，ip是我们攻击机的ip吗，下面出现红框的内容就是说明连接成功
然后我们使用代理工具去连接
SocksCap64
然后点击这里进行测试连接，连接成功
如果想让其他工具使用代理就在这里面添加
Proxifier
添加代理服务器
配置代理规则
添加代理规则 应用程序：选择需要使用socks代理的程序，这里指定的是超级弱口令工具exe，其他程序请自行浏览添加 目标主机：如有内网环境，可选择添加其他网卡网段如 192.168.52.*，默认为全部 目标端口：如有需要，可以指定，默认为任意，随机选择端口 动作：proxy socks5 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d4593756e9e9254ac5324a3cfe492e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d822c44ca4194a5e0cce27c97b434895/" rel="bookmark">
			解决Navicat无法连接数据库 数据库无法外联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在物理机中的Navicat连接虚拟机数据库时，出现如下情况：
排除物理机与虚拟机相互连通，解决办法为：
找到路径C:\phpstudy_pro\Extensions\MySQL5.7.26下的my.ini 添加
bind-address=0.0.0.0
在C:\phpstudy_pro\Extensions\MySQL5.7.26\bin目录下打开终端运行mysql.exe账户名密码在phpstudy数据库中有显示
切换到MySQL数据库并且查询user，host
mysql&gt;use mysql; mysql&gt;select user,host from user; 如果没有找到host的值为百分号（即结果如上图），那么执行如下语句并刷新
mysql&gt;update user set host='%' where user='root'; mysql&gt;flush privileges; 赋予外联主机使用用户名 root 密码root@123对数据库进行访问的权力
mysql&gt;grant all privileges on *.* to 'root' @'%' identified by 'root@123' with grant option; mysql&gt;flush privileges; 重新查询user，host看到host中有%即成功
在物理机的navicat中重新连接，显示连接成功，大功告成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d4e419af445c06c85e5b59b7e268ac/" rel="bookmark">
			MySQL精通知识点笔记-高级篇-索引的数据结构与 InnoDB的数据存储结构(物理)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引的本质：索引是数据结构。你可以简单理解为排好序的快速查找数据结构，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。
优点
数据库的IO成本数据的唯一性以 加速表和表之间的连接减少查询中分组和排序的时间 缺点
创建索引和维护索引要 耗费时间要占 磁盘空间会 降低更新表的速度 1 索引设计思路(InnoDB——B+树) 首先建立一个普通的表，表中存储数据
mysql&gt; CREATE TABLE index_demo( -&gt; c1 INT, -&gt; c2 INT, -&gt; c3 CHAR(1), -&gt; PRIMARY KEY(c1) -&gt; ) ROW_FORMAT = Compact; 用一个简单的结构存储每一行数据
record_type ：记录头信息的一项属性，表示记录的类型，
0 表示普通记录、2 表示最小记录、3 表示最大记录、1 表示目录行，下面会用到 一个数据库由多个页组成，每个页内的数据按照主键大小排序，就会形成如图
如果数据库很大，页就会很多，我们建立一个标志每个页的目录项，就会方便检索到目标页。查询的时候先查询目录项，再查询具体页的内容
key：所指向的页的最小值page_no：页的具体序号 页特别多的时候，就需要对目录项进行存储，存储结构使用与存储数据一致的结构，方便存储与管理
随着页数增加，目录页也变多，为了索引快一点，我们同样需要形成索引目录页的目录页 我们形成的这样的数据结构，称为B+树
为什么数据存储的B+树一般不超过4层/为什么查询一般不超过四次读取？
假设一个页只能存储一百条记录
如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。
如果B+树有2层，最多能存放 1000×100=10,0000 条记录。
如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。
如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。这个数量级已经相当多，绝大多数情况下都已经够用
2 常见索引分类 索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或者辅助索引。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97d4e419af445c06c85e5b59b7e268ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb91f34b10ab6adfe704db0de4888ae/" rel="bookmark">
			java后台给指定接口发送json数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口方法：
public static String post(JSONObject json, String path) { String result = ""; try { //创建httpclient对象 CloseableHttpClient client = HttpClients.createDefault(); //创建post方式请求对象 HttpPost post = new HttpPost(path); //设置请求头 post.setHeader("Content-Type", "appliction/json"); post.addHeader("usercode", "123"); post.addHeader("password", "123"); post.addHeader("ProtocolVersion", "1.1"); //装填参数 StringEntity s = new StringEntity(json.toString(), "utf-8"); s.setContentEncoding(new BasicHeader(HTTP.CONTENT_TYPE, "appliction/json")); //设置参数到请求对象中 post.setEntity(s); //执行请求操作，并拿到结果（同步阻塞） CloseableHttpResponse httpResponse = client.execute(post); InputStream in = httpResponse.getEntity().getContent(); BufferedReader br = new BufferedReader(new InputStreamReader(in, "utf-8")); StringBuilder strber = new StringBuilder(); String line = null; while ((line = br.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb91f34b10ab6adfe704db0de4888ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dcdc6a42b9e41c58692c3096c26ebd4/" rel="bookmark">
			Java Swing药品库房管理系统，界面漂亮、功能全，直接使用 窗体版本-402
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天为大家分享一个java语言编写的药品库房管理系统-402，目前系统功能已经很全面，后续会进一步完善。整个系统界面漂亮，有完整得源码，希望大家可以喜欢。喜欢的帮忙点赞和关注。一起编程、一起进步
开发环境 开发语言为Java，开发环境Eclipse或者IDEA都可以，数据为MySQL。运行主程序，或者执行打开JAR文件即可以运行本程序。
系统框架 利用JDK自带的SWING框架开发。纯窗体模式，直接运行Main文件即可以。同时带有详细得设计文档。
主要功能 功能描述 药品库房管理系统提供了一个强大的后台管理模块——数据维护。在数据维护模块中，用户可以方便的管理系统中的使用人员的帐号，系统中的药品信息，药品生产厂商，药品供货商，药品类别等信息。使用帐号管理功能可以方便的给予某人某个权限，使其拥有某种操作的权限，也可以快捷的修改自己本身的密码。而后面的这些信息管理功能可以给系统中的其他模块一个规范也是一个约束，这样就不会在系统中出现错误的信息，保证了信息的有效性和信息的完整性。整个系统分三种用户类型：库房管理员、系统管理员、业务审核员。
(1) 系统管理员：拥有系统中所有功能.功能包括：账号管理、生产单位资料管理、供货商管理、药品信息管理、药房信息管理、药品类别管理。
(2)库房管理员:拥有系统中所有功能。功能包括：账号管理、生产单位资料管理、供货商管理、药品信息管理、药房信息管理、药品类别管理。
(3)业务审核员：修改密码、业务单据录入、业务单据审核、药品管理、统计与报表管理
系统流程图 运行效果 1 用户登录 2 账号管理 3 修改密码 4 新增账号 5 账号管理 6 供货单位资料管理 7 供应商信息管理 8 药品信息管理 9 药房信息管理 10 药品信息管理 11 业务单据录入 12 业务单据审核 13 药品调价 14 库存查询和统计 项目总结 通过此项目，我收获了很多很多，其中最重要的一点是细心和耐心，刚开始的时候不一定要考虑到系统的方方面面，在项目开发的过程中，先画出业务流程图和用例图，把大体框架做好，然后再逐一细化。刚开始不可能做到面面俱到，围绕原型一步步完善。做为系统设计和编码的程序员，要善于思考，以现实为依据，让自己的每一行代码都能实现自己的意义。
通过本次项目的开发和设计，我掌握了事件处理，文件操作，Java UI布局,JDBC、界面美化等知识，并且能够运用到实际项目中，对我以后的学习和就业有非常大的帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/330eec61b083e87e54fdb874037b8966/" rel="bookmark">
			vue路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 `vue-router`路由的理解什么是路由：路由分类：1.前端路由：2.后端路由：基本使用： 多级路由（嵌套路由）路由的query参数路由的params参数路由命名路由的props配置`&lt;router-link&gt;`的replace属性编程式路由导航缓存路由组件两个新的生命周期钩子 路由守卫独享守卫组件内守卫 vue-router 理解：vue的一个插件库，专门用来实现SPA应用
SPA（single page web application）：
单页web应用整个应用只有一个完整的页面点击页面中的导航连接不会刷新页面，只会被页面局部更新数据是需要通过Ajax请求获取 路由的理解 什么是路由： 一个路由就是一组映射关系（key-value）key为路径，value为fuction或者component 路由分类： 1.前端路由： 理解：value就是component，用于展示页面工作过程：当浏览器路径改变时，对应组件就会改变 2.后端路由： 理解：value就是function，用于处理客户端提交的请求工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来去处理请求，返回响应数据 基本使用： 1.安装vue-router：npm i vue-router
2.应用插件：Vue.use(VueRouter)
3.编写router配置项：
// 创建整个应用的路由器 import VueRouter from 'vue-router' // 引入组件 import About from '../components/About' import Home from '../components/Home' // 创建并暴露一个路由器 export default new VueRouter({ routes: [{ path: '/about', component: About }, { path: '/home', component: Home } ] }) 4.实现切换效果（router-link）
&lt;router-link class="list-group-item" active-class="active" to="/about"&gt;About&lt;/router-link&gt;
5.指定展示位置
&lt;router-view&gt;&lt;/router-view&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/330eec61b083e87e54fdb874037b8966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b668f93e050e486e96df06808e47ee/" rel="bookmark">
			数据分片技术及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据分片是一种将数据分散存储在多个节点上的技术，它可以提高系统的容量、性能、可用性和可扩展性。数据分片技术的主要思想是将数据按照特定的规则进行分片，然后将分片的数据分散存储在多个节点上。
数据分片的实现需要考虑以下几个方面：
分片规则：分片规则是指将数据按照什么方式进行分片。常见的分片规则有：按照数据的ID进行分片、按照数据的时间戳进行分片、按照数据的地理位置进行分片等。
分片数量：分片数量是指将数据分成多少份。分片数量需要根据数据的大小、分布情况、系统的负载情况等因素进行决定。
数据备份：数据分片后，需要考虑数据的备份。通常采用数据副本的方式来实现数据的备份，即将每个数据分片复制多份存储在不同的节点上，以确保数据的高可用性和可靠性。
数据访问：数据分片后，需要考虑如何进行数据的访问。通常采用数据分布策略、数据路由策略、负载均衡算法等方式来实现数据的快速访问和传输。
数据分片技术的应用非常广泛，包括以下几个方面：
分布式数据库：数据分片技术可以用于分布式数据库的实现，将数据分散存储在多个节点上，提高系统的容量、性能、可用性和可扩展性。
大数据处理：数据分片技术可以用于大数据处理系统的构建，将大数据按照特定的规则进行分片，然后采用分布式计算的方式进行处理和分析。
云存储：数据分片技术可以用于云存储系统的构建，将用户的数据分散存储在多个节点上，实现数据的高可用性和可靠性。
分布式缓存：数据分片技术可以用于分布式缓存系统的构建，将缓存数据按照特定的规则进行分片，然后存储在多个节点上，提高缓存系统的容量、性能和可用性。
总之，数据分片技术是一种非常有用的技术，可以帮助我们实现系统的高性能、可扩展性、可用性和可靠性。在实际应用中，需要根据具体的需求和场景来选择合适的技术和方案，以实现系统的最优化设计和实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/462ca62f944b7b85a52780f0b813bd6a/" rel="bookmark">
			Ubuntu16安装ClickHouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1步：检查是否支持SSE4.2
因为向量化执行需要用到这一项特性
如果不支持SSE指令集,则不能直接使用预编译安装包,
需要通过源码编译特定的版本进行安装
grep -q sse4_2 /proc/cpuinfo &amp;&amp; echo "SSE 4.2 supported" || echo "SSE 4.2 not supported"
第2步：为apt添加clickhouse仓库
网上好多都说使用Yandex的官方仓库，
我一开始的时候也是用的Yandex的官方仓库，但是速度特慢，20KB/s左右下载完要1个多小时
于是换了清华源，链接在这里
https://mirrors.cnnic.cn/help/clickhouse/
当然你也可以选用阿里云源，163源，（一般阿里云源比清华源用得人更多，但是不知道为什么clickhouse相关的很少）
vim /etc/apt/sources.list
添加：
deb https://mirrors.tuna.tsinghua.edu.cn/clickhouse/deb/stable/ main/
或者：
deb http://repo.yandex.ru/clickhouse/deb/stable/ main/
第3步：添加依赖并更新apt数据库
apt install dirmngr
apt-key adv --keyserver keyserver.ubuntu.com --recv E0C56BD4
apt update
第4步：安装clickhouse服务端及客户端
apt-get install clickhouse-client clickhouse-server
第5步：启动clickhouse
先修改配置文件，可以远程访问
# 文件可能没有写入权限，先添加写入权限
sudo chmod 600 /etc/clickhouse-server/config.xml
vim /etc/clickhouse-server/config.xml
# config.xml文件添加以下内容或者直接找到把注释去除即可
&lt;listen_host&gt;0.0.0.0&lt;/listen_host&gt;
# 启动命令
systemctl start clickhouse-server
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/462ca62f944b7b85a52780f0b813bd6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/889060f230d83bf884ba538192c85c60/" rel="bookmark">
			【MySQL进阶】深入理解InnoDB数据页结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【MySQL进阶】深入理解InnoDB数据页结构 参考资料：《MySQL是怎么运行的：从根儿上理解MySQL》。
数据页结构的快速浏览 数据页代表的这块 16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：
从图中可以看出，一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。下边我们用表格的方式来大致描述一下这7个部分都存储一些啥内容（快速的瞅一眼就行了）：
记录在页中的存储 存储的记录会按照我们指定的行格式存储到User Records部分一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了 记录头信息的秘密 为了故事的顺利发展，我们先创建一个表：
mysql&gt; CREATE TABLE page_demo( -&gt; c1 INT, -&gt; c2 INT, -&gt; c3 VARCHAR(10000), -&gt; PRIMARY KEY (c1) -&gt; ) CHARSET = ascii ROW_FORMAT = Compact; Query OK, 0 rows affected (0.03 sec) 这个新创建的 page_demo 表有3个列，其中 c1 和 c2 列是用来存储整数的， c3 列是用来存储字符串的。需要注意的是，我们把 c1 列指定为主键，所以在具体的行格式中InnoDB就没必要为我们去创建那个所谓的 row_id 隐藏列了。而且我们为这个表指定了 ascii 字符集以及 Compact 的行格式。所以这个表中记录的行格式示意图就是这样的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/889060f230d83bf884ba538192c85c60/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/70/">«</a>
	<span class="pagination__item pagination__item--current">71/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/72/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>