<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70f026190989924f870c52f12181b73f/" rel="bookmark">
			U盘重装系统后可能遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、重装系统 具体流程安装参考百度盘的使用优启通进行安装。安装完系统后可能会出现如下现象，一般台式机比笔记本简单，因为台式机不存在外围设备，例如触控板等。：
1、自己的优启通的万能驱动可能不具有相应的硬件驱动，
在安装完系统后会提示：未找到相应的驱动。2、联想的电脑最可能出现上面的问题，即使用鲁大师进行驱动检测，也无法安装完所有的驱动，例如触控板或者Fn加的亮度
调节等都无法其作用。3、此时可以直接到联想售后网址：售后客户服务中心。
4、其中触控板的最可能的驱动选项是：驱动程序(2）如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d245aedd86885ea2466fa3d780be6c4/" rel="bookmark">
			JAVA的Socket详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 问题引入
1.1 网络架构模型
网络架构模型主要有OSI参考模型和TCP/IP五层模型
1.1.1 OSI参考模型
OSI（Open System Interconnect），即开放式系统互联。一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。ISO为了更好的使网络应用更为普及，推出了OSI参考模型，这样所有的公司都按照统一的标准来指定自己的网络，就可以互通互联了。
OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）。
1.1.2 TCP/IP五层模型
TCP/IP五层协议（物理层、数据链路层、网络层、传输层、应用层）
1.1.3 各协议层的说明
应用层
应用层最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET等。
传输层
建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。
网络层
本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。
1.2 网络编程中的问题
常见的网络编程中的问题主要是怎么定位网络上的一台主机或多台主机，另一个是定位后如何进行数据的传输。对于前者，在网络层中主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定Internet上的一台主机。对于后者，在传输层则提供面向应用的可靠（tcp）的或非可靠（UDP）的数据传输机制。
对于客户端/服务器（C/S）结构。 即通信双方一方作为服务器等待客户提出请求并予以响应。客户则在需要服务时向服务器提出申请。服务器一般作为守护进程始终运行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服务端口，使后来的客户也能及时得到服务。
对于浏览器/服务器（B/S）结构。 客户则在需要服务时向服务器进行请求。服务器响应后及时返回，不需要实时监听端口。
1.3 TCP协议与UDP协议
1.3.1 TCP TCP是（Tranfer Control Protocol）的简称，是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建立连接，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。
TCP的三次握手
建立起一个TCP连接需要经过“三次握手”：第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求。
1.3.2 UDP UDP是（User Datagram Protocol）的简称，是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。
1.3.3 TCP和UDP的区别
UDP：
1、每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。
2、UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。
3、UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方
TCP：
1、面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中需要连接时间。
2、TCP传输数据没有大小限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大的数据。
3、TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。
应用：
1、TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高。
2、UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些。
2 socket网络编程
2.1什么是socket?
Socket的英文原义是“孔”或“插座”。在网络编程中，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。
Socket套接字是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
Socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。
2.2 Socket的原理
Socket实质上提供了进程通信的端点。进程通信之前，双方首先必须各自创建一个端点，否则是没有办法建立联系并相互通信的。正如打电话之前，双方必须各自拥有一台电话机一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d245aedd86885ea2466fa3d780be6c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e2bc3ab05cc7c1a182f92130636f4b6/" rel="bookmark">
			NLTK组块分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务 将昨天完成的已进行词性标注的摘要列进行组块分析，并将两个结果放到Excel中进行的对比分析
代码 import nltk from nltk.tokenize import sent_tokenize from stanfordcorenlp import StanfordCoreNLP from nltk.tree import Tree import numpy as np import pandas as pd import re nlp = StanfordCoreNLP(r'E:\网页下载\stanford-corenlp-4.2.2')#程序内调用 def chunking(word_broken): # 写一个匹配名词的模式 pattern = """ NP: {&lt;DT&gt;&lt;VBG|VBN&gt;*&lt;JJ.*&gt;*&lt;VBG|VBN&gt;*&lt;NN.*&gt;*&lt;VBG|VBN&gt;*&lt;JJ.*&gt;*&lt;VBG|VBN&gt;*&lt;NN.*&gt;+}#必有定词修饰，包含前置定语与后置定语两种情形 {&lt;VBG|VBN&gt;*&lt;JJ.*&gt;*&lt;VBG|VBN&gt;*&lt;NN.*&gt;*&lt;VBG|VBN&gt;*&lt;JJ.*&gt;*&lt;VBG|VBN&gt;*&lt;NN.*&gt;+}#无定词修饰 """ # 定义组块分析器 chunker=nltk.RegexpParser(pattern) result=chunker.parse(word_broken) return result path='E://网页下载/20210915-ASML-高被引专利.csv' path_end='E://网页下载/0-500_processed_1.csv' with open(path,encoding="utf-8") as file: d = pd.read_csv(file) df1=pd.DataFrame(d["摘要"]) value_1=[] value_2=[] data={"摘要分词":value_1,"组块分析":value_2} for row in df1['摘要']: text = re.sub('%','',row) text = re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e2bc3ab05cc7c1a182f92130636f4b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e605b82cbebe648c8cb17685be18d5/" rel="bookmark">
			Andriod Studio显示Manifest merger failed with multiple errors的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Andriod Studio显示Manifest merger failed with multiple errors的问题 错误如下：
其实，这是因为编译器版本还没有更新，但是如果应用的是最新的Andriod SDK，也就是安卓版本，就会因为配置文件不符合导致出错。
例如，我的Andriod Studio是2020.3最后一次更新，但是现在我应用的安卓SDK如图所示，这是2021年发布的。
在app目录下，我们的build.gradle文件，配置如下
compileSdk和targetSdk是31，对应的是31，但是我们app目录的外层配置文件却因为AS版本没有更新无法对应，就是在运行时报错。
解决办法如下：
①点开左上角的file-&gt;settings-&gt;Appearance&amp;Behavior-&gt;System Settings-&gt;Andriod SDK,下载低版本的Andriod SDK，我下载的是Andriod11
②打开app目录下的build.gradle，将compileSdk和targetSdk改成你下载的安卓版本对应的API level，我下载的Andriod 11对应的是30，则改成30
问题完美解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f83455f39aabdfc8d412c5f364241fc9/" rel="bookmark">
			NLP之英文分词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务 对Excel中的摘要列的英文段落进行英文分词、词性标注，将结果导入Excel
下面展示代码`。
import nltk from nltk.tokenize import WordPunctTokenizer, sent_tokenize from nltk.corpus import stopwords from nltk.tag import pos_tag import numpy as np import pandas as pd import xlwt #英文断句分词	def wo_se_broken(sentence): #先分句，再分词 paragraph = sentence#句子与下一个句子之间要用空格隔开 sents=nltk.sent_tokenize(paragraph.lower())#sent_tokenize返回分句后的句子列表 #print(sents) words=[] for sent in sents: text_list=nltk.word_tokenize(sent)#分词 #去掉标点符号 english_punctuations=[',', '.', ':', ';', '?', '(', ')', '[', ']', '&amp;', '!', '*', '@', '#', '$', '%'] word_1=[w for w in text_list if w not in english_punctuations] #去掉停用词(停用词均为小写形式，需先将句子转为小写形式） stops = set(stopwords.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f83455f39aabdfc8d412c5f364241fc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1df1e2a6a1bacd0c0a8d209b123f855e/" rel="bookmark">
			NIPS15 - 神经网络中的空间转换模块STN《Spatial Transformer Network》(含代码复现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 原文地址论文阅读方法初识相知回顾代码 原文地址 原文
论文阅读方法 三遍论文法
初识 CNN方法在计算机视觉领域大放异彩，在很多领域都已经代替了传统方法。然而卷积神经网络的架构缺乏空间不变性（Spatially Invariant），即使卷积和max-pooling操作在一定程度上引入了平移不变性和空间不变性，但如果输入发生了较大的空间变化，CNN就变得无法识别了。
因此本文提出了一个空间转换模块，并以此构建了空间转换网络，能在一定程度增加CNN的空间不变性。并且这是一个即插即用的模块，能较方便地插入到各种架构中。
相知 介绍主要技术和部分实验
基于矩阵操作的空间变换
熟悉传统图像处理的小伙伴肯定知道大多数空间转换就可以转换成基于矩阵的采样操作，假设输入图像(source)的像素点由( x i s , y i s x_i^s, y_i^s xis​,yis​)表示，输出图像(target)像素点由( x i t , y i t x_i^t, y_i^t xit​,yit​)表示，只要确定了一组变换参数θ就能确定一种空间变换。以2D放射变换矩阵为例：
矩阵 A θ A_θ Aθ​可以有平移、旋转、缩放、错切等操作，只要确定了其中6个参数，就可以根据矩阵变换求得输出图像各像素点的值（视为从原图采样的操作）。
这里贴上恒等映射（ θ 11 , θ 22 θ_{11}, θ_{22} θ11​,θ22​为1其他为0）和一种仿射变化的效果图：
了解更多关于2D仿射变换矩阵请参照这篇文章：仿射变换及其变换矩阵的理解
既然可以将空间变换确定为矩阵操作，那么不妨让网络去学习生成矩阵参数，从而学会空间转换。
整体架构
STN模块的整体结构如上图所示，其由localisation net、Grid generator和Sampler三部分组成，输入特征图U（也可以直接是RGB图像）经过空间变换模块得到输出特征图V。
其中Localisation net将输入特征图中送到一个子网中，得到空间变化参数θ；Grid generator根据θ确定一个空间变化，并创建采样网格(sampling grid， 确定输入图中哪些点会被用于变换)；Sampler根据采样网格对输入特征图进行采样，从而得到最终的输出。
Localisation net
定位子网接受输入特征图，送到隐层中提取特征（可以是卷积层，也可以是全连接层），并根据预设的变换输出对应的参数（比如之前提到的仿射变换就是6个参数）。
Grid generator
其实就是根据参数构造转换矩阵，从而确定采样空间。
其中有一些细节需要注意，输入输出图的坐标均归一化到[-1, 1]之间
Image Sampling
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1df1e2a6a1bacd0c0a8d209b123f855e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d0bbca357cefc922209f1709102ee74/" rel="bookmark">
			前端基础知识总结---HTML篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML 面试知识点总结 本部分主要是笔者在复习 HTML 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！
目录 1. DOCTYPE 的作用是什么？2. 标准模式与兼容模式各有什么区别？3. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;，而不需要引入 DTD？4. SGML 、 HTML 、XML 和 XHTML 的区别？5. DTD 介绍6. 行内元素定义7. 块级元素定义8. 行内元素与块级元素的区别？9. HTML5 元素的分类10. 空元素定义11. link 标签定义12. 页面导入样式时，使用 link 和 @import 有什么区别？13. 你对浏览器的理解？14. 介绍一下你对浏览器内核的理解？15. 常见的浏览器内核比较16. 常见浏览器所用内核17. 浏览器的渲染原理？18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）20. 什么是文档的预解析？（浏览器解析过程）21. CSS 如何阻塞文档解析？（浏览器解析过程）22. 渲染页面时常见哪些不良现象？（浏览器渲染过程）23. 如何优化关键渲染路径？（浏览器渲染过程）24. 什么是重绘和回流？（浏览器绘制过程）25. 如何减少回流？（浏览器绘制过程）26. 为什么操作 DOM 慢？（浏览器绘制过程）27. DOMContentLoaded 事件和 Load 事件的区别？28. HTML5 有哪些新特性、移除了那些元素？29. 如何处理 HTML5 新标签的浏览器兼容问题？30. 简述一下你对 HTML 语义化的理解？31.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d0bbca357cefc922209f1709102ee74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55b2aa8e5c2afdf9ee02f376ec5db337/" rel="bookmark">
			配置域名访问及Nginx（命令/宝塔）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用宝塔方式开发 1 添加解析 登录云服务器，在云服务器的控制台找到DNS解析，腾讯云可以在上面的云产品中搜DNS，如下
点进去后如下，可以看到这里是空的，因为没有添加任何解析，咱们点击添加解析，然后添加自己的域名
添加后会有一条添加域名信息，点击域名，这里要添加三条记录，以下三条：
注：如果只是要配置自己的网站能够通过域名访问，那就只需要配置下满截图中的第三条二级域名就可以了，但是一般来说，一个服务器不只是通过二级域名访问，还会有直接访问和
@：表示直接解析域名www：解析域名通过www访问xxxx（二级域名）：解析通过二级域名访问，我这里配置的是onestar二级域名 这里添加后如下，记录值为自己服务器的公网IP
添加完成后就可以使用域名进行访问了，But，这样直接访问的话，访问的是服务器默认访问的80端口，而我们项目用的端口是8083，所以这里要将端口进行转发，将8083端口转发到域名，这里就要用到反向代理的技术了。
前提：必须先将项目部署上去和运行，要是不知道怎么部署可以观看：服务器购买与项目部署
接下来就进入正题了，不要走开！
进到到Nginx文件目录中
点击上面的，再点击conf文件夹进入下面页面。打开
include：这是头文件包含，可以看到这里配置了/www/server/nginx/conf/product/*.conf，意思是包含/www/server/nginx/conf/product目录下的所有.conf配置文件，咱们可以在/www/server/nginx/conf/product文件夹下创建后缀为.conf 的文件来添加配置，等会就要用到sever：要修改的就是这个部分了，也就是服务配置，但是一般我们不直接在这里修改，因为一个服务器一般会有很多个服务要跑，如果直接在这里修改的话就不方便拓展，可以看到我这里将server注释了，也就是不用这个server，而是在include另外添加配置文件 注：咱们可以理解为nginx.conf是一个总配置文件，include所包含的是子配置文件，如果要添加一个服务，就可以再/www/server/nginx/conf/product目录下去添加一个子配置文件，这里也是用的这种方式。
解释：（就相当于Nginx配置反向代理是通过sever，如果我们在主文件中修改比较麻烦，也不方便管理，所以就引入子配置文件，只需要包含在主文件中即可！这里的子配置文件自己创建）
我这里是创建在这个位置。
去blog.conf中配置需要映射项目信息。
这里我们了解一下几点就可以了：
listen：监听80端口server_name：转发到哪个地址，也就是前面配置的二级域名地址proxy_pass：代理到哪个地址，也就是要访问的服务器端口地址access_log：表示记录日志信息，会在根目录下创建onestar.newstar.net.cn.access.log日志文件，打印项目的日志信息 重启Nginx：
重启后服务就生效，可以使用域名进行访问了：yq.bingninglyq.cn/
大功告成，✿✿ヽ(°▽°)ノ✿
命令方式配置 这种方式摘抄自ONSTAR
一般来说，一个服务器不止跑一个服务（看自己需求，当然也可以只跑一个），每个服务都是使用一个二级域名来进行访问，所以这里配置二级域名进行访问
1、反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。这里使用NGINX反向代理，将80端口转发到8080端口，需要对NGINX进行配置，所以要先下载NGINX
2.1 下载安装NGINX
# 下载NGINX： yum install nginx # 启动nginx： systemctl start nginx # 加入开机启动： systemctl enable nginx # 查看nginx的状态： systemctl status nginx 2.2 配置NGINX
下载后需要对NGINX进行配置，这里的配置文件是nginx.conf，可以使用命令 find / -name “nginx.conf” 进行查找，默认是在 /etc/nginx/nginx.conf，咱们来进行配置：
# 打开nginx.conf配置文件 vim /etc/nginx/nginx.conf 可以看到如下配置，这里只讲解两个地方，也就是框出的部分
include：这是头文件包含，可以看到这里配置了 /etc/nginx/conf.d/*.conf，意思是包含/etc/nginx/conf.d/目录下的所有.conf配置文件，咱们可以在/etc/nginx/conf.d/ 文件夹下创建后缀为.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55b2aa8e5c2afdf9ee02f376ec5db337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f61b55e08e33a85d4a7673fb470461/" rel="bookmark">
			Echarts 柱状图渐变色设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		渐变色的设置是通过在series属性中的itemStyle属性设置的。其中主要是echarts.graphic.LinearGradient方法。 series: [ { type: 'bar', barWidth: 10, stack: 'total', data: this.seriesData, itemStyle: { normal: { color: new echarts.graphic.LinearGradient(1, 0, 0, 0, [{ // 四个数字分别对应 数组中颜色的开始位置，分别为 右，下，左，上。例如（1,0,0,0 ）代表从右边开始渐 // 变。offset取值为0~1，0代表开始时的颜色，1代表结束时的颜色，柱子表现为这两种颜色的渐变。 offset: 0, color: '#4d76ff' }, { offset: 1, color: '#80aaff' }]), } }, } ], 效果如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a95b425baacac1de306c68413a09eeef/" rel="bookmark">
			测试RT-Thread 动态模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		听说国人开发的RT-Thread OS 已经有一段时间了，一直没有尝试。毕竟学习一个新的平台花费的时间和精力非常多。这次来测试RT-Thread 的主要目的是希望使用它的动态库功能。现在Cortex-M 系列的Arm 处理器已经非常强大了。但是由于Cortex-M没有内存管理器。程序缺乏重定位的功能。所以难以实现类似linux OS 的共享库（lib.so )。而共享库对于系统的功能扩展非常重要。比如在控制器中，需要动态地导入功能块。如果没有共享库功能。那么新增加的程序库必须要和内核，OS 一起重新编译下载。实现远程添加，更新功能块就更加麻烦。所以，共享库对于控制设备的嵌入式软件而言是非常重要的。
初识RT-Thread RT-Thread Studio 开发环境非常方便
RT-Thread 已经提供了一个一体化的开发环境RT-Thread Studio。使用起来十分方便。为了减少一开始设置的麻烦，购买了一个Art PI 开发板。开发一个闪灯程序非常快捷和顺利。
RT-Thread的 依赖项
RT-Thread 使用ST link 作为程序下载工具，需要下载和安装STlink，同时也是有Python 需要安装Python 2.7
RT-Thread 的msh
与其他嵌入式OS 不同，RT-Thread 提供了一个类似Linux shell 的命令工具， 前叫做msh。通过开发板上的USB 与PC 链接。你可以使用一个串口软件使用。以前好像叫做Finsh 。不知道为什么不直接叫做shell ？
摆脱不了 RT-Thread 的ENV 工具
以前RT-Thread 是使用ENV 工具开发的。目前开发动态模块，好像依然脱不了ENV 工具。它是是在windows cmd 下使用的。在相关的目录下 击右键，选择 conEMU Here 进入。
吐槽一下
也许是一些历史的包袱，RT-Thread 的某些概念，命名和使用方式有点古怪，与linux ，或者其他的开发环境不同。初学起来有点摸不着头脑。正如我所指出的。开发一个软件，要十分小心地起名字和术语。尽量符合社会化语义（也就是人们的习惯）。
RT-Thread 的另一个问题是国人开发的软件普遍存在一个问题，不是软件本身的技术不好，而是社区不好。遇到问题在网络上很难找到答案。网络上的除了原厂的文档以外，回答问题，相互讨论和分享经验比较少。大多数是文章是相互转发的，或者是自己的学习笔记，或者是培训老师的文案。说的话都一个样。一个地方出错，许多地方都是错。这是使用国内软件的最大困惑。
使用动态模块 主要参考【STM32H750】玩转ART-Pi（八）——添加动态模块 这篇博文。视乎没有遇到太大的问题。
主要的scons 命令
set RTT_ROOT=C:\RT-ThreadStudio\workspace\art_pi_module\rt-thread set BSP_ROOT=C:\RT-ThreadStudio\workspace\art_pi_module scons --target=ua -s $ scons --lib=lib scons: Reading SConscript files .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a95b425baacac1de306c68413a09eeef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d806b661d51b49a4ea5155110a972775/" rel="bookmark">
			https协议详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载至 https://www.cnblogs.com/xietianjiao/p/13260021.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccee28ed09e32a94fe525c95b4be1236/" rel="bookmark">
			Oracle中id自增
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle创建主键自增可以采取两种方式
方式一：创建序列
create sequence OCR_TEMPLATE_seq --序列名 increment by 1 --自增基数 start with 1 --从1开始自增 nomaxvalue --无最大值 nominvalue --无最小值 nocycle --累加 不循环 nocache; --无缓存 方式二：创建触发器
create or replace trigger OCR_TEMPLATE_seq before insert on OCR_TEMPLATE for each row begin select OCR_TEMPLATE_seq.nextval into :new.id from dual; end; 对应的mybatisMapper
&lt;insert id="insertSelective" parameterType="test.model.OcrTemplate"&gt; &lt;!--@mbg.generated--&gt; &lt;selectKey keyProperty="id" resultType="java.math.BigDecimal" order="BEFORE"&gt; SELECT OCR_TEMPLATE_SEQ.NEXTVAL FROM DUAL &lt;/selectKey&gt; insert into OCR_TEMPLATE &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt; &lt;if test="ocrCode != null and ocrCode !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccee28ed09e32a94fe525c95b4be1236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/309a1d13179e83d5455ceb2767988090/" rel="bookmark">
			【Godot】使用代码控制点击按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Godot 3.3
直接上代码
## 点击按钮 ## @button 要点击的鼠标 func click_button(button : BaseButton) -&gt; void: # 按下鼠标左键 var event = InputEventMouseButton.new() event.pressed = true event.button_index = BUTTON_LEFT button._gui_input(event) # 弹起鼠标左键 event = InputEventMouseButton.new() event.pressed = false event.button_index = BUTTON_LEFT button._gui_input(event) 以此类推，你可以发散思维，改成其他类型的节点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2632aae73522ad87c704f313b6ed3031/" rel="bookmark">
			cuda10.1 &#43; py3.7 &#43; torch1.7.1 安装MinkowskiEngine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 新建conda环境
conda create -n mink python=3.7 source activate mink 安装torch1.7.1+torchvision0.8.2，可到此处下载
torch-1.7.1+cu101-cp37-cp37m-linux_x86_64.whl torchvision-0.8.2+cu101-cp37-cp37m-linux_x86_64.whl 在whl路径下安装
pip install torch-1.7.1+cu101-cp37-cp37m-linux_x86_64.whl pip install torchvision-0.8.2+cu101-cp37-cp37m-linux_x86_64.whl 安装后注意torch的cuda版本是否为10.1，可通过下面命令查看
python -c "import torch; print(torch.version.cuda)" 安装依赖库
sudo apt-get install libopenblas-dev 安装open3d
pip install open3d 最后，安装MinkowskiEngine
git clone https://github.com/NVIDIA/MinkowskiEngine.git cd MinkowskiEngine python setup.py install --blas_include_dirs=${CONDA_PREFIX}/include --blas=openblas 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8b8ed3903724001810815005a635d26/" rel="bookmark">
			LeetCode25—K个一组翻转链表（java版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
标签：递归 链表 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
进阶：
你可以设计一个只使用常数额外空间的算法来解决此问题吗？
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
代码：
思路分析：
1、将链表分为三个部分，已翻转--待翻转--未翻转。
2、定义start和end来指向待翻转部分的开头结点和末尾结点，并定义pre和next用来指向带翻转部分的前驱结点和后继结点。（由于头部没有前驱结点，所以定义一个哨兵节点dummy来作为头结点的前驱结点）。
3、每k个一组进行一下循环：
①首先end指向前驱结点pre，循环往前移动k次，找到待翻转链表的最后一个节点。（其中有可能不足k个，就提前跳出循环，跳出循环后做个判断当前end是不是null，如果是说明不足k个，不需要进行以下翻转链表的操作）；
②开始翻转链表，记录next=end.next保存后继结点，然后使end.next = null（即将待翻转部分先分隔开），start=pre.next
③写个翻转链表的方法reverse，传入的参数就是start，作为待翻转链表的头结点，并返回翻转后链表的头结点，并使pre.next=返回的头结点（这就处理了待翻转部分的前驱结点的连接）
④使start.next = next（这就处理了待翻转部分的后继结点的连接）
4、上述便完成了一次k个一组链表的翻转，更新pre=start，end=pre开始下一次循环
5、最后返回头节点dummy.next，因为定义的哨兵节点永远指向头结点。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseKGroup(ListNode head, int k) { ListNode dummy = new ListNode(0); dummy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8b8ed3903724001810815005a635d26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7216be7a53d5bf2985f90446c93d357a/" rel="bookmark">
			优雅的实现企业微信临时素材上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近接收到一个写企业微信临时素材上传工具类的任务，首先开企业微信官方文档的介绍：
文档地址：https://work.weixin.qq.com/api/doc/90000/90135/90253
请求示例：
POST https://qyapi.weixin.qq.com/cgi-bin/media/upload?access_token=accesstoken001&amp;type=file HTTP/1.1 Content-Type: multipart/form-data; boundary=-------------------------acebdf13572468 Content-Length: 220 ---------------------------acebdf13572468 Content-Disposition: form-data; name="media";filename="wework.txt"; filelength=6 Content-Type: application/octet-stream mytext ---------------------------acebdf13572468-- 上才艺
优雅版本：
/** * * @param fileUrl 网络文件地址, * 图片大小小于2M， * 语音（voice） ：2MB， * 播放长度不超过60s，仅支持AMR格式，视频（video） ：10MB， * 支持MP4格式，普通文件（file）：20MB * @param fileType 图片（image）、语音（voice）、视频（video），普通文件(file) * @return */ public String upload(String fileUrl, QiyeWeixinMediaType fileType){ String result = ""; String accessToken = getAccessToken(); try{ String upUrl = "https://qyapi.weixin.qq.com/cgi-bin/media/upload"; URI uri = UriComponentsBuilder.fromHttpUrl(upUrl) .queryParam("access_token", accessToken) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7216be7a53d5bf2985f90446c93d357a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e6a1c74d652fc258791790381e32b68/" rel="bookmark">
			全选反选（框）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全选反选（框） &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;全选反选（框）&lt;/title&gt; &lt;style&gt; * { padding: 0; margin: 0; } .wrap { width: 300px; margin: 100px auto 0; } table { border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; width: 300px; } th, td { border: 1px solid #d0d0d0; color: #404060; padding: 10px; } th { background-color: #09c; font: bold 16px "微软雅黑"; color: #fff; } td { font: 14px "微软雅黑"; text-align: center; } tbody tr { background-color: #f0f0f0; } tbody tr:hover { cursor: pointer; background-color: #fafafa; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e6a1c74d652fc258791790381e32b68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e84e0b89acb202ca2942a878e7a178a8/" rel="bookmark">
			2021-08-31 从原理上理解补码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想知道为什么有补码，首先我们来考虑一下计算机怎么计算减法。
我们知道，计算机中只有加法器，也就是说只能计算加法。那么如何计算减法呢？首先想到的是把减法 换成 负数加法，那么怎么表示负数呢？当然是表示成正数的相反数了。
以4位的运算器为例子：如果1表示为0001，那么 -1表示为1110就是理所当然的了，为了方便称呼，起了个名叫反码。表里可以清晰的看出其实-1就是1的按位取反。
十进制四位的二进制10001-11110 有了反码还不够嘛？不够的，因为存在这样的问题，0怎么处理？
如果把0当作正数，那么0表示为0000，-0就得表示为1111,这样0就有了两种表示方法，0不等于-0，显然是不合理的，那么怎么解决这个问题呢？
让1111的含义不再是-0，而是-1不就好了。原本-1表示为1110，现在我们希望-1表示为1111，就是在原来的基础上加了1。
0的问题解决了，但是这种改动也影响了所有负数的表示方法，因此对于负数，我们需要把他们加1。这也就形成了所谓“补码”的计算方法。
到此为止就结束了，理解了之后，就再也不用死记硬背那些转换规则了，你甚至可以脱口而出，-1的二进制为全1(16进制为：0xFFFFFF)，因为-1取代了-0的位置。
希望本文可以帮助到你，欢迎批评指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecb17b67868b166fd03362d824efe181/" rel="bookmark">
			基本分段存储管理方式（分段 段表 地址变换 分段、分页管理的对比）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 前言知识总览分段段表地址变换分段、分页管理的对比知识回顾与重要考点 前言 此篇文章是我在B站学习时所做的笔记，大部分图片都是课件老师的PPT，方便复习用。此篇文章仅供学习参考。
提示：以下是本篇文章正文内容
知识总览 分段 进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程)，每段从0开始编址内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。
解说：
由于各个分段是按功能模块来划分的，并且这些段名是由用户自己定义的，所以用户在读这个程序的时候就知道这两句代码做的事情是把某个全局变量的值赋值X的这个子函数当中的某个变量，因此对于用户来说采用分段机制之后程序的可读性还是很高的。在用户编程时，使用的是段名来操作各个段，但是在CPU具体执行的时候其实是使用段号这个参数，所以编译程序会把段名转换为与它们各自相对应的段号，然后CPU再执行这些指令的时候是根据段号来区分各个段的。 段号的位数决定了每个进程最多可以分几个段
段内地址位数决定了每个段的最大长度是多少
段表 问题：程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。
相对于页表来说，段表多了“段长”，因为每个分段的长度可能是不一样的，而在在分页存储管理当中，每个页面的长度是一样的，所以在分页存储中页长是不需要显示记录的，在分段存储中是需要显示的。
物理内存大小为4GB（即232B，可用32位表示整个物理内存地址空间）
1个字节=8位（1B=8bit）
48位大小的数字，只用6B的空间就可以表示。
地址变换 解说：
如果说此时要访问的逻辑地址的段号是2，然后段内地址是1024的话，那首先需要用段号2和段表长度M进行一个检查，那显然此时这个进程的段表长度应该是3，因为它有3个段，所以段号是&lt;段表长度的，因此段号合法，所以就可以进行下一步用段号和段表始址查到这个段号对应的段表项，那这样的话就找到了2号段对应的段表项，那接下来需要对段内地址的合法性进行一个检查，段内地址和段长对比，发现2号段的段长是6k，而段内地址是1024也就是1k，所以段内地址&lt;段长，因此在这个地方并不会产生越界中断，可以继续执行下去，那接下来通过这个段表项，我们知道了这个段在内存当中存放的起始地址是40k，所以用这个段的起始地址40k+段内地址w，也就是1024，那这样的话，我们就得到了最终想访问的目标内存单元，也就是A那个变量存放的位置，那这样的话，就完成了对这个逻辑地址的访问。
分段、分页管理的对比 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要,完全是系统行为，对用户是不可见的。段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。 分段比分页更容易实现信息的共享和保护。 不能被修改的代码称为纯代码或可重入代码（不属于临界资源)，这样的代码是可以共享的。
可修改的代码是不能共享的
访问一个逻辑地址需要几次访存?
1、分页（单级页表)︰第一次访存――查内存中的页表，第二次访存――访问目标内存单元。总共两次访存
2、分段：第一次访存――查内存中的段表，第二次访存――访问目标内存单元。总共两次访存与分页系统类似，分段系统中也可以引入 快表 机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。 知识回顾与重要考点 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed3d625576d25b367afc269d89c8142/" rel="bookmark">
			宝塔面板利用反向代理实现图片及其它资源的访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片服务器已经搭建好，并且已实现上传，但是图片一下访问不了，前前后后折腾了几天很是崩溃，今天利用反向代理终于实现，由于以前接触宝塔比较少，故发此贴，一为自已日后翻查、二为方便各位朋友沟通交流，直接上图:
1. 开启ngnix后启动，无需做任何配置、无需做任何配置，后续都会自动添加到配置当中，如需更改端口的除外，我用的是默认端口，因为我是一通乱配之后，又回到了起点所以在此说明，避免朋友们走弯路，在此说明，以下为我的配置，可对照参考：
user www www;
worker_processes auto;
error_log /www/wwwlogs/nginx_error.log crit;
pid /www/server/nginx/logs/nginx.pid;
worker_rlimit_nofile 51200;
events
{
use epoll;
worker_connections 51200;
multi_accept on;
}
http
{
include mime.types;
#include luawaf.conf;
include proxy.conf;
default_type application/octet-stream;
server_names_hash_bucket_size 512;
client_header_buffer_size 32k;
large_client_header_buffers 4 32k;
client_max_body_size 50m;
sendfile on;
tcp_nopush on;
keepalive_timeout 60;
tcp_nodelay on;
fastcgi_connect_timeout 300;
fastcgi_send_timeout 300;
fastcgi_read_timeout 300;
fastcgi_buffer_size 64k;
fastcgi_buffers 4 64k;
fastcgi_busy_buffers_size 128k;
fastcgi_temp_file_write_size 256k;
fastcgi_intercept_errors on;
gzip on;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aed3d625576d25b367afc269d89c8142/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/128/">«</a>
	<span class="pagination__item pagination__item--current">129/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/130/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>