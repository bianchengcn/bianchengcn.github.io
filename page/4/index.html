<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26663c88e1d8cea38a6d5ce5a69197e2/" rel="bookmark">
			动手实践WebVR 全景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 近年来VR概念越来越火，相信大家在网上都有过VR的浏览体验，比如VR全景看房[1]、VR全景看车[2]、VR全景旅游[3]等等，VR全景给了我们视觉上的沉浸式体验。本文将会简单探究Web VR全景的实现原理，同时也会用threejs实现两个小的demo，希望对大家以后在业务上遇到类似的场景能有所帮助。
什么是VR 引用维基百科的定义：
虚拟现实（英语：virtual reality，缩写VR），是利用电脑模拟产生一个三维空间的虚拟世界，提供用户关于视觉等感官的模拟，让用户感觉仿佛身历其境，可以即时、没有限制地观察三维空间内的事物。用户进行位置移动时，电脑可以立即进行复杂的运算，将精确的三维世界影像传回产生临场感。
与基于现实场景进行增强效果的 AR（Augmented Reality）的区别在于，VR 的场景需要完全重建，类似于进入另一个世界。
虚拟现实的实现原理 人眼对世界的感知，是通过将三维世界投射至视网膜上，以二维图像建立的视觉体系。所以一张具备透视关系的图像，在特定的角度，可以使人感受到三维的空间关系，这就是人眼的深度知觉（depth perception）。VR 技术则建立在这个基础之上。
广泛意义上来说，只要符合模拟三维空间这一行为，就可以称为 VR，手机、电脑、大荧幕、VR 眼镜甚至于空气，都可以成为 VR 的载体。
如何在web上模拟三维空间 三维空间是由2D和3D图形构成的，要模拟三维空间，必须绘制2D和3D图形，我们写js有ECMAScript规范，同理的绘制2D和3D图形也有一套规范，这套规范就是OpenGL
OpenGL是什么 OpenGL（英语：Open Graphics Library，译名：开放图形库或者“开放式图形库”）是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）
OpenGL规范描述了绘制2D和3D图形的抽象API，常用于CAD、虚拟现实、科学可视化程序和电子游戏开发。
在Web上能用OpenGL吗 可以的，在web上可以使用WebGL，它是Web浏览器中OpenGL的JavaScript绑定。
什么是WebGL WebGL是一种JavaScript API，用于在不使用外挂程式的情况下在任何相容的网页浏览器中呈现交互式2D和3D图形。WebGL完全整合到浏览器的所有网页标准中，可将影像处理和效果的GPU加速使用方式当做网页Canvas的一部分。WebGL元素可以加入其他HTML元素之中并与网页或网页背景的其他部分混合。
有了WebGL API，我们就可以web网页上构建三维空间啦。我们可以借助canvas标签来获取WebGL实例来进行WebGL API的调用，更多API可以戳WebGL: 2D and 3D graphics for the web - Web APIs | MDN[4]查看，下面是使用示例：
// 创建canvas标签 const canvas = document.createElement('canvas'); document.body.appendChild(canvas); // 获取webgl实例 const gl = canvas.getContext("webgl"); // 调用webgl api绘制图形 // ..... 目前业界有很多成熟的WebGL3D引擎，比如three.js[5]、babylon.js[6]等等，这些3D引擎已经对WebGL API做了非常高效的封装，可以帮助我们快速绘制2D和3D图形。
three.js实现vr全景 在实战前先了解下three.js的基本概念
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26663c88e1d8cea38a6d5ce5a69197e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b6d5c0375b32351c24d2814b468fe0/" rel="bookmark">
			JNPF低代码平台与其他低代码工具功能有什么不同？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JNPF低代码平台是一种新兴的技术解决方案，它可以帮助开发者快速构建应用程序而无需编写大量的代码。本文将深入了解JNPF低代码平台的常见类型与功能特点，帮助读者更好地理解和应用这项技术。
JNPF低代码平台的功能特点。首先，JNPF低代码平台具有可视化开发功能，开发者可以通过拖拽、配置和连接各种组件和模块，来快速搭建应用程序的界面和功能。这种可视化开发方式大大降低了开发难度，提高了开发效率。其次，JNPF低代码平台具有强大的集成能力，能够与各种第三方服务和系统进行集成，实现数据共享和功能整合。这种集成能力使得开发者能够轻松地将各种功能和服务集成到应用程序中，提供更加丰富和多样化的功能。
此外，JNPF低代码平台还具有自动生成代码的功能，开发者只需进行简单的配置和定制，就可以自动生成目标平台所需的代码，减少了手动编写代码的工作量。通过JNPF的扩展性和灵活性，开发者还可以根据实际需求进行二次开发和定制，满足特定的业务需求。
作为一款服务企事业单位的开发平台，JNPF具备便捷灵活的特性，可以大大简化应用程序的开发过程，提高开发效率和质量。无论是想快速构建软件应用、开发移动应用还是实现复杂的企业级应用，平台都能提供相应的解决方案。通过可视化开发、强大的集成能力和自动生成代码的功能，开发者可以轻松地搭建和定制应用程序，提供各种各样的功能。
通过可视化开发、集成能力、自动生成代码、扩展性和灵活性等功能特点，开发者可以更加高效地构建各种类型的应用程序，实现快速开发和创新。随着低代码平台技术的不断发展和普及，相信JNPF低代码平台将在未来得到更广泛的应用和推广。
应用体验地址：https://www.jnpfsoft.com/?csdnxx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92d3ea611220fd9b276d66afbd3650ae/" rel="bookmark">
			企业电子招标采购系统源码Spring Boot &#43; Mybatis &#43; Redis &#43; Layui &#43; 前后端分离 构建企业电子招采平台之立项流程图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能模块： 待办消息，招标公告，中标公告，信息发布
描述：
全过程数字化采购管理，打造从供应商管理到采购招投标、采购合同、采购执行的全过程数字化管理。通供应商门户具备内外协同的能力，为外部供应商集中推送展示与其相关的所有采购业务信息（历史合作、考察整改，绩效评价等），支持供应商信息的自助维护，实时风险自动提
服务框架：Spring Cloud、Spring Boot2、Mybatis、OAuth2、Security
前端架构：VUE、Uniapp、Layui、Bootstrap、H5、CSS3
涉及技术：Eureka、Config、Zuul、OAuth2、Security、OSS、Turbine、Zipkin、Feign、Monitor、Stream、ElasticSearch等
业务服务
业务服务：通过服务与服务之间的内部（Feign）、外部通讯（Restful），满足不同业务需求。外部服务通过标准化协议，对外提供安全稳定的Restful服务，对内通过Spring Cloud Feign方式进行通讯，数据库完整CRUD操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/492ab95abff752b1124adf43309d7062/" rel="bookmark">
			MySQL--增、删、改、查操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 在数据库example下创建college表。College表内容如下所示：
字段名 字段描述 数据类型 主键 外键 非空 唯一 自增
number 学号 INT(10) 是 否 是 是 否
name 姓名 VARCHAR(20) 否 否 是 否 否
major 专业 VARCHAR(20) 否 否 是 否 否
age 年龄 INT(5) 否 否 否 否 否
要求1:
使用Sql命令完成建表行为.
要求2:
在college表上创建视图college_view。视图的字段包括student_num、student_name、
student_age和department。ALGORITHM设置为MERGE类型，并且为视图加上WITH LOCAL CHECK OPTION条件
要求3:
使用两种方式 修改视图，使其显示专业为计算机的信息，其他条件不变.
要求4:
删除视图college_view. 1. 使用sql命令建表 CREATE TABLE college( number INT(10) NOT NULL UNIQUE PRIMARY KEY COMMENT '学号', name VARCHAR(20) NOT NULL COMMENT '姓名', major VARCHAR(20) NOT NULL COMMENT '专业', age INT(5) COMMENT '年龄'); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/492ab95abff752b1124adf43309d7062/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f7de21030eec26ab7c196a31cda8872/" rel="bookmark">
			算法总结归纳（第十二天）（剩余的图论）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、图论
Ⅰ、spfa算法
spfa求最短路
思路：
代码：
spfa判断负环
思路：
代码：
Ⅱ、floyd算法
思路：
代码：
Ⅲ、prime算法
思路：
代码：
Ⅳ、kruskai算法
思路：
代码：
Ⅴ、染色法判定二分图
思路：
代码：
Ⅵ、匈牙利算法（二分图）
思路
代码：
一、图论 Ⅰ、spfa算法 spfa求最短路 题目链接：spfa求最短路
思路： 本题使用的是队列求解，思路与dijkstra有相似之处，使用邻接表进行存储，使用w数组存储每个边的权重，然后t表示上一层的结点，j表示它的儿子结点，dist[j] &gt; dist[t] + w[i]来更新边长，从而使得边长变为最小。
代码： #include&lt;iostream&gt; using namespace std; #include&lt;cstring&gt; #include&lt;queue&gt; const int N = 1e6 + 10; int e[N], ne[N], h[N], w[N], idx; int dist[N]; bool st[N], cnt; int n, m; void add(int a, int b, int c) { e[idx] = b; ne[idx] = h[a]; w[idx] = c; h[a] = idx ++; } int spfa() { memset(dist, 0x3f3f3f3f, sizeof(dist)); dist[1] = 0; st[1] = true; queue&lt;int&gt; q; q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f7de21030eec26ab7c196a31cda8872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae4da49a4cf438d9a275f28ba7ac9786/" rel="bookmark">
			探索智能巡检机器人深度学习的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器人深度学习（Robot Deep Learning）是指利用深度学习技术，使机器人能够从大量数据中学习和提取特征，进而实现自主感知、决策和行动的能力。通过深度学习算法，机器人可以从传感器获取的数据中自动学习模式和规律，不断优化自身的行为和性能，从而更加智能地应对各种复杂环境和任务。机器学习技术已经成为人工智能领域的关键组成部分，在图像识别、语音识别、自然语言处理、推荐系统、金融风控、医疗诊断等各个领域都得到了广泛应用。
机器人学习的发展历程 机器人深度学习的发展历程可以概括为以下几个阶段：
1. 早期探索阶段（20世纪60年代至80年代）：在20世纪60年代至80年代，人工智能领域处于探索阶段。研究人员开始尝试将机器学习技术应用于机器人领域，但受限于计算能力和数据量的限制，进展较为缓慢。
2. 传统机器学习阶段（80年代至2000年代初）：在80年代至2000年代初，传统机器学习算法开始被应用于机器人领域。例如，基于规则的方法、支持向量机（SVM）、决策树等算法被用于机器人的感知、决策和控制任务。
3. 深度学习兴起阶段（2000年代中期至今）： 随着计算能力的提升和数据量的爆发式增长，深度学习技术在机器人领域开始崭露头角。2006年，深度学习的突破性研究成果——深度信念网络（DBN）的提出，标志着深度学习进入了一个新的发展阶段。随后，卷积神经网络（CNN）和循环神经网络（RNN）等深度学习模型被广泛应用于机器人的感知和决策任务中。
4. 深度学习与机器人融合阶段（2010年代至今）： 2010年代至今，随着深度学习技术的不断发展和机器人硬件的不断进步，深度学习与机器人的融合越来越深入。深度学习技术被应用于机器人的视觉识别、语音识别、自然语言处理、运动控制等各个方面，使得机器人具备了更高级别的感知和认知能力，为实现真正智能的机器人奠定了基础。
机器人深度学习的原理 机器人深度学习的原理基于人工神经网络和深度学习算法。其核心思想是通过多层次的神经网络结构，对大量数据进行学习和特征提取，从而实现对环境的感知、决策和行动。具体原理包括：
1. 人工神经网络（ANN）：人工神经网络是模仿生物神经网络结构和工作原理而设计的计算模型。它由多个神经元组成的多层次网络，每个神经元与上一层和下一层的神经元相连，通过权重和偏置对输入信号进行加权求和，并通过激活函数进行非线性变换。机器人深度学习通过构建多层次的神经网络，实现对数据的分层抽象和特征提取。
2. 深度学习算法：深度学习算法是指一类基于多层神经网络的机器学习算法，如卷积神经网络（CNN）、循环神经网络（RNN）、长短期记忆网络（LSTM）等。这些算法具有强大的学习能力和泛化能力，能够从大规模数据中学习复杂的非线性模式和特征，适用于处理图像、语音、文本等不同类型的数据。
3. 训练过程： 机器人深度学习的训练过程包括数据准备、网络构建、损失函数定义和优化算法选择等步骤。在训练过程中，通过反向传播算法不断调整网络参数，使得模型输出与真实值之间的误差最小化。通过大量数据的反复训练，模型能够逐渐优化，学习到数据的内在规律和特征。
4. 推理过程： 训练完成的深度学习模型可以用于机器人的推理和决策。机器人通过将感知到的数据输入模型，模型经过前向传播计算得到输出结果，从而实现对环境的理解和响应。这种端到端的学习和推理过程使得机器人能够自主地完成各种复杂的任务，如目标检测、路径规划、物体识别等。
深度学习的分类 机器人深度学习可以根据其应用领域和任务类型进行分类，主要包括以下几种：
1.视觉感知：这种类型的深度学习用于机器人的视觉感知任务，包括目标检测、物体识别、图像分割等。常见的深度学习模型包括卷积神经网络（CNN），用于从图像数据中提取特征并进行分类或定位。
2. 运动控制：这种类型的深度学习用于机器人的运动控制任务，包括动作规划、轨迹生成、运动学建模等。常见的深度学习模型包括循环神经网络（RNN）、深度强化学习等，用于学习复杂的运动模式和控制策略。
3.语音识别：这种类型的深度学习用于机器人的语音识别任务，包括语音指令识别、语音情感识别等。常见的深度学习模型包括长短时记忆网络（LSTM）、转录注意力模型（Transducer）等，用于处理连续的语音信号并进行识别。
4. 自然语言处理： 这种类型的深度学习用于机器人的自然语言理解和生成任务，包括文本分类、命名实体识别、机器翻译等。常见的深度学习模型包括循环神经网络（RNN）、Transformer模型等，用于处理自然语言数据并进行语义理解或生成。
5. 决策与规划：这种类型的深度学习用于机器人的决策和规划任务，包括路径规划、任务调度、行为决策等。常见的深度学习模型包括深度强化学习（Deep Reinforcement Learning）等，用于学习从感知到动作的映射关系，实现智能决策和规划。
通过这些分类，机器人可以利用深度学习技术实现更加智能和灵活的行为，从而适应不同的环境和任务需求。
机器人深度学习的发展趋势 1. 端到端学习：未来的机器人深度学习将更加注重端到端的学习，即直接从输入数据到输出动作的学习和映射，避免手工设计特征和规则。这将使得机器人能够更加智能地从原始数据中学习和推断，适应不同环境和任务的需求。
2. 多模态融合：未来的机器人深度学习将更加注重多模态数据的融合，包括视觉、语音、文本等多种感知模态的融合和协同学习。这将使得机器人能够更全面地理解和处理复杂的现实世界，实现更加智能和自然的交互。
3. 强化学习与迁移学习：未来的机器人深度学习将更加注重强化学习和迁移学习等技术的应用，使得机器人能够通过不断的试错和探索，从环境中学习和优化自身的行为。同时，迁移学习技术将使得机器人能够更好地将在一个任务中学到的知识和经验迁移到其他任务中，实现知识的共享和复用。
4. 自我监督学习： 未来的机器人深度学习将更加注重自我监督学习，即利用机器人自身生成的数据进行学习和优化。通过自我监督学习，机器人可以在无需标注数据的情况下进行学习，降低了对大量标注数据的依赖性，提高了学习的效率和泛化能力。
5. 持续学习与适应性： 未来的机器人深度学习将更加注重持续学习和适应性，即能够在不断变化的环境中不断学习和优化自身的行为。通过持续学习和适应性，机器人可以更好地应对环境的变化和不确定性，实现更加稳健和灵活的行为。
超维智能巡检机器人的深度学习 超维科技采用基于YOLO的卷积神经网络深度识别算法，已选目标点可达准确率100%。拥有数十万行业量级数据，有较强的鲁棒性和容错能力，能把部分设备在仅有局部特征情况下还原接近原生特征。
机器人自身携带的可见光摄像机，完成视频图像的数据采集，通过高精度图像识别算法，对图像数据进行智能分析处理，从而识别图像内容。目前能够准确识别电气设备的指针式、数字式仪表、压板、开关、指示灯、刀闸变位、设备外观等多种表计，并进行表计自动读数记录，生成巡检报告，从而代替人眼及时掌握站内电力设备及环境状态信息。
数据机房应用
继电保护室应用
防爆场景应用
变电站应用
在智能巡检机器人的发展历程中，深度学习技术的应用无疑是一个里程碑式的进步。通过深度学习算法的不断演进和优化，智能巡检机器人已经具备了更高级别的感知、理解和决策能力，能够在复杂的工业环境中完成各种任务，为提高生产效率、保障安全生产作出了重要贡献。
未来，随着深度学习技术的不断发展和智能巡检机器人的进一步完善，我们有理由相信，智能巡检机器人将在工业领域发挥越来越重要的作用。通过不断地学习和优化，智能巡检机器人将能够更加准确、高效地检测和监测设备状态，及时发现和预防潜在的安全隐患，为工业生产的可持续发展提供有力支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eeb427e1c105cb0f4e14a59f89c56f4/" rel="bookmark">
			幻兽帕鲁服务器Palworld游戏怎么更新？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自建幻兽帕鲁服务器进入Palworld游戏提示“您正尝试加入的比赛正在运行不兼容的游戏版本，请尝试升级游戏版本”什么原因？这是由于你的客户端和幻兽帕鲁服务器版本不匹配，如何解决？更新幻兽帕鲁服务器即可解决。阿里云百科aliyunbaike.com分享幻兽帕鲁服务器更新教程：
幻兽帕鲁服务器更新 首先确定你的幻兽帕鲁服务器的操作系统是Windows还是Linux，不同操作系统更新教程不一样，详细如下：
Linux系统幻兽帕鲁服务器更新 1、先登录到你的云服务器ECS控制台，然后远程连接到ECS实例，远程连接教程：https://t.aliyun.com/U/8WrnnT
如下图：
阿里云服务器远程连接
2、然后执行更新命令：
curl -sSL https://icms-static-public.oss-cn-zhangjiakou.aliyuncs.com/scripts/aliyun-palworld-server-update.sh | bash 3、命令执行完毕后，重新打开游戏，重新连接服务器即可。
Windows系统幻兽帕鲁服务器更新 1、先登录到你的云服务器ECS控制台，然后远程连接到ECS实例
2、然后在 PowerShell 中执行命令 tasklist
在输出中找到程序“PalServer-Win64-Test-Cmd.”，记录后面4位数pid，如图所示：
PalServer-Win64-Test-Cmd
3、然后执行命令 kill pid，例如上图中的pid为4328，所以执行命令：kill 4328，停止正在运行的Palworld服务器
4、接着执行如下命令，来获取最新的 Palworld 服务器程序，此命令执行可能较慢，因为要下载游戏服务器文件，请耐心等待其执行完成
Start-Process "C:\Program Files\PalServer\steam\steamcmd.exe" -ArgumentList "+login anonymous +app_update 2394010 validate +quit" -Wait 5、执行完成后，重启下云服务器，重启教程 https://t.aliyun.com/U/9O8u9C
至此，阿里云幻兽帕鲁Palworld服务器升级游戏版本教程结束，更多关于幻兽帕鲁服务器说明，请参考 aliyunbaike.com/go/palworld
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f6be28788cf9ae0d853852d70bf59a/" rel="bookmark">
			Android Studio六大基本布局详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio是谷歌推出的一个Android集成开发工具，基于IntelliJ IDEA。类似Eclipse ADT，Android Studio提供了集成的Android开发工具用于开发和调试。
Android Studio的开发环境和模式更加的丰富和便捷，能够支持多种语言，还可以为开发者提供测试工具和各种数据分析。在IDEA的基础上，Android Studio提供五大功能：
开发者可以在编写程序的同时看到自己的应用在不同尺寸屏幕中的样子。Android设备拥有大量不同尺寸的屏幕和分辨率，根据新的Studio，开发者可以很方便的调整在各个分辨率设备上的应用。同时Studio还解决语言问题，多语言版本、支持翻译都让开发者更适应全球开发环境。Studio还提供收入记录功能。开发者可以对应用进行测试，然后向测试用户推出，测试结果不会对外公布。 此外，Android Studio的安装步骤包括：首先需要先安装好JDK并配置好Path环境变量；然后进入官网点击download options，选择对应的版本后下载；下载完成后将SDK放在之前创建好的SD文件夹里；接着进行解压和配置；最后确认将要下载的组件及其文件大小，等待组件下载完成即可。
线性布局（LinearLayout） 线性布局（LinearLayout）是Android中最常用的布局方式之一，它能够将子视图按照垂直或水平方向进行排列。线性布局会将所有子视图按照指定的方向（垂直或水平）依次排列，如果超出了当前屏幕的宽度或高度，会自动进行滚动。
在XML中使用LinearLayout非常简单，只需要在根元素中添加一个LinearLayout标签即可。LinearLayout标签的属性主要包括：
android:orientation：指定线性布局的方向，可选值为vertical（垂直）和horizontal（水平）。android:gravity：指定线性布局内元素的排列方式，可选值为center、left、right、top和bottom等。 以下是一个简单的XML示例，演示如何使用LinearLayout：
&lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:gravity="center"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TextView 1" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TextView 2" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TextView 3" /&gt; &lt;/LinearLayout&gt; 在上述代码中，我们创建了一个垂直方向的LinearLayout，并在其中添加了三个TextView。由于我们设置了android:gravity="center"，所以所有的TextView都居中对齐。
在代码中操作LinearLayout也非常简单，只需要创建一个LinearLayout对象，然后添加子视图即可。以下是一个简单的Java示例：
// 创建一个LinearLayout对象 LinearLayout linearLayout = new LinearLayout(this); linearLayout.setOrientation(LinearLayout.VERTICAL); // 设置方向为垂直 linearLayout.setGravity(Gravity.CENTER); // 设置居中对齐 // 创建一个TextView对象并添加到LinearLayout中 TextView textView1 = new TextView(this); textView1.setText("TextView 1"); linearLayout.addView(textView1); TextView textView2 = new TextView(this); textView2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86f6be28788cf9ae0d853852d70bf59a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9300697ca6c44ff1a0e47d57f5b7f421/" rel="bookmark">
			VSCode 插件集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 翻译(英汉词典)Auto Close TagAuto Rename TagBetter CommentsBracket Pair Colorization TogglerChinese (Simplified) (简体中文)colorizeHighlight Matching TagImage previewJAR ViewerLive ServerMarkdown Preview EnhancedMaterial Icon ThemeMaterial Themeopen in browserTODO HighlightError LensGit GraphGitLive 最近复习了一下前端，又打开了尘封已久的 VSCode，挑选了一些插件分享一下。胖友们有更好用的插件欢迎在评论区留言分享。👍
翻译(英汉词典) 在状态栏中显示选中词的释义，支持驼峰和下划线命名查询；运行 “批量翻译标识符”，批量翻译当前文件中被识别出的标识符，打开并列编辑器并显示翻译后内容。 点击状态栏显示更全信息。当选中单词时，详细信息包括词形变化；当选中驼峰或下划线命名时，详细信息包括所有单词的释义，但不包括各词的词形变化。
批量翻译识别出的命名：
查询单词：
查询驼峰命名：
查询下划线命名：
如果下划线命名是固定短语，则采用短语释义：
优先形容词+名词组合：
查无结果：
悬停显示翻译结果：
配置项：
键名称默认值说明EnglishChineseDictionary.enableHoverfalse开启悬停显示翻译结果 Auto Close Tag 自动添加 HTML/XML 关闭标签：
Auto Rename Tag 自动重命名成对的 HTML/XML 标记。
Better Comments 在代码中创建更人性化的注释。 有了这个扩展，将能够将您的注释分类为：
警报 （Alerts）查询 （Queries）待办事项 （TODOs）突出（Highlights） 注释掉的代码也可以样式化，以明确代码不应该存在。
Bracket Pair Colorization Toggler 括号对着色。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9300697ca6c44ff1a0e47d57f5b7f421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c4371976042355b456ff2bdfadff60/" rel="bookmark">
			STM32低功耗模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、低功耗模式介绍 STM32 的低功耗模式有 3 种：
1)睡眠模式（CM3 内核停止，外设仍然运行）
2)停止模式（所有时钟都停止）
3)待机模式（1.8V 内核电源关闭）
在这三种低功耗模式中，最低功耗的是待机模式，在此模式下，最低只需要 2uA 左右的电
流。停机模式是次低功耗的，其典型的电流消耗在 20uA 左右。最后就是睡眠模式了。
二、待机模式 待机模式可实现 STM32的最低功耗。该模式是在 CM3 深睡眠模式时关闭电压调节器。整个 1.8V 供电区域被断电。PLL、HSI 和 HSE 振荡器也被断电。SRAM 和寄存器内容丢失。仅备份的寄存器和待机电路维持供电。
从待机模式唤醒后的代码执行等同于复位后的执行(采样启动模式引脚，读取复位向量等)。电源控制/状态寄存器(PWR_CSR)将会指示内核由待机状态退出。在进入待机模式后，除了复位引脚以及被设置为防侵入或校准输出时的 TAMPER 引脚和被使能的唤醒引脚（WK_UP 脚），其他的 IO 引脚都将处于高阻态。
三、代码实现 将PA0配置位外部中断
将PA0配置位上升沿触发
// 系统进入待机模式 static void PWR_Enter_Standby(void) { __HAL_RCC_PWR_CLK_ENABLE(); // 使能 PWR 时钟 __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU); // 清除 Wake_UP 标志 HAL_PWR_EnableWakeUpPin(PWR_WAKEUP_PIN1); // 设置 WKUP 用于唤醒 HAL_PWR_EnterSTANDBYMode(); // 进入待机模式 } 然后MCU进入待机模式之后按下WKUP按钮，此时产生一个上升沿，然后退出待机模式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3af6e0098eac94e88a0601587717729/" rel="bookmark">
			《操作系统真象还原》第十五篇：实现用户进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十五篇：实现用户进程 第十五篇：实现用户进程进程创建流程创建虚拟地址空间页表创建及激活初始化中断栈 ，实现特权转移 进程创建流程 进程的创建基于线程来实现，进程创建和线程创建有以下三点不同：
进程拥有自己的虚拟地址空间进程拥有自己的页表和3特权级栈进程创建后需要由特权级0进入特权级3 进程创建和第一次执行的流程如下:
创建进程函数如下：
//创建用户进程 void process_execute(void* filename, char* name) { //在内核中申请一页用作pcb struct task_struct* thread = get_kernel_pages(1); //初始化进程pcb init_thread(thread, name, DEFAULT_PRIO); //创建进程虚拟地址池 create_user_vaddr_bitmap(thread); //创建并初始化线程栈 thread_create(thread, start_process, filename); //创建页表 thread-&gt;pgdir = create_page_dir(); //将新进程加入队列 enum intr_status old_status = intr_disable(); ASSERT(!node_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag)); list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag); ASSERT(!node_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag)); list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag); set_intr_status(old_status); } 创建虚拟地址空间 //创建用户进程虚拟地址位图 void create_user_vaddr_bitmap(struct task_struct* user_prog) { user_prog-&gt;userprog_vaddr_pool.vaddr_start = USER_VADDR_START; uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8, PG_SIZE); user_prog-&gt;userprog_vaddr_pool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3af6e0098eac94e88a0601587717729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b51de6b41d163e89b562764e370825/" rel="bookmark">
			科普类——设计一套无人驾驶遥操作系统的步骤、架构、软硬件需求（十一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设计一套无人驾驶遥操作系统的步骤、架构、软硬件需求 **设计步骤**：**整体架构**：**所需硬件及提供商**：**人员需求**： 设计无人驾驶中的遥操作系统是一个跨学科的工程项目，涉及机械工程、电子工程、计算机科学和通信技术等多个领域。
以下是一个概括性的步骤和架构，以及可能需要的硬件和提供商，还有人员需求：
设计步骤： 项目规划：
明确项目目标、预算和时间表。进行市场调研和技术分析。 需求分析：
分析无人驾驶车辆的操作需求。确定遥操作的功能和性能指标。 系统架构设计：
设计遥操作系统的整体架构，包括硬件、软件、通信和安全模块。设计用户界面和交互逻辑。 硬件选型与采购：
根据系统需求选择合适的硬件设备。与硬件供应商沟通，获取技术支持。 软件开发：
开发遥操作软件，包括控制算法、数据处理和用户界面。实现与无人驾驶车辆的通信协议。 系统集成与测试：
将硬件和软件集成到一起。在模拟环境和实际车辆上进行测试。 安全与合规性评估：
确保系统符合相关安全标准和法规。实施数据加密和网络安全措施。 用户培训与文档编写：
对遥操作员进行培训。编写操作手册和维护指南。 部署与维护：
在实际环境中部署遥操作系统。定期进行系统维护和升级。 整体架构： 用户界面：提供给操作员的控制界面，包括视频监控、车辆状态显示和控制输入设备。通信模块：负责与无人驾驶车辆的数据交换，包括实时视频流、传感器数据和控制指令。数据处理单元：处理来自车辆的原始数据，如图像、激光雷达点云等。控制算法：实现车辆的路径规划、避障和驾驶决策。安全与监控系统：确保操作过程的安全性，包括紧急停止机制和数据备份。 所需硬件及提供商： 传感器：
激光雷达（LIDAR）：Velodyne、Luminar、禾赛科技（Heesight）摄像头：Sony、OmniVision、OnSemi雷达：Continental、Bosch、Arbe RoboticsGPS/IMU：NovAtel、u-blox、Xsens 计算平台：
NVIDIA Jetson、Intel NUC、Texas Instruments (TI) SoM 通信设备：
5G模块：华为、Qualcomm、EricssonWi-Fi/Ethernet：Cisco、TP-Link、Netgear 输入设备：
游戏控制器、专业驾驶模拟设备 显示设备：
高分辨率显示器：Dell、HP、LG 安全设备：
防火墙和加密设备：Cisco、Fortinet、Palo Alto Networks 人员需求： 项目经理：负责项目的整体规划和管理。系统架构师：设计系统架构和集成方案。软件工程师：开发遥操作软件和控制算法。硬件工程师：负责硬件选型、集成和测试。通信工程师：设计和实现通信系统。安全专家：确保系统的网络安全和数据保护。测试工程师：进行系统测试和性能评估。遥操作员：在实际环境中操作无人驾驶车辆。技术支持和维护人员：提供系统的日常维护和用户支持。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12564629a1942a542c1cd1e233d77dd5/" rel="bookmark">
			《操作系统真象还原》 第十四篇：定义并初始化TSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十四篇：定义并初始化TSS 第十四篇：定义并初始化TSS任务状态段(TSS)的介绍TSS的定义TSS的初始化 任务状态段(TSS)的介绍 TSS由程序员提供，由CPU来维护。用于进程切换时，保存进程的上下文环境。
在现代操作系统中，TSS仅用于为0特权级的任务提供栈指针
当CPU由地特权级进入高特权级时，会自动从TSS中获取对应特权级的栈指针
TSS结构如下：
为了访问到TSS，需要在GDT中注册TSS描述符，并将其选择子写入tr(task register)寄存器
TSS描述符结构如下：
写入tr寄存器的命令如下：ltr “16位通用寄存器” 或 “16位内存单元”
TSS的定义 //任务状态段tss结构 struct tss { uint32_t backlink; uint32_t* esp0; uint32_t ss0; uint32_t* esp1; uint32_t ss1; uint32_t* esp2; uint32_t ss2; uint32_t cr3; uint32_t (*eip) (void); uint32_t eflags; uint32_t eax; uint32_t ecx; uint32_t edx; uint32_t ebx; uint32_t esp; uint32_t ebp; uint32_t esi; uint32_t edi; uint32_t es; uint32_t cs; uint32_t ss; uint32_t ds; uint32_t fs; uint32_t gs; uint32_t ldt; uint32_t trace; uint32_t io_base; }; TSS的初始化 //更新tss中的esp0字段的值为pthread的0级栈 void update_tss_esp(struct task_struct* pthread) { tss.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12564629a1942a542c1cd1e233d77dd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9db5fb257433846520b7511362dfadc5/" rel="bookmark">
			java 图书管理系统 spring boot项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java 图书管理系统ssm框架 spring boot项目
功能有管理员模块：图书管理，读者管理，借阅管理，登录，修改密码
读者端：可查看图书信息，借阅记录，登录，修改密码
技术：spring boot spring mybatics jsp mysql 。
环境：idea,mysql5.7,java1.8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473720ef599066ef03a25c7f33f5be01/" rel="bookmark">
			【Sa-Token】SpringBoot 整合 Sa-Token 快速实现 API 接口签名安全校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在涉及跨系统接口调用时，我们容易碰到以下安全问题：
请求身份被伪造请求参数被篡改请求被抓包，然后重放攻击 sa-token api-sign 模块将帮你轻松解决以上难题。（此插件是内嵌到 sa-token-core
核心包中的模块，开发者无需再次引入其它依赖，插件直接可用）
假设我们有如下业务需求：
用户在 A 系统参与活动成功后，活动奖励以余额的形式下发到 B 系统。
1. 初始方案：直接裸奔 在不考虑安全问题的情况下，我们很容易完成这个需求：
1、在 B 系统开放一个接口
@RestController @RequestMapping("/sign") public class SignController { @PostMapping("/addMoney") public String addMoney(Long userId, Long money) { // TODO 处理业务... return "ADD SUCCESS"; } } 2、在 A 系统使用 http 工具类调用这个接口
@RestController @RequestMapping("/activity") public class ActivityController { @PostMapping("/join") public String join() { // 参加完活动后，发送余额 Long userId = 1L; Long money = 100L; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/473720ef599066ef03a25c7f33f5be01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74066413b0f5a4722018d0743b2a2ece/" rel="bookmark">
			js中 window.top , window.parent , window.self 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在应用有frameset或者iframe的页面时，parent是父窗口，top是最顶级父窗口（有的窗口中套了好几层frameset或者iframe），self是当前窗口， opener是用open方法打开当前窗口的那个窗口。
1，window.self window.self 功能：是对当前窗口自身的引用。它和window属性是等价的。
语法：window.self
注：window、self、window.self是等价的。
2，window.top window.top 功能：返回顶层窗口，即浏览器窗口。
语法：window.top
注：如果窗口本身就是顶层窗口，top属性返回的是对自身的引用。
3，window.parent window.parent 功能：返回父窗口。
语法：window.parent
注：如果窗口本身是顶层窗口，parent属性返回的是对自身的引用。
在框架网页中，一般父窗口就是顶层窗口，但如果框架中还有框架，父窗口和顶层窗口就不一定相同了。
判断当前窗口是否在一个框架中 &lt;script type="text/javascript"&gt; var b = window.top!=window.self; document.write( "当前窗口是否在一个框架中："+b ); &lt;/script&gt; 你应当将框架视为窗口中的不同区域，框架是浏览器窗口中特定的部分。一个浏览器窗口可以根据你的需要分成任意多的框架，一个单个的框架也可以分成其它多个框架，即所谓的嵌套框架。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b488d683aeee7c5c33933b1c35cc4e6/" rel="bookmark">
			vue中使用stomp.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 STOMP即Simple (or Streaming) Text Orientated Messaging Protocol，简单(流)文本定向消息协议，它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单，易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。
安装使用： 1,在项目中通过 npm i stompjs 下载stompjs包 2,在需要使用stomp进行通信的vue页面中引入 import Stomp from 'stompjs' 连接和订阅 确定连接的url 改url由后端给予，大致长：‘ws://xxx.xxx.com:8080/xxx/xxx’ 后面可能还会带有要传的内容，如token等，请自行拼接该字符串通过该url进行连接，这一步将会使浏览器和服务器之间产生ws连接
stompjs提供了以下方法进行连接： // 连接 // 三个参数分别是header，连接成功的回调，失败的回调 // header中的内容如果后端没有强调，可以直接为 {} client.connect(headers, connectCallback, errorCallback) // 订阅 两个参数分别是 主题 回调 返回一个订阅对象 包含了 订阅id 取消订阅的方法 unsubscribe client.subscribe("/queue/test", callback) // 实例 let client = null let subscription = null let url = 'xxx.xxx.xxx:xxx/xxx/xxx?xxx=xxx' function initWs(){ client = Stomp.client(url) // 创建stomp对象 client.connect( {}, (res)=&gt;{ // 连接成功，此时可以在network中看到建立了ws连接 // 在这里进行订阅 主题由后端提供 const topic = '/xxxx/xxxx/xxxx subscription = client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b488d683aeee7c5c33933b1c35cc4e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a322378cf14f8a17d34947c13e3efdb/" rel="bookmark">
			测试pytorch（GPU）安装，并输出版本号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
GPU版本pytorch安装测试
CUDA信息显示
GPU版本pytorch安装测试 我们一般完成pytorch(GPU)版本后，要进行测试，以下代码用于备注：
import torch flag = torch.cuda.is_available() print(flag) ngpu= 1 device = torch.device("cuda:0" if (torch.cuda.is_available() and ngpu &gt; 0) else "cpu") print(device) print(torch.__version__) print(torch.cuda.get_device_name(0)) print(torch.rand(3,3).cuda()) 测试结果如下： True
cuda:0
2.0.0+cu118
NVIDIA GeForce RTX 3090
tensor([[0.0756, 0.7062, 0.6051],
[0.2772, 0.5758, 0.3481],
[0.4451, 0.9666, 0.9337]], device='cuda:0')
CUDA信息显示 在CUDA后续的更新中，windows系统的任务管理器看不见CUDA占用了，在Ubuntu中同样无法看见，需要在命令行窗口输入：
nvidia-smi 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf01cd7cc6c6effa536612399ab89ef0/" rel="bookmark">
			通用CI/CD软件平台TeamCity全新发布v2023.11——增强Git托管平台的集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TeamCity是一个通用的 CI/CD 软件平台，可以实现灵活的工作流、协作和开发做法。我们的解决方案将帮助在您的 DevOps 流程中成功实现持续集成、持续交付和持续部署。
TeamCity 2023.11正式版下载
TeamCity 2023.11 带来了矩阵构建和构建缓存等多项备受期待的功能，这些功能将帮助您更轻松地配置构建。新版本增强了与 Git 托管平台的集成，包括 GitHub、GitLab、Bitbucket 和 Azure DevOps，支持更便捷的身份验证选项。同时还为 EC2 和 S3 插件完全重做的 UI 简化了这些 Amazon 服务的使用过程。
使用矩阵构建 借助 TeamCity 中的矩阵构建，您可以定义参数和相应值的组合来创建构建矩阵。 每个参数值组合都会生成一个独特构建。 然后，多个并行运行的构建组成矩阵构建。
构建缓存助力“缩短、重用、回收” 新版本构建缓存会下载项目依赖的文件并在项目中重用，帮助优化 CI/CD 构建时间。
漫游云端：EC2 和 S3 插件更新 在 2023.11 版本中彻底重做了设置云配置文件和镜像的方式，新 UI 将引导您完成整个过程，并提供相关的设置选项建议。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f977845eca7be80b003468dfd823e5b/" rel="bookmark">
			仓储物流系统架构平台的设计与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着电子商务和供应链管理的迅速发展，仓储物流系统在现代商业中扮演着至关重要的角色。一个高效、稳定的仓储物流系统能够极大地提升企业的运营效率和客户满意度。本篇博客将探讨仓储物流系统架构平台的设计与实践，介绍其核心组成和关键考虑因素。
### 1. 系统架构概述
一个典型的仓储物流系统通常包括以下核心模块：
- 订单管理：处理订单信息，包括接收、处理、分配和跟踪订单状态。
- 库存管理：管理物品的入库、出库、库存盘点等操作。
- 物流配送：负责物流路线规划、运输工具调度、货物配送等功能。
- 数据分析与报告：收集、分析和报告关于仓储物流活动的数据，为决策提供支持。
### 2. 系统架构设计考虑因素
在设计仓储物流系统架构时，需要考虑以下因素：
#### 2.1 可伸缩性
系统需要支持不断增长的业务规模，因此应具备良好的可伸缩性，能够随着业务需求的增长而扩展。
#### 2.2 实时性
对于订单处理和物流配送等功能，系统需要具备实时性，能够快速响应并处理大量的实时数据。
#### 2.3 数据安全
仓储物流系统涉及大量敏感数据，包括订单信息、库存数据等，因此需要采取严格的数据安全措施，确保数据的保密性和完整性。
#### 2.4 故障容忍性
作为关键的业务系统，仓储物流系统需要具备良好的故障容忍性，能够在硬件或软件故障时保持稳定运行。
### 3. 实践案例：基于微服务架构的仓储物流平台
近年来，微服务架构在仓储物流系统中得到了广泛的应用。通过将系统拆分为多个独立的微服务，可以更好地实现系统的可伸缩性和故障容忍性。
#### 3.1 订单管理微服务
负责处理订单相关的逻辑，包括订单接收、处理、状态更新等功能。
#### 3.2 库存管理微服务
管理物品的入库、出库、库存盘点等操作，并与订单管理微服务进行交互。
#### 3.3 物流配送微服务
负责规划物流路线、调度运输工具，并实现货物的实时跟踪和配送。
#### 3.4 数据分析与报告微服务
收集并分析各个微服务产生的数据，生成报告并提供数据分析功能。
### 4. 总结
仓储物流系统的设计与实践需要综合考虑业务需求、系统性能和安全性等方面的因素。采用微服务架构可以帮助系统更好地满足业务需求，并具备良好的可伸缩性和故障容忍性。随着技术的不断发展，仓储物流系统架构平台也将不断演进，为企业提供更高效、稳定的仓储物流解决方案。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/3/">«</a>
	<span class="pagination__item pagination__item--current">4/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/5/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>