<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d1abfd798c1a147a7fda2ba53ae4cd/" rel="bookmark">
			【剑指Offer系列03】数组中重复的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目代码PythonC++ 题目 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例 1：
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3
限制：
2 &lt;= n &lt;= 100000
代码 Python # 思路： # 原地置换，注意题干“长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内” # 复杂度： # O(N),空间复杂度只有O(1) class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: i = 0 # 遍历数组 while i&lt;len(nums): if nums[i]==i: # 索引与其对应的值相等 i+=1 continue if nums[nums[i]] == nums[i]: return nums[i] # 重复数 nums[nums[i]], nums[i] = nums[i], nums[nums[i]] # 原地置换，注意顺序 return -1 # 无重复数 C++ class Solution { public: int findRepeatNumber(vector&lt;int&gt;&amp; nums) { for(int i = 0; i &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2d1abfd798c1a147a7fda2ba53ae4cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f93c97d78ebe345a1c3d4b64f1ec3ce/" rel="bookmark">
			LRU算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LRU算法：最近最少使用算法。大意就是根据最近访问的记录，对缓存的数据进行淘汰。如果一个数据最近被访问，或经常访问。则把数据放到列表的前面，而数据很久未访问，或者访问率较低，就会被放在后面，在列表内存不足的时候，将其移除缓存列表。
#include &lt;iostream&gt; #include &lt;unordered_map&gt; #include &lt;algorithm&gt; using namespace std; //双向链表结构 struct DLinkedNode { //保存一个key，value对 int key, value; DLinkedNode* prev; DLinkedNode* next; DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {} DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {} }; class LRUCache { private: //哈希结构，保存键值映射 unordered_map&lt;int, DLinkedNode*&gt; cache; //双向链表头尾结点 DLinkedNode* head; DLinkedNode* tail; //存在多少结点 int size; //容量，总共可以保存多少结点 int capacity; public: LRUCache(int _capacity): capacity(_capacity), size(0) { head = new DLinkedNode(); tail = new DLinkedNode(); head-&gt;next = tail; tail-&gt;prev = head; } int get(int key) { //cache.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f93c97d78ebe345a1c3d4b64f1ec3ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b01fc2b36cd91af6348edf9adbe233/" rel="bookmark">
			初识HTML（四）——style属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		style是一种新的首选的改变 HTML 元素样式的方式。通过 HTML 样式，能够通过使用 style 属性直接将样式添加到 HTML 元素，或者间接地在独立的样式表中（CSS 文件）进行定义。 修改背景颜色和字体
&lt;html&gt; &lt;body style="background-color:PowderBlue;"&gt; &lt;h1&gt;Look! Styles and colors&lt;/h1&gt; &lt;p style="font-family:verdana;color:red"&gt; This text is in Verdana and red&lt;/p&gt; &lt;p style="font-family:times;color:green"&gt; This text is in Times and green&lt;/p&gt; &lt;p style="font-size:30px"&gt;This text is 30 pixels high&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; style应用实例：
1.修改背景颜色
&lt;html&gt; &lt;body style="background-color:yellow"&gt; &lt;h2 style="background-color:red"&gt;This is a heading&lt;/h2&gt; &lt;p style="background-color:white"&gt;This is a paragraph.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 2.标签的字体颜色和尺寸
style属性的多个分属性的数值需要‘；’来间隔。
&lt;html&gt; &lt;body&gt; &lt;h1 style="font-family:verdana"&gt;A heading&lt;/h1&gt; &lt;p style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4b01fc2b36cd91af6348edf9adbe233/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/682b3171a9c20dfc7da9ffdd85b8be74/" rel="bookmark">
			安全测试知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安全测试的定义：
验证被测对象的安全保护机制能否在实际应用中保护系统不受非法侵入，用来保证系统本身数据的完整性和保密性。
安全性测试方法：
1.功能验证
采用黑盒测试方法，对涉及安全的软件功能，如：用户管理模块、权限管理模块、加密系统、认证系统等进行测试。
2.漏洞扫描
漏洞扫描器分为主机漏洞扫描器和远程漏洞扫描器
主机漏洞扫描器是在系统本地运行检测系统漏洞的程序，如（COPS、Tripewire、Tiger）.远程漏洞扫描器是网络远程检测目标网络和主机系统漏洞的程序，如（Satan、ISS、Internet、Scanner）.
3.模拟攻击实验
“授权”、“非授权”
安全测试工具：
AWVS （ Acunetix Web Wulnerability Scanner）是一个自动化的Web 应用程序安全测试工具，它可以扫描任何可通过Web 浏览器访问的和遵循 HTTP/HTTPS 规则的 Web站点和 Web应用程序、国内普遍简称WVS。
HP WebInspect 可提供快速扫描功能、广泛的安全评估范围及准确的 Web 应用程序安全扫描结果。它可以识别很多传统扫描程序检测不到的安全漏洞。利用创新的评估技术，例如同步扫描和审核 (simultaneous crawl and audit, SCA) 及并发应用程序扫描，您可以快速而准确地自动执行 Web 应用程序安全测试和 Web 服务安全测试。WebInspect是最准确和全面的自动化的Web应用程序和Web服务漏洞评估解决方案。
AppScan对现代 Web 应用程序和服务执行自动化的动态应用程序安全测试(DAST) 和交互式应用程序安全测试 (IAST)。支持 Web 2.0、 JavaScript 和 AJAX 框架的全面的 JavaScript 执行引擎。涵盖 XML 和 JSON 基础架构的 SOAP 和 REST Web 服务测试支持 WSSecurity 标准、 XML 加密和 XML 签名。详细的漏洞公告和修复建议。40 多种合规性报告，包括支付卡行业数据安全标准 (PCI DSS)、支付应用程序数据安全标准 (PA-DSS)、 ISO 27001 和 ISO 27002，以及 Basel II
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/682b3171a9c20dfc7da9ffdd85b8be74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fcbc58c09406f14496f20e089480314/" rel="bookmark">
			华为认证HCIE考试认证相关问题解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很多人咨询小誉会问HCIE笔试，LAB，面试相关问题，今天小誉就给大家来解答下：
笔试 试卷题型: 单选、多选、判断 考试时长: 90min 及格分/总分: 600/1000 考试费用: 300USD 考试语言: 中文,英文 实验 试卷题型: 操作 考试时长: 480min 及格分/总分: 80/100 考试费用（实验&amp;面试）: 8000CNY 考试语言: 中文,英文 面试 试卷题型: 问答 考试时长: 60min 及格分/总分: 80/100 考试费用（实验&amp;面试）: 8000CNY 考试语言: 中文,英文 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80e60aa590e39d6ac690120ce39f70e9/" rel="bookmark">
			nodejs连接有密码的redis、连接有密码的mongoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nodejs连接redis redis版本5.0.6
nodejs依赖包redis版本2.6.2
import redis from 'redis' const redisLink = 'redis://127.0.0.1:6379' const pwd = '289181' const opts = { auth_pass: pwd, } const redisClient = redis.createClient(redisLink, opts) redisClient .on('error', err =&gt; console.log('------ Redis connection failed ------' + err)) .on('connect', () =&gt; console.log('------ Redis connection succeed ------')) export default { redis: redis, redisClient: redisClient, } nodejs连接mongoDB nodejs依赖包mongoose版本4.6.0 ; mongoomise版本0.0.8；bluebird版本3.4.6；
nodejs v12.13.0
mongoDB 版本4.2.1
在mongoDB中执行以下命令创建用户：
db.createUser({ user:'admin',pwd:'test123',roles:[ { role:'userAdminAnyDatabase', db: 'admin'}]}); nodejs连接代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80e60aa590e39d6ac690120ce39f70e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef4f2a96bd6274f91ee2ab234cb95a8f/" rel="bookmark">
			uniapp 工作经验:详情页样式(哪些样式需要统一,哪些样式不需要封装)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题,待写
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6463ed479bc3d3fedaecef3785076b6b/" rel="bookmark">
			SemEval 2014数据集预处理：Python xml.etree.cElementTree解析XML文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做Aspect-level情感分类时一般会用到SemEval 2014数据集。官网给的数据集都是XML格式，我们要对其进行解析。
首先看一下数据结构。
一个XML文件里包含多个sentence，每个sentence里包含text、aspectCategories和aspectTerms子节点，即我们需要提取出来的内容。
下面是代码。
首先，导入库。
import xml.etree.cElementTree as ET Python标准库中，提供了ElementTree的两种实现。一个是纯Python实现的xml.etree.ElementTree，另一个是速度更快的C语言实现的xml.etree.cElementTree。第二种速度更快，而且内存消耗较少。
接下来读文件，获取根节点。
path = 'data/restaurants-trial.xml' tree = ET.parse(path) root = tree.getroot() 子节点是嵌套的，我们可以通过索引访问特定的子节点。
如：
root[0][0].text 输出是第一个sentence中text节点的内容。
然后获取XML中的元素，保存到数组中即可。
获取aspectCategory data = [] for sentence in root.findall('sentence'): text = sentence.find('text').text aspectCategories = sentence.find('aspectCategories') for aspectCategory in aspectCategories.findall('aspectCategory'): category = aspectCategory.get('category') polarity = aspectCategory.get('polarity') data.append((text, category, polarity)) Element.findall(): 只找到带有标签的元素，该标签是当前元素的直接子元素。
Element.find() :找到第一个带有特定标签的子元素。
Element.text:访问标签的内容
Element.get()：访问标签的属性值
也可以转化成dataframe，保存到csv文件里。
df=pd.DataFrame(data,columns=['text','category','polarity']) df.to_csv('data/data.csv',sep=' ') df.head() 提取aspectTerms 提取aspectTerms和提取aspectCategories有一点不同，即并不是每个sentence都有aspectTerms节点，因此我们不能直接查找所有sentence的aspectTerms节点。那么解决方法是什么呢。这里就要用到强大的xpath表达式了，’.//aspectTerms/…'的含义是选择所有包含aspectTerms的sentence节点，其中“//”表示从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。“…”表示选择当前节点的父节点。
data=[] for sentence in root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6463ed479bc3d3fedaecef3785076b6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63226087d392587bfaad9e9219f0a4ed/" rel="bookmark">
			IDEA中maven的Dependencies中出现红色波浪线问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA中maven的Dependencies中出现红色波浪线问题分析 IDEA-Maven的Dependencies中出现红色波浪线解决方法总结 IDEA-Maven的Dependencies中出现红色波浪线 我们使用maven管理项目依赖时，在导入依赖后，IDEA右边的maven管理窗口的Dependencies会出现红色波浪线，原因可能是多个地方引用同一jar包，或者引用同一jar包，但引用版本不同（groupId和artifactId相同，但version不同）。
解决方法 方法1 ：可在pom文件中删除引用，保存后，带引用红色消失，再撤销删除，最后需要引用的包依然会被导入，但红色波浪就会消失，网上很多方案介绍操作也是如此。
方法2：分析依赖关系，修改POM文件依赖版本，选择排除冲突的依赖包。
总结 红色的波浪线并不会影响项目的正常运行，可能会使一些有强迫症的同学有点看不惯，遇到红色就想去除，以上方法仅供参考，如有错误，请指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5957116d8694723537bf795d409b1872/" rel="bookmark">
			OpenCV-C&#43;&#43;-CUDA-05-高斯双边加速，实时美颜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章我们继续使用OpenCV-C++版本在CUDA下的编程应用，主要使用双边模糊，对图像进行美颜细化。
1、高斯双边模糊 int main(int argc, char** argv) { Mat image = imread("F:/test/face_image.jpg"); imshow("input image", image); cuda::GpuMat image_gpu,dst; image_gpu.upload(image); //高斯双边模糊 cuda::bilateralFilter(image_gpu, dst, 0, 100, 15, 4); Mat result; dst.download(result); imshow("result", result); waitKey(0); return 0; } 原图：
模糊处理后的结果：
看上去效果还不错，脸上的坑坑洼洼都被去掉了。
当然，除了图片以外，还可以使用视频或摄像头：
void video_test_gpu() { VideoCapture cap(0); Mat frame,result; cuda::GpuMat frame_gpu,dst_gpu; while (true) { double t1 = getTickCount(); cap.read(frame); frame_gpu.upload(frame); cuda::bilateralFilter(frame_gpu, dst_gpu, 0, 50, 10, 4); dst_gpu.download(result); double fps = getTickFrequency()/(getTickCount() - t1); putText(result, format("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5957116d8694723537bf795d409b1872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52d21b82895e309ff126ce5638c3dc9e/" rel="bookmark">
			IDEA RUST插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [IDEA RUST插件](https://plugins.jetbrains.com/plugins/nightly/8182) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/943729cb6f0c752073ac750d49627d34/" rel="bookmark">
			MyBatis-Plus 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、MyBatis-Plus
1、简介
2、使用 SpringBoot 快速使用 MyBatis-Plus
二、Mybatis-Plus 常用操作
1、配置日志
2、简单认识一下常用注解
3、代码生成器
4、自动填充数据功能
5、逻辑删除
6、分页插件的使用
7、乐观锁的实现
三、Mybatis-Plus CRUD 操作简单了解一下
1、Mapper 接口方法（CRUD）简单了解一下
2、Service 接口方法（CRUD）简单了解一下
3、条件构造器（Wrapper，定义 where 条件）
一、MyBatis-Plus 1、简介 MyBatis-Plus 是一个 Mybatis 增强版工具，在 MyBatis 上扩充了其他功能没有改变其基本功能，为了简化开发提交效率而存在。
官网文档地址：
https://mp.baomidou.com/guide/
MyBatis-Plus 特性：
https://mp.baomidou.com/guide/#%E7%89%B9%E6%80%A7
2、使用 SpringBoot 快速使用 MyBatis-Plus （1）准备工作
需要 Java 开发环境（JDK）以及相应的开发工具（IDE）。
需要 maven（用来下载相关依赖的 jar 包）。
需要 SpringBoot。
可以使用 IDEA 安装一个 mybatis-plus 插件。
（2）创建一个 SpringBoot 项目。
方式一：去官网 https://start.spring.io/ 初始化一个，然后导入 IDE 工具即可。
方式二：直接使用 IDE 工具创建一个。 Spring Initializer。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/943729cb6f0c752073ac750d49627d34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f5928fe83087bf5c12c87461be8557/" rel="bookmark">
			【LeetCode】从尾到头反过来返回每个节点的值（用数组返回）day03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制： 0 &lt;= 链表长度 &lt;= 10000 第一次
//使用栈的特性先进后出 //复杂度O（n） public int[] reversePrint(ListNode head) { Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); ListNode temp = head; while(temp!= null){ stack.push(temp); temp = temp.next; } int[] result = new int[stack.size()]; for(int i = 0 ; i&lt; stack.size();i ++ ){ result[i] = stack.pop().val; } return result; } //自己脑瓜子有点问题 public int[] reversePrint(ListNode head) { ListNode[] result = new ListNode[]; ListNode temp = head; int count = 0; while(temp !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8f5928fe83087bf5c12c87461be8557/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01cc082e6ec071fbd668d718abf54000/" rel="bookmark">
			户型图去水印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般的户型图上都是有各种水印的，在处理过程中可能会造成各种影响，这里提出一个简单的方法去水印：
#去水印 import cv2 import numpy as np img = cv2.imread('./pic/ceshi3.jpg') new = np.clip(2.0*img-160, 0, 255).astype(np.uint8) cv2.imwrite('./out/cleaned3.jpg', new) #这里面用到了np.clip()方法，如np.clip(a, 1,8)，它的作用是将a里面所有小于1的设置为1，如0&lt;1所以修改为1， 所有大于8的修改为8，
#最终保证数组里面的元素全部都在1~8之间。
#上面的代码使用np.clip()的作用就是保证经常计算后的img能够不越界，一致保持在[0,255]之间。
去水印之前：
去水印之后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c52ba0f47a31b644f720231635ad58b4/" rel="bookmark">
			vagrant 启动失败 There was an error while executing `VBoxManage`, a CLI used by Vagrant for controlli......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PS C:\Users\ben\ubuntu16&gt; vagrant up Bringing machine 'default' up with 'virtualbox' provider... ==&gt; default: Resuming suspended VM... ==&gt; default: Booting VM... There was an error while executing `VBoxManage`, a CLI used by Vagrant for controlling VirtualBox. The command and stderr is shown below. Command: ["startvm", "494f01d6-d48c-4682-9da0-01de843424a3", "--type", "headless"] Stderr: VBoxManage.exe: error: Failed to load unit 'lsilogicscsi' (VERR_SSM_LOADED_TOO_LITTLE) VBoxManage.exe: error: Details: code E_FAIL (0x80004005), component ConsoleWrap, interface IConsole https://github.com/hashicorp/vagrant/issues/9318
使用power shellhttps://stackoverflow.com/questions/34778147/cannot-boot-windows-guest-in-virtualbox-without-kernel-module-error 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d6c76caf47448ec219a84d97c8e774/" rel="bookmark">
			springboot中在方法上使用@Cacheable注解实现redis缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 平时大家使用redis一般都是直接存储key,value.
spring全家桶肯定帮大家想到了这一点.可以让大家方便的使用注解操作redis节省代码量.
把总结放前面:
总共有三种方式,底层利用了spring的aop,并且方法返回的对象一定要实现序列化
@Cacheable:注解于方法上,第一次会把后面的cacheNames+key 拼接为key,把返回值序列化后作为value set到redis中去.后面再一次访问相同的key的时候就直接从redis中取值了,不会再访问这个方法 @Override @Cacheable(cacheNames = "product",key = "#id") public ProductInfo findOne(String id) { return productInfoRepository.findById(id).orElse(null); } @CachePut:每次都会把方法的返回值序列化之后set到redis中去(每次都会执行方法),即更新这个key对应的值 @Override @CachePut(cacheNames = "product",key = "#productId") public ProductInfo onSale(String productId) { ProductInfo productInfo = this.findOne(productId); if(null == productInfo){ throw new SellException(ResultEnum.PRODUCT_NOT_EXIST); } if(productInfo.getProductStatusEnum().getCode() == ProductStatusEnum.UP.getCode()){ log.warn("[商品上架处理]-----商品已经是上架状态了,这里直接返回原ProductInfo={}",productInfo); }else { productInfo.setProductStatus(ProductStatusEnum.UP.getCode()); productInfo = this.save(productInfo); } return productInfo; } @CacheEvict:这个比较好理解,就是从redis中把这个key删除了 @Override @CacheEvict(cacheNames = "product",key = "#productInfo.productId") public ProductInfo save(ProductInfo productInfo) { return productInfoRepository.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36d6c76caf47448ec219a84d97c8e774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e93c8d27461a4aac43a245ec4233e27/" rel="bookmark">
			OpenCV-C&#43;&#43;-CUDA-02-图像基本操作之像素操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章继续学习CUDA下的OpenCV学习，主要是学习CUDA下图像的像素变换。
一、图像之间的加减乘除 (1) 图像相加
主要API：
cuda::add(input image1, input image2, output image)
需要相加的两张图片：
相关代码：
#include&lt;opencv2/opencv.hpp&gt; #include&lt;iostream&gt; using namespace cv; using namespace std; int main(int argc, char **argv) { Mat src1 = imread("D:/opencv/opencv_4.1.2/sources/samples/data/WindowsLogo.jpg"); Mat src2 = imread("D:/opencv/opencv_4.1.2/sources/samples/data/LinuxLogo.jpg"); imshow("input1", src1); imshow("input2", src2); //GPU操作 cuda::GpuMat g_src1, g_src2,dst; g_src1.upload(src1); g_src2.upload(src2); cuda::add(g_src1, g_src2, dst);//图像相加，每个通道的值分别相加（像素值超过255会等于255） Mat result; dst.download(result); imshow("reslut", result); waitKey(0); return 0; } 结果：
（2）图像相减
cuda::subtract(input image1, input image2, output image);
#include&lt;opencv2/opencv.hpp&gt; #include&lt;iostream&gt; using namespace cv; using namespace std; int main(int argc, char **argv) { Mat src1 = imread("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e93c8d27461a4aac43a245ec4233e27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4db87ea651027af023dd1f005eba5c18/" rel="bookmark">
			win10&#43;Anaconda&#43;pytorch&#43;CUDA10.1安装指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10+Anaconda+pytorch+CUDA10.1安装指南 一、电脑配置检查1. 检查电脑显卡类型2.设置首选图形处理器 二、安装CUDA1.NVIDIA开发者网站下载CUDA 10.12.安装CUDA 10.13.验证CUDA安装 三、安装cuDNN1.下载cuDNN2.安装cuDNN 四、安装Anaconda3 2019.102.配置方法：3.验证Anaconda安装 五、创建管理虚拟环境六、安装PyTorch CUDA版1.官网获取安装命令2.在PyTorchLearn虚拟环境中安装PyTorch3.文件下载太慢或者下载失败4.验证PyTorch安装 七、更新组件1.torch module无法调用2.Anaconda中ImportError: No module named 'matplotlib' 问题的解决 参考链接： 一、电脑配置检查 1. 检查电脑显卡类型 注意电脑显卡不是NVIDIA的忽略这一步，非NVIDIA显卡不能安装CUDA。
在桌面鼠标右键：
点击NVIDIA 控制面板-&gt;选择左下角 系统信息
可以看到第三行信息支持CUDA的，我的显卡是GTX1650，官网没有显示是否支持但是能安装CUDA
2.设置首选图形处理器 二、安装CUDA 1.NVIDIA开发者网站下载CUDA 10.1 https://developer.nvidia.com/cuda-downloads 根据自己的版本选择后下载
2.安装CUDA 10.1 双击运行cuda_10.1.243_426.00_win10.exe
设置用于提取CUDA安装程序的临时目录
提取完成后，经过一段漫长的兼容性检查
选择自定义安装
自定义安装选项的时候，CUDA是核心组件必须安装，如果NVIDIA GeForce Experience等组件的当前版本比新版本低可以选择安装。
选择安装位置一般不要更改默认位置
提示没有Visual Studio，可以不用理会，勾选并点击NEXT。（注意关闭安全软件，否则会失败）
安装完毕，结束
3.验证CUDA安装 打开命令行工具（win+r:运行 cmd）
输入nvcc -V (查看版本信息)，安装成功
三、安装cuDNN 1.下载cuDNN 官网： https://developer.nvidia.com/cudnn 下载需要登陆账号，登陆界面“Join”可以注册账号，若不想注册可以将下载链接复制到迅雷等其他下载器中下载。
根据自己的CUDA版本自行选择下载
2.安装cuDNN 解压下载的cudnn-10.1-windows10-x64-v7.6.5.32.zip压缩文件
将三个文件夹拷贝至CUDA 10.1的安装目录(安装CUDA时选择的安装位置)下
添加环境变量，系统变量-&gt;Path中新增C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1\lib\x64
四、安装Anaconda3 2019.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4db87ea651027af023dd1f005eba5c18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/084692b68f943a2f131e4b4d79579fff/" rel="bookmark">
			Android Notification自定义View注意事项（View显示不出来/无法显示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天在调试后台播放使用自定义Notification显示播放曲目及控制面板，发现一直显示不出来。后面发现是使用了ConstraintLayout的原因，将其改为常用的LinearLayout或RelativeLayout就可以正常显示了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193effccf07ba8c52706f949f9906258/" rel="bookmark">
			【剑指Offer系列07】重建二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目代码PythonC++ 题目 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如，给出
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
3
/ 9 20
/ 15 7
限制：
0 &lt;= 节点个数 &lt;= 5000
代码 Python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None # 思想： # 1.得到前序根结点 # 2.搜索根节点在中序索引,划分左右子树 # 3.分别递归遍历左右子树 # 复杂度：O(N),N是节点数量,前提是建立哈希表再搜索根节点在中序索引会是O(1),以空间换时间 class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/193effccf07ba8c52706f949f9906258/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/167/">«</a>
	<span class="pagination__item pagination__item--current">168/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/169/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>