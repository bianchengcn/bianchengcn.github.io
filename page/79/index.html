<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbea40a4d0094a3c4c62cf61d9899429/" rel="bookmark">
			A very lightweight and efficient image super-resolution network
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A very lightweight and efficient image super-resolution network 非常轻量级和高效的图像超分辨率网络 1、摘要
深度卷积神经网络显著提高了单图像超分辨率 （SISR） 的性能。通常，较大的网络（即更深和更宽）具有更好的性能。然而，更大的网络需要更高的计算和存储成本，这限制了它们在资源受限设备上的应用。非常需要参数更少、计算工作量更小的轻量级 SISR 网络。关键挑战是在模型复杂性和性能之间取得更好的平衡。在本文中，我们提出了一种非常轻量级和高效的SISR网络。我们的主要贡献包括：（1）提出频率分组融合块（FGFB），可以更好地融合高/低频特征信息;（2）提出一种多向注意力块（MWAB），可以利用特征信息的多种不同线索;（3）提出轻量级残差级连块（LRCB），可以结合残差连接和信道级联的优点;（4）提出一种用于图像超分辨率的轻量级卷积块（LConv），可以显著减少参数数量;（5）提出一种渐进式交互群卷积（PIGC），比传统的群卷积更有效。大量的实验结果表明，我们的方法明显优于目前可用的其他最先进的方法，在模型复杂性和性能之间取得了更好的平衡。
2、引言
单图像超分辨率（SISR）（Freeman，Pasztor和Carmichael，2000）是计算机视觉领域的经典任务，旨在从相应的低分辨率（LR）对应物中恢复高分辨率（HR）图像。它具有广泛的应用，例如视频监控（Zou &amp; Yuen，2012），医学诊断（Shi等人，2013）和遥感成像（Thornton，Atkinson，&amp;Holland，2006）。
卷积神经网络（CNN）（Dong， Loy， He， &amp; Tang， 2014）显著提高了SISR的性能，并主导了当前对SISR的研究。然而，基于CNN的SISR方法在很大程度上取决于网络的大小，即网络的深度（层数）和宽度（通道数）。较大的SISR网络更具表现力，通常具有更好的性能。例如，EDSR（Lim，Son，Kim，no，&amp;Mu Lee，2017）有65个卷积层和43个M参数，RCAN（Zhang，Li等人，2018）有400多个卷积层和16个M参数。虽然EDSR和RCAN等方法具有良好的性能，但它们需要很高的计算和内存成本，并且难以应用于资源有限的设备（例如移动电话）。轻量级SISR网络（通常被认为具有小于1 M的参数）是非常可取的。当前的SISR方法，特别是轻量级的SISR方法，面临着一个共同的挑战：由于纹理等高频信息的丢失，重建的超分辨率（SR）图像经常遭受模糊和失真（Ahn，Kang，&amp;Sohn，2018）。
当前SISR方法使用的网络架构主要包括残差连接（Lim等人，2017），密集连接（Zhang，Tian，Kong，Zhong&amp;Fu，2018）和通道注意机制（Zhang，Li等人，2018），它们主要删除了流行的批量归一化和池化层（Huang等人，2021，Lim等人，2017）中的分类网络（He， Zhang， Ren， &amp; Sun， 2016），以减少特征信息的丢失，提高特征信息的利用率和表达能力。常见的密集连接方案（Zhang， Tian et al.， 2018），如图1（a）所示。提取的层次特征连接在一起。Qiu， Wang， Tao， and Cheng （2019） 表明，SISR网络的浅层特征包含更多的低频信息，深层特征包含更多的高频信息。低频信息由更简单的结构和纹理组成，其中需要更简单的功能来恢复它们;高频信息由复杂的结构和纹理组成，需要更复杂的恢复功能。残差和密集连接并不是将浅层信息传递到深层的最佳方式，因为深层容易过度拟合低频信息，导致恢复图像失真。最近，Luo等人（2020）提出了一种新的向后顺序连接方案，如图1（b）所示。采用1×1卷积层将每个FEB输出的特征通道数减少一半，降维特征从后到前逐渐串联，可以更好地还原SR图像中的高频信息。
在本文中，我们提出了一种非常轻量级和高效的图像超分辨率网络（VLESR）。我们的核心贡献是，主要受到Luo等人（2020）工作的启发，我们建议将高频/低频特征成对分组和融合，以更好地利用特征信息。低频和高频之间差异最大的特征构成第一组，差异次高的特征形成第二组，依此类推。然后，从频率差最小的特征组开始，逐渐融合各组的特征，直到频率差最大的特征组。此外，我们提出了一种多路注意力块（MWAB）来挖掘特征信息的多个不同线索。为了使我们的模型足够轻量级和有效，我们提出了轻量级残差级联块（LRCB），轻量级卷积块（LConv）和渐进式交互群卷积（PIGC）。我们工作的贡献可归纳如下：
提出一种非常轻量级和高效的图像超分辨率网络（VLESR），它在复杂性和性能之间取得了更好的平衡，并且优于其他最先进的方法（请参阅图2）。
•
提出一种分组融合块（FGFB），可以更好地融合高频和低频特征信息。
•
提出一种多向注意力块（MWAB），可以利用特征信息的多种不同线索。
•
提出一种轻量级残差级联块（LRCB），它可以结合残差连接和信道级联的优点。
•
提出一种用于图像超分辨率的轻量级卷积块（LConv），可以显著减少参数数量。
•
提出渐进式交互式群卷积（PIGC），比传统的群卷积更有效。
本文的其余部分组织如下。在第2节中，我们回顾了相关工作。第 3 节描述了我们的方法。第4节说明了详细的实验结果以及与其他最新方法的比较。第5节结束了本文。为便于阅读，表1总结了本文的主要缩写。
3、相关
3.1. 基于CNN的轻量级SISR方法 Dong等人（2014）提出了第一个基于CNN的SISR方法，称为SRCNN。SRCNN仅包含三个卷积层，端到端地学习LR和HR图像之间的非线性映射，并优于传统的SISR方法。Kim，Kwon Lee和Mu Lee（2016a）提出了VDSR，它使用跳过连接来学习残差信息，并将卷积层的数量增加到20个，这进一步提高了SISR的性能。一般来说，更深（更多的卷积层）和更宽（更多的特征通道）网络具有更大的表达能力，可以提高SISR的性能。Lim等人提出的EDSR（Lim等人，2017）有65个卷积层。Zhang， Li et al. （2018） 提出的 RCAN 具有 400 多个卷积层。较大的网络需要更高的计算和内存成本，并且难以应用于资源受限的设备（例如手机）。非常需要轻量级 SISR 网络（具有低计算和内存要求）。Kim等人提出的DRCN（Kim，Kwon Lee和Mu Lee，2016b）将递归结构引入SISR任务，其中卷积层的参数是共享的。递归结构可以在不增加参数数量的情况下构建更深的网络，但不能减少计算工作量。 Ahn等人提出的CARN（Ahn等人，2018）是一个级联残差网络，它使用组卷积来减少参数数量和计算工作量。 Hui等人提出的IMDN（Hui， Gao， Yang， &amp; Wang， 2019）使用信息蒸馏（拆分和聚合操作）来提取分层特征，以减少参数数量和计算工作量。刘等人提出的RFDN（Liu， Tang &amp; Wu， 2020）进一步改进了IMDN的信道拆分，更加轻量级有效。最近，Zhao， Kong， He， Qiao， and Dong （2020） 提出了一种非常轻量级的模型，称为 PAN。PAN使用轻量级自校准卷积（Liu，Hou等人，2020）作为基本构建块，并且还使用1×1卷积来构建非常轻量级的像素注意力（PA）块。在本文中，我们设计了一种新的轻量级高效构建块，可以显着减少参数数量和计算工作量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbea40a4d0094a3c4c62cf61d9899429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/661d3af0eb1321af96b3e0ff9b5e6e08/" rel="bookmark">
			使用8086汇编语言设计洗衣机及proteus仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用8086汇编语言设计洗衣机的过程包括以下几个步骤:
首先，你需要确定洗衣机的功能和要求，并确定你希望在洗衣机中使用哪些传感器和电机。
然后，你需要设计洗衣机的硬件系统，包括选择合适的单片机、传感器和电机，并设计电路板。
之后，你需要使用8086汇编语言编写控制代码，该代码负责控制洗衣机的传感器和电机，并实现洗衣机的功能。
最后，你可以使用Proteus软件进行仿真，验证你的设计是否正确。
在使用Proteus进行仿真时，你需要导入你设计的电路板模型和控制代码，然后运行仿真，查看系统的运行情况。如果发现问题，你可以回到前面的步骤进行调试和修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a983449bffcc283424f4e49e2345fee/" rel="bookmark">
			LeetCode 1223. 掷骰子模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode 1223. 掷骰子模拟
暴力递归
const int MOD = 1e9 + 7; class Solution { public: int n; vector&lt;int&gt; rm; int dfs(int u, int last, int rest) { if(u == n) return 1; int res = 0; for(int i = 0; i &lt; 6; i ++) { if(last != i) res = (res + dfs(u + 1, i, rm[i] - 1)); else if(rest) res = (res + dfs(u + 1, i, rest - 1)); } return res; } int dieSimulator(int n, vector&lt;int&gt;&amp; rollMax) { this -&gt; n = n; rm = rollMax; int res = 0; for(int i = 0; i &lt; 6; i ++) res = (res + dfs(1, i, rollMax[i] - 1)); return res; } }; 记忆化搜索
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a983449bffcc283424f4e49e2345fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a753bad567a489e9aed9cd0237d075/" rel="bookmark">
			OpenWrt设置外网访问WEB及SSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置SSH访问，点击System -&gt; Administration，修改端口2200（也可不修改），勾选下面3个选项
设置防火墙，Network -&gt; Firmware，将Zone中的wan一栏中的input、Output、Forward全部设置为accept，外网访问才不会被拦截
设置端口转发，Network -&gt; Firmware -&gt; Port 方法
嗯嗯
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f559ade6a1ac6875bb35731ccc415968/" rel="bookmark">
			OpenWrt设置无线桥继教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击NetWork-Wifi，点击Scan进行扫描、
选择网络Join NetWork
如下图则表示连接完成
点击Add，然后配置AP
设置密码
打完收工
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5093f62617e58dad1637be9abd7fb9d/" rel="bookmark">
			Node.js笔记-简介和安装，fs模块，path模块和http模块的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
node.js的简介和安装 简介
安装
在Node.js环境中打印"hello,node.js"
node内置模块-fs模块
readFile()-读取指定文件内容
writeFile()-读取指定文件内容
路径动态拼接的问题
node内置模块-path模块
path.join()-将多个路径进行拼接
path.basename()-获取路径中的文件名
node内置模块-http模块
创建web服务器
request请求对象和response响应对象
根据请求URL不同进行方法分发
将URL映射为本地后输出
node.js的简介和安装 简介 什么是node？
node.js是JavaScript的运行环境，将JS代码放到node环境中，就可以使用node.js提供的内置API，内置API可以对文件，数据库内容进行操作，还可以创建web服务器等许多功能的实现，这样，使用JS代码放到node环境中运行将可以做后端开发。
提到运行环境，node.js环境中不能操作DOM或BOM结构，因为node.js环境不提供操作DOM或BOM的内置API。我们在浏览器环境可以操作DOM或BOM结构是因为在浏览器环境中提供了操作DOM或BOM的内置API。
虽然在node.js环境中不能操作DOM或BOM结构，但是并不影响我们使用node.js的真实需求，我们使用node.js环境是做后端开发，是对数据库的数据操作和web服务器的创建及提供请求接口等功能。所以并不需要在node.js中操作DOM或BOM结构。
总结:使用javascript这个语言通过在node.js环境中执行做了后端的开发工作。
安装 node.js的安装非常简单，我们先到node.js官网。
我们下载LTS版本（稳定版），下载好后打开安装程序，无脑点击下一步即可。
检查是否安装成功
安装好了以后，我们打开命令行，输入node -v（查看版本），出现版本号就算安装成功。
在Node.js环境中打印"hello,node.js" 想要在node.js环境打印东西，那么我们就需要创建一个js文件，并且在node.js环境中运行。
// 在js文件中书写 console.log("hello,node.js"); 命令行执行 node 文件名
node内置模块-fs模块 说明：fs模块是node内置的模块，可以看作是node内置的一类API。
fs模块作用：主要用来操作文件，模块中提供了一系列的方法和属性，用来对文件的各种操作。
模块的导入：
// js文件中导入模块方式 const fs = require("fs"); readFile()-读取指定文件内容 方法参数说明
//前提需要先导入模块 fs.readFile(path,[,options],callback)
path:必选，文件路径
[options]:可选，指定编码格式
callback:必选，回调函数，获取读取结果。
使用 需求，定义一个文件"hello.txt"，使用方法fs.readFile()进行读取。
// 导入模块方式 const fs = require("fs"); fs.readFile("./hello.txt","utf-8",(err,datastr)=&gt;{ if(err){return console.log("读取失败!")} console.log("读取成功!数据为",datastr); }) 回调函数的参数说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5093f62617e58dad1637be9abd7fb9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87a5b192ed56535cbfd4958f920f7dcd/" rel="bookmark">
			QT中完成文本编辑器的文件另存功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		widget.h:
#ifndef WIDGET_H #define WIDGET_H #include&lt;QFont&gt; #include &lt;QWidget&gt; #include&lt;QColor&gt; #include&lt;QColorDialog&gt; #include&lt;QFontDialog&gt; #include&lt;QFile&gt; #include&lt;QFileDialog&gt; QT_BEGIN_NAMESPACE namespace Ui { class Widget; } QT_END_NAMESPACE class Widget : public QWidget { Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); private slots: void on_font_clicked(); void on_calor_clicked(); void on_openbtn_clicked(); void on_savebtn_clicked(); private: Ui::Widget *ui; }; #endif // WIDGET_H widget.cpp:
#include "widget.h" #include "ui_widget.h" #include&lt;QMessageBox&gt; Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget) { ui-&gt;setupUi(this); } Widget::~Widget() { delete ui; } //字体对话框对应的槽函数 void Widget::on_font_clicked() { bool ok; //判断是否选中字体 QFont f= QFontDialog::getFont(&amp;ok,QFont("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87a5b192ed56535cbfd4958f920f7dcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a527acf4398378761e273c8776f58fac/" rel="bookmark">
			C&#43;&#43; opencv实现中心裁剪图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//你可以使用OpenCV库中的getRectSubPix()函数来实现裁剪图像的功能，它可以以指定的中心点为基准，从图像中提取指定尺寸的子图像。具体的代码如下： Mat img_src; // 图像原始数据 Mat img_dst; // 目标数据 Point center(width/2, height/2); // 指定的中心点 Size size(60, 60); // 裁剪出的图片大小 getRectSubPix(img_src, size, center, img_dst); // 裁剪出目标图片 方法二：
以裁剪300*300大小为例
void center_resize(cv::Mat &amp;img, cv::Size new_shape)//中心裁剪 new_shape提前定义（300*300） { float width = img.cols; float height = img.rows; int center_x = round(width / 2); int center_y = round(height / 2); int dh = int(round((new_shape.height - height) / 2)); int dw = int(round((new_shape.width - width) / 2)); cv::Scalar color = cv::Scalar(0, 0, 0);//填充色 if (width &gt;= 300 &amp;&amp; height &gt;= 300) { img = img(cv::Range(center_y - (round(new_shape.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a527acf4398378761e273c8776f58fac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a244090685fb5c8b4a83caef0e269090/" rel="bookmark">
			python恶搞代码1：“随机弹窗&#43;警告窗口&#43;关机“大杂烩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.代码编写 1.基础构建 python能做许多无聊却“有趣”的事情，比如编写一个恶搞序，发给你的朋友们，让他们欲哭无泪放松一下，比如下面这行代码：
import tkinter.messagebox while True: tkinter.messagebox.showwarning('windows警告','你的电脑正在被攻击！') 这是一个很简单的程序，虽然很简单，但杀伤力不小，如果对方不会杀进程，就更有趣，但我们可以在里面加入更多的代码，比如让电脑关机：
#操作电脑有这两种代码： 现在关机：shutdown /s /t 0 现在注销：shutdown /l /t 0 在此提醒：如果不想友尽的话，不要用现在注销！！！
加入关机后，我们可以再对tkinter窗口添油加醋，最后代码如下：
import tkinter.messagebox import os word = '''你的电脑正在被攻击！ 请不要关闭正在运行的程序，否则会丢失信息 攻击路径：C://Users/appdata/dghgha/langtgdwqi/poquue/sittings/virus.exe''' while True: tkinter.messagebox.showwarning('windows警告',word) tkinter.messagebox.showinfo('info','goodbye!') os.system('shutdown /s /t 0') 效果图：
2.继续扩展 只有前面这些代码并不够，我们可以继续加入一些程序
增加随机弹窗 我们可以通过tkinter窗口实现随机弹窗的出现：
import tkinter import random def boom(): window = tk.Tk() width = window.winfo_screenwidth() height = window.winfo_screenheight() a = random.randrange(0, width) b = random.randrange(0, height) window.title('嘿嘿') window.geometry("200x50" + "+" + str(a) + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a244090685fb5c8b4a83caef0e269090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c4a9ce0bd099e1eb1a484c7a5d2d30d/" rel="bookmark">
			Linux 查找隐藏病毒程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过top命令监控无法查看隐藏的病毒程序，需要下面的脚本和命令解决
curl -o /usr/bin/busybox https://blog.tag.gg/soft/busybox-x86_64
chmod +x /usr/bin/busybox
busybox top
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2de471331a3e8eef50a5e2ccd49815/" rel="bookmark">
			docker容器正常启动宿主机却无法正常访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：重新开启linux虚拟机后有时候可以访问有时候不可以访问docker容器或者完全无法访问
原因：linux内核版本和docker版本不兼容
解决：更新linux内核版本
yum update -y
原文：http://t.csdn.cn/yv6tU
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/476bd7eceb334ffe2ff7e53ae716574a/" rel="bookmark">
			qqmap-wx-jssdk.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 微信小程序JavaScriptSDK * * @version 1.0 * @date 2017-01-10 * @author jaysonzhou@tencent.com */ var ERROR_CONF = { KEY_ERR: 311, KEY_ERR_MSG: 'key格式错误', PARAM_ERR: 310, PARAM_ERR_MSG: '请求参数信息有误', SYSTEM_ERR: 600, SYSTEM_ERR_MSG: '系统错误', WX_ERR_CODE: 1000, WX_OK_CODE: 200 }; var BASE_URL = 'https://apis.map.qq.com/ws/'; var URL_SEARCH = BASE_URL + 'place/v1/search'; var URL_SUGGESTION = BASE_URL + 'place/v1/suggestion'; var URL_GET_GEOCODER = BASE_URL + 'geocoder/v1/'; var URL_CITY_LIST = BASE_URL + 'district/v1/list'; var URL_AREA_LIST = BASE_URL + 'district/v1/getchildren'; var URL_DISTANCE = BASE_URL + 'distance/v1/'; var Utils = { /** * 得到终点query字符串 * @param {Array|String} 检索数据 */ location2query(data) { if (typeof data == 'string') { return data; } var query = ''; for (var i = 0; i &lt; data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/476bd7eceb334ffe2ff7e53ae716574a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0867bd866c4719359913a7a9aa485669/" rel="bookmark">
			vite理解与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初识vite 前言：最近项目要从vue2.x迁移到vue3，于是借此机会打算重构整个项目。在搭建项目的时候发现vue3更新了构建方式，放弃了webpack，使用了新的构建机制vite。再经过一番了解后发现vite借助了esbuild与rollup。
vite开发大致分两个阶段
开发阶段：
vite采用no-bundle的方式,借助现代浏览器支持了esmodule的能力，在开发阶段项目无需打包即可运行调试，这让开发编译速度得到很大提升。生产阶段：
为了在生产环境中获得最佳的加载性能，不能完全 no-bundle，且由于rollup 对于代码的 tree-shaking 和 ES6 模块有着算法优势上的支持，项目只需要打包出一个简单的bundle包，于是vite打包借助了rollup来用来实现代码分割、tree-shaking等操作，并且vite的插件机制是借鉴rollup来实现的。 esbuild的作用 依赖预构建，esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。加速文件编译,如webpack等以往的编译工具需要借助babel,tsc等工具编译代码，速度相对较慢，在利用esbuild后避免了terser、babel重复解析的问题，可以大大加快快速编译速度代码压缩,vite统一采用esbuild,共用ast树只进行一次解析，解决了terser 和 babel 单独使用了ast造成的重复编译问题。 rollup的作用： 现代浏览器基本支持了esmodule，考虑到要在生产环境获得最佳的加载性能，vite在生产环境使用rollup来进行打包构建，由于vite的插件机制是借鉴rollup来实现的，使得rollup大部分插件可以直接在vite中使用，可以说是双向奔赴了
vite基本配置 当以命令行方式运行 vite 时，vite 会自动解析项目根目录下名为 vite.config.js 的文件。以下是基础的配置文件：
1. IDE智能提示 通过 IDE 和 jsdoc 的配合来实现智能提示
// vite.config.js /** @type {import('vite').UserConfig} */ export default { // 一些自定义基础配置 } 使用工具函数 defineConfig
import { defineConfig } from 'vite'; export default defineConfig({ // 一些自定义基础配置 }) 2. 开发/生产环境情景配置 使用defineConfig工具函数并以箭头函数作为callback函数接收command, mode, ssrBuild来获取一些基本参数，用于区分环境亦或者是一个 SSR 构建（ssrBuild）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0867bd866c4719359913a7a9aa485669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73754e3160c194d4b62fc9042baae07b/" rel="bookmark">
			Java学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java学生信息管理系统 文章目录 Java学生信息管理系统前言一、创建学生信息类二、实现系统功能1.添加学生信息2.删除学生信息3.修改学生信息4.查看学生信息 总结 前言 简单实现Java学生信息管理系统，无数据库部分，仅用Java基础指数实现简单的Java学生信息管理系统。
学生信息可自由添加，功能仅限于简单的增删改查。
一、创建学生信息类 为简单操作，将学生信息设定为四项，学号，姓名，学院，专业，学号类似为数据库主键，不可重复，其他三项并无限制
package student_system; public class student { private String name; private String id; private String major; private String college; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getMajor() { return major; } public void setMajor(String major) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73754e3160c194d4b62fc9042baae07b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20abab61cc3c571543816c23b6673b75/" rel="bookmark">
			Octopus：专为红队设计的安全研究预操作C2服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Octopus Octopus是一款基于Python开发的开源工具，该工具可以通过HTTP/S控制Octopus Powershell代理。
Octopus的主要目的是帮助红队研究人员在对目标进行操作之前，先通过Octopus收集目标设备的信息，并对其执行渗透测试。
Octopus以一种非常简单的方式通过加密良好的通道执行命令并与C2交换信息，这种方式确保了几乎所有的AV、终端保护和网络监控方案都难以识别和探测到Octopus操作。
Octopus中有一个很酷的功能叫做ESA，它代表“端点态势感知”，它将收集有关目标的一些重要信息，帮助我们更好地了解在操作过程中将面对的目标网络端点，从而让我们能够根据这些信息定制实际操作方案。
Octopus的操作非常隐蔽，并且使用了AES-256作为PowerShell代理和C2服务器之间通信数据的加密算法。除此之外，我们还可以通过有效证书来配置Octopus
C2服务器使用SSL/TLS。
Octopus关键功能 Octopus提供了许多功能，可以帮助红队研究人员在开始任务之前更好地了解目标的相关信息：
1、通过HTTP/S控制代理；
2、执行系统命令；
3、下载/上传文件；
4、加载外部PowerShell模块；
5、C2和代理之间使用AES-256加密信道；
6、使用了隐蔽的方法来执行命令和传输数据；
7、支持为每个目标创建自定义的监听器；
8、生成不同类型的Payload；
9、生成2.0或更高版本的PowerShell，支持所有版本的Windows；
10、在不需要触发powershell.exe进程的情况下执行Octopus Windows代理可执行程序；
11、自动从所有端点自动收集信息；
工具要求 下列命令可以安装Octopus所需的所有依赖组件：
pip install -r requirements.txt 如果使用的是Linux系统，则需要安装nasm、mingw-w64和mono-devel：
apt install nasm apt install mingw-w64 apt install mono-devel 工具安装 首先，我们需要使用下列命令将该项目源码克隆至本地：
git clone https://github.com/mhaskar/Octopus/ 接下来，使用下列命令安装Octopus所需的所有依赖组件：
pip install -r requirements.txt 最后，使用下列命令开启并运行Octopus服务器：
./octopus.py 此时，我们将看到如下所示的信息：
工具使用 HTTP监听器 下列命令将运行一个名为operation1的监听器：
listen_http 0.0.0.0 8080 192.168.178.1 5 page.php operation1 上述命令将返回如下所示的结果：
Octopus &gt;&gt;listen_http 0.0.0.0 8080 192.168.178.1 5 page.php operation1 Octopus &gt;&gt; * Serving Flask app "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20abab61cc3c571543816c23b6673b75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c846ed7e97c0bbd1f8f89146d707cb8/" rel="bookmark">
			有序链表的合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：首先对俩个链表进行判空，哪个空了就直接返回另外一个。
二：定义一个指针p，让p指向俩个有序链表中更小的第一个结点。
三：进行链表的有序合并
四、如果循环结束要么俩个链表都为空，要么其中一个为空，将后面的链表接入p的位置即可
一个比较简单的链表合并，不过两种思路挺不错。
一：首先对俩个链表进行判空，哪个空了就直接返回另外一个。 if(NULL == pHead1) return pHead2; if(NULL == pHead2) return pHead1; 二：定义一个指针p，让p指向俩个有序链表中更小的第一个结点。 struct ListNode* p = NULL; struct ListNode* P = NULL; struct ListNode* p1 = pHead1; struct ListNode* p2 = pHead2; if(p1-&gt;val &lt;= p2-&gt;val) { p = p1; p1 = p1-&gt;next; } else { p = p2; p2 = p2-&gt;next; } P = p; 三：进行链表的有序合并 while(p1 &amp;&amp; p2) { if(p1-&gt;val &gt;= p2-&gt;val) { //利用p结点后的尾插 利用p指针的直接指向 pHead2 = p2-&gt;next; //p-&gt;next = p2; p2-&gt;next = p-&gt;next; //p2 = p2-&gt;next; p-&gt;next = p2; p2 = pHead2; } else { pHead1 = p1-&gt;next; //p-&gt;next = p1; p1-&gt;next = p-&gt;next; //p1 = p1-&gt;next; p-&gt;next = p1; p1 = pHead1; } p = p-&gt;next; } 可以看到有俩种思路，我先想到的是直接在p指针后将结点尾插到后面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c846ed7e97c0bbd1f8f89146d707cb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c4a98aba91180989e288ccc9cf12e4/" rel="bookmark">
			一文读懂spring的lookup-method的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：在spring中，我们通常创建的Bean是单例的。那么当我们使用存在一个这样bean，它自身是单例的，但是其需要通过调用某个原型bean的方法。在这种场景下，我们应该去怎么实现这个需求呢？
解决方案有如下几种，
一、该类型实现ApplicationContextAware接口，感知到应用上下文 import org.springframework.beans.BeansException; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; public class CommandManager implements ApplicationContextAware { private ApplicationContext applicationContext; public Object process(Map commandState) { // grab a new instance of the appropriate Command Command command = createCommand(); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); } protected Command createCommand() { // notice the Spring API dependency! return this.applicationContext.getBean("command", Command.class); } public void setApplicationContext( ApplicationContext applicationContext) throws BeansException { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c4a98aba91180989e288ccc9cf12e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6381f54b21605918d0fe37702c4d989/" rel="bookmark">
			Spring 集成Mybatis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：将 MyBatis与 Spring进行整合，主要解决的问题就是将 SqISessionFactory对象交由 Spring来管理。所以，该整合只需要将SqISessionFactory的对象生成器SqlSessionFactoryBean注册在Spring容器中，再将其注入给Dao的实现类即可完成整合。 实现思路： 实现Spring与MyBatis的整合常用的方式:扫描的Mapper动态代理。Spring像插线板一样, mybatis 框架是插头,可以容易的组合到一起。插线板spring插上mybatis,两个框架就是一个整体。
2.实现步骤 2.1创建数据库 使用的mysq1库，使用学生表 student(stuid int主键列，自动增长，stuname varchar (45)，stusex int ,stunum varchar (45))
2.2创建maven项 2.3 加入依赖 spring依赖，mybatis依赖，mysq1驱动。 junit依赖mybatis- spring依赖(mybatis网站 上提供的，用来在spring项目中，创建mybatis对 象)spring有关事务的依赖。mybatis和spring整合的时候，事 务是自动提交的。
&lt;!--1. spring所需要的jar包：（8+2） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring事务依赖jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6381f54b21605918d0fe37702c4d989/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37808e0cda50a17fe4035b69150ae995/" rel="bookmark">
			uniapp使用原生插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp做app有些功能实现不了，需要原生安卓Ios开发插件，然后集成到uniapp项目里
原生插件使用地址
在项目里创建个nativeplugins文件
大概流程就是让原生处理好插件后打个包给你，然后把包放到nativeplugins文件里，然后配置好东西，在页面里使用
大概使用的东西在官网都能看到，就讲点细节的地方
package.json里的dependencies配置是插件要用到的依赖，一定要添加，不然云打包会出错！！！
package.json里的dependencies配置是插件要用到的依赖，一定要添加，不然云打包会出错！！！
插件有两种类型，这种是带页面和样式的，让原生开发告诉你是哪种
component模式
在配置里选上本地插件，打个自定义基座，然后再调试使用
使用页面，需要是nvue页面
module模式的使用就看官网吧
module模式使用官网
一般调试的话可以先生成本地包，然后让原生开发去调试，这样快一些，云打包自定义基座比较慢还有次数限制
打正式包也可以通过上面那样吧本地包发给原生，然后让他生成apk包，ios也类似
或者在uniapp通过云打包生成apk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c58e64253757d861b31f4cf0ef4037/" rel="bookmark">
			Git常用配置与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 查看git的用户名和密码 1.1. 查看 查看用户名 ：git config user.name
查看密码： git config user.password
查看邮箱：git config user.email
查看配置信息： $ git config --list
1.2. 修改 修改用户名 git config --global user.name “xxxx(新的用户名)”
修改密码 git config --global user.password “xxxx(新的密码)”
修改邮箱 git config --global user.email “xxxx@xxx.com(新的邮箱)”
1.3. 修改出现的报错 原因：用户名过多
解决办法：$ git config --global --replace-all user.name “你的 git 的名称”
$ git config --global --replace-all uesr.email “你的 git 的邮箱”
2. SSH免密登录配置 SSH key 的作用:实现本地仓库和 Github 之间免登录的加密数据传输。 SSH key 的好处: 免登录身份认证、数据加密传输。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8c58e64253757d861b31f4cf0ef4037/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/78/">«</a>
	<span class="pagination__item pagination__item--current">79/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/80/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>