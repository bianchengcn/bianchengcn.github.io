<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ce6b5a6a30ce39c7ab67d04586c5b15/" rel="bookmark">
			C#中数组的存放位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class Program { static void Main(string[] args) { char[] a = new char[4]; object[] b = new object[3]; Console.WriteLine(a.GetType().IsSubclassOf(typeof(System.Array)));//True Console.WriteLine(b.GetType().IsSubclassOf(typeof(System.Array)));//True Console.Read(); } } 示例中，数组a和b都是分配再栈上的引用，数组a每个元素的值实际是分配在堆上，存储的是对应的值；数组b的每个元素也在堆上，但存储的只是引用，引用在堆上其他地方存储的真实值。
转载自：http://blog.51cto.com/cnn237111/1420977
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81bc042282ed81f9d9948768ea82926e/" rel="bookmark">
			Scala基础-隐式转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为scala的一个优秀的功能，也是困扰我许久的一个功能，今天尝试弄明白。
我们知道scala语言以简洁著称，几十行的java代码scala通常几行就可以搞定，为了达到这个特点，个人认为编译器会尝试尽可能多的做一些推导，比如：1，就默认为Int类型，a，就默认为String类型，因为我们通常都是这样用的，为什么非要每次都需要明确指出它的类型呢？你说我就认为1是String类型的“1”呢？那可以啊，你要用String 的类型拼接的时候，比如1+a，我给你自动识别成“1a”啊，你做1+1的时候我给你自动识别成2啊，又有什么不可以呢？
以上都是我个人为了想便于了解scala的隐式转换所做的一些思想准备，实际上可能不是这样的。那么我们现在可以了来了解网上经常说到scala隐式转换的那句话：
“隐式转换和参数，可以在编写Scala程序时故意漏掉一些信息，让编译器去尝试在编译期间自动推导出这些信息来，这种特性可以极大的减少代码量，忽略那些冗长，过于细节的代码。”
好像是这么回事哦，我写1，我就不写1：Int；写a，就不写a:String，我让编译器自己去给我推导这些信息。好了，我们现在弄明白隐式转换他要达到一个什么目的了，现在我们就可以来看看他是怎么使用的。
一、隐式参数
object Test7 { def k1(x:Int,y:Int):Int=x+y def k2(x:Int)(implicit y:Int=5):Int=x+y def main(args: Array[String]): Unit = { println(k1(2,3)) println(k2(5)) } } 结果为：
5 10 k1可以理解，调用k2的时候，我们只给了一个参数，却也能得出结果，是因为在方法中隐式给了值。编译器在调用k2的时候发现只穿了一个参数，这时就会在上下文中寻找有没有隐式参数，如果有，就调用隐式参数。
object Test7 { implicit var b:Int=10 def k2(x:Int)(implicit y:Int=5):Int=x+y def main(args: Array[String]): Unit = { println(k2(5)) } } 结果为：
15 可以发现编译器会首先在上下文中寻找隐式参数，一找到符合的，就使用，不再去找参数列表中寻找。
object Test7 { implicit var b:Double=10.0 def k2(x:Int)(implicit y:Int=5):Int=x+y def main(args: Array[String]): Unit = { println(k2(5)) } } 结果为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81bc042282ed81f9d9948768ea82926e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff9d22b419f1ecd679c3cc6f49b85b1/" rel="bookmark">
			jquery事件三 -- load(), ready(), resize()以及bind()事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例子1
ready() DOM加载完毕
load() 元素加载完毕
resize() 浏览器窗口的大小发生变化
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.12.4.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; /*原生写法 window.onload = function(){ } */ /*jquery写法 上面等同于下面的写法 $(window).load(function() { }); */ /* ready的写法： $(document).ready(function(){ }) */ /* ready的简写： $(function(){ }) */ // 窗口改变尺寸的时候，会触发事件；比如多次手动拉动浏览器窗口大小，就会触发多次2 $(window).resize(function() { console.log('2'); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 二，bind()
使用bind()可以绑定多个事件，比如bind('click' mouseover', function(){...}，其中有2个参数，第一个参数表示事件，多个事件用空格隔开，比如这里点击和鼠标经过都会触发事件；后面的参数是一个匿名函数，写入触发的事件。
绑定和解绑方法如下
$(function(){ $('#div1').bind('mouseover click', function(event) { alert($(this).html()); // $(this).unbind(); $(this).unbind('mouseover'); }); }); 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff9d22b419f1ecd679c3cc6f49b85b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b1cbe7c1e58c91724a8e2085f124f0d/" rel="bookmark">
			python学习笔记-基础语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python filename.py,在执行.py文件之前，需要把当前目录切换文件所在目录使用python命令切换到交互模式使用./filename.py直接执行py文件需要在.py文件的首行加上#！/usr/bin/env python 3 # -*- coding：utf-8 -*-print()函数用于输出，print(‘hello’);默认是换行输出的，想要实现不换行输出需要在变量末尾加上’,’ python3要求带括号input()函数用于输入,函数中可以添加提示,个人测试使用raw_input();更合适。注释符号# 相邻的两句的缩进需要统一使用tab或统一使用空格，不能混用。在python中strings tuples numbers是不可更改的对象，而list dict则是可以修改的对象同一行多条语句的时候使用；隔开多行内容使用\n换行符或者使用（··· ···）反引号除法分/和//地板除两种，地板除得到的是整数字符编码：utf-8 汉子三个字节\u开头的字符串是unicode编码，转换为中文汉字使用str.decode(‘unicode_escap’)ord(char)获取自负对应的整数，chr(int)获取整数对应的字符将字符串保存到磁盘上时需要将类型转换成字节流类型bytes，bytes类型数据使用’b’做前缀x=b’abc’使用的是str.encode(),bytes.decode()。包含不能被解码的字节，decode就会报错。len（str）函数查看字符串包含多少字符格式化占位符%d整数 %f浮点数 %s字符串 %x十六进制整数 %来转义%号条件循环等语句都是以关键字开始以：结束该行之后的一行或多行构成代码组,不支持switch允许同时为多个变量赋值a=b=c=1del用来删除单个或多个对象的引用+字符串连接，*重复操作，操作*n重复n次数据类型：数字、字符串、列表、元组、字典列表用[]标识，列表切割也用[头下标：尾下标]，包含头下标对应的值不包含尾下标对应的值，使用list.append[‘’]为列表项追加元素，使用del()删除列表元素del list[index],删除指定位置元素 cmp(l1,l2)比较两个列表的元素len(list)列表元素个数Max（list）列表元素最大值min()list(元组)将元组转换为列表Lname.append(obj) lname.count(obj) lname.extend(seq) lname.index(obj) lname.pop() lname.remove()移除列表中某个值的第一个匹配项lname.reverse() lname.sort() lname.insert(index,obj) 元组用()标识，元组不能二次赋值，相当于只读列表 注意元组中只包含一个元素时，需要在元素后面添加逗号元组中的元素是不能修改的，但是我们可以对元组进行组合元组的元素值是不允许删除的，但是我们可以使用del语句删除整个元组元组中的方法cmp(元组1，元组2)，len（元组）计算元组个数，max（元组）min（元组），tuple（列表）将列表转换为元组字典用{}标识，类似js中的对象 Dict(a=‘’,b=‘’),通过方法创建字典访问字典 dict[‘索引值’]删除字典元素 del dict[‘索引值’]清空字典所有条目 del dict；注意不允许一个键出现两次，键值必须不可变，所以可以用数字，，字符串或元组充当，但是不能使用列表cmp() len() type(var)返回输入变量的类型str(字典名) 输出字典可打印的字符串表示Dict.clear() 清空字典Dict.copy()浅拷贝，复制，注意直接赋值和copy的区别，直接赋值是引用对象（修改原对象，赋值的对像值也会相应地改变），使用函数是深拷贝父对象（修改原对象，不会改变父对象的值），子对象还是引用(与直接赋值效果一样)，深拷贝是完全复制，原对象和复制的对象相互独立，浅拷贝是引用。Dict.deepcopy()深度拷贝Dict.fromkeys(swq[,val]),创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值Dict.get(key,default=None)返回指定键的值，如果值不存在（访问的key不存在）则返回default的值Dict.has_key(key)判断字典中是否含有某个键，有返回true，没有返回falseDict.items()以列表返回可遍历的（键，值）元组数组[(),()]dict.keys()以列表返回一个字典的所有的键[‘’,’’]Dict.setdefault(key,default=None)如果字典中包含有给定键，则返回该键对应的值，否则返回为该键设置的值Dict.update(dict2),把dict2的键值对添加到dict中Dict.values(),以列表返回字典中的所有值Dict.pop(key[,default])删除字典给定键所对应的值，返回值为被删除的值，key值必须给出，否则返回default的值Dict.popitem()随机返回并删除字典中的一对键和值返回形式元组（’key’，’value’） 算术运算符，基本一致，注意a**b是指a的b次方。//是地板除 注意python不支持++和—运算比较运算符&lt;&gt;和！=都表示不等于’赋值运算符**=和//=位运算符&amp; | ^ ！～ &gt;&gt; &lt;&lt;逻辑运算符用关键字 and or not成员运算符 in 类似php中的as（foreach），not inis 和is not判断两个标识符是不是引用自一个对象id（）函数用来获取对象的内存地址无限循环while var==1: while else在while条件为false时执行elsepass语句时空语句，用作占位语句数字：整型，长整型、浮点数、复数数学运算的函数都在math模块和 cmath模块使用时需要引入 import math随机数函数需要引入随机模块import random random.choice(seq)从序列元素中随机挑一个元素random.randrange([start,]stop[,step])从指定范围获取一个随机数，比较有意思的是python竟然在参数取值上不遵循最右原则Random.random()随机生成一个0到1之间的实数random.seed([x])Random.shuffle(lst)将序列的所有元素随机排序Random.uniform(x,y)随机生成一个实数在【x，y】之间三角函数需要引入数学函数import math数学常量 pi表示pai e表示自然常数三引号类似php中的定界符Python 日期和时间 提供了很多处理时间和日期的函数，在使用之前需要引入模块import time时间元组 九组数字组成 分别表示年 月 日 时 分 秒 一周的第几日 一年的第几日 夏令时 获取当前的时间戳使用time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b1cbe7c1e58c91724a8e2085f124f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1513756ada4581ae32a3c65b6adece4/" rel="bookmark">
			【Windows】win10升级后多出一个盘怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处，原文链接：https://blog.csdn.net/u013642500/article/details/80204678
【前言】 2017年10月18日，win10升级到1709之后，就发现多出一个盘。
2018年05月02日，win10升级到1803之后，又发现多出一个盘。
此硬盘有的是256MB，有的是500MB，有的是800MB，大小不一，却往往不足1GB大小。而且有的能打开，内部无任何文件；有的却打不开，提示权限不足等。
该分区是系统保留分区，内部含有重要文件，用户轻易不要动该盘文件。万万不可有“把这部分空间分给其他盘，这样就有了更大的可用空间了”这种想法。这种分区不应该被分配盘符，不应该显示出来，然而却因为win10升级的bug给其分配了盘符。我们要做的就是取消该盘符。
【名词解释】 1、磁盘（磁盘）：磁盘，俗称硬盘，指整个存储空间。每块磁盘可以划分很多分区（卷）（盘），如：C盘、D盘。
2、分区（卷）（盘）：分区又叫卷，俗称盘，指单独的一部分存储空间。
3、驱动器号（盘符）（LTR）：驱动器号又叫盘符，每个分区的代号，如：C、D。
4、diskpart：磁盘管理工具。
【步骤】 1、按 win+X，然后按A，打开 Windows PowerShell(管理员)。
如果弹出用户账户控制提示，点击“是”。
2、输入 Diskpart 回车。
3、输入 list disk 回车。
4、选择要处理的硬盘，输入 sel disk 0 回车，如果那个多出来的分区在磁盘1上，则输入 sel disk 1。
5、输入 list vol 回车。
6、根据大小，找到那个多出来的卷，然后记住前面的数字，我这里是1，于是输入 sel vol 1 回车。
7、输入 remove 回车。
8、提示成功之后，就可以关了它了。然后就看不到那个盘了。
【步骤答疑】 1、sel是select的简写，“选择”的意思。vol是volume的简写，“卷”的意思。
2、disk是磁盘的意思，有的电脑带两块硬盘，所以 list disk 之后就会出现两行，那么用 sel disk 来选择要处理的磁盘
3、如果只有一块磁盘，list disk 之后只会出现一行，那么只能 sel disk 0 选择那块磁盘。
4、如果不执行 sel disk ，那么就无法执行后面的步骤。
【注意事项】 如果由于不小心操作失误，将不该删除的盘符删除了，可以通过语句 assign letter = I 重新分配盘符。当然了，之前选择了哪个卷就是给哪个卷分配盘符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1513756ada4581ae32a3c65b6adece4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f6ac74edc177382490240d88d0f852/" rel="bookmark">
			阿里P9架构师简述从单机至亿级流量大型网站系统架构的演进过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阶段一、单机构建网站
网站的初期，我们经常会在单机上跑我们所有的程序和软件。此时我们使用一个容器，如tomcat、jetty、jboos，然后直接使用JSP/servlet技术，或者使用一些开源的框架如maven+spring+struct+hibernate、maven+spring+springmvc+mybatis；最后再选择一个数据库管理系统来存储数据，如mysql、sqlserver、oracle，然后通过JDBC进行数据库的连接和操作。
把以上的所有软件都装载同一台机器上，应用跑起来了，也算是一个小系统了。此时系统结果如下：
阶段二、应用服务器与数据库分离
随着网站的上线，访问量逐步上升，服务器的负载慢慢提高，在服务器还没有超载的时候，我们应该就要做好准备，提升网站的负载能力。假如我们代码层面已难以优化，在不提高单台机器的性能的情况下，增加机器是一个不错的方式，不仅可以有效地提高系统的负载能力，而且性价比高。
增加的机器用来做什么呢？此时我们可以把数据库，web服务器拆分开来，这样不仅提高了单台机器的负载能力，也提高了容灾能力。
应用服务器与数据库分开后的架构如下图所示：
阶段三、应用服务器集群
随着访问量继续增加，单台应用服务器已经无法满足需求了。在假设数据库服务器没有压力的情况下，我们可以把应用服务器从一台变成了两台甚至多台，把用户的请求分散到不同的服务器中，从而提高负载能力。多台应用服务器之间没有直接的交互，他们都是依赖数据库各自对外提供服务。著名的做故障切换的软件有keepalived，keepalived是一个类似于layer3、4、7交换机制的软件，他不是某个具体软件故障切换的专属品，而是可以适用于各种软件的一款产品。keepalived配合上ipvsadm又可以做负载均衡，可谓是神器。
我们以增加了一台应用服务器为例，增加后的系统结构图如下：
系统演变到这里，将会出现下面四个问题：
用户的请求由谁来转发到到具体的应用服务器
有什么转发的算法
应用服务器如何返回用户的请求
用户如果每次访问到的服务器不一样，那么如何维护session的一致性
我们来看看解决问题的方案：
第一个问题即是负载均衡的问题，一般有5种解决方案：
1、http重定向。HTTP重定向就是应用层的请求转发。用户的请求其实已经到了HTTP重定向负载均衡服务器，服务器根据算法要求用户重定向，用户收到重定向请求后，再次请求真正的集群
优点：简单。
缺点：性能较差。
2、DNS域名解析负载均衡。DNS域名解析负载均衡就是在用户请求DNS服务器，获取域名对应的IP地址时，DNS服务器直接给出负载均衡后的服务器IP。
优点：交给DNS，不用我们去维护负载均衡服务器。
缺点：当一个应用服务器挂了，不能及时通知DNS，而且DNS负载均衡的控制权在域名服务商那里，网站无法做更多的改善和更强大的管理。
3、反向代理服务器。在用户的请求到达反向代理服务器时（已经到达网站机房），由反向代理服务器根据算法转发到具体的服务器。常用的apache，nginx都可以充当反向代理服务器。
优点：部署简单。
缺点：代理服务器可能成为性能的瓶颈，特别是一次上传大文件。
4、IP层负载均衡。在请求到达负载均衡器后，负载均衡器通过修改请求的目的IP地址，从而实现请求的转发，做到负载均衡。
优点：性能更好。
缺点：负载均衡器的宽带成为瓶颈。
5、数据链路层负载均衡。在请求到达负载均衡器后，负载均衡器通过修改请求的mac地址，从而做到负载均衡，与IP负载均衡不一样的是，当请求访问完服务器之后，直接返回客户。而无需再经过负载均衡器。
第二个问题即是集群调度算法问题，常见的调度算法有10种：
1、rr 轮询调度算法。顾名思义，轮询分发请求。
优点：实现简单
缺点：不考虑每台服务器的处理能力
2、wrr 加权调度算法。我们给每个服务器设置权值weight，负载均衡调度器根据权值调度服务器，服务器被调用的次数跟权值成正比。
优点：考虑了服务器处理能力的不同
3、sh 原地址散列：提取用户IP，根据散列函数得出一个key，再根据静态映射表，查处对应的value，即目标服务器IP。过目标机器超负荷，则返回空。
4、dh 目标地址散列：同上，只是现在提取的是目标地址的IP来做哈希。
优点：以上两种算法的都能实现同一个用户访问同一个服务器。
5、lc 最少连接。优先把请求转发给连接数少的服务器。
优点：使得集群中各个服务器的负载更加均匀。
6、wlc 加权最少连接。在lc的基础上，为每台服务器加上权值。算法为：（活动连接数*256+非活动连接数）÷权重 ，计算出来的值小的服务器优先被选择。
优点：可以根据服务器的能力分配请求。
7、sed 最短期望延迟。其实sed跟wlc类似，区别是不考虑非活动连接数。算法为：（活动连接数+1)*256÷权重，同样计算出来的值小的服务器优先被选择。
8、nq 永不排队。改进的sed算法。我们想一下什么情况下才能“永不排队”，那就是服务器的连接数为0的时候，那么假如有服务器连接数为0，均衡器直接把请求转发给它，无需经过sed的计算。
9、LBLC 基于局部性的最少连接。均衡器根据请求的目的IP地址，找出该IP地址最近被使用的服务器，把请求转发之，若该服务器超载，最采用最少连接数算法。
10、LBLCR 带复制的基于局部性的最少连接。均衡器根据请求的目的IP地址，找出该IP地址最近使用的“服务器组”，注意，并不是具体某个服务器，然后采用最少连接数从该组中挑出具体的某台服务器出来，把请求转发之。若该服务器超载，那么根据最少连接数算法，在集群的非本服务器组的服务器中，找出一台服务器出来，加入本服务器组，然后把请求转发之。
第三个问题是集群模式问题，一般3种解决方案：
1、NAT：负载均衡器接收用户的请求，转发给具体服务器，服务器处理完请求返回给均衡器，均衡器再重新返回给用户。
2、DR：负载均衡器接收用户的请求，转发给具体服务器，服务器出来玩请求后直接返回给用户。需要系统支持IP Tunneling协议，难以跨平台。
3、TUN：同上，但无需IP Tunneling协议，跨平台性好，大部分系统都可以支持。
第四个问题是session问题，一般有4种解决方案：
1、Session Sticky。session sticky就是把同一个用户在某一个会话中的请求，都分配到固定的某一台服务器中，这样我们就不需要解决跨服务器的session问题了，常见的算法有ip_hash法，即上面提到的两种散列算法。
优点：实现简单。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f6ac74edc177382490240d88d0f852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/522f3429695d9e359d697cf2fe719ab1/" rel="bookmark">
			2018第九届蓝桥杯C/C&#43;&#43; B组省赛题解（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目六：
题解：
#include &lt;bits/stdc++.h&gt; using namespace std; int a[100100], b[100100], c[100100]; int main() { int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) { scanf("%d", &amp;a[i]); } for(int i = 0; i &lt; n; i++) { scanf("%d", &amp;b[i]); } for(int i = 0; i &lt; n; i++) { scanf("%d", &amp;c[i]); } int ans = 0; sort(a, a+n); sort(b, b+n); sort(c, c+n); for(int i = 0; i &lt; n; i++) { int x = lower_bound(a, a+n, b[i]) - a; int y = upper_bound(c, c+n, b[i]) - c; //cout &lt;&lt; x &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/522f3429695d9e359d697cf2fe719ab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a82e9f9835a515af6f54364283774296/" rel="bookmark">
			【Windows】Win10家庭版启用组策略gpedit.msc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处，原文链接：https://blog.csdn.net/u013642500/article/details/80138799
【前言】 大家都认为，Windows 10家庭版中并不包含组策略，其实不然，它是有相关文件的，只是不让你使用而已。那么我们让系统允许你使用就好了。
【操作步骤】
1、首先你需要在桌面上新建一个txt文本文档。然后将以下代码复制到这个新建的txt文本文档中。
@echo off pushd "%~dp0" dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt for /f %%i in ('findstr /i . List.txt 2^&gt;nul') do dism /online /norestart /add-package:"C:\Windows\servicing\Packages\%%i" pause 如图所示：
2、保存，关闭，重命名这个新建文本文档，修改其后缀.txt变成.cmd。
3、右键单击这个“新建文本文档.cmd”，选择以管理员身份运行即可。
4、运行结果如下图所示：
运行完毕，你的电脑就可以使用组策略gpedit.msc了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd53195cf716fefdc147274605e3176/" rel="bookmark">
			dvwa之 file upload （low）一句话木马和中国菜刀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		low等级的可以使用一句话木马和中国菜刀
低等级的没有对于上传做任何的过滤或者是防护，所以直接用一句话木马进行上传即可（相关原理可以参照其他大佬的）
首先直接用一个txt里面构造一句话木马即可：（php）：&lt;?php @eval($_POST['pass']);?&gt;
直接命名为pass.php即可（只是针对low等级），然后上传
上传成功，路径如下：../../hackable/uploads/pass.php succesfully uploaded!
完整路径为：http://127.0.0.1/dvwa/hackable/uploads/pass.php 密码为：pass（就是一句话中间的密码）
使用中国菜刀进行连接
直接连接即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eed630bf55d3d4f30ef262067ac6fda/" rel="bookmark">
			对Verilog 初学者比较有用的整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对Verilog 初学者比较有用的整理(转自它处) ********************************************************************************************************************
*作者: Ian11122840 时间: 2010-9-27 09:04 *
*标题: 菜鸟做设计必看！有关如何做设计的整体思路，以及能否综合的笔记 *
*所谓综合，就是把描述语言转化成能硬件实现的电路，学verilog的时候，没有人给我说要不要考虑能否综合的问题~~~ *
*看了5本书，居然没有一本书讲到能否综合，所以设计出来的程序完全不能用~~~ *
*而且，书中都是讲语句的具体使用办法，例如always @()，但是什么时候用always，几个always之间、时序电路、逻辑电路、任务与函数什么时候用，却没有一本书能讲清楚。*
*这个笔记详细写了这些思路的问题，分享给新手看看，学习一种思路~~
*点击此处下载 ourdev_585849OJ54KV.doc(文件大小:720K) (原文件名:verilog_经验(适合初学者).doc) *
********************************************************************************************************************
先记下来：
1、不使用初始化语句；
2、不使用延时语句；
3、不使用循环次数不确定的语句，如：forever，while等；
4、尽量采用同步方式设计电路；
5、尽量采用行为语句完成设计；
6、always过程块描述组合逻辑，应在敏感信号表中列出所有的输入信号；
7、所有的内部寄存器都应该可以被复位；
8、用户自定义原件（UDP元件）是不能被综合的。
一：基本
Verilog中的变量有线网类型和寄存器类型。线网型变量综合成wire，而寄存器可能综合成WIRE，锁存器和触发器，还有可能被优化掉。
二：verilog语句结构到门级的映射
1、连续性赋值：assign
连续性赋值语句逻辑结构上就是将等式右边的驱动左边的结点。因此连续性赋值的目标结点总是综合成由组合逻辑驱动的结点。Assign语句中的延时综合时都将忽视。
2、过程性赋值：
过程性赋值只出现在always语句中。
阻塞赋值和非阻塞赋值就该赋值本身是没有区别的，只是对后面的语句有不同的影响。
建议设计组合逻辑电路时用阻塞赋值，设计时序电路时用非阻塞赋值。
过程性赋值的赋值对象有可能综合成wire, latch,和flip-flop，取决于具体状况。如，时钟控制下的非阻塞赋值综合成flip-flop。
过程性赋值语句中的任何延时在综合时都将忽略。
建议同一个变量单一地使用阻塞或者非阻塞赋值。
3、逻辑操作符：
逻辑操作符对应于硬件中已有的逻辑门，一些操作符不能被综合：===、!==。
4、算术操作符：
Verilog中将reg视为无符号数，而integer视为有符号数。因此，进行有符号操作时使用integer,使用无符号操作时使用reg。
5、进位：
通常会将进行运算操作的结果比原操作数扩展一位，用来存放进位或者借位。如：
Wire [3:0] A,B;
Wire [4:0] C;
Assign C=A+B;
C的最高位用来存放进位。
6、关系运算符：
关系运算符：&lt;,&gt;,&lt;=,&gt;=
和算术操作符一样，可以进行有符号和无符号运算，取决于数据类型是reg，net还是integer。
7、相等运算符：==，！=
注意：===和！==是不可综合的。
可以进行有符号或无符号操作，取决于数据类型
8、移位运算符：
左移，右移，右边操作数可以是常数或者是变量，二者综合出来的结果不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eed630bf55d3d4f30ef262067ac6fda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4415a2213ec1209b74621d686f16c7fe/" rel="bookmark">
			西门子plc  s7-200写的先进先出范例 用fifo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人最近写了一个五台锅炉共用一个冷却水泵的程序，开始打算用时间戳来记录每台锅炉需要冷却的时间，然后用时间进行排序，但是后来无意中发现fifo可以实现表的先进先出的功能，就抱着学习的目的，用fifo写了本程序。
第一步，先要建立一个表如下图，上电初始化建立一个具有5个值的表，从VW200开始，VW200存放的是表的容量，VW202仿的是当表内的实际个数,然后给vw100-vw108（每台锅炉在表里的id）赋值。
第二部，5个i口作为5台锅炉发来的请求冷却信号，这5个信号必须用上升沿P或者下降沿N来触发
第三步，当表内有数据，且水泵处于休眠状态下，执行先进先出程序，vw300就是目前出去的值（锅炉序号）
第四步，检测当前的先进先出执行到哪台锅炉，对应锅炉就执行输出，这里的q0.1-q0.5就是5台锅炉，vw202和vw300只是方便测试用的，可以删除，m0.1-m0.5都是是同一个水泵的工作信号，为了防止双线圈，才命名不一样
第五步，双线圈的解决办法，q1.0就是水泵电机
fifo这个函数在很多地方都可以用到，排队程序在工业自动化中占比也算大的，但是网络上都找不到详细的说明，希望我这个教程能帮助到大家，给个回复就算谢谢了。日行一善！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0e1e32e6ede677e357c4b8289bbadb/" rel="bookmark">
			引导修复第一类：关于Windows的引导修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信各位爱好重装系统的同志，在装多系统时都遇到过装完A系统只能进A系统，没有引导选择A和B和...系统的界面，这篇博客就是解决这个问题的。引导修复我分为两类，第一大类：windows双（多）系统的引导修复；第二大类windows与linux双（多）系统的引导修复。在此先介绍第一类，我又将第一类分为以下两种情况（第二大类链接）：
第一种情况能进其中一个windows（你需要网络） 1、下载NTBOOTautofix v2.0.2.exe选择自动修复即可
2、重启能看到自己的windows双（多）个系统的引导选项
3、下载并使用EasyBCD.exe修改每个个系统的名字
第二种情况没有任何引导界面不能进入系统（你需要网络与U盘） 1、做windows启动盘在此以大白菜为例（大白菜：http://www.bigbaicai.com/）下载装机版
2、一键生成大白菜启动盘（U盘会被清空）
3、重启电脑、使用电脑快捷启动进入大白菜WIN8-PE
4、使用大白菜开始菜单里的NTBOOTautofix v2.0.2.exe选择自动修复即可、
5、重启进入系统后，下载并使用EasyBCD.exe修改每个个系统的名字
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c3dd35d4bcae68ee3553d8cc8ed991/" rel="bookmark">
			利用IDA dump文件内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一开始需要dump文件中一段数据，但是突然发现自己没有接触过这种东西…真TM菜逼…搞到现在居然dump文件都不会…然后简单总结一下，利用得IDA。 首先从File选项中找到script command这个选项 然后我们主要可以利用两种语言实现，一种是IDC，是一种IDA强大得扩展语言，另一种是IDApython了 IDC 直接上脚本，这只是dump文件得部分，IDC还有很多厉害得功能，具体可以参考一些博客 https://introspelliam.github.io/2017/09/18/IDA%E7%9A%84%E8%B0%83%E8%AF%95%E8%84%9A%E6%9C%ACidc/
脚本应用得场景是reverse.kr得ImagePrc题目
static main() { auto i,fp; fp = fopen("d:\\dump","wb"); auto start = 0x47e060; auto size = 90000; for(i=start;i&lt;start+size;i++) { fputc(Byte(i),fp); } fp.close(); } IDApython import idaapi start_address = 0x47e060 data_length = 90000 data = idaapi.dbg_read_memory(start_address , data_length) fp = open('d:\\dump1', 'wb') fp.write(data) fp.close() 简单记录一下吧…主要确实是太菜了… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337c9fb889ca3cfe1f3ca0edb32757c2/" rel="bookmark">
			计算机视觉实习面经【微软/阿里/腾讯】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NVIDIA DLI 深度学习入门培训 | 特设三场 4月28日/5月19日/5月26日 一天密集式训练 快速带你入门深度学习 阅读全文 &gt; 正文共3397个字，1张图，预计阅读时间8分钟。
从CVPR出结果之后就开始找人内推，先后面了微软，腾讯，阿里，最后定了腾讯ailab计算机视觉研究员的offer。
我的github（欢迎follow）：https://github.com/ahangchen
简历 简历一定要好好做，基本信息写清楚，论文，实习经历，GitHub，博客，商用项目，都是加分项，投MSRA的话还需要准备中英文简历，所以我的简历投出去的时候都是中英文一起投的，想要看简历的同学可以发邮件给我（聪明的你应该能在这篇文章找到我的邮箱的线索）。
微软 MSRA语音组（2月23日） 语音组是华工联合培养的一个师姐推荐的，加了微信，微信电话面，当时寒假，还在家里。语音组正在搞文本识别和图文分析，一上来就问实习时间多长，想做什么样的task，然后问了简历上的论文和一个项目，然后等消息，说等我跟老板确定实习时间了再联系。
感觉MSRA招人都是希望尽快入职的，并且比较难转正，有点像临时工，后面就没有继续联系了。
MSRA视觉计算组（3月1日） 我在官网直接投了网络多媒体组（视频分析啥的跟我做的东西比较match），入职时间写的5月1日（后面跟老师讨论了一下只能最早六月去）。
这天晚上在实验室干活，忽然有视觉计算组的一个小姐姐打电话进来，是从简历池里捞到的我的简历，说他们想做object detection和模型压缩相关的东西，想找个实习生，了解了一下实习时间，发现不match（她希望能5月入职），就说之后再联系。
小结 MSRA目前接触到的几个面试官这边应该都凉凉了，主要还是不match（时间和任务上）
简历要是比较突出的话，扔官网海投也是有被捞的希望的
实习时间和方向match会大大提升被捞和通过的机会
腾讯 AI Lab计算机视觉组。 一面 在我们学院一个班长群问了一下有没有人可以内推腾讯，同时有两个师兄说可以内推，一个推了SNG QQ，一个推了AI iLab。
AI Lab的大佬很快发了邮件给我，加了微信，约了个时间微信电话面（2月27日）
找了个平常开会用的会议室，因为刚开学没啥人，还比较顺利。先问CVPR的论文，问完之后稍微问了一下其他的项目，没有问多少基础知识，说等跟老板确定实习时间之后再联系。
回到学校跟老板确定实习时间之后，AI Lab这边说，因为6月才能入职，现在处理起来有点早，让我4月的时候给他留言，到时候会有一个coding test，如果也通过了就没问题了。
等通知。
二面 约了3月22日做coding测试，原本是用collabedit.com协作编辑器来写代码的，中间出了点故障，就改用doc.google.com写代码（没高亮，不用IDE，主要看思路），两个LeetCode上的题（没刷到），先用小半个小时，简单写法做了一遍，第二题很快就OK了，然后想第一题的O(1)空间解法，一路提示下来还是写了出来。
第一题：https://leetcode.com/problems/find-the-duplicate-number/description/
第二题：https://leetcode.com/problems/product-of-array-except-self/description/
HR面（4月3日） 3月31日腾讯的简历投递就要截止了，于是跟ailab的大佬说了一下这个情况，他们就给我转到流程里了，直接到HR面。4月3日下午，在实验室看论文，忽然打电话过来。主要问了这些东西。
之前的面试感受（感觉还不错呀，觉得还挺适合的）
介绍CVPR的论文（没怎么问细节，问了一下在论文中和导师的分工，还有实验效果）
毕业后的打算（工作）
家乡在哪里，对工作地和工作内容有没有什么意向，如果出省如何（偏好广东，出省也可以）
有没有亲属在腾讯（如实回答，鹅厂有亲属回避制度的）
实习时间安排
课上完了没，实验室有没有什么活没干完
问了一下我有没有问题
因为早上收到了笔试通知，所以我问了一下要不要做笔试，HR小哥说有空可以做一下，后面的流程比如offer会在清明后再联系我。
不过因为过了提前批的时间，所以系统状态里秒变不适合该岗位，内推我的面试官微信跟我说了一下这个情况，说是要4月9日之后开始实习生招聘了去更新状态，然后发offer给我，不过因为是硕士所以在AI Lab实习不一定能转正，可能会转到ai平台应用部，这边会给我实习offer（口头offer get√），但是如果想参加其他部门后面的实习招聘流程也是可以的，然后就是希望能早一点点入职。
正式offer（4月11日） 先电话确认细节，然后发短信和邮箱录用函，回邮件确认即可。
SNG QQ（2月26日） SNG QQ在我们组开组会的周五打了电话进来，问了论文和一个detection的项目，从这里开始有问一点基础知识了：
Faster RCNN和SSD有啥不同，为啥SSD快？（不做Region Proposal，one-stage的）
训练加速有什么办法？（答加大batch size，或者先adam再SGD）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337c9fb889ca3cfe1f3ca0edb32757c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c2aba884c7830b62971a149eb1a8a3/" rel="bookmark">
			如何将WinEdt 10与SumatraPDF建立互联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1:点击opinions-&gt;点击由上向下的第二个 2：进入如下页面点击红色方框处 3： 将方框处设置为SumatraPDF的地址，点击apply,然后点击ok 设置完成。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/455ffe962ff8913c436c456dc2375913/" rel="bookmark">
			FPGA的引脚VCCINT 、VCCIO VCCA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FPGA的引脚VCCINT 、VCCIO VCCA 首先是看到FPGA在配置的时候有三种不同的电VCCINT 、VCCIO VCCA，于是就查了下有什么不同：
FPGA一般会有许多引脚，那它们都有什么用呢？
VCCINT为施加于 FPGA 内核逻辑的电压，典型的电压为1.2 V、1.5 V、1.8 V、2.5 V和3V,电流可达12A（？）
专用引脚和用户引脚
FPGA引脚分为两类：专用引脚和用户自定义引脚
专用引脚大概占FPGA引脚数的20%~30%，也就是说其硬件编码都是为了实现专用功能而编写的。
而专用引脚又分为以下3个子类：
电源引脚：接地或阳极引脚（内核或IO）。
配置引脚：用来“下载”FPGA。
专用输入或时钟引脚：它们能驱动FPGA内部的大网线，适合于带有大输出端口（fanout）的时钟和信号。
其它的引脚就是用户引脚了。
用户引脚
FPGA的大部分引脚属于“用户引脚”（比如所谓的“IOs",或者"I/Os",或"用户I/Os",或"用户IOs”，或"IO引脚",或……自己理解）。IO代表“输入-输出”。
注意：
用户可以完全自定制用户IO。它们可以被编程作为输入，输出或双向IO（三向缓冲）。每个“IO引脚”被连接$到FPGA内部的IO单元上。这个“IO单元”通过VCCIO（IO加电引脚）引脚来上电。
IO簇
通常每个FPGA有很多VCCIO引脚（IO Power pins），都被加同样的电压。但是新一代的FPGA引入了“用户IO组”。可以把IO分为不同的组，每组加各自的电压。这就使FPGA可以用作一个变压转换器了，比如对于开发板部分工作于3.3v，部分工作于2.5v的很有用。（比如cyclone III系列的接DDR2要1.8V的电压）
FPGA电源
FPGA通常需要两个电压才能运行：一个是“核心电压”，另一个是“IO电压”。每个电压通过独立的电源引脚来提供。
内核电压（这里简称VCCINT）是用来给FPGA内部的逻辑门和触发器上的电压。该电压随着FPGA的发展从5v、3.3v、2.5v、1.8v、1.5v变的越来越低。核心电压是固定的。（根据所用FPGA的模式来确定）。IO电压（简称VCCIO）是用于FPGA的IO模块（同IO引脚）上的电压。该电压应该与其它连接到FPGA上的器件的电压匹配。
实际上，FPGA器件本身是允许VCCINT和VCCIO相同的（比如VCCINT和VCCIO两种引脚可以被连接在一起）。但是FPGA设计是面向低电压内核和高电压IO的，所以两种电压一般是不相同的。
命名
内部电压Xilinx简称VCC，Altera简称VCCINT；IO电压Xilinx简称VCCO，而Altera简称VCCIO。
此文章为转载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d92dba084080e9b6ab6005ad31cca94/" rel="bookmark">
			二叉树转置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4 / \ 2 7 / \ / \ 1 3 6 9 转置成
4 / \ 7 2 / \ / \ 9 6 3 1 public TreeNode invertTree(TreeNode root) { if(root==null) return null; // TreeNode nodetemp=root.right; TreeNode nodetemp=root.left; root.left=invertTree(root.right); root.right=invertTree(nodetemp); return root; }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da3facc5e07d78ab1cbef9ae07ce06f/" rel="bookmark">
			微信小程序----团购或秒杀的批量倒计时实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前效果体验二维码 如果文章对你有帮助的话，请打开微信扫一下二维码，点击一下广告，支持一下作者！谢谢！ 效果图 实现思路 微信小程序实现倒计时，可以将倒计时的时间进行每一秒的计算和渲染！
JS 模拟商品列表数据 goodsList；在 onLoad 周期函数中对活动结束时间进行提取；建立时间格式化函数 timeFormat；建立倒计时函数 countDown；在 onLoad 周期函数的提取结尾执行倒计时函数 countDown。 倒计时函数详解 获取当前时间，同时得到活动结束时间数组；循环活动结束时间数组，计算每个商品活动结束时间的倒计时天、时、分、秒；用 setData 方法刷新数据；每个一秒执行一次倒计时函数 setTimeout(this.countDown,1000)； let goodsList = [ {actEndTime: '2018/05/01 10:00:43'}, {actEndTime: '2018/04/01 11:00:00'}, {actEndTime: '2018/06/01 12:45:56'}, {actEndTime: '2018/07/01 15:00:23'}, {actEndTime: '2018/05/23 17:00:22'}, {actEndTime: '2018/05/14 19:00:44'}, {actEndTime: '2018/05/21 21:00:34'}, {actEndTime: '2018/06/17 09:00:37'}, {actEndTime: '2018/03/21 05:00:59'}, {actEndTime: '2018/04/19 07:00:48'}, {actEndTime: '2018/04/28 03:00:11'} ] Page({ data: { countDownList: [], actEndTimeList: [] }, onLoad(){ let endTimeList = []; // 将活动的结束时间参数提成一个单独的数组，方便操作 goodsList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6da3facc5e07d78ab1cbef9ae07ce06f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79280cf019393ddb206b01554691b241/" rel="bookmark">
			通过java发起http请求url中参数含有空格的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发项目的时候需要使用java发起http请求，遇到了java.io.IOException: Server returned HTTP response code: 400 for URL这个错误，但是把url放到postman中可以正常访问。造成这个问题的主要原因是因为url的参数中含有空格，我们只要把含有空格的参数URLEncoder.encode(param,"utf-8")一下就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/055ff806b8fd5e6e8617e859b5b5a195/" rel="bookmark">
			H5移动端手势滑动圆盘转动效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="viewport" content="user-scalable=no"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"/&gt; &lt;meta name="format-detection" content="telephone=no"&gt; &lt;meta http-equiv = "Cache-Control" content = "no-transform"&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8"&gt; &lt;meta name = "applicable-device" content = "mobile"&gt; &lt;title&gt;jquery.rotate旋转插件&lt;/title&gt; &lt;style&gt; #box{height:800px;width:800px;margin:100px auto;line-height:900px;text-align:Center;color:#fff;font-size:120px;background:red;transition: all 1s;border-radius:400px;} #box .out-circle{position:relative;top:150px;width:500px;height:500px;border-radius:300px;margin:0 auto;background:yellow;} #box .item{position:absolute;left:175px;top:175px;width:150px;height:150px;border-radius:75px;line-height:150px;} #box .out-circle div:nth-of-type(2){transform: rotate(60deg);} #box .out-circle div:nth-of-type(3){transform: rotate(120deg);} #box .out-circle div:nth-of-type(4){transform: rotate(180deg);} #box .out-circle div:nth-of-type(5){transform: rotate(240deg);} #box .out-circle div:nth-of-type(6){transform: rotate(300deg);} #box .out-circle div:nth-of-type(1) a{border-radius:75px;background:blue;display:block;height:150px;width:150px;transform:translateX(-325px);} #box .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/055ff806b8fd5e6e8617e859b5b5a195/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/198/">«</a>
	<span class="pagination__item pagination__item--current">199/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/200/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>