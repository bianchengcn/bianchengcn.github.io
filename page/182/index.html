<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1feca550d63c1b9ff0d1556c8d72ff93/" rel="bookmark">
			Latex学习（脚注）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		\documentclass{cctart} \begin{document} 你好世界\footnote{这是脚注}还说些什么\footnote{还是脚注} \end{document} 转载于:https://www.cnblogs.com/tiandsp/archive/2012/11/09/2762959.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0effd2cd6fbbe01df9bea5abb8b95d7c/" rel="bookmark">
			模板模式（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; using namespace std; class Road { public: Road(){} virtual ~Road(){} void operation() { start(); step1(); step2(); step3(); end(); } void start(){cout&lt;&lt;"start"&lt;&lt;endl;} void end(){cout&lt;&lt;"end"&lt;&lt;endl;} virtual void step1()=0; virtual void step2()=0; virtual void step3()=0; }; class way1 : public Road { public: way1(){} virtual ~way1(){} void step1(){cout&lt;&lt;"way1_step1"&lt;&lt;endl;} void step2(){cout&lt;&lt;"way1_step2"&lt;&lt;endl;} void step3(){cout&lt;&lt;"way1_step3"&lt;&lt;endl;} }; class way2 : public Road { public: way2(){} virtual ~way2(){} void step1(){cout&lt;&lt;"way2_step1"&lt;&lt;endl;} void step2(){cout&lt;&lt;"way2_step2"&lt;&lt;endl;} void step3(){cout&lt;&lt;"way2_step3"&lt;&lt;endl;} }; int main() { Road *pr1=new way1; Road *pr2=new way2; pr1-&gt;operation(); pr2-&gt;operation(); delete pr2; delete pr1; system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0effd2cd6fbbe01df9bea5abb8b95d7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/836fbc00f516628a5a1744f33f8a1bf9/" rel="bookmark">
			迭代器模式（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;string&gt; #define CAP 100 using namespace std; class group { public: group():pc(0){} virtual ~group(){} friend class Iterator; void push(string m) { if (pc&lt;CAP) vec[pc++]=m; } string pop() { if (!isempty()) return vec[--pc]; } bool isempty() { if (pc&lt;=0) { return true; } return false; } private: int pc; string vec[CAP]; }; class absIterator { public: absIterator(){} virtual ~absIterator(){} virtual string operator++()=0; virtual string operator++(int)=0; }; class Iterator : public absIterator { public: Iterator(group *gup):index(0),p_gup(gup){} virtual ~Iterator(){} string operator++() { return p_gup-&gt;vec[++index]; } string operator++(int) { return p_gup-&gt;vec[index++]; } private: group* p_gup; int index; }; int main() { group *gp=new group; gp-&gt;push("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/836fbc00f516628a5a1744f33f8a1bf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca5da6940f6b4a87b0e49fd3c985faf1/" rel="bookmark">
			ASP.NET获取IP与MAC[using C#]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取服务器的IP地址方法以DNS法较为简单实用，如下：
using System.Net;
private void ButtonIP_Click(object sender, System.EventArgs e)
{ System.Net.IPAddress[] addressList = Dns.GetHostByName(Dns.GetHostName()).AddressList; if ( addressList.Length&gt;1)
{ TextLIP.Text = addressList[0].ToString();
TextSIP.Text = addressList[1].ToString();
}
else
{
TextLIP.Text = addressList[0].ToString();
TextSIP.Text = "没有可用的连接";
}
}
获取服务器的IP地址与MAC地址另一方法如下：
using System.Management;
string stringMAC = "";
string stringIP = "";
ManagementClass MC = new ManagementClass "Win32_NetworkAdapterConfiguration");
ManagementObjectCollection MOC= MC.GetInstances();
foreach(ManagementObject MO in MOC)
{
if ((bool)MO["IPEnabled"] == true)
{
stringMAC += MO["MACAddress"].ToString();
TextMAC.Text = stringMAC.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca5da6940f6b4a87b0e49fd3c985faf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c7cff63ebcb3d753dc8446ae8ff82a/" rel="bookmark">
			VC实现自绘图形输出到bmp文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现方法 要把文本和图形保存到位图文件，只要对掌握位图结构有一定的了解，一切都ok呢。先必须要创建内存设备环境，然后内存设备环境创建的DIB区域，别忘 了还要创建个CBitmap对象，CBitmap对象必须和DIB区域关联起来，把CBitmap对象选择到当前设备环境，然后在当前设备环境输出文本和 图形就可以了。
具体实现代码如下 void CTestSaveBmpView::SaveAsBmp(CString filename) { //定义图形大小 int iWidth = 800; int iHeight = 600; int iPixel = 16; //图形格式参数 LPBITMAPINFO lpbmih = new BITMAPINFO; lpbmih-&gt;bmiHeader.biSize = sizeof(BITMAPINFOHEADER); lpbmih-&gt;bmiHeader.biWidth = iWidth; lpbmih-&gt;bmiHeader.biHeight = iHeight; lpbmih-&gt;bmiHeader.biPlanes = 1; lpbmih-&gt;bmiHeader.biBitCount = iPixel; lpbmih-&gt;bmiHeader.biCompression = BI_RGB; lpbmih-&gt;bmiHeader.biSizeImage = 0; lpbmih-&gt;bmiHeader.biXPelsPerMeter = 0; lpbmih-&gt;bmiHeader.biYPelsPerMeter = 0; lpbmih-&gt;bmiHeader.biClrUsed = 0; lpbmih-&gt;bmiHeader.biClrImportant = 0; //创建位图数据 HDC hdc,hdcMem; HBITMAP hBitMap = NULL; CBitmap *pBitMap = NULL; CDC *pMemDC = NULL; BYTE *pBits; hdc = CreateIC(TEXT("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78c7cff63ebcb3d753dc8446ae8ff82a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02f74af89ea68ad6954d578437f9e1f/" rel="bookmark">
			IBatisNet.DataMapper 升级到 1.6.2  之后报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Code private static volatile ISqlMapper _mapper = null;
protected static void Configure(object obj)
{
_mapper = null;
}
protected static void InitMapper()
{
ConfigureHandler handler = new ConfigureHandler(Configure);
DomSqlMapBuilder builder = new DomSqlMapBuilder();
_mapper = builder.ConfigureAndWatch(handler);
}
public static ISqlMapper Instance()
{
if (_mapper == null)
{
lock (typeof(SqlMapper))
{
if (_mapper == null) // double-check
{
InitMapper();
}
}
}
return _mapper;
}
public static ISqlMapper Get()
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c02f74af89ea68ad6954d578437f9e1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e9119c8d893cac0e8206045f75b9089/" rel="bookmark">
			gitlab-ci前端在阿里云实现nodejs可持续化集成部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 不甘心当一个切图仔，所以什么都要学一下；可持续化集成是一个项目工程架构的问题；但在这篇文章中我将它缩小到了前端的领域内。
必要条件 一台阿里云服务器-2核4G以上(CentOS7-ECS我的心好痛800大洋) 技术栈 linux操作基础git/github/gitlabnodejs环境基础 步骤 阿里云安装git阿里云安装gitlab(8.0开始默认支持gitlab-ci)阿里云安装gitlab-runner写测试.gitlab-ci.ymltag自动运行nodejs项目实践 阿里云安装git 安装Git工具linux：安装Git，使用自带的源安装。
yum install git 阿里云安装gitlab 1.安装依赖包。
sudo yum install -y curl policycoreutils-python openssh-server 2.设置SSH开机自启动并启动SSH服务。
sudo systemctl enable sshd sudo systemctl start sshd 3.添加GitLab软件包仓库。
curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash 4.安装GitLab。
sudo EXTERNAL_URL="GitLab服务器的公网IP地址" yum install -y gitlab-ce 我的ip是这个39.100.42.98；然后开放了一个8888端口（记得去阿里云管理平台上开放）；所以我的 GitLab服务器的公网IP地址 是 http://39.100.42.98:8888
5.安装成功就可以访问了
6.登录GitLab
在浏览器的地址栏中输入ECS服务器的公网IP即可登录GitLab的界面，第一次登录使用的用户名和密码为 root 和 5iveL!fe。
首次登录会强制用户修改密码。密码修改成功后，输入新密码进行登录。
7.小结：
这个gitlab相对于是一个正常的gitlab/github;我们可以在上面创建自己的项目，它同样支持我们在本地电脑的git连接传输数据(同样需要设置ssh密钥)
参考地址
阿里云安装gitlab-runner 1.官方安装-参考地址
如果你英语不是很好的话也不要担心，其实就是复制那行运行代码运行而已！
2.清华镜像包-参考地址
由于我买的服务器是国内的，不能用官方安装所以只能用清华的镜像包(你懂得万里长城)。安装过程也不难，仔细点，耐心点就ok了。
3.详细的教程
成功后我们服务器上会有一个gitlab-runner文件夹，它会直接同步我们gitlab上开启了runner的项目到它这里。
写测试.gitlab-ci.yml 1.在我们的gitlab上创建一个项目，我命名为ci-vue-cli
2.将该项目克隆到我们的本地电脑，然后在该目录下添加一个.gitlab-ci.yml文件
内容就随便写一个job吧
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e9119c8d893cac0e8206045f75b9089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec07341eed70bef105280cd2c769c8d5/" rel="bookmark">
			清除（设置）CCS5.5 eclipse的workspace记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用eclipse进行开发的时候，首先要选择workspace。 一些workspace是不会再被使用的，可是switch workspace时它老是在那碍眼，怎么清楚它呢? 在eclipse文件夹中找到这个文件即可： //eclipse/configuration/.settings/org.eclipse.ui.ide.prefs 用记事本打开这个文件。如果你是第一次打开eclipse，他默认的workspace是 RECENT_WORKSPACES=C/://Documents and Settings//Administrator//workspace 如果你使用过多个workspace，参数RECENT_WORKSPACES后面会有多个用回车符（/n）分隔的路径。 删除你不需要的workspace路径，然后重启eclipse即可。 现在打开switch workspace看看，心情好多了。 转载于:https://www.cnblogs.com/derek32/p/4091135.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a877df38b50efb0450ff749c1eca3737/" rel="bookmark">
			算法7-排序-归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		归并排序的基本思想 将待排序序列R[0...n-1]看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表；将这些有序序列再次归并，得到n/4个长度为4的有序序列；如此反复进行下去，最后得到一个长度为n的有序序列。
综上可知：
归并排序其实要做两件事：
（1）“分解”——将序列每次折半划分。
（2）“合并”——将划分后的序列段两两合并后排序。
我们先来考虑第二步，如何合并？
在每次合并过程中，都是对两个有序的序列段进行合并，然后排序。
这两个有序序列段分别为 R[low, mid] 和 R[mid+1, high]。
先将他们合并到一个局部的暂存数组R2中，带合并完成后再将R2复制回R中。
为了方便描述，我们称 R[low, mid] 第一段，R[mid+1, high] 为第二段。
每次从两个段中取出一个记录进行关键字的比较，将较小者放入R2中。最后将各段中余下的部分直接复制到R2中。
经过这样的过程，R2已经是一个有序的序列，再将其复制回R中，一次合并排序就完成了。
核心代码
public void Merge(int[] array, int low, int mid, int high) { int i = low; // i是第一段序列的下标 int j = mid + 1; // j是第二段序列的下标 int k = 0; // k是临时存放合并序列的下标 int[] array2 = new int[high - low + 1]; // array2是临时合并序列 // 扫描第一段和第二段序列，直到有一个扫描结束 while (i &lt;= mid &amp;&amp; j &lt;= high) { // 判断第一段和第二段取出的数哪个更小，将其存入合并序列，并继续向下扫描 if (array[i] &lt;= array[j]) { array2[k] = array[i]; i++; k++; } else { array2[k] = array[j]; j++; k++; } } // 若第一段序列还没扫描完，将其全部复制到合并序列 while (i &lt;= mid) { array2[k] = array[i]; i++; k++; } // 若第二段序列还没扫描完，将其全部复制到合并序列 while (j &lt;= high) { array2[k] = array[j]; j++; k++; } // 将合并序列复制到原始序列中 for (k = 0, i = low; i &lt;= high; i++, k++) { array[i] = array2[k]; } } 掌握了合并的方法，接下来，让我们来了解 如何分解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a877df38b50efb0450ff749c1eca3737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68b343054c4c220d0c2822e2760318c/" rel="bookmark">
			存储过程和视图的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL里面不带参数的存储过程与视图的区别
1、存储过程是程序化的sql可以实现一般sql不能实现的功能。 如：先检索一个表得到一些数据，经过一定的编辑后更新到另外一个表中、这就可以用不带参数的存储过程实现。 2、视图是虚拟表，不存储数据，存储的是sql，检索他的时候实际上是执行定义它的sql语句。
说明：从你的问题上可以看出，你使用存储过程仅仅是用它检索数据，所以你会产生这样的疑问，一定要记住，存储过程理解的简单一点就是“数据库中的程序”,
可以在不需要外部程序（如C，java，vb等）的情况下，让数据库自己解决复杂的、用一般sql不能实现的功能，而视图则不然。
视图和存储过程比是没什么意义的 视图就是虚拟表，把视图和表比较还有点意思 视图不占实际空间，可以对任意的表进行叠加和剪裁，利用分区视图的功能，能加快表的I/O读取时间（需要2块以上硬盘）
视图只不过是存储在sql server上的select语句罢了，当对视图请求时，sql server会像执行一句普通的select语句那样的执行视图的select语句，它的性能并不像人们想象得那么出色。 而存储过程在编译后可以生成执行计划，这使得每次执行存储过程的时候效率将会更高，这是存储过程，另外台提交参数的时候，使用存储过程将会减少网络带宽流量，这是存储过程相对于普通的sql语句在性能上的最大的优势。
视图可以被看成是虚拟表或存储查询。可通过视图访问的数据不作为独特的对象存储在数据库内。数据库内存储的是 SELECT 语句。SELECT 语句的结果集构成视图所返回的虚拟表。用户可以用引用表时所使用的方法，在 Transact-SQL 语句中通过引用视图名称来使用虚拟表。使用视图可以实现下列任一或所有功能：
将用户限定在表中的特定行上。 例如，只允许雇员看见工作跟踪表内记录其工作的行。 将用户限定在特定列上。 例如，对于那些不负责处理工资单的雇员，只允许他们看见雇员表中的姓名列、办公室列、工作电话列和部门列，而不能看见任何包含工资信息或个人信息的列。 将多个表中的列联接起来，使它们看起来象一个表。 聚合信息而非提供详细信息。 例如，显示一个列的和，或列的最大值和最小值。 ------------------ 数据库中的索引与书籍中的索引类似。在一本书中，利用索引可以快速查找所需信息，无须阅读整本书。在数据库中，索引使数据库程序无须对整个表进行扫描，就可以在其中找到所需数据。 ------------------ 存储过程可以使得对数据库的管理、以及显示关于数据库及其用户信息的工作容易得多。存储过程是 SQL 语句和可选控制流语句的预编译集合，以一个名称存储并作为一个单元处理。存储过程存储在数据库内，可由应用程序通过一个调用执行，而且允许用户声明变量、 有条件执行以及其它强大的编程功能。 存储过程可包含程序流、逻辑以及对数据库的查询。它们可以接受参数、输出参数、返回单个或多个结果集以及返回值。 可以出于任何使用 SQL 语句的目的来使用存储过程，它具有以下优点： 可以在单个存储过程中执行一系列 SQL 语句。 可以从自己的存储过程内引用其它存储过程，这可以简化一系列复杂语句。 存储过程在创建时即在服务器上进行编译，所以执行起来比单个 SQL 语句快。 转载于:https://www.cnblogs.com/Eleanore/archive/2012/06/11/2545384.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0670bb4ba163db51f949bb17ed4c602/" rel="bookmark">
			同步传输和异步传输的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网络通信过程中，通信双方要交换数据，需要高度的协同工作。为了正确的解释信号，接收方必须确切地知道信号应当何时接收和处理，因此定时是至关重要的。在计算机网络中，定时的因素称为位同步。同步是要接收方按照发送方发送的每个位的起止时刻和速率来接收数据，否则会产生误差。通常可以采用同步或异步的传输方式对位进行同步处理。
1. 异步传输（Asynchronous Transmission）： 异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方从不知道它们会在什么时候到达。一个常见的例子是计算机键盘与主机的通信。按下一个字母键、数字键或特殊字符键，就发送一个8比特位的ASCII代码。键盘可以在任何时刻发送代码，这取决于用户的输入速度，内部的硬件必须能够在任何时刻接收一个键入的字符。
异步传输存在一个潜在的问题，即接收方并不知道数据会在什么时候到达。在它检测到数据并做出响应之前，第一个比特已经过去了。这就像有人出乎意料地从后面走上来跟你说话，而你没来得及反应过来，漏掉了最前面的几个词。因此，每次异步传输的信息都以一个起始位开头，它通知接收方数据已经到达了，这就给了接收方响应、接收和缓存数据比特的时间；在传输结束时，一个停止位表示该次传输信息的终止。按照惯例，空闲（没有传送数据）的线路实际携带着一个代表二进制1的信号，异步传输的开始位使信号变成0，其他的比特位使信号随传输的数据信息而变化。最后，停止位使信号重新变回1，该信号一直保持到下一个开始位到达。例如在键盘上数字“1”，按照8比特位的扩展ASCII编码，将发送“00110001”，同时需要在8比特位的前面加一个起始位，后面一个停止位。
异步传输的实现比较容易，由于每个信息都加上了“同步”信息，因此计时的漂移不会产生大的积累，但却产生了较多的开销。在上面的例子，每8个比特要多传送两个比特，总的传输负载就增加25%。对于数据传输量很小的低速设备来说问题不大，但对于那些数据传输量很大的高速设备来说，25%的负载增值就相当严重了。因此，异步传输常用于低速设备。
2. 同步传输（Synchronous Transmission）：同步传输的比特分组要大得多。它不是独立地发送每个字符，每个字符都有自己的开始位和停止位，而是把它们组合起来一起发送。我们将这些组合称为数据帧，或简称为帧。
数据帧的第一部分包含一组同步字符，它是一个独特的比特组合，类似于前面提到的起始位，用于通知接收方一个帧已经到达，但它同时还能确保接收方的采样速度和比特的到达速度保持一致，使收发双方进入同步。
帧的最后一部分是一个帧结束标记。与同步字符一样，它也是一个独特的比特串，类似于前面提到的停止位，用于表示在下一帧开始之前没有别的即将到达的数据了。
同步传输通常要比异步传输快速得多。接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们。另外，同步传输的开销也比较少。例如，一个典型的帧可能有500字节（即4000比特）的数据，其中可能只包含100比特的开销。这时，增加的比特位使传输的比特总数增加2.5%，这与异步传输中25 %的增值要小得多。随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少。但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小。另外，帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久。
同步传输方式中发送方和接收方的时钟是统一的、字符与字符间的传输是同步无间隔的。
异步传输方式并不要求发送方和接收方的时钟完全一样，字符与字符间的传输是异步的。
同步与异步传输的区别
1,异步传输是面向字符的传输，而同步传输是面向比特的传输。
2,异步传输的单位是字符而同步传输的单位是桢。
3,异步传输通过字符起止的开始和停止码抓住再同步的机会，而同步传输则是以数据中抽取同步信息。
4,异步传输对时序的要求较低，同步传输往往通过特定的时钟线路协调时序。
5,异步传输相对于同步传输效率较低。
如果往磁盘里写，异步是先写到Buffer，再写到目标磁盘，比如原写 1 2 3 4 5，而目标端只写了1。同步是不等收到没收到都会写到本地磁盘，容易造成Buffer阻塞。同步传输通常要比异步传输快速得多。接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们。另外，同步传输的开销也比较少　转载于:https://www.cnblogs.com/Eleanore/archive/2012/01/06/2314684.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84477a1538acd7515fefa0d57b0994dd/" rel="bookmark">
			-bash：rm：找不到命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行yum重新安装coreutils，它将被修复
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c694e87902ac5c32bb0728e5b8ffc6f/" rel="bookmark">
			Dependency introduction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dependency Walker 是 Microsoft Visual C++ 中提供的非常有用的 PE 模块依赖性分析工具。主要功能如下：
查看 PE 模块的导入模块。
查看 PE 模块的导入和导出函数。
动态剖析 PE 模块的模块依赖性。
解析 C++ 函数名称。
Dependency Walker的另一个重要用途就是分析DLL(动态链接库)的详细信息，适合有经验用户进行分析。
转载于:https://www.cnblogs.com/kungfupanda/archive/2012/08/30/2663339.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89544487d97216267d053e789f7c4791/" rel="bookmark">
			sprintf_s与_snprintf与_snprintf_s
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int snprintf(char *str, size_t size, const char *format, ...); 将可变个参数(...)按照format格式化成字符串，然后将其复制到str中 (1) 如果格式化后的字符串长度 &lt; size，则将此字符串全部复制到str中，并给其后添加一个字符串结束符('\0')； (2) 如果格式化后的字符串长度 &gt;= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符('\0') 函数返回值:若成功则返回欲写入的字符串长度，若出错则返回负值。 -------------------------------------------- #include &lt;stdio.h&gt; //snprintf() #include &lt;string.h&gt; //strlen() int main() { char toname[30]; char *name = "yangtaiping"; printf("strlen(name) = %d\n", strlen(name)); snprintf(toname, strlen(name)+strlen("姓名：")+1, "姓名：%s", name); printf("toname = %s\n", toname); printf("strlen(name) = %d\n", strlen(name)); } strcpy() sprintf() strcat() 存在安全隐患， 其对应的安全版为：strncpy() snprintf() strncat() 。　snprintf(s, 100, "%.*S", 3, "abcd");s的值为abc %.*s 表示有两项， 第一项指定了长度，第二项则是%s的内容，所以取前三位 词条图册更多图册 类似的函数还有： #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89544487d97216267d053e789f7c4791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acc2d99b8f55a429503f9666ca188932/" rel="bookmark">
			三大运营商移动电话用户总数达15.9亿户 同比增长6.2%
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【TechWeb】日前，工信部发布《2019年1-5月份通信业经济运行情况》。数据显示，截至5月底，三家基础电信企业的移动电话用户总数达15.9亿户，同比增长6.2%，但比上月末减少162万户。其中，移动宽带用户（即3G和4G用户）总数达13.5亿户，占移动电话用户的85%；4G用户规模为12.2亿户，占移动电话用户的76.7%，较上年末提高2.3个百分点。
其中，百兆速率以上宽带用户占比超四分之三，光纤接入用户占比稳步提升。截至5月底，三家基础电信企业的固定互联网宽带接入用户总数达4.31亿户，1－5月净增2412万户。其中，光纤接入（FTTH/O）用户3.93亿户，占固定互联网宽带接入用户总数的91%。宽带用户持续向高速率迁移, 100Mbps及以上接入速率的固定互联网宽带接入用户达3.28亿户，占总用户数的76%，占比较上年末提高5.7个百分点。
IPTV用户规模不断扩大。截至5月底，三家基础电信企业发展IPTV（网络电视）用户达2.78亿户。手机上网用户数为12.9亿户，对移动电话用户的渗透率为81.5%。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aef0d56755f61cc6817fdb40f769865/" rel="bookmark">
			How to revising your document, based on Silyn-Roberts, ch. 16
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		How to revising your document, based on Silyn-Roberts, ch. 16 Five stage process:
1. Structure and content only
Have you followed your plan?Is the overall structure logical?Are the sections in a logical order?Are the subsections within a section in a logical order?Will the relationship between ideas be clear to the reader? 2. Style, grammar, punctuation, equations
3. Proofread
Find:
typosirregular spacingerrors in punctuationerrors in spellingomitted wordsfunny fonts or formattingerrors in equations, figures, tables 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aef0d56755f61cc6817fdb40f769865/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf2943ed54e072fa3d16e9d09bc6b63/" rel="bookmark">
			神一样的存在，河北衡水中学2019高考再次碾压所有中学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在各省的高考成绩已经出炉，分数不错的考生们近几天已经开始报志愿选择自己喜欢的大学，但是分数一般的或者觉得自己分数有更大提升空间的同学也开始了自己复读的道路。因此很多同学选择河北高考的神话中学衡水中学，那衡水中学在2019年高考的成绩是什么样呢，一起来看看吧！
在2019年高考中，衡水中学又是不出意外的包揽了全省的文科状元和理科状元，其中王昊同学以717分的成绩夺得河北省理科状元，王天亮同学以685的裸分成绩夺得了河北的文科状元。河北省理科的前十名全部出于衡水中学，理科的前十名衡水中学包揽了八名；理科前二十名有十八人来自衡水中学，文科前二十名有十名来自衡水中学；理科前三十名有二十八名来自衡水中学，文科有十六人进入全省前三十名；理科前五十名有四十一人来自衡水中学，文科二十六人进入全省前五十名；其中理科700分以上有23人，占全省的85%，696分以上有68人，占全省的66%；文科678分以上有8人，占全省的62%，670分以上有22人占全省的52%。
自古河北状元出衡中，好似河北省每年的高考状元都出自河北衡水中学，我们一起回顾一下。2017年理科状元窦艺高考分数710分来自衡水中学；2016年文科状元袁嘉玮分数706分来自衡水中学，理科状元孟祥熙分数724分来自衡水中学；2014年文科状元郭宁分数676分来自衡水中学，理科状元李榕榕分数715分来自衡水中学；2013年文科状元于潇676分来自衡水中学，理科状元分数孟令航703分来自衡水中学。可以看到从2013年到2019年7年的时间，有4年的河北高考状元是完全被衡水中学包揽，还有一年就是2017年仅有理科状元出自衡水中学。貌似衡水中学从来没有让人失望过，每年它一所中学上名校的人数甚至要比全省所有中学加起来还要多。
在2019年衡水有62人通过了清华大学自主招生的初审，其中衡水中学就占了43人，人们常说在河北衡水中学就是给清华、北大培养人才的重点重点中学。据数据统计，2019年在衡水中学预计被清华北大录取人数要达到200余人，占整个河北省清华、北大名额的90%以上。
当然这么傲人的成绩肯定是和学校严格的制度分不开的。学生在学校各种小的碎片化时间都被分配的非常合理，从早上5:40到晚上22:10都有着明确的时间规定，这样看似模式化的管理，带来的效果是非常突出的。总有人说衡水中学这样的高考加工厂不适合存在，但是在现在的应试教育大环境下，或许这才是最好的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82c1a5426ec847cf4d73bd4f6fd6dbc2/" rel="bookmark">
			C 单向链表之动态链表：尾插法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C 单向链表之动态链表：尾插法 尾插法：在尾节点后插入，每插入一个元素，将其作为尾节点。 一、动态链表 静态链表的意义不是很大，主要是因为数据存储在栈上，栈的存储空间有限，不能动态分配。所以链表要实现存储的自由，要动态申请堆里的空间。
二、动态链表的实现 节点和静态链表节点的定义一样：
typedef struct node { int data; //数据域：存储数据 struct node * next; //指针域：指向下一个节点（指向谁，就保存了谁的地址） }Node; 可将动态链表的结构用如下小火车表示：
实现代码 创建一个动态链表，输入0结束。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct node { int data; //数据域：存储数据 struct node * next; //指针域：指向下一个节点（指向谁，就保存了谁的地址） }Node; Node * createList(); int main() { Node * head = createList(); Node * pHead = head; pHead = pHead-&gt;next; while (pHead) { printf("%d\n",pHead-&gt;data); pHead = pHead-&gt;next; } return 0; } Node * createList() { Node *head = (Node*)malloc(sizeof(Node)); if(NULL == head) exit(-1); head-&gt;next = NULL; Node *tmp = head, *ptr; int inputData; scanf_s("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82c1a5426ec847cf4d73bd4f6fd6dbc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff36cc29d5b8f95b48df83f410fdcf4f/" rel="bookmark">
			查询的数据出现Bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询的数据出现Bug
开发工具与关键技术：SQL Server 2014 Management Studio 查询出现的Bug
作者：李国旭
撰写时间：2019年6月27日
我们在做项目的时候经常会出现一些问题，也就是所谓的“BUG”。不断地创造和修复，同样在修复BUG的同时也能让自己学到更多的知识。查询数据的时候经常出现无数据或者是数据异常（Erro）还有的就是常见的500错误……等等这些BUG。有时候传错参数ID、打错了个单词、路径（URL）错了都会出现500和404还有的就是报应用程序出错，这就是我们常见的BUG。
在数据库中查询的话，它语句中我们可以使用一个或者多个表，表之间就使用逗号分割，并使用Where语句来设定查询条件。select它的命令可以读取一条或者多条记录。 你可以使用星号来代替其他字段，SELECT语句会返回表的所有字段数据 你可以使用 WHERE 语句来包含任何条件。 你可以通过offset指定select语句开始查询的数据偏移量。默认情况下它的偏移量就是为0。 当然了我们还可以可以使用 limt 属性来设定返回的记录数。
上面的那张表就是数据重载了之后路径没写对出现的BUG，而下面的就是页面的路径跟控制器那边的路径名称不对应，所以就会出现404找不到
下面的是单表查询的代码，如果我们不给它传参数的话就会出现无数据的状态，不知道是自己写的代码的问题还是不给参数就不行，我这里查询这张表的所有数据；当然还有多表查询同时Join多张表或者可以左连接右连接的把这张表的数据查询出来。那么该语句会读取左边的数据表的所有选取的字段数据
多表查询的时候需要创建一个类来装自己所需要的字段和属性名称，方便我们去查询数据，所以说为了避免一些错就一定要创建那个表类
联表所查询出来的数据，而且我是用了表格的数据重载的方法来做的，所以每一次新增的数据呢它都会显示在第一条，而不会跑到最后面去。假如我们有很庞大的数据的话，不用数据重载那么结果可想而知，可以找到天荒地老了；那么为了避免这个问题呢就需要用到这表格的数据重载了。
效果图,如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ecf6ec3ffe6a2c94332e2360591391c/" rel="bookmark">
			我们常用的基础SQL Server能干啥？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们常用的基础SQL Server能干啥？
开发工具与关键技术：SQL Server 2014 Management Studio SQL Server数据库的功能
作者：李国旭
撰写时间：2019年6月27日
SQL Server 2014 Management Studio，这个就是SQL Server的全称。就是我们现阶段经常会用它来建数据库，当然建数据库的工具不止它这个还有其他的工具可以用；比如说：MySQL、Oracle、MS Access…等等。只不过上面说的这些的工具还没有接触到，所以我们只能用SQL Server 2014 Management Studio这个来干活了。它呢是用于访问和处理数据库的标准计算机语言。
平常，SQL Server我们都是用来对数据库进行查询数据，或者从数据库中取回数据也同样可以在我们的数据中插入新的数据；还可以更新数据库中的数据和删除数据库中的数据，也可以创建新的数据库、创建新的表、创建存储的过程、创建视图，还有就是可以设置表、存储过程和视图的权限。
SELECT 语句用于从数据库中选取数据，那么它的结果呢是被存储在一个结果表中，又称为结果集。注意：SQL Server对大小写是不敏感而且SELECT和select是一样的。还有就是分号的问题，它在其他的数据库的系统里面可能会要求每条语句末端使用分号；分号是在数据库的系统中分隔每条SQL Server语句的标准方法，这样就可以再对服务器的相同请求中执行更多的SQL的语句。
如下图所示的是SQL查询的语句，所查询到的数据都可以看得到：
我们不仅要会手敲代码，而且要学会手写代码，所以要记住一些重要的SQL命令，例如：SELECT - 从数据库中提取数据；UPDATE - 更新数据库中的数据；DELETE - 从数据库中删除数据；INSERT INTO - 向数据库中插入新数据；CREATE DATABASE - 创建新数据库；ALTER DATABASE - 修改数据库；CREATE TABLE - 创建新表；ALTER TABLE - 改变数据库中表；DROP TABLE - 删除表；CREATE INDEX - 创建索引；DROP INDEX - 删除索引。这样不管我们去到哪家公司面试对这样的数据库的题就不会感觉到头疼，所以就要学会手写代码。
每一次的更改数据库中的数据表和插入新的值，一定要记得刷新一下数据库和在Model中更新数据表，如果不更新那么我们想要的数据也得不到。在更新之前呢先删除原先的表，再进行从数据库中更新模型
首先，在空白处右键就会弹出下面那个提示框就可以进行下面的操作了，就是在Visual Studio 2015里面的Models的那里点击进去进行从模型删除，然后再从数据库更新模型就可以了。
如下图所示：
数据库中的视图可以当成表来使用，比如说我们的权限就可以通过创建视图来制作他们的权限和其他的操作等等
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/181/">«</a>
	<span class="pagination__item pagination__item--current">182/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/183/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>