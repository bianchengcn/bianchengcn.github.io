<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ab34b5da8a54d26d096b33279b6fe3/" rel="bookmark">
			win10完美解决文字锯齿问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		别的不说，直接上步骤............
接下来，就是各种下一步.........
ok了，就是这么简单
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5a3da782488979be0171a6f38384072/" rel="bookmark">
			恢复上一次注册表数据（误删注册表的恢复）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将文件夹：C:\Windows\System32\config\RegBack中数据全部拷贝到C:\Windows\System32\config中即可 PS：cmd拷贝文件命令copy 来源 目标
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a850eb37c5f4a4c94bdb1694a0fc3a/" rel="bookmark">
			js查看Object对象的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设将对象赋给test，此时test是也是对象。
var test = object; 一、查看对象内容(一级对象)。 for(i in test ){ alert(i); //获得属性 alert(test[i]); //获得属性值 } 二、查看对象里的对象(二级及以上) for(i in test ){ alert(i); alert(test[i].toSource()); } 比如在微信支付中的应用，微信公众号支付，使用JS调起微信支付： &lt;script type="text/javascript"&gt; var jsApiParameters = {$jsApiParameters}; function jsApiCall() { //alert(jsApiParameters.appId); WeixinJSBridge.invoke( 'getBrandWCPayRequest', jsApiParameters, function(res) { //WeixinJSBridge.log(res.err_msg); //alert(res.err_msg); for(i in res ){ alert(i); //获得属性 alert(res[i]); //获得属性值 } if(res.err_msg == 'get_brand_wcpay_request:ok') { //alert(res.err_msg); window.location.href=APP+'?m=Index&amp;a=index&amp;sid='+sid+'&amp;fuid='+fuid; } else if(res.err_msg == 'get_brand_wcpay_request:cancel') { //用户取消 } else if(res.err_msg == 'get_brand_wcpay_request:fail') { //发送失败 }else if(res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a850eb37c5f4a4c94bdb1694a0fc3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ee42f3f68cb3aa005f9d8632f918688/" rel="bookmark">
			Django&#43;Markdown&#43;Pygments 支持Markdown 实现代码高亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown部分 安装markdown pip install markdown 在view.py中导入包 from markdown import markdown使用markdown()将需要用markdown格式解析的内容（字符串）封装起来。 注：models里面有一个Article类，Article里面有一项是content存储博客内容。
def detail(request, id): try: post = Article.objects.get(id=str(id)) #for markdown test post.content = markdown(post.content) except Article.DoesNotExist: raise Http404 return render(request, 'post.html', {'post' : post}) 在后台编辑博文 &gt; ## This is a test. &gt; &gt; 1. This is the first list item. &gt; 2. This is the second list item.
前台显示 {{ post.content | safe}}，注意使用了safe过滤器，防止内容在输出前被解析。 ps：和这个问题是一个原因，django数据库里Html代码，如何在前台让浏览器正确解析?
完 Pygments部分 官网下载最新的版本的Pygments。使用pip安装下载的包Pygments-2.0.2.tar.gz,敲命令pip install Pygments-2.0.2.tar。运行如下命令pygmentize -S default -f html -a .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ee42f3f68cb3aa005f9d8632f918688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a6e821979eb7155b393969bc4cffbbf/" rel="bookmark">
			Linux2.6.32驱动笔记（4）ioctl方法解析及mini2440-led驱动实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要： 介绍了字符设备驱动的控制方式——ioctl，同时利用该方式在mini2440上实现led驱动。
驱动中，除了read,write,open,close之外，还有很多的访问方式，其中对于设备的控制，ioctl是一种重要的方式。
一、ioctl函数
int ioctl(int fd,unsigned long cmd,…)
fd:要控制的设备文件描述符
cmd:发送给设备的控制命令
…:可选参数，依赖于第二个cmd参数
当应用程序使用ioctl的时候，驱动程序将由如下驱动函数来响应：
2.6.36内核以前：
long(*ioctl)(struct inode *inode,struct file *filp,unsigned int cmd,unsigned longarg)
2.6.36内核以后：
long(*unlock_ioctl)( struct file *filp,unsigned int cmd,unsigned long arg)
二、控制实现步骤
1.定义命令
命令其实是一个整数，但是为了可读性更好，分为四个段，分别是：类型（幻数）8位，序号8位，传送方向2位，参数大小14位。
type(类型/幻数)：表明这是属于哪个设备的命令；
number(序号)：用来区分同一个设备的不同命令；
direction:参数传递方向，可能的值是没有传输方向，读或者写；
size:参数长度。
命令宏，Linux提供了一组宏来帮助定义命令:
_IO(type,nr):不带参数的命令；
_IOR(type,nr,datatype):从设备中读参数的命令；
_IOW(type,nr,datatype):向设备写入参数的命令；
_IOWR(type,nr,datatype)：双向传输。
其中命令的type 和size是通过datatype中取对应位得来。
2.实现操作
这个模式就是switch case，我们给进去定义的命令，然后让switch去匹配，匹配到哪个就执行相应的操作，都没有匹配到就返回-EINVAL。
switchcmd
case命令A：
//执行A对应的操作
case命令B：
//执行B对应的操作
default:
//return–EINVAL
三、LED字符驱动实现
首先，mini2440上和四个led相连接的gpio口分别是PORTB的5,6,7,8四个端口。那么就需要定义寄存器的基地址，并且使用ioremap把它映射到用户空间给我们使用。
led.c如下：
&lt;span style="font-size:18px;"&gt;#include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/io.h&gt; //#include &lt;mach/gpio-bank-k.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a6e821979eb7155b393969bc4cffbbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d89c0fd0d8e03486069d8f99ab61f742/" rel="bookmark">
			数据库优化之利用索引、避免全表扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 5.in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d89c0fd0d8e03486069d8f99ab61f742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab15f10f057829f7fa21b68af41a7a87/" rel="bookmark">
			【Cocos2dx】基本动作、动作序列与动作合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前几篇关于Cocos2dx的文章都是从一些静态的事物入手，比如控件、场景什么的。其实，Cocos2dx中提供了大量动作实现方法，移动一个精灵并不是那么费事，直接调用该方法即可，唯一的难点就是多个动作如何组合起来，下面用一个例子来说明这个问题。
做出如下的实例：
有一个已经被玩烂的自带按钮精灵，首先闪烁3下，之后向上移动，等待1秒之后向下跳动，之后旋转缓慢下落。
这个效果很赞很赞，如果要用Flash等其它语言去搞不知道要浪费多少关键帧与代码，但是Cocos2dx实现起来就很简单了。
制作过程如下：
首先还是新建一个用cpp语言写的名为moveAction的Cocos2dx工程，打开里面proj.win32的HelloCpp.sln开始程序编写，此步骤已经在此前文章多次提及，不会的可以参看《【Cocos2dx】Windows平台下Cocos2dx 2.x的下载、安装、配置，打造自己的Helloworld》（点击打开链接）。
之后，在AppDelegate.cpp关掉调试信息之后，直接对HelloWorldScene.cpp修改成如下，重点对其中的bool HelloWorld::init()函数进行修改：
#include "HelloWorldScene.h" USING_NS_CC; CCScene* HelloWorld::scene() { // 'scene' is an autorelease object CCScene *scene = CCScene::create(); // 'layer' is an autorelease object HelloWorld *layer = HelloWorld::create(); // add layer as a child to scene scene-&gt;addChild(layer); // return the scene return scene; } // on "init" you need to initialize your instance bool HelloWorld::init() { //获取屏幕的尺寸、位置信息等 CCSize visibleSize = CCDirector::sharedDirector()-&gt;getVisibleSize(); //设置精灵，并把精灵添加到舞台的中央 CCSprite *sprite=CCSprite::create("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab15f10f057829f7fa21b68af41a7a87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8fb9e48b492c0ab400e4200ad7b68d2/" rel="bookmark">
			记录java位运算的一些用途
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 判断int型变量a是奇数还是偶数 a&amp;1 = 0 偶数 a&amp;1 = 1 奇数 2. 求平均值，比如有两个int类型变量x、y,首先要求x+y的和，再除以2，但是有可能x+y的结果会超过int的最大表示范围，所以位运算就派上用场啦。 (x&amp;y)+((x^y)&gt;&gt;1); 3. 对于一个大于0的整数，判断它是不是2的几次方 ((x&amp;(x-1))==0)&amp;&amp;(x!=0)； 4. 比如有两个int类型变量x、y,要求两者数字交换，位运算的实现方法：性能绝对高效 x ^= y; y ^= x; x ^= y; 5. 求绝对值 int abs( int x ) { int y ; y = x &gt;&gt; 31 ; return (x^y)-y ; //or: (x+y)^y } 6. 取模运算，采用位运算实现： a % (2^n) 等价于 a &amp; (2^n - 1) 7. 乘法运算 采用位运算实现 a * (2^n) 等价于 a &lt;&lt; n 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8fb9e48b492c0ab400e4200ad7b68d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb45416afe7fae9ff588ffa96eee1ea/" rel="bookmark">
			【C&#43;&#43;】求数组中所有元素的排列或组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本目标是这样的，比如有如下的数组{0,1,2,3,7,8,12,40,51}需要求出其所有排列与组合，
需要求出其所有组合，做出如上的结果，也就是随便在数组中挑两个数组成一个对子。
代码如下，这里需要用到一个两组循环：
void Combination(int* arr,int arr_length){ for(int i=0;i&lt;arr_length-1;i++){ for(int j=i+1;j&lt;arr_length;j++){ cout&lt;&lt;"{"&lt;&lt;arr[i]&lt;&lt;","&lt;&lt;arr[j]&lt;&lt;"}"; } } } 思想是指针j从i，这个从数组开始到数组末尾不停缓慢移动的指针，移到数组末尾，输出数组中脚标为i与j的两个元素，之后i++，j回到i这个位置。
好像很复杂的样子，但是联系到C语言中著名的冒泡排序，就很简单的。
其实冒泡排序也是用到这种类似的双重循环的思想，只是每次循环，j的指针不是回到i这个位置，而是回到数组开头。
以下是冒泡排序的代码：
void bubbleSort(int* arr,int arr_length){ for(int i=0;i&lt;arr_length-2;i++){ for(int j=0;j&lt;arr_length-1;j++){ if(arr[j]&gt;arr[j+1]){ int temp=arr[j+1]; arr[j+1]=arr[j]; arr[j]=temp; } } } } 以下是冒泡排序的运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d9784b7e9086fe4f61559bafc345fc8/" rel="bookmark">
			论编程学习方法的重要性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、每日“多省吾身” Question 1：明天会上哪些内容的课程呢？ 如果可以的话，你可以拷贝到往届学长学姐们的笔记，每天利用5分钟的时间大致浏览第二天的课程，从而能够从全局把握课程结构，从而使自己在第二天老师6个小时的狂轰滥炸中不至于处于被动，然后不知道自己所处何处。反之，你就可以化被动为主动，从而可以将6个小时的课程切割成对应于各个知识点的小模块。通过这种方式，你就可以极大地提升自己的听课质量。 Question 2：今天的课程我完全听懂了吗？ 听课质量的高低对学习效果可以说起到了中流砥柱的作用。试想一下，如果你的听课效率质量很高，那么晚上敲代码、复习的时间就可以大大地减少。因为，你不会再对着老师分发的代码和资料问自己一些愚蠢的问题。例如：这段代码是干什么的来着？这个知识点好像完全没听懂。这些令人抓狂的问题会严重挫伤你学习的积极性。因此，如果上课有任何内容没有听懂，那么不要忽略掉，应该把自己想问的问题记录下来，下课之后，立刻通过与同学和老师的讨论解决掉。 Question 3：今天我对哪些问题有疑问呢？ 如果你是抱着积极的学习态度在听课，那么你一定会在上课期间产生各种各样的idea。你可能在想一种代码效果有没有另外一种实现方式，或者另外一种配置方式会有什么效果。这时候，一定要迅速记录下来这些问题，不要占用上课时间跟同学讨论或者自己纠结于此。因为，一旦你这样做，后面的课程你就完全不会在用心听了，这就降低了听课的质量。 Question 4：有疑问的问题自己可以通过网络或者写一些例子得到结果吗？ 产生任何问题之后，不要急于问老师和同学，而是要培养自己独立学习和解决问题的能力。你可以通过网络或者API文档查询到结果，又或者自己写一个例子程序得到答案。如果实在有困难，再向学生和老师求助。这样，可以培养你独立解决问题的能力。毕竟，在公司里，是没有太多人给你全方位的指导和帮助的，不是吗？ Question 5：今天的代码我有敲完吗？ 很多同学有时候会进入一个误区，那就是他认为上课的时候代码已经完全理解了，下课就没有必要再敲这些代码了，这就走向了一个极端。另外一个极端则是认为代码必须自己从头到尾一个字母不漏的敲出来才算掌握了。实际上，代码最重要的是写出思路，然后通过查询API文档完成代码。当然，第一次敲代码的时候最好可以临摹老师的代码，然后再自己独立完成。否则，由于难度太大，可能会打消学习的积极性并且浪费时间在回忆代码上。另外一个需要指出的点是，千万不要给自己拖延的理由，今天的代码今天必须要完成，即使奋战到凌晨2点也在所不惜。如果你拖延到明天，那么再加上第二天的代码量，你会倾向于放弃昨天的代码，甚至对今天的代码也感到厌烦。毕竟学习的时间是有限的，利用一天的时间承担两天的任务量，没有压力才怪呢！ Question 6：我可以对这些代码进行封装或者优化吗？我可以做一些小应用吗？ 任何的知识想要活学活用都必须要经过自我优化并且不断应用从而达到熟能生巧的过程。如果仅仅局限于老师的例子代码，你将会发现自己解决问题的能力并不强，还只是处于粘贴拷贝的码农阶段。但是如果你能够思考这些代码怎么去封装和优化，并且自己试图做一些应用，那么恭喜你，你就在朝着架构师以及高级软件工程师的方向发展了。 Question 7：今天我的任务完成了吗？ “今日事，今日毕”。古人的这句话说明了执行力的重要性。所以，千万不要给自己任何拖延的理由。不要说，今天几个玩的很好的哥们邀我玩dota，今天的任务明天我一定做！如果这样的话，你会发现，第二天你已经生疏了第一天的知识。因为你没有复习也没有敲代码。你会感到更大的阻力去重新学习昨天的课程。这时候厌倦的情绪会大大的降低你的学习效果。所以，不要让任何事情阻碍你去完成你今天的任务。你需要明白，拖延不是选项，你甚至根本不要去考虑它。 Question 8：我有明确而有效的复习计划吗？ 孔子有句话，“温故而知新，可以为师矣”。见名知意，就是经常温习就可以学到新的东西，也就是熟能生巧。很多同学在学习后面知识的时候经常会抱怨以前的知识已经遗忘了。因而，当他们学习后面的知识时，就会感觉到非常的有压力，甚至产生了放弃学习的念头。这种心态会严重扼杀一个人的自信心并且学习效率极低。等到就业找工作的时候，这些同学会变得极度不自信。因为，他认为所有的知识在他心中越来越模糊。那么，好的措施就是制定明确有效的学习计划，定期复习将会使你保持对知识的熟悉程度。
2、学习感言 黑马的学习经历 2.1　黑马制度 黑马每天上课六个小时，早上是8:30-11:30，下午是14:30-17:30，晚自习的时间18:30-20:30 大家可能感觉每天上课的时间并不是很长，但是个人的感受是每天上课就要六个小时，那么自己练习的时间也是和这个差不多的，如果再加上自己有可能会卡到某个知识点，因而呢，正常情况每天下来是很辛苦的，以个人为例(我算是比较懒惰的)，早上7:00起床，中午午休半小时到一个小时之间，晚上是零点睡觉。 说些题外话，我们寝室五个人，其他同学比我勤快多了，早上六点钟就起床，晚上零点+才睡觉的。当然这是要看个人情况，我大学学习的就是计算机，而且个人理论知识学习的比较好，个人还有相关一年的工作经验，所以不是特别辛苦，所以还是要结合个人情况来看待问题。 黑马这边一周休息一天，周三一般是自习，给大家用于调整和巩固前面学习的知识的，大家不需要担心来到这里学不到东西，知识是比较多的，还是要很用功和努力的。
2.2 来黑马的目的 来黑马的目的根据时间划分应该是两类，一类是来之前，一类是来之后。 来之前呢，大家的目的想必99%都是冲着改变命运来的，其实也就是冲着高薪来的，要不然也不会有这么多非计算机专业的同学，甚至有的在学计算机之前连android是何物都不知道的，就这样开始学习毕向东的视频了。 来黑马之后呢，我们的目的就要做一些调整了，个人将目的分为三点: 1、忘掉高新，勤加学习和练习 2、学习氛围 3、建立朋友关系，一个技术圈子 为什么要这么说呢?大家也都知道，仰望星空与脚踏实地，我们的目的地是星空，但是去往星空的路上我们是要脚踏实地的。在来黑马之前，我们是处于仰望星空的阶段，这个是我们的最终目的，但是为了实现这个目标和梦想，我们是需要脚踏实地，一步一步来实现的，因而说在来到黑马之后，我们应该忘掉高薪，每天需要做的就是勤加学习和练习每天的知识，黑马的知识能够掌握80%，出去找份10K+的工作不是问题。 学习氛围:很多黑马的视频都可以在网上找到的，只要你努力加之丰富的信息源。但是为什么还是有很多人要挤破头颅要来到黑马学习?这是从时间成本和氛围来综合考虑的，如果不来黑马，而只是自己抽空学习，可能80%的人是坚持不下的。另外，黑马四个月的课程，个人学习可能要花一年左右的时间(因为我们不可能每天呆在家里或者宿舍，自己不上课或者不工作，专门用于学习黑马的视频，如果你是未毕业的大学生可能还有可能)，这还是次要的，遇到问题不知道如何解决，或者说解决的时间比较长，最终如果信心不够坚定，那么很有可能坚持不下来。 刚刚说到第二点的时候，其实第三点就自然而然的出来了，建立有技术基础的圈子，来到这里，大家都是来学习知识的，每天学习的内容遇到的难题或者说有好的点子，大家可以分享，并且以后从事的行业都是相关的，那么在工作中遇到的问题同样可以这样处理。
2.3 一个月的java web学习经历 很多有计算机基础或者了解过android的人都知道，做客户端很可能不需要知道太多的web知识，但是为什么黑马要安排一个月的javaweb呢? 其实这也是黑马课程安排的巧妙性所在。在此我为大家分析一下: 1、很多人来黑马之前，确实是已经具备了一定的java基础，但是工具使用的是不够熟练的，比如说eclipse中常用的快捷键，快捷键先不提，就说来之前就有很多是一指禅的专家，那么这一个月的时间就要注意了，让自己从几乎是鼠标操作按钮转变为纯粹的键盘操作eclipse，这也是一个人熟练程度的体现。在此简单的提下个人的面试经历的一个插曲，当时面试官让我现场写选择排序，冒泡排序，恶汉式的单例，当时个人把笔记本拿出来，几乎没有使用鼠标，就把程序给写出来了，并且是很熟练的，编程从任务变成了一个秀操作的过程，因而面试官是相信个人有这个实力来胜任这份工作的。 2、学会做笔记 这种学习方式，我至今仍然在使用，大家来之前，可能使用过txt或者word做笔记，其实这种方式并不是不好，而是从长远考虑， 并不会产生很多的价值。在此提一下个人的经验： 笔记呢，分为两类，一类是思路性质的笔记，另外一类是详细的笔记，针对不同的笔记，是有相应的软件的 1、 思路性的笔记:思路性的笔记呢，这个比较出名的就是思维导图，也叫做脑图(个人大学时看过一本书，专门讲解思维导图的，这个就是相应的软件)，对于思路的拓展和总结具有很好的效果 2、 详细的笔记，这里就要提到几个比较出名的笔记软件: onenote，印象笔记，为知笔记。可能会有人有疑问，为什么不说txt和word呢，因为txt和word只是单个笔记，而我刚刚提到的几个笔记的软件具有整体的搜索功能，比如说我有十几篇笔记是关于一个知识点的，那么我既可以用搜索标题的形式也可以用搜索内容的形式来查找相关的知识。而用txt或者word在电脑上保存的话，一般只能按照文档的名字来搜索，甚至如果名字不对的话，那么就需要自己记住存放在那个文件夹下，而刚刚提到的这几个软件，就是用来解放我们的大脑，用于做更重要的事情。 另外插播一句，并不是纸质的笔记不重要，而是我认为纸质的笔记相对于电脑的笔记，已经落伍了，从便携性以及长远的可移植性和修改的方面来看，纸质的已经淘汰的差不多了，另外，如果想截张图来保存当时的一些细节，假如用纸质完成。 那么时间成本是很大的。 再来插播一句其他的吧，其实大家想想为什么为什么两个人都可以做的事情，结果工作年限多的人一般工资会高一些，因为他熟练这些内容，遇到问题解决起来轻车熟路，而刚毕业或者参加工作的人，需要花费时间比较长，另外做出的东西从扩展性和设计的规范性来讲，是不成熟的。 3、 翻阅文档，查看api， 上网搜索相关资料的技能 在一个月的web学习过程中，起码jdk的文档个人应该翻阅起来要轻车熟路，另外的话，遇到问题，能够独立的上网搜索相关的资料，学习吸收，解决当前的问题。在此可以推荐几个不错的网站，国内的技术论坛，博客园，CSDN，国外的网站: stackoverflow(一个几乎你遇到的问题都可以解决的网站，不过英语能力还是要可以的，起码能够看得懂) 4、Demo制作的能力 其实学习计算机和做玩具差不多，一般也是要先做一个原型，在学习新的知识的时候，我们一般也要先了解这个知识，然后才用到我们的产品中，这就涉及到demo的制作，而在学习javaweb的时候，这个技能也是要练习的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d9784b7e9086fe4f61559bafc345fc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a77edefca8af5b4c4a252466253a9ed/" rel="bookmark">
			对于java反射的一些学习理解和认知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 反射（Reflection）的概念
反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所属的属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。
功能：
反射是java中一种强大的机制. Java反射机制主要提供了以下功能：
1.运行时判断任意一个对象所属的类；
2.运行时构造任意一个类的对象；
3.运行时判断任意一个类所具有的成员变量和方法；
4.在运行时调用任意一个对象的方法，生成动态代理。
反射简单的解释就是,把类中的成分,映射到相应的类,达到用这些类操作框架.
2. Class 类
Java 程序在运行时，系统会对所有的对象进行所谓的运行时类型标识，用来保存这些信息的类就是 Class 类。Class 类封装一个对象和接口运行时的状态。
从Java源程序到java程序运行要经历一个曲折的过程: 源程序javac编译源程序,得到.class文件.jvm从硬盘读取.class文件,并且把.class文件转化成字节码存入内存读取这些字节码,得到程序运行效果
在第三个步骤的, jvm从硬盘读取.class文件,并且把.class文件转化成字节码存入内存,其中每一份字节码就是一个Class对象,Class相当于字节码的类(类似于Person是人的类).要得到Class类,通常有3种方式:
类名.class
对象名.getClass()
Class. forName(完整的类名)—在反射中比较常用
反射的作用是把类中的成分,映射到相应的类,也就是说类中的方法,字段,构造函数,数组等都有映射的类,它们对应的就是Method , Field, Constructor, Array。
Class类中的getFields , getConstructors,和getMethods方法返回public修饰的字段,构造函数和方法的数组,其中包括父类的公有成员.
Class类中的getDeclareFields , getDeclareMethods和getDeclareConstructors方法返回类中声明的全部字段,方法和构造函数,包含私有的和受保护的,但是不包括父类的成员。
3、通过案例来一步一步熟悉JAVA反射机制
//实例1、通过一个对象获取完整的包名和类名 package cn.cast.reflect; class Demo{ } public class test01 { public static void main(String[] args) { Demo demo=new Demo(); System.out.println(demo.getClass().getName()); } } 运行结果： cn.cast.reflect.Demo（所有类的对象都是Class的实例） package cn.cast.reflect; /* * 实例2、Class类的实例化 * 由于Class类没有构造方法，所以实例化Class类的方式有点特殊，有三种方式： * 对象.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a77edefca8af5b4c4a252466253a9ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c177c3a047a276bd5196f3428711d20/" rel="bookmark">
			【linux下编程】MakeFile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了几篇文章，整理一下心得
原文链接
http://www.itokit.com/2012/0312/73300.html 在linux上开发c++
http://blog.csdn.net/liigo/article/details/582231 gdb十分钟教程
http://blog.csdn.net/liang13664759/article/details/1771246 关于MakeFile
一些重点：
1.makefile
2.man：help
3.gdb调试器的命令
关键词：GTK（类似一个跨平台的MFC）, QT, SHELL, GDB, GCC, makefile,STL
编程步骤：
1，使用gedit，或者任何文本编辑器（最好有语法高亮，自动缩进功能）编写您的代码。
2，编写代码时，使用标准库的函数和数据结构，或者其它已经实现的模块，或者linux系统API调用。
3，碰到不知道的标准库，或者linux API，使用man命令查询，没有的话，到网上查询。
4，编写makefile.
5，在g++上添加 -g参数，加入调试符号。
6，使用gdb调试或者打印log测试。
7，去掉-g参数，release。
8，结束。
Makefile
首先要知道，源程序-&gt;编译(.o)-&gt;链接-&gt;可执行文件-&gt;运行
粗略地看一看Makefile的规则。
target ... : prerequisites ...
command
...
...
target：一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。
prerequisites：要生成那个target所需要的文件或是目标。
command：make需要执行的命令。（任意的Shell命令）
核心：target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。
make
根据Makefile文件编译源代码、连接、生成目标文件、可执行文件。
make clean
清除上次的make命令所产生的object文件（后缀为“.o”的文件）及可执行文件。
make install
将编译成功的可执行文件安装到系统目录中，一般为/usr/local/bin目录。
make是如何工作的 在默认的方式下，也就是我们只输入make命令。那么， 1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。 2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。 3、如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。 4、如果edit所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程） 5、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。
MakeFile的一个示例 正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。 edit : main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c177c3a047a276bd5196f3428711d20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/215e5d67912fee878b7afe0063f24951/" rel="bookmark">
			二叉树，完全二叉树，满二叉树，二叉排序树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 二叉树：二叉树是每个节点最多有两个子树的树结构； 是n(n&gt;=0)个结点的有限集合，它或者是空树（n=0），或者是由一个根结点及两颗互不相交的、分别称为左子树和右子树的二叉树所组成。
完全二叉树：除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点； 树中所含的n个节点和满二叉树中编号为1至n的节点一一对应
满二叉树：除最后一层外，每一层上的所有结点都有两个子结点；满二叉树是一种特殊的完全二叉树； 二叉排序树：二叉树中，每个节点都不比它左子树的任意元素小，而且不比它的右子树的任意元素大。又叫二叉搜索树。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7874dc1c0342f18a90c47d7560d6635f/" rel="bookmark">
			K-mediods算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K-mediods(K中心点)算法介绍
一、K-mediods算法介绍
a) 话说，聚类算法可以被分为那么几种，比如基于划分方法的、基于层次方法的、基于密度方法的、基于网格方法的、基于模型方法的；K-mediods算法就是基于划分方法的一种聚类算法，确切的说，是对K-means算法的一种改进算法。
二、K-mediods算法优缺点
a) K-mediods算法具有能够处理大型数据集，结果簇相当紧凑，并且簇与簇之间明显分明的优点，这一点和K-means算法相同。
b) 同时，该算法也有K-means同样的缺点，如，必须事先确定类簇数和中心点，簇数和中心点的选择对结果影响很大；一般在获得一个局部最优的解后就停止了；对于除数值型以外的数据不适合；只适用于聚类结果为凸形的数据集等。
c) 与K-means相比，K-mediods算法对于噪声不那么敏感，这样对于离群点就不会造成划分的结果偏差过大，少数数据不会造成重大影响。
d) K-mediods由于上述原因被认为是对K-means的改进，但由于按照中心点选择的方式进行计算，算法的时间复杂度也比K-means上升了O(n)。
三、K-mediods算法描述
a) 首先随机选取一组聚类样本作为中心点集
b) 每个中心点对应一个簇
c) 计算各样本点到各个中心点的距离（如欧几里德距离），将样本点放入距离中心点最短的那个簇中
d) 计算各簇中，距簇内各样本点距离的绝度误差最小的点，作为新的中心点
e) 如果新的中心点集与原中心点集相同，算法终止；如果新的中心点集与原中心点集不完全相同，返回b)
四、K-mediods算法举例
a) 设有(A,B,C,D,E,F)一组样本
b) 随机选择B、E为中心点
c) 计算D和F到B的距离最近，A和C到E的距离最近，则B,D,F为簇X1，A,C,E为簇X2
d) 计算X1发现，D作为中心点的绝对误差最小，X2中依然是E作为中心点绝对误差最小
e) 重新以D、E作为中心点，重复c)、d)步骤后，不再变换，则簇划分确定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c6d181197aee01fcaef92fb725a091/" rel="bookmark">
			Jcef应用浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CEF应用浅析
一、CEF简介
a) CEF是一款基于Chromium浏览器的嵌入式框架，提供了基本的浏览器功能。包括自定义插件、各种协议、Javascript对象访问和扩展。一些可选的功能包括，资源加载、导航、上下文目录、打印等；值得一提的是，它对HTML5的支持和性能与Google Chrome浏览器同样优秀。
b) CEF包括CEF1、CEF2和CEF3三个大版本。其中，CEF1仅支持单线程，CEF2已经被废弃，所以现在基本是使用CEF3进行开发。
c) 如果希望了解更多相关内容，可以访问它的网站
https://bitbucket.org/chromiumembedded/cef/wiki/Home
d) 由于CEF是基于Chromium内核的，所以CEF支持的操作系统也会有限制。参考下表
Branch Date
Release Branch
Chromium Version
CEF1
CEF3
Windows Build Requirements
Mac OS X Build Requirements
Linux Build Requirements
Dec 2011
963
17
Yes
No
WinXP+, VS2008, Win7 SDK
OS X 10.6-10.7, 10.5+ SDK, Xcode 3.2.6
Ubuntu 10.04+, Debian Squeeze+
Feb 2012
1025
18
Yes
No
WinXP+, VS2008, Win7 SDK
OS X 10.6-10.7, 10.5+ SDK, Xcode 3.2.6-4.x
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c6d181197aee01fcaef92fb725a091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb7032b2413924d3baf113402463ef1/" rel="bookmark">
			Log4j详细使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		林炳文Evankaka原创作品。转载请注明出处http://blog.csdn.net/evankaka
日志是应用软件中不可缺少的部分，Apache的开源项目Log4j是一个功能强大的日志组件,提供方便的日志记录。在apache网站：jakarta.apache.org/log4j 可以免费下载到Log4j最新版本的软件包。
一、入门实例 本例子工程下载
1.新建一个JAva工程，导入包log4j-1.2.17.jar，整个工程最终目录如下
2、src同级创建并设置log4j.properties
### 设置### log4j.rootLogger = debug,stdout,D,E ### 输出信息到控制抬 ### log4j.appender.stdout = org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target = System.out log4j.appender.stdout.layout = org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n ### 输出DEBUG 级别以上的日志到=E://logs/error.log ### log4j.appender.D = org.apache.log4j.DailyRollingFileAppender log4j.appender.D.File = E://logs/log.log log4j.appender.D.Append = true log4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayout log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [ %t:%r ] - [ %p ] %m%n ### 输出ERROR 级别以上的日志到=E://logs/error.log ### log4j.appender.E = org.apache.log4j.DailyRollingFileAppender log4j.appender.E.File =E://logs/error.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eb7032b2413924d3baf113402463ef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cedad80de2d9be53a0deada3253eaf6/" rel="bookmark">
			【MAXScript】3DMax批量修改贴图名及模型名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这应该是我的Coder路上的一段小插曲~~~
一堆废话 想不到自己还会接触3DMAX的脚本语言——MAXScript。首先申明一下，本人不是建模组的，对建模什么的不甚了解。倒是想学来着，会点建模如果自己要独立开发一些小项目，也可以不麻烦人，如果可以，什么事情还是自己亲力亲为来得快。可是同事说怕我抢了他的饭碗，愣是没有教我。嘿嘿！其实我知道那不过是他的玩笑话，主要还是我自己没有时间去学啦，毕竟不是一朝一夕就能够学会的。 “这么多模型，这么多贴图要怎么改？”又听见建模组同事在仰天长哮~~~公司早期有很多项目是使用一款叫virtools（我也有幸用过一段时间，oh no！跟unity真的不是一个等级的，最关键的是网上完全没有资料可寻，碰到一个问题，可以折腾你一个星期也束手无策~）的引擎来开发的，后来客户要求将一些virtools项目改成unity3D，而virtools引擎支持中文命名的模型及贴图，但是众所周知，unity对中文的支持不是很好，经常因为中文发生莫名的错误，或者乱码之类的问题，所以不得不将这些模型和贴图的名称全部改成英文的。“你们3DMAX有没有什么脚本之类的，可以使用脚本来批量改啊，一般软件都会自带脚本，以解决软件自身功能局限的问题。”我刚说完，就感受到了来自对面的‘杀气’，只见同事恶狠狠的盯着我。。。好吧！我错了，忘了同事压根没有写过代码，说了也是白说（我不是有意要打击你们的哟）。“好吧，我帮你看看3DMAX有没有脚本，研究一下要怎么写。”同事听罢，嘴角上扬。。。唉，这奸笑意味着我又要折腾一番了。于是，便开始了MAXScript编程之旅。
批量修改模型名 没有任何MAXScript基础该怎么开始呢？总要先了解一下该脚本语言的语法规则和常用API吧，于是上网下载了本电子书《3ds MAXScript 脚本语言完全学习手册》（各位看官可自行搜索下载，很好找哦，一搜一大把）。（由于自己机子上没有装3DMAX，所以也不方便附上测试的截图，但是代码之前都是在同事机子上实验过的，成功帮助他们改了模型名以及贴图名，所以在特定条件下是没有问题的，关于这个“特定条件下”以及可能会出现的问题在后面也会提到。） 步骤： 1. 建立两个txt文件，一个是用于存放原模型名的列表，一个用于存放新模型名的列表（之所以分成两个txt文件，而不是一个txt文件存储两个列表， 是因为对maxscript比较陌生，使用两个列表省了解析字符串的麻烦）； 2. 逐行读取两个txt文件的内容； 3. 读取一行，就搜索场景中名称匹配的模型，然后替换成新名称。 具体实现： 1. 只能手动解决，这个没有什么快捷方式。 2. 可以通过书中第三章3.2.19节的FileStream（文件数据流）的OpenFile方法对文本文件进行I/O操作。切记： maxscript的函数并不是以一对“()”括号来标识的，传参数的方法也不像其他常用语言那样在“()”里填入参数，而是在函数名后“ ”加“空格”然后在后面带上函数参数，如要读取D盘下的maxscript.txt文件内容，应如此写：
source = OpenFile "d:\maxscript.txt" --后面不带封号，不一样的注释符号"--"; 而不是：
source = OpenFile("d:\maxscript.txt"); 3. 这个步骤主要是获取指定名称的对象，找了好久，终于找到一个“好东西”：$（好像是叫“选择符”），用处貌似还蛮大，但是我只会它的一种功能：搜索场景中指定名称的模型物体，并返回该物体对象，如：要搜索一个名称叫“box1”的物体，可以采用如下方式：
$box1 各位注意看了，有没有发现非常坑爹的一点，就是 ‘$’这个选择符后的box1居然不用加双引号，也就是box1被直接识别成了字符串，那么问题来了：如果我要传一个字符串变量该怎么办？假如，我有一个变量str，并搜索str所代表的模型，如下：
str = "box1" --不需要申明变量类型，应该是自动识别的 $str --如果是通过这样，那便会搜索名称为"str"的模型，而不是搜索"box1" 尝试很多方法也无法向 ‘$’传入变量，至此，也只能抛弃这个神奇的符号了（没有深入研究，不了解它的用法，各位如果知道怎么传入变量，还请留言告知，谢谢）。好吧，继续翻看一下学习手册吧，看看有没有其他的方法。就是你了：selection（当前选择对象集合），可参看手册“3.5.3 ObjectSet（对象集）”，几番测试，可以通过for循环遍历selection中所有的模型对象，但是此法效率过于低下，因为找一个物体就要遍历一遍selection，没找到更好的方法，将就用吧，下面附上源码：
source = OpenFile "C:\Users\Administrator\Desktop\批量改名\原名.txt" --获取"原名.txt文件"的io流 des = OpenFile "C:\Users\Administrator\Desktop\批量改名\新名.txt" --获取"新名.txt文件"的io流 for j = 1 to 3 do --列表几条记录就写几条，maxscript习惯从1开始计数 ( str = readLine source --逐行读取文本内容 strD = readLine des for obj in selection do --遍历场景中所有模型，注：selection需要选中场景中的模型哦 ( if obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cedad80de2d9be53a0deada3253eaf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0066879fe32ba41b67738f6475ff48c0/" rel="bookmark">
			SemEval2015语义评测任务总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在2014年11月份的时候老师带队，参加了SemEval 2015task15的评测，现在论文刚过，这件事也算是告一段落了，大赛期间那段过程还是比较难受的，时正大三上学期，专业课一大堆，每天的休息时间少的可怜。后期发表论文的过程也是非常漫长的，论文更改的次数接近30次。现在才知道要在会议上发表一篇文章是多么不易了，整个过程持续时间长达5个月。不过这个过程下来，自己的收获绝对非常大，所以今天总结一下。本来这篇文章使用来写一些心得体会的，但是后面想了想，以后求职时在介绍这个经历，要是面试官要求介绍任务，我的处理方法时，直接说我觉的不太容易能说清楚，举例子会清楚得多，另外对我的方法介绍有图才会更清楚一些。于是把这篇文章定位了一下，总结+简要介绍任务和我的处理方法。这样我就可以打开博客跟面试官介绍，我能讲的更清楚，也能让对方了解的更明白，双方都好~
一.接触前沿研究领域的NLP任务
老师说过，进入自然语言领域的一个最快的方法就是参加一个相关的比赛，具体扎入其中，完事后就大概知道自然语言处理做什么了。参加这个任务时我NLP方面的知识几乎为0，当时会比较熟练的使用perl脚本，拿到比赛任务时头晕眼花，根本不知任务所云，感兴趣的可以看看这个任务, 名字叫CPA，花了几天的时间才把任务到底要做什么搞明白。这次比赛也有运气方面的原因，就是这项任务非常新，是最新研究领域的一个块技术，所以参数队总共就5支，所以我们这批可以是为这个技术的发展做垫底的，我比较确信这个任务下次会变的更难一些出现在2016的任务上。一般的测评任务参数队伍非常多，比较成熟的像STS系列，各个国家的参数队伍多达70多支。竞争相当激烈，不过成熟的任务有一个最大的好处就是有前任的基础成果，前任做的好的会在会议上发表论文，贡献出他们的方法来，后面的可以再次基础上改进。对于像CPA这样的第一批参加者，好处是竞争者少，就5支队伍，坏处就是摸着石头过河，几乎没有任何方法的参照，完全的自己想。
二.任务举例描述与我的简单处理方法
先简要的描述一下CPA, 语料模式分析 (CPA) 是语言分析的新技术，该技术主要用于确定文本中词语使用的主要模式。本次任务是确定动词的主要模式。整个任务分为三个子任务，但是结果上我们第一个任务比较出色，所以就只介绍第一个任务，第一个任务可以说是序列的标注问题，分为两层，一层是语法标注，另一层是在语法标注的基础上进行语义标注。语法标注的标签集是
用一个最简单的例子来表明第一个任务，假设当前句子的输入是：
Mr Eigen plans to wage his war diplomatically. 指定以plan为核心动词，经过任务一后变成下面这样，标注出来的结果就是plan的上下文环境。
对于简单句的标注，明白的人都知道一般的依存关系就能解决了，但是如果是下面这样的句子呢：
Lord Sankey 's attitude indicates that a court of law in the United Kingdom would need weighty evidence before becoming willing toabandon the principle of legality according to the pre-existing constitutional norms, and so it should, so long as uncertainty as to the `realities' prevails. 现在要求找出abandon的主语，我相信人直接读过去，可能一时半会都很难找出abandon的主语吧，怎样让计算机在瞬间根据某个算法找出abandon的正确主语呢，又万一abandon根本就没有主语呢。当时我被这个问题困扰了好久，大概花了一周的时间来想算法，期间每天一大早的起床对着数千行的文本进行归类，分析。经过一周后，在某天终于分析点出眉目来，想出了一个感觉可行的算法，马上兴奋的写了实现，结果效果果然不错！后来我把这个算法叫做基于依存连的标注算法，对主语宾语的标注比较有效。下面的图解是我的一个方法：
沿着abandon的依存链开始走，满足某些规则的情况下，会找到court，即是abandon的主语，如果没有满足规则的，则认为abandon无主语。
另外遇到的一个瓶颈问题是语义的一个问题，大致介绍下，经常会遇到两个几乎一样结构的句子，简单来说，比如account for, for 与account含有某种标签关系，其他句子中出现的verb for，就不一定了，得看具体的语义环境，人是很容就能读出来verb与for之间是否存在标签关系的，因为我们明白其中的含义就知道了，怎样让计算机也明白了。后来我想了一个也算有效的方法，就是提前把预览语料，分析出核心动词的结构，并且统计，如果某类结构经常出现的话，我认为那类结构是那个动词比较常用的方式，也自然在那类结构里面与该动词含有标签的概率就大得多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0066879fe32ba41b67738f6475ff48c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d546de66653f121d2befdf25d25f5f70/" rel="bookmark">
			LSTM简介以及数学推导(FULL BPTT)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间看了一些关于LSTM方面的论文，一直准备记录一下学习过程的，因为其他事儿，一直拖到了现在，记忆又快模糊了。现在赶紧补上，本文的组织安排是这样的：先介绍rnn的BPTT所存在的问题，然后介绍最初的LSTM结构，在介绍加了遗忘控制门的，然后是加了peephole connections结构的LSTM，都是按照真实提出的时间顺序来写的。本文相当于把各个论文核心部分简要汇集一下而做的笔记，已提供快速的了解。
一.rnn结构的BPTT学习算法存在的问题 先看一下比较典型的BPTT一个展开的结构，如下图，这里只考虑了部分图，因为其他部分不是这里要讨论的内容。
对于t时刻的误差信号计算如下：
这样权值的更新方式如下：
上面的公式在BPTT中是非常常见的了，那么如果这个误差信号一直往过去传呢，假设任意两个节点u, v他们的关系是下面这样的：
那么误差传递信号的关系可以写成如下的递归式：
n表示图中一层神经元的个数，这个递归式的大概含义不难理解，要求t-q时刻误差信号对t时刻误差信号的偏导，就先求出t-q+1时刻对t时刻的，然后把求出来的结果传到t-q时刻，递归停止条件是q = 1时，就是刚开始写的那部分计算公式了。将上面的递归式展开后可以得到：
论文里面说的是可以通过归纳来证明，我没仔细推敲这里了，把里面连乘展开看容易明白一点：
整个结果式对T求和的次数是n^(q-1), 即T有n^(q-1)项，那么下面看问题出在哪儿。
如果|T| &gt; 1, 误差就会随着q的增大而呈指数增长，那么网络的参数更新会引起非常大的震荡。
如果|T| &lt; 1， 误差就会消失，导致学习无效，一般激活函数用simoid函数，它的倒数最大值是0.25, 权值最大值要小于4才能保证不会小于1。
误差呈指数增长的现象比较少，误差消失在BPTT中很常见。在原论文中还有更详细的数学分析，但是了解到此个人觉的已经足够理解问题所在了。
二.最初的LSTM结构 为了克服误差消失的问题，需要做一些限制，先假设仅仅只有一个神经元与自己连接，简图如下：
根据上面的，t时刻的误差信号计算如下：
为了使误差不产生变化，可以强制令下式为1：
根据这个式子，可以得到：
这表示激活函数是线性的，常常的令fj(x) = x, wjj = 1.0，这样就获得常数误差流了，也叫做CEC。
但是光是这样是不行的，因为存在输入输出处权值更新的冲突(这里原论文里面的解释我不是很明白)，所以加上了两道控制门，分别是input gate, output gate，来解决这个矛盾，图如下：
图中增加了两个控制门，所谓控制的意思就是计算cec的输入之前，乘以input gate的输出，计算cec的输出时，将其结果乘以output gate的输出，整个方框叫做block, 中间的小圆圈是CEC, 里面是一条y = x的直线表示该神经元的激活函数是线性的，自连接的权重为1.0
三.增加forget gate 最初lstm结构的一个缺点就是cec的状态值可能会一直增大下去，增加forget gate后，可以对cec的状态进行控制，它的结构如下图： 这里的相当于自连接权重不再是1.0，而是一个动态的值，这个动态值是forget gate的输出值，它可以控制cec的状态值，在必要时使之为0，即忘记作用，为1时和原来的结构一样。 四.增加Peephole的LSTM结构 上面增加遗忘门一个缺点是当前CEC的状态不能影响到input gate, forget gate在下一时刻的输出，所以增加了Peephole connections。结构如下： 这里的gate的输入部分就多加了一个来源了，forget gate, input gate的输入来源增加了cec前一时刻的输出，output gate的输入来源增加了cec当前时刻的输出，另外计算的顺序也必须保证如下： input gate, forget gate的输入输出cell的输入output gate的输入输出cell的输出(这里也是block的输出) 五.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d546de66653f121d2befdf25d25f5f70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea3ee5fe7067678fa00fb87c9962581/" rel="bookmark">
			1003.斐波那契数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述： 在数学上，斐波那契数列（Fibonacci Sequence），是以递归的方法来定义：
F0 = 0
F1 = 1
Fn = Fn - 1 + Fn - 2
用文字来说，就是斐波那契数列由0和1开始，之后的斐波那契数就由之前的两数相加。首几个斐波那契数是：
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946，………………
特别指出：0不是第一项，而是第零项。
在西方，最先研究这个数列的人是比萨的列奥纳多（又名斐波那契），他描述兔子生长的数目时用上了这数列。
n 第一个月有一对刚诞生的兔子
n 第两个月之后它们可以生育
n 每月每对可生育的兔子会诞生下一对新兔子
n 兔子永不死去
假设在n月有新生及可生育的兔子总共a对，n+1月就总共有b对。在n+2月必定总共有a+b对：因为在n+2月的时候，所有在n月就已存在的a对兔子皆已可以生育并诞下a对后代；同时在前一月(n+1月)之b对兔子中，在当月属于新诞生的兔子尚不能生育。
现请以较短的时间，求出斐波那契数列第n项数值，0≤n≤40。
解析： 对于斐波那契数列，兔子生育问题不能再经典和形象了，这个例子很好的将数列应用化，再详细解释下为什么N+2=N+（N+1）.见下： 兔子类型一共是两种要记住：1已长大可以生孩子的兔子 2新生的兔子 注意这里是一对老兔子生一对新兔子，为了不说起来麻烦，我只直接说1生1喽。
首先N月的兔子包括已长大可以生孩子的兔子 群体A和本月是新生儿的兔子群体B，生产力为A，那么在N+1月，A又生了A，而B刚长大，下个月即N+2月才能生，所以N+1月兔子数应为A(N月就能生了)+A（N+1月新生儿）+B（本月刚成熟）,生产力为A+B，所以这样来看就很简单了，N+2月的总数量就是N+1月的兔子总量A+A+B加上N+1月新生产的新生儿A+B,即3A+2B，正好是N月和N+1月的总和。 不知道这样讲能否让你明白，如果还是云里雾里，不妨自己画图看一下。其实有个很直观的理解，就是，我们应该明白， 一个月的兔子数就应该是上个月已有的兔子数+本月又新生产的兔子，那么本月又新生产的兔子是怎么来的呢，无疑看公式来说必须是上上个月所有兔子的总数，因为上上个月还不能生孩子的兔子在第三个月（也就是N+2月）生出来了第一批！而N+1月比N月多出来的兔子对N+2月是没有生产力的！
这就是斐波那契数列应用模型。
下面是自己写的比较挫的一个代码。检验无错，但是提交显示ERROR at test 2 ，不理解，有知道的朋友麻烦指正我。
#include&lt;iostream&gt; using namespace std; unsigned long int Fibonacci(unsigned long int F0,unsigned long int F1, int n, int count){ unsigned long int F2; F2=F0+F1; count++; if(count!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eea3ee5fe7067678fa00fb87c9962581/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/210/">«</a>
	<span class="pagination__item pagination__item--current">211/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/212/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>