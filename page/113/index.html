<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db2be1a36740686a672920fbaabb4430/" rel="bookmark">
			CSS右箭头的写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css：
width: 6px; height: 6px; border-top: 1px solid #cccccc; border-right: 1px solid #cccccc; transform: rotate(45deg); span { padding-left: 5px; padding-right: 7px; color: @primary-color; font-size: 12px; opacity: 0.6; position: relative; &amp;::after{ position: absolute; content: ''; width: 5px; height: 5px; border-top: 1px solid @primary-color; border-right: 1px solid @primary-color; transform: rotate(45deg); right: 1px; top: 6px; } &amp;:hover{ opacity: 1; } } 效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ab8fcfcbdd46e3a692c16c17c8a1c9d/" rel="bookmark">
			django中使用JWT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.pyJWT简述 因http协议本身为无状态，这样每次用户发出请求，我们并不能区分是哪个用户发出的请求，这样我们可以通过保存cookie以便于识别是哪个用户发来的请求，传统凡事基于session认证。但是这种认证本身很多缺陷，扩展性差，CSRF等问题。JWT(Json web token) 相比传统token，设计更为紧凑且安全。通过JWT可以实现用户认证等操作。
pyJWT下载
pip install pyJWT JWT构成：
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsInR5cGUiOiJqd3QifQ.eyJ1c2VybmFtZSI6InhqayIsImV4cCI6MTU4MjU0MjAxN30.oHdfcsUftJJob66e5mL1jLRpJwiG0i9MOD5gzM476eY jwt是由三段信息构成，将3部分信息构成JWT字符串，通过点进行分割，第一部分称为头部(header),第二部分称为在和(payload类似于飞机上承载的物品),第三部分是签证(signature)。
header
jwt的头部承载两部分：声明类型，声明加密算法
headers = { "type":"jwt", "alg":"HS256" } 然后将头部进行base64加密。(该加密是可以对称解密的)，构成了第一部分
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsInR5cGUiOiJqd3QifQ playload
载荷就是存放有效信息的地方，这个名字像是特指飞机上承载的货品，这些有效信息包含三部分：
标准中注册声明(建议不强制使用)：
iss:jwt签发者。sub:jwt所面向的用户aud:接收jwt的一方exp:jwt过期时间，这个过期时间必须大于签发时间nbf:定义在什么时间之前，该jwt都是不可用的lat:jwt的签发时间jti:jwt的唯一身份表示，主要用来作为一次性token,从而回避重放攻击。 公共的声明：
可以添加任何信息，一般添加用户相关信息。但不建议添加敏感信息，因为该部分在客户端可解密 私有的声明：
私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。{ "username": "xjk", } signature
jwt的第三部分是一个签证信息，这个签证信息由三部分组成： header(base64后的)payload(base64后的)secret这个部分需要base64加密后的header和base64加密后pyload使用，连接组成的祖父穿，然后通过header中声明加密方式，进行加盐secret组合加密，这样构成第三部分 2.pyJWT在django应用 views视图：
from django.http import JsonResponse from django.views import View from django.views.decorators.csrf import csrf_exempt from django.utils.decorators import method_decorator from utils.jwt_auth import create_token # 定义method_decorator 免 csrf校验， dispatch表示所有请求，因为所有请求都先经过dispatch @method_decorator(csrf_exempt,name="dispatch") class LoginView(View): """ 登陆校验 """ def post(self,request,*args,**kwargs): user = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ab8fcfcbdd46e3a692c16c17c8a1c9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad65279919b2c9af8e6770b57d49e17b/" rel="bookmark">
			Volatile关键字的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Volatile关键字的作用主要有如下两个：
1.线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。
2. 顺序一致性：禁止指令重排序。
一、线程可见性 我们先通过一个例子来看看线程的可见性：
public class VolatileTest { boolean flag = true; public void updateFlag() { this.flag = false; System.out.println("修改flag值为：" + this.flag); } public static void main(String[] args) { VolatileTest test = new VolatileTest(); new Thread(() -&gt; { while (test.flag) { } System.out.println(Thread.currentThread().getName() + "结束"); }, "Thread1").start(); new Thread(() -&gt; { try { Thread.sleep(2000); test.updateFlag(); } catch (InterruptedException e) { } }, "Thread2").start(); } } 打印结果如下，我们可以看到虽然线程Thread2已经把flag 修改为false了，但是线程Thread1没有读取到flag修改后的值，线程一直在运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad65279919b2c9af8e6770b57d49e17b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e82e170c140f00deb19e4a843ad118d/" rel="bookmark">
			UVM中uvm_sequencer的方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类声明
class uvm_sequencer #( type REQ = uvm_sequence_item, RSP = REQ ) extends uvm_sequencer_param_base #(REQ, RSP) |new|使用给定的名称和父类(如果有)创建该类实例的标准componnet构造函数。|
|stop_sequences|告诉sequencer杀死当前在sequencer上操作的所有sequence和子sequence，并删除当前排队的所有请求、锁定和响应。|
sequencer接口这是一个与sequencer通信的接口seq_item_export该export提供了对该sequencer接口的sequencer实现的访问。get_next_item从sequence中检索下一个可用的item项。try_next_item如果sequence中有可用项，则从sequence中检索下一个可用项。item_done表明请求已经完成。put发送响应发回给发送请求的sequence。get从sequence中检索下一个可用item项。peek如果有一个在FIFO中，则返回当前请求项。wait_for_sequences等待sequence有一个可用的新item。has_do_available如果在sequencer上运行的任何sequence准备提供transaction，则返回1，否则返回0。 new
function new ( string name, uvm_component parent = null ) 使用给定的名称和父类(如果有)创建该类实例的标准component构造函数。
stop_sequences
virtual function void stop_sequences()
告诉sequencer杀死当前在sequencer上操作的所有sequence和子sequence，并删除当前排队的所有请求、锁定和响应。这实质上是将sequencer重置为空闲状态
sequencer接口
这个一个和sequencer通信的接口。
这个接口定义为
Requests: virtual task get_next_item (output REQ request); virtual task try_next_item (output REQ request); virtual task get (output REQ request); virtual task peek (output REQ request); Responses: virtual function void item_done (input RSP response=null); virtual task put (input RSP response); Sync Control: virtual task wait_for_sequences (); virtual function bit has_do_available (); 请参阅 uvm_sqr_if_base #(REQ,RSP) 了解这个接口的信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e82e170c140f00deb19e4a843ad118d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd0c86ccc8abe9a4920156589f65955/" rel="bookmark">
			JAVA实现学生和老师同页面登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：搭建了一个JAVA WEB开发的项目架子，简单实现了学生和老师同页面登录，暂时未连接数据库；用户名和密码的校验是代码中写死的。连上数据库后就可动态校验。 1.效果图 项目登录页面展示： 使用用户名和密码进行登录，可以选择登录类型，默认登录类型为学生；
登录校验：
如果用户名或密码为空，则会给予提示；若用户名或密码不正确也会给出提示；
学生登录成功：
学生登录成功后跳转到学生的使用界面，展示每个学生的登录名称，具体页面内容可用自己添加；
老师登录成功：
2.项目目录结构 3个JSP页面；4个JAVA类；整个项目非常简洁，可自己进行扩展；项目代码我已经上传，需要一点费用下载；需要的可以去看看，下载后有不懂的地方可以问我；
以后有时间会逐步添加其它基本功能：统一中文编码，验证码，注册之类的；
3.下载链接： JAVA学生和老师同页面登录项目-Java文档类资源-CSDN下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fa7109f5640ccba589378c974ff0f51/" rel="bookmark">
			navicat连接其他电脑数库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 navicat 连接其他电脑的数据库 第一步：先看本电脑是否可以ping通其他的电脑的ip第二步 在navicat中输入查询命令第三步：grant all on . to admin@‘%’ identified by ‘123456’ with grant option;flush privileges;grant all privileges on . to ‘root’@‘%’ identified by ‘123456’ with grant option;flush privileges;完成 ；数据库中的user表中会多权限 两个% 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/532980d5e25727daf1ceb631b8a04af7/" rel="bookmark">
			出现报错Object reference not set to an instance of an object
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况描述：
我在Unity的Hierarchy最初始的Main Camera进行挂载了一个脚本，后来因为其他原因，删除了最初始的Main Camera，而后新建了一个Camera，并命名为Main Camera，然后挂载了之前相同的脚本之后，发现会出现下列bug：Object reference not set to an instance of an object。
原因：
未将对象引用到对象的实例.也就是没有实例化一个对象。当声明了变量,但是没有赋值,仍然为null.用的时候就会报错。
解决方法：
点击选中新建Camera,在Inspector属性设置中，找到tag下拉菜单中的Main Camera选中。重新运行程序，报错消除！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a8ea34fbd641eeaf83e9f43c6ebe2f/" rel="bookmark">
			权限中心设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. 权限模型1.1 RBAC0 模型1.2 RBAC1 模型1.3 RBAC2 模型1.4 RBAC3 模型1.5 用户组1.5.1 组织1.5.2 职位 1.6 含有组织 / 职位 / 用户组的模型 2. 授权流程3. 表结构4. 权限框架5. 结语 前言 权限管理是所有后台系统的都会涉及的一个重要组成部分，主要目的是对不同的人访问资源进行权限的控制，避免因权限控制缺失或操作不当引发的风险问题，如操作错误，隐私数据泄露等问题。
目前在公司负责权限这块, 所以对权限这块的设计比较熟悉, 公司采用微服务架构, 权限系统自然就独立出来了, 其他业务系统包括商品中心, 订单中心, 用户中心, 仓库系统, 小程序, 多个 APP 等十几个系统和终端
1. 权限模型 迄今为止最为普及的权限设计模型是 RBAC 模型, 基于角色的访问控制（Role-Based Access Control)
1.1 RBAC0 模型 RBAC0 模型如下:
以上是 RBAC 的核心设计及模型分析, 此模型也叫做 RBAC0, 而基于核心概念之上, RBAC 还提供了扩展模式。包括 RBAC1,RBAC2,RBAC3 模型。
下面介绍这三种类型
1.2 RBAC1 模型 此模型引入了角色继承 (Hierarchical Role) 概念，即角色具有上下级的关系，角色间的继承关系可分为一般继承关系和受限继承关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09a8ea34fbd641eeaf83e9f43c6ebe2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a70c64a3bdfd6be281a4580905204261/" rel="bookmark">
			《啊哈算法》学习笔记（三）——最短路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最短路径问题 这是整本书学得我最痛苦的地方…
而最后一章“其他算法”中有些代码已经看不明白了，也先搁置，以后系统学习数据结构和算法时再涉及。下面一起来看看几个精彩的最短路径算法。
Floyd-Warshall——多源最短路径 问题如下：
根据题意要求任意两个城市之间的最短路径，我们称这类问题为“多源最短路径问题”。
解决这类问题的弗洛伊德算法在初看时给我留下了深刻的印象，因为它的核心代码仅仅四行。
for (z = 1; z &lt;= n; z++) for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) if (e[i][j] &gt; e[i][z] + e[z][j]) e[i][j] = e[i][z] + e[z][j]; 我们关注最里面的判断条件，翻译一下就是：是否i到z再到j，会比i直接到j的距离更近，如果更近，就更新i到j的距离。
也就是不断的在两点之间插入另一个点，然后判断是否更新最短路径。在z的循环视角下，最后将所有额外的点都试着插入各个两点之间，使得所有点与点之间的路径都经过尝试与判断，于是求得了所有的最短路径。
来看完整代码：
#include &lt;stdio.h&gt; int main() { int n, m; int e[20][20] = {0}; int book[20] = {0}; int min = 999; int a, b, c; int i, j, z; int start, end; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a70c64a3bdfd6be281a4580905204261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c577a100187aea3c7737d0bd8b607d5/" rel="bookmark">
			《啊哈算法》学习笔记（二）——搜索与图的遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜索与图的遍历 《啊哈算法》在“搜索”前还有两个章节，讲了数据结构中的栈、队列和链表以及枚举算法。这些内容比较浅显，只是简单介绍，这里就不记录了，后续自学数据结构时会提到。这篇把搜索和图的遍历放在一起。
dfs——深度优先搜索 #include &lt;stdio.h&gt; int a[20][20];//用来存储地图，0为路，1为障碍 int book[20][20];//记录某点是否已走过（在路径上） int min = 999, way, top; int n, m; int end_x, end_y; struct Stu { int x; int y; } pos[100]; void dfs(int x, int y, int step) { int i; int next[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};//模拟走向右上左下 if (x == end_x &amp;&amp; y == end_y)判断是否到达终点 { if (step &lt; min) min = step; way++; if (way == 1) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c577a100187aea3c7737d0bd8b607d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8ec16d1b5c135730cb045e9d758b7a/" rel="bookmark">
			对信息断舍离进行时——一段自我反省
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对信息断舍离进行时 前些日子里我发现自己每天都在学，但是总感觉时间不够用，进度推不上去。我想也许是社交软件和视频网站浏览得太多了？于是乎我给手机和平板设置了使用时长限制，手机社交软件每日只能使用半小时，平板看哔哩哔哩只能看半小时。第一天实验就感到很诧异，自己连早上都还没有过，手机就提示半小时已经使用完了，而平板的视频限制也在午饭后稍微看一会就达到了。
我发现时间在这些零散碎片化的信息冲击下，流逝得无声无息。我开始思考，对网络中提到“我们正处在一个信息爆炸的时代”的观点有了更多一点的认识。
在我缓慢地敲下这些文字的时候，我有点惊恐。想想自己每天看的视频，开始被一个个惊奇的标题所吸引，然后不加思索地点进去，看上七八分钟，十多分钟，有的甚至只有一两分钟。在这一个视频的时间里，我收获了什么呢？许多时候只是笑了一下，没有什么实质性的价值。我想这对一个学业繁重的大学生来说，看这样的短视频是一件很浪费的事情，但这并不是让我惊恐的点。真正令我惊恐的是，看视频时的放松感觉，这种放松像是自我无意识的被五花八门的信息反复地冲刷着大脑。我的大脑一直在接收信息，但没有接受信息，我感觉自己的意识在那个时间段没有任何的抵抗力，只是被默默地冲刷…
再想想自己学习知识，很多时候听网课时的思考很少，一直在被动地接收，很多思考短暂而简单，而深层的思考越来越少。记得不久前对一个堆排序的相关问题有过一次深度思考的经历，因为看的教学视频中老师用的是java，他解决问题用到了Java自带的一个函数，具有那样功能的函数我发现C语言中并没有，想要解决这个问题，于是我自己试着手写实现同样的功能。那天我想了很久，试了很多次，从上午9点想到下午2,3点，很遗憾，我最终还是没能实现。同时，我恍然发现时间已经过去这么久，当时我感到很懊恼，也很焦虑，焦虑学习的进度太慢了，似乎这样的思考并不值得。现在回想起来，能得出一个关于我自己的结论：如果我进入了深度思考的状态，自己几乎感受不到时间。这样回忆后我感到很欣喜，以前听过一种叫做心流的状态，说是人的大脑进入高速运转时，常常意识不到时间的流逝，学习效率是很高的。我应该庆幸自己能进入那样的状态。
但身处当今时代，以前的高中老师就有说法：“做不出来就跳下一题，不要老是在一个点干耗着。”现实生活中也常出现这样的情况：如果我继续卡在这里，用了本该做后面的事情的时间，那么后面的事情也会做不完。即许多时候是一个节奏在推着我们走，人似乎身不由己。
我不想继续处在“身不由己”的状态。在高中老师逼着学，逼着学生按照老师自己认为正确的节奏走的日子里，我无比地渴望进入大学生活，高中就喜欢文学、电影，想着到了大学能静下心来多读书，多看电影，能够自我选择地学习一些自己感兴趣的东西。但现状是，我至今没能坚持着完成自己这小小的心愿，似乎还有种有人在后头催着你一定要学这，你一定要学那的感觉，同时本可以用来完成心愿的时间也在刷短视频、无用社交中浪费了。我喜欢自己学，“自己搞一套”，哪怕学同样的内容，我也时常不愿意跟着老师的路走。我知道，**“身不由己”本质上不是环境造就的，不是老师逼的，其实是自己给自己设定的囚笼、枷锁。**自己设定的牢笼不需要打破，只要有勇气敢走出来。如果仍顾忌着想要牢里的东西，如课堂上跟着老师学的平时分，完成奇奇怪怪要求的平时成绩，那就只能继续怨声怨气地继续“身不由己”。事实上，大部分学科自己用心学了就肯定能学有所成，不学才会必挂科。要成为自己想成为的人才，社会需要的人才，而不是只被教我的不喜欢的老师认可的人才。
我想我已经到了要跳出”做不出来就空着跳下一题，不要在一个点干耗着“这种思维定式的时候了，这不是一种明智取舍，而是放弃钻研习惯逃避。我该追寻更多的深度思考。先前深度思考后我回想所用的时间，竟焦虑地觉得是一种浪费。真是病态。我本该感到酣畅淋漓，求之不得啊!
而说回时间，摆脱快餐学习、浅层次吸收知识的代价，肯定是需要更多时间的。那时间从哪来，就从看视频、看社交软件上来吧！根据刚才的反省，既然自己惊恐地感到被碎片化无营养的信息冲刷了大脑，说明自己筛选信息、独立思考判断的能力还十分有限。干脆就大胆地对它们进行断舍离好了！每天人都是要接收信息的，学习中的信息必定要接受，而社交信息、社会新闻，这些信息中有些信息需要接收、有些没有意义，既然自我的判断能力还很差，干脆只接收一边的信息。尽可能舍弃无用社交，断绝短视频。回到高中时期没有手机时，知晓新闻只通过每日回家午饭时的新闻联播。算是让大脑专一一点吧。
**少一点无用社交，断绝短视频，多一点高质量的思考。**嗯，人区别于动物的特征就是思考，也许这样做，能让自己的心灵和生活之间多一点平衡与和谐吧！
先试着坚持一段时间，有所收获以后再回来记录感受。加油咯，Day1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba50d8b378eb07b8a3b0606e13e194cc/" rel="bookmark">
			业内视频超分辨率新标杆，快手&amp;大连理工研究登上CVPR 2022
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载整理自 快手音视频技术
量子位 | 公众号 QbitAI 现在，视频超分辨率算法又迎来新突破。
一篇最新登上CVPR 2022的论文，从一种新的视角，统一了视频超分辨率中的低分辨率和高分辨率的时序建模思路。
论文提出一种新的视频超分辨率框架，以较小的计算代价，充分利用了低分辩和高分辨率下的时序互补信息，以此带来更多细节和纹理的超分辨率结果。
研究在多个公开数据集上达到了SOTA效果，也为后续的视频超分辨率研究提供了新的灵感。
文章地址：https://arxiv.org/abs/2204.07114
代码地址：https://github.com/junpan19/VSR_ETDM
视频超分辨率难在哪？ 超分辨率是计算机视觉领域的经典技术，利用图像的自然结构信息实现图像从低分辩率到高分辨率的映射。随着深度学习的发展，卷积神经网络通过强大的拟合能力，在图像超分辨率场景取得了叹为观止的效果。
于是人们开始将目光转向更难的视频超分辨率任务，并在视频领域得到大规模的落地实践，如在快手App的服务端、移动端等业务都已广泛应用。视频超分辨率的难点在于时序信息的利用，即如何利用多帧图像序列间的互补信息来产生超分辨率所需的纹理细节。
现有的时序建模方法大致分为两个方向。
一个是基于光流[1,2,3]、可变形卷积[4,5]、3D卷积[6,7]的方法。这类方法会在低分辨率层面显性或者隐性地建模前后帧的时序信息，然后经过融合网络得到重建的高分辨率结果。由于这些建模的结构大多基于神经网络，并且较为复杂，有时难以直接插入到任意的视频框架中。
另一个时序建模的思路是基于递归隐状态累积的方法[8,9,10,11,12]，通过不断在隐层累积历史特征来建模整段视频序列的互补信息。
这种方案最早采用了单向的循环卷积网络，即只利用当前帧与前一帧和历史累积的结果作为网络的输入，融合得到超分辨率结果。该方式的好处是在一定的信息累积后，仅用较小的网络结构和运算成本便可取得可观的收益。但它的问题是前几帧的信息累积不充分，导致初始几帧的超分辨率效果都会受到损失。在实际场景中需要“预热”一段时间后才可以被使用。
双向循环卷积网络是缓解信息分配不平衡的一个解决方案，它将视频的全部信息分别进行正向和反向的传播，最终结合正向和反向的信息生成超分辨率结果。本文深入分析了这种方法，并发现双向的传播策略也面临两个问题。
（1）信息利用的灵活性。由于双向的传播策略通常是利用前一个和后一个的时序特征，所以当这些时刻发生遮挡或者视差变换时，误差也会累积到隐层特征中，对当前时刻的超分产生错误结果。
一个直观的解决方案是直接将多个时刻的信息传播到当前时刻，但较大的运动差异反而会影响融合的效果。近期有一些方法，采取对预测结果进行运动补偿来弥补，但无论是光流还是可变形卷积都会引入庞大的计算开销。
（2）实时性。由于双向循环卷积网络的每次运算都要导入所有图像序列的处理，导致难以在实况直播这种因果系统中应用。
此外，无论是在相邻帧的融合方式，还是在特征传播上，现有的视频超分辨率框架仍没有统一的处理方案，往往需要应对各自的时序建模的对象来单独设计策略，这也引发了本文的思考，是否存在一种统一的策略，来对低分辨率图像和高分辨率结果进行时序建模？
面对上述问题，本文提出用相邻帧的时间残差图来统一低分辨率和高分辨率的时序建模视角。
在低分辨率空间下，输入帧的时间残差图可以用来区分这两帧间中的低变化和高变化区域，不同的区域所包含的互补信息应当在重建中被区分对待。在高分辨率空间下，时序残差图可以将不同时刻的预测结果以较小的运算代价传播到任意过去和未来的时刻。
值得一提的是，所提出的视频超分辨率框架（ETDM）虽然是单向循环网络的传播结构，但在时间残差图的帮助下，当前时刻的初步超分辨率结果可以被多个过去和未来的结果进一步增强。
图1展示了ETDM在学术公开集Vid4上的处理效果，超过了众多已经发表的视频超分辨率方案，同时也展示了一张图片从320×180超分到1280×720所需的速度。ETDM方法以单向的循环卷积网络结构超过了大部分单向、双向、多帧融合的方法，达到了更好的效果与速度的平衡。
△图1 ETDM方法与其他SOTA方法在效果和速度上的对比
具体如何实现？ 如图2所示，本文提出的视频超分辨率结构（ETDM）是一个基于单向结构的循环卷积网络，即隐层特征只采用正向的传播方式。对于每个时刻，网络的输入分为两个层面：一个是低分辨率空间下的图像序列（前一帧I{t-1}、当前帧I{t}和后一帧I{t+1}）；另一个是高分辨率空间下的预测结果。
ETDM的核心是提出用相邻帧的差分图来统一这两个层面下的时序建模方式。这里定义当前帧为参考帧，时间差分图为参考帧与相邻帧的差，它既可以表示为前后帧图像的像素变化差异，也可以被认为是参考帧到邻近帧的转换“桥梁”。接下来将从这两方面具体介绍时间差分图的应用方式。
△图2 所提出的ETDM网络结构
在低分辨率空间下的显性时序建模 由于视频帧在获取时具有连续性，存在冗余和非冗余的时序信息，因此相邻帧有着不同程度的互补信息。为了验证这一点，采用图3描绘了参考帧相对邻近帧在不同区域的像素变化程度，不同的颜色表示不同的强度。
△图3 相邻两帧每个像素点的差异程度
可以发现，相邻帧中存在像素点运动差异变化程度较小和较大的区域。这种差异程度具有一定启发性，是否能用时间残差图将邻近帧拆分为低变化（LV）和高变化（HV）的区域。
直觉上，LV区域的表征变化细微，那么相邻帧的互补信息可能来源于微小的细节；而HV区域的整体差异较大，可以从不同方面提供更粗尺度的互补信息。
但是，时间差分图是非常稀疏的。为了得到完整的划分区域，我们先对它用3×3进行滤波和图形化方法处理，然后将其变为二值化的时序差分图并作用到原图上，得到LV和HV区域，如下所示：
由于自然图像的平滑性，LV可能对应帧间小运动的区域，而HV可能对应大运动的区域。
因此在融合方式上，本文选择用参数共享但感受野不同的融合网络。具体来讲，为HV分支的前几层网络分配了更大的空洞率，从而捕捉更大的运动信息。
在高分辨率空间下的显性时序建模 残差图的另一层含义是参考帧到邻近帧的转换“桥梁”。于是，除了重建当前时刻的超分辨率结果外，我们还会重建当前时刻到过去和未来的高分辨率时序残差图。
如上图2所示，我们在特征提取网络后增加了3个Residual Head （Spatial-Residual Head, Past-Residual Head 和 Future-Residual Head）。它们分别预测当前时刻的超分辨率结果，当前到过去的时序残差图的超分辨率结果，以及当前到未来的时序残差图的超分辨率结果。
通过利用所预测的时序残差图，当前、未来或者过去时刻所预测的超分辨率结果便可以传播到当前时刻，并为当前时刻提供更多互补信息。
于是，我们提出了时序往返优化机制。对于当前时刻而言，过去时刻和未来时刻的结果可以按照下面的方式传播到当前时刻：
传播过来的结果带来了不同时刻下的互补信息，因此可以帮助当前时刻的超分辨率结果获得进一步优化。
我们进一步发现，时间残差图具备累积转移特性，即当前时刻到任意时刻的时间转移都可以用这段时间内每个相邻帧的时序残差图来累积得到。于是，自然地将传播过程进阶扩展到任意的时间顺序上。下式展示了将第t-l个时刻的结果传递到当前时刻：
同理，也可以将t+l个时刻的结果传递到当前时刻：
为了充分利用不同时刻下的互补信息，我们维护了长度为N的存储器，来存储N个过去和未来时刻的超分辨率结果，即和。
下图表示了存储器的更新过程。
△图4 存储器的更新过程
这里以第t帧处理后，开始重建第t+1时刻的帧为例。此时，网络不仅需要更新隐层的特征，还需要更新存储器中的特征，采用下方公式来更新：
效果如何？
一些现有的方法采用不同的数据集来训练网络，这些数据集中的纹理分布不同，对性能也具有一定影响，不利于公平地比较。本文采用了公开的数据集Vimeo-90K来训练网络，并在该数据下复现了部分已有的方法。具体性能比较如图5所示。
△图5 定量的性能对比
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba50d8b378eb07b8a3b0606e13e194cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f832588daa186f9ce81ab6ad1329edf8/" rel="bookmark">
			eval跟new Function的区别是什么?是否有共同点?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eval() 函数会将传入的字符串当做 JavaScript 代码进行执行
console.log(eval('2 + 2'));// 4 let p = 1; let aa = eval('(function a(){console.log("eval定义的函数",p)})()'); console.log(aa);// "eval定义的函数" 1 建议在nodejs模式下执行，浏览器会报安全问题！
入参只有一个，是string类型：
一个表示 JavaScript 表达式、语句或一系列语句的字符串。表达式可以包含变量与已存在对象的属性
new Function 每个 JavaScript 函数实际上都是一个 Function 对象。运行 (function(){}).constructor === Function // true 便可以得到这个结论。
由 Function 构造函数创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 Function 构造函数创建时所在的作用域的变量。这一点与使用 eval() 执行创建函数的代码不同。
需要在浏览器上运行，在nodejs上运行的结果是不一样的
var x = 10; function createFunction1() { var x = 20; return new Function('return x;'); // 这里的 x 指向最上面全局作用域内的 x } var f1 = createFunction1(); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f832588daa186f9ce81ab6ad1329edf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d675575d31fdf31ea5cc1ade1f0125/" rel="bookmark">
			matlab无法打开excel的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab无法打开excel problem怎么解决 problem 重装系统时直接移植了matlab和office两个大套件，之前用matlab调用读取电子表格一直没有什么问题，今天在统计手机上网流量的时候想用matlab对表格里的单位处理一下，好家伙这玩意给我报错把我搞懵逼了。是太久没用了突然今天停工出问题来抗议吗？表现如下：
以及
怎么解决 找了半天问题终于妥妥搞定，下面来讲一下怎么解决。
不是matlab的问题，是excel的com加载项出了毛病。
1.在office安装的根目录找到excel.exe的文件，右键单击采用以管理员身份运行，不然还是会还原成原来的样子。注意我说的重点哦，如果直接打开一个excel文档进行下面的操作没有效果的，而且一定要用管理员的身份打开。
2.打开后点击文件，进入选项中的com加载项。
3.把com加载项里的福昕阅读器的选项取消掉。
4.最后把excel和matlab两个软件都关了，接着重启后就可以在matlab里直接打开电子表格或调用xlsread函数了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1349e2f16a7929e36a50914b0c9e9c77/" rel="bookmark">
			利用python实现m4a格式到MP3的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现m4a格式到MP3的转换 前言安装ffmpeg库安装pydub库代码主体 前言 \quad 因为会议海报需要录制音频解说，但是手机录音机默认的格式是m4a的格式，不符合mp3的格式要求，所以在格式转换上花费了我很大功夫：先是找到了免费的在线转化（网址https://convertio.co/zh/），文件上限制为100M下载了但是超过了上传的上限，无奈又下载了几个音频转换软件，结果不是有音频水印就是转换容量特别小，反正就是要你买会员掏钱，最后还是求助自己编程实现转换。
\quad 看了一下matlab，只能够支持这些格式的输入输出。
所以只能用python啦。本文面向安装了Anaconda的用户使用，需要基本的python使用基础。
安装ffmpeg库 打开Anaconda，搜索ffmpeg，点击默认安装即可。
安装pydub库 pydub库在Anaconda里面没有，运行cmd通过pip install pydub 回车进行安装。
代码主体 下面就是代码主体啦，新建一个py文件，把需要转换的文件放在同一个目录，输入下面的内容运行即可，这里针对MP3进行示范。
from pydub import AudioSegment def trans_mp3_to_other(filepath, hz): song = AudioSegment.from_mp3(filepath) song.export("Newsound." + str(hz), format=str(hz)) def trans_wav_to_other(filepath, hz): song = AudioSegment.from_wav(filepath) song.export("Newsound." + str(hz), format=str(hz)) def trans_ogg_to_other(filepath, hz): song = AudioSegment.from_ogg(filepath) song.export("Newsound." + str(hz), format=str(hz)) def trans_flac_to_other(filepath, hz): song = AudioSegment.from_file(filepath) song.export("Newsound." + str(hz), format=str(hz)) def trans_m4a_to_other(filepath, hz): song = AudioSegment.from_file(filepath) song.export("Newsound." + str(hz), format=str(hz)) # 参数1：音频路径， 参数2：转换后的格式 trans_m4a_to_other("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1349e2f16a7929e36a50914b0c9e9c77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ece221de17a1df456ee018311f512f51/" rel="bookmark">
			idea一个类启动多个线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先将一个类启动起来，这里为了便于区分，这里控制台打印一下
2.然后配置该类可以多线程启动
3.修改一下打印再次启动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e1a6d7c665eff352b9212413a77758/" rel="bookmark">
			AntdPro上传文件之Antd各个版本的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、antd3上传图片二、antd4上传文件三、使用antdPro 之前一直在使用antd上传文件，图片，从antd3到antd4再到antdPro，总结一下经验吧 一、antd3上传图片 这里用的antd的版本是"antd": "^3.25.0",
import React, { FC, forwardRef, useState, memo } from 'react'; import { Button, Icon, Upload as AntdUpload, Spin } from 'antd'; import { UploadChangeParam } from 'antd/lib/upload'; import { UploadFile } from 'antd/lib/upload/interface'; import { getBase64Rotatatin } from 'utils'; import { detectImageAutomaticRotation } from 'utils/rotatain'; import styles from './uploadImg.module.scss'; import classNames from 'classnames'; interface Props { onChange?(base64: string): void; value?: string; size?: 'small' | 'default'; } //获取base64 // eslint-disable-next-line @typescript-eslint/explicit-function-return-type function getBase64(img: any, callback: any) { const reader = new FileReader(); reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9e1a6d7c665eff352b9212413a77758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4d45e408650d880cda0e93e7dfae58/" rel="bookmark">
			记录一次将学习项目从github到gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因为学习rabbiteMQ，然后创建了一个项目在github上。但是用了两天发现因为网络原因导致很多时候会提交或者拉取代码失败，所以打算将项目转到码云上！
1.首先导入github的仓库
2.选择自己的导入方式
3.找到新的git地址
4.idea安装码云插件
5.添加码云的账户
登录的时候发现，这里不能使用手机号登录，我直接用创建时候的邮箱登录的。
6.替换掉原有的github的地址
7.替换完成
8.直接拉取会报错 先上传一次。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb049262254255da1505a351bb905d19/" rel="bookmark">
			react&#43;ts搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、通过create-react-app脚手架创建项目
npx create-react-app testproject --template typescript
在vscode中打开项目，可以看到顺利生成了react项目且组件的后缀为tsx,此时说明成功创建了react+typescript项目的雏形
在项目根目录下，运行npm run start，成功启动项目
npm run start
二、配置路由
npm i react-router-dom@5.2.0 react-router-config @types/react-router-config @types/react-router-dom -S
src目录下创建views文件夹，views内创建Home，Contact，About，Navbar四个tsx文件，其中Navbar用来控制路由，其他三个页面用来展示
Home:
import React, { Component } from "react";
export default class Home extends Component {
render() {
return (
&lt;div className="home"&gt;
&lt;div className="container"&gt;
&lt;h3 className="center"&gt; Home页面&lt;/h3&gt;
&lt;p&gt;欢迎来到首页&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
);
}
}
Contact:
import React, { Component } from "react";
export default class Contact extends Component {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb049262254255da1505a351bb905d19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/132ff2f75244ba940fb4196e3a76489c/" rel="bookmark">
			初始webshell&#43;中国菜刀的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章内容仅用于渗透测试研究学习，请勿用于非法测试
文章目录 一、webshell是什么？二、木马三、中国菜刀 一、webshell是什么？ “Web” 的含义是服务器开放web服务；
"Shell"的含义是取得对服务器某种程度上的操作权限；
"webshell"就是获取对服务器的控制权限，这就需要我们借助一些webshell管理工具和一些漏洞去得到这种权限。
二、木马 在我们使用webshell管理工具之前，需要先在目标服务器上传或创建一个木马文件
木马分为大马、小马和一句话木马：
小马：文件体积小、上传文件、文件修改、文件管理大马：文件体积较大、功能齐全、能够提权、操作数据库等（不推荐）一句话木马：短小精悍、功能强大、隐蔽性好、客户端直接管理（主流） php
&lt;?php @eval($_POST['x'];?)&gt; asp
&lt;%eval request ("x")%&gt; aspx
&lt;%@ Page Language="Jscript"%&gt; &lt;%eval(Request.Item["x"],"unsafe");%&gt; 三、中国菜刀 这里以php为例
首先我们先将php一句话木马上传到目标服务器中，用菜刀去尝试连接
在地址中填写上传一句话木马的地址，在后面的方框中填写所要连接的参数（也就是代码中的’x’）
添加完成之后就可以对目标服务器进行控制，可以对文件进行相关的操作，也可以对数据库进行操作，也可以创建一个用户。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/112/">«</a>
	<span class="pagination__item pagination__item--current">113/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/114/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>