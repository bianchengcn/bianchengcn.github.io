<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a01ee6f3f70dededcedca7cdc96c7a/" rel="bookmark">
			vue下拉加载更多数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.div内容
&lt;div
class="qkdqMenu"
v-for="(item, index) in recomList"
:key="index"
@click="goChild(item)"
&gt;
&lt;div class="kwtjImg"&gt;
&lt;img
src="../../assets/img/none.jpg"
alt=""
style="width: 100%; height: 100%"
v-if="item.qkfy == null"
/&gt;
&lt;img :src="item.qkfy" alt="" style="width: 100%; height: 100%" v-else /&gt;
&lt;/div&gt;
&lt;div class="qkdqIntr"&gt;
&lt;div class="qkdpTitle" :title="item.qkmc"&gt;{{ item.qkmc }}&lt;/div&gt;
&lt;div class="intr"&gt;{{ item.introduce }}&lt;/div&gt;
&lt;/div&gt;
&lt;div class="qkdqImg"&gt;荐&lt;/div&gt;
&lt;/div&gt;
2.vue调用
mounted() {
window.addEventListener("scroll", this.onScrollFunc, true);
},
beforeUnmount() {
window.removeEventListener("scroll", this.onScrollFunc, true);
},
unmounted() {
window.removeEventListener("scroll", this.onScrollFunc, true);
},
destroyed() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58a01ee6f3f70dededcedca7cdc96c7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87fbc02c9f2acc9cb4187b31931bd6b9/" rel="bookmark">
			Java中 Map集合 compute 、computeIfAbsent 、 computeIfPresent、putIfAbsent 、getOrDefault 方法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中 Map集合 compute 、computeIfAbsent 、 computeIfPresent、putIfAbsent 、getOrDefault 方法的区别 一、概述 最近在写代码过程中，发现java map中增加一些方法：compute 、computeIfAbsent 、 computeIfPresent、putIfAbsent 、getOrDefault ， 在平时开发中要到一些，但是没有仔细对比各个方法之间的区别。 本文将系统性的整理 几个重要的方法区别：
compute 3个方法之间的区别；putIfAbsent 和computeIfAbsent 方法的异同点 ；put 和 putIfAbsent方法的区别。 二、代码演示 1、 get 和 getOrDefault 方法演示 @Test public void getAndgetOrDefaultTest() throws Exception { final HashMap&lt;Object, Object&gt; map = Maps.newHashMap(); map.put("name", "名字"); System.out.println("get 获取存在： " + map.get("name")); System.out.println("get 获取不存在： " + map.get("hh")); System.out.println("getOrDefault 获取存在： " + map.getOrDefault("name", " 不存在值")); System.out.println("getOrDefault 获取不存在： " + map.getOrDefault("hh", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87fbc02c9f2acc9cb4187b31931bd6b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d1cd1cf7247cfef41b9262586a2077/" rel="bookmark">
			如何同步 Github 和 Gitee的仓库代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、从github导入仓库，手动同步 在 Gitee 的项目主页，导入的仓库会会有一个同步的按钮，你只用点一下，即可与 Github 同步更新，但是注意这里的同步功能默认是强制同步。有点麻烦的是，我们需要在推送到 Github 后，再到 Gitee 项目主页手动点击一下。
二、推送两个仓库 可以通过本地仓库的形式，同时推送到github和gitee，相当于执行两次commit的操作，push两次。但显然也不是我想要的。
git remote add 远程库名 远程库地址 eg: git remote add gitee git@github.com:xxx/xxx.git 除此之外我们还可以在sh脚本文件里deploy.sh直接推送2个仓库
#!/usr/bin/env sh # 确保脚本抛出遇到的错误 set -e # 定义变量 dist_path=docs/.vuepress/dist # 打包生成的文件夹路径 # 生成静态文件 npm run docs:build # 进入生成的文件夹 cd $dist_path git init git add -A git commit -m 'deploy' # 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt; git push -f git@github.com:ytking/test.git master:gh-pages git push -f git@gitee.com:ytanck/test.git master:gh-pages cd - rm -rf $dist_path 当我们执行 sh deploy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d1cd1cf7247cfef41b9262586a2077/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e57fc01353c5ca782358c7eb291d4ef5/" rel="bookmark">
			电脑不能调节亮度了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天更新一下系统，电脑突然不能调节亮度。
看到这个答案受到启发：电脑突然调节不了亮度？让我教你来恢复
打开 "设备管理器" =&gt; "显示适配器" =&gt; 下面的驱动右键（两个都要） =&gt; 选择更新驱动 =&gt; 浏览我的计算机以查看驱动程序软件 =&gt; 选择 "让我从计算机上的可用驱动程序列表中选取" =&gt; 在显示兼容硬件下, 选择 "通用即插即用监视器"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1636b528dbe436fa43ba279e6adcd92/" rel="bookmark">
			vivado 2022.2 搭建ZCU104最小系统 Block Design 后提示 Submodule Runs Failed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		省流：线程开多了，设为1试试 。
最近在搭ZCU104最小系统，参考ug940手册（SP701）：
ug940
但是在 Step 5: Generate Output Products 时发生错误，综合失败。
在bing上搜索，发现有同学和我同样错误： ​ Vivado 2021.2 in windows always gives Submodule Runs Failed -&gt; synth_design ERROR without any error description ​
尝试了几种方法无果，无意中发现将线程设置为1，综合全部通过：
结论：电脑配置问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d42bc8adf4b68525121ba92a0b9c981/" rel="bookmark">
			封装的方法固定的参数，特殊环境下需要多带参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件封装的时候某些方法回传出去某些参数，但是特殊条件下需要将其他参数也一并带入方法中使用
比如图片中的方法就可以实现不影响自带的参数，也不影响我们需要多带的参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f319c060cee569ff9d4d61903d1bf7f5/" rel="bookmark">
			Qt Creator编译含opencv的程序时报错libopencv_calib3d.so:-1: error: error adding symbols
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息：
/home/lyc/Exe/opencv-3.4.16/opencv_install/lib/libopencv_calib3d.so👎 error: error adding symbols: File in wrong format
进入libopencv_calib3d.so所在的目录，利用file查看文件格式。
由于libopencv_calib3d.so最终软链接为libopencv_calib3d.so.3.4.16
执行：
file libopencv_calib3d.so 得到的信息：
看来之前编译时，采用了交叉编译器gcc-arm
解决措施：重新采用x86_64平台的gcc编译opencv库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62d45b13775ff7f370da5e2028551283/" rel="bookmark">
			javascript高级程序设计pdf,javascript 高级程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，给大家分享一下javascript高级程序设计 javascript权威指南，很多人还不知道这一点。下面详细解释一下。现在让我们来看看！
一、面向对象的程序设计 1. 属性类型 // 1.数据属性 object.defineproperty(属相所在的对象，属性名，（4种）) let person = {}; Object.defineProperty(person, "name", { configurable: true, //表示能否通过delete删除属性从而重新定义属性，能否修改属性 enumerable: true, //表示能否通过for-in循环返回属性 writable: true, // 表示是否能修改属性的值 value: "xujiang" // 属性的值 }) /* 在调用Object.defineProperty()方法创建一个新属性时，如不指定前三个属性字段，默认值都为false, 如果是修改已定义的属性时，则没有此限制 */ // 2.访问器属性get/set let person = {name: "xujaijgn", year: 11}; Object.defineProperty(person, "_name", { get: function(){ return this.name }, // 定义Set时，则设置一个属性的值时会导致其他属性发生变化 set: function(newValue){ this.name = newValue; this.year = 12; } }) // 定义多个属性 Object.defineProperties(book, { _year: { writable: false, value: 2001 }, year: { get: function(){ return _year }, set: function(newValue){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62d45b13775ff7f370da5e2028551283/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f3e73f34814a9a335936ed76fcdecfa/" rel="bookmark">
			sql查询到了数据但是实体类个别字段为null(映射失败)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客： sql查询到了数据但是实体类个别字段为null(映射失败)_sql语句查到值,加字段!null没值-CSDN博客
问题描述： 1.SQL查询到了数据，在idea调试output控制台窗口打印出SQL语句，字段有值；
2.接收实体对象字段无值；
3.接收实体对象所对应的数据库表无该字段，只在实体类中定义（额外增加的字段）；
4.SQL语句：该字段的值来自其他表，SQL语句存在关联查询。
问题原因： SQL语句的接收对象没有定义该字段的映射，没有与实体类建立映射关系。
解决办法： 增加字段映射
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca13e8e55095b5213e7ac9bb3613d554/" rel="bookmark">
			QT属性动画--设置样式属性(其他属性)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 故事背景遇到的问题解决过程最终方法总结 故事背景 最近在制作一个按钮切换的动画特效中接触了属性动画这部分内容，并由此产生了一些思考。
开始也是不会使用 QPropertyAnimation 这个类，然后就在网上查资料总算是完成自己想要的效果了，但是发现了一个问题，网上我查到的资料在介绍使用QPropertyAnimation类时都是只使用 geometry 这一个属性。
porpAnim-&gt;setPropertyName("geometry"); 这就令我很奇怪了，按理说这个QPropertyAnimation(属性动画)应该可以控制很多属性的，为什么大家都知识介绍这一个属性，以这个为契机，我开始研究如何进行样式动画属性.
遇到的问题 既然是设置样式动画属性，那属性肯定不是geometry了，我们需要到头文件里面看看。我这里要设置的控件是QPushButton，我们可以直接去它的基类QWidget里面看样式属性。可以看到属性名称是styleSheet，是一个QString类型变量。
Q_PROPERTY(QString styleSheet READ styleSheet WRITE setStyleSheet) 接着仿照设置geometry来设置styleSheet。我是想着设置btn_A按钮的背景颜色进行一个由黑变白的动画效果。但是很遗憾，这样的操作并不奏效。于是我去网上找相关的资料，希望可以找到一点线索。
QPropertyAnimation *animation = new QPropertyAnimation(ui-&gt;btn_A, "styleSheet"); animation-&gt;setDuration(100); animation-&gt;setStartValue(QString("background-color:#000000")); animation-&gt;setEndValue(QString("background-color:#ffffff")); animation-&gt;start(); 解决过程 在网上转了一圈，还是没有找到什么好的方法，于是我决定自己来看看到底怎么解决这个问题。首先我想到的是可能是我传入setStartValue的值不对，既然是样式属性，那么传入的参数应该是样式表这样的字符串吧，于是我进行了如下修改。为了能看到明显变化，我在界面的构造函数中还设置btn_A按钮的样式表为红色。但还是不生效。
#include "mainwindow.h" #include "ui_mainwindow.h" MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-&gt;setupUi(this); this-&gt;setStyleSheet("#btn_A{ background-color:red} "); //首先设置样式表 } MainWindow::~MainWindow() { delete ui; } void MainWindow::on_btn_B_clicked() { QPropertyAnimation *animation = new QPropertyAnimation(ui-&gt;btn_A, "styleSheet"); animation-&gt;setDuration(100); animation-&gt;setStartValue(QString("QPushButton{ background-color:#000000} ")); //这里是我的改动 animation-&gt;setEndValue(QString("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca13e8e55095b5213e7ac9bb3613d554/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96bdf564d18ba115fe445ba7b0a0217/" rel="bookmark">
			2021年经典大厂面试题——算法与数据结构版（含答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经典大厂面试题 题目 请问，Object作为HashMap的key的话，对Object有什么要求吗？请问 hashset 存的数是有序的吗？输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径二叉树的搜索区间现在有一个单向链表，谈一谈，如何判断链表中是否出现了环随机链表的复制找出数组中和为S的一对组合，找出一组就行求一个数组中连续子向量的最大和谈一谈，如何得到一个数据流中的中位数？你知道哪些排序算法，这些算法的时间复杂度分别是多少，解释一下快排？请你解释一下，内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法。说一说，heap和stack有什么区别。请你设计一个算法，用来压缩一段URL？谈一谈，id全局唯一且自增，如何实现？一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数，请说一下你的思路并手写代码请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素判断一个链表是否为回文链表，说出你的思路并手写代码 答案 请问，Object作为HashMap的key的话，对Object有什么要求吗？ 考察点：哈希表
参考回答： 要求 Object 中 hashcode 不能变。
解读： 什么是hashcode。Java语言中，Object对象有个特殊的方法：hashcode(), hashcode()表示的是JVM虚拟机为这个Object对象分配的一个int类型的数值，JVM会使用对象的hashcode值来提高对HashMap、Hashtable哈希表存取对象的使用效率。
关于Object对象的hashCode()返回值，网上对它就是一个简单的描述：“JVM根据某种策略生成的”.
什么是JVM。Java虚拟机（Java Virtual Machine 简称JVM）。通常来说，高级语言运行在不同的平台上，需要编译为不同的语言，但是如果不同的平台都有虚拟机，由虚拟机来执行Java语言，就不需要编译为不同的语言，这也就解释了为什么Java可以跨平台运行。
请问 hashset 存的数是有序的吗？ 参考回答： Hashset 是无序的。
解读：什么事hashset。hashset储存的是唯一的对象，没有下标，只能通过增强for，或者迭代器进行遍历。当出现相同的对象，会合并，只储存一个空间。
//遍历方法一： Iterator&lt;news&gt; it=set.iterator(); while(it.hasNext()){ News n=it.next(); } ----------------------------------------- //遍历方法二： for(News n:set){ printf(n); } 输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径 剑指Offer JZ24 二叉树中和为某一值的路径
/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) { vector&lt;int&gt; path; vector&lt;vector&lt;int&gt; &gt;res; if(root==NULL)return res; Find(root,path,expectNumber,res); return res; } void Find(TreeNode* root,vector&lt;int&gt;&amp; p,int sum,vector&lt;vector&lt;int&gt;&gt; &amp;res){ p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e96bdf564d18ba115fe445ba7b0a0217/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b40d8f12bf4ed078af805558f5268fb9/" rel="bookmark">
			面向C&#43;&#43;模块的开源 IFC SDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早在 VS2019 v16.10 版本的时候，我们就官宣了对 C++ 模块(以及几乎所有其他 C++ 20 特性)的全面支持，包括 MSVC 编译器工具集，静态分析，智能感知和调试器等，而实现模块需要将 C++ 代码实现为一种内部的临时表示形式。
今天，我们高兴地宣布将 IFC SDK 开源，它是 Microsoft 对 IFC 规范的一个实现。
IFC 规范将 C++ 程序形式化为适合基于语义操作的数据。
我们开源 IFC SDK 的目的是，希望加速 C++ 模块在 C++ 社区和 C++ 工具生态系统中的广泛使用和实施。
什么是 IFC 以及它的作用是什么？ C++ 模块接口（或头单元）源文件的一种常用编译策略是将源文件（恰好一次）转换为适合在其他源文件中重用的内部表示形式。这种中间形式通常称为构建模块接口（BMI）。IFC文件则是 BMI 概念的实现。IFC 文件是与 C++ 程序的语义有关的所有信息的持久性表示。
除了编译器直接使用C++模块外，还可以通过非编译器工具检查 IFC，以便对C++源文件进行基于语义的探索。这些工具对于探索者了解如何以适合 C++ 模块实现的形式表示 C++ 源代码级构造非常有用。
IFC SDK 的使用 IFC SDK 目前是一个实验项目。它侧重于提供支持 IFC 文件读写的数据类型和源代码。此 SDK 与 MSVC 编译器前端中用于实现 C++ 模块的经过测试的实现相同。
这些数据类型可以直接进行内存映射，以实现可扩展和高效的处理。
该项目还具有用于格式化或查看 IFC 文件的实用程序。我们欢迎并且正在寻找能够弥补SDK和规范之间差距的贡献，以及支持从 C++20 及更高版本开始的 C++ 标准所需的更改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b40d8f12bf4ed078af805558f5268fb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a4adb86a23fd1ab12c04dc75b076942/" rel="bookmark">
			Linux运行环境搭建系列-JDK安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JDK安装 构建环境：腾讯云CentOS 7.9。
JDK jar包下载地址：https://www.oracle.com/java/technologies/downloads
使用scp命令上传Jar包到/usr/local目录下：
$ scp jdk-8u152-linux-x64.tar.gz root@81.70.247.41:/usr/local 解压缩
$ cd /usr/local &amp;&amp; tar zxvf jdk-8u152-linux-x64.tar.gz &amp;&amp; rm -f jdk-8u152-linux-x64.tar.gz 设置环境变量
$ yum install vim &amp;&amp; vim /etc/profile export JAVA_HOME=/usr/local/jdk1.8.0_152 export PATH=$PATH:$JAVA_HOME/bin 退出vim编辑器，使环境变量设置立即生效
$ source /etc/profile 查看JDK版本
$ java -version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5b5f9e035331ff0d3923581b105c09/" rel="bookmark">
			【案例】从kaggle的房价预测模型案例中了解深度学习模型，即如何学习深度学习模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景 深度学习是什么，为了解决什么样的问题
深度学习是一种机器学习的方法，它的主要目的是从数据中自动学习到有效的特征表示。深度学习通过多层的特征转换，把原始数据变成更高层次、更抽象的表示。这些学习到的表示可以替代人工设计的特征，从而避免“特征工程”。
深度学习主要要解决的是如何让机器能够模仿人脑的思考方式。从而摆脱原来的固有数据库比较的限制。让机器能够通过深度学习理解这个不断变化的世界。
结合本次分享，主要是预测芝加哥房价
问题陈述
房价预测是kaggle的一个经典Data Science项目，作为数据分析的新手，这是一个很好的入门练习项目。
任务很明确，就是要根据给出的79个特征，预测对应的房价，这些特征包括房子的类型、临街宽度、各层的面积等等。
数据可以在以下链接下载：
Kaggle: House Price
给出的数据包括四份文件：
. ‘train.csv’：训练数据
· ‘test.csv’：测试数据
· ‘data_description.txt’：说明各个特征的文档
· ‘sample_submission.csv’：预测结果提交的示例
一个模型好不好，我们要给出评价模型，我们采用kaggle官方给出的模型评价函数RMSE
2、深度学习的基础理论 人工神经网络：人工神经网络（Artificial Neural Network，即ANN ），是20世纪80 年代以来人工智能领域兴起的研究热点。它从信息处理角度对人脑神经元网络进行抽象， 建立某种简单模型，按不同的连接方式组成不同的网络。在工程与学术界也常直接简称为神经网络或类神经 。人工神经网络是一种应用类似于大脑神经突触联接的结构进行信息处理的数学模型，简称为“神经网络”或类神经网络 。
反向传播算法：反向传播算法（Backpropagation Algorithm），简称BP算法，是一种用于训练多层神经网络的监督学习算法。它建立在梯度下降法的基础上，适合于多层神经元网络的一种学习算法。反向传播算法网络的输入输出关系实质上是一种映射关系：一个n输入m输出的BP神经网络所完成的功能是从n维欧氏空间向m维欧氏空间中一有限域的连续映射，这一映射具有高度非线性。反向传播算法主要由两个环节(激励传播、权重更新)反复循环迭代，直到网络的对输入的响应达到预定的目标范围为止 。
激活函数的作用：激活函数的作用是将神经元的输入信号转换为输出信号，从而引入非线性因素，使神经网络能够更好地拟合复杂的数据集。激活函数可以是一个非线性函数，如Sigmoid、Tanh、ReLU等，也可以是一个线性函数，如恒等映射。在神经网络中，激活函数的选择对网络的性能有很大的影响 。虽然上面有多种激活函数，但是每个激活函数都有各自的优劣，比如sigmoid会导致梯度消失等问题，所以目前常用的激活函数是ReLU函数。
3、我们需要选择深度学习的框架和工具 作为深度学习的框架，目前已知的特别多，比如国外的TensorFlow、PyTorch、Keras、Caffe、Theano等等，国内有百度的Paddle，这些都是很优秀的深度学习框架。在这其中我们选用PyTorch使用，因为它最简单上手快的特点。
4、模型的训练 1、读取数据
import pandas as pd train = pd.read_csv('/kaggle/input/house-prices-advanced-regression-techniques/train.csv') train_copy = train.copy() test = pd.read_csv('/kaggle/input/house-prices-advanced-regression-techniques/test.csv') 2、查看前面5条数据
train.head() 3、查看数据摘要，他会展示整个数据的情况
train.info() 4、进行预测
import matplotlib.pyplot as plt import random#sheng cheng shujuji import torch import numpy as npnum_inputs = 2 num_examples = 1000 true_w = [2,-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f5b5f9e035331ff0d3923581b105c09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1a5a15bdd2cc93412da4da8a7aae2c7/" rel="bookmark">
			react-redux 详解 redux-promise
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景 某个组件的状态，需要共享某个状态需要在任何地方都可以拿到一个组件需要改变全局状态一个组件需要改变另一个组件的状态 设计思想 Web 应用是一个状态机，视图与状态是一一对应的；所有的状态，保存在一个对象里面。 基本原则 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象编写 reducers为了描述 action 如何改变 state tree 基本概念 Store （1）定义：用于存储整个应用的 state 数据的唯一容器
（2）使用：
① 新建文件夹 store，再添加 index.js,， 内容如下：
import { legacy_createStore as createStore, combineReducers} from 'redux' import countReducer from "./reducer/countReducer" import listReducer from "./reducer/listReducer" import objReducer from './reducer/objReducer'; export default createStore(combineReducers({ countReducer, listReducer, objReducer })); createStore函数接受纯函数作为参数，返回新生成的 Store 对象；
combineReducers 将多个 reducer （处理不同数据时，需要抽离多个reducer）合并成为一个；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1a5a15bdd2cc93412da4da8a7aae2c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f514564040250e03fa57131506766e1/" rel="bookmark">
			Pytorch深度学习—FashionMNIST数据集训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 FashionMNIST数据集需求库导入、数据迭代器生成设备选择样例图片展示日志写入评估—计数器模型构建训练函数整体代码训练过程日志 FashionMNIST数据集 FashionMNIST（时尚 MNIST）是一个用于图像分类的数据集，旨在替代传统的手写数字MNIST数据集。它由 Zalando Research 创建，适用于深度学习和计算机视觉的实验。 FashionMNIST 包含 10 个类别，分别对应不同的时尚物品。这些类别包括 T恤/上衣、裤子、套头衫、裙子、外套、凉鞋、衬衫、运动鞋、包和踝靴。每个类别有 6,000 张训练图像和 1,000 张测试图像，总计 70,000 张图像。每张图像的尺寸为 28x28 像素，与MNIST数据集相同。数据集中的每个图像都是灰度图像，像素值在0到255之间。
需求库导入、数据迭代器生成 import os import random import numpy as np import datetime import torch import torch.nn as nn from torch.utils.data import DataLoader import torchvision from torchvision import transforms import argparse from tqdm import tqdm import matplotlib.pyplot as plt from torch.utils.tensorboard import SummaryWriter def _load_data(): """download the data, and generate the dataloader"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f514564040250e03fa57131506766e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2854d59b8e8fc1bcc7d0cdc534be2b58/" rel="bookmark">
			学生英语题python代码解片段，给出单词，按字母表顺序列出字母顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给出某一个单词，按字母表顺序列出字母顺序
代码 python ：
# data = ['b', 'o', 'd', 'y'] # data = ['f', 'a', 'c', 'e'] # data = ['w', 'a', 's', 'h'] # data = ['T', 'O', 'U', 'C', 'H'] # data = ['G', 'A', 'M', 'E'] data = ['F', 'R', 'I', 'E', 'N', 'D'] print(sorted(data)) # 输出: # ['D', 'E', 'F', 'I', 'N', 'R'] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76267ded95f1d10410a668fcb2ea9b9b/" rel="bookmark">
			全面分析Vision Transformer如何work的、优势（从低层原理角度）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文链接：https://arxiv.org/abs/2202.06709
代码链接：https://github.com/xxxnell/how-do-vits-work
读论文有感，总结一下，
经典好文，因为面试被问到Transformer在CV领域大放光彩，跟卷积比，他的优势具体在哪儿，为什么在大数据集上表现很好。
摘要：
近来一段时间，有关视觉ViT的工作层出不穷，目前计算机视觉社区大多将ViT的成功归结于多头自注意力技术（MSA）。此外很多工作对MSA工作原理的分析停留在其具有弱归纳偏置（weak inductive bias）和长距离依赖捕捉（long-range dependency）的能力。
&amp; 所谓归纳偏置，其实是性质或者属性的意思，比如说卷积，他在视觉任务上非常成功，依赖于它本身内置的两个归纳偏置：权重共享和局部相关，可以高效的去学习，自身具有的功能，不需要再去学习，所以模型从更少的数据上就能表现得很好，但是当存在大量数据时，这些归纳偏置可能会限制模型；而Transformer具有弱归纳偏置，说明在小数据集下是存在限制的，所以就需要大数据集去学习，性能往往优于CNN。 本文是一篇刚刚被ICLR2022接受的文章，对视觉Transformer的低层原理进行了全面分析，具体总结了MSA和ViT的三大特性：
1、MSA提高了网络的精度，但是这种改善主要归因于训练数据的特异性（data specificity），而不是长距离依赖性；
2、MSA与卷积Conv呈现两种不同的操作形式，MSA是低通滤波器，而Conv是高通滤波器。二者是共为互补的；
3、MSA在模型特征融合阶段扮演了非常重要的角色，基于此，作者提出了一种新网络AlterNet，将每个stage末尾的Conv块替换成了MSA。AlterNet在大中小型数据集上的性能表现都超过了单纯的CNN模型和ViT模型。
一、引言 从CNN的角度来看，MSA可以看成是一种特殊的卷积变换，它作用在整个feature map上，具有大尺寸的核参数，因此MSA应该具有卷积操作的基础能力。但是MSA的长距离依赖建模能力对于模型预测性能的提升，本文作者提出了反对意见，作者认为给予模型适当的距离约束可以帮助模型学习更鲁棒的表示。因此作者针对卷积和Transformer提出三个核心问题：
1、我们需要MSA中的哪些属性来更好的优化网络，MSA的长期依赖建模到底对模型优化起到了怎样的作用？
2、MSA的操作与Conv有何不同？
3、如何协调使用MSA和Conv才能更好的发挥它们各自的优势？
二、分析 问题一：我们需要MSA中的哪些属性来更好的优化网络，MSA的长期依赖建模到底对模型优化起到了怎样的作用？
MSA的本质是广义空间平滑操作，其本身的弱归纳偏置会扰乱神经网络的训练。MSA的一个关键特性是数据特异性，而不是长距离依赖。MSA之所以能提升模型的整体性能，是因为它使损失平面变得扁平化，这有助于ViT的训练。下图展示了ViT和ResNet损失函数的平面示意图，如图所示，损失平面越平坦，模型的性能和泛化能力越好。
但是另一方面，MSA允许模型在接触数据时使用负Hessian特征值，这意味着MSA的损失函数是非凸的，这种这种非凸性在一般情况下会干扰神经网络的优化。这一说法也可以通过上图（c）进行证实，图（c）提供了模型训练阶段的Top-5 Hessian特征值密度，batchsize为16，可以看出，ViT具有非常多的负Hessian特征值，而ResNet只有少数，这种损失优化情况会扰乱网络的优化，尤其是在训练的早期阶段。但是在数据量非常大的情况下，这个缺陷会消失，图（a）通过使用滤波器归一化方法可视化得到的损失函数平面，表明ViT的平面相比ResNet更加平坦，这种趋势在边界区域更加明显。同样，在图（b）中展示着ResNet遵循不规则的优化轨迹，而ViT逐渐沿着平滑的轨迹收敛到最优值，这也说明了为什么ViT在大数据集上表现的比CNN好。
&amp; Hessian矩阵：它的特征值就是形容其在该点附近特征向量方向的凹凸性，特征值越大，凸性越强。你可以把函数想想成一个小山坡，陡的那面是特征值大的方向，平缓的是特征值小的方向。而凸性和优化方法的收敛速度有关，比如梯度下降。如果正定Hessian矩阵的特征值都差不多，那么梯度下降的收敛速度越快，反之如果其特征值相差很大，那么收敛速度越慢。 问题二：MSA与Conv有何不同？
论文中说MSA和Conv的操作基本上呈现相反的效应，其中MSA是低通滤波器，而Conv是高通滤波器，MSA在空间上平滑了具有更高自注意力值的特征图区域，因此，其倾向于减少高频信号。为了支持这一论点，作者对MSA和Conv的特征图进行了傅立叶分析，结果如下图所示：
其中图（a）的相对对数幅度表明，ViT倾向于减少高频信号，而ResNet会放大。图（b）展示了基于频率计算得到的随机噪声对模型准确率的影响程度，可以看到ResNet非常容易受到高频噪声的影响，而ViT对高频噪声具有一定的鲁棒性，因此将二者结合可以有效提升整体性能。
此外，作者还分析了二者在特征融合方面的差异，作者认为MSA操作可以有效的对不同层次的特征进行聚合，但是Conv不能。这是因为MSA具有平均化特征图的操作，这会减少特征图点之间的方差，进而对特征图进行集成，为了证明这一论点，作者做实验对ResNet和ViT的特征图的方差进行计算，实验结果如下图所示：
从图中可以看出，MSA倾向于减少方差，相反，ResNet中的Conv和ViT中的MLP会增大方差。此外作者还观察到了两个特征图的方差演化模式：
1、随着网络层数的深入，方差会先在每个层中累积，随着深度的增加而增大；
2、在ResNet中，特征图方差在每个stage结束时达到峰值，因此可以通过在ResNet每个阶段的末尾插入一个MSA来提高ResNet的特征聚合能力。
这一点很重要，在后期模型改进的时候可以参考这一点，涨点明显哦！
问题三：如何协调使用MSA和Conv才能更好的发挥它们各自的优势？
作者在问题二中认为MSA可以和卷积互补，，因此在问题三中，作者提出了一种设计规范来将MSA和Conv进行组合，称为AlterNet，下图展示了AlterNet与其他两种组合形式的对比。
作者假设MSA放置在网络stage结束的位置可以显著提升性能，而不是放置在整个模型的末尾。
作者提出的MSA和Conv交替模式的设计规范如下：
1、在baseline CNN模型的末尾使用MSA替换Conv块；
2、如果添加的MSA块不能提高预测性能，就将之前stage末尾的Conv块继续替换为MSA块；
3、越在后stage的MSA块，给定的head参数和隐藏层维度应该越大。
在原ResNet-50结构基础上做了改进，第2个stage上第4个卷积块替换成MSA模块，第3个stage上最后一个卷积块替换成MSA模块，第4个stage上最后一个卷积块后添加一个MSA模块。
下图展示了改进后的ResNet-50模型与它基线模型在CIFAR-100的准确性和鲁棒性，由于CIFAR是一个小型数据集，因此CNN模型由于ViT模型，但是本文改进的模型在小数据集上的性能也优于CNN，这表明MSA操作可以对Conv操作进行补充和增强。
三、总结 MSA操作不仅仅是广义的Conv操作，它还起到补充原有的Conv的广义空间平滑功能，除此之外，MSA通过集成特征图和平滑损失平面来帮助神经网络学习更加鲁棒的特征表示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3732df0cfdc27e1da9a5b57f943b06d2/" rel="bookmark">
			matlab绘制尖角colorbar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab代码 cmap = [69 117 180 116 173 203 171 217 233 254 224 144 253 174 77 244 109 67 215 48 39 165 0 38]/255; %画图的部分代码 figure set(gcf,'outerposition',get(0,'screensize')) ax = axes('Position',[0.2 0.2 0.6 0.6]); % pos需要自己设置位置 h = colorbar; % colormap(ax,cmap) map = colormap(jet); colorbar_arrow(map,1,get(h,'position'),0.03) xmin = -15; xmax = 25; caxis([xmin xmax]); % % % 绘制带尖角的colorbar % x y % 宽度 高度 % 尖角的长度 % 尖角的拐点 x = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3732df0cfdc27e1da9a5b57f943b06d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/787216d8dbaa42f9e10c52a1ec9bb2e9/" rel="bookmark">
			Windows网络管理及诊断命令整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
traceroute：
ping：
pathping:
netstat:
ipconfig：
nslookup：
route：
ARP:
FTP:
netsh：
nbtstat：
sniffer(嗅探器)：
winipcfg：
traceroute： 用于路由跟踪,返回结果第一跳为网关IP地址。
原理：递增TTL字段的ICMP回送错误报文
ping： 基于ICMP协议，检查网络连通性
-t：持续ping,直到Ctrl+C中断
-a：将IP解析为主机名
-n Count：设置ping包个数
pathping: 结合了ping和traceroute功能，可以显示通信线路上每个子网的延时和丢包率。
-g host-list:与主机列表一起的松散源路由。
-h maximum hops:指定搜索目标路径中的节点最大数。默认值为30个节点
-i address:使用指定的源地址。
-n:禁止将中间路由器的IP地址解析为名字，可以提高 pathping 显示速度
-p period:两次 Ping之间等待的时间(以毫秒为单位，默认值为250毫秒)。
-q num_queries: 指定发送到路径中每个路由器的回响请求消息数。默认值为100查询
-w timeout:指定等待每个应答的时间(单位为毫秒，默认值为3000 毫秒)。
-4：强制使用 IPv4;
-6：强制使用 IPv6
targetname:指定目的端，它既可以是IP地址，也可以是计算机名。pathping 参数区分大小写。实际使用中要注意，为了避免网络拥塞、影响正在运行的网络业务，应以足够慢的速度发送 ping信号。
netstat: netstat 基本命令格式:netstat[-a][-e][-n][-o][-pproto][-r][-s][-v][interval]
-a:显示所有连接和监听端口。
-e: 用于显示关于以太网的统计数据。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量。这些统计数据既有发送的数据报数量，也有接收的数据报数量。此选项可以与 -s 选项组合使用。
-n:以数字形式显示地址和端口号。
-o:显示与每个连接相关的所属进程ID。
-p proto:显示 proto指定的协议的连接:proto 可以是下列协议之-: TCPUDP、TCPV6或UDPv6。如果与-s 选项一起使用，可以显示按协议统计信息。
-r:显示路由表，与route print 显示效果一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/787216d8dbaa42f9e10c52a1ec9bb2e9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/40/">«</a>
	<span class="pagination__item pagination__item--current">41/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/42/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>