<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5f2156b73b7a866d7ba8075afa53c13/" rel="bookmark">
			图片懒加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;div&gt; &lt;img src="1.png" data-src='http://img07.tooopen.com/images/20170316/tooopen_sy_201956178977.jpg'&gt; &lt;/div&gt; &lt;div&gt; &lt;img src="1.png" data-src='http://img07.tooopen.com/images/20170316/tooopen_sy_201956178977.jpg'&gt; &lt;/div&gt; &lt;div&gt; &lt;img src="1.png" data-src='http://img07.tooopen.com/images/20170316/tooopen_sy_201956178977.jpg'&gt; &lt;/div&gt; &lt;div&gt; &lt;img src="1.png" data-src='http://img07.tooopen.com/images/20170316/tooopen_sy_201956178977.jpg'&gt; &lt;/div&gt;&lt;div&gt; &lt;img src="1.png" data-src='http://img07.tooopen.com/images/20170316/tooopen_sy_201956178977.jpg'&gt; &lt;/div&gt; &lt;div&gt; &lt;img src="1.png" data-src='http://img07.tooopen.com/images/20170316/tooopen_sy_201956178977.jpg'&gt; &lt;/div&gt; &lt;div&gt; &lt;img src="1.png" data-src='http://img07.tooopen.com/images/20170316/tooopen_sy_201956178977.jpg'&gt; &lt;/div&gt; &lt;div&gt; &lt;img src="1.png" data-src='http://img07.tooopen.com/images/20170316/tooopen_sy_201956178977.jpg'&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var img = document.querySelectorAll('img'); var imgs = Array.from(img); imgs.forEach(function(item,index){ if(item.offsetTop&lt;window.innerHeight){ item.src = item.dataset.src; } }) window.onscroll=function(){ imgs.forEach(function(item,index){ let height = window.getComputedStyle(imgs[0],null).getPropertyValue('height').replace('px',''); if(item.offsetTop&lt;(window.pageYOffset+window.innerHeight-200)){ //(item.offsetTop+height)&gt;window.pageYOffset&amp;&amp; item.src = item.dataset.src; }else{ item.src='1.png' } }) } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09317a9aba22b3ae9f6308596d52904a/" rel="bookmark">
			gets()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gets()和puts()函数：gets()函数的简单易用，它读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个C字符串.它通常与puts函数配对使用，该函数用于显示字符串，并在末尾添加换行符。 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define STLEN 81 int main() { char words[STLEN]; puts("enter a string,please"); gets(words); printf("Your string twice :\n"); puts(words); puts("Done"); return 0; } 该函数在运行时会产生warning:this program uses gets(),which is unsafe;问题出在他唯一的参数words，它无法检查数组是否装得下输入行。数组名会被转换成该数组手元素的地址，因此，get()函数只知道数组的开始出，并不知道数组中有多少个元素；如果输入的字符过长，会导致缓冲区溢出，即多余的字符超出了指定得目标空间，如果这些多余的字符串只是占用了尚未使用的内存，就不会立即出现问题；如果他们擦写掉程序中的其他数据，会导致程序异常中止；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff1ac8081abbb334bf1621aa85416360/" rel="bookmark">
			PyQt5基本控件详解之QLineEdit（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QLineEdit QLineEdit类中常用的方法如下表
方法描述setAlignment()按固定值方式对齐文本Qt.AlignLeft：水平方向靠左对齐Qt.AlignRight:水平方向靠右对齐Qt.AlignCenter：水平方向居中对齐Qt.AlignJustify：水平方向调整间距两端对齐Qt.AlignTop：垂直方向靠上对齐Qt.AlignBottom：垂直方向靠下对齐Qt.AlignVCenter：垂直方向居中对齐setEchoMode()设置文本框的显示格式，允许输入的文本显示格式的值可以是：QLineEdit.Normal：正常显示所输入的字符，此为默认选项QLineEdit.NoEcho：不显示任何输入的字符，常用于密码类型的输入，且长度保密QLineEdit.Password：显示与平台相关的密码掩饰字符，而不是实际输入的字符QLineEdit.PasswordEchoOnEdit：在编辑时显示字符，负责显示密码类型的输入setPlaceholderText()设置文本框显示文字setMaxLength()设置文本框所允许输入的最大字符数setReadOnly()设置文本为只读setText()设置文本框的内容text()返回文本框的内容setDragEnable()设置文本框是否接受拖动selectAll()全选setFocus()得到焦点setInputMask()设置掩码setValidator()设置文本框的验证器（验证规则），将限制任意可能输入的文本，可用的校验器为QIntValidator:限制输入整数QDoubleValidator:限制输入浮点数QRegexpValidator:检查输入是否符合正则表达式 QLineEdit类中常用信号如下
信号描述selectionChanged只要选择改变了，这个信号就会发射textChanged当修改文本内容时，这个信号就会发射editingFinished当编辑文本结束时，这个信号就会发射 定义输入掩码的字符 下表列出了输入掩码的占位符和字面字符，并说明其如何控制数据输入
字符含义AASCII字母字符是必须输入的（A-Z，a-z）aASCII字母字符是允许输入的，但不是必须输入的NASCII字母字符是必须输入的（A-Z，a-z，0-9）nASCII字母字符是允许输入的，但不是必须输入的X任何字符都是必须输入x任何字符都是允许输入的，但不是必须输入的9ASCII数字字符是必须输入的（0-9）0ASCII数字字符是允许输入的，但不是必须输入的DASCII数字字符是必须输入的（1-9）dASCII数字字符是允许输入的，但不是必须的（1-9）#ASCII数字字符与加减字符是允许输入的，但不是必须的H十六进制格式字符是必须输入的（A-F，a-f，0-9）h十六进制格式字符允许输入，但不是必须的B二进制格式字符是必须输入的（0,1）b二进制格式字符是允许输入的，但不是必须的&gt;所有字母字符都大写&lt;所有字母字符都小写！关闭大小写转换\使用‘\’转义上面列出的字符 掩码由掩码字符与分隔符字符串组成，后面可以跟一个分号和空白字符，空白字符在编辑后会从文本删除的 掩码示例如下：
掩码注意事项000.000.000.000;_ip地址，空白字符是‘_’HH:HH:HH:HH:HH:HH;MAC地址0000-00-00日期，空白字符是空格&gt;AAAAA-AAAAA-AAAAA-AAAAA-AAAAA;#许可证号，空白字符是‘_’，所有字母都转换为大写 ————————————————————————————————————————————
实例一：EchoMode的显示效果 from PyQt5.QtWidgets import QApplication,QLineEdit,QWidget,QFormLayout import sys class lineEditDemo(QWidget): def __init__(self,parent=None): super(lineEditDemo, self).__init__(parent) self.setWindowTitle('QLineEdit例子') #实例化表单布局 flo=QFormLayout() #创建4个文本输入框 PNormalLineEdit=QLineEdit() pNoEchoLineEdit=QLineEdit() pPasswordListEdit=QLineEdit() pPasswordEchoOnEditLineEdit=QLineEdit() #添加到表单布局中 #flo.addRow(文本名称（可以自定义），文本框) flo.addRow('Normal',PNormalLineEdit) flo.addRow('NoEcho', pNoEchoLineEdit) flo.addRow('Password', pPasswordListEdit) flo.addRow('PasswordEchoOnEdit', pPasswordEchoOnEditLineEdit) #设置setPlaceholderText()文本框浮现的文字 PNormalLineEdit.setPlaceholderText('Normal') pNoEchoLineEdit.setPlaceholderText('NoEcho') pPasswordListEdit.setPlaceholderText('Password') pPasswordEchoOnEditLineEdit.setPlaceholderText('PasswordEchoOnEdit') #setEchoMode()：设置显示效果 #QLineEdit.Normal：正常显示所输入的字符，此为默认选项 PNormalLineEdit.setEchoMode(QLineEdit.Normal) #QLineEdit.NoEcho：不显示任何输入的字符，常用于密码类型的输入，且长度保密 pNoEchoLineEdit.setEchoMode(QLineEdit.NoEcho) #QLineEdit.Password：显示与平台相关的密码掩饰字符，而不是实际输入的字符 pPasswordListEdit.setEchoMode(QLineEdit.Password) #QLineEdit.PasswordEchoOnEdit：在编辑时显示字符，负责显示密码类型的输入 pPasswordEchoOnEditLineEdit.setEchoMode(QLineEdit.PasswordEchoOnEdit) #设置窗口的布局 self.setLayout(flo) if __name__ == '__main__': app=QApplication(sys.argv) win=lineEditDemo() win.show() sys.exit(app.exec_()) 效果如下 实例二：验证器 #导入，Qapplication，单行文本框，窗口，表单布局 from PyQt5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff1ac8081abbb334bf1621aa85416360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3cd11a4fa6cb869736e5b3c5252120/" rel="bookmark">
			LeNet详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeNet-5是一个较简单的卷积神经网络。下图显示了其结构：输入的二维图像，先经过两次卷积层到池化层，再经过全连接层，最后使用softmax分类作为输出层。关于CNN参见：https://blog.csdn.net/qq_42570457/article/details/81458077
LeNet-5 这个网络虽然很小，但是它包含了深度学习的基本模块：卷积层，池化层，全连接层。是其他深度学习模型的基础， 这里我们对LeNet-5进行深入分析。同时，通过实例分析，加深对与卷积层和池化层的理解。
LeNet-5共有7层，不包含输入，每层都包含可训练参数；每个层有多个Feature Map，每个FeatureMap通过一种卷积滤波器提取输入的一种特征，然后每个FeatureMap有多个神经元。
各层参数详解：
1、INPUT层-输入层 首先是数据 INPUT 层，输入图像的尺寸统一归一化为32*32。
注意：本层不算LeNet-5的网络结构，传统上，不将输入层视为网络层次结构之一。
2、C1层-卷积层 输入图片：32*32
卷积核大小：5*5
卷积核种类：6
输出featuremap大小：28*28 （32-5+1）=28
神经元数量：28*28*6
可训练参数：（5*5+1) * 6（每个滤波器5*5=25个unit参数和一个bias参数，一共6个滤波器）
连接数：（5*5+1）*6*28*28=122304
详细说明：对输入图像进行第一次卷积运算（使用 6 个大小为 5*5 的卷积核），得到6个C1特征图（6个大小为28*28的 feature maps, 32-5+1=28）。我们再来看看需要多少个参数，卷积核的大小为5*5，总共就有6*（5*5+1）=156个参数，其中+1是表示一个核有一个bias。对于卷积层C1，C1内的每个像素都与输入图像中的5*5个像素和1个bias有连接，所以总共有156*28*28=122304个连接（connection）。有122304个连接，但是我们只需要学习156个参数，主要是通过权值共享实现的。
3、S2层-池化层（下采样层） 输入：28*28
采样区域：2*2
采样方式：4个输入相加，乘以一个可训练参数，再加上一个可训练偏置。结果通过sigmoid
采样种类：6
输出featureMap大小：14*14（28/2）
神经元数量：14*14*6
可训练参数：2*6（和的权+偏置）
连接数：（2*2+1）*6*14*14
S2中每个特征图的大小是C1中特征图大小的1/4。
详细说明：第一次卷积之后紧接着就是池化运算，使用 2*2核 进行池化，于是得到了S2，6个14*14的 特征图（28/2=14）。S2这个pooling层是对C1中的2*2区域内的像素求和乘以一个权值系数再加上一个偏置，然后将这个结果再做一次映射。于是每个池化核有两个训练参数，所以共有2x6=12个训练参数，但是有5x14x14x6=5880个连接。
4、C3层-卷积层 输入：S2中所有6个或者几个特征map组合
卷积核大小：5*5
卷积核种类：16
输出featureMap大小：10*10 (14-5+1)=10
C3中的每个特征map是连接到S2中的所有6个或者几个特征map的，表示本层的特征map是上一层提取到的特征map的不同组合。
存在的一个方式是：C3的前6个特征图以S2中3个相邻的特征图子集为输入。接下来6个特征图以S2中4个相邻特征图子集为输入。然后的3个以不相邻的4个特征图子集为输入。最后一个将S2中所有特征图为输入。则：可训练参数：6*(3*5*5+1)+6*(4*5*5+1)+3*(4*5*5+1)+1*(6*5*5+1)=1516
连接数：10*10*1516=151600
详细说明：第一次池化之后是第二次卷积，第二次卷积的输出是C3，16个10x10的特征图，卷积核大小是 5*5. 我们知道S2 有6个 14*14 的特征图，怎么从6 个特征图得到 16个特征图了？ 这里是通过对S2 的特征图特殊组合计算得到的16个特征图。具体如下：
C3的前6个feature map（对应上图第一个红框的6列）与S2层相连的3个feature map相连接（上图第一个红框），后面6个feature map与S2层相连的4个feature map相连接（上图第二个红框），后面3个feature map与S2层部分不相连的4个feature map相连接，最后一个与S2层的所有feature map相连。卷积核大小依然为5*5，所以总共有6*(3*5*5+1)+6*(4*5*5+1)+3*(4*5*5+1)+1*(6*5*5+1)=1516个参数。而图像大小为10*10，所以共有151600个连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef3cd11a4fa6cb869736e5b3c5252120/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4ac8c906be6012fdaaf4fa5534140f/" rel="bookmark">
			ubuntu 虚拟机设置root密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于ubuntu虚拟机安装之后忘记（不知道）root密码的解决方法 在vmware安装的ubuntu虚拟机，安装过程没有输入过root密码，导致进入系统后不知道root密码是什么。其实这是ubuntu系统处于安全性的考虑，屏蔽了用户在安装过程设置root密码，解决方法如下：
打开终端输入：sudo passwd
Password: &lt;--- 输入你当前用户的密码
Enter new UNIX password: &lt;--- 新的Root用户密码
Retype new UNIX password: &lt;--- 重复新的Root用户密码
passwd：password updated successfully
成功之后 su - root
输入刚刚设置的root密码后，即可成功切换到root用户。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac73077f6d8bf616e0f62ac675991bed/" rel="bookmark">
			ajax的success函数获取不到返回的值（或者返回的json带有K_BackingField）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先看下我们的ajax： $.ajax({ url: "Handler/GetUsers.ashx",//路径 type: "get",//get请求 data: { "LoginName": "Admin" }, dataType:"json", async: false,//同步 cache: false,//不缓存 //成功调用的函数 success: function (datas) { alert(datas); //这里如果返回{object:object} alert(datas.LoginName);//而这里在f12调式工具中提示错误,或者为undefined,并且LoginName并没有写错 }, //发生错误调用的函数 error: function (errmsg) { alert("发生错误！"); } }); 接下来看我们的ashx(一般处理程序) public void ProcessRequest (HttpContext context) { context.Response.ContentType = "text/plain"; string LoginName = context.Request.Params["LoginName"]; Users model = new TestService().GetList_Users(LoginName); DataContractJsonSerializer ds = new DataContractJsonSerializer(typeof(Users)); ds.WriteObject(context.Response.OutputStream, model); } 我们用的是DataContractJsonSerializer这个类去序列化成json,并返回值
(注意：用DataContractJsonSerializer需引用命名空间 System.Runtime.Serialization.Json;)
接下来我们看看我们ajax获取到的datas是什么？ 运行vs，等执行了ajax并且返回了值我们按f12进入tiao调试者工具。找到Network这个选项点击
找到对应的ashx,你会发现我们的键值中的键跟我们model中的不一样,多出来K_BackingField这一项.
这是怎么回事呢？那是因为我们序列化的这个类中被我们加上了[Serializable]这个特性，我们只用这样写就可以正常获取了
[Serializable] [DataContract] public class Users { [DataMember] public int Uid {get;set;}//Id [DataMember] public string LoginName {get;set;}//登陆账号 [DataMember] public string LoginPwd {get;set;}//登陆密码 [DataMember] public int Rid {get;set;}//角色id [DataMember] public int EId { get; set; }//员工id } 在类加上一个[DataContract]这个特性,下面的列也要加上[DataMember]这个特性，这样我们获取的json就不会出现K_BackingField了。注意 需引用命名空间using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac73077f6d8bf616e0f62ac675991bed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa598272677a6970c0463fc7a7be18b/" rel="bookmark">
			jpg转svg文字路径动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近对svg动画很感兴趣，用svg+css可以实现一些让人眼前一亮的效果，Ant Design 官网首屏就出现了svg动画，coding 官网首页也出现svg动画，也许在非前端人员看来效果很普通，但是在前端开发人员眼里，这种效果低调而又张扬！这是用jq animate做不到的。
能做成Ant Design那样的动画效果是我的目标，我想先做个简单点的效果，譬如这样的文字描边动画效果
怎么做的呢？
这张jpg是我的头像，最终呈现的效果就是以这张图为基础。
首先要在PS中将图的选区转换成路径
再将带路径的ps文件导出到Ai
需要注意的是，第二个字母的路径由两部分组成，外层一个大选区，里面一个小的选区，这里要选“窗口”→“路径查找器”，形状模式选“差集”。
保存成svg格式，得到了代码：
&lt;svg version="1.1" id="图层_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 215 215" style="enable-background:new 0 0 215 215;" xml:space="preserve"&gt; &lt;style type="text/css"&gt; .st0{fill-rule:evenodd;clip-rule:evenodd;fill:#30479B;} &lt;/style&gt; &lt;g&gt; &lt;path class="st0" d="M197,101c-7.9,2.1-13.8,8.2-25,5c-1.3-7.7-2.7-15.3-4-23c2.3-2.3,4.7-4.7,7-7c5.5-1.6,11.3-3.4,15,1 c4.5-1.4,3.6-0.5,5-5c-3.7-1.7-7.3-3.3-11-5c-10.1,4.6-14.5,6.3-22,12c1.3,9.7,2.7,19.3,4,29c3.8,6.1,18.2,5.6,26,3 c4.1-2,5-3.9,7-8C198.3,102.3,197.7,101.7,197,101z"/&gt; &lt;path class="st0" d="M144,73c-1.3,0-2.7,0-4,0c-2.3,1-4.7,2-7,3c1.3,5.3,2.7,10.7,4,16c3.3-1,6.7-2,10-3 C148.1,83.3,145.3,79.1,144,73z"/&gt; &lt;path class="st0" d="M126,84c-10,0-20,0-30,0c1.3,14,2.7,28,4,42c2,0,4,0,6,0c-1-11.3-2-22.7-3-34c0.7-0.3,1.3-0.7,2-1 c5.3,0,10.7,0,16,0c3,10,6,20,9,30c1.2,3.1,2,1.2,6,1c-3.3-12-6.7-24-10-36C126,85.3,126,84.7,126,84z"/&gt; &lt;path class="st0" d="M18,97c0.3,4.7,0.7,9.3,1,14c9,0.7,18,1.3,27,2c0.3,3,0.7,6,1,9c-7.7,0-15.3,0-23,0c0,1.7,0,3.3,0,5 c5,0.7,10,1.3,15,2c4.3,0,8.7,0,13,0c0.7-6.3,1.3-12.7,2-19c-4.2-4-20.4-4.2-28-4c-0.3-2.3-0.7-4.7-1-7c7.8-5.5,19.4-2.3,29-5 c0.7,0,1.3,0,2,0c0-2,0-4,0-6C34.4,87.6,30.9,88,18,97z"/&gt; &lt;path class="st0" d="M146,96c-1.7,0.7-3.3,1.3-5,2c-2.1,11.1,6.7,23,9,34c3.4,0.8,5.1,0.7,8-1c1-0.3,2-0.7,3-1 c-3.3-11.3-6.7-22.7-10-34C149.3,96,147.7,96,146,96z"/&gt; &lt;path class="st0" d="M57,122c2.7,8.7,5.3,17.3,8,26c9.5,1.9,19.2-5.2,28-8c1.2-5.9-0.6-23.6-5-29C77.7,114.7,67.3,118.3,57,122z M70,141c-1.7-4.3-3.3-8.7-5-13c5.7-2.7,11.3-5.3,17-8c2.5,2.4,2.9,5,4,9C85.8,138.6,78.7,140.6,70,141z"/&gt; &lt;/g&gt; &lt;/svg&gt; 将css修改一下
.st0{fill: none; stroke-width:2; stroke:#30479B; stroke-linejoin:round; stroke-linecap:round; stroke-dasharray: 250, 250; animation: lineMove 5s ease-out infinite; } @keyframes lineMove { 0%{ stroke-dasharray: 0, 250; } 100%{ stroke-dasharray: 250, 250; } } 关于svg和css相结合，以本示例为参考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aa598272677a6970c0463fc7a7be18b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aba03dda4063bc017a4103fc646c6669/" rel="bookmark">
			Sqlmap 使用方法小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平常的使用GET方法像–tables –columns -T -D –dbs –dump 啥的就不说了，只是博客几天不发，空着不好，还是得写写东西
--is-dba 当前用户权限（是否为root权限，mssql下最高权限为sa） --dbs 所有数据库 --current-db 网站当前数据库 --users 所有数据库用户 --current-user 当前数据库用户 --random-agent 构造随机user-agent --passwords 数据库密码 --proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理 --time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒 --threads= 使用多少线程 --is-dba 这个命令有时候决定了你是否可以在服务器下进行写的操作，这个很重要，是否有写的权限，代表你是否可以在服务器上面写入一句话木马
利用sqlmap进行POST注入 先利用bp去抓一个包，直接发送包里面的内容保存到一个文件里面，然后用-r参数去实现它就好 例如 sqlmap -r “c:\tools\request.txt” -p “username” –dbms mysql 指定username参数，-dbms指定了某种数据库，这句话指定的是mysql数据库，-p指定的是参数，不指定的话每一个参数他都会尝试 注意这句话已经不像平常那样需要-u参数了，直接-r参数即可，因为报文里面已经含有了含有应有的各种条件
利用sqlmap进行需要登陆的注入 可以跟上面进行post注入的一样，直接-r参数带上你的抓包文件路径，既然是需要登录的注入，那么报文里面肯定是要有cookie的 我们还可以利用–cookie参数注入，例如: sqlmap.py -u "http://10.1.1.136/vulnerabilities/sqli/?id=1&amp; Submit=Submit" --cookie="PHPSESSID=q3bm4gupu58dqptm0lve1o12u4; security=low" --current-db 这里面的cookie参数可以抓包获得
利用sqlmap进行交互式写shell 这个要利用sqlmap写shell的话前提需要获取网站的绝对路径，而且必须叙是root权限
使用burpsuite进行抓包，获取cookie。判断用户是否为dba，输入命令：
sqlmap.py -u "http://10.1.1.136/vulnerabilities/sqli/?id=1&amp;Submit=Submit" --cookie="PHPSESSID=q3bm4gupu58dqptm0lve1o12u4; security=low" --is-dba 输入命令：
sqlmap.py -u "http://10.1.1.136/vulnerabilities/sqli/?id=1&amp;Submit=Submit" --cookie="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aba03dda4063bc017a4103fc646c6669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e14698897cf0fad0c4d2ea9b2fcd5a3d/" rel="bookmark">
			CentOS 7系统离线安装gcc，gcc-c&#43;&#43;，让你摆脱联网装不了的困惑！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的就是CentOs7系统，需要装一个Nginx服务器的时候，死活都装不上运行环境gcc，gcc-c++，一直纠结了几天，后来我睡觉的时候突然一个灵感来了，就继续查资料，如果缺少依赖包，那么就去装依赖包，手动安装或者离线安装都可以。
第二天上班的时候我就开始查网上查资料，果然有这种解决办法，并且还有各个依赖包都抽离出来了，感谢各位大佬的分享，我写这个不是为了宣传什么，我就是一个小人物，我想把我的经验分享大家，让大家以后少走弯路！
一、首先，你要下载一个CentOS7的系统镜像（https://www.centos.org/download/）
二、然后解压ISO镜像，去里面找gcc，gcc-c++缺少的安装包，放在你CentOS 7的系统里面自己新建一个文件夹
三、前期工作都准备好了，那我们开始动手吧，skr！嘿嘿嘿
1.首先安装的时候，我们要切换root账户，不要用普通账户，不然它会报没有权限！
2.然后将你导入CentOS 7系统目录里面的rpm安装包逐一安装，但是我是统一安装的，在终端里面输入：
rpm -Uvh *.rpm --nodeps --force
3.安装完之后我们要去验证下是否安装成功了吧，输入，并执行：
gcc -v；
gcc-c++ -v；
就可以查看gcc，gcc-c++编译环境的版本号了！
4.可以输入并执行以下命令，查看是否缺少gcc，gcc-c++环境安装包！
rpm -qa|grep gcc；
rpm -q gcc rpm -q gcc-c++ rpm -q make； 谢谢，综合各家所长，汇总适合自己的，并验证成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9acf3ccbc532f2c96934b49c55ef70fd/" rel="bookmark">
			SQL学习-数据库的备份和还原  分离和附加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自：https://blog.csdn.net/daodaojiejacket/article/details/45102455
数据库备份和还原的目的：
数据库备份主要是为了防止数据的丢失，或者在错误数据的出现的时候，能够将数据还原到之前的一个版本。企业经常会做一个任务，每天将数据库进行备份，这样保证了数据不会丢失。
数据库分离和附加的目的： 数据库分离简单的说就是把本地的数据库从服务器分离出来，然后拿到别的服务器上附加，即可实现数据库的转移（但我总觉得，如果不会出现数据的丢失，直接备份一份，然后过去还原就可以了，这个以后如果有新的看法再补充。
注意：备份的时候是针对School数据库进行的备份，然后还原的时候你会发现图中也是右击的School数据库，然后还原。这个的意思就是：我之前对School数据库进行了备份，然后可能过了几天我发现数据有问题，所以我就要还原到之前我备份的版本，所以我就右击了这个School数据库，针对它来还原（在还原的时候，弹出来的界面会自动在目标数据库输入框中填充School）。
（而我所谓的想要一个数据库，不通过分离附加的方式，直接备份然后还原的方式就是，你右击“数据库”（不是右击哪个数据库，是最上面的“数据库”三个字），然后选择还原数据库，然后在弹出界面就不会自动填充目标数据库，此时，你可以自己定义一个你要的名字，然后还原过来就好了，没有必要再什么分离附加，浅见，以后有新看法会补充。）
具体操作如下：
1.备份数据库
选择要备份的数据库，点击右键，找到任务中备份选项。
先点删除将默认的备份路径删除:
然后点添加按钮，添加目标备份路径:
点击红圈处，定义存储路径：
选择文件类型为所有文件：
在文件名框中输入备份的文件名：
连续点击确定显示备份完成。
还原数据库
右键要还原数据的数据库，选择任务中还原数据库：
选择源设备找到数据库备份文件的位置：
点击添加按钮，文件类型选择所有文件，然后选择还原数据库文件，点确定：
然后将用于选择的数据库还原集前打钩，点确定：
显示数据库还原成功。
2.分离数据库
选择要分离的数据库，右键选择任务中分离：
点确定按钮将数据库从服务器上分离：
在对象资源管理其中我们已经找不到school数据库，表示已分离（第一个图表示分前的资源管理器，第二个图表示分离后的资源管理器）：
点击服务器右键中的属性，查看Sql server文件的存储路径：
根目录即为sql server文件的存储地址，将地址复制到计算机中地址栏：
找到DATA文件夹
进入文件夹，找到你分离的数据库的mdf和ldf文件
将他们拷贝到U盘中，以便将其移到另一台机器上。
附加数据库
右键数据库，选择附加选项：
点击添加按钮，从文件目录中找到你要附加的数据库的mdf文件，选择后点确定：
点确定后，若对象资源管理器中出现附加的数据库表示附加成功。
请注意，此时对数据库的操作都是对你U盘中的原数据库进行操作，可以将其备份到本地以免误操作导致数据库损毁无法使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab19f83f222b6191e7061be76f98e664/" rel="bookmark">
			php  base64图片保存到服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html &lt;form enctype="multipart/form-data" id="oForm"&gt; &lt;input type="file" name="file" id="file" onchange="readAsDataURL()" /&gt; &lt;input type="button" value="提交" onclick="doUpload()" /&gt; &lt;/form&gt; &lt;div&gt; &lt;img alt="" id="img"/&gt; &lt;/div&gt; script function doUpload() { var data = $('#img').attr('src'); $.post('1.php',{data:data},function(res){ console.log(res) }); } function readAsDataURL(){ //检验是否为图像文件 var file = document.getElementById("file").files[0]; if(!/image\/\w+/.test(file.type)){ alert("看清楚，这个需要图片！"); return false; }else{ var reader = new FileReader(); //将文件以Data URL形式读入页面 reader.readAsDataURL(file); reader.onload=function(e){ var result=document.getElementById("img"); //显示文件 result.src= this.result ; } } } php $base64 = $_POST['data']; $arr = explode(',',$base64); $base64Str = $arr[1]; $ext = base64Ext($arr[0]); $file = base64_decode($base64Str); $name = time(); $r = file_put_contents('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab19f83f222b6191e7061be76f98e664/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d1f58633a36a1dc3dfd8bcc2f11262/" rel="bookmark">
			模型过拟合问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概念 过拟合就是训练出来的模型在训练集上表示很好，但在测试集上表现较差的一种现象 原因 1、数据有噪声（即不相关的干扰因素） 2、训练数据不足 3、训练模型过度导致模型非常复杂 解决方式 1、early stopping 提前结束训练，就是找到了一个点，这个点的参数精确值最高，并且在接下来的n次训练中精度都不如这个点，那么就提前结束，n的选择视情况而定 2、数据集扩增
可以在数据源获取更多数据将原本的数据复制几倍，可以加上随机噪声根据已知模型构造更多数据 3、正则化方法 结构风险最小化、模型复杂度的约束 简单来说，就是对于一个训练集我们可能会得到不止一个模型，那么在这些得到的模型中一定会有一个复杂度最小的，使用正则化方法就是尽量让得到的这个模型就是这个复杂度最小的，这样来防止过拟合的发生 常用的正则化方法：
L0范数（参数为0的个数最多时）L1正则L2正则P范数核范数无穷范数（向量元素中绝对值的最小值） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e9d1bbc000e3e4479a270cebc3e15e0/" rel="bookmark">
			你有没有遇到过改用户权限结果主用户也获取不了root权限的情况？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu系统，新建一个用户，该用户默认是没有root权限的，安装软件之类的操作很不方便，想更新一下该用户的权限。 编辑/etc/sudoers添加一句jz ALL=(ALL:ALL) ALL（新建用户的用户名是jz） 结果保存后出现
nvidia@tegra-ubuntu:~$ sudo su /etc/sudoers: syntax error near line 1 sudo: parse error in /etc/sudoers near line 1 sudo: no valid sudoers sources found, quitting sudo: unable to initialize policy plugin
凉了，主用户也用不了root权限了。 各种需要高权限的操作都没有办法进行了。怎么破？
上面的提示信息已经讲得很清楚了。在/etc/sudoers中第一行有语法错误。也就是说，改文件的时候改错了。
解决办法是 在图形界面的终端内输入命令
pkexec visudo -f /etc/sudoers 把刚刚改错的地方，也就是出现语法错误的地方，改回来。保存退出，(o゜▽゜)o☆[BINGO!]
参考：https://arstechnica.com/civis/viewtopic.php?t=1246553
注意： 一定要在图形界面的终端内操作，用ssh连接后执行相同的命令也会提示没有权限。
nvidia@tegra-ubuntu:~$ pkexec visudo ==== AUTHENTICATING FOR org.freedesktop.policykit.exec === Authentication is needed to run `/usr/sbin/visudo’ as the super user Multiple identities can be used for authentication: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e9d1bbc000e3e4479a270cebc3e15e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eaca077b7e2169db0d52955c45af331/" rel="bookmark">
			小程序毫秒级倒计时（适用于拼团秒杀功能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说直接上代码：
效果图：
index.js
Page({ /** * 页面的初始数据 */ data: { countdown:'' , endDate2: '2018-08-08 11:41:00' }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { var that = this; that.countTime() }, countTime() { var that = this; var date = new Date(); var now = date.getTime(); var endDate = new Date(that.data.endDate2);//设置截止时间 var end = endDate.getTime(); var leftTime = end - now; //时间差 var d, h, m, s, ms; if (leftTime &gt;= 0) { d = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4eaca077b7e2169db0d52955c45af331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35d61d599a07cd224598af60d64d8eb1/" rel="bookmark">
			Linux使用基本目录介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了便于Linux系统的使用，本篇博文整理自google，关于这方面的文章都很多，但很乱，在这儿花了写时间适当的进行综合整理了一下，如有不当的地方，欢迎指正！！！
Linux目录类似一个树，最顶层是其根目录，常见目录简介如下：
/bin 二进制可执行命令 /dev 设备特殊文件 /etc 系统管理和配置文件 /etc/rc.d 启动的配置文件和脚本 /home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 /lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件 /sbin 超级管理命令，这里存放的是系统管理员使用的管理程序 /tmp 公共的临时文件存储点 /root 系统管理员的主目录 /mnt 系统提供这个目录是让用户临时挂载其他的文件系统 /lost+found这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里 /proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 /var 某些大文件的溢出区，比方说各种服务的日志文件 /usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录，其中包含： /usr/x11R6 存放x window的目录 /usr/bin 众多的应用程序 /usr/sbin 超级用户的一些管理程序 /usr/doc linux文档 /usr/include linux下开发和编译应用程序所需要的头文件 /usr/lib 常用的动态链接库和软件包的配置文件 /usr/man 帮助文档 /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里 /usr/local/bin 本地增加的命令 /usr/local/lib 本地增加的库根文件系统
Linux常见目录详细介绍：
/bin目录 /bin目录包含了引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。这些命令都是二进制文件的可执行程序( bin是binary–二进制的简称)，多是系统中重要的系统文件。/sbin目录 /sbin目录类似/bin ，也用于存储二进制文件。因为其中的大部分文件多是系统管理员使用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使用。/etc目录 /etc目录存放着各种系统配置文件，其中包括了用户信息文件/etc/password，系统初始化文件/etc/rc等。linux正是这些文件才得以正常地运行。/root目录 /root 目录是超级用户的目录。/lib目录 /lib目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件。这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本，故可以使得可执行文件变得更小，节省空间。/lib/modules 目录 /lib/modules 目录包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重新引导系统所需的模块(例如网络和文件系统驱动)。/dev目录 /dev目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用户可以通过访问/dev/mouse来访问鼠标的输入，就像访问其他文件一样。/tmp目录 /tmp 目录存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用/var/tmp来代替/tmp ，因为前者可能拥有一个更大的磁盘空间。/boot目录 /boot目录存放引导加载器(bootstraploader)使用的文件，如lilo，核心映像也经常放在这里，而不是放在根目录中。但是如果有许多核心映像，这个目录就可能变得很大，这时使用单独的文件系统会更好一些。还有一点要注意的是，要确保核心映像必须在ide硬盘的前1024柱面内。/mnt目录 /mnt 目录是系统管理员临时安装(mount)文件系统的安装点。程序并不自动支持安装到/mnt 。/mnt 下面可以分为许多子目录，例如/mnt/dosa 可能是使用msdos文件系统的软驱，而/mnt/exta 可能是使用ext2文件系统的软驱，/mnt/cdrom 光驱等等。/proc,/usr,/var,/home目录 其他文件系统的安装点。 Linux 下各文件系统，详细介绍：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35d61d599a07cd224598af60d64d8eb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/794e95556fd6e151ead1d0ba5b38da57/" rel="bookmark">
			前端图片压缩上传(纯js的质量压缩，非长宽压缩)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;XMLHttpRequest上传文件&lt;/title&gt; &lt;script type="text/javascript"&gt; /* 三个参数 file：一个是文件(类型是图片格式)， w：一个是文件压缩的后宽度，宽度越小，字节越小 objDiv：一个是容器或者回调函数 photoCompress() */ function photoCompress(file,w,objDiv){ var ready=new FileReader(); /*开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容.*/ ready.readAsDataURL(file); ready.onload=function(){ var re=this.result; canvasDataURL(re,w,objDiv) } } function canvasDataURL(path, obj, callback){ var img = new Image(); img.src = path; img.onload = function(){ var that = this; // 默认按比例压缩 var w = that.width, h = that.height, scale = w / h; w = obj.width || w; h = obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/794e95556fd6e151ead1d0ba5b38da57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26af1b4c2c56012da7e4d0bde330b9b3/" rel="bookmark">
			Glide
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个图片加载库
Glide是一款由Bump Technologies开发的图片加载框架，使得我们可以在Android平台上以极度简单的方式加载和展示图片。 Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。
为什么使用Glide ？ TT5
多种图片格式的缓存，适用于更多的内容表现形式（如Gif、WebP、缩略图、Video）
生命周期集成（根据Activity或者Fragment的生命周期管理图片加载请求）
高效处理Bitmap（bitmap的复用和主动回收，减少系统回收压力）
高效的缓存策略，灵活（Picasso只会缓存原始尺寸的图片，Glide缓存的是多种规格），加载速度快且内存开销小（默认Bitmap格式的不同，使得内存开销是Picasso的一半）
（WebP（发音weppy，项目主页），是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 的测试，无损压缩后的 WebP 比 PNG 文件少了 45％ 的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少 28％的文件大小。）
Glide 的使用？
Glide.with(Context)
.load(Url)
.into(imageView);
目前，Glide最稳定版本是3.7.0 最新版本是4.2.0 使用Glide 加载一张图片
Glide.with(Context).load(Url) .into(imageView);
这一行代码进可以做非常非常多的事情了，包括加载网络上的图片、加载手机本地的图片、加载应用资源中的图片等等。
下面我们就来详细解析一下这行代码。
首先，调用Glide.with()方法用于创建一个加载图片的实例。with()方法可以接收Context、Activity或者Fragment类型的参数。也就是说我们选择的范围非常广，
不管是在Activity还是Fragment中调用with()方法，都可以直接传this。那如果调用的地方既不在Activity中也不在Fragment中，可以获取当前应用程序的ApplicationContext，
传入到with()方法当中。注意with()方法中传入的实例会决定Glide加载图片的生命周期，如果传入的是Activity或者Fragment的实例，那么当这个Activity或Fragment被销毁的时候，
图片加载也会停止。如果传入的是ApplicationContext，那么只有当应用程序被杀掉的时候，图片加载才会停止。
接下来看一下load()方法，这个方法用于指定待加载的图片资源。Glide支持加载各种各样的图片资源，包括网络图片、本地图片、应用资源、二进制流、Uri对象等等。
因此load()方法也有很多个方法重载，除了加载一个字符串网址之外，你还可以这样使用load()方法：
// 加载本地图片
File file = new File(getExternalCacheDir() + "/image.jpg");
Glide.with(this).load(file).into(imageView);
// 加载应用资源
int resource = R.drawable.image;
Glide.with(this).load(resource).into(imageView);
// 加载二进制流
byte[] image = getImageBytes();
Glide.with(this).load(image).into(imageView);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26af1b4c2c56012da7e4d0bde330b9b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f899b0490371240a891305064db9e60e/" rel="bookmark">
			java中List集合根据多个字段去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public List getMOPList(List list){
List&lt;Map&gt; list1= new ArrayList&lt;Map&gt;(); Set&lt;String&gt; set=new HashSet&lt;String&gt;(); for (Map m : list) { String project_no = String.valueOf(m.get("project_no")); if(set.contains(project_no)&amp;&amp;m.toString().contains("payment_situation=2")){ continue; }else{ set.add(project_no); list1.add(m); } } set.clear(); return list1; **如果另一个字段不是固定值，则set.add(另一个字段);多个字段 亦是如此** 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b82723b3e97e97712287a16a8f1faf62/" rel="bookmark">
			[Scala] Scala 学习笔记 (9) - 入参的颗粒化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 颗粒化：Currying。将原来函数的2个入参拆开，分别写在两个括号里面。
/** * * currying 颗粒化 * 将原来函数的2个入参拆开 * 这种做法在Spark SQL UDF里面常用 */ def sum(a:Int, b:Int) = a + b def sum2(a:Int)(b:Int) = a + b println(sum(2,4)) println(sum2(2)(4)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c33293c0c4564a82500514de0941b49/" rel="bookmark">
			深度学习与神经网络的异同：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 相同点：
二者均采用分层结构，系统包括输入层，隐藏层（多层），输出层组成的多层网络，只有相邻层节点之间有连接，同一层以及跨层节点之间相互无连接，每一层都可以看作是一个logistic回归模型。
2. 不同点：
（1）神经网络：
（a）采用BP算法调整参数，即采用迭代式算法来训练整个网络。随机设定初值，计算当前网络的输出，然后根据当前输出和样本真实标签之间的差去改变前面各层的参数，直到收敛；
（b）比较容易过拟合，参数比较难调整，而且需要不少的技巧。
（c）训练速度比较慢。在成熟比较少（小于等于3）的情况下效果并不比其他方法更优；
（2）深度学习：采用逐层训练机制。采用该机制的原因在于如果采用BP机制，对于一个深层网络（7层以上），残差传播到最前面的层将变得很小，出现所谓的gradient diffusion（梯度扩散）。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/195/">«</a>
	<span class="pagination__item pagination__item--current">196/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/197/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>