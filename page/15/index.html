<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56835250e4cc7e3575b868325c7d0c0e/" rel="bookmark">
			如何在yolov8中验证时计算FPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ultralytics-main/ultralytics/engine/validator.py文件下，第200行左右，添加如下代码
LOGGER.info(f'FPS:{(1000 / sum(self.speed.values())):.2f}') speed.values()是一个字典，包括preprocess,inference,loss,postprocess的时间，所以这行代码计算的fps包括对图片前处理，推理和后处理的总时间，每次运行可能FPS会有波动，如果想要一个稳定的数值，可以运行多次求平均。
如果只想要纯网络的推理时间,可以使用如下代码
LOGGER.info(f'FPS:{(1000 / tuple(self.speed.values())[1]):.2f}') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58eba252f96705f9738bf8d97cba1c1/" rel="bookmark">
			AI作画工具 stable-diffusion-webui 一键安装工具（A1111-Web-UI-Installer）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装 下载最新版本确保你的 NVIDIA 显卡驱动程序是最新的（起码不能太老）启动安装程序在欢迎屏幕上单击下一步在屏幕上，选择要安装的内容如果你已经安装了 Python 3.10 和 Git，那么可以取消选中如果你不知道这些是什么，就按默认的来。（注意python这玩意，特定版本很重要）点击next等待下载/安装，耐心等待，安装在后台进行这一步的时候注意一下 安装路径：整个工具加上模型，体积还是比较大的，最好装在SSD上，硬盘闲置空间大于40GB，以及避免安装路径中出现中文install SD Checkpoint ：你要是不知道这个东西是什么，就保持勾选。I understand：用户协议这种东西，懂的都懂，勾上就完了。然后单击【install】按钮视你的网速，需要等待几十分钟到几小时不等 10.完成安装后，将自动打开一个文件夹，其中包含一个名为A1111 WebUI的快捷方式
11. 这个就是SD webUI 的启动器啦，你可以放个快捷方式到桌面上去。
12. 勾选你需要的启动器参数，点击【LAUNCH WEBUI】，它会启动一个 CMD 窗口，耐心等待即可，好了之后会调用你的默认浏览器打开SD webUI
启动器参数 Low VRAM：启用低显存优化，让具有低显存的卡能够生成较大尺寸的图像，这会显著成倍的增加渲染时间
Enable Xformers：大大加快了 RTX 3000 / 4000 卡的速度，有时也可以与以前的卡一起使用！
Do Not Convert Model to FP16：针对16XX系显卡会出黑图绿图的修正，如果你不是16XX系显卡，没生成黑图绿图的问题，就不要勾。
Checkpoint Folder：选择你放ckpt模型文件的文件夹，一般默认就行，除非你把模型和前端打算分开放。
Default VAE File：选择默认的VAE文件
Auto-Update WebUI：每次启动时更新（git pull）SDWebUI
Auto-Update Extensions：每次启动时更新（git pull）扩展
Clear Generated Images：每次启动时，清除上一次生成的所有图片（除了上次你在SD webUI 里点击保存，放到收藏夹内的图片，其他图片都会被清理），给你一个干干净净的工作区。
一些注意的点 这个一键安装启动工具并不能帮你解决你的git与python的网络访问问题，该改仓库改仓库，该设置代理设置代理。如果你对直接给git和python配置代理比较苦手，可以试试用Proxifier这个软件，可以给系统内的任何（绝大多数）软件设置代理。
需要设置的规则如下
怎么用Proxifier，怎么免费注册，网上教程一搜一大把，我就不废话了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2dd0d5d12142c2762864742d4481b5/" rel="bookmark">
			git Filename too long
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git Filename too long 原因： 文件名限制260长度
解决：全局配置git
git config --system core.longpaths true 查看：
git config --get core.longpaths 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8060f786b564b037d64049ca6b4237/" rel="bookmark">
			橘子学ES实战操作01之集群模式如何实现快照备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道ES中通过副本在一定意义上实现了数据的备份和高可用。但是我们说万一副本数据丢失了，不小心被rm -f了，你就说逆天不逆天吧，此时要实现数据真正意义上的备份就要使用到快照机制，来把数据持久化备份起来，万一数据被删了，也能及时恢复。
而单节点的操作直接看官网操作即可。这里就不演示了。或者我后面再补充，实际开发我们一般都是集群模式，官网地址如下：
https://www.elastic.co/guide/en/elasticsearch/reference/7.17/snapshot-restore.html
集群模式略有不同，不同在于存储仓库必须是分布式的文件存储，不能在每个节点的本地配置，因为他要做分布式的备份和恢复读取。你要是像单节点那样本地配置会报错。
我们这里来操作一下集群模式下的快照备份。而且我这个是在离线环境下的操作，实际上和有网络也大差不差，主要是一个数据包的安装区别，你要是有网络直接安装就行，我这里需要拷贝一个数据包。
一、环境配置 1. 集群模式 2. 有的机器是多节点，有的机器是单节点。这样更加具有普遍性。 机器1：node1 node2 机器2：node3 3. 文件服务器，minio，配置信息如下 endPoint: http://192.168.1.1 port: 9000 accessKey: accessKey123 accessSecret: accessSecret123 二、准备材料 离线环境需要下载离线的S3插件包，用于连接s3文件服务器。和自己的ES下载版本一致的最好。我是7.17.7的。
S3插件包地址：https://artifacts.elastic.co/downloads/elasticsearch-plugins/repository-s3/repositorys3-7.17.7.zip，你要是有网络直接Install安装即可。
在minio中建立一个专用快照文件的bucket，我创建为leviBucket。
三、操作步骤 # 1、拷贝s3插件包到指定位置(我这里为/opt/elastic/version7/) # 2、在离线环境安装s3插件包，进入到每个ES节点的bin下面，使用elasticsearch-plugin命令安装repository-s3插件，将命令中的&lt;plugin•zip&gt;替换为插件压缩包的路径和文件名： bin/elasticsearch-plugin install file:///path/to/plugin-zip运行该命令后，Elasticsearch将解压缩并安装插件。一路yes即可。 比如我的目录对应的命令就是./bin/elasticsearch-plugin install file:///opt/elastic/version7/repository-s3-7.17.7.zip。 注意这一步需要再每个es节点都执行，不然对应的node节点起不来。 # 3、 设置elasticsearch.keystore 为每一个ES节点配置文件服务器的连接信息，授权。我的文件服务器为minio，所以进入ES的bin目录，执行以下两句命令。 bin/elasticsearch-keystore add s3.client.default.access_key 执行之后再输入命令位置，输入minio的access_key也就是accessKey123 bin/elasticsearch-keystore add s3.client.default.secret_key 执行之后再输入命令位置，输入minio的minio的secret_key也就是accessSecret123 # 4、修改ES每一个节点的配置文件elasticsearch.yml，配置s3文件服务器的位置端点，在每个elasticsearch.yml最后添加 s3.client.default.endpoint: minio ip:端口 s3.client.default.protocol: http 对应到我的环境就是 s3.client.default.endpoint: 192.168.1.1:9000 s3.client.default.protocol: http # 5、配置完毕重启每个ES节点 四、配置快照 启动之后，连接kibana，首先创建快照仓库，也就是你的快照最后存储在哪里，ES允许以仓库分隔。以下操作都在kibana以DSL命令的方式进行操作。
1、创建快照仓库 这个仓库是在ES层面的仓库，来实际关联minio的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de8060f786b564b037d64049ca6b4237/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2796f11b99cbe02867dab418c4f9b3d/" rel="bookmark">
			如何解决resize方法多次调用的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var resizeTimer = null; $(window).bind('resize', function (){ if (resizeTimer) clearTimeout(resizeTimer); resizeTimer = setTimeout(function(){ console.log("窗口发生改变了哟！"); } , 500); }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e19b379b9c52bdc94b31c7820e4174/" rel="bookmark">
			Vue学习笔记之应用创建和基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装方式
CDN方式安装：
&lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
2、创建应用
使用Vue内置对象创建一个应用，基本代码结构如下：
&lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script&gt; const { createApp } = Vue; createApp({ data(){ return { } }, methods: { }, mounted() { }, computed: { } }).mount('#app'); &lt;/script&gt; id为app的div元素，代表vue应用绑定的dom元素，vue对内部数据的操作都会直接影响dom的数据更新；
data：响应式数据均定义在data内部
methods：自定义函数定义在区域
mounted：DOM元素挂在应用后，可再此执行初始化操作，使用this对象操作data数据
computed：计算属性定义在此区域，一般只涉及读操作，基于响应式数据组合为一个新属性，提供给DOM元素渲染，也支持修改计算属性，但不建议这么做。
3、插值语法
使用两个{{}}大括号表示，如在data部分定义返回属性count，
&lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt; &lt;div id="app"&gt; {{count}} &lt;/div&gt; &lt;script&gt; const { createApp } = Vue; createApp( { data() { return { count: 1 } }, }).mount('#app'); &lt;/script&gt; 3、v-if,v-else判断指令
cansee为真时展示v-if的p元素，否则展示v-else的p元素
&lt;script src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7e19b379b9c52bdc94b31c7820e4174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b9e544e221b74383a4f24809cb3c58/" rel="bookmark">
			Genome-wide association studies in R
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全基因组关联（GWA）研究扫描整个物种基因组，寻找多达数百万个SNPs与特定感兴趣特征之间的关联。值得注意的是，感兴趣的性状实际上可以是归因于群体的任何类型的表型，无论是定性的（例如疾病状态）还是定量的（例如身高）。本质上，给定p个SNP和n个样本或个体，GWA分析将拟合p个独立的单变量线性模型，每个模型基于n个样本，使用每个SNP的基因型作为感兴趣特征的预测因子。每个P检验中的关联显著性（P值）由相应SNP的系数估计确定（从技术上讲，关联的显著性为）。请注意，由于这些测试是独立的且数量众多，因此在设置并行GWA分析时有很大的计算优势（我们将很快进行）。非常合理的是，有必要使用多种假设检验方法，如Bonferroni、Benjamini Hochberg或错误发现率（FDR）来调整所得的P值。GWA研究现在在许多不同物种的遗传学中很常见。
读取数据 让我们首先从三个民族中的每一个导入PLINK转换的.ded、.fam和.bim Illumina文件。我们将使用snpStats包中的函数read.plink，并在本教程的其余部分中处理生成的对象。此函数读取.bed、.fam和.bim，并创建一个包含三个元素的列表——$genesis、$fam和$map。第一个包含从所有样本中确定的所有SNP，第二个包含关于谱系和性别的信息，第三个包含SNP的基因组坐标。目前，我们共有323人（110名中国人、105名印度人和108名马来人）和2527458个SNPs。接下来，我们将把$genetype中存储的Illumina SNP ID更改为更传统的rs ID，这将使我们能够在USCS基因组浏览器中放大候选SNP周围的基因组区域。我准备了一个表来建立两者之间的对应关系，这样我们就可以轻松地切换ID。
library(snpStats) load("conversionTable.RData") pathM &lt;- paste("Genomics/108Malay_2527458snps", c(".bed", ".bim", ".fam"), sep = "") SNP_M &lt;- read.plink(pathM[1], pathM[2], pathM[3]) pathI &lt;- paste("Genomics/105Indian_2527458snps", c(".bed", ".bim", ".fam"), sep = "") SNP_I &lt;- read.plink(pathI[1], pathI[2], pathI[3]) pathC &lt;- paste("Genomics/110Chinese_2527458snps", c(".bed", ".bim", ".fam"), sep = "") SNP_C &lt;- read.plink(pathC[1], pathC[2], pathC[3]) # Merge the three SNP datasets SNP &lt;- rbind(SNP_M$genotypes, SNP_I$genotypes, SNP_C$genotypes) # Take one bim map (all 3 maps are based on the same ordered set of SNPs) map &lt;- SNP_M$map colnames(map) &lt;- c("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51b9e544e221b74383a4f24809cb3c58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a2f893ec2a1e9174707d001d745a960/" rel="bookmark">
			每日一题 力扣2861 最大合金数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2861. 最大合金数 题目描述： 假设你是一家合金制造公司的老板，你的公司使用多种金属来制造合金。现在共有 n 种不同类型的金属可以使用，并且你可以使用 k 台机器来制造合金。每台机器都需要特定数量的每种金属来创建合金。
对于第 i 台机器而言，创建合金需要 composition[i][j] 份 j 类型金属。最初，你拥有 stock[i] 份 i 类型金属，而每购入一份 i 类型金属需要花费 cost[i] 的金钱。
给你整数 n、k、budget，下标从 1 开始的二维数组 composition，两个下标从 1 开始的数组 stock 和 cost，请你在预算不超过 budget 金钱的前提下，最大化 公司制造合金的数量。
所有合金都需要由同一台机器制造。
返回公司可以制造的最大合金数。
示例 1：
输入：n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3] 输出：2 解释：最优的方法是使用第 1 台机器来制造合金。 要想制造 2 份合金，我们需要购买： - 2 份第 1 类金属。 - 2 份第 2 类金属。 - 2 份第 3 类金属。 总共需要 2 * 1 + 2 * 2 + 2 * 3 = 12 的金钱，小于等于预算 15 。 注意，我们最开始时候没有任何一类金属，所以必须买齐所有需要的金属。 可以证明在示例条件下最多可以制造 2 份合金。 示例 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a2f893ec2a1e9174707d001d745a960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1891f41c45f29a8e3e83892bc6673076/" rel="bookmark">
			【数据分析】numpy基础第四天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前天教程与巩固1.1. 第一天1.2. 第二天1.3. 第三天 2. 问题解析2.1. 第一天1. 如何创建Numpy数组2. 如何获取第3个元素3. 如何获取包含第1、2、3行的切片 2.2. 第二天4. 如何将一个有10个元素的一维数组，转变为10行1列的二维数组5. 如何在垂直或者水平上合并两个数组6. 如何筛选出数组arr中大于5的元素 2.3. 第三天7. 对下面创建的数组`arr`的所有元素乘以38. 计算数组`arr`的最大值和最小值9. 计算数组`arr`的标准差和均值 总结 在第四天，我们只需要用一点代码案例来巩固一下以前的内容就OK了。
1. 前天教程与巩固 以下是前面三天的教程链接，以及用于巩固的小问题：
1.1. 第一天 第一天教程 如何创建Numpy数组如何获取第3个元素如何获取包含第1、2、3行的切片 1.2. 第二天 第二天教程 如何将一个有10个元素的一维数组，转变为10行1列的二维数组如何在垂直或者水平上合并两个数组如何筛选出数组arr中大于5的元素 1.3. 第三天 第三天教程 对下面创建的数组arr的所有元素乘以3 arr = np.array([[x for x in range(3)] for _ in range(3)]) 计算数组arr的最大值和最小值。计算数组arr的标准差和均值。 2. 问题解析 2.1. 第一天 1. 如何创建Numpy数组 示例代码
import numpy as np arr = np.array([1, 2, 3]) 代码解析
在这段代码中，我们首先导入了numpy包，并使用别名np引用它。然后，我们调用了np.array()函数并传入了一个列表[1, 2, 3]，来创建一个numpy数组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1891f41c45f29a8e3e83892bc6673076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c02efe74995dd04b29e43ee1bf18409/" rel="bookmark">
			【DeepLearning-8】MobileViT模块配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整代码： import torch import torch.nn as nn from einops import rearrange def conv_1x1_bn(inp, oup): return nn.Sequential( nn.Conv2d(inp, oup, 1, 1, 0, bias=False), nn.BatchNorm2d(oup), nn.SiLU() ) def conv_nxn_bn(inp, oup, kernal_size=3, stride=1): return nn.Sequential( nn.Conv2d(inp, oup, kernal_size, stride, 1, bias=False), nn.BatchNorm2d(oup), nn.SiLU() ) class PreNorm(nn.Module): def __init__(self, dim, fn): super().__init__() self.norm = nn.LayerNorm(dim) self.fn = fn # mg def forward(self, x, **kwargs): return self.fn(self.norm(x), **kwargs) class Attention(nn.Module): def __init__(self, dim, heads=8, dim_head=64, dropout=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c02efe74995dd04b29e43ee1bf18409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255fde6acc155c83908545d62f913268/" rel="bookmark">
			「优选算法刷题」：将×减到0的最小操作数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。
如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。
示例 1：
输入：nums = [1,1,4,2,3], x = 5 输出：2 解释：最佳解决方案是移除后两个元素，将 x 减到 0 。 示例 2：
输入：nums = [5,6,7,8,9], x = 4 输出：-1 示例 3：
输入：nums = [3,2,20,1,1,3], x = 10 输出：5 解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。 二、思路解析 来，大家先看看这道题要求的最短数组，是不是信息量很多，不太容易求？
这时候，就可以用上 “正难则反” 这个思想来进行等价转换了。
那我们可以把题目要求的问题等价转换为：求数组内⼀段连续的、和为 sum(nums) - x 的最长数组，此时，就是熟悉的「滑动窗⼝」问题了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255fde6acc155c83908545d62f913268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25f1f1a7eeec42a28d9f5594fbf6fac9/" rel="bookmark">
			洛谷B3624猫粮规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猫粮规划 题目描述 到中午了，机器猫要吃猫粮了。
机器猫掏出 n n n 份食物，第 i i i 份食物含有的能量为 w [ i ] w[i] w[i]。机器猫可以吃掉其中一些食物，获得这些食物的能量之和。
机器猫又不想变得太胖又不想变得太瘦，所以指定了一个目标区间 [ l , r ] [l, r] [l,r]。显然，可能有很多种选择食物的方式可以达成这个目标，因此机器猫想知道方案总数。
输入格式 第一行，三个正整数 n , l , r n, l, r n,l,r。
第二行， n n n 个正整数，表示每一份食物含有的能量 w [ i ] w[i] w[i]。
输出格式 仅一行，一个整数，表示方案数。
样例 #1 样例输入 #1 4 70 85 10 10 20 50 样例输出 #1 4 提示 样例解释 所有方案如下：
选择食物 1, 2, 4，能量 10+10+50 = 70
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25f1f1a7eeec42a28d9f5594fbf6fac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0abd8f0640686925a166a5d99762e7c6/" rel="bookmark">
			利用python代码获取金价查询 API接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，使用三方接口平台该API接口需要先注册后申请此API接口。申请成功后使用个人中心的API秘钥就可以进行对接开发。
API接口地址为： https://www.tanshuapi.com/market/detail-86
接口地址中shgold为数据源头，他代表的是上海黄金交易所。所有可选值为：
shgold：上海黄金交易所。
shfuture：上海期货交易所。
bankgold：银行账户黄金（纸黄金）。
hkgold：香港黄金。
storegold：金店金价。
london：伦敦金银。
其中，KEY为用户后台我的api页面展示的API密钥。
下面介绍上海黄金交易所的接口使用方法
python import requests //接口详情 https://www.tanshuapi.com/market/detail-86 # 设置API Key key = 'yourkey' //你的api秘钥 # 构造请求的URL url = 'https://api.tanshuapi.com/api/gold/v1/shgold?key={}' . format(key) # 发送请求 response = requests.get(url) # 解析返回结果 result = response.json() # 输出查询结果 print(result) 返回结果为：
{ "code": 1, "msg": "操作成功", "data": { "list": [ { "type": "Au(T+D)", //品种代号 "typename": "黄金延期", //品种名称 "price": "475.00", //最新价 "openingprice": "467.70", //开盘价 "maxprice": "475.00", //最高价 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0abd8f0640686925a166a5d99762e7c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f369bcf52587a0eaf4917557f7d4820d/" rel="bookmark">
			Discuz论坛搭建：Linux宝塔面板一键部署，固定地址畅享公网访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：聆风吟
🔥系列专栏：网络奇遇记、Cpolar杂谈
🔖少年有梦不应止于心动，更要付诸行动。
文章目录 📋前言一. 安装基础环境二. 一键部署Discuz三. 安装cpolar工具四. 配置域名访问Discuz五. 固定域名公网地址六. 配置Discuz论坛📝结语 📋前言 Crossday Discuz! Board（以下简称 Discuz!）是一套通用的社区论坛软件系统，用户可以在不需要任何编程的基础上，通过简单的设置和安装，在互联网上搭建起具备完善功能、很强负载能力和可高度定制的论坛服务。
下面我们在Linux上使用宝塔面板+Discuz+cpolar内网穿透工具结合,搭建一套发布到互联网环境的论坛服务，无需公网IP服务器、也无需设置路由器。
一. 安装基础环境 安装PHP版本,由于Discuz支持的最高PHP7.4版本环境,我们在面板中安装PHP7.0版本,搜索PHP,即可看到,然后点击安装即可
安装一个数据库,如果已经安装,可以跳过,点击面板上数据库,点击安装
然后修改一下数据库密码,改成自己能记住的密码,用户名为root
二. 一键部署Discuz 在面板中搜索一下关键字Discuz,然后点击一键部署
设置参数,域名设置本机域名127.0.0.1,端口号可以自定义,然后设置数据库账号密码,数据库用户名和密码自己设置,点击提交,然后等待下载完成
然后我们点击面板中的网站,即可看到我们刚刚部署的站点,
接下来在面板中开放一个端口:8089
打开浏览器,使用Linux 局域网ip+:8090(上面设置的端口号)进行访问,出现安装向导界面表示成功
三. 安装cpolar工具 打开宝塔终端命令窗口,使用cpolar一件安装脚本:
curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash token认证
登录cpolar官网www.cpolar.com,点击左侧的验证，查看自己的认证token，之后将token贴在命令行里
cpolar authtoken xxxxxxx 向系统添加服务
sudo systemctl enable cpolar 启动cpolar服务
sudo systemctl start cpolar 在宝塔面板中选择安全.然后开放9200端口
然后数据Linux局域网ip+:9200端口即可出现cpolar管理界面
输入官网注册的账号登陆即可对隧道进行操作.
四. 配置域名访问Discuz 我们在cpolar管理界面创建一个随机的8089的隧道:
隧道名称：可自定义，注意不要重复协议：http本地地址：8089端口类型：随机域名地区：China vip 点击创建
然后打开在线隧道列表,查看创建隧道的公网地址,复制地址
打开浏览器,使用上面的公网地址访问,既然出现了欢迎页,表示成功
五. 固定域名公网地址 需升级至基础套餐或以上才支持配置固定域名
登录cpolar官网后台，点击左侧仪表盘的预留，找到保留二级子域名，为http隧道保留一个二级子域名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f369bcf52587a0eaf4917557f7d4820d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa52641674cb713efcf6817b13bf51b/" rel="bookmark">
			GWAS——Genome-Wide Association Study
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全基因组关联研究（Genome-Wide Association Study，GWAS）是一种广泛用于寻找复杂遗传疾病关联基因的重要手段。通过大规模的群体DNA样本进行全基因组高密度遗传标记（如SNP或CNV等）分型，从而寻找与复杂疾病相关的遗传因素。GWAS基于统计学的关联分析方法，将个体的基因型与表型特征进行关联分析，以发现影响表型变异的基因变异。
GWAS的应用范围广泛，已经发现了超过10万个与各种疾病（如癌症，高血压，II型糖尿病，类风湿性关节炎等）以及重要生理性状关联的基因位点。在实践中，GWAS可以通过多种统计方法和软件包进行，如PLINK、R语言和Tassel等。
虽然GWAS在遗传学研究中具有重要价值，但仍然存在一些挑战和限制。例如，GWAS发现的基因变异通常只解释了疾病风险的一小部分，这表明可能存在更多的遗传因素等待发现。此外，GWAS结果需要进一步的功能验证实验来证实基因变异对疾病的影响。
全基因组关联研究（GWAS）在遗传学研究中具有广泛的应用，主要包括以下几个方面：
疾病易感性研究：GWAS可以通过分析大规模人群的基因组数据，寻找与复杂疾病相关的基因变异。这些基因变异可能涉及多种疾病，如癌症、神经退行性疾病、糖尿病等。通过GWAS，可以了解个体的遗传风险因素，有助于疾病的早期预防和干预。药物研发：GWAS可以帮助研究人员发现与药物分布、活化、代谢等有关的基因变异。这些基因变异可能影响药物的疗效和安全性，了解这些基因变异有助于开发更有效的药物和个性化治疗方案。人类进化研究：GWAS可以通过比较不同人群的基因组差异，了解人类的进化过程和历史。这有助于深入探究人类种群的迁徙、分化、混合等现象，以及人类适应环境的能力和特点。生物多样性研究：GWAS可以用于研究生物多样性，比较不同物种之间的基因组差异。这有助于了解物种的进化、适应和分化机制，以及生物多样性的形成和维持机制。农业育种：GWAS可以用于农业育种研究，通过分析作物的基因组数据，寻找与产量、品质、抗逆性等性状相关的基因变异。这有助于培育高产、优质、抗逆的作物品种，提高农业生产效率。 GWAS对人类进化研究有着重要的贡献。通过GWAS，研究人员可以检测到人类基因组中的变异位点，并了解这些变异位点在不同人群中的分布情况。这些变异位点可以提供有关人类进化的重要线索。
首先，GWAS可以帮助研究人员了解人类的起源和迁徙历史。通过比较不同地区人群的基因组数据，可以发现哪些基因变异位点在特定地区更为常见，这有助于了解人类的迁徙路线和混合情况。例如，GWAS研究发现，现代欧洲人的一些基因变异位点来源于古代北方欧亚人，而另一些基因变异位点则来源于古代非洲人。
其次，GWAS可以帮助研究人员了解人类的适应性进化。在人类进化过程中，一些基因变异位点可能对人类的生存和繁衍具有重要意义，因此这些基因变异位点可能会在人群中变得更为普遍。例如，GWAS研究发现，一些基因变异位点与人类适应高原、沙漠和山地等环境有关。
此外，GWAS还可以帮助研究人员了解人类的遗传性疾病和表型特征之间的关系。一些遗传性疾病和表型特征可能是由于特定的基因变异位点引起的，通过GWAS可以发现这些基因变异位点，并了解它们对人类进化的影响。
GWAS的研究流程包括多个步骤，每个步骤都有其特定的目的和要求。以下是一个典型的GWAS研究流程：
数据准备：这是GWAS研究的初始步骤，包括收集样本、准备基因组数据和表型数据。基因组数据可以通过全基因组测序或基因芯片技术获得，表型数据则是与研究对象相关的各种特征和表现。质量控制：在获得数据后，需要进行质量控制，以确保数据的准确性和可靠性。质量控制包括检查数据的一致性、去除低质量的数据和重复样本等。样本筛选：在质量控制后，需要筛选样本，以确保它们符合研究目的和要求。例如，需要排除非相关或具有异常基因型的样本。基因型数据预处理：在样本筛选后，需要对基因型数据进行预处理，包括去除无效的SNP（单核苷酸多态性）数据、调整SNP坐标系等。统计分析：在预处理后，需要进行统计分析，以确定哪些SNP与表型特征显著相关。统计分析方法包括关联分析、回归分析和聚类分析等。结果解释：在统计分析后，需要解释结果，以确定哪些SNP与表型特征具有关联性，并探索其生物学意义。这需要结合生物学知识和统计方法来进行解释。验证和重复实验：最后，需要验证和重复实验，以确认研究结果的可重复性和可靠性。验证和重复实验可以通过不同的样本和实验方法来进行。 在整个GWAS研究流程中，需要使用各种软件和工具来处理和分析数据，例如PLINK、GATK、VCFtools和R语言等。同时，研究人员需要具备深厚的生物学和统计学知识，以确保研究结果的准确性和可靠性。
GWAS研究流程中的质量控制的具体步骤包括：
控制检出率：在基因型数据中，存在着缺失SNPs数据的个体和缺失个体数据的SNPs，在进行分析之前需要去除这些数据。这一过程称为控制检出率（Calling Rate or Missingness）。剔除性别不一致：在基因型数据中，个体的性别信息存在表型~基因型的冲突（Sex Discrepancy），即在基因型数据中表现为一性别，而在表型中记录为另一性别。为了实验结果的准确性，需剔除或修正（根据基因型）数据。剔除低MAF数据：次等位基因（Minor Allele，MA），即在给定的群体中，其基因频率第二高的基因，其出现的频率即为次等位基因频率（Minor Allele Frequency，MAF）。通常，GWAS项目采用的MAF阈值在0.01-0.05之间，取决于样本大小。 剔除性别不一致的方法主要包括以下几种：
检查性别信息：在基因型数据中，需要检查个体的性别信息是否一致。如果存在表型~基因型的冲突（Sex
Discrepancy），即在基因型数据中表现为一性别，而在表型中记录为另一性别，则需要进行剔除或修正。使用PLINK软件：PLINK软件可以用于检查性别信息并标记不一致的个体。通过使用PLINK软件，可以方便地提取不一致的个体并进行后续处理。使用awk和grep等文本处理工具：可以使用awk和grep等文本处理工具来提取不一致的个体。例如，可以使用awk和grep来筛选出基因型数据中性别信息不一致的个体，然后将其剔除或进行修正。根据基因型数据修正性别信息：如果存在性别不一致的情况，可以通过基因型数据来修正性别信息。例如，可以根据基因型数据中Y染色体上的SNP位点来确定个体的性别，并将其修正为正确的性别信息。 这些方法都需要对基因型数据进行仔细的分析和处理，以确保数据的准确性和可靠性。同时，研究人员需要具备深厚的生物学和统计学知识，以便更好地理解和解释结果。
# 加载必要的包 library(GenABEL) library(qqman) # 读取GWAS数据 # 假设你的数据集是一个名为"gwas_data.csv"的CSV文件，包含基因型信息和表型信息 gwas_data &lt;- read.csv("gwas_data.csv", header = TRUE) # 进行质量控制和数据清理 # 例如，你可以检查缺失值、哈迪温伯格平衡等 qc_report &lt;- GWAQC(gwas_data) print(qc_report) # 过滤不合格的变异体和样本 gwas_filtered &lt;- GWA(gwas_data, pop = "Finnish", pop.gen = "Finnish", pop.kin = "Finnish", pop.kin.mode = "pedigree", pop.kin.pedigree = NULL, pop.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aa52641674cb713efcf6817b13bf51b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea273d4e6a53460810de2554acda3395/" rel="bookmark">
			睡眠与时间的小讨论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是阿赵。
这次来讨论一下睡眠和时间的问题。
昨天是周五，我病了，发烧到38.5度。所以我请假回家休息，昨晚十点就睡觉了，一直睡到今天早上8点才起床，居然睡了差不多十个小时。
可能对于很多朋友来说，这也没什么特别的，很多人每天都能睡足8个小时，甚至周末都是睡到中午的。但对于我来说，好像是很多很多年都没有试过了。
平时工作日，晚上9点半才下班，我是跨市通勤的，回到家起码都要晚上10点半了。洗完澡之后我还要写博客，一般都会忙到差不多1点多才睡。第二天早上7点就要起床，因为小孩要上学了。所以我每天基本上都只能睡不到6个小时。而周末基本上也要照顾小孩，小孩醒我就要醒，所以也不可能睡很晚。所以有时候博客上的网友说，我能不能帮忙做点什么东西，实际上我是有心无力，的确没有太多时间。
所以，我其实很久没有体验过睡足觉的感觉了，今天起来，感觉整个世界都不太一样。平时睡醒，觉得头很重，眼睛很涩，对于周围事物的感知好像受到一层薄膜的干涉，难以集中精神。今天醒来，好像感觉不到身体的重量，眼睛也很清晰，特别是精神上似乎是进入了一个全新的世界，精神感知好像可以往远处扩展一样。
原来睡足了觉的感觉是这么美好的。当然，我小时候也是曾经睡足过觉的，只不过每天都能睡足觉的人，是不会有这样的感觉的，因为习以为常。如果能一直保持每天充足的睡眠，是不是能提高工作效率，甚至延年益寿呢？
不过这只是一种妄想。在这个以卷为中心思想的年代，想保证睡眠也是一件奢侈的事情。
在差不多20年前，在培训班学习美术的时候，有一位老师给我们分享了一位师兄的故事。那位师兄非常的努力，曾经2个月就学会了培训中心的大部分课程，而他这两个月里面每天才睡4个小时。那位老师说，原则上每天只要睡2个小时，人就不会死。对于这个说法，我一直是怀疑的。也许这只是那位老师想激励我们的一种手段。不过从侧面可以证明，在一般人的思维里面，卷就需要比别人付出更多的时间。而时间对于每个人都是公平的，一天都是24个小时。那么为了比别人付出更多时间，那就只能牺牲其他时间了，比如睡眠时间。
但付出了更多的时间，是不是收获就会更大呢？我觉得一件事情是否能做好，除了时间以外，还有很多因素影响的。比如，做事情的人的能力水平是否足够，人的精神状态是否足够的好，人的心思是否足够的集中，人的效率是否足够的高。
举个例子，比如小张要做一个Excel表格，本来可以用一些公式就能快速的制表完成，但小张不会，而且太忙了，连学习的时间都没有，所以他就只能逐行逐行的去拖数据。然后由于睡眠不足，精神不集中，经常的拖错了表格，需要重新做。最后，由于每天都早出晚归，家里面很多事情没时间处理，不停的有电话打进来催他这样那样的事情。在这样的情况下，小张就算每天真的只睡2个小时，估计他的工作还是难以完成的。
可惜的是，作为老板，是不会考虑这些事情的。发现小张卷不动了，老板完全可以以工作能力不符合为理由把小张炒掉，然后继续招聘了小李、小陈等，就完事了。因为从老板的角度，是不可能放松对时间的控制的。如果减少了上班时间，可能大部分不自觉的员工根本不会去学习或者处理事情，而是把时间拿去花天酒地，那样对工作同样是没有帮助的。而假如员工本身很自觉很努力，那么压榨更多的工作时间，肯定能提高产出的。反正我们国家人口实在是多，老板们总不担心招不到合适的人员。
作为打工人，我们既要保命、又要照顾家庭，还要满足工作的需求，这是一个难度很高的挑战。近几年，我自己也感觉到身体明显没有以前那么好了。在早几年前，我曾经试过连续加班一个星期没有回家，然后回家睡了一觉就满血复活了。这两年，有几次加班到1、2点，第二天8点半到公司，就连续几天觉得人集中不了精神了。也许这样就是为什么总是流传着游戏程序员35岁就很难找工作的原因吧。因为我们都不是靠知识吃饭，而是靠加班吃青春饭的。
也有一种可能，我们不能靠知识吃饭，是因为我们的知识水平还不足以受到尊重。现在的游戏行业的确也不太追求什么技术。不止一位游戏公司的老板和我说过，游戏只要不会运行时崩溃，对于技术来说就可以了，游戏赚不赚钱，都是看策划。所以游戏老板们，都是招一两个认为水平稍微高点的技术人员，然后带着一帮工资低廉的小技术在做项目。
既然自己的技术水平还得不到应有的尊重，那唯一解决问题的办法，就只能是不断的提高自己的水平了。阿赵我虽然很忙，但一直在坚持写博客，也是出于这种原因。写博客的好处是可以不停地逼自己复习旧的知识，学习新的知识。并且这些内容是可以让所有人看到的，假如学得不对，还可以有人来指正。
我在现在这家公司工作了差不多9年了，从进公司开始，我就已经是主程，都是我在分享知识，并没有人能在工作上给与我任何的知识分享。工作了这么久之后，虽然工资提升的不多，但比起9年前，我的技术是有了几倍以上的飞跃。只要对比一下以前和现在的项目代码和Shader，自己都能明显感觉得到。能有这样的进步，无非就是我牺牲了业余的娱乐和睡眠的时间，在不停的学习而得到的。
人生总是残酷的，如果没有掌握到投胎的正确技巧，不能成为一名优秀的富二代，那么我们就只能通过各种的牺牲，来达到自己的目的。我首先牺牲了的就是睡眠的时间。但我在想，偶尔是不是应该也可以休息一下？比如一年里面，找2、3天时间睡够8个小时，是不是也是一件挺美好的事情？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ecec06014ad4ca59c743791c0bc8ccb/" rel="bookmark">
			Python网络爬虫实战——实验1：Python爬虫环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		综述 随着信息时代的到来，互联网上涌现出海量的数据，而网络爬虫作为一种强大的数据采集工具，为我们提供了获取和分析这些数据的途径。本文将为您介绍一系列Python网络爬虫实战实验，从环境配置到项目部署，帮助您全面了解和掌握这一领域的技能。
通过本文的实验，您将不仅学会构建一个完整的网络爬虫系统，还能够处理爬虫过程中可能遇到的各种挑战。网络爬虫技能的掌握将为您在数据分析、信息挖掘等领域提供有力的支持，让您在信息的海洋中游刃有余。
目录 实验1：Python爬虫环境配置；
实验2：Python爬虫网络请求与内容解析；
实验3：Python爬虫之文字验证码实战；
实验4：Python爬虫代理的使用；
实验5：Python爬虫之selenium动态数据采集实战；
实验6：Python实现js逆向与加解密；
实验7：Python使用apscheduler定时采集任务实战；
实验8：Python爬虫项目部署与kafka消息队实战
实验1：Python爬虫环境配置 【实验内容】 本实验主要介绍关于网络爬虫数据采集的Django项目的环境搭建。
【实验目的】 1、熟悉django项目结构、app目录；
2、了解django开发常用命令；
3、掌握django文件配置，mysql数据库连接；
【实验步骤】 步骤1 使用pycharm创建django项目
步骤2 创建app目录
步骤3 项目文件配置
步骤1：使用pycharm创建django项目
如下图所示，在桌面创建一个DjangoSpider项目。
点击create创建完成后可以看到如下图所示的项目结构。步骤2 创建app目录
点击terminal打开终端输入：
python manage.py startapp SpiderAddInfo
即可生成如下图所示app目录
步骤3 项目文件配置
(1) 数据库连接配置
在settings.py文件中按照上述代码所示，配置数据库、域名、端口、用户名、密码(以自己本地mysql为准)。
（2）数据库迁移
python manage.py makemigrations
python manage.py migrate
使用上述命令行后，终端提示如上图所示表示数据库连接成功。
（3）时区与语言修改
/===================================================/
（4）项目运行
python manage.py runserver
在终端中输入上述命令行即可运行项目文件。
在浏览器中访问http://127.0.0.1:8000/可以看到如下图所示则表示项目运行成功。至此你已经完成了django开发环境的搭建。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224376f75486187238118ab5d7e75172/" rel="bookmark">
			Github 2024-01-27 开源项目日报 Top10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据Github Trendings的统计，今日(2024-01-27统计)共有10个项目上榜。根据开发语言中项目的数量，汇总情况如下：
开发语言项目数量Python项目3Jupyter Notebook项目2非开发语言项目2JavaScript项目1Go项目1Rust项目1Shell项目1 Papers We Love（PWL）：学术计算机科学论文社区 创建周期：3695 天开发语言：ShellStar数量：81115 个Fork数量：5905 次关注人数：81115 人贡献人数：247 人Open Issues数量：17 个Github地址：https://github.com/papers-we-love/papers-we-love.git项目首页: http://paperswelove.org/ Papers We Love（PWL）是一个致力于阅读、讨论和学习学术计算机科学论文的社区。该社区已经整理了一些最好的论文目录，尽管由于许可限制，他们并不总是能够自己托管这些论文。但是，他们会提供论文链接，并鼓励参加本地分会的讨论和在Discord服务器上进行讨论。
DevOps和SRE面试问题和练习集合 创建周期：1577 天开发语言：Python协议类型：OtherStar数量：61028 个Fork数量：13212 次关注人数：61028 人贡献人数：158 人Open Issues数量：54 个Github地址：https://github.com/bregman-arie/devops-exercises.git 该存储库包含与各种主题相关的技术问题和练习的集合，例如Linux、Jenkins、AWS、SRE、Prometheus、Docker、Python、Ansible、Git、Kubernetes、Terraform、OpenStack、SQL、NoSQL、Azure、GCP、DNS、Elastic、Network和虚拟化。它旨在帮助个人为DevOps和SRE领域的面试做准备，尽管需要注意的是，这些问题和练习可能并不完全代表实际的面试场景。该存储库目前包括2624个练习和问题，并欢迎贡献者通过拉取请求添加更多练习。
使用视觉和简单术语解释复杂系统 创建周期：131 天协议类型：OtherStar数量：53021 个Fork数量：5344 次关注人数：53021 人贡献人数：14 人Open Issues数量：34 个Github地址：https://github.com/ByteByteGoHq/system-design-101.git项目首页: https://blog.bytebytego.com/ 这个开源项目旨在使用视觉和简单术语解释复杂系统，对于准备系统设计面试或希望了解系统工作原理的人来说非常有帮助。它涵盖了广泛的主题，包括通信协议、架构模式、数据库、微服务架构、支付系统、DevOps、Git、云服务、开发人员生产力工具、Linux、安全性以及实际案例研究。
Ollama: 在本地使用大型语言模型的设置和使用 创建周期：215 天开发语言：Go协议类型：MIT LicenseStar数量：33457 个Fork数量：2209 次关注人数：33457 人贡献人数：106 人Open Issues数量：526 个Github地址：https://github.com/ollama/ollama.git项目首页: https://ollama.ai Ollama是一个开源项目，帮助用户在本地设置和使用诸如Llama 2和Mistral之类的大型语言模型。
大型语言模型（LLMs）课程 创建周期：221 天开发语言：Jupyter Notebook协议类型：Apache License 2.0Star数量：18166 个Fork数量：1760 次关注人数：18166 人贡献人数：2 人Open Issues数量：19 个Github地址：https://github.com/mlabonne/llm-course.git项目首页: https://mlabonne.github.io/blog/ 大型语言模型（LLMs）课程分为三个部分：LLM基础涵盖数学、Python和神经网络的基本知识，LLM科学家专注于使用最新技术构建最佳的LLMs，而LLM工程师专注于创建基于LLMs的应用程序并部署它们。
Zed: 由Atom和Tree-sitter的创建者开发的高性能多人代码编辑器 创建周期：1071 天开发语言：Rust协议类型：OtherStar数量：9428 个Fork数量：260 次关注人数：9428 人贡献人数：42 人Open Issues数量：1187 个Github地址：https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/224376f75486187238118ab5d7e75172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02fed084d7cb9dde114fe3ea6d68d2aa/" rel="bookmark">
			阿里云幻兽帕鲁服务器4核16G配置报价
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自建幻兽帕鲁服务器租用价格表，2024阿里云推出专属幻兽帕鲁Palworld游戏优惠服务器，配置分为4核16G和4核32G服务器，4核16G配置32.25元/1个月、10M带宽66.30元/1个月、4核32G配置113.24元/1个月，4核32G配置3个月339.72元。ECS云服务器规格e实例和u1实例。阿里云服务器网aliyunfuwuqi.com分享兽帕鲁服务器详细配置和租用价格表：
幻兽帕鲁服务器租用价格表 幻兽帕鲁专属活动页面 https://t.aliyun.com/U/bLynLC 活动打开如下图：
阿里云幻兽帕鲁服务器租用价格
幻兽帕鲁服务器CPU内存公网带宽系统盘优惠价格阿里云经济e实例ecs.e-c1m4.xlarge4核16G按固定带宽 3Mbs100GB ESSD Entry32.25元/1个月阿里云经济e实例ecs.e-c1m4.xlarge4核16G按固定带宽 10Mbs100GB ESSD Entry66.30元/1个月阿里云通用算力u实例ecs.u1-c1m8.xlarge4核32G按固定带宽 10Mbs100GB ESSD Entry113.24元/1个月阿里云通用算力u实例ecs.u1-c1m8.xlarge4核32G按固定带宽 10Mbs100GB ESSD Entry339.72元/3个月 1分钟自建幻兽帕鲁服务器教程 基于阿里云1分钟自建教程 阿里云计算巢-服务详情
基于阿里云自建幻兽帕鲁服务器
幻兽帕鲁是Pocketpair开发的一款开放世界生存制作游戏，游戏中玩家可以在广阔的世界中收集神奇的生物“帕鲁”，派他们进行战斗、建造、做农活，工业生产等。本文阿里云百科介绍如何在阿里云计算巢控制台，快速部署幻兽帕鲁联机服务，实现和朋友一起联机游戏。预计部署时间1~2分钟。大家直接移步到阿里云官方自建教程查看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcaf0943016dae4dfd039df181a7620a/" rel="bookmark">
			Spring Boot 项目的创建和启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是 Spring Boot创建Spring Boot 项目IDEA网页版 Spring Boot 的使用项目目录介绍项目启动实现 Hello 输出 什么是 Spring Boot Spring 的诞生是为了简化 Java 程序的开发的，而 Spring Boot 的诞生是为了简化 Spring 程序开发。
也就是说 Spring Boot 是为了快速开发 Spring 框架而诞生的。
其优点：
快速集成框架，Spring Boot 提供了启动添加依赖的功能，用于秒级集成各种框架。内置运行容器，无需配置 Tomcat 等 Web 容器，可以直接运行和部署程序。快速部署项目，无需外部容器即可启动并运行项目。可以完全抛弃繁琐的 XML，使用注解和配置的方式进行开发。支持更多的监控的指标，可以更好的了解项目的运行情况。 创建Spring Boot 项目 有两种方式可以创建
使用IDEA 直接创建使用Spring 官方提供的网页版来创建 IDEA 如果 IDEA 是社区版的，需要先安装 Spring Boot Helper 插件才可以使用，这个插件在2022版IDEA之前是免费的
首先打开新建项目，选择 Spring Initializr 一栏
然后选择版本号，选择第三方框架
点击创建即可，如果是第一次开 Spring Boot 项目需要加载很久，因为当前 Spring Boot 框架并没有在自己的本地仓库。配置了国内源之后速度会大大提升
网页版 首先要打开网址 https://start.spring.io
点击生成项目后就会自动下载一个压缩包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcaf0943016dae4dfd039df181a7620a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/14/">«</a>
	<span class="pagination__item pagination__item--current">15/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/16/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>