<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a8d9b9f278303d86a744f1293a8e48a/" rel="bookmark">
			《第一行代码：Android》第三版7.4SQLite数据库存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		布局文件略过，就是五个按钮，点击按钮执行对应的功能。
Android 专门提供了一个SQLiteOpenHelper帮助类来对数据库进行创建和升级。
自己创建一个类继承自SQLiteOpenHelper,重新写onCreate()方法和onUpgrade()方法，分别对应创建数据库和升级数据库。
还有两个非常重要的方法：getReadableDatabase()和getWritableDatabase(),它们都可以创建或者打开一个现有的数据库。
insert（）方法用于添加数据。
update（）方法用于对数据进行更新。
delete（）方法用来删除数据。
query（）方法用来查询数据，返回的是一个Cursor对象。
主代码文件内容如下：
package com.example.databasetest import android.annotation.SuppressLint import android.content.ContentValues import androidx.appcompat.app.AppCompatActivity import android.os.Bundle import android.util.Log import android.widget.Button class MainActivity : AppCompatActivity() { @SuppressLint("SuspiciousIndentation") override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) //下面的是数据库相关的代码 //创建数据库 val dbHelper=MyDatabaseHelper(this,"BookStore.db",1) val createDatabase: Button =findViewById(R.id.createDatabase) createDatabase.setOnClickListener{ dbHelper.writableDatabase//没错，我就是用来创建你这个 xxx.db 的 } //增加一条记录 val addData:Button=findViewById(R.id.addData) addData.setOnClickListener{ val db=dbHelper.writableDatabase //ContentValues()是个啥？原书没有说，咱也不敢问啊，照着写就得嘞 val values1=ContentValues().apply{ //开始组装第一条数据 put("name","The Da Vinci Code") put("author","Dan Brown") put("pages",454) put("price",16.96) } //插入第一条数据 db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a8d9b9f278303d86a744f1293a8e48a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53404caa20d3b319b26641c6c0846e33/" rel="bookmark">
			探索CV经典主干网络：从VGGNet到ResNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机视觉领域，深度学习技术已经成为了主流。其中，一些经典的主干网络如VGGNet、ResNet和Xception等，对于推动计算机视觉技术的发展起到了至关重要的作用。这些网络结构以其独特的架构和强大的性能，为各种计算机视觉任务提供了有效的解决方案。本文将详细介绍这些经典主干网络，并探讨它们在计算机视觉领域的应用和影响。
一、VGGNet：深度卷积神经网络的先驱 VGGNet是由牛津大学的Visual Geometry Group提出的一种深度卷积神经网络。它在当时引起了广泛的关注，并为后续的深度学习研究奠定了基础。VGGNet的核心思想是使用连续的小的过滤器（例如3x3）进行卷积，以在深度卷积神经网络上获得良好的性能。
VGGNet通过堆叠多个小的过滤器来模拟更大的过滤器，从而实现更深的网络结构。这种设计思想使得网络在处理图像时能够更好地捕捉到图像的细节信息。此外，VGGNet还采用了全连接层来处理图像特征，并通过最大池化层来降低特征图的维度，从而减少了网络的参数数量。
VGGNet在当时取得了很大的成功，并在多项计算机视觉任务中获得了很好的成绩。它为后续的深度卷积神经网络研究提供了一个很好的参考模板，并为后来的网络结构提供了灵感。
二、ResNet：突破深度限制的网络结构 随着深度学习技术的发展，研究者们开始探索更深层的网络结构。然而，随着网络深度的增加，训练难度和模型性能逐渐成为了研究的难题。在这个背景下，微软研究院提出的ResNet（残差网络）突破了深度限制，让网络可以设计得更深。
ResNet的核心思想是通过引入残差块（residual block），将输入特征图与经过一层或几层卷积后的特征图相加，从而跳过一些不必要的卷积操作。这种设计有效地解决了深度神经网络中的梯度消失问题，让网络可以设计得更深，并取得了很好的性能。
ResNet采用了跳跃连接（skip connection）的方式将不同层的特征图进行连接。这种连接方式可以有效地缓解梯度消失问题，并提高了网络的表达能力。此外，ResNet还采用了批归一化（batch normalization）技术来稳定训练过程，并提高了模型的泛化能力。
ResNet在多项计算机视觉任务中都取得了非常好的成绩，尤其是在图像分类、目标检测和人脸识别等任务中取得了突破性的进展。它的出现为计算机视觉领域的研究提供了更强大的工具，并为后续的网络结构创新提供了新的思路。
三、Xception：深度可分离卷积的先驱 在ResNet之后，Google提出了Xception网络结构。Xception采用了深度可分离卷积（depthwise separable convolution）来替代标准卷积，从而提高了网络的性能和计算效率。
深度可分离卷积将标准卷积拆分为两个步骤：深度卷积（depthwise convolution）和点卷积（pointwise convolution）。深度卷积用于模拟标准卷积中的滤波器部分，而点卷积用于对深度卷积后的特征图进行组合和缩放。这种设计可以减少网络的参数量和计算量，并提高网络的表达能力。
Xception采用了残差结构和跳跃连接的方式，类似于ResNet。但是，Xception在网络结构上进行了改进，将标准卷积替换为深度可分离卷积，从而提高了网络的性能和计算效率。此外，Xception还采用了全局平均池化层来替代全连接层，进一步减少了网络的参数量和计算量。
Xception在多项计算机视觉任务中都取得了很好的成绩，尤其是在图像分类和目标检测等任务中表现出色。它的出现为计算机视觉领域的研究提供了新的思路和方法，并为后续的网络结构创新提供了更多的可能性。
四、总结与展望 CV经典主干网络如VGGNet、ResNet和Xception等在计算机视觉领域中具有举足轻重的地位。它们通过独特的架构和强大的性能，为各种计算机视觉任务提供了有效的解决方案。这些网络结构不仅推动了计算机视觉技术的发展，还为后续的网络结构创新提供了新的思路和方法。
随着深度学习技术的不断发展，我们期待更多的创新性网络结构出现。未来的研究将进一步探索网络结构的优化和创新，以提高模型的性能和计算效率。同时，随着应用场景的不断扩展和数据量的不断增加，计算机视觉技术将在更多的领域得到应用和发展。我们相信CV经典主干网络将继续为计算机视觉领域的研究提供重要的支持和参考，并为未来的技术进步和应用拓展做出更大的贡献。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eebd1c8a768b37359f5f62146185aeb1/" rel="bookmark">
			Nuxt3中写Vue自定义指令，以v-auth为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在后台管理系统中，常需要按钮级权限控制。在常见的访问控制RBAC 模型（用户、角色、权限）中，我们可能需要根据角色或权限来控制某个按钮的显示隐藏。
因此，我们期望使用以下方式来控制
// 单个角色 v-auth:role="'admin'" // 多个角色 v-auth:role="['admin','manager']" // 单个权限 v-auth:permission="'user_read'" // 多个权限 v-auth:permission="['user_read','user_write']" 编写指令 在根目录下创建文件夹plugins，Nuxt会自动引入这个目录下的一级js文件，不需要在配置中引入。因此，我们可以创建一个auth.js文件。
// plugins/auth.js export default defineNuxtPlugin((nuxtApp) =&gt; { // 不再是 import Vue from 'vue'的写法了 nuxtApp.vueApp.directive('auth', { // 不用mounted，在mounted时用户权限集还是空的 updated(el, { arg, // role | permission value, // string | array }) { if (typeof value == 'string') { value = [value]; } // 用户信息，这里面有属性 role | permission const userInfo = useState('userInfo'); const userAuth = userInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eebd1c8a768b37359f5f62146185aeb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e5c72100840677594bd3e7712cb72e/" rel="bookmark">
			编写代码，定义一个基类MyClass，其中包含虚拟方法GetString()。(C#)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写代码，定义一个基类MyClass，其中包含虚拟方法GetString()。这个方法应返回存储在
受保护字段myString中的字符串，该字段可以通过只写公共属性ContainedString来访问。
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Collections; namespace name1 { abstract class Progrom { static void Main(string[] args) { } } public abstract class Myclass { private string myString; public string ContainedString { set { myString = value; } } public void MyClass(string str) { myString = str; } public virtual string GetString() { return myString; } } } 从类MyClass中派生一个类MyDerivedClass。重写GetString()方法，使用该方法的基类实现
代码从基类中返回一个字符串，但在返回的字符串中添加文本“(outputfromderivedclass)。
using System; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25e5c72100840677594bd3e7712cb72e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abcb5c343dd702d6552c8eaef9bbb23d/" rel="bookmark">
			右箭头css，箭头css
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 .box { position: relative; } .box::after { width: 4px; height: 4px; border-top: 1px solid; border-right: 1px solid; border-color: #222; content: ''; position: absolute; right: 7px; top: 3px; transform: rotate(45deg); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca8385baa3db8bd44a430be2b23ac4c7/" rel="bookmark">
			逆向还原sourcemap源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.使用npm安装reverse-souecemap 1.1 安装npm1.2 npm配置优化 1.2.1 全局模块存放路径和cache路径1.2.2 更改镜像源1.2.3 升级更新npm，并添加环境变量 1.3 安装 reverse-sourcemap 2. 使用reverse-sourcemap逆向获取源码3. 漏洞修复 1.使用npm安装reverse-souecemap 1.1 安装npm 访问官网，下载安装包，然后一路next即可
https://nodejs.org/en
安装包会自动添加环境变量
确认是否安装成功
npm -v 1.2 npm配置优化 建立两个文件夹node_cache和node_global
1.2.1 全局模块存放路径和cache路径 运行命令
npm config set prefix "D:\nodejs\node_global" npm config set cache "D:\nodejs\node_cache" 1.2.2 更改镜像源 npm config set registry=http://registry.npm.taobao.org 查看刚才的配置是否生效
npm config list 1.2.3 升级更新npm，并添加环境变量 # npm install 安装或更新模块 -g代表全局安装，即安装到D:\nodejs\node_global目录下 npm install npm -g 安装报错
根据提示信息，以管理员模式打开cmd，再次执行更新命令，成功安装
此时，再次查看global中已经安装了那些模块，可以发现我们安装的npm
npm list -global 由于默认的模块路径为：D:\nodejs\node_modules 目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca8385baa3db8bd44a430be2b23ac4c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffea46c1908bd8128b3165b6032c7010/" rel="bookmark">
			Addressable（10）从服务器加载资源AB包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 模拟远端发布资源1.将本机模拟为一台资源服务器，通过Unity自带工具或者第三方工具2.设置分组为远端加载路径3.打包4.测试 实际上的远端发布资源视频使用了Windows服务器+hfs.exe我使用的是Linux服务器+宝塔面板来操作 模拟远端发布资源 1.将本机模拟为一台资源服务器，通过Unity自带工具或者第三方工具 使用addresable的hosting
记住使用的192.168.3.83与58474端口
设置addressable的profile
2.设置分组为远端加载路径 指定分组使用远端加载
记得需要勾选Build Remote Catalog
3.打包 有文件目录，也有bundle
4.测试 加载的AB包
代码
void Start() { print("开始加载。。。"); Addressables.LoadAssetsAsync&lt;GameObject&gt;(new List&lt;string&gt;() { "Cube", "SD" }, (obj) =&gt; { var newObj = Instantiate(obj); newObj.transform.position = new Vector3(0, 0, 0); }, Addressables.MergeMode.Intersection); } 构建应用程序并且测试
成功加载模拟服务器的AB包资源
实际上的远端发布资源 视频使用了Windows服务器+hfs.exe 我的服务器是linux，就跳过视频中的步骤
我使用的是Linux服务器+宝塔面板来操作 服务器信息
使用的typecho搭建的网站，开放端口是80。（这步需要网上搜索）
远程服务器加载AB包过程
Unity打包
上传打包的文件到服务器网站目录下
可以用网页访问.json文件，查看是否能访问
再Unity中运行程序，即可从远程服务器中加载AB包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/524e8a62ecadf9da060498158d4dcdb1/" rel="bookmark">
			Addressable（9）资源打包理论与本地应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 理论：资源打包知识点一：资源打包指的是什么知识点二：资源打包的模式知识点三：资源打包的注意事项 应用：资源打包(本地 )知识点一：编辑器中资源加载的几种方式知识点二：本地资源发布本地发布打包：使用默认设置打包：**修改**组的默认的本地构建和加载路径 理论：资源打包 知识点一：资源打包指的是什么 原先
需要手写代码或者工具进行打包
现在addressbale
此打AB包过程自动化了
如何使用AB包
和游戏安装包放一起将AB包放远程，发布游戏时只打包必备资源到包中（更好：减小包体，热更新） 知识点二：资源打包的模式 一个组有3个模式
Pack Together：创建包含组中所有资产的单个包Pack Separately：为组中的每个类型的资源创建一个包。精灵、预制体Pack Together by label：为共享相同标签组合的资产创建一个包 知识点三：资源打包的注意事项 场景资源始终有自己单独的包
即：一个组中有场景资源和普通资源时，场景资源和其它资源始终被分开打包。
资源依赖的注意事项
资源c被a所在的A、b所在的B包引用这样A包有a、c，B包也有b，c，造成资源重复好的解决方法是：将资源c打一个包 资源c如果是图集，应该被重视，不同包的内容使用同一个图集中的图片时，需要一个专门的图集包。
应用：资源打包(本地 ) 知识点一：编辑器中资源加载的几种方式 Use Asset Database（fastest）
不用打AB包，直接本地加载资源，主要用于开发功能时和学习
Simulate Groups（advanced）
不用打AB包通过ResourceManager从资产数据库加载资产，就像通过AB包加载一样，通过引入时间延迟，模拟远程AB包的下载速度和本地AB包加载速度 Use Existing Build（requires built groups）
需打AB包会从AB包中加载资源 知识点二：本地资源发布 代码
void Start() { Addressables.LoadAssetsAsync&lt;GameObject&gt;(new List&lt;string&gt;() { "Cube", "SD" }, (obj) =&gt; { Instantiate(obj); }, Addressables.MergeMode.Intersection); } 本地发布 组设置
每个组都可以选择打包路径和加载路径
打包：使用默认设置 说明
当发布应用程序时，会自动帮我们将AB包放入StreamingAssets文件夹中
如下
打包：修改组的默认的本地构建和加载路径 说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/524e8a62ecadf9da060498158d4dcdb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33bfac6a5015d9f9722544810e5062a6/" rel="bookmark">
			phpstudy小皮（PHP集成环境）下载及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 https://www.xp.cn/download.html直接官网下载即可，下载完解压是个.exe程序，直接点击安装就可以，它会自动在D盘目录为D:\phpstudy_pro
使用 phpMyAdmin是集成的数据库可视化，这里需要下载一下，在软件管理-》网站程序-》数据库工具-》phpMyAdmin4.8.5.
这里咱们启动这两个，有时候mysql启动不了，是因为你的电脑已经有mysql在运行了，可以打开任务管理器服务里面将其关掉，然后这个MySQL5.7.26就可以启动了。
例子（HkCms开源项目管理系统） https://www.hkcms.cn/index/index/uplogs进入网站后点击下载最新版就可以
将下载的的zip文件放到D:\phpstudy_pro\WWW文件夹下解压，这个就是下载的小皮（phpstudy）的WWW文件下。
打开小皮（phpstudy）,点击左侧管理-》创建网站，自己起一个域名，根目录必须是public,确认后重启小皮（关闭所有服务）再进入打开服务，点击管理-》打开网站，就进入到安装页面，安装完之后就可以进入到管理后台或前台页。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bfe68bf5b85dc78f6830c7b8122b042/" rel="bookmark">
			实战11:SpringBoot和Vue实现登录、注册和异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、异常统一处理类
1、Result包装类
2、系统异常统一处理
二、SpringBoot实现登录、注册、个人信息
三、Vue实现登录、注册、个人信息
1、登录： 登录方法 、表单数据校验、登录表单、跳转注册
2、注册：页面布局、表单数据校验 、注册 、返回登录
3、个人信息：卡片和表单 、localStorage存储登录用户全局用户数据 、根据用户名称获取用户数据 、修改用户数据
4、路由配置
5、用户全局状态
一、异常统一处理类 1、Result包装类 package com.example.demo.common; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /* 接口统一返回包装类 */ @Data @NoArgsConstructor @AllArgsConstructor public class Result { private String code; private String msg; private Object data; public static Result success() { return new Result(Constants.CODE_200, "", null); } public static Result success(Object data) { return new Result(Constants.CODE_200, "", data); } public static Result error(String code, String msg) { return new Result(code, msg, null); } public static Result error() { return new Result(Constants.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bfe68bf5b85dc78f6830c7b8122b042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca814c7605d8233a21316b88a2b3e255/" rel="bookmark">
			《第一行代码：Android》第三版6.5高阶函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要是讲高级函数，首先来看看什么是高阶函数？（HighOrderFunction）
高阶函数定义 定义：如果一个函数接收另一个函数作为参数，或者返回值的类型是另一个函数，那么该函数就称为高阶函数。
编程的数据类型有int ，布尔类型等，Kotlin中增加了一个函数类型的概念。如何声明一个函数类型？（String，Int）-&gt;Unit 这么写的意思就是：这是一个函数，接收String 和Int作为输入参数，返回值是Unit，Unit 相当于Java中的void。
高阶函数允许让函数类型的参数来决定函数的执行逻辑。
书中例子代码 例子是纯kotlin代码，可以在play中实现。实现了一个高阶函数，传入两个数，和plus 或者minus ，根据是加还是减来决定执行逻辑。
后面的result3 和result4 连函数都懒得声明了，直接就是匿名函数了，更自由了，想怎么整您就直接写得嘞。
/** * You can edit, run, and share this code. * play.kotlinlang.org */ fun main() { println("Beginning:Hello, world!!!") val num1=100 val num2=80 val result1=num1AndNum2(num1,num2,::plus) val result2=num1AndNum2(num1,num2,::minus) println("result is $result1") println("result is $result2") //下面是使用lamda表达式的写法来实现的 val result3=num1AndNum2(num1,num2){n1,n2-&gt;n1+n2} val result4=num1AndNum2(num1,num2){n1,n2-&gt;n1-n2} println("use lamda:result is $result3") println("use lamda:result is $result4") } fun num1AndNum2(num1:Int,num2:Int,operation:(Int,Int)-&gt;Int):Int{ val result=operation(num1,num2) return result } fun plus(num1:Int,num2:Int):Int{ return num1+num2 } fun minus(num1:Int,num2:Int):Int{ return num1-num2 } 运行结果 Beginning:Hello, world!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca814c7605d8233a21316b88a2b3e255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bdf2d33ae359d377406e8af1ad5a246/" rel="bookmark">
			当年为什么选择计算机？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确切的来说不是远的计算机，高考那会计算机很热门，根本考不上！学习了一个和计算机关系很密切的专业，编程搞得好，才能找到好工作，才能有饭吃！记得当年我还跑去武汉大学的计算机课堂和人家一起听课，可惜没有坚持下来！学生时代学习的是C语言，使用的教材是谭浩强的书，我觉得人家写的挺好的。后来好像是大学四年级吧，有一门课叫数据结构，老师是以Pascal语言来讲解的数据结构，自然听的是一脸懵懵…现在想起来我估计当时的老师你让她讲C语言版本的，估计是讲不下来的，这玩意还是有一些深度难度的！
同宿舍的同学那会攒钱买计算机了，打游戏，看电影之余有个同学会去编程！他学习的是VB,学起来感觉难度不大，就是挺好学好用的！不过这几年VB微软都打算停止维护了！那会我对计算机感兴趣，遗憾的是我却做不出来专业老师给我们布置的作业，是我下的功夫太少，心智不成熟，也不知道干点正经事，跑去干兼职，谈恋爱，听音乐去了…所以现在我的水平还是那么幼稚。
还学习过计算机图形学，教材是C语言的代码，当我照着书上把程序实现完毕，屏幕上出现五彩斑斓的图案的时候，我好开心。大三还是大四吧 同学说未来是Java的天下，软件报上就是这么说的，遗憾的是我那会只是听说过没有见过，后来读研究生了，才在自己的机器上实践过几个简单的程序，算是有一点基础了。
后来Csharp出来了，买了本入门的书也看过一阵子，都说未来这个很能打…再后来做项目需要，学习了一会脚本语言，3 Dmax脚本，用来给模型修改一下属性数据，很快，可以批量操作，工作效率一下子提高了不少。
工作了，国外的软件天天讲Com组件，我也研究啊研究，还有候捷的书，就是讲MFC的那本书，花了我大概六十块钱，可惜的是我并没有学会MFC就感觉这玩意有点反人性，这玩意也快玩完了。
后来学习了网页设计，html，CSS，JavaScript，dojo这玩意挺好的，做个网页出来效果立马看得见！后来还学习了DOJO一个JavaScript框架，能用这个做个网页什么的。还学习了Python，感觉这个最简单了。还学习了C++OSG开发，能出现一个虚拟出来的三维地球，失业在家还学习了C++QT编程,这个就是比MFC好用，我用MFC我做个按钮我都不会，这个QT就直观多了。现在在学习kotlin，安卓手机开发，我就是学了这么多，还是期待自己能成为一个高手…
有点扯远了，回到题目上来为啥选择计算机呢？当然是为了多赚钱了，不会计算机就只能去做项目助理资料员了，那多没意思啊…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab3bb25e9861f660cc5cafbe6920e42/" rel="bookmark">
			【Vue】router.push用法实现路由跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
router.push用法
在Login.vue中
在Register.vue中
​
上一篇：登录与注册界面的制作
https://blog.csdn.net/m0_67930426/article/details/134895214?spm=1001.2014.3001.5502
制作了登录与注册界面，并介绍了相关表单元素即属性的用法
在登录页面中，通过点击注册按钮，跳转到注册页面
在注册页面中，通过点击登录按钮，跳转到登录页面
实现如下
首先这两个页面在router包的index.js文件中都配置了对应的路由
import('../views/Login.vue') 对应的是
import('../views/Register.vue') 对应的是
router.push用法 在Login.vue中 @click="$router.push('/register')" 这里的 '/register' 对应router包的index.js文件中的
在Register.vue中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ee2f07a6a89e77b9a067938b5dbea1/" rel="bookmark">
			《程序员超强大脑》读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理一些对自己有启发和帮助的点，与君共享，强烈推荐这本书，值得从新手到中高级程序员共读
文章目录 记忆长时记忆短时记忆工作记忆 那如何利用这些理论呢？使用设计模式编写注释添加信标抽认卡主动记忆减轻认知负荷代码重构依赖图状态表 代码深层含义变量角色框架构建代码的心智模型工作记忆的心智模型长时记忆中构建代码的心智模型 变量名 三步模型提高解决复杂问题的能力 记忆 工作中，经常有些大佬，你问他项目的很多细节，都能给你一一道来，难道他们的记忆就那么厉害吗？
自己也试过记笔记，为啥没啥效果，而且很多事情，时间长了，啥都想不起来了，领导问的时候很尴尬，必须借助confluence文档或自己的笔记才能复现。
为什么会出现这种情况？我们的大脑到底是怎么记忆的？
大脑有三种记忆方式：
长时记忆 长时记忆(long-term memory) 可以无限期存储所有记忆，比如你走路的时候肯定不会想着怎么走，甚至同时还能打电话、聊天；有些人写二叉搜索树很快，这些都属于长时记忆。类比硬盘。
长时记忆会存储几类相关的编程信息，例如成功运用某种编程技巧的记忆、Java关键字的含义、英语单词的含义或者Java中int型变量的最大值(2147483647)。
短时记忆 短时记忆，它用于暂时保存大脑接收的信息。比如你收到验证码短信，不会进入长时记忆。类比内存。
在阅读程序时，大脑会把程序使用的关键字、变量名和数据结构暂时保存在短时记忆中。
进入短时记忆之前，信息会经历感觉记忆(sensory memory)的阶段。类比于鼠标、键盘等输入设备相互通信的I/O缓冲区。感觉记忆用于暂时存储大脑接收的视觉、听觉或触觉信息。
与视觉信息有关的感觉记忆，即图像记忆(iconic memory)。类比翻页书，闭上眼睛仍能“看见”图像。
利用图像记忆来提高代码阅读的效率：首先扫一眼代码，然后回忆看到的内容。练习“扫视代码”有助于大脑建立起对代码的初步印象。
工作记忆 实际的思维活动不是在短时记忆或长时记忆中进行，而是在工作记忆中进行。大脑内部用于追踪以及进行其他复杂认知活动的机制称为工作记忆。工作记忆是孕育新想法、新观点以及新方案的摇篮。相当于大脑的“处理器”。
在阅读代码的过程中，大脑尝试在脑海里组织并执行代码。如果大脑感觉需要借助外部媒介来存储信息，则可能意味着工作记忆的负担过重，难以加工更多信息。
那如何利用这些理论呢？ 使用设计模式 其实跟我们汉语的成语一样，能让别人快速识别自己的代码
编写注释 有助于新成员更好地理解同事的代码库，此外，不是一开始就能写出完整的代码，写代码时也有可能被打断思路(比如开会、电话、微信等)，有注释能让我们更快的回忆，进入状态。
添加信标 beacon，包含简单信标和复合信标。
简单信标：简单信标是自解释的语法代码元素，例如有意义的变量名。比如root、tree、&amp;&amp;、if等
复合信标：由多个简单信标构成的较大代码结构。例如，for循环包括变量、初始化赋值、增量值以及边界值，特定的编程结构（例如交换或初始化为空列表）同样能够充当信标。
在阅读代码时，多关注信标，注释、变量名、方法名或中间值，它们都能充当信标。
抽认卡 抽认卡的目的，是让概念从短时记忆存储到长时记忆。
形式可以是纸质的，也可以是电子版，如开源的anki。
内容可以是编程语言、框架、代码片段。比如正面：执行某种计算的推导式；反面：[x * x for x in numbers]。
流程：整理抽认卡 --&gt; 使用(练习，可敲键盘再对比) --&gt; 扩充抽认卡 --&gt; 精简抽认卡
主动记忆 存储到长时记忆很重要，但更重要的是工作记忆要能很快提取。如何做到？和生活中很多事情一样，经常练习也就是主动记忆才能巩固记忆。
如何主动记忆？在谷歌之前先设法记住信息。
减轻认知负荷 代码重构 为什么要重构代码，因为代码太乱，在阅读代码时让我们的工作记忆不堪重负，因此需要认知重构(cognitive refactoring)，帮助我们读懂代码，如将方法声明移到第一次方法调用附近或许有助于提高代码可读性。又比如三元运算符、lamda表达式等的重构。由于程序员先验知识并不一样，认知重构因人而异，其目的只是帮助程序员理解代码，属于临时操作，有git之后，可以自建分支用来梳理代码。
依赖图 复杂的代码，需要使用依赖图。依赖图(dependency graph)不仅有助于理解代码流，而且有助于遵循逻辑流程来阅读代码。如何绘制？打印为pdf，不要用IDE进行跳转，然后梳理变量、方法、类等，不同颜色圈中、连线，查看。
状态表 过于复杂的，可能需要状态表，比如工作流，记录每个变量的初始值、每一步之后的值，减轻认知负荷。
代码深层含义 变量角色框架 变量在代码推理中处于主导地位，含义明确的变量名，对理解代码至关重要。为什么变量难以理解？因为程序员没有专业训练和语言规范，长时记忆没有建立起能够关联变量的有效图式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75ee2f07a6a89e77b9a067938b5dbea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48439111b5aaef3d7594ac49ab44ba37/" rel="bookmark">
			CommandLineRunner和@PostConstruct区别与应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CommandLineRunner和@PostConstruct区别与应用场景 时机和触发方式： CommandLineRunner 接口的run方法在整个Spring Boot应用程序启动完成后执行。它是在应用程序启动的最后阶段触发的，这样你可以确保在Spring Boot应用程序完全启动并准备好接受请求之前执行你的逻辑。@PostConstruct注解标注的方法会在Spring容器实例化Bean并完成依赖注入后立即执行。这意味着它是在Bean的生命周期中非常早的阶段执行的，但在整个Spring应用程序完全启动之前。 参数传递： CommandLineRunner接口的run方法可以接受一个字符串数组参数，这个数组包含了应用程序启动时传递的命令行参数。这为你提供了一种在应用程序启动时动态配置或执行不同的逻辑的机会。@PostConstruct注解的方法不能接受参数，因为它是通过反射调用的。这意味着你不能直接在方法中获取Spring Boot应用程序启动时的参数。 应用场景 CommandLineRunner 适用于整个SpringBoot程序启动后执行的初始化逻辑可以执行程序级别操作，如执行定时任务、执行数据加载等提供了访问命令行参数的能力，可以在run方法中获取应用程序启动时传递的参数。 @PostConstruct 用于spring Bean初始化阶段执行的一些逻辑一般用于与Bean属性初始化的相关操作，比如初始化资源、建立链接等等 使用方式 CommandLineRunner
@Component public class MyCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { // 在应用程序启动后执行的逻辑 } } @PostConstruct
@Component public class MyBean { @PostConstruct public void init() { // 在Bean初始化阶段执行的逻辑 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/727ddeb802b29ac1bae8349cee51bd77/" rel="bookmark">
			VUE 高德地图JS API --- 快速创建地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、实现步骤 1.1 准备 成为开发者并创建 key：为了正常调用 API，请先注册成为高德地图开放平台开发者，并申请 web 平台（JS API）的 key 和安全密钥，点击 具体操作。
1.2 页面准备 &lt;template&gt; &lt;div class="container"&gt; &lt;!-- 预设用于添加自定义内容 --&gt; &lt;div class="map" id="container"&gt; &lt;/div&gt;	&lt;/div&gt; &lt;/template&gt; &lt;style&gt; .container { display: flex; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; right: 0; bottom: 0; } .map { position: relative; width: 100%; height: 100%; z-index: 1; } &lt;/style&gt; 1.3 JS API 的加载和地图初始化 使用 JS API Loader 来加载，引入在控制台申请的 key 和 安全密钥。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/727ddeb802b29ac1bae8349cee51bd77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e43ef3ec386af3b4c9325ae05fdba550/" rel="bookmark">
			电脑闲置不用，弹出全屏广告，有关闭按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://jingyan.baidu.com/article/624e745907544775e8ba5a8f.html
1
打开暴风影音
2
点击左上角，选择高级选项
3
在常规设置，其他设置中，去掉屏保的✔，然后应用确定
END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595ea83681ec060832a815c9c44ff0e3/" rel="bookmark">
			[深度学习] Python人脸识别库Deepface使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		deepface是一个Python轻量级人脸识别和人脸属性分析（年龄、性别、情感和种族）框架，提供非常简单的接口就可以实现各种人脸识别算法的应用。deepface官方仓库为deepface。deepface提供了多种模型，模型下载地址为deepface_models。
安装方式： pip install deepface -i https://pypi.tuna.tsinghua.edu.cn/simple
deepface主要提供以下人脸识别算法，具体对应接口为：
DeepFace.verify：人脸验证DeepFace.find：人脸识别DeepFace.analyze：人脸属性分析DeepFace.detectFace：人脸检测DeepFace.represent：人脸特征提取DeepFace.stream：人脸实时分析 总体而言，这个项目的人脸识别模型识别效果还行，但是离工程应用还是有一定的距离，不过还是非常推荐学习该库内部代码。
某些网站会判定本文人脸图片违规，这是网站识别算法自身问题。
本文所有算法展示效果和代码见：
github: Python-Study-Notes
此外可以看一看另外一个人脸识别库，功能更加齐全：[深度学习] Python人脸识别库face_recognition使用教程
文章目录 0 数据准备1 人脸验证DeepFace.verify2 人脸识别DeepFace.find3 人脸属性分析DeepFace.analyze4 人脸检测DeepFace.detectFace5 人脸特征提取DeepFace.represent6 参考 0 数据准备 # deep库的导入就一行代码 from deepface import DeepFace import matplotlib.pyplot as plt from PIL import Image, ImageDraw import os import cv2 import numpy as np 所使用的数据集为网络明星图片，共五个明星，每个明星三张人脸，数据集的路径如下：
root ├── images │ ├── baijingting │ │ ├── 0000.jpg │ │ ├── 0001.jpg │ ├── jiangwei │ │ ├── 0000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/595ea83681ec060832a815c9c44ff0e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e9d69afb0ced048714aa7521eab37cb/" rel="bookmark">
			Tensorflow找不到GPU：tensorflow 2.11.0版本开始，在windows上不再支持GPU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 由于近期更换了电脑，所以需要在新电脑上重新配置Tensorflow的运行环境。本着使用最新版本的原则，按照官方指导教程进行安装以及配置CUDA, cuDNN等。此时我安装的最新版本为2.11.0，经测试tensorflow无法使用GPU。
测试是否能够使用GPU的代码：
import tensorflow as tf gpus = tf.config.experimental.list_physical_devices(device_type='GPU') cpus = tf.config.experimental.list_physical_devices(device_type='CPU') print(gpus, cpus) 程序运行结果为：
[] [PhysicalDevice(name='/physical_device:CPU:0', device_type='CPU')] 显然tensorflow没有找到GPU，只有CPU。
以下是官网给出的安装教程：
官方链接: 使用 pip 安装 TensorFlow
在虚拟环境中使用pip安装tensorflow pip install tensorflow 接着配置相关软件 NVIDIA® GPU 驱动程序-CUDA® 11.2 要求 450.80.02 或更高版本。CUDA® 工具包：TensorFlow 支持 CUDA® 11.2（TensorFlow 2.5.0 及更高版本）CUDA® 工具包附带的 CUPTI。cuDNN SDK 8.1.0 cuDNN 版本。（可选）TensorRT 6.0，可缩短用某些模型进行推断的延迟时间并提高吞吐量。 配置环境变量
确保安装的 NVIDIA 软件包与上面列出的版本一致。特别是，如果没有 cuDNN64_8.dll 文件，TensorFlow 将无法加载。如需使用其他版本，请参阅在 Windows 下从源代码构建指南。将 CUDA®、CUPTI 和 cuDNN 安装目录添加到 %PATH% 环境变量中。例如，如果 CUDA® 工具包安装到 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e9d69afb0ced048714aa7521eab37cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66ce3f37d1e6035c582a86463a90dc3f/" rel="bookmark">
			Java计算两个日期之间月份的差值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本功能只实现计算两个日期之间，月份差了几个月，与日无关，与30天无关。比如：20231030与20231215，月份相差2个月。
public static int monthDiff(String dateString1, String dateString2){ // 将字符串转换为 LocalDate 对象 LocalDate date1 = LocalDate.parse(dateString1); LocalDate date2 = LocalDate.parse(dateString2); // 获软时间1的年份和月份 int year1 = date1.getYear(); int month1 = date1.getMonthValue(); // 获取时间2的年份和月份 int year2 = date2.getYear(); int month2 = date2.getMonthValue(); // 计算时间1的总月数 int totalMonths1 = year1 * 12 + month1; // 计算时间2的总月数 int totalMonths2 = year2 * 12 + month2; // 计算总月数差 int monthsDiff = totalMonths2 - totalMonths1; return monthsDiff; } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/31/">«</a>
	<span class="pagination__item pagination__item--current">32/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/33/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>