<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1179aede9450e81e47deecee34ec107b/" rel="bookmark">
			XSS靶场练习（pikachu和dvwa）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pikachu靶场xss练习 反射型xss(get) 输入123发现被直接插入到了html中，而且输入框有字符长度限制
在url中构造payload:&lt;script&gt;alert(123)&lt;/script&gt;
反射型xss(post) 查看源码发现登录界面没有任何机会；登录后输入123发现和xss(get)写入位置一样；只是url不可见；同样的构造payload：&lt;script&gt;alert(123)&lt;/script&gt;;这里没有字符限制；如果有字符限制可以前端代码把限制的js代码去掉（火狐可以，edge不行）或者直接bp抓包修改
存储型xss 通过输入发现留言板中的内容都会显示在下面；不删除是一直存在的；直接构造
payload:&lt;script&gt;alert(123)&lt;/script&gt;;输入后会直接弹窗；而且之后每次提交数据都会触发alert()t弹窗
DOM型xss 通过分析前端源码发现数据的数据在一个&lt;a&gt;标签中，输入信息充当跳转的链接
构造payload:javascript:alert(123)或者javascript:alert("xss")；输入会显示一个链接；点击链接实现跳转
注意：此时alert()函数中间是字符串时必须用双引号；因为&lt;a&gt;标签中用单引号选中链接；用单引号会破坏语句
DOM型xss-x 原理和DOM型xss一样；只不过对输入的数据中的+进行了替换；同样构造payload:javascript:alert("xss")通过
XSS盲打 只看前端代码没有任何信息；看不到写入的数据放到哪里了；但是找到了后台的地址
通过地址登入后台发现数据写入的位置和格式；那么直接根据源码进行构造payload:&lt;/td&gt;&lt;img src="1" οnerrοr="alert(document.cookie)"&gt;&lt;td&gt;;前端没响应，登入后台会直接弹窗；如果不删除的话每次刷新都会弹
XSS之过滤 直接输入123看源码；发现写入了html中的&lt;p&gt;标签里；虽然写着xss过滤但是试了一下没发现过滤了什么；直接构造payload:&lt;/p&gt;&lt;p οnclick="alert(123)"&gt;;然后点击第二行的文字进行触发
XSS之htmlspecialchars 通过输入123看源码；发现生成了一个&lt;a&gt;标签；链接为输入内容；显示也为输入内容；好了；直接构造payload：javascript:alert(123)
XSS之href输出 输入123看源码；发现和上一关一样；直接构造payload:javascript:alert(123)
XSS之js输出 直接输入123看源码；发现输入的信息在js代码中被一个变量接收了；构造payload:';alert(123)//
DVWA靶场XSS练习 火狐看不到源码；背后逻辑只能猜；真的烧脑；尤其是DOM类型；
XSS(DOM) low 通过选择下拉框中的内容发现url有参数变化；直接在url中对default参数构造payload：&lt;script&gt;alert(123);&lt;/script&gt;;成功弹框并且在下拉框中写入了url编码后的内容；写入时需要展开参数，此时执行了alert(123)
XSS(DOM) Medium 查看页面源码发现没什么变化；不过过滤严重了；
构造payload:&lt;input οnfοcus="alert("xss");"&gt;会出现一个输入框；选中即触发弹窗
XSS(DOM) High 通过抓包利用&amp;截断绕过
通过不断的实验发现这关只允许返回规定好的语言；不能创建；尖括号、引号等都被过滤掉了；
&amp;可以实现截断的作用，通过构造payload:Spanish&amp;&lt;input%20οnfοcus="alert(123)"&gt;通过
XSS(反射型) Low
直接输入&lt;script&gt;alert(123)&lt;/script&gt;
XSS(反射型) Medium 输入123查看源码；找到了数据写入的位置；构造&lt;script&gt;发现被过滤了
构造payload:&lt;img src="1" οnerrοr="alert(123)"&gt;
XSS(反射型) High 构造payload:&lt;/pre&gt;&lt;img src="1" οnerrοr=alert()&gt;//
&lt;pre&gt;标签中的内容被格式化了；无法直接在&lt;pre&gt;标签中执行
XSS(存储型) Low 无任何过滤，直接绕过；内容框绕过
构造payload:&lt;script&gt;alert(123)&lt;/script&gt;
XSS(存储型) Medium 利用bp抓包修改name的值；
构造payload:&lt;svg%20οnlοad=alert(123)&gt;
XSS(存储型) High 利用bp修改名字实现xss攻击;对名字进行修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1179aede9450e81e47deecee34ec107b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c596403791563f4a3eed431fdb535d7c/" rel="bookmark">
			制作一个简单的HTML个人网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今数字化的世界里，拥有一个个人网站已经成为了展示个人品牌、分享作品和信息的必备工具。虽然有各种复杂的内容管理系统（CMS）和平台可以帮助我们快速搭建个人网站，但对于初学者或者想要了解更多技术细节的人来说，从头开始创建一个简单的HTML网站是一个很好的学习与实践的方式。
在这篇文章中，我们将一步步地指导你如何制作一个简单的HTML个人网站。
一、规划和设计
首先，你需要明确你的网站要展示什么内容。考虑你希望在网站上展示的作品、文章、项目、联系方式等。同时，也要考虑网站的布局和设计。你可以使用手绘草图、线框图或者设计工具来帮助你规划网站的结构和设计。
二、创建HTML文件
在你的电脑上创建一个新的文件夹，作为你的网站文件夹。然后在该文件夹中创建一个新的HTML文件。你可以使用任何文本编辑器（如Notepad++、Sublime Text、VS Code等）来创建和编辑HTML文件。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;我的个人网站&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 在这里添加你的内容 --&gt; &lt;/body&gt; &lt;/html&gt; 三、编写HTML代码
在HTML文件中，你需要编写一些基本的标签来构建你的网站。以下是一个简单的HTML结构示例：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;我的个人网站&lt;/title&gt; &lt;style&gt; body { font-family: Arial, sans-serif; margin: 20px; padding: 20px; } header { text-align: center; padding: 20px; background-color: #f2f2f2; } section { margin-top: 20px; } h2 { color: #333; } p { line-height: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c596403791563f4a3eed431fdb535d7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54106db6920d743fbbeb2c44c9c5fb41/" rel="bookmark">
			最简单有效的修改vscode插件安装位置的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode插件默认安装在C盘用户目录下，随着安装的插件数量增加，占用C盘内存较大。这里给出亲测有效的修改插件安装位置的办法。
将默认安装路径（一般是C:\Users\你的用户名.vscode）下的extensions文件夹剪切到想放的目录下，比如放在D:.vscode下面。
建议不要将插件路径放到vscode的安装目录下，因为vscode更新刷新安装目录，会导致非安装时创建的文件被删除。以管理员身份运行命令管理行窗口，通过mklink /D命令创建软连接（注意，必须是管理员权限，否则会提示权限不足）
格式：mklink /D “C:\Users\你的用户名.vscode\extensions” “剪切后的路径” mklink /D "C:\Users\用户名\.vscode\extensions" "D:\.vscode\extensions" 运行成功后会有快捷方式已创建的相关提示。
可以看到，原安装目录下的extensions文件夹变成了快捷方式，原.vscode文件夹的大小只有几KB。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44d5eafb8c4d98a21960588717ee56f7/" rel="bookmark">
			聊聊 FTP、SFTP、FTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 FTP概述两种工作方式FTP、SFTP、FTPSSFTP和FTPS的区别命令详解SFTPFTP 个人简介 FTP概述 文件传送协议FTP(File Transfer Protocol)是TCP/IP协议簇中的一个成员，也是现在因特网上最广泛的文件传送协议。FTP协议包括两个部分，一个是FTP客户端，另一个是FTP服务器。当然，FTP服务器是用来存储文件资源的，FTP客户端通过访问FTP服务器来获得资源的。 两种工作方式 一般情况下，当使用FTP服务的时候，我们都知道默认是21号端口，其实还有一个20号端口。FTP使用两个TCP连接，21号端口负责控制连接，20号端口负责数据连接，这样才不会混乱，是FTP可以更好的为我们服务。FTP协议的工作方式可以分为主动方式和被动方式两种，主动是指FTP客户端发送PORT命令连接FTP服务器，被动是FTP客户端发送PASV命令连接FTP服务器。主动方式：在通过21号端口连接好控制通道后，客户端发送给服务器PORT命令，就是给服务器说咱们俩通信你可以在那个端口进行，于是服务器打开20号端口，连接上客户端的指定的端口进行连接，传送数据。需要创建一个新的连接。被动方式：在通过21号端口连接好控制通道后，客户端发送给服务器PASV命令，就是给服务器说咱们俩通信的端口号你选择，然后服务器随机选择一个端口（大于1024）,FTP客户端连接至此端口，进行通信。不需要创建一个新的连接。 FTP、SFTP、FTPS FTP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。FTPS是在安全套接层使用标准的FTP协议和指令的一种增强型FTP协议，为FTP协议和数据通道增加了SSL安全功能。FTPS也称作“FTP-SSL”和“FTP-over-SSL”。SSL是一个在客户机和具有SSL功能的服务器之间的安全连接中对数据进行加密和解密的协议。SFTP是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的加密方法。sftp 与 ftp 有着几乎一样的语法和功能。SFTP 为 SSH的一部分，是一种传输档案至 Blogger 伺服器的安全方式。 SFTP和FTPS的区别 SFTP 和FTPS都是为ftp连接加密，一个是借助ssl协议加密，一个时借助ssh加密。ssl是为http/smtp等加密设计的，ssh是为telnet/ftp等加密、建立传输通道而设计的。简单的讲：sftp协议是ssh中的一条独立的协议，利用ftp服务器就可以传输数据。而ftps是ftp-over-ssl的意思，即ftp借助ssl协议加密传输，不但要用ftp服务器还要用ssl协议加密。 命令详解 SFTP # 连接 sftp user_name@remote_server_address[:path] -B: buffer_size，制定传输 buffer 的大小，更大的 buffer 会消耗更多的内存，默认为 32768 bytes； -P: port，制定连接的端口号； -R: num_requests，制定一次连接的请求数，可以略微提升传输速度，但是会增加内存的使用量。 # 从远程服务器拉取文件 get /path/remote_file #上传本地文件到服务器 put local_file # 查看远程服务器目录内容 ls # 查看本地目录内容 lls # 执行本地 Shell 命令 ![command] FTP # 登录 ftp host -p ：指定端口 # 下载 get 命令：下载指定文件 mget 命令：下载多个文件 # 上传 put 命令：上传指定文件 mput 命令：上传多个文件 个人简介 👋 你好，我是 Lorin 洛林，一位 Java 后端技术开发者！座右铭：Technology has the power to make the world a better place.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44d5eafb8c4d98a21960588717ee56f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4892a7f5eee1e07486eb8b612fc7bf6/" rel="bookmark">
			Krpano生成的vr,如何解密去掉域名的限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		krpano加密都会有域名的限制，如果换域名的话显示就会出现问题，并且加密的代码不利于我们的学习
下面是我的处理过程：
1.需要下载一个工具： KRPano插件一键解密大师 – KRPano技术解密
2.输入vr的网址，然后回车，等着页面加载出来以后 右键解密该网站全部的XML/js
3.把请求的tour.js换成你解密以后的
4.把里面的xml换成你下载下来的
5.换成任何的域名项目依然能跑起来
注：文件的替换过程需要结合自己的项目去实现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5febe4eed5c548440d071b3e5d953d/" rel="bookmark">
			RabbitMQ系列之死信交换机的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉🎉欢迎来到我的CSDN主页！🎉🎉
🏅我是君易--鑨，一个在CSDN分享笔记的博主。📚📚
🌟推荐给大家我的博客专栏《RabbitMQ系列之死信交换机的使用》。🎯🎯
🎁如果感觉还不错的话请给我关注加三连吧！🎁🎁
前言 在我们上一期的RabbitMQ博客系列的分享中我们分享了有关RabbitMQ中交换机的使用，其中讲解到什么是交换机，以及交换机的类型。主要讲述了直连交换机、主题交换机、扇形交换机的示例使用，还有一个死信交换机的示例使用没有讲到，本期博客就针对与死信交互机详细的讲解一下。
一、死信交换机的简介 1. 简单概述 死信交换机（Dead-Letter-Exchange，简称DLX）是 RabbitMQ 的一种消息机制，用于处理那些无法被正常消费的消息。当消息在一个队列中满足某些条件（如过期、被拒绝等）时，这些消息会被放入死信队列中。如果队列配置了死信交换机属性，这些死信消息会被投递到指定的交换机中，这个交换机就被称为死信交换机。
死信交换机的使用可以帮助避免消息的丢失，并提供了重试和诊断问题的机制。当消息成为死信后，可以将其重新投递到另一个队列中，以便再次尝试消费。此外，死信交换机还可以用于实现延时队列的功能。
当我们发送一个消息到我们的RabbitMQ中，我们的一个消息被消费者拒绝后，可以通过设置requeue参数为false,使其消息成为死信消息并被投递到死信交换机中。死信交换机可以与普通交换机一样绑定队列，将死信路由与他绑定的队列中。通过这种的方式可以实现对问题的诊断和重试消费。
2. 优缺点 死信交换机是一种网络设备，它可以在数据包从一个端口发送到另一个端口时确保数据包的安全性和可靠性。它通常用于安全传输敏感信息，如公司内部的机密文件或政府机构的敏感信息。以下是死信交换机的一些优缺点：
死信交互机的优点 优点说明数据包安全性和可靠性由于数据包不会直接从一个端口发送到另一个端口，攻击者无法窃取数据包并篡改其内容。这确保了数据包的安全性和可靠性。数据包完整性验证当数据包到达死信邮箱时，接收方可以确认接收到的数据包的完整性并进行相关操作。这有助于防止数据包在传输过程中被篡改或损坏。防止拒绝服务攻击死信交换机可以用于防止拒绝服务攻击。在这些攻击中，攻击者会向目标服务器发送大量垃圾流量，以使其崩溃或过载。使用死信交换机可以避免这种情况的发生，因为攻击者无法直接攻击目标服务器，而只能攻击死信交换机上的邮箱地址。 死信交换机的缺点 缺点说明对服务器和数据库性能要求高（要求高）由于死信交换机需要处理大量数据包和请求，因此对服务器和数据库的性能要求较高。如果服务器或数据库性能不足，可能会导致数据包处理延迟或丢失。处理大量订单力不从心（效率低）对于需要处理大量订单的应用程序，死信交换机可能无法满足实时性的要求。由于数据包需要经过多个中间节点，可能会导致处理时间延迟。配置和维护复杂（成本高）死信交换机需要正确配置和持续维护，以确保其正常工作并保持最佳性能。这可能需要较高的技术水平和资源投入。 总之，死信交换机在确保数据包的安全性和可靠性方面非常有用，但在使用过程中需要注意其性能和配置要求。在选择使用死信交换机时，需要根据实际需求和资源状况进行权衡和考虑。
3. 实现的流程 当队列中的消息满足以下情况之一时，可以成为死信：
消费者使用basic.reject或basic.nack声明消费失败，并且消息的requeue参数设置成了false。消息是一个过期消息，超时无人消费。要投递的队列消息满了，最新进来的消息变成死信。 图解说明 模拟业务图解说明 视频讲解 不懂的小伙伴可以观看视频学习了解。
阿里一面——说说RabbitMQ死信队列、延时队列
二、死信交换机实战 1. 创建队列 我们基于上一期博客代码进行实战演示，我们重新创建两个队列用于模拟实现我们的功能，
// 创建两个队列 @Bean // 声明第一个队列 。 public Queue queueA(){ return new Queue("queueA"); } @Bean // 声明第二个队列 public Queue queueB(){ return new Queue("queueB"); } 2. 创建交换机 对应上述的图解我们创建两个交换机，一个是普通交换机，一个是死信交换机。
// 创建两个交换机 一个是死信交换机 一个是普通交换机 @Bean public DirectExchange exchangeA(){ return new DirectExchange("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b5febe4eed5c548440d071b3e5d953d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c741a507b825d9ce5c825cef06624940/" rel="bookmark">
			京东按关键字搜索商品 API(item_search-按关键字搜索商品-onebound.jd.item_search)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		京东提供了API接口供开发者进行商品搜索。要使用这个API，首先需要去京东开放平台注册一个账号并创建一个应用，然后获取到应用的API密钥。
关于按关键字搜索商品的API接口，京东开放平台提供了item_search这个接口。以下是这个接口的基本使用方法：
请求URL: https://api.jd.com/routerjson
请求方法: POST
请求参数:
method: 接口名，固定为item_search。param: 请求参数，是一个JSON字符串。例如： json`{ "keyword": "iPhone 13", "page": 1, "page_size": 10, "sort": "sales", "order": "desc", "area": "0", "price": "0-10000", "catalog_id": "586", "属性": "color=red&amp;weight=heavy" }` 其中：
+ keyword: 搜索关键字。
+ page: 页码，从1开始。
+ page_size: 每页显示的商品数量。
+ sort: 排序方式，如"sales"表示按销量排序，"price"表示按价格排序等。
+ order: 排序方式，"desc"表示降序，"asc"表示升序。
+ area: 地区，根据实际情况填写，如"0"表示全国范围。
+ price: 价格范围，如"0-10000"。
+ catalog_id: 类目ID。
+ 属性: 商品属性，多个属性之间用"&amp;"分隔，如"color=red&amp;weight=heavy"。
返回结果: JSON格式的响应数据，包含了商品列表、总页数等信息。
错误处理: 如果请求失败，返回结果中会包含错误信息。开发者需要根据错误码和错误信息进行处理。
注意事项: 使用API时需要遵守京东开放平台的相关规定，不能违反法律法规和侵犯他人的权益。此外，频繁的请求可能会导致IP被封禁，需要注意控制请求频率。
文档参考: 可以查阅京东开放平台的官方文档获取更多关于API接口的详细信息和使用示例。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36669c6dda12e28c4a1788fc7269b294/" rel="bookmark">
			java安装，从java1.8升级到java11.0，java，javac，javaw，javaws，jdk，jre
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习 PyFlink，需要安装Java11环境，但是本机已经安装了java1.8，在升级的过程中遇到了一些问题，在这里记录一下。
windows下安装JDK11
下载JDK11：https://www.oracle.com/java/technologies/downloads/#java11-windows
选择jdk-11.0.22_windows-x64_bin.exe
安装到 C:\Program Files\Java\jdk-11
发现安装后的目录中没有 jre 目录，运行CMD（以管理员身份，否则会报错）命令：
cd C:\Program Files\Java\jdk-11 bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre JDK和JRE是Java开发和运行工具，其中JDK包含了JRE，但是JRE是可以独立安装的，一般在安装JDK的时候会安装JRE。
由于在Java1.5时，人们觉得版本更新速度很慢，都是1.x.x 的，就直接取后面的数字叫Java5，所以说其实是一种东西，只是叫法不同
JDK：Java SE Development Kit JRE：Java(TM) SE Runtime Environment 设置环境变量，都设置在系统变量
JAVA_HOME：C:\Program Files\Java\jdk-11 CLASSPATH：.;%JAVA_HOME%\lib; Path：%JAVA_HOME%\bin 和 %JAVA_HOME%\jre\bin 重新打开CMD窗口
&gt; java -version java version "1.8.0_201" Java(TM) SE Runtime Environment (build 1.8.0_201-b09) Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode) &gt; javac -version javac 11.0.22 &gt; echo %JAVA_HOME% C:\Program Files\Java\jdk-11 好了，问题出现了，java 程序依然是旧的版本，javac 程序已经是新版本了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36669c6dda12e28c4a1788fc7269b294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10196942c3eacca71de4dfa6355fb604/" rel="bookmark">
			three.js加载的stl模型的坐标位置(postion)与boundingbox计算的位置不一致怎么办?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		three.js加载的stl模型的坐标位置[postion]与boundingbox计算的位置不一致怎么办? 问题原因问题解决运用在项目中 问题原因 在处理Three.js中加载的STL模型时，如果发现模型的坐标位置（通过模型的 position 属性获取）与通过其 BoundingBox 计算出的位置不一致，这通常是因为模型的原点（原始中心点）和它的几何中心不同步造成的。
问题解决 为了解决这个问题，您可以通过以下步骤来调整模型的位置，使其与 BoundingBox 计算的位置一致：
1.加载模型：首先加载STL模型。
2.计算BoundingBox：使用 Box3 对象来计算模型的 BoundingBox。
3.调整模型原点：基于 BoundingBox 的中心点调整模型的原点。这通常涉及将模型的几何体（Geometry）平移到新的中心点。
4.设置模型位置：根据需要设置模型的 position 属性。
下面是一个简化的示例代码，展示了如何根据 BoundingBox 调整模型的原点：
import * as THREE from 'three'; import { STLLoader } from 'three/examples/jsm/loaders/STLLoader.js'; const loader = new STLLoader(); loader.load('path/to/your/model.stl', function (geometry) { // 创建材质 const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 }); // 创建网格（Mesh） const mesh = new THREE.Mesh(geometry, material); // 计算BoundingBox const boundingBox = new THREE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10196942c3eacca71de4dfa6355fb604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/545884e9694426a10c42de2fd22d45c8/" rel="bookmark">
			SQL Server 安装程序无法通过 Windows Update 服务搜索更新。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题 安装SQL2019、2017均提示错误，但是执行下一步可以，安装完成后仍然会提示SQL无法使用。
2.解决办法 需要对Windows 11系统进行设置和调整
2.1 打开计算机管理
2.2 选择服务→ windows 更新（英文版 则是 windows update ）
2.3 将启动类型【手动】变更为【自动】，然后应用+保存。
3.再次安装SQL，更新错误则会跳过，不会在提示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00c5b3ea6e58ca1271c7bebd153f5dbe/" rel="bookmark">
			RabbitMQ系列之交换机的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉🎉欢迎来到我的CSDN主页！🎉🎉
🏅我是君易--鑨，一个在CSDN分享笔记的博主。📚📚
🌟推荐给大家我的博客专栏《RabbitMQ系列之交换机的使用》。🎯🎯
🎁如果感觉还不错的话请给我关注加三连吧！🎁🎁
目录
前言
一、交换机的简介
1. 什么是交换机
2. 交换机的作用
3. 交换机的应用场景
4. 图解说明
5.交换机属性
二、 交换机类型讲解
1. 直连交换机（Direct exchange）
1.1 基本概述
1.2 特点
1.3 缺点
2. 主题交换机（Topic exchange）
2.1 基本概述
2.2 特点
2.3 应用场景
3. 扇形交换机（Fanout exchange）
3.1 基本概述
3.2 特点
3.3 应用场景
4. 首部交换机（Headers exchange）
4.1 基本概述
4.2 特点
4.3 应用场景
5. 默认交换机 5.1 基本概述
6. 死信交换机 6.1 基本概述
6.2 图解说明 6.3 案例图解
​编辑
三 、实战演示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00c5b3ea6e58ca1271c7bebd153f5dbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b1f20ae5e56a783a60e76e572db3ae/" rel="bookmark">
			el-form动态检验无法生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;el-form-item label="状态：" prop="zt" class="bitianxian"&gt; &lt;el-select v-model="ruleForm.zt" placeholder="请选择" @change="emptyztXM()"&gt; &lt;el-option v-for="(item,index) in ZTdata" :key="index" :label="item.label" :value="item.value"&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label="XXX：" :prop="ruleForm.zt=== 1 ? 'byclsl' : 'empty'" &gt; &lt;el-input v-model="ruleForm.byclsl" v-input.float @input="yanzhegn($event,'byclsl')" placeholder="请输入"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="BBBB：" :prop="ruleForm.zt==1?'zgrcll':'empty'" &gt; &lt;el-input v-model.trim="ruleForm.zgrcll" v-input.float @input="yanzhegn($event,'zgrcll')" placeholder="请输入"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; data
rules: { zt: [{ validator: reg_xiala, required: true }], byclsl: [{ validator: reg_kong, required: true }], zgrcll: [{ validator: reg_kong, required: true }], } methods yanzhegn(event,yzname){ if(event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2b1f20ae5e56a783a60e76e572db3ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/087eb3f9ddb22d891be7ce1bb14ed1cd/" rel="bookmark">
			趣学贝叶斯统计：量化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概率理论不仅仅是一个数学概念，更是一种对随机性和不确定性的理解方式。通过量化我们对事件发生的信念，我们能够更准确地预测和解释各种现象。在本章中，我们将探讨事件概率与信念概率，为我们的理论和分析工具箱增添新的维度。
事件概率 计算概率最常见的方法是对事件结果计数。对事件来说，有两组结果很重要。第一组是一个事件（event）的所有可能结果（事件概率）。第二组是你感兴趣的结果的计数（信念概率）。
计算机通常将“真”表示为1，将“假”表示为0。概率同样可以使用这个模型：P(X=0)等同于X=假，P(X=1)则等同于X为真。在0和1之间，存在无限多可能的取值。概率值接近0意味着我们更确定某件事情为假，而概率值接近1则意味着我们更确定某件事情为真。值得注意的是，概率为0.5意味着完全不能确定某件事情是真还是假。
举例:
就以掷硬币这个简单例子来说，可能的结果是硬币落地后正面朝上或反面朝上。第一步是对所有可能的事件进行统计，在这个例子中，有两个：出现正面或出现反面
Ω = { 正面，反面 } \Omega={\{正面，反面\}} Ω={正面，反面}
P ( 正面 ) = { 正面 } { 正面 , 反面 } P(正面)=\frac{ \{正面\}} {\{正面,反面\}} P(正面)={正面,反面}{正面}​
复杂版：
掷2枚硬币时，至少出现一个正面的概率是多少？
Ω = { ( 正面，正面 ) ， ( 正面，反面 ) , ( 反面，反面 ) ， ( 反面，正面 ) } \Omega=\{(正面，正面)，(正面，反面),(反面，反面)，(反面，正面)\} Ω={(正面，正面)，(正面，反面),(反面，反面)，(反面，正面)}
为了计算出至少出现一个正面的概率，需要确认有多少组合符合条件：
( 正面 , 正面 ) , ( 正面 , 反面 ) , ( 反面 , 正面 ) {(正面, 正面), (正面, 反面), (反面, 正面)} (正面,正面),(正面,反面),(反面,正面)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/087eb3f9ddb22d891be7ce1bb14ed1cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4e99cdbbf69caafdb80bbada4a1bdcf/" rel="bookmark">
			『OpenCV-Python|鼠标作画笔』
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Opencv-Python教程链接：https://opencv-python-tutorials.readthedocs.io/
本文主要介绍OpenCV-Python如何将鼠标作画笔绘制圆或者矩形。
示例一：图片上双击的位置绘制一个圆圈 首先创建一个鼠标事件回调函数，鼠标事件发生时就会被执行。鼠标事件可以是鼠标上的任何动作，比如左键按下，左键松开，左键双击等。通过鼠标事件获得与鼠标对应的图片上的坐标。根据这些信息可以做任何想做的事。可以通过执行下列代码查看所有被支持的鼠标事件：
import numpy as np
import cv2 as cv
# mouse callback function
def draw_circle(event,x,y,flags,param):
if event == cv.EVENT_LBUTTONDBLCLK:
b, g, r = np.random.randint(0, 255), np.random.randint(0, 255), np.random.randint(0, 255)
l = np.random.randint(2, 100)
cv.circle(img,(x,y),l,(b, g, r),-1)
# Create a black image, a window and bind the function to window
img = np.zeros((1080,960,3), np.uint8)
cv.namedWindow('image')
cv.setMouseCallback('image',draw_circle)
while(1):
cv.imshow('image',img)
if cv.waitKey(20) &amp; 0xFF == 27:
break
cv.destroyAllWindows()
效果图： 示例二：拖动鼠标时绘制矩形或者是圆圈 这是一个典型的例子，它可以帮助我们更好的理解与构建人机交互式程序，比如物体跟踪，图像分割等。任务是根据选择的模式在拖动鼠标时绘制矩形或者是圆圈（就像画图程序中一样）。因此回调函数包含两部分：一部分画矩形，一部分画圆圈。 将此鼠标回调函数绑定到OpenCV窗口。在主循环中，把按键'm'设置为切换绘制矩形还是圆形。参考以下代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4e99cdbbf69caafdb80bbada4a1bdcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7328e30fd9dc56249e72ec266f2a14/" rel="bookmark">
			报错“ERR! code CERT_HAS_EXPIRED npm ERR! errno CERT_HAS_EXPIRED d, reason: certificate has expired np”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因是npm证书过期
解决方法
解决方法： 1、取消ssl验证： npm config set strict-ssl false 第一步基本上就解决了 2、更换npm镜像源： npm config set registry http://registry.cnpmjs.org npm config set registry http://registry.npm.taobao.org 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/160d60c38e692a432ad9f99c57e160b6/" rel="bookmark">
			vue项目中路由懒加载的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 . vue异步组件技术 ==== 异步加载 vue-router配置路由 , 使用vue的异步组件技术 , 可以实现按需加载 . 但是,这种情况下一个组件生成一个js文件
/* vue异步组件技术 */
{ path: '/home', name: 'home', component: resolve =&gt; require(['@/components/home'],resolve) }, { path: '/index', name: 'Index', component: resolve =&gt; require(['@/components/index'],resolve) }, { path: '/about', name: 'about', component: resolve =&gt; require(['@/components/about'],resolve) } 2.组件懒加载方案二 路由懒加载(使用import) const 组件名=() =&gt; import('组件路径'); // 下面2行代码，没有指定webpackChunkName，每个组件打包成一个js文件。 /* const Home = () =&gt; import('@/components/home') const Index = () =&gt; import('@/components/index') const About = () =&gt; import('@/components/about') */ // 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。 把组件按组分块 const Home = () =&gt; import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/home') const Index = () =&gt; import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/index') const About = () =&gt; import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/about') { path: '/about', component: About }, { path: '/index', component: Index }, { path: '/home', component: Home } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/160d60c38e692a432ad9f99c57e160b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c14bb2e14753d3c93a2b83ddf1a97ca/" rel="bookmark">
			c&#43;&#43; 之Lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lambda表达式 Lambda 表达式是 C++11 引入的一种匿名函数的方式，它允许你在需要函数的地方内联地定义函数，而无需单独命名函数
基本语法如下 [capture clause](parameters) -&gt; return_type { // 函数体 // 可以使用捕获列表中的变量 return expression; // 可选的返回语句 } [捕获列表](参数列表) -&gt; 参数类型 {}; Lambda 表达式由以下部分组成：
捕获列表（Capture clause）
主要用于捕获外部的变量，在 Lambda 表达式中可以访问这些变量。捕获列表可以为空，也可以包含变量列表 [var1, var2, …]。参数列表（Parameters）
这就跟普通函数的参数列表很像，可以为空。返回值类型（return_type）
Lambda表达式可以做到自动推断返回类型，也可以显式的给它自定返回类型。如果函数体只有一条返回语句，可以省略返回类型。函数体（Body）
Lambda 表达式的函数体，包含需要执行的代码。 Lambda表达式简单应用（实现加法的功能） #include &lt;iostream0&gt; using namespace std; int main() { int x = 30; int y = 20; auto add = [](int a, int b) -&gt; int{ return a + b; }; int ret = add(x, y); cout &lt;&lt; ret &lt;&lt; endl; return 0; } 以上就是一个捕获列表为空，的一个Lambda表达式的简单应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c14bb2e14753d3c93a2b83ddf1a97ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfbba4e8d454d00665cfb1712098587b/" rel="bookmark">
			算法练习-螺旋矩阵（思路&#43;流程图&#43;代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		难度参考 难度：中等
分类：数组
难度与分类由我所参与的培训课程提供，但需要注意的是，难度与分类仅供参考。以下内容均为个人笔记，旨在督促自己认真学习。
题目 给定一个正整数n，生成一个包含1到 n^2 所有元素，且元素按【顺时针】顺序螺旋排列的正方形矩阵。
示例1:
输入：n=3
输出：[[1,2,3]，[8,9,4]，[7,6,5]]
思路 题目要求生成一个顺时针螺旋排列的正方形矩阵，矩阵元素从1到n^2逐个递增。
初始化矩阵： 创建一个大小为n×n的矩阵，初始化所有元素为0。
定义边界： 使用四个变量top、bottom、left、right表示当前螺旋的边界。
顺时针填充矩阵： 使用循环，按照从左到右、从上到下、从右到左、从下到上的顺序填充矩阵。
更新边界： 每填充完一个方向后，更新相应的边界，确保下一轮填充在新的边界内进行。
重复步骤3和4： 循环执行步骤3和4，直到矩阵填充完成。
示例 考虑n=3的情况，即生成一个3×3的螺旋矩阵。
1.初始化矩阵：matrix = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]，
matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] 初始边界：top=0, bottom=2, left=0, right=2。
2.从左到右：matrix[0][0]=1, matrix[0][1]=2, matrix[0][2]=3，
matrix = [ [1, 2, 3], [0, 0, 0], [0, 0, 0] ] 更新top=1，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfbba4e8d454d00665cfb1712098587b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/962e4194de2d60c751a5d64d429d483a/" rel="bookmark">
			Vue3 Hooks函数使用及封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 什么是hooks函数？2.封装一个hooks函数不带参数的hooks的封装带参数的hooks的封装 1. 什么是hooks函数？ 将单独功能的js代码抽离出来， 加工成公共函数，从而达到逻辑复用。
有了composition API 意味着我们就可以自定义封装hooks，最终的目的都是进行复用，在Vue2中复用的方式大部分都是采取的mixin，但相比hooks,hooks更清楚复用的功能来源及功能。
2.封装一个hooks函数 hooks封装规范：
新建hooks文件；
新建文件名前缀加上use+上文件里内容的简意；
合理利用Vue提供的响应式函数及生命周期；
暴露出 变量 和 方法 提供外部需要时使用；
如： src/hooks/useSum.ts
意思就是创建一个数据内容的hooks文件
不带参数的hooks的封装 import { ref } from 'vue' export default function () { // 数据 const addSum = ref(0) // 方法 function sum() { addSum.value += 1 } // 向外部提供 东西 return { sum, addSum } } vue文件引入hooks文件
&lt;template&gt; &lt;div class="app"&gt; &lt;el-button type="success" @click="sum"&gt;求和&lt;/el-button&gt; &lt;span&gt;加法等于:{{ addSum }}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/962e4194de2d60c751a5d64d429d483a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1f4e748eed381936aa004dc6fc8cf07/" rel="bookmark">
			2022 大厂面试题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JAVA基础 HASHMAP、HASHTABLE、LINKEDHASHMAP的区别HASHMAP 结构HASHMAP闭环如何产生的CONCURRENTHASH结构HASHMAP1.8之后结构区别线程池参数，线程状态，线程状态的变化过程TreadLocal 结构，为什么引入弱引用？有什么问题？原子类如何实现线程竞争？CAS什么时候退出？ABA问题如何解决？AQS实现原理公平锁和非公平锁的区别，哪个效率更高Syncronized原理（所升级过程）wait/notify和park/unpark的区别多线线程如何有序输出A，B，C讲一讲BIO/AIO/NIO JVM 运行时的数据区类加载过程常用的垃圾回收算法和垃圾回收器G1和CMS区别CMS并发标记失败问题调优经历线上配置解决过的问题用过哪些JVM工具CPU占用率高、内存占用率高符合分析、线程暴涨分析 TOMCAT调优 连接池连接方式NIOJVM配置 SPRING 启动过程实例化Bean过程循环依赖解决方式AOP实现过程Spring事务实现过程事务失效 场景 SPRINGMVC 请求处理过程 SPRINGBOOT 有什么优势SPI原理启动流程自定义Spring boot启动器 MYSQL 常用的存储引擎有哪些explain不同存储引擎的区别事务隔离级别有哪些幻读如何产生的 怎么解决介绍一下mvcc日志有哪些，主要用来做什么binlog和redo log区别binlog里记录了哪些内容锁有哪些？排他锁如何实现索引失效场景聚簇索引和非聚簇索引的区别B树和b+书的区别以及场景索引下推 ICPSQL优化方案SQL执行过程主从同步过程主从同步延迟问题 原因以及解决方案新增一个从节点过程 RPC dubbo SPI负载均衡策略有哪些敏感发现服务提供方宕机优雅宕机启动过程 REDIS 常用数据结构底层数据结构为什么要动态字符串跳表的结构reids什么时候是多线程的？什么时候是单线程的？雪崩、穿透、击穿？解决方案过期策略内存淘汰机制缓存和DB双写 一致性方案(Cache Aside Pattern)并发一致性解决方案（多个客户端同时写一个key）线程模型（NIO IO多路复用）处理请求过程分布式锁的实现原理，以及问题和解决方案锁续命问题主从模式 工作原理读、写、数据同步过程全量复制和增量复制判断依据和过程哨兵模式介绍一下集群结构 工作原理读、写、数据同步过程hash算法(普通hash,一致性HASH,HASH 槽) ZOOKEEPER 集群用的什么算法如何选举的如何保证一致性集群脑裂了解吗？如何解决的zookeeper节点有几种角色，分别起什么作用，zookeeper 读写请求的处理过程zookeeper 同步流程 Linux 如何查看系统内存使用情况如何查看系统CUP信息如何查看网络情况Linux虚拟内存和缓冲区什么概念 算法 红包分配 要求：金额随机，sum分完，个数K 精度0.1判断链表闭环 案例 分布式事务一致性解决方案 TCCseata本地化事务消息中间件限流算法有哪些，优缺点分布式唯一号生成算法秒杀方案防止重复下单如何设计一个高可用，高并发的服务。库存超卖问题如何处理热数据如何处理如何实现单点登录 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/18/">«</a>
	<span class="pagination__item pagination__item--current">19/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/20/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>