<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9baa543b26fbacf6c674d12f2df1156/" rel="bookmark">
			15年IT经验结晶：Spring Boot分布式系统实践文档，深入浅出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 当前，Java后端领域中一个不容忽视的现象是，除了部分老旧项目外，几乎所有的新项目都基于Spring Boot进行开发。这并非偶然，而是因为Spring Boot的易用性和微服务友好的特性使其成为Java后端技术的翘楚。毫不夸张地说，Spring Boot在Java后端领域占据着举足轻重的地位，对于Java程序员来说，掌握它是至关重要的。
通过使用Spring Boot开发框架，我们不仅可以提高开发速度，提升生产效率，从某种意义上说，它更像是解放了程序员的双手。新技术的运用，如Spring Boot，不仅能增强系统的稳定性，更能拓展系统的性能边界。本书正是基于提高开发效率、增强系统性能、推广新技术应用的目标而撰写。
这本书，犹如一座巍峨的知识宝塔，分为三大部分，各具特色。首部篇章，引领我们踏上基础应用的探险之旅，从简单的入门知识出发，逐步深入到数据库的奥秘、界面设计的艺术，直至安全设计的核心策略，每一步都充满了挑战与惊喜。
第二部分则是一次分布式系统和云应用开发的奇妙探险。Spring Boot在这片广袤的领域中，如同一艘驶向知识海洋的航船，带领我们穿越微服务的迷宫，构建出高可用的服务平台。
而第三部分，则是一次对Spring Boot和SpringCloud底层实现的深度探索。从程序加载、自动配置到数据管理，从配置管理、发现服务到负载均衡，每一项技术都仿佛一颗璀璨的星辰，照亮了我们探索技术宇宙的道路。
目录 由于平台文章篇幅限制，细节内容过多，所以只把部分知识点截图出来粗略的介绍，每个小节点里面都有更细化的内容！需要的朋友可在文章末尾获取资料
技术维度 第一部分(1~5章)，针对性地介绍了Spring Boot入门、数据库的使用和访问性能提升、界面设计、安全设计等重要技术知识，以实用性为主，旨在帮助读者快速掌握Spring Boot开发方法和精髓，尽快融入生产实践中。
第1章 Spring Boot入门
在开启Spring Boot的奇妙之旅前，我们需要精心地为其搭建一个良好的开发环境。这就像是为一位尊贵的客人布置舒适的客房，需要我们用心去准备。首先，我们需要邀请JDK这位核心成员加入我们的团队，因为它是运行Spring Boot应用的基础。接下来，选择一个得力的助手——开发工具。在这里，IntelliJ IDEA，它对Spring Boot有着深入的理解和全面的支持，能帮助我们更高效地完成工作。本书中的所有实例也都是基于IDEA创建的。
第2章 在Spring Boot中使用数据库
使用数据库是开发应用程序的基石。借助开发框架，我们得以远离繁复的底层代码，如JDBC或连接池，从而在更高的层次上与数据库交互。而Spring Boot更是将这种便利性推向了新的高度，它以一种前所未有的方式简化了数据库访问。这得益于Spring Boot所包含的强大资源库，为开发者提供了更为简洁的接口，使数据库访问变得轻而易举。
第3章 Spring Boot界面设计
利用Spring Boot框架构建Web界面时，我们依然秉持MVC（模型-视图-控制器）的设计理念，通过分层处理数据管理、事件控制和界面显示，实现多层结构的构建。具体来说，视图作为界面设计核心，主要负责内容的组织和展示。当界面上发生事件时，控制器会接收并处理这些事件。
第4章 提高数据库访问性能
使用关系型数据库的应用系统的性能瓶颈最终还是数据库。随着业务的迅速增长，数据量会不断增大，会逐渐暴露出关系型数据库的弱点，即性能大幅下降。提升关系型数据库的访问性能是开发者的迫切任务。下面从程序开发角度，对提升数据库的访问性进行介绍和探讨。
第5章 Spring Boot安全设计
Web应用的安全管理，主要包括两个方面的内容：一方面是用户身份认证，即用户登录的设计；另一方面是用户授权，即一个用户在一个应用系统中能够执行哪些操作的权限管理。权限管理的设计一般使用角色来管理，即给一个用户赋予哪些角色，这个用户就具有哪些权限。本章主要使用spring-cloud-security来进行安全管理设计。下面首先了解安全设计的依赖配置管理。
实践维度 第二部分(6~9章)，用生产环境中的实际案例讲解了如何使用Spring Boot开发分布式应用和云应用，以及如何用微服务构建高可用的服务平台，实践性极强。
第6章 Spring Boot SSO
一个企业级的应用系统可能存在很多应用系统，每个应用系统都需要设计安全管理，即实现用户的认证和访问授权，但是不可能为每一个应用系统都设计一套安全管理，这样不但耗时耗力，而且要做重复的工作，也不适宜建立统一的用户中心。这就需要使用单点登录( Single Sign On, SSO)的方式来建立一个登录认证系统，并且实现对用户的统一管理。 对于一个开放平台来说，SSO也能为合作伙伴提供用户的身份认证和授权管理。
第7章 使用分布式文件系统
几乎我们提供的实例工程中,最终都使用了打包成jar的方式进行发布，细心的读者可能会提出疑问，如果上传文件，如上传图片，应该怎样保存，保存在哪里？传统的做法一般都保存在Web服务器所在的机器中。这样把工程打包成war的方式进行发布，也是可以的。但是随着业务的日益发展，可能上传的文件会累积得越来越多，单独一台机器往往会不堪重负。对于大型的分布式系统来说，这种情况更加明显，而且再加上一些负载均衡的配置和服务，如果还将上传文件保存在Web服务所在的机器中，会显得越来越不合理，更不用说单台机器的容量和性能的问题。
第8章 云应用开发
2014年6月，Pivotal 团队正式发布了Spring Cloud 1.0.0 版本。Spring Cloud是一套云应用开发工具集，为分布式的微服务开发提供了一整套简单易用的使用工具。Spring Cloud主要包含配置管理、服务发现、动态路由、负载均衡、断路器、安全管理、事件总线、分布式消息等组件的开发工具包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9baa543b26fbacf6c674d12f2df1156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9160d72b5145a2650be4dca680ad8b/" rel="bookmark">
			【SpringBoot】springboot整合mongoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.配置
2.使用
创建实体类
创建MongoDB仓库接口
创建一个控制器
1.配置 创建好springboot工程后
引入mongoDB依赖
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;
&lt;/dependency&gt;
在application.properties中配置MongoDB的连接信息
格式如下：
spring.data.mongodb.uri=mongodb://user:password@localhost:27017/mydatabase
application.yml格式如下
spring:
data:
mongodb:
uri: mongodb://username:password@localhost:27017/myDatabase 2.使用 创建实体类 @Document(collection = "users") public class User { @Id private String id; private String name; private int age; public User(String id, String name, int age) { this.id = id; this.name = name; this.age = age; } public String getId() { return id; } public void setId(String id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc9160d72b5145a2650be4dca680ad8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1448d79c314bf058e482eb3a634ec087/" rel="bookmark">
			第十二章 软件工程（上午题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CMM( 能力成熟度模型 ) CMM 将软件过程改进分为以下五个级别
初始级：杂乱无章，没有明确定义的步骤
可重复级：建立了基本的项目管理过程和实践，有必要的过程准则来重复以前在同类项目中的成功
已定义级：软件过程文档化、标准化
已管理级：制定了软件过程和产品质量的详细度量标准
优化级：加强了质量分析，通过过程质量反馈、新观念、新技术等不断改进
二、 CMMI( 能力成熟度集成模型 ) 阶段式模型，结构类似 CMM ，关注组织的成熟度
初始的，过程不可预测缺乏控制已管理的，过程为项目服务已定义的，过程为组织服务定量管理的，过程已度量和控制优化的，集中于过程改进 连续式模型，关注每个过程域的能力
CL0( 未完成的 ) ：表明过程域的一个或多个目标没有被满足CL1( 已执行的 ) ：过程域特定目标完成，转化可识别的输入目标产品，产生可识别的输出目标产品CL2( 已管理的 ) ：已管理的过程制度化，关注针对单个过程实例的能力CL3( 已定义级 ) ：已定义的过程制度化，关注过程的组织标准化及部署CL4( 定量管理级 ) ：可定量管理的过程制度化CL5( 优化的 ) ：优化的过程制度化，持续改进优化 三、瀑布模型 瀑布模型是将软件生命周期中各个活动，规定为依线性顺序链接的若干阶段模型需求分析 》 设计 》 编码 》 测试 》 运行与维护，由前至后，相互衔接的固定次序瀑布模型假设，一个待开发的系统需求是完整的，简明的，一致的，而且可以先于设计和实现之前完成以项目的阶段评审和文档控制来对开发过程进行指导优点： 容易理解，管理成本低强调开发早期计划，需求调研，和产品测试适合开发需求明确的，大致固定不会随意变更的系统 缺点： 客户必须要完整的，正确的，清晰的表达出需求开始的两到三个阶段很难评估进度接近项目结束时，出现大量的集成和测试工作项目结束之前都不能演示系统能力需求或者设计中的错误，到了项目后期才能发现项目风险控制能力较弱 V 模型是瀑布模型的一个变体，重点在于质量保证活动和沟通，将基本问题逐步细化，实际上执行了一系列测试 四、增量模型 融合了瀑布模型的基本成分，和原型实现的迭代特征，它假设可以将需求分段为一系列的增量，每一个增量可以分别开发第一个增量往往是核心产品，客户对每个增量的使用和评估都作为下一个增量的新特征和功能每个增量均发布一个可操作版本 优点：
具有瀑布模型的所有优点第一个可交付版本所需的成本时间很少开发由增量表示的小系统所承担的风险不大 缺点：
如果没有对用户的变更要求有规划，那么产生的初始增量可能造成后续增量的不稳定管理成本、进度、复杂性 五、演化模型 演化模型是迭代的过程模型，使得软件开发人员能够逐步的开发出更完整的软件版本演化模型特别适合对软件需求缺乏准确认识的情况，典型的演化模型有，原型模型和螺旋模型演化模型与增量模型区别：增量每次开发的时小的功能模块，演化每次开发整个产品 六、原型模型 原型模型比较适合用户需求不清、需求经常发生变化的情况，当系统规模不是很大，也不太复杂时采用比较合适一个原型不必满足目标软件的所有约束，其目的是能快速、低成本的构建原型，迅速的开发出一个看得见摸得着的系统框架步骤：交流沟通 》 快速计划 》 快速设计方式建模 》构建原型 》部署交付和反馈 – 完成后继续循环步骤原型始于沟通其目的是为了定义软件的总体，有效的捕获用户需求原型模式不适合大规模的系统开发 七、螺旋模型 螺旋模型将瀑布模型和演化模型相结合，加入了两个模型都忽略了的风险分析每个螺旋周期和瀑布模型大致相符合每个螺旋周期分为四个步骤 制定计划：确定软件目标，制定实施方案，明确项目开发的限制条件风险分析：识别风险、消除风险实施工程：软件开发、验证阶段性产品用户评估：提出修正建议，制定下一周期开发计划 螺旋模型的特点是加入了风险分析，适合大规模、高风险、需求变化的系统缺点：过多的迭代次数，会增加开发成本，延迟提交时间 八、喷泉模型 喷泉模型是一种以用户需求为动力，以对象作为驱动的模型，适合与面向对象的开发方法喷泉模型克服了瀑布模型不支持软件重用，和多项开发活动集成的局限性喷泉模型的开发过程具有迭代性和无间隙性无间隙是指在开发活动（分析、设计、编码）之间不存在明显边界，允许活动交叉、迭代进行 优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1448d79c314bf058e482eb3a634ec087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a8d409d02f1bafda370bb99ccfd0e4e/" rel="bookmark">
			图像中的对比度/亮度/色相等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客：https://leeguoren.blog.csdn.net/article/details/79038360?spm=1001.2101.3001.6650.10&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-10-79038360-blog-100518667.235%5Ev43%5Epc_blog_bottom_relevance_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-10-79038360-blog-100518667.235%5Ev43%5Epc_blog_bottom_relevance_base3&amp;utm_relevant_index=17
一、对比度 对比度指不同颜色之间的差别。对比度越大，不同颜色之间的反差越大，即所谓黑白分明，对比度过大，图像就会显得很刺眼。对比度越小，不同颜色之间的反差就越小。
对比度描述在给定的物体分辨率下，黑色与白色的区分程度。要使图像看起来轮廓分明，黑色细节需要显示为黑色，白色细节必需显示为白色（参见图1）。黑色和白色信息越趋向于中间灰色，该频率下的对比度越低。明暗线条之间的强度差异越大，对比度越高。
二、亮度
亮度指照射在景物或图像上光线的明暗程度。图像亮度增加时，就会显得耀眼或刺眼，亮度越小时，图像就会显得灰暗。
三、色调：
色调是各种图像色彩模式下原色的明暗程度，级别范围从0到255，共256级色调。例如对灰度图像，当色调级别为255时，就是白色，当级别为0时，就是黑色，中间是各种程度不同的灰色。在RGB模式中，色调代表红、绿、蓝三种原色的明暗程度，对绿色就有淡绿、浅绿、深绿等不同的色调。
色调是指色彩外观的基本倾向。在明度、纯度、色相这三个要素中，某种因素起主导作有用，可以称之为某种色调。
如把色调调低接近红色
四、色相
色相就是颜色，调整色相就是调整景物的颜色，例如，彩虹由红、橙、黄、绿、青、蓝、紫七色组成，那么它就有七种色相。顾名思义即各类色彩的相貌称谓，如大红、普蓝、柠檬黄等。色相是色彩的首要特征，是区别各种不同色彩的最准确的标准。事实上任何黑白灰以外的颜色都有色相的属性，而色相也就是由原色、间色和复色来构成的
五、饱和度
饱和度是指图像颜色的浓度。饱和度越高，颜色越饱满，即所谓的青翠欲滴的感觉。饱和度越低，颜色就会显得越陈旧、惨淡，饱和度为0时，图像就为灰度图像。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0c7db93eeba9096cd92622abeb9843/" rel="bookmark">
			阿里云原生高级架构师笔记：K8S&#43;Spring Cloud实战指南，从入门到精通，全程解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道，Docker 确实好用，但在面对庞大的集群和数以千计的容器时，它似乎显得力不从心。此时，我们的主角 Kubernetes 闪亮登场。接下来，让我们先来了解一下 Kubernetes 的基本概念，然后再深入探讨其实践应用，让我们循序渐进地探索这个强大的工具。
在了解 Kubernetes 的基本概念时，我们将重点关注以下七个方面：
Docker 的管理痛点什么是 K8s？云架构 &amp; 云原生K8s 架构原理K8s 核心组件K8s 的服务注册与发现关键问题 Docker 的管理痛点 如果要将 Docker 应用于庞大规模的业务环境，我们将会面临着一系列严峻的挑战，如编排、管理和调度的难题。为了更好地应对这些问题，我们急需一套先进且灵活的管理系统，对 Docker 和容器进行深度管理。此时，Kubernetes 应势而生！Kubernetes 这个名字源于希腊语，有「舵手」或「飞行员」的意思，寓意着它能够引领我们顺利地驾驭和管理复杂的容器环境。
在2014年，Google向世界开源了Kubernetes项目，这是基于其在大规模生产工作负载运营方面累积的十余年经验，同时汇聚了社区中的卓越理念与实践。K8s，即Kubernetes的简称，用数字8代替了“ubernete”，使得称呼更为简洁。在接下来的描述中，我们将采用这一简称。
什么是 K8s ？ Kubernetes（K8s）是一个既可移植又可扩展的开源平台，它如一座稳固的桥梁，横跨在容器化的工作负载和服务之上，引导着它们安全、有序地前行。K8s 采用声明式配置，让自动化成为可能，极大地提升了管理的便捷性。
更重要的是，K8s 的生态系统如繁星点点，既庞大又充满活力，不断吸引着更多领域的精英加入其中。各种服务、支持和工具如同一道道璀璨的光芒，照亮了K8s 的发展道路，使其在开源世界的舞台上更加耀眼夺目。
通过 K8s 我们可以：
快速部署应用快速扩展应用无缝对接新的应用功能节省资源，优化硬件资源的使用 在探索 Kubernetes（k8s）与 Docker 的学习之路上，我曾深陷迷茫的海洋，犹如一叶孤舟，在无尽的大海中寻找指引的灯塔。各大平台上的学习资料如同散落的珍珠，难以串联起这两个技术的完美融合，让我掌握其中的精髓。然而，天无绝人之路，一份偶然得来的 Docker+Kubernetes 笔记成为了我心中的明灯，照亮了我前进的道路。
这份笔记如同一本航海图，引导我深入浅出地理解 Docker 的奥秘。它更进一步地融合了 Docker、Kubernetes 与 SpringCloud 微服务，为我揭示了如何实现持续部署的秘诀。笔记中详尽的分布式主从构建方案，让我领悟到 Kubernetes 在中小企业项目中的巨大潜力。它不仅仅是一个自动化运维平台，更是一种对服务器资源的极致利用，让服务的无缝迁移成为可能。
这份笔记使我深刻认识到，Kubernetes 不仅可以帮助我们将项目从开发到生产无缝迁移，更能在中小企业的中小型项目中发挥出巨大的价值。它像一位智者，用简洁的语言和生动的实例，让我在这段学习旅程中收获颇丰。它如同璀璨的星辰，指引我在技术的海洋中找到前进的方向，引领我走向更加光明的未来。
第一份笔记：Kubernetes（K8s）学习笔记 由于篇幅原因，为了避免影响到大家的阅读体验，在此只以截图展示部分内容，详细完整版的看文末有免费的获取方式！
理论篇
这么理解集群控制器，能行！ 集群网络详解 集群伸缩原理 认证与调度 集群服务的三个要点和一种实现 镜像拉取这件小事 读懂这一篇，集群节点不下线 节点下线姊妹篇 我们为什么会删除不了集群的命名空间？ 阿里云 ACK 产品安全与配置管理 二分之一活的微服务 半夜两点 Ca 证书过期问题处理情况总结 第二份笔记：使用springcloud和docker实战微服务入门到精通 目录：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd0c7db93eeba9096cd92622abeb9843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c0579f97fa244e0a3fba10ee2298f18/" rel="bookmark">
			Vite&#43;Vue3使用Vue-i18n笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载依赖 vue-i18n yarn add vue-i18n 创建存放语言文件的目录 以及配置文件的配置 我是在src/lang 新建index.ts、cn.ts、en.ts以及test文件夹其中再分别新建cn.ts以及en.ts
/lang/index.ts 用于导出vue-i18n需要的配置对象
import en from "./en.ts"; import zh from "./cn.ts"; const messages = { en, zh, }; const language = ( // 读取本地浏览器语言环境中文 zh-CN 英文 eng (navigator.language ? navigator.language : navigator.userLanguage) || "zh" ).toLowerCase(); export default { fallbackLocale: "zh", legacy: false, // composition API globalInjection: true, //全局生效$t locale: language.split("-")[0] || "zh", // 默认zh翻译 messages, }; /src/lang/en.ts 以及同目录下的cn.ts用于收集模块的语言文件并统一提供给Index.ts导出
import test from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c0579f97fa244e0a3fba10ee2298f18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45c2a79f85ea60bf6dbb8cb4c1360cf6/" rel="bookmark">
			pmp考试是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PMP的全称是Project Management Professional（项目管理专业人士资格认证）。它是由美国项目管理协会(PMI)发起的一项严格评估项目管理人员知识和技能的高品质资格认证考试，旨在为项目管理人员提供统一的行业标准。
在我在其他平台发文时，时常有人私信询问是否有资格报名PMP认证。然而，了解对方的基本学历情况之后，发现有些人担心自己是否符合条件，实际上并不必过分担心。无论是正在攻读硕士学位、持有大专学历、毕业已久，甚至只有19岁，以上这些情况中除了年龄只有19岁的情况外，其他情况都是可以考取PMP认证的。
2024年PMP考试时间：3月、6月、8月、11月， PMP报考条件要求如下：
考生需要完成35个学时（PDU）以上的项目管理PMBOK指南的学习或培训。
对于项目管理经验，你无需过于担心，只要有相关的工作经验即可。
学历方面，满足以下三个条件之一即可：年满23岁、高中毕业满五年、或者大专以上毕业满三年。
PMP为个人带来的好处有很多。首先，它能够提升个人的能力。通过学习PMP知识和理论，个人能够增加项目管理方面的储备，更好地应对工作中的挑战，也能够为升职提供更好的机会。对于求职者来说，PMP证书是一块“敲门砖”，在面试中获得更多机会，并且在谈薪资时具备更多谈判的筹码。此外，PMP备受各大企业的重视，这是因为它能够为公司带来收益并具备一定的价值。
其次，PMP获得了官方的认可。不仅是官方明确提出，在项目经理的评分中，提供PMP证书的项目经理可以获得额外的分数；在竞标中，具备PMP证书以及其他相关资质和能力的项目管理负责人可以获得更高的评分。此外，许多知名企业，如中石油、中石化、国家电网、中国银行、招商银行、中国电信、中国移动、中国核电、IBM、摩托罗拉、HP、强生、东软、华为等，都高度认可PMP，并定期组织员工参加PMP学习与认证。
因此，PMP可以通过提高个人的知识认知、技巧和能力，实践与理论相结合，从而提升项目管理知识。在实际工作中，具备PMP证书的人能够展现出作为项目管理专业人士所具备的能力，能够用行业通用语言分析和解决问题，在与同事和领导的沟通中更好地理解高层管理者考虑问题的方法和思路，从而更有效地完成工作。
当前，国内许多大型企业在招聘时候通常会有一项要求：“具备PMP认证的项目经理优先考虑”。此外，在一些大型招投标活动中，对方项目经理需要具备PMP证书才有资格参与。大家可以通过各大招聘网站进一步搜索，发现人力资源部门通常将PMP证书持有者列为优先录用对象。
根据PMI（PMP认证官方机构）的统计数据显示，在中国一线城市的 IT 和金融行业，PMP认证的项目经理的年薪可达到45-50万元，相当于每月大约3.5万元左右。而在其他行业，PMP认证的项目经理年薪可达到30-35万元，相当于每月大约3万元左右。这意味着通过获得PMP认证可以帮助提升收入水平。
66%的受调查者表示获得PMP认证一年后，年薪有所增长，上涨幅度主要集中在30%以内，也有一部分上涨在50%以上，总体而言，PMP对薪酬的涨幅有较大帮助。
PMP认证所学到的项目管理知识体系具有广泛的应用范围。许多世界知名大公司，例如摩托罗拉、虹志、摩根、惠普、诺基亚、贝尔乃至美国白宫和世界银行，都采用项目管理的模式进行运作。因此，这些组织都聘请拥有PMP证书的专业人员来负责项目管理相关工作。
补充说明一下： PMP学习的是理论知识，知识涵盖面非常广泛，真正靠PMP的理论知识并不能管理好一个项目，还需要很好的实践或者项目管理工作经验，理论是进步的基础。但这也不能成为一些攻击PMP含金量不高言论的依据。我只能说PMP虽然是理论体系知识，但它是 项目管理实践 的基础，学好了项管理体系。项目管理实践才能走的更远。相反没有PMP理论学习考取PMP证书，那你可能进不了项目管理门槛。
备考资料分享如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7314d0488461190b4d8d039250bcab9/" rel="bookmark">
			PMP重考流程与费用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多参加PMP®考试的考生都经历过辛勤的学习过程，特别是那些在毕业几年后才开始备考的人。对大多数人来说，PMP®考试都是一项艰难的任务。尽管PMP®考试的平均通过率超过90%，但仍然有些人无法在首次尝试中通过考试。那么，如果一次没有通过PMP®考试，考试费和培训费是否需要重新支付呢？下面我们将为大家解答这个问题。
PMP®初考费用3900元人民币，补考费用2500元人民币。缴费时间一般在中文报名时间内进行，中文报名一般在考前两个月左右，一般考试时间为3月、6月、9月、12月，预计四次PMP®报名缴费时间为1月、4月、7月、11月。（2024年考试安排是3、6、8、11月）
首先在国内报考PMP®需要通过在PMI网站注册，而注册的时间有效期为一年。也就是一次注册有一年的时间可以报考国内的PMP®考试。国内PMP®考试一年为四次，如果我们1月份注册，可以顺利报考参加3月份的考试。如果3月份的考试没有通过，那么可以参加6月份的补考，这是第一次补考。之后还有9月、12月的考试，都是本年度内的PMP®考试。也就是说PMP®考试如果在3月份考试未通过的情况下，可以参加3次补考。 学员是不用重新交培训费的。
PMP®考试重考流程包括确认考试资格、填写重考申请表、登录考试报名网站进行再次报名并缴纳重考费用。具体流程如下：
1. 确认自己在PMI注册的资料是否在有效期内。有些学员在注册后并未立即参加临近的PMP®考试，可能在注册有效期即将结束时才准备参加考试。若在此次考试未通过，想要参加重考，就需要重新注册才能进行正式考试的报名。
2. 填写重考申请表，并由PMP培训机构协助提交给考试的官方机构。
3. 等待下一次PMP®考试报名开始，登录外专局培训机构中心项目管理网站，进行PMP®考试的再次报名。
4. 若在资格有效期内，所有考试都未通过，考生需等待最后一次考试结束后一年的时间才能重新申请认证考试。
总结而言，初次未通过PMP®考试并不要紧，应该对不通过的原因进行反思，并保留充足的时间来认真准备补考。务必熟悉考试所涵盖的知识点，有针对性地进行题库刷题，并坚持下去，胜利就会属于你！
备考资料分享如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f460d7b401876b555a13fd3944d07fb6/" rel="bookmark">
			小白都会的幻兽帕鲁服务器搭建教程（详细图文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：
由于幻兽帕鲁游戏的火爆，导致其官方服务器频现游戏卡顿掉线，为了能够正常流畅的体验幻兽帕鲁，有不少人都搭建了幻兽帕鲁服务器（私服），网上虽然也有很多幻兽帕鲁服务器搭建教程，但内容专业性有点高，比较适合有技术基础的玩家，对于小白或者第一次搭建游戏私服的用户而言，理解起来还是有点难度的，下面我将会已最简单的方式和白话讲解幻兽帕鲁服务器的搭建全过程，跟着本教程步骤走，会实现你的第一次搭建私服体验。
准备工具：
服务器安装脚本进入游戏 一、选购服务器
由于幻兽帕鲁游戏数据较大，为了保障良好的游戏体验，这里我用的恒创香港云服务器4核16G 10M带宽的，当然也可以选择阿里云，腾讯云这些大厂，配置推荐4核16G或32G，对于内存要求较大。
系统：Ubuntu 22.04-×64
放行端口：UDP 8211
二、登录VNC
这里的账号密码需要用到，点击VNC
2.1、登录VNC
2.2、安装脚本
输入以下安装脚本命令
wget -O - https://pal-server-1251810746.cos.accelerate.myqcloud.com/pal-server/Ubuntu/install.sh|sh 需要注意：幻兽帕鲁属于国外游戏，如果用户使用大陆服务器在搭建游戏服务器时，网络会有所波动导致脚本运行失败，属于正常，因为需要请求steam的服务器，如遇见安装超时等情况，多尝试几次或者换个时间段重新安装即可。
安装完成。
至此，幻兽帕鲁服务器就算搭建完成了。
一键部署脚本执行成功后，会为您创建一个名为pal-server的服务，如果您后续想管理该服务，可以使用以下命令来进行：
# 启动幻兽帕鲁的服务 sudo systemctl start pal-server # 重启幻兽帕鲁的服务 sudo systemctl restart pal-server # 关闭幻兽帕鲁的服务 sudo systemctl stop pal-server # 查询幻兽帕鲁服务的状态 sudo systemctl status pal-server 三、登录游戏（需要本地下载steam，并且幻兽帕鲁游戏需要购买）
3.1、登录steam
接下来，我们登录steam客户端，
3.2、启动幻兽帕鲁游戏
在游戏库中找到palworld/幻兽帕鲁（游戏库没有的，可以直接搜索游戏名称），启动游戏
3.3、选择加入多人游戏（专用服务器）
3.4、输入您已部署的Dedicated Server的IP地址+端口（8211）即可畅快开玩，如需多人联机，让其他玩家输入你的IP地址+端口（8211）即可。
好了，幻兽帕鲁私人服务器搭建到此已经结束，赶快去体验吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1291f555df26d1bd472019d4d670a14b/" rel="bookmark">
			跟着cherno手搓游戏引擎【15】DrawCall的封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标： Application.cpp:把渲染循环里的glad代码封装成自己的类：
#include"ytpch.h" #include "Application.h" #include"Log.h" #include "YOTO/Renderer/Renderer.h" #include"Input.h" namespace YOTO { #define BIND_EVENT_FN(x) std::bind(&amp;x, this, std::placeholders::_1) Application* Application::s_Instance = nullptr; Application::Application() { YT_CORE_ASSERT(!s_Instance, "Application需要为空！") s_Instance = this; //智能指针 m_Window = std::unique_ptr&lt;Window&gt;(Window::Creat()); //设置回调函数 m_Window-&gt;SetEventCallback(BIND_EVENT_FN(Application::OnEvent)); //new一个Layer，放在最后层进行渲染 m_ImGuiLayer = new ImGuiLayer(); PushOverlay(m_ImGuiLayer); //unsigned int id; //glGenBuffers(1, &amp;id); uint32_t indices[3] = { 0,1,2 }; float vertices[3 * 7] = { -0.5f,-0.5f,0.0f, 0.8f,0.2f,0.8f,1.0f, 0.5f,-0.5f,0.0f, 0.2f,0.3f,0.8f,1.0f, 0.0f,0.5f,0.0f, 0.8f,0.8f,0.2f,1.0f, }; m_VertexArray.reset(VertexArray::Create()); std::shared_ptr&lt;VertexBuffer&gt; m_VertexBuffer; m_VertexBuffer.reset(VertexBuffer::Create(vertices, sizeof(vertices))); { BufferLayout setlayout = { {ShaderDataType::Float3,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1291f555df26d1bd472019d4d670a14b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65ecf080b110a5297bda8c8e45b1533/" rel="bookmark">
			雾锁王国多人联机专用服务器推荐！最高支持16人联机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Steam平台24日新上线一款奇幻生存冒险建造动作RPG游戏《ENSHROUDED雾锁王国》，玩家将置身于一个广阔的可编辑改造的体素世界中，在被灾祸笼罩的先祖之地上展开生存之旅。在《雾锁王国》中，玩家可以独自冒险，也可以与最多16名玩家联合作战。
同时雾锁王国还支持自建多人联机专用服务器，官方最高支持16人联机。
官方有发布游戏专用服务器的配置要求，同时在线人数越多对服务器配置要求就越高
4核8G 10M带宽 可以支持6-8人游戏
8核16G 32M带宽 可以支持16人联机
雾锁王国服务端默认游戏端口是15636，默认查询端口是15937，云服务器就自行在控制台安全组添加规则即可
参考价：
阿里云：4核16G10M 26元/月
腾讯云：4核16G12M 32元/月
创建服务器，掌握建筑技巧，一起打造梦想庇护所吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/787c50d8901e1f4e640331e39d692bf1/" rel="bookmark">
			台达dvp16es2plc-qt串口通信协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#ifndef DELTA_DVP_PROTOCOL_H #define DELTA_DVP_PROTOCOL_H #include &lt;QByteArray&gt; class Delta_dvp_protocol { public: Delta_dvp_protocol() = default; static QByteArray set_Y_CMD_5_Bit(int slaveAddress,int address,bool isOn); static QByteArray set_M_CMD_5_Bit(int slaveAddress,int address,bool isOn); static QByteArray set_S_CMD_5_Bit(int slaveAddress,int address,bool isOn); static QByteArray set_T_CMD_5_Bit(int slaveAddress,int address,bool isOn); static QByteArray set_C_CMD_5_Bit(int slaveAddress,int address,bool isOn); static QByteArray read_one_address_X_Bit(int slaveAddress, int address); static QByteArray read_one_address_Y_Bit(int slaveAddress, int address); static QByteArray read_one_address_M_Bit(int slaveAddress, int address); static QByteArray read_one_address_S_Bit(int slaveAddress, int address); static QByteArray read_one_address_T_Bit(int slaveAddress, int address); static QByteArray read_one_address_C_Bit(int slaveAddress, int address); static QByteArray set_D_CMD_6_Word(int slaveAddress,int address,int value); static QByteArray set_T_CMD_6_Word(int slaveAddress,int address,int value); static QByteArray set_C_CMD_6_Word(int slaveAddress,int address,int value); static QByteArray set_C_CMD_6_Word_GreaterThan199(int slaveAddress,int address,int value); static QByteArray read_one_address_D_Word(int slaveAddress, int address); static QByteArray read_one_address_T_Word(int slaveAddress, int address); static QByteArray read_one_address_C_Word(int slaveAddress, int address); static QByteArray set_M_Y_S_T_C_CMD_5_Bit(int slaveAddress,int address,bool isOn,const QString &amp; innerDeviceName); static QByteArray set_M_Y_S_T_C_CMD_F_Bit(int slaveAddress, int address, bool isOn, const QString &amp; innerDeviceName); static QByteArray set_D_T_CMD_6_Word(int slaveAddress,int address,int value, const QString &amp; innerDeviceName); static QByteArray read_one_address_D_T_Word(int slaveAddress,int address,const QString &amp; innerDeviceName); static QByteArray read_one_address_Y_M_S_T_C_X_Bit(int slaveAddress, int address,const QString &amp; innerDeviceName); static void parsingReceiveData(const QByteArray &amp; data); }; #endif // DELTA_DVP_PROTOCOL_H #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/787c50d8901e1f4e640331e39d692bf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d9ae1de817bf42485e0211650c3761/" rel="bookmark">
			NC248:左叶子之和(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.题目描述 2.题目分析 我们以一个二叉树为例
左叶子的特点是什么？
是左节点并且没有左右孩子节点 所以我们用leftnode保存root-&gt;lefe节点，判断条件为leftnode存在，并且不存在leftnode-&gt;left和leftnode-&gt;right，如果满足条件，则将val加到全局变量x中去，x的初始值为0，然后递归root-&gt;right
如果不满足条件，就继续递归root-&gt;left和root-&gt;right
3.代码示例 /** * struct TreeNode { *	int val; *	struct TreeNode *left; *	struct TreeNode *right; *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * }; */ class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param root TreeNode类 * @return int整型 */ int count=0; int sumOfLeftLeaves(TreeNode* root) { if(root==nullptr) return 0; TreeNode* leftnode=root-&gt;left; if(leftnode&amp;&amp;!leftnode-&gt;left&amp;&amp;!leftnode-&gt;right) { count +=leftnode-&gt;val; sumOfLeftLeaves(root-&gt;right); } else { { sumOfLeftLeaves(root-&gt;left); sumOfLeftLeaves(root-&gt;right); } } return count; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ab60e0c66975465826c39915efb98a/" rel="bookmark">
			关于监控的那些事，你有必要了解一下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		监控在整个运维和产品生命周期中扮演着至关重要的角色。其目标是在应用的各个阶段，从程序设计、开发、部署到下线，实现事前预警、事中问题定位和事后问题分析的全方位服务。
一、监控的目的 监控贯穿应用的整个生命周期，服务对象主要包括技术和业务两个方面：
1. 技术 通过监控系统，技术团队能够了解技术环境的实时状态，有助于检测、诊断和解决技术环境中的故障和问题。监控系统在技术层面的目标是提供全面的技术支持。
2. 业务 监控系统最终的目标是为业务提供支持，确保业务的持续开展。因此，监控的目的可以简要概括如下： ● 实现对系统的7*24小时实时监控。 ● 提供及时的系统状态反馈。 ● 保障平台的稳定运行。 ● 确保服务的安全可靠。 ● 保障业务的持续运行。 监控的全面性和及时性使其成为确保系统和业务顺利运行的关键环节。
三、监控的方式 监控的主要方式包括：
1. 健康检查 健康检查针对应用本身的健康状况进行监控，检查服务是否正常存活。
2. 日志 日志是排查问题的主要方式，提供丰富信息用于定位和解决问题。
3. 调用链监控 调用链监控完整呈现一次请求的全部信息，包括服务调用链路、所耗时间等。
4. 指标监控 指标是基于时间序列的离散数据点，通过聚合和计算反映重要指标的趋势。 在这四种监控方式中，健康检查由云平台等基础设施提供，日志一般由独立的日志中心进行采集、存储、计算和查询。调用链监控通常有独立的解决方案进行服务调用的埋点、采集、计算和查询。指标监控则通过抓取目标暴露的指标，清理、聚合数据，并通过展示和告警等方式提供监控信息。 ❝说明：该方案主要针对指标监控❞
四、监控选型 1.健康检查 云平台提供健康检查能力，可在云平台中直接配置。
2.日志 成熟的开源日志解决方案为ELK。
3.调用链监控 常用的调用链监控工具包括skywalking、zikpin、pinpoint、elastic APM、Cat。其中，zikpin和cat对代码有侵入性，而skywalking、pinpoint、elastic APM基于字节码注入技术，对代码没有侵入性。 在云原生环境下，推荐使用skywalking和elastic APM，它们支持多种语言，且无代码侵入。
五、监控应用选择 1. 百川云网站监测 长亭百川云网站监测是一款专为有站点监测需求的用户打造的 SaaS 应用，致力于解决用户互联网风险监测难题的 SaaS 化订阅服务产品。可实现对网络质量、页面性能、入侵篡改、内容违规、挂马暗链、SSL 证书等场景进行周期性监控，支持多维度分析性能指标。利用可视化性能数据和告警通知，帮助用户及时对业务质量作出反应，保证业务稳定正常运行。 监控类型包括： ● 可用性监控 ● 稳定性监控 ● 内容合规监控：敏感内容+内容篡改 ● 安全监控：暗链监控、挂马监控、dns解析监控 ● 漏洞扫描
2. Prometheus ● 成熟的社区支撑，是CNCF的毕业项目，得到大厂支持。 ● 易于部署和运维，核心只有一个二进制文件，无其他依赖。 ● 采用Pull模型，通过HTTP的Pull方式从各监控目标拉取数据，避免了Push模型的运维难度和压力。 ● 强大的数据模型，支持自定义标签，有助于进行数据聚合和计算。 ● 强大的查询语言PromQL，支持数据查询、聚合、可视化和告警。 ● 完善的生态，提供丰富的接入方案和客户端SDK。 ● 高性能，单一实例可处理数以百计的监控指标。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14ab60e0c66975465826c39915efb98a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc6c22d40488e5091f0b8356f7edafc/" rel="bookmark">
			Shell脚本基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.shell脚本的概念
将要执行的命令按顺序保存到一个文本文件
给该文件可执行权限
可结合各种shell控制语句以完成更复杂的操作
2.shell脚本应用场景
重复性操作
交互性任务
批量事务处理
服务运行状态监控
定时任务执行
.....
3.shell的作用
命令解释器，“翻译官”
介于系统内核与用户之间，负责解释命令行
用户登录后默认使用的shell程序，一般为 /bin/bash
不同shell的内部指令，运行环境等会有所区别
通过/etc/shells 文件可以了解当前系统所支持的 Shell 脚本种类
查看当前的系统支持的shell
bash:基于gun的框架下发展的shell
csh:类似c语言的shell
tcsh:整合了csh提供了更多功能
sh:已经被bash替换
nologin:让用户无法登录
4.shell脚本的构成
① 解释器 （脚本是用什么语言写的)
第一行开头 #！/bin/bash 表示此行以下的代码语句是通过/bin/bash程序来解释执行。
是默认的解释器，还有其他类型的解释器，#！/bin/python #！/bin/expect
②注释 （解释语句的含义）
以#开头的语句表示为注释信息 # 注 释
③ 执行语句
比如echo命令用于输出“ ”之间的字符串
5.如何执行脚本
①使用路径执行 （需要加执行权限）
②直接使用解释器 （不需要权限）
③source和 . 执行 （不需要权限）
使用前两种方式执行脚本会开启子bash去执行，一般用这两种
使用source和点 会影响当前的bash环境
6. 脚本错误调试
①命令错误
命令出错不会影响接下来的命令继续
②语法错误
会影响接下来的命令继续
③逻辑错误
只能自己去筛查
bash -n 脚本名称 （不在当前目录下加绝对路径） 检查语法错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddc6c22d40488e5091f0b8356f7edafc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4095c6736819436a974572de30a58dee/" rel="bookmark">
			MySQL运维实战(5.2) charset基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：俊达
mysql多字符集 mysql支持多字符集。一个数据库中可以存储不同字符集的数据，一个表的不同字段可以使用不同的字符集。
mysql&gt; show character set like '%g%'; +---------+---------------------------------+--------------------+--------+ | Charset | Description | Default collation | Maxlen | +---------+---------------------------------+--------------------+--------+ | big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 | | gb18030 | China National Standard GB18030 | gb18030_chinese_ci | 4 | | gb2312 | GB2312 Simplified Chinese | gb2312_chinese_ci | 2 | | gbk | GBK Simplified Chinese | gbk_chinese_ci | 2 | | geostd8 | GEOSTD8 Georgian | geostd8_general_ci | 1 | | greek | ISO 8859-7 Greek | greek_general_ci | 1 | +---------+---------------------------------+--------------------+--------+ 6 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4095c6736819436a974572de30a58dee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ddd79f99a01ea4f46e7f5ae1c051746/" rel="bookmark">
			MySQL数据库-理论基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 什么是数据库 数据： 描述事物的符号记录， 可以是数字、 文字、图形、图像、声音、语言等，数据有多种形式，它们都可以经过数字化后存入计算机。
数据库： 存储数据的仓库，是长期存放在计算机内、有组织、可共享的大量数据的集合。数据库中的数 据按照一定数据模型组织、描述和存储，具有较小的冗余度，较高的独立性和易扩展性，并为各种用户 共享，总结为以下几点：
数据结构化
数据的共享性高，冗余度低，易扩充
数据独立性高
数据由 DBMS 统一管理和控制（安全性、完整性、并发控制、故障恢复）
1.2 数据库管理系统(DBMS) 数据库系统成熟的标志就是数据库管理系统的出现。数据库管理系统(DataBase ManagermentSystem，简称DBMS)是管理数据库的一个软件，它充当所有数据的知识库，并对它的存储、安全、一致性、并发操作、恢复和访问负责。是对数据库的一种完整和统一的管理和控制机制。
1.3 数据库与文件系统的区别 文件系统： 文件系统是操作系统用于明确存储设备（常见的是磁盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。
数据库系统： 数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称 DBMS。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。
对比区别： 管理对象不同： 文件系统的管理对象是文件，并非直接对数据进行管理，不同的数据结构需要使用不同的文件类型进行保存（举例： txt 文件和 doc 文件不能通过修改文件名完成转换） ；而数据库直接对数据进行存储和管理
存储方式不同：文件系统使用不同的文件将数据分类（.doc/.mp4/.jpg） 保存在外部存储上；数据库系统使用标准统一的数据类型进行数据保存（字母、 数字、符号、时间）
调用数据的方式不同：文件系统使用不同的软件打开不同类型的文件；数据库系统由 DBMS 统一调用和管理。
优缺点总结： 由于 DBMS 的存在，用户不再需要了解数据存储和其他实现的细节，直接通过 DBMS 就能获取数据，为数据的使用带来极大便利。
具有以数据为单位的共享性，具有数据的并发访问能力。 DBMS 保证了在并发访问时数据的一致性。
低延时访问，典型例子就是线下支付系统的应用，支付规模巨大的时候，数据库系统的表现远远优于文件系统。
能够较为频繁的对数据进行修改，在需要频繁修改数据的场景下，数据库系统可以依赖 DBMS 来对数据进行操作且对性能的消耗相比文件系统比较小。
对事务的支持。 DBMS 支持事务，即一系列对数据的操作集合要么都完成， 要么都不完成。在DBMS上对数据的各种操作都是原子级的。
1.4 DBMS支持的数据模型 层次模型 若用图来表示，层次模型是一棵倒立的树。在数据库中，满足一下条件的数据模型称为层次模型：
有且仅有一个节点无父节点，这个节点称为根节点
其他节点有且仅有一个父节点。桌面型的关系模型数据库
网状模型 在现实世界中，事物之间的联系更多的是非层次关系的，用层次模型表示非树型结构是很不直接的，网状模型则可以克服这一弊病。网状模型是一个网络。在数据库中，满足以下两个条件的数据模型称为网状模型。A.允许一个以上的节点无父节点；B.一个节点可以有多于一个的父节点。
从以上定义看出，网状模型构成了比层次结构复杂的网状结构，适宜表示多对多的联系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ddd79f99a01ea4f46e7f5ae1c051746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e72acef270a690b49d352e380fd624e/" rel="bookmark">
			Tiff格式图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、参考博客：
TIFF图像文件（三）：图像的Tag_tiff tag-CSDN博客
https://www.cnblogs.com/ybqjymy/p/14155537.html
TIFF数据格式实例分析_astifftagviewer.exe-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e0a871de8e8fb235e304776b6b4e05/" rel="bookmark">
			【Linux】System V 共享内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、System V共享内存的原理共享内存的内核数据结构 二、共享内存的使用1. 创建shmget()系统调用创建shm在命令行中查询共享内存 2. 释放使用命令释放共享内存资源使用shmctl释放共享内存资源 3. 关联4. 去关联 三、用共享内存实现server&amp;client通信 一、System V共享内存的原理 共享内存让不同进程看到同一份资源的方式就是，在物理内存当中申请一块内存空间，然后将这块内存空间分别与各个进程各自的页表之间建立映射，再在虚拟地址空间当中开辟空间并将虚拟地址填充到各自页表的对应位置，使得虚拟地址和物理地址之间建立起对应关系，至此这些进程便看到了同一份物理内存，这块物理内存就叫做共享内存。
共享内存的内核数据结构 在系统当中可能会有大量的进程在进行通信，因此系统当中就可能存在大量的共享内存，那么操作系统必然要对其进行管理，所以共享内存除了在内存当中真正开辟空间之外，系统一定还要为共享内存维护相关的内核数据结构。
共享内存的数据结构如下：
/* Obsolete, used only for backwards compatibility and libc5 compiles */ struct shmid_ds { struct ipc_perm shm_perm; /* operation perms */ int shm_segsz; /* size of segment (bytes) */ __kernel_time_t shm_atime; /* last attach time */ __kernel_time_t shm_dtime; /* last detach time */ __kernel_time_t shm_ctime; /* last change time */ __kernel_ipc_pid_t shm_cpid; /* pid of creator */ __kernel_ipc_pid_t shm_lpid; /* pid of last operator */ unsigned short shm_nattch; /* no.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e0a871de8e8fb235e304776b6b4e05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf6f78db6acc2d12f8ab727f53028c8f/" rel="bookmark">
			K8S搭建（centos）完整版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天行健，君子以自强不息；地势坤，君子以厚德载物。
每个人都有惰性，但不断学习是好好生活的根本，共勉！
文章均为学习整理笔记，分享记录为主，如有错误请指正，共同学习进步。
文章目录 一、环境准备1. 服务器要求2. 服务器参数3. 服务器配置4. 软件参数 二、服务器设置1. 基础参数查看1.1 查看本机ip1.2 查看系统参数1.3 查看内核参数1.4 查看mac address和product_uuid1.5 主机参数查看1.6 端口查看 2. 基础参数设置（每个节点）2.1 防火墙关闭2.2 交换内存swap分区关闭2.3 禁用SELinux2.4 节点互通配置2.4.1 修改主机名称2.4.2 主机名与ip绑定 2.5 时间同步设置2.6 可信列表配置（可跳过，本篇跳过） 三、安装Docker（每个节点）1. 卸载docker2. 安装docker3. 配置docker4. 验证docker版本5. 用户组添加（可跳过，本篇跳过）6 网络模块开机自动加载（可跳过，本篇执行）7. 使桥接流量对iptables可见（可跳过，本篇执行） 四、安装k8s（每个节点）1. 添加kubernetes的镜像仓库2. 安装k8s组件2.1 指定版本安装（本篇执行）2.2 默认安装最新版 3. 设置开机自启4. 查看kubelet状态5. 版本验证6. 配置自动补全命令（可跳过，本篇未执行） 五、初始化（master节点）1. 镜像预拉取1.1 查看所需要镜像1.2 查看镜像仓库地址中的版本列表1.3 拉取镜像 2. 初始化操作3. 重置kubeadm 六、搭建集群（master节点）1. 配置.kube2. 配置.bash_profile3. 配置网络3.1 kube-flannel.yml3.2 网段确认3.3 部署flannel3.4 查看kube-flannel服务状态 4. 查看kubernetes系统状态5. 主节点状态获取6. 集群节点查看 七、节点加入集群1. 加入集群命令获取（主节点）2. 加入集群（从节点）3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf6f78db6acc2d12f8ab727f53028c8f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/6/">«</a>
	<span class="pagination__item pagination__item--current">7/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/8/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>