<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c747f907c02d96bf64a109fb9f85a9a/" rel="bookmark">
			uniapp导出文件给原生插件使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要讲述的是使用uniapp导出单个js文件内容，也就是token，之后插件获取到传到的token进行操作，这个我在网上找了好久，没有类似的需求，所以看文档琢磨出来决定记录下
注意~如果uni要传数据给插件，那么一定要和插件的开发者联系好，因为需要插件的获取操作
1、在uniapp项目的manifest.json文件中找到mp-weixin后添加字段
/* 快应用特有相关 */ "mp-weixin": { "plugins": { "hello-plugin": { "version": "发布插件版本", "provider": "插件的wxid", "export": "导出文件地址plugin.js" } } } 2、创建文件plugin.js我在这直接放在主文件目录下和manifest.json文件同级，我在这定义了一个导出方法专门用于暴露token给插件使用，注意！：如果你自己添加了plugin.js文件，之后你重新编译微信开发者工具发现app.json同级没有这个文件的话，我建议你关闭开发者工具，和hbuilderx后重新编译就能看到了
module.exports = { //定义方法 greeting() { return uni.getStorageSync('token'); } } 3、插件开发者在需要使用token的页面js文件中获取token并且赋值给data中的token字段
requireMiniProgram：插件引入当前使用者小程序。返回使用者小程序通过插件配置中export暴露的方法。
//greeting是uniapp暴露的方法 onload(){ const token = requireMiniProgram().greeting() this.setData({ token: token }) } 最后插件使用者可以通过uniapp传过来的token进行一些判断操作。
文章到此结束，希望对你有所帮助~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f176eb9c8b0b41587d66e96e80f9c6/" rel="bookmark">
			并发漏洞实战1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天测试了一些网站，发现了两个通过并发造成的漏洞，记录一下。 一、
第一个具体位置在购物车
并发之后，购物车添加了三十多个
成功的截图就不放了。
二、第二个在创建地址的位置，我们通过并发，可以一次性产生三十多个地址
我们看到同一时间产生的地址
我感觉这种漏洞在点赞或者其他地方也可能产生。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3383b769739956167a9ade448181632/" rel="bookmark">
			值得关注的5款“企业级低代码开发平台”推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优质的“企业级低代码开发平台”该如何评估？ 企业级低代码作为平台层的一员，其对应的核心价值是：提升应用软件开发效率 和 降低应用软件开发门槛。
由企业级低代码的核心价值还可衍生出两项重要价值：
降低应用软件开发成本；增强企业的敏捷性。 而要评估企业级低代码开发平台是否好用，除了以上2个核心标准以外，还需结合其品牌、产品、技术、服务、安全、价值等方面综合考虑。
随着低代码市场火爆，产品供应剧增，用户陷入选型困难，需要一套科学的、专业的、权威的认证模型。海比研究院邀请清华大学、北京大学、信通院等权威机构的专家参与模型设计工作，打造出一套独家的低代码产品选型评估认证模型，致力于用户能快速、准确地选择产品。
值得关注的5款企业级低代码开发平台推荐！ 结合以上6个评估标准，本人还详细分析了5家企业级低代码开发平台，下面一起来看看他们在品牌、产品、技术、服务、安全、价值等6个方面分别有什么突出的优势与差别吧~
一、织信Informat（企业级低代码开发平台）
1、品牌能力
深圳基石协作科技公司成立于2019年，多年来专注于研发企业内部信息化产品。公司成立至今已先后研发了2款产品：
cornerstone（项目管理平台）织信Informat（企业级低代码平台） 开发这2款企业信息化产品的初衷，主要得益于母公司，其母公司是一家为企业进行信息化软件管理咨询和定制的项目服务公司。主要是为大型客户，包括平安、腾讯、微众银行等企业进行内部核心系统的研发服务。也是基于这些年的项目经验和技术积累，提炼出了一整套低代码开发逻辑，从而创造了织信Informat这个低代码平台。目前在低代码领域也是小有名气。
2、产品能力
织信Informat企业级低代码平台目前通过不断的客户交付，提炼出高度成熟的核心功能模板，比如：
OA办公场景常见的：人员管理、流程审批、绩效考核、okr、日周月报；ERP资源管理常见的：资源流管控，数据整合，企业中台；项目管理场景常见的：项目计划、工作分解、风险预警；CRM管理场景常见的：客户线索、营销工具、合同管理；物联网管理场景常见的：软硬件对接、数据采集、阈值警报；生产管理场景常见的：生产排产、订单处理、人员调整、设备管理等等。 这些场景，织信低代码都能基于客户的个性化需求快速实现，给客户进行专门的配置，并且还能完成和企业原有系统的API集成、关联。 帮助企业进行系统或项目的快速落地。
3、技术能力
织信后端开发采用java开发语言+可视化拖拉拽来实现，这种组合方式能实现其他产品所做不到的功能，无论是对表单功能的扩展和增强，还是对外部数据的对接、获取，还是对于数据的复杂运算、计算，都可以使用织信后端来完成。最后还为具备编程能力的用户提供了一个简单的方法来整合织信数据与任何外部数据，标准的https接口，可以对表单数据进行增、删、改、查操作。
4、服务能力
服务能力作为衡量低代码平台的重要指标。而织信提供服务的体系较为全面，包含人工客服、操作文档、技术文档、在线支持、7×24小时工单反馈等服务。
5、安全能力
织信已获得安全认证组织的“ISO27001”信息安全管理体系认证证书。在部署方式、系统安全机制、权限管理和控制功能等层面都有不错表现，可全方位赋能开发者构建安全的、符合企业规则的企业级应用。并支持本地私有部署、全SSL数据传输、密码强度策略、跨域访问控制、细粒度的用户权限控制等能力。不管是大型企业、还是特定行业企业（如军工、金融等）均可适用。
6、价值能力
可以帮助企业大大节省软件费用、降低定制开发的成本和时间，拥有一个极度灵活和易用的数据中台。核心团队在软件开发行业深耕10余年，大型企业项目经验极其丰富，涉及金融、电商、教育、地产、政府、互联网、物流及新能源等10+主流行业。总累积企业合作客户高达2000多家。其中包含几十家各个行业的头部企业。
二、钉钉宜搭（阿里旗下低代码工具）
1、品牌能力
阿里云是阿里巴巴集团旗下公司，是全球领先的云计算及人工智能科技公司。提供免费试用、云服务器、云数据库、云安全、云企业应用等云计算服务，以及大数据、人工智能服务、精准定制基于场景的行业解决方案。
2、产品能力
宜搭平台可支持信息发布、知识管理、Portal 整合、数据管理、流程审批、移动办公等各种办公应用场景，如：报名登记、调查问卷、财务管理、人力资源管理、行政管理、资产管理、客户管理、工作流转、任务审批等等。
3、技术能力
遵循阿里巴巴技术规约标准，无缝集成达摩院、高德地图、阿里云IOT等算法或产品。
4、服务能力
享有阿里巴巴企业级服务标准，包括：个性化定制：快速搭建、便捷试用、低成本变更；集成钉钉：快速实现组织在线、沟通在线；性能稳定：依托阿里云强大的技术及计算能力，默认提供大数据、高并发的解决方案，承诺99.999%高可用；开放的生态：开发的应用和插件可发布到开放市场。
5、安全能力
在信息安全方面，提供DDoS攻击防御，WEB应用防火墙，接口安全检测等安全服务。
6、价值能力
累积服务客户超6000家，覆盖新零售、医疗、生产制造、能源、教育、酒店六大行业。
三、腾讯云微搭（腾讯云自主研发的低代码工具）
1、品牌能力
腾讯云是腾讯集团倾力打造的云计算品牌，面向全世界各个国家和地区的政府机构、企业组织和个人开发者，提供全球领先的云计算、大数据、人工智能等技术产品与服务，打造丰富的行业解决方案，构建开放共赢的云端生态，推动产业互联网建设，助力各行各业实现数字化升级。
2、产品能力
腾讯云微搭低代码是高效、高性能的拖拽式低代码开发平台，向上连接前端的行业业务，向下连接云计算的海量能力，助力企业垂直上云。微搭通过行业化模板、拖放式组件和可视化配置快速构建多端应用（小程序、H5应用、PC Web 应用等）。
3、技术能力
微搭以云开发作为底层支撑，云原生能力将应用搭建的全链路打通，提供高度开放的开发环境。无需关心服务器、数据库等底层运维和技术架构，具备 Serverless 化的高可用、安全防刷、免流量等能力。
4、服务能力
提供服务的体系全面，包含自助服务、帮助文档、在线支持、7×24小时工单及热线服务。
5、安全能力
产品具有高可用服务能力，保证产品的使用安全，七大安全联合实验室团队，一体化智慧安全管理体系，帮助用户建立系统性的安全防御机制。
6、价值能力
自2021年3月发布以来，腾讯云微搭低代码已经在工业、零售、教育、政务等各行业的商业化落地上得到了验证，高效助力客户完成业务搭建，快速实现运营数字化。
四、数睿数据（无代码开发平台）
1、品牌能力
南京数睿数据科技有限公司成立于2016年，是一家专注于大数据与无代码软件产品的技术与服务提供商，公司聚焦服务规模以上软件企业，推动基于无代码软件平台的智能软件工程的全面落地。
2、产品能力
smardaten是中国首家数据驱动的企业级无代码软件平台，包含三大功能模块：无代码构建：应用原型设计、填报设计、表单视图等；数据平台底座：数据连接器、数据图书馆 、 数 据 交 换 机 等 ； 智 能 化 应 用 ： HCAEngine（超融合分析引擎）、OneSketch（智能草图识别）等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3383b769739956167a9ade448181632/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb312a4fb6f6d257704753b156592fc5/" rel="bookmark">
			CTF-PHP反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTFSHOW-关卡254到258-原生类&amp;POP构造 CTF-254-对象引用执行逻辑 username=xxxxxx&amp;password=xxxxxx
解题思路：触发vipOneKeyGetFlag这个方法，同时让方法中的判断为真才能获取flag。
首先分析代码，查看下方判断，用两个GET方法接受账号密码，然后创建ctfShowUser这个类的对象，调用login这个方法，当该方法将isVip赋值为真时才能触发checkVip方法并返回为真，最后触发vipOneKeyGetFlag获取flag。
可以从login方法入手，当$u和$p等于username和password时，isVip将赋值为true。然后执行checkVip方法返回为true时，最后触发vipOneKeyGetFlag获取flag。
通过代码可以发现username和password的值为xxxxxx,那么直接传递账号密码为xxxxxx，底部直接获取flag
CTF-255-反序列化变量修改 public $isVip=true; $a=new ctfShowUser(); echo urlencode(serialize($a)); Get:username=xxxxxx&amp;password=xxxxxx
Cookie:user=O%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A8%3A%22password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D
该关的源码与上关差距不大，但是在login方法中除了简单比较了一下username和password并没有将isVip改为true，那么在后面的checkVip方法中就无法返回true，无法在vipOneKeyGetFlag方法中获取flag
思路：下方的$user接受的是反序列化，那么可以利用反序列化将isVip的值直接改为true
利用网页工具 菜鸟php工具 将ctfShowUser这个类进行序列化并将isVip的值改为true，获取序列化字符串，使用urlencode编码防止赋值到网页时一些空格或其他数据造成的影响 查看源代码可知道反序列化是在cookie中的user里面的内容，那么访问页面利用burpsuite进行截断，并添加cookie和其中的user，将user值改为序列化字符串，再在url头部进行username和password的传输
放出截断的代码获取flag。
CTF-256-反序列化参数修改 public $username='x'; public $password='y'; public $isVip=true; $a=new ctfShowUser(); echo urlencode(serialize($a)); GET:username=x&amp;password=y
COOKIE:user=O%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A1%3A%22x%22%3Bs%3A8%3A%22password%22%3Bs%3A1%3A%22y%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D
该关的考点非常清楚，在login和vipOneKeyGetFlag两个方法中$u和$p与username和password分别要全等，但是username和password不能全等。
思路：依旧用上一关的办法并且修改掉$username和password$的值即可，然后在x和y中传递与username和password相同的值，那么即可绕过判断。
依旧利用burp截断网页，利用url头传递参数并添加cookie CTF-257-反序列化参数修改&amp;对象调用逻辑 class ctfShowUser{ private $class; public function __construct(){ $this-&gt;class=new backDoor(); } } class backDoor{ private $code='system("cat f*");'; } $b=new ctfShowUser(); echo serialize($b); GET：username=xxxxxx&amp;password=xxxxxx
COOKIE：user=O%3A11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A18%3A%22%00ctfShowUser%00class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A17%3A%22system%28%22cat+f%2A%22%29%3B%22%3B%7D%7D
思路：该关出现了多个类，难度已经偏中等左右。分析代码可以发现有个eval函数，该函数可以将字符串当做JS代码执行，那么就可以从该函数入手。观察代码可以发现__destruct函数调用getInfo这个方法，但是因为ctfShowUser类中的class为info，所以destruct函数指向的info类里的getInfo，那么第一步就是将construct的实例化对象值改为backDoor，使destruct方法调用backDoor这个类中的getInfo从而触发eval函数。在利用eval函数的特性执行hs代码获取falg。
依旧利用网页工具对类进行序列化，将__construct方法的内容改为创建backDoor类的对象，当利用$a实例化ctfShowUser时就会触发__construct方法。根据源码当对象销毁时会执行destruct方法，调用backDoor中的getInfo方法，然后会执行方便eval函数，然后修改code值为JS代码让eval函数执行。
因为这个知道了路径下有flag.php文件，所以直接写上。正常情况下需要利用ls查看当前目录。
为了代码美观，无关的数据已经删掉，因为起不到作用。
将反序列化字符串的url编码写入到cookie中并在get中传递参数，获取flag
CTF-258-反序列化参数修改&amp;对象调用逻辑 &lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb312a4fb6f6d257704753b156592fc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7c010930d700ee85d383fba977d15b2/" rel="bookmark">
			微信小程序页面跳转方式&#43;跳转小程序（直接复制代码可用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 微信小程序跳转页面方法 1.跳转到 tabBar 页面 wx.switchTab({ url: '/index' }) 2.跳转到其他页面（非tabBar页）
//redirectTo方法（会关闭当前页面） wx.redirectTo({ url: '/page'//页面路径 }) //navigateTo方法（不会关闭当前页面并且页面栈最多十层） wx.navigateTo({ url: '/page'//页面路径 }) //reLaunch方法（会关闭所有页面） wx.reLaunch({ url: '/page'//页面路径 }) 3.返回上一页面或返回多级页面
//navigateBack方法（用来返回上一页面或多级页面，并关闭当前页面） wx.navigateBack({ delta: 2 //返回的页面数，1为返回上一页，如果delta大于现有页面数，则返回到首页。 }) 二. 跳转到其他小程序 1.首先需要在当前小程序app.json中定义：需要跳转的小程序的app-id
app.josn
"navigateToMiniProgramAppIdList": [ "*******" //appid ], 第一种方法：wx.navigateToMiniProgram（打开另一个小程序）
wx.navigateToMiniProgram({ appId: '**********', path: 'page/index/index?id=123', //路径和携带的参数 extraData: { foo: 'bar' }, envVersion: 'develop', success(res) { // 打开成功 }, fail(res){ // 打开失败 }, complete(res){ // 调用结束 不管成功还是失败都执行 } /** * appId：跳转到的小程序app-id * path：打开的页面路径，如果为空则打开首页，path 中 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7c010930d700ee85d383fba977d15b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc7e0a49ca3930427017b183c6bd30d/" rel="bookmark">
			[转]为什么要建立数据中台？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接:数据中台都是忽悠人的？ - 知乎
一、中台有什么价值
以行业普遍实践结合国内外数据资产管理的标准规范来说，数据中台需要具备以下几个方面的价值：
1、打通数据孤岛，实现跨系统的数据融合
通过中台打通现有数据孤岛，帮助各业务部门“自助”进行数据归集、融合和分类管理，降低数据准备门槛，缩短数据交付时间，提升数据开发利用成效。
2、治理公共数据，提升数据质量
依托自动智能的数据质量稽核与清洗工具，帮助用户建立常态化的数据质量管控体系，落地“一数一源一码”，提升数据质量，实现数据向优质资产的转变。
3、实现跨部门、跨层级、跨系统的数据共享服务
围绕数据资产目录和数据服务目录，提供公共数据的统一共享服务，同时提供可视化的数据服务发布、订阅和管理工具，帮助用户降低数据服务的开发和维护的成本。
4、支持数据资产的动态盘点与价值发现
通过数据资产一站式动态追踪盘点，快速实时了解核心数据资产的总量、类别、分布、使用等情况，一键检索数据，并根据数据使用情况分析数据价值，实现用户数据资产“看的见，管的了，用的着”。
5、保障数据共享安全合规
符合国家等保2.0标准，实现事前可管、事中可控、事后可查的数据共享安全管控，确保数据获取和使用合法合规。
结合上述价值需求，通过建设数据中台，形成数据资产到业务应用的闭环，实现数据资产化（对内增值）和资产业务化（对外增效）。以GI大数据中台为例，其框架如下图所示：
除了以上基础价值外，针对不用业务场景需求，中台还可提供数据仓库构建、人工智能算法、大数据实时计算、标签指标体系等增值服务能力。
这里还需要强调一点，数据中台只是一套工具，要充分发挥价值，还需要有相应的方法论进行指导，并配套建设数据标准体系、数据质量管理规范、数据共享管理办法等。就像打仗，只给大家配枪，但却不教战术，不讲纪律，肯定是打不了胜仗的。所以数据中台成功实施，离不开专业的数据治理团队以及供应商优质的服务。
二、谁适合使用中台
当我们了解了数据中台的价值，这个问题就容易回答了，先看看你的单位或你的客户是否存在以下问题：
1、数据难以整合利用。单位的核心数据资源散落在不同的部门和业务系统中，数据源结构各异，缺少高效的核心数据归集、整合与分类管理手段，阻碍了数据治理和开发利用。
2、数据质量有待提升。核心数据不一致、不唯一、不规范、不完整，导致数据统计分析不准确、领导难决策、业务难协同。
3、数据共享服务有待加强。单位内外部的数据孤岛普遍存在，这阻碍了跨部门、跨系统的数据共享，降低了资源利用率和数据的可得性。
4、缺少数据资产管理手段。单位核心数据资产的总量、类别、分布、使用、价值等情况不清楚，缺少动态可视化监测管理手段。
5、缺乏安全的数据运营环境。缺少完善的数据安全管理理念和技术，导致共享数据时容易造成泄露与滥用，束缚数据价值的释放。
6、数据展现分析速度慢。原因可能是多方面的，但缺少事前已建好并能及时更新数据的主题分析模型往往是关键原因，这方面类似数仓的作用。
如果存在上述一个以上的问题，就可以考虑上中台，否则还是建议把钱花在其他刀刃上。
总结来说，有需要的用户特点一般有三，一是有一定规模，二是有多个呈烟囱状的信息系统，三是有数据开发利用的需求。
根据这三个特点，可以甄别潜在用户群体如下：
1、省、市、区（县）各级政府单位
2、各类大中型企业和事业单位
3、运营商、电网、金融等涉及海量数据的行业
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afab9e47c5f7f67510052582ea358ff1/" rel="bookmark">
			Nordic 中心设备（central）获取 外围设备（peripheral）设备名 （Device Name）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nordic 中心设备（central）获取 外围设备（peripheral）设备名 （Device Name） 中心设备在扫描到外围设备后，我想知道扫描到设备的设备名称。通过ble_advdata_parse( )可获得外设设备的设备名称，即蓝牙广播名称。
需要的头文件包括：ble_gap.h，ble_advdata.h
在ble_gap_evt_t结构体中有adv_report字段。通过上面的接口可从这个字段中获取到设备名。
typedef struct { uint16_t conn_handle; /**&lt; Connection Handle on which event occurred. */ union /**&lt; union alternative identified by evt_id in enclosing struct. */ { ble_gap_evt_connected_t connected; /**&lt; Connected Event Parameters. */ ble_gap_evt_disconnected_t disconnected; /**&lt; Disconnected Event Parameters. */ ble_gap_evt_conn_param_update_t conn_param_update; /**&lt; Connection Parameter Update Parameters. */ ble_gap_evt_sec_params_request_t sec_params_request; /**&lt; Security Parameters Request Event Parameters. */ ble_gap_evt_sec_info_request_t sec_info_request; /**&lt; Security Information Request Event Parameters.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afab9e47c5f7f67510052582ea358ff1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b2fcd18853084ae0bcc42a704aa9e76/" rel="bookmark">
			js Object 对象 属性和方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MDN Object
Object.keys 返回对象的自身可枚举属性组成的数组Object.valuesObject.entries Object.fromEntries(entries)
Object.getOwnPropertyNames()
包括不可枚举属性但不包括 Symbol 值作为名称的属性
返回数组Object.getOwnPropertySymbols() propertyIsEnumerable 属性是否可枚举 toString [object 构造函数] valueOf 原始值 当遇到需要对象的原始值时，JavaScript 会自动调用它
每个内置的核心对象都会覆盖此方法以返回适当的值。如果对象没有原始值，则 valueOf 将返回对象本身。
对象返回值Array返回数组对象本身。Boolean布尔值。Date存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。Function函数本身。Number数字值。Object对象本身。这是默认情况。String字符串值。Math 和 Error 对象没有 valueOf 方法。 使用 valueOf 将内置对象转换为原始值
toLocaleString 被用于派生对象为了特定语言环境的目的而重载使用
hasOwnProperty / Object.hasOwn 判断对象是否具备属性 Object.hasOwn 意图取代 hasOwnProperty
Object.assign() 对象拼接 targetsources 针对 Object.hasOwnProperty() 返回 true 的属性
相同属性，后者覆盖前者
注：不会完整复制描述信息，如this
Object.create() 基于已有对象（原型）创建 第二个参数可额外配置属性
Object.defineProperty() / Object.defineProperties() 新增/修改属性 objprop / props属性描述符 configurable 可改可删 默认false enumerable 可枚举属性 默认false value writable get set Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b2fcd18853084ae0bcc42a704aa9e76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e25eb7387832a4709c3c2c56ad468fc/" rel="bookmark">
			服务器安装jdk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，下载jdk
Java Downloads | Oracle 中国https://www.oracle.com/cn/java/technologies/downloads/
二，安装路径下解压文件
安装路径
cd /usr/local/java/
解压文件
tar -xvf jdk-8u221-linux-x64.tar.gz
三，配置环境变量
编辑配置文件
vim /etc/profile
进入编辑模式
i
export JAVA_HOME=/usr/local/java/jdk1.8.0_221 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin/:$PATH 保存并退出
wq 使添加内容生效
source /etc/profile
四，其它
任意路径下使用：查看jdk版本信息
java -version
查找安装路径
which java
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431998c1fba24a9162ff181bfa667a62/" rel="bookmark">
			实时操作系统与分时操作系统的含义、特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为CSDN博主「嵌入式小胖」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_37765662/article/details/83018523
1. 什么是实时操作系统？ 实时操作系统（RTOS）是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的操作系统。其特点是及时响应和高可靠性。实时系统又分为硬实时系统和软实时系统，硬实时系统要求在规定的时间内必须完成操作，这是在操作系统设计时保证的；软实时则只要按照任务的优先级，尽可能快地完成操作即可。
2. 什么是分时操作系统？ 使一台计算机同时为几个、几十个甚至几百个用户服务的一种操作系统。把计算机与许多终端用户连接起来，分时操作系统将系统处理机时间与内存空间按一定的时间间隔，轮流地切换给各终端用户的程序使用（时间片的概念）。由于时间间隔很短，每个用户的感觉就像他独占计算机一样。
3. 实时操作系统需要满足哪些特征？ 多任务：由于真实世界的事件的异步性，能够运行许多并发进程或任务是很重要的。多任务提供了一个较好的对真实世界的匹配，因为它允许对应于许多外部事件的多线程执行。系统内核分配CPU给这些任务来获得并发性。
抢占调度：真实世界的事件具有继承的优先级，在分配CPU的时候要注意到这些优先级。基于优先级的抢占调度，任务都被指定了优先级，在能够执行的任务（没有被挂起或正在等待资源）中，优先级最高的任务被分配CPU资源。换句话说，当一个高优先级的任务变为可执行态，它会立即抢占当前正在运行的较低优先级的任务。
任务间的通讯与同步：在一个实时系统中，可能有许多任务作为一个应用的一部分执行。系统必须提供这些任务间的快速且功能强大的通信机制。内核也要提供为了有效地共享不可抢占的资源或临界区所需的同步机制。
任务与中断之间的通信：尽管真实世界的事件通常作为中断方式到来，但为了提供有效的排队、优先化和减少中断延时，我们通常希望在任务级处理相应的工作。所以需要在任务级和中断级之间存在通信。
4. 分时操作系统需要满足哪些特征？ 交互性：用户与系统进行人机对话。 多路性：多用户同时在各自终端上使用同一CPU。 独立性：用户可彼此独立操作，互不干扰，互不混淆。 及时性：用户在短时间内可得到系统的及时回答。 5. 实时操作系统主要应用领域 主要应用于过程控制、数据采集、通信、多媒体信息处理等对时间敏感的场合。例如：机器人的运动控制、无人驾驶等。
6. 分时操作系统主要应用领域 现在流行的PC，服务器都是采用这种运行模式，即把CPU的运行分成若干时间片分别处理不同的运算请求。
7. 常见的实时操作系统有哪些？ vxworks是美国windriver公司于1983年设计开发的高性能、可扩展的实时操作系统，具有嵌入实时应用中最新一代的开发和执行环境，支持市场上几乎所有的处理器，以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演戏、弹道制导、飞机导航等Nucleus是美国accelerated technology incorporated公司研发的产品，是世界上最受欢迎的嵌入式操作系统之一，其特点是约95%的代码用ANSI C编写，因此非常便于移植并能够支持大多数类型的处理器，同时可提供网络、图形用户界面、文件系统等模块支持QNX是加拿大QNX公司出品的一种商用的、遵从POSIX标准规范的类UNIX实时操作系统。QNX是最成功的微内核操作系统之一，在汽车领域得到了极为广泛的应用，如保时捷跑车的音乐和媒体控制系统和美国陆军无人驾驶Crusher坦克的控制系统，还有RIM公司的blackberry playbook平板电脑。具有独一无二的微内核实时平台，实时、稳定、可靠、运行速度极快Windows CE是美国microsoft公司推出的嵌入式操作系统，支持众多的硬件平台，其最主要特点是拥有与桌上型windows家族一致的程序开发界面，因此，桌面操作系统windows家族开发的程序可以直接在windows ce上运行，主要应用于PDA（个人数字助理）、平板电脑、智能手机等消费类电子产品。但嵌入式操作系统追求高效、节省，windows ce在这方便是笨拙的，它占用内存过大，应用程序庞大RT-Linux是美国墨西哥理工学院开发的基于linux的嵌入式实时操作系统，是一款提供源代码、开放式自由软件。rt-linux使用了精巧的内核，并把标准的linux核心作为实时核心的一个进程，同用户的实时进程一起调度。这样对linux内核的改动非常小，并且可以充分利用Linux 下现有的丰富的软件资源uc/oc-ii前身是uc/os，最早于1992年由美国嵌入式系统专家设计开发，目前uc/os-iii也已面世。uc/osii具有执行效率高、占用空间小、实时性能优良和可扩展性强等特点，最小内核可以编译至2KB。UC/OS-II已经移植到了几乎所有知名的CPU上，uc/os-ii也是在国内研究最为广泛的嵌入式实时操作系统之一FreeRTOS是一个使用迷你内核的小型嵌入式实时操作系统。由于嵌入式实时操作系统需占用一定的系统资源（尤其是RAM资源），只有QNX、uc/os-ii、freeRTOS等少数实时操作系统能在小RAM单片机上运行。相对QNX、uc/os-ii等商业操作系统，FreeRTOS操作系统是完全开源的操作系统，具有代码公开、可移植、可裁剪、调度策略灵活的特点，可以方便地移植到各种单片机上运行RT-Thread我国在对嵌入式实时操作系统的研发中也取得了一定的成果。由中国开源社区主导开发的RT-Thread，不仅包含一个实时操作系统内核，更有完整的应用生态体系，包含了与嵌入式实时操作系统相关的各个组件：TCP/IP协议栈，文件系统，Libc接口，图形用户界面等，具有相当大的发展潜力MQX最早源于位于加拿大渥太华市的一家公司。MQX在加载了系统内核、中断管理系统、信号量、队列及存储管理系统等基本服务的情况下，仅占用6KB的ROM存储空间，硬件资源开销较小。MQX同UC/OS-II规模相近，但无论从用户体验上还是系统服务的丰富程度上都远超uc/os-ii 8. 常见的分时操作系统有哪些？ 比如常见的linux和windows都是属于分时操作系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f7a10835719dc4d14bac1411c39e2da/" rel="bookmark">
			计算机二级C语言知识点复习资料，精简版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言知识复习资料 第一章 C语言基本知识
【考点1】C程序
用C语言编写的程序称为C语言源程序，源程序文件后缀名为“.c”。
源程序经编译后生成后缀名为“.obj”的目标文件。
再把目标文件与各种库函数连接起来，生成后缀名为“.exe”可执行文件。
C语言有三种基本结构：顺序结构、选择结构、循环结构。
【考点2】main函数
main函数（又称主函数），是C程序的入口。main后面跟一对小括号和一对花括号，花括号括起来的部分称为main函数的函数体。一个C程序从main函数开始执行，到main函数体执行完结束，而不论main函数在整个程序中的位置如何。每一个程序有且仅有一个main函数，其他函数都是为main函数服务的。
【考点3】存储形式
计算机在电脑中保存数据是采用二进制形式，由0或1构成的二进制称为位（bit），八个位构成一个字节（Byte），1个Byte=8个bit。
二进制、八进制、十六进制转化为十进制采用乘法。
十进制转化为二进制、八进制、十六进制采用除法。
数据的存放位置就是它的地址。
【考点4】注释
是对程序的说明，可出现在程序中任意合适的地方，注释从“/*”开始到最近一个“*/”结束，其间任何内容都不会被计算机执行，注释不可以嵌套。
【考点5】书写格式
每条语句的后面必须有一个分号，分号是语句的一部分。
一行内可写多条语句，一个语句可写在多行上。
【考点6】标识符
是标识名字的有效字符序列，可以理解为C程序中的单词。
标识符的命名规则是：
（1）标识符只能由字母、数字和下划线组成，字母区分大小写。
（2）标识符的第一个字符必须是字母或下划线，不能为数字。
C语言标识符分如下3类：
（1）关键字（保留字）。它们在程序中有固定的含义，不能另作他用。如int、for、switch等。
（2）预定义标识符。预先定义并具有特定含义的标识符。如define、include等。
（3）用户标识符。用户根据需要定义的标识符，符合命名规则且不与关键字相同。
【考点7】常量与变量
常量是指在程序运行过程中，其值不能改变的量。分为整型常量、实型常量、字符常量、字符串常量、符号常量5种。
在程序运行过程中其值可以改变的量称为变量。C语言中没有字符串变量。存放字符串使用字符数组。
【考点8】整型数据
整型常量有十进制、八进制、十六进制三种表示形式，没有二进制形式。
八进制整型常量加前导数字“0”，十进制常量可不加前导数字，也可以加“0O”，十六进制常量加前导“0X”。
整型变量可分为基本整型（int）、短整型（short）、长整型（long）、和无符号整型（unsigned）。一个基本整型占4个字节，长整型占8个字节。。
【考点9】实型数据
实型数据有两种表示形式：小数形式和指数形式。掌握判定指数形式合法性。
实型变量分为单精度型（float）和双精度型（double），单精度型占四个字节。
【考点10】算术运算
算术运算符一共有+、—、*、/、%这五个。求余运算要求运算对象只能为整型，除法运算符两边运算对象都为整型时，运算结果也为整型即舍掉小数部分。
【考点11】强制类型转换
将一个运算对象转换成指定类型，格式为“（类型名）表达式”，注意小括号位置。
【考点12】赋值
赋值运算符为“=”，不同于关系等于“= =”。
赋值表达式格式为：变量名=表达式，赋值运算符左边必须为变量，赋值运算是把赋值运算符右边表达式的值赋给左边变量。
复合赋值运算符是将算术运算符或位运算符与赋值运算符组合在一起组成的运算符，掌握复合赋值表达式转化为赋值表达式的方法。如n+=100可转化为n=n+100。
【考点13】自加自减运算
自加运算符“++”与自减运算符“--”是单目运算符，运算对象必须是变量。
自增自减运算分前缀运算和后缀运算，它们所对应的表达式的值是有区别的，如j=i++;等价于j=i;i=i+1;（先等于后加）;而j=++i;等价于i=i+1;j=i;（先加再等于）。
【考点14】逗号运算
逗号运算符运算优先级最低，可将多个表达式构成一个新的表达式。
第二章 顺序结构
【考点1】运算符、表达式、语句
表达式：运算对象加运算符。
表达式语句：表达式加分号。
运算对象可以是表达式、常量、变量。
赋值表达式：赋值运算符加运算对象。
赋值语句：赋值表达式加分号。
【考点2】运算符的优先级和结合顺序
运算符按参加运算的对象数目可分为单目运算符、双目运算符和三目运算符。
初等运算符优先级别最高，然后依次是单目运算符、算术运算符、关系运算符、逻辑运算符（除逻辑非！）、条件运算符、赋值运算符、逗号运算符。
位运算符优先级介于算术运算符与逻辑运算符之间。结合顺序大多为自左向右，而自右向左的有三个：单目运算符、条件运算符和赋值运算符。
【考点3】printf函数
格式为：printf(输出控制，输出列表)。输出控制是用一对双引号括起来的，包含格式说明和原样信息。输出列表包含若干输出项。
【考点4】printf函数中格式说明
%d对应整型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f7a10835719dc4d14bac1411c39e2da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171c201e303c9abef45f2fb6a2b94932/" rel="bookmark">
			宿主机无法访问docker容器的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker的网络有3中模式
bridgehostnone
经常用的bridge方式，安装docker后默认的bridge是docker0,按常理说在根据docker0建立容器之后，宿主机是可以ping通容器的，并且容器内部也可以访问外部网络。docker0和容器之间采用了evth的网络技术。宿主机和容器以及docker0之间通信如下图： 而我遇到的问题是宿主机ping不通容器，查阅资料，资料见参考文献，才知道是由于 docker 加载内核的bridge.ko 驱动异常，导致docker0 网卡无法转发数据包，也就是系统内核的网桥模块bridge.ko 加载失败导致的。
具体的解决办法就是升级centos系统的内核。
升级centos系统内核的命令：
rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm yum --enablerepo=elrepo-kernel install kernel-ml vim /etc/default/grub 修改 GRUB_DEFAULT=0 grub2-mkconfig -o /boot/grub2/grub.cfg reboot uname -r systemctl restart docker 参考文献 https://blog.csdn.net/weixin_42288415/article/details/105366176https://www.cnblogs.com/xzkzzz/p/9627658.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9fd0f241b123325ad0f614a1784103e/" rel="bookmark">
			Java全栈体系路线（总结不易，持续更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Java全栈工程师&lt;font color=orange&gt;Java基础基础语法面向对象工具类集合框架序列化反射机制注解文件处理设计模式视频教程文档教程练习题面试题GUI模块多线程模块Socket模块JDBC模块数据库操作起步JDBC执行sql数据库进阶操作JDBC进阶视频教程文档教程 JVM教程基础实战并发编程视频教程文档教程 &lt;font color=orange&gt; Javaweb（必须用html、css、js）Servlet（请求响应，域对象，会话追踪）Filter（过滤器的实现）Listener（监听器的实现）JSP（九大内置对象，EL表达式，JSTL标签库）基础视频推荐实战视频推荐文档教程实战项目 &lt;font color=orange&gt; Maven&lt;font color=orange&gt; SSMMybatis视频教程文档教程 Spring视频教程文档教程 SpringMVC视频教程文档教程 SSM整合教程SSM文档教程SSM项目实战 &lt;font color=orange&gt; JfinalJfinal文档教程Jfinal视频教程Jfinal实战 &lt;font color=orange&gt; Spring BootSpring Boot视频教程Spring Boot文档教程Spring Boot实战教程 &lt;font color=orange&gt; Redis为什么用Redis、Redis快再哪里Redis视频教程Redis文档教程 &lt;font color=orange&gt; SwaggerSwagger视频教程 &lt;font color=orange&gt; RabbitMQRabbitMQ视频教程 &lt;font color=orange&gt; ActiveMQActiveMQ视频教程 &lt;font color=orange&gt;GitGit视频教程 &lt;font color=orange&gt;dubbodubbo视频教程 &lt;font color=orange&gt;ZookeeperZookeeper视频教程 &lt;font color=orange&gt;SpringcloudSpringcloud视频教程Springcloud项目实战Springcloud文档教程 &lt;font color=orange&gt;docker容器docker容器视频教程 &lt;font color=orange&gt; K8S（Kubernetes）K8S（Kubernetes）视频教程 数据库&lt;font color=orange&gt;关系型数据库MySQL学习MySQL的完美卸载MySQL面试题核心必看MySQL学习视频推荐 Oracle学习Oracle学习视频推荐 SQLServer学习SQLServer视频推荐 DB2学习DB2学习视频推荐 &lt;font color=orange&gt;非关系型数据库MongoDB学习MongoDB学习视频推荐 Hbase学习Hbase学习视频推荐 Linux&lt;font color=orange&gt; 基础环境搭建&lt;font color=orange&gt;文档教程&lt;font color=orange&gt;Linux学习视频推荐 Go语言&lt;font color=orange&gt;Go语言基础教程&lt;font color=orange&gt;Go语言实战教程 前后端分离学习必备技能&lt;font color=red&gt;Java项目实战教育类电商类管理类社区类/博客类娱乐类社会类小程序模板类微服务类 韩顺平老师主讲 (超全超详细的Java企业级学习）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9fd0f241b123325ad0f614a1784103e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f553cbad05c071a5b3e3300683349a2/" rel="bookmark">
			XShell免费版的安装配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载XShell： Xshell免费版官网下载地址：家庭/学校免费 - NetSarang Website
1.访问XShell官网，填写姓名和邮箱即可获取下载地址
2. 从邮箱复制链接下载
3. 安装Xshell
3-1. 双击运行XShell安装文件，并点击“下一步”
3-2. 点击“我接受许可证协议中的条款”，点击“下一步” 3-3. 点击“浏览”更改默认安装路径，点击“下一步”
3-4. 直接点击“安装”
3-5. 安装完成，点击“完成”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5dc37962f407d66a9fa113154e25946/" rel="bookmark">
			vue中使用MD5加密和base64加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MD5：
安装：npm install --save js-md5 在main.js引入 import md5 from 'js-md5'; Vue.prototype.$md5 = md5; 使用加密： "password": this.$md5(this.loginFrom.pwd) base64：
安装：npm install --save js-base64 当前页面直接引入: let Base64 = require('js-base64').Base64; //使用 password: Base64.encode(this.loginForm.password) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56cb6fb704d4e3f01eb432bffc9e266/" rel="bookmark">
			Java 中经常被提到的 SPI 到底是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 程序员在日常工作中经常会听到 SPI，而且很多框架都使用了 SPI 的技术，那么问题来了，到底什么是 SPI 呢？今天就带大家好好了解一下 SPI。
SPI 概念 SPI 全称是 Service Provider Interface，是一种 JDK 内置的动态加载实现扩展点的机制，通过 SPI 技术我们可以动态获取接口的实现类，不用自己来创建。
这里提到了接口和实现类，那么 SPI 技术上具体有哪些技术细节呢？
接口：需要有一个功能接口；
实现类：接口只是规范，具体的执行需要有实现类才行，所以不可缺少的需要有实现类；
配置文件：要实现 SPI 机制，必须有一个与接口同名的文件存放于类路径下面的 META-INF/services 文件夹中，并且文件中的每一行的内容都是一个实现类的全路径；
类加载器 ServiceLoader：JDK 内置的一个类加载器，用于加载配置文件中的实现类；
举个栗子 上面说了 SPI 的几个概念，接下来就通过一个栗子来带大家感受一下具体的用法。
第一步 创建一个接口，这里我们创建一个解压缩的接口，其中定义了压缩和解压的两个方法。
package com.example.demo.spi; /** * &lt;br&gt; * &lt;b&gt;Function：&lt;/b&gt;&lt;br&gt; * &lt;b&gt;Author：&lt;/b&gt;@author ziyou&lt;br&gt; * &lt;b&gt;Date：&lt;/b&gt;2022-10-08 21:31&lt;br&gt; * &lt;b&gt;Desc：&lt;/b&gt;无&lt;br&gt; */ public interface Compresser { byte[] compress(byte[] bytes); byte[] decompress(byte[] bytes); } 第二步 再写两个对应的实现类，分别是 GzipCompresser.java 和 WinRarCompresser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b56cb6fb704d4e3f01eb432bffc9e266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b495263d8d7186e61334686a4e33fc92/" rel="bookmark">
			Linux网卡的开关与网卡自启设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网卡开关与自启设置
1、启用、禁用网卡有很多种方法。
启用禁用网卡可以使用以下 5 个方法来完成：
1、ifconfig 命令：用于配置网卡。它可以提供网卡的很多信息。
2、ifdown/up 命令：ifdown 命令用于禁用网卡，ifup 命令用于启用网卡。---常用
3、ip 命令：用于管理网卡，用于替代老旧的、不推荐使用的 ifconfig 命令。它和 ifconfig 命令很相似，但是提供了很多 ifconfig 命令所不具有的强大的特性。
4、nmcli 命令：是一个控制 NetworkManager 并报告网络状态的命令行工具。
5、nmtui 命令：是一个与 NetworkManager 交互的、基于 curses 图形库的终端 UI 应用。
（1）ifconfig
ifconfig 网卡名 up/doun
ifup、ifdown ifup 网卡名、ifdown 网卡名
ip ip ilnk set 网卡名 up/down
nmcli nmcli con show
nmcli con up/down
（5）nmtui
nmtui
2、配置网卡自启
vim /etc/sysconfig/network-scripts/ifcfg-ens33
最后刷新网络或重启计算机即可
service network restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99af162b79a40f624fd6a7f6dc9480ac/" rel="bookmark">
			Java 菜单列表转成树形结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作中菜单多的情况，会遇到list列表转为树形结构的菜单，特此记录下利用反射实现
一、实体类中格式 /** * 系统菜单表 */ @ApiModel(value="系统菜单表") @Data public class Menu implements Serializable { private static final long serialVersionUID = 1L; /** * ID */ @TreeField(TreeField.Field.ID) @ApiModelProperty(value = "ID") private String id; @ApiModelProperty(value = "父ID") @TreeField(TreeField.Field.PARENDID) private String parentId; @ApiModelProperty(value = "菜单名称") private String menuName; @ApiModelProperty(value = "菜单路径") private String menuUrl; @ApiModelProperty(value = "图标") private String menuIcon; @ApiModelProperty(value = "子菜单") private List&lt;Menu&gt; children; } 二、自定义注解（通过反射） @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface TreeField { TreeField.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99af162b79a40f624fd6a7f6dc9480ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c658dc3a63a4652813566c0dbdd1c0b/" rel="bookmark">
			naive-ui ngrid自适应布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt;
&lt;div&gt;
&lt;n-divider&gt;Self 响应式&lt;/n-divider&gt;
&lt;n-grid cols="2 400:4 600:6" responsive="self"&gt;
&lt;n-grid-item&gt;
&lt;div class="light-green"&gt;
1 似乎自适应不好用，
&lt;/div&gt;
&lt;/n-grid-item&gt;
&lt;n-grid-item&gt;
&lt;div class="green"&gt;
2
&lt;/div&gt;
&lt;/n-grid-item&gt;
&lt;n-grid-item&gt;
&lt;div class="light-green"&gt;
3
&lt;/div&gt;
&lt;/n-grid-item&gt;
&lt;n-grid-item&gt;
&lt;div class="green"&gt;
4
&lt;/div&gt;
&lt;/n-grid-item&gt;
&lt;n-grid-item&gt;
&lt;div class="light-green"&gt;
5
&lt;/div&gt;
&lt;/n-grid-item&gt;
&lt;n-grid-item&gt;
&lt;div class="green"&gt;
6
&lt;/div&gt;
&lt;/n-grid-item&gt;
&lt;/n-grid&gt;
&lt;NGrid cols="2 s:3 m:4 l:5 xl:6 2xl:6" responsive="screen"&gt;
&lt;NGridItem&gt;
&lt;div class="green"&gt;
cols="2 s:3 m:4 l:5 xl:6 2xl:6" 默认2列 s宽度的时候是3列 m宽度的时候是4列 l的时候是5列 xl的时候是6列 2xl是6列 不过需要 responsive=screen
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c658dc3a63a4652813566c0dbdd1c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d947592b6a1dc06daac89ed2ffdcd17/" rel="bookmark">
			Java编写WebService服务端接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 项目结构 （使用java方式,只需要jdk，不需要添加任何 jar 和依赖）
2 接口
public interface TestService{ String sayHello(String name); } 3 实现类
import javax.jws.WebMethod; import javax.jws.WebParam; import javax.jws.WebResult; import javax.jws.WebService; @WebService public class TestServiceImpl implements TestService{ @WebMethod @WebResult(name = "resultName") @Override public String sayHello(@WebParam(name = "name") String name) { return "say1" +name; } } 4 测试类
import javax.xml.ws.Endpoint; public class StartWebService { public static void main(String[] args) { String address = "http://localhost:9410/ws"; Endpoint.publish(address, new TestServiceImpl()); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d947592b6a1dc06daac89ed2ffdcd17/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/93/">«</a>
	<span class="pagination__item pagination__item--current">94/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/95/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>