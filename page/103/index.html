<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07e85fd3944700a6894909bb3c69b5d2/" rel="bookmark">
			win10查看GPU信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一：打开任务管理器可以直接查看，但有些人任务管理器中可能没有GPU相关信息。
优点：此方式可以同时查看共享GPU和专享GPU的状态。
缺点：当使用GPU训练网络模型时，GPU的内存占用发生变化，但是其使用率却一直为0（不得其解）
方式二（推荐）：通过cmd控制台查看，表格中每项的具体含义参考此博客。
nvidia-smi //查看当前GPU的信息 nvidia-smi.exe -l 5 //每5秒刷新一次，Ctrl+C停止 nvidia-smi.exe -f D:\info.txt //将查询的信息输出到具体的文件中 如果上述的命令无效，则需要添加nvidia-smi.exe文件的环境变量。通常在此目录下：C:\Program Files\NVIDIA Corporation\NVSMI
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f427114e565627d52a57f84b10448999/" rel="bookmark">
			String类地址存放分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 String类解析String c = a + b实现过程存放地址分析JVM内存分析存放地址论证补充 String类 解析String c = a + b实现过程 String a = "hello"; String b = "world"; String c = a + b; //通过字符串的引用拼接 String c2 = "hello" + "world"; //直接通过字符串拼接 首先底层使用StringBuilder在堆中实例化一个对象。然后使用append方法依次拼接字符串。 //底层运行原理 StringBuilder stb = new StringBuild(); stb.append(a); stb.append(b); 存放地址分析 String c = a + b;在创建过程中通过实例化StringBuilder对象产生，所以 c 变量应该指向堆中的对象地址，堆中的对象再指向常量池中的"helloworld"地址。String c2 = “hello” + “world”;为直接拼接的字符串，所以 c2 变量直接指向常量池中的"helloworld"地址。 JVM内存分析 存放地址论证 //对比论证 System.out.println(c == c2); //输出为flase System.out.println(c.equals(c2)); //输出为true 补充 注：如果想让 c 直接指向常量池中字符串地址，可以使用intern()方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f427114e565627d52a57f84b10448999/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/745d84850ff7dfc533e5f9394908f016/" rel="bookmark">
			windows系统重装（绝对干净）、备份还原、引导修复步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、装PE
二、下镜像
三、重装
四、备份与还原
五、引导修复
六、建ESP分区
一、装PE 在此我使用微PE工具箱，是因为这是我用过的PE工具中最干净的一个，不会在装系统时捆绑安装软件，清爽至极。（其他pe工具箱也可以，大同小异）
下载地址： 微PE工具箱 - 下载
方法1. 安装PE到系统（如果没有U盘，或者仅用于自己这一台电脑）
可以改个壁纸，然后点“立即安装进系统”
安装完成
方法2. 安装PE到U盘（随身携带，可以维修任何电脑，只要不是硬件坏了的）
要选择NTFS，可以自定义PE壁纸。
安装完成
安装完成后，插入U盘时，电脑会读出两个盘，EFI为PE盘，勿动
二、下镜像 网站：MSDN： MSDN, 我告诉你 - 做一个安静的工具站
MSDN的镜像来自官方原版，无乱七八糟的广告，选择需要的系统，复制链接，迅雷会自动识别链接地址并进行下载。
此处我选择了multiple版，multiple镜像中集合了多个windows版本（家庭版、学习版等），在安装时可以从中选择，很方便（虽然一般都安装专业版）
三、重装 EFI系统分区（EFI system partition，简写为ESP），ESP是系统引导分区，重装时用于进入PE系统（PE：带有必要功能的 体积最小的windows系统，用于修复/重装/备份/还原 目标系统）
进入PE：
1、如果安装PE到硬盘，则不需要U盘，只需要在开机选择系统时选择微PE；
2、如果使用U盘，插上U盘，电脑开机过程中有提示从硬盘还是U盘进入系统，选择U盘。
3、若没有提示，直接开机进入系统，则重启，并在开启电脑、电脑亮屏前多次点击键盘的BIOS快捷键（一般是键盘最上一排，ESC 或 F几，可百度一下自己电脑型号进BIOS的键） 进入BIOS，修改启动方式为U盘优先，保存退出，再重启电脑。
进入PE后：
使用桌面的Dism++重装系统：
若是如下提示，是因没有ESP分区，就先准备一个引导分区（见六）。有则确定
等待片刻
重启电脑
拔掉U盘，重启亮屏前按快捷键进入BIOS，将boot设置中硬盘设置回来，保存并退出。此时重启即可正常进入安装的系统，出现“你好，我是小娜”或“海内存知己，天涯若比邻”的安装系统界面，跟随指引安装好后就是干干净净的windows了~
可以在显示设置中设置系统文本大小
四、备份与还原 还是PE中的dism++，使用系统备份工具，将系统打包备份为.wim镜像文件，在系统出问题时可以将系统还原到备份时的状态。
还原同上述重装系统步骤，只需要在选择镜像时选择前面备份过的系统镜像（back20220723.wim）即可
五、引导修复 如果安装好了系统，但想起来自己删掉了ESP盘，或者安装时没勾选“添加引导”，导致开机进不了系统，则需要进行引导修复（很简单）：
若是提示如下，是因为没有ESP分区，需要建立一个ESP分区（见六），再引导修复
六、建ESP分区 打开桌面的DiskGenius软件，先从一个分区中拆分300M空间
删除刚才拆分出的空分区，使300M空间保持空闲
为300M空间建立ESP分区
可以取消勾选MSR
点击左上角保存更改，建立ESP分区完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/181028f7e52003b19441743a1922e69d/" rel="bookmark">
			用bat批量启动多个软件/程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用bat批量启动软件可以做什么？
每次开电脑，你可能需要打开一系列软件，如：QQ、微信、词典... 但是你又不想设置这些软件开机自启占用开机时间，这时候你就可以用一个“.bat” 来解决问题。只需要手动打开“.bat”文件，就可以打开一系列你想要打开的软件。
核心代码： start /d "D:\Program Files\Dict" YoudaoDict.exe
步骤：
1. 在桌面新建“打开.txt”文件
2. 找到想要打开的程序对应的目录：右键桌面快捷方式-&gt;属性，复制出“目标”中的内容
3. 将目标中的内容拼接写作命令，写入新建的文本文档中，每个要打开的软件对应一行，如：
start /d "D:\Program Files\Tencent\TIM\Bin" QQScLauncher.exe start /d "D:\Program Files\Tencent\WeChat" WeChat.exe start /d "D:\Program Files\Dict" YoudaoDict.exe 4. 改后缀名 .txt 为 .bat
文件显示后缀名方法：先打开文件资源管理器，在“查看 ”选项卡中勾选“文件扩展名”即可。
5. 双击打开“打开.bat”，QQ、微信、有道词典，就一次性全部打开了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d18f1706ddbb68d9e3f7617e471c8d6/" rel="bookmark">
			nodeJs--fs模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、fs模块是什么二、常用方法fs.read和fs.readFile方法的比较fs.writeFilefs.statfs.mkdirfs.appendFilefs.readdirfs.renamefs.rmdirfs.unlinkfs.copyFile 一、fs模块是什么 跟http模块一样，fs模块也是node的核心模块之一，主要用于对系统文件及目录进行读写操作。
二、常用方法 操作方法打开文件fs.open(path, flags[, mode], callback)文件信息fs.stat(path[, options], callback)新建文件fs.appendFile(path, data[, options], callback)写入文件fs.writeFile(file, data[, options], callback)读取文件fs.read(fd, buffer, offset, length, position, callback)读取文件fs.readFile(path[, options], callback)重命名文件fs.rename(oldPath, newPath, callback)关闭文件fs.close(fd, callback)截取文件fs.ftruncate(fd[, len], callback)删除文件fs.unlink(path, callback)文件存在fs.stat() / fs.access()监听文件fs.watchFile(filename[, options], listener)停止监听fs.unwatchFile(filename[, listener])打开大文件fs.createReadStream(path[, options])写入大文件fs.createWriteStream(path[, options])创建目录fs.mkdir(path[, options], callback)读取目录fs.readdir(path[, options], callback)删除目录fs.rmdir(path, callback) fs.read和fs.readFile方法的比较 fs.read()读取文件数据
语法格式：
fs.read(fd, buffer, offset, length, position, callback)
从文件描述符fd中读取文件数据。
fd - 通过 fs.open() 方法返回的文件描述符。
buffer - 数据写入的缓冲区。
offset - 缓冲区写入的写入偏移量。
length - 要从文件中读取的字节数。
position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d18f1706ddbb68d9e3f7617e471c8d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382ce30306c9de56b2791261c37e9e14/" rel="bookmark">
			Python数据库sqlite3详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提到数据库，大家第一时间想到的可能是 sql 数据库，
这种数据库****非常好用，但是对于新手就不是很容易上手，
需要熟悉一段时间才可以大概掌握。这种数据库在大型的
项目开发过程中用到的地方不会很多，但是一些普通的项目
还是很实用的，大大减少了代码量。
目录
sqlite3数据库
1.需要的模块（只有一个）
2.模块的使用
2.1创建与数据库的连接
2.2创建游标
2.3创建 table
2.4插入数据
2.5查找数据
快乐的coding时间！
最后
sqlite3数据库 sqlite3 数据库是 Python 自带的数据库，甚至不需要额外安装模块，而且操作简单。
Python + Mysql = SQLite
但是这种数据库在网上的教程很少，因为我也是最近才知道，所以找了很长时间的资料，
今天终于找齐了，来总结一下。真的找了好长时间啊
1.需要的模块（只有一个） import sqlite3 2.模块的使用 首先打开我们的编译器（推荐使用vscode，因为数据库文件后缀是 .db，vscode里显示比较清楚）
2.1创建与数据库的连接 先放上代码
conn = sqlite3.connect('test.db') 使用 sqlite3 的 connect 函数可以创建数据库或者连接数据库，
如果这个数据库存在，就连接这个数据库，
如果这个库不存在，就创建数据库。
右边小括号里的是数据库名。
我们把这个保存在变量 conn 里，这个变量名可以自己起
公式：
变量名 = sqlite3.connect( '你要的数据库名.db' ) 2.2创建游标 还是先放代码
cur = conn.cursor() 在 2.1 中，我们创建了与数据库的连接，我们现在还需要一个游标来执行 sql 命令，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/382ce30306c9de56b2791261c37e9e14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0b3996a9bdc30f90ef5a94656894eb/" rel="bookmark">
			Unity场景优化工具：Mesh Baker 基础教程（贴图篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、Mash Baker是什么？
二、使用步骤
1.打开场景
2.将Texture Baker添加到场景中
3.使用Texture Baker生成贴图集
4.烘焙新的模型并使每个模型独立
总结
前言 模型贴图整合是3D游戏中美术资源优化的重要环节，我们通常把多个模型的贴图集成到一张2048大小的贴图集中，以达到减少贴图和材质球的数量来节省资源。但是面对成百上千的模型，纹理贴图，法线贴图，高光贴图等等，每种贴图集合成大图，再分别对一次UV，结果是累死，各种贴图还未必对得上位置……，那使用 Mesh Baker 我们可以批量自动拼合贴图并映射UV，大多数工作只需在 Unity 中来完成，免去在三维软件中手动调整UV的烦恼。话不多说，上教程。
使用后：多个模型共用一个材质球，使用一张大贴图（图片来源网络） 使用前：一个模型对应一个材质球，使用一张小贴图（图片来源网络） 一、Mash Baker是什么？ Mash Baker 用于 Unity 有优化模型场景的一种工具，该工具是为了解决场景模型数量过多导致运行时产生较高的DrawCall而创建的。
以下是官方的对于这款插件的介绍。
提高性能！结合网格和材料以减少批量！ Mesh Baker 是一个强大的工具包，具有灵活的非破坏性工作流程，用于优化道具和场景。 Unity 最著名的优化工具。自 2012 年以来的五星级支持和更新。
* 为道具组创建图集或纹理数组
* 在大型复杂场景中查找、分组和组合网格
* 修改道具预制件以使用图集材料
* 支持 URP、HDRP、标准管道
* 适用于内置和自定义着色器
* 为使用色调的材料创建地图集
* 支持多种材质的道具
* 处理平铺纹理
* 结合自定义并向蒙皮网格添加道具
* 创建可定制的蒙皮网格角色
* 将蒙皮网格与混合形状相结合
* UV、法线、切线自动调整
*光照贴图支持
*混合搭配灵活的工作流程工具
* 运行时 API
二、使用步骤 1.打开场景 如果导入的模型都集中在世界原点，这将不利于我们后面的操作，我们需要把模型分开 分开放置，方便我们后续的操作 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b0b3996a9bdc30f90ef5a94656894eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba415e0a40a5d11c00ed7d47dd5a6094/" rel="bookmark">
			第五篇：开启网络功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部分：
在编译ssd212 demo，并且烧录后，会发现ssd212的网卡不存在。
使用指令：
ifconfig -a 发现有一张网卡eth0,使用以下指令开启网卡
ifconfig eth0 up 通过udhcpc 获取IP
udhcpc -i eth0 -s /etc/init.d/udhcpc.script 例如打印日志：
/ # udhcpc -i eth0 -s /etc/init.d/udhcpc.script udhcpc (v1.20.2) started Setting IP address 0.0.0.0 on eth0 Sending discover... Sending discover... Sending select for 192.168.50.243... Lease of 192.168.50.243 obtained, lease time 86400 Setting IP address 192.168.50.243 on eth0 Deleting routers route: SIOCDELRT: No such process Adding router 192.168.50.1 Recreating /appconfigs/resolv.conf Adding DNS server 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba415e0a40a5d11c00ed7d47dd5a6094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab373a28cda4da291406caf9abf8f64e/" rel="bookmark">
			数据中台为什么要汇聚数据？_光点科技
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据中台是当下大数据领域最前沿的数据建设体系, 它并不是从零开始, 无中生有的，数据中台是传统的数据仓库的一种升级, 是数据采集、建设、管理与使用的一整套体系。
数据汇聚是数据中台必须提供的核心工具，把各种异构网络、异构数据源的数据方便地采集到数据中台中进行集中存储，为后续的加工建模做准备。
一、数据汇聚的概念
数据汇聚就是按照确定的数据分析框架，收集相关数据的过程，它为数据分析提供了素材和依据。
在汇聚数据的时候，通常把数据类型分为一手数据和二手数据这两个类型。其中一手数据主要是指可以通过抽取的方式获得的数据，二手数据主要是指需要通过一定的方式对原始数据进行加工处理最后得到的可以进行使用的数据。
二、数据汇聚的方式
将不同的业务系统的数据加载到数据仓库中。数据汇聚有多种方式，按照数据汇聚的传输方式，可以分为文件传输、数据抽取、内容爬虫等方式。
1.文件传输：文件传输包含系统日志与文件的传输。其中文件方式需要业务系统定时进行数据抽取，需要业务系统改造。很多互联网企业都有自己的海量数据采集工具，多用于系统日志采集，如Hadoop的Chukwa，Cloudera的Flume，Facebook的Scribe等，这些工具均采用分布式架构，能满足每秒数百MB的日志、文件数据采集和传输需求。
2.数据抽取：数据抽取也就是利用接口进行数据抽取。它不需要业务系统改造，适用场景多，主要针对于企业生产经营数据或学科研究数据等保密性要求较高的数据，可以通过与企业或研究机构合作，使用特点系统接口等相关方式采集数据。
3.内容爬虫：内容爬虫也就是网络数据采集它主要针对无法访问数据库，只能访问网页或者API的等方式从网站上获取数据信息。该方法可以将非结构化数据从网页中抽取出来，将其存储为统一的本地数据文件，并以结构化的方式存储。它支持图片、音频、视频等文件或附件的采集，附件与正文可以自动关联。除了网络中包含的内容之外，对于网络流量的采集可以使用DPI或者DFI等带宽管理技术进行处理。
三、数据汇聚的作用
随着大数据越来越被重视，数据汇聚的重要性也变的尤为突出，现如今数据汇聚面临几大难点，数据来源多种多样，数据量大，数据变化快。但数据汇聚平台可服务于数据治理，并且解决数据汇聚难、监控难等问题。
数据汇聚不仅仅是数据采集，它更重要的是构建数据汇聚任务的配置、管理、监控、调度等服务。
四、数据汇聚的意义
将整个数据中台流程比作商品的加工流程，那么对应关系：原材料收集——数据汇聚 （业务系统-&gt;ODS层）材料清洗——清洗整合（ODS层-&gt;DWD层）商品加工——数据融合（DW、DM层）商品出售——数据输出（API服务、数据交换） 数据汇聚在数据中台中是首要关键的第一步，也是计算机与外部物理世界连接的桥梁。
关于光点科技
光点科技是一家在政企数据治理、数据中台建设、数据可视化展示分析方面有着丰富经验的公司。作为国内专业的数据智能解决方案专家，光点科技自成立以来就一直专注于数据产品的研发和落地，服务的客户涉及智慧城市、园区、政府、集团企业、金融、制造、能源、电信、工程、教育、检验检测等多个行业。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38db60a89aab2fe9a873120424b51f3c/" rel="bookmark">
			Source Insight 4.0使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Source Insight是一个功能非常强大的，面向项目的程序编辑器，具有针对C/C ++，C＃，Java，Objective-C等的内置动态分析。Source Insight可实现多文件代码中变量和函数的快速搜索，有利于代码的搜索与阅读，能够轻松地浏览和编辑代码，同时自动显相关信息，轻松跳转到函数的调用者或对变量的引用。
一，Source Insight的安装 Source Insight安装包可以在Source Insight的官方网站获取，可以下载试用版免费使用30天。
也可以从我的网盘获取永久版
链接：https://pan.baidu.com/s/1RXIK2By9kwFrqJXkx4eAig
提取码：drec
运行Source Insight界面如下：
二，Source Insight的使用 1，新建工程 选择 Project → New Project 新建一个工程，输入工程名字和保存工程的路径，然后点击OK，如下图所示：
剩下的选项可以默认设置，然后点击OK，如下图所示：
接下来，在我们新建工程以后，Source Insight 要求我们为所建的工程添加文件，我们可以通过接下来的这个窗口来为工程增加文件。选择需要添加的源代码，上一步中我们已经定位到源代码工程中，所以我们选择Add All，把所有文件添加到工程中，当然也可以自己选择添加，然后勾选上包含下级文件，点击OK，确定，然后关闭即可，如下图所示：
或者
add tree ,不选中Recursively add lower sub-directorries 也可以 为所建的工程添加文件。
需要注意，File Name框中显示的只是Source Insight所能支持的文件（.c .cpp .h等），对于ASM程序和其它文件将不会显示(可以手动添加)。我们可以通过勾选Show only known file types这一选项来选择显示其它类型的文件。
这样我们的新建工程完成就完成了，默认的会显示下图这三个小窗口，可以通过1.这三个按钮来选择打开或者关闭，界面如下所示：
2. 使用ctrl+o 打开右侧文件列表
3.代码同步
在编辑区域中，键盘按下Ctrl，用鼠标单击变量或方法时，会跳到变量或方法的定义。
如果某个变量或者方法是黑色字体表示的，说明它还没有被定义。
当然有时候也不是因为没定义，需要同步一下，Project-&gt;Synchronizing Files。
2，认识工程以及源码阅读 当我们新建好工程之后，可以通过工程窗口来查看或者打开所添加的文件，打开工程中的process.c，左边弹出相应的源程序文本，同时，源程序的文本用不同的颜色表示代码的不同意义。
最左边部分为打开的源程序的结构和变量函数等信息，这个窗口方便我们观察源程序结构并且可以快速定位到变量和函数，并且用不同的图标来表示，如：
表示头文件包含、条件编译等
表示宏定义
表示变量
表示函数
我们定位到process_start函数且选中process结构体变量时，下方Context窗口会显示结构体定义是在哪个文件的哪个位置定义的，双击久可以跳转到对应位置，右下边Relation窗口，也会显示结构体的结构，如下图所示：
3，查找定位及Reference等功能 在进行源程序的阅读中，我们要查看函数变量的定义原型，可以右击选择Jump To Definition来定位，或者点击工具栏中的，当然也可以通过上面提到的Context窗口定位。
然后就是Source Insight中的Reference功能，可以快速找出整个工程中所有的标记，并且在该行程序前加上红色双向箭头快速定位，如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38db60a89aab2fe9a873120424b51f3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a45f5359024b6e002a192efb5a41e3f4/" rel="bookmark">
			kkFileView LibreOffice文件预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档地址: https://gitee.com/kekingcn/file-online-preview/blob/master/README.md
Windows环境下：
点击此处拉取代码
直接导入idea启动
直接启动可能会报找不到office组件，这个时候就需要去下载安装LibreOffice,官方下载地址
双击下载下来的 Libreoffice 程序，全部使用默认安装的方式进行安装，直接点击“下一步”安装完成。
默认Windows的安装路径:C:\Program Files\LibreOffice
将Libreoffice 加入到 Windows系统环境 Path 变量。
加入到系统环境变量中的 Path 变量值：C:\Program Files\LibreOffice\program
cmd到/LibreOffice/program位置下输入启动命令：
soffice -headless -accept="socket,host=127.0.0.1,port=8100;urp;" -nofirststartwizard 最后回到kkFileView代码中，重启，成功，访问127.0.0.1:8012出现演示首页
到这，windows部署kkFileView LibreOffice全部成功，不用改其中的代码，只需要在前端添加上面的两行代码（注意:根据演示页面可以看出“url”后面不是接的访问路径，而是将访问路径转为了base64,进行访问，根据下面的预览测试也能看出）
Linux环境
将拉取的项目进行打包，会出现3个文件
kkFileView-4.1.0-SNAPSHOT.jar（Spring Boot打包后得到jar包）
kkFileView-4.1.0-SNAPSHOT.jar.original（是Maven在Spring Boot重新打包之前创建的原始jar文件）
kkFileView-4.1.0-SNAPSHOT.tar.gz（Linux版本：项目中通过assembly配置，生成的发行项目包，带配置好的启动脚本startup.sh等）
kkFileView-4.1.0-SNAPSHOT.zip（Window版本：项目中通过assembly配置，生成的发行项目包，带配置好的启动脚本startup.bat等）
注意：在配置文件中startup.sh或startup.bat的文件名，可能与IDEA打包生成的文件名不一致，需要自己修改。
打包完成后进行部署
将kkFileView-4.1.0-SNAPSHOT.tar.gz压缩包放到服务器位置进行解压
终端解压后进入bin目录，直接执行：./startup.sh 脚本就运行了
执行：./startup.sh可以查询项目运行的日志，./shutdown.sh结束运行（这些需要注意：执行启动脚本后，会生成kkFileView.pid文件，如果是执行./shutdown.sh结束运行，该文件会自动删除，如果是kill 杀掉该进程，该文件会还存在，需手动删除该文件，不然再次运行启动脚本，它判断到该文件还存在，会报进程在运行）
到这linux部署kkFileView完成，接下来一样部署LibreOffice
官网下载：https://www.libreoffice.org/download/download/
选择linux版本
命令解压：tar -zxvf LibreOffice_6.2.4_Linux_x86-64_rpm.tar.gz
进行安装
进入解压路径;cd LibreOffice_6.2.4_Linux_x86-64_rpm/RPMS
执行安装命令为：su -c’yum install * .rpm’
安装过程中会让你输入，y/N ，输入y 即可
安装成功：安装成功后会在 /opt/ 下生产一个 libreoffice7.2 的文件夹
最后更改环境变量 ：vim /etc/profile
加入（7.2是看自己的版本对应）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a45f5359024b6e002a192efb5a41e3f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4dbb39508c3fc9cc1ca6e78b02bc51e/" rel="bookmark">
			sqlmap使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
sqlmap基础使用
1、判断是否存在注入
2、判断文本中的请求是否存在注入
3、查询当前用户下的所有数据库
4、获取数据库中的表名
5、获取表中的字段名
6、获取字段内容
7、获取数据库所有用户
8、获取数据库用户的密码
9、获取当前网站数据库的名称
10、获取当前网站数据库的用户名称
SQLMap进阶：参数讲解
1、--level 5: 探测等级
2、--is-dba：当前用户是否为管理权限
3、--roles：列出数据库管理员的角色
4、--referer：http referer头
5、--sql-shell运行自定义的sql语句
6、--os-cmd，--os-shell：运行任意操作系统的命令
7、--fire-read：从数据库服务器中读取文件
8、 --fire-write --file-dest：上传文件到数据库服务器中
SQLMap自带绕过脚本tamper
一些常用的tamper脚本：
sqlmap是一个自动化的SQL注入工具，主要功能是扫描、发现，并利用给定url的SQL注入漏洞。
sqlmap基础使用 1、判断是否存在注入 sqlmap.py -u url (如果注入点后面的参数大于等于两个，需要加双引号）
2、判断文本中的请求是否存在注入 Sqlmap.py -r desktop/1.txt 一般在存在cookies注入的情况下使用
3、查询当前用户下的所有数据库 sqlmap.py -u url --dbs 确定网站存在注入后，用于查询当前用户下的所有数据库。如果当前用户有权限读取包含所有数据库列表信息的表，使用该命令就可以列出所有相关数据库。
4、获取数据库中的表名 sqlmap.py -u “url” -D dkeye(具体数据库） --tables 如果不加入-D来指定某一个数据库，那么会列出数据库中的所有的表。继续注入时缩写成—T，在某表中继续查询
5、获取表中的字段名 sqlmap.py -u “url” -D dkeye -T user_info(具体表名） --columns 查询完表名后，查询该表中的字段名，在后续的注入中，—columns缩写成-C
6、获取字段内容 sqlmap.py -u “url” -D dkeye -T user_info(具体表名） -C usrname password(具体字段） --dump 7、获取数据库所有用户 sqlmap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4dbb39508c3fc9cc1ca6e78b02bc51e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df5d96dbb36f0c5c21e419308d9f277/" rel="bookmark">
			关于JavaScript的Object所有方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Object.assign()–复制修改对象 Object.assign() 方法将所有可枚举（Object.propertyIsEnumerable() 返回 true）和自有（Object.hasOwnProperty() 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象
尝试一下
const target = { a: 1, b: 2 }; const source = { b: 4, c: 5 }; const returnedTarget = Object.assign(target, source); console.log(target); // { a: 1, b: 4, c: 5 } console.log(returnedTarget); // { a: 1, b: 4, c: 5 } 语法
Object.assign(target, ...sources) 参数
target 目标对象，接收源对象属性的对象，也是修改后的返回值。sources 源对象，包含将被合并的属性。 返回值
目标对象
2. Object.create()–创建新对象 Object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）
示例
const person = { isHuman: false, printIntroduction: function() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df5d96dbb36f0c5c21e419308d9f277/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a58089bf622cac7d8bda7ad4e90fdbb/" rel="bookmark">
			tomact启动报错：org.apache.catalina.startup.ContextConfig.populateSCIsForCacheEntry(ContextConfig.java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： tomcat7.0.33版本启动项目报错，提示内存溢出，调整JVM内存，还是会偶尔启动报错。
java.util.concurrent.ExecutionException: java.lang.StackOverflowError at java.util.concurrent.FutureTask.report(FutureTask.java:122) at java.util.concurrent.FutureTask.get(FutureTask.java:188) at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:1123) at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:785) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1559) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1549) at java.util.concurrent.FutureTask.run(FutureTask.java:262) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:744) Caused by: java.lang.StackOverflowError at java.util.HashSet.&lt;init&gt;(HashSet.java:102) at org.apache.catalina.startup.ContextConfig.populateSCIsForCacheEntry(ContextConfig.java:2243) at org.apache.catalina.startup.ContextConfig.populateSCIsForCacheEntry(ContextConfig.java:2260) at org.apache.catalina.startup.ContextConfig.populateSCIsForCacheEntry(ContextConfig.java:2260) at org.apache.catalina.startup.ContextConfig.populateSCIsForCacheEntry(ContextConfig.java:2260) at org.apache.catalina.startup.ContextConfig.populateSCIsForCacheEntry(ContextConfig.java:2260) at org.apache.catalina.startup.ContextConfig.populateSCIsForCacheEntry(ContextConfig.java:2260) at org.apache.catalina.startup.ContextConfig.populateSCIsForCacheEntry(ContextConfig.java:2260) at org.apache.catalina.startup.ContextConfig.populateSCIsForCacheEntry(ContextConfig.java:2260) at org.apache.catalina.startup.ContextConfig.populateSCIsForCacheEntry(ContextConfig.java:2260) 原因分析： tomcat7.0.3X版本支持servlet3.0的特性，比如说支持@WebServlet、@WebListener，要支持这些特性，tomcat就得去扫描所有的jar包里面的每个类。这个异常表明在扫描jar包的时候，递归调用太深，导致栈溢出了，tomcat给了一个馊主意，让你增大xss，这个还是不好，xss加大了，可用线程数就少了。
分析tomcat源代码，发现它扫描的流程如下：
1.扫描所有jar包
2.通过查找jar包中META-INF/services/javax.servlet.ServletContainerInitializer文件内的定义，初始化ServletContainerInitializer实现
3.如果web.xml中配置了metadata-complete="true" 或者没有找到ServletContainerInitializer实现，都不会继续扫描jar包
网上大多数的答案的都是说在web.xml中加入了metadata-complete="true"就能避免这个异常。确实在很多场景下，这个异常是能够避免。但是使用spring-web-3.1.0.RELEASE的同学就杯具了，这个jar包中定义了一个ServletContainerInitializer，还是导致了扫描jar包。
我们可以用另外的办法来解决这个问题，我们让tomcat不扫描指定的jar包，tomcat就要轻松得多了，org.apache.tomcat.util.scan.StandardJarScanner中定义了defaultJarsToSkip，有了这个东东，我们就可以跳过某些jar包。
如果你不想使用servlet3.0 annotation支持，在tomcat的catalina.properties配置文件中tomcat.util.scan.DefaultJarScanner.jarsToSkip的值后面加一个",*"，这样就不会扫描所有的jar包了。启动更快，也不会出异常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/930ef93e41d936f22f82a45d39cc6c0b/" rel="bookmark">
			Windows中卷(Volume)操作，获取卷GUID、磁盘类型、磁盘大小等API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows中卷(Volume)操作
1、阅读msdn整理卷相关的知识点
https://docs.microsoft.com/zh-cn/windows/win32/fileio/volume-management
2、重点讲解几个常用的API及其示例
2.1、GetVolumeNameForVolumeMountPoint
用于获取卷的GUID路径，通过与该卷相关的挂载点（mount point）（如：盘符（drive letter），挂载文件夹等）。
API：
BOOL GetVolumeNameForVolumeMountPointW( [in] LPCWSTR lpszVolumeMountPoint, [out] LPWSTR lpszVolumeName, [in] DWORD cchBufferLength ); 示例代码：
#include &lt;Windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #define BUFSiZE MAX_PATH void main(void) { BOOL bFlag; TCHAR buf[BUFSiZE]; TCHAR Drive[] = TEXT("c:\\"); TCHAR I; for (I = TEXT('c'); I &lt; TEXT('z'); ++I){ Drive[0] = I; bFlag = GetVolumeNameForVolumeMountPoint( Drive, buf, BUFSiZE); if (bFlag){ /** result: The Id of drive "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/930ef93e41d936f22f82a45d39cc6c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e6689339383a2fc576bc0ef2ff1de9/" rel="bookmark">
			【深度学习】半监督模型（Π-Model、Temporal Ensembling、Mean Teacher）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两种误差：一致性误差（consistency cost）和分类误差
一致性误差： J ( θ ) = E x , η ′ , η [ ∣ ∣ f ( x , θ ′ , η ′ ) − f ( x , θ , η ) ∣ ∣ 2 ] J(\theta)=\mathbb{E}_{x,\eta',\eta}[||f(x,\theta',\eta')-f(x,\theta,\eta)||^2] J(θ)=Ex,η′,η​[∣∣f(x,θ′,η′)−f(x,θ,η)∣∣2]
三种半监督模型的区别（这些都用的噪声扰动）：
Π-Model： θ ′ = θ \theta'=\theta θ′=θ
Temporal Ensembling： f ( x , θ ′ , η ′ ) f(x,\theta',\eta') f(x,θ′,η′)用连续预测的加权平均值逼近
Mean Teacher： θ t ′ = α θ t − 1 ′ + ( 1 − α ) θ t \theta'_t=\alpha\theta_{t-1}'+(1-\alpha)\theta_t θt′​=αθt−1′​+(1−α)θt​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e6689339383a2fc576bc0ef2ff1de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ea55005a0e3440d9eaaa316748e225/" rel="bookmark">
			Vue计时器和倒计时组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue代码 &lt;template&gt; &lt;span :endTime="endTime" :endText="endText"&gt; &lt;slot&gt; {{ content }} &lt;/slot&gt; &lt;/span&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { content: '', } }, props: { // 时间戳 startTime: { type: String, default: '', }, // 时间戳 endTime: { type: String, default: '', }, endText: { type: String, default: '已结束', }, }, watch: { endTime() { this.countdowm(this.endTime) }, startTime() { this.timer(this.startTime) }, }, mounted() { // this.countdowm(this.endTime) // this.timer(this.startTime) }, methods: { //倒计时 countdowm(timestamp) { let self = this let timer = setInterval(function () { let nowTime = new Date() let endTime = new Date(timestamp * 1000) let t = endTime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31ea55005a0e3440d9eaaa316748e225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f650ce8d70b153f0c5ae8d376ce72ba/" rel="bookmark">
			VSR论文笔记三| 2018CVPR Deep Video Super-Resolution Network Using Dynamic Upsampling Filters Without Expl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Deep Video Super-Resolution Network Using Dynamic Upsampling Filters Without Explicit Motion Compensation 1.总结 以往的方法依赖于运动估计和补偿。对运动估计的准确度要求高。同时最后输出的HR图像是通过CNN混合来自多个运动补偿输入LR帧得到的，最终的结果也比较模糊。
作者提出一个基于每个像素局部的时空邻域产生动态上采样滤波器和残差图像的网络，一次阻止显式的运动补偿。最终HR图像的产生是通过直接对输入图片做动态上采样滤波和残差增强细节。
2.方法 VSR问题的定义为：
Y ^ t = G θ ( X t − N : t + N ) \hat Y_t = G_{\theta}(X_{t-N:t+N}) Y^t​=Gθ​(Xt−N:t+N​)
G G G是 T × H × W × C T \times H \times W \times C T×H×W×C，输出张量是 1 × r H × r W × C 1\times rH \times rW \times C 1×rH×rW×C。 r r r是上采样因子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f650ce8d70b153f0c5ae8d376ce72ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94232037e5de3788065ffb974d7593e3/" rel="bookmark">
			转载：SQL注入常见绕过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：SQL注入绕过技巧 - VVVinson - 博客园 (cnblogs.com) 1.绕过空格（注释符/* */，%a0）： 两个空格代替一个空格，用Tab代替空格，%a0=空格：
%20 %09 %0a %0b %0c %0d %a0 %00 /**/ /*!*/ 最基本的绕过方法，用注释替换空格：
/* 注释 */ 使用浮点数：
select * from users where id=8E0union select 1,2,3 select * from users where id=8.0 select 1,2,3 2.括号绕过空格： 如果空格被过滤，括号没有被过滤，可以用括号绕过。
在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。
例如：
select(user())from dual where(1=1)and(2=2) 这种过滤方法常常用于time based盲注,例如：
?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23 （from for属于逗号绕过下面会有）
上面的方法既没有逗号也没有空格。猜解database（）第一个字符ascii码是否为109，若是则加载延时。
3.引号绕过（使用十六进制）： 会使用到引号的地方一般是在最后的where子句中。如下面的一条sql语句，这条语句就是一个简单的用来查选得到users表中所有字段的一条语句：
select column_name from information_schema.tables where table_name="users" 这个时候如果引号被过滤了，那么上面的where子句就无法使用了。那么遇到这样的问题就要使用十六进制来处理这个问题了。
users的十六进制的字符串是7573657273。那么最后的sql语句就变为了：
select column_name from information_schema.tables where table_name=0x7573657273 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94232037e5de3788065ffb974d7593e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f2f31af26325bdb47931e17e8c84b2/" rel="bookmark">
			vue基础教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE 1、基础篇 1.1、初识Vue 准备
VsCode 插件 Vetur、Prettier-Code formatter
浏览器工具 vuejs devtool
vue基础
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;01-初识vue.html&lt;/title&gt; &lt;!-- 0、导入vue.js --&gt; &lt;script src="../js/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1、定义一个容器 --&gt; &lt;div id="app"&gt; &lt;h3&gt; 第一个vue程序，并使用插值表达式取得值为：{{name}} &lt;/h3&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; // 去除浏览器控制台中的错误信息 可以尝试去掉这个，然后进入浏览器控制台，观察上面报的东西 Vue.config.productionTip = false; // 2、初始化Vue容器 new Vue({ el: "#app", data: { name: "紫邪情", age: "18" } }) &lt;/script&gt; &lt;/html&gt; Vue容器中的代码一样符合html规范，只不过是混入了一些Vue的特殊用法而已，这个容器中的代码被称为：Vue模板{{xxx}}中的xxx要写js表达式（ {{}} 即为插值表达式 ），且xxx可以自动读取到data中的所有属性一旦data中的数据发生改变，那么页面中使用该数据的地方一样发生改变 1.2、认识v-bind - 数据单向绑定 &lt;!DOCTYPE html&gt; &lt;html lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4f2f31af26325bdb47931e17e8c84b2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/102/">«</a>
	<span class="pagination__item pagination__item--current">103/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/104/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>