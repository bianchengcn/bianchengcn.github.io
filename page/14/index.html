<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc965401a0d5a5e8412a7d133c70c19/" rel="bookmark">
			Spring Boot 项目配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 配置文件的作用properties基本语法读取文件信息缺点 yml基本语法优点配置不同数据类型字符串类型的写法 配置对象配置集合 读取配置文件的几种方法Environment@PropertySource使用原生方式读取 设置不同环境的配置文件 配置文件的作用 整个项目中重要的数据都是在配置文件中配置的，例如：
数据库的连接信息（包含连接主机、用户名和密码的设置）；项目的启动端⼝；第三方系统的调用秘钥等信息；发现和定位问题的普通日志和异常日志等 Spring Boot 配置文件主要分为以下两种格式：
.properties.yml 配置文件都是放在：/src/main/resources中的，默认的 Spring Boot 项目生产的是 .properties 格式的配置文件，.yml 格式文件需要自己手动创建
注意事项：
properties 可以和 yml ⼀起存在于⼀个项目当中，但是如果两个配置文件中出现了同样的配置那么会以 properties 中的配置为主，但加载完 .properties 文件之后，也会加载 .yml 文件的配置信息。properties 配置文件是 Spring Boot 项目的默认配置文件 properties 基本语法 properties 是以键值的形式配置的，key 和 value 之间以 “=” 连接。
# 注释 server.port=8088 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/testdb?characterEncoding= utf8 spring.datasource.username=root spring.datasource.password=root 读取文件信息 在项目中想要主动的读取配置文件中的内容，可以使用 @Value 注解来实现
import jakarta.annotation.PostConstruct; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; /* @Component 在 Spring Boot 启动时候会注入到框架中 注⼊到框架中时会执⾏ @PostConstruct初始化⽅法 读取配置文件信息 */ @Component public class UserComponent { @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecc965401a0d5a5e8412a7d133c70c19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3eb106724c62b91bf10ec82ac98f4f2/" rel="bookmark">
			体验 AutoGen Studio - 微软推出的友好多智能体协作框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		体验 AutoGen Studio - 微软推出的友好多智能体协作框架 - 知乎
最近分别体验了CrewAI、MetaGPT v0.6、Autogen Studio，了解了AI Agent 相关的知识。
它们的区别
可能有人要问：AutoGen我知道，那Autogen Studio是什么？
https://github.com/microsoft/autogen/tree/main/samples/apps/autogen-studio AutoGen和AutoGen Studio都是由微软研究团队开发的，用于创建和管理人工智能（AI）智能体。
AutoGen是一个更底层的工具，它提供了创建和管理AI智能体的框架，而AutoGen Studio则提供了一个更直观的用户界面，使得用户可以更容易地使用AutoGen框架来创建和管理AI智能体。
AutoGen Studio简介
https://microsoft.github.io/autogen/blog/2023/12/01/AutoGenStudio/ 主要特性
智能体和工作流定义修改：用户可以在界面上定义和修改智能体的参数，以及它们之间的通信方式。与智能体的互动：通过UI创建聊天会话，与指定的智能体交互。增加智能体技能：用户可以显式地为他们的智能体添加技能，以完成更多任务。发布会话：用户可以将他们的会话发布到本地画廊。 使用和安装
注：启动Web UI前，Mac电脑需要export OPENAI_API_KEY=&lt;your_api_key&gt;。
进入后首页
AutoGen Studio的组成
构建部分（Build）：定义智能体属性和工作流。游乐场（Playground）：与在构建部分定义的智能体工作流进行互动。画廊（Gallery）：分享和重用工作流配置和会话。 默认的三个Skill是生成图片、获取个人网页正文、找Arxiv的论文。
以上都是AutoGen Studio默认的页面。
AutoGen Studio的General Agent Workflow默认的提示词：
AutoGen Studio的Visualization Agent Workflow默认的提示词：
Autogen Studio的Playground给出了提示词示例，我选择它的提示词体验了下。
注：图片的AI绘图提示词来自http://x.com博主Umesh。
提交可视化示例里的提示词，并没有获得有效图表，我请GPT总结终端里的输出内容。
后查询了解到 yfinance 是从Yahoo获取市场数据的工具，我电脑网络一直访问不了Yahoo，大概是这个原因，我没有获得最终结果。
Autogen Studio是支持创建各种Skill的，给出的示例都是代码，看来要想运用好，需要有一定代码基础，当然你也可以和Autogen Studio的workflow对话，让它帮你完成某项任务，复制生成后的代码，变成新的Skill，然后我们就可以迭代完成更复杂的任务。
对比CrewAI、MetaGPT，Autogen Studio提供了可视化界面，操作起来还是很清晰的。
使用 AutoGen Studio 的应用示例 1. 自动化文档生成和管理 场景：公司需要创建和管理大量技术文档，这通常是一个耗时且重复的工作。如何使用 AutoGen Studio： 创建智能体：开发一个专门的智能体，用于从数据库和其他资源自动提取信息，生成文档。定义工作流：设置一个工作流程，该流程涉及从技术团队收集输入、利用智能体处理这些信息，然后生成更新的文档。结果：自动更新的技术文档，减少了人工编辑的需求，提高了文档准确性和及时性。 2. 多智能体协作的客户服务 场景：提高客户服务效率，处理大量客户查询。如何使用 AutoGen Studio： 建立客户服务智能体：设计多个智能体，每个智能体专注于不同类型的客户问题（如订单问题、技术支持、反馈收集等）。设置智能体工作流：当客户提交查询时，初始智能体会评估问题类型并将其转发给相应的专门智能体。结果：提高了客户服务的响应时间和解决方案的质量，同时减轻了客服团队的压力。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3eb106724c62b91bf10ec82ac98f4f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0df75caad9d4c076111491372be9eb1/" rel="bookmark">
			LeNet跟LeNet5详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 LeNet结构 主要是为了手写数字识别
具体结构讲解：从图中例子可得
1 先传入一个灰度图像尺寸为1x28x28，通道数为1，尺寸为28x28的灰度图像
2 第一层5x5卷积，经过公式 输入图像尺寸-卷积核尺寸+2padding/步长+1，（其中，因为是正方形，所以长宽都一样，直接一个式子得出）因为没有padding，输出特征图20个通道，24x24的尺寸。
3 经过第二层Pooling层，计算方式同上，得到20x12x12
4 在经过第三层5x5卷积，输出50x8x8，
5 第四层Polling，得到50x4x4
6 扁平化然后reshape为500x1的神经元用于全连接（也可以把上述得到的进行扁平化再进行一次全连接，800 -500）
7 然后Relu激活函数
8 全连接输出 10x1，代表十个数字的置信度
9 使用softmax来计算输出的值的在0-9的概率
（上述，其实上述每一层卷积都要使用Relu激活函数），下面代码复现再具体看
2 代码复现 import torch import torch.nn as nn class LeNet(nn.Module): def __init__(self) -&gt; None: super().__init__() self.features = nn.Sequential( nn.Conv2d(in_channels=1, out_channels=20, kernel_size=5, stride=1, padding=0), nn.ReLU(), nn.MaxPool2d(kernel_size=(2, 2), stride=2), nn.Conv2d(in_channels=20, out_channels=50, kernel_size=5, stride=1, padding=0), nn.ReLU(), # nn.MaxPool2d(kernel_size=(2, 2), stride=2), nn.AdaptiveMaxPool2d((4, 4)) # 这个是为了不止让限制为28x28的输入图像 ) self.classify = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0df75caad9d4c076111491372be9eb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f7cc0c43a027d25c744958099d36b6/" rel="bookmark">
			【报错栏】application.properties 配置文件中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00b5854a91a83db853e7332b311beb5e/" rel="bookmark">
			PalWorld/幻兽帕鲁Ubuntu 22.04 LTS 一键部署脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上去就是干！ 创建install.sh文件 #!/bin/bash steam_user=steam log_path=/tmp/pal_server.log if getent passwd "$steam_user" &gt;/dev/null 2&gt;&amp;1; then echo "User $steam_user exists." else echo "User $steam_user does not exist.Adding $steam_user ..." sudo useradd -m -s /bin/bash $steam_user fi echo "Installing SteamCMD..." sudo add-apt-repository multiverse -y &gt; $log_path sudo dpkg --add-architecture i386 &gt;&gt; $log_path sudo apt-get update -y &gt;&gt; $log_path sudo apt-get remove needrestart -y &gt;&gt; $log_path echo steam steam/license note '' | sudo debconf-set-selections echo steam steam/question select "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00b5854a91a83db853e7332b311beb5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5febbefeed0da8b5dd3a021ec4891eba/" rel="bookmark">
			PyTorch 之 nn.Parameter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用方法：为什么使用 `nn.Parameter`：示例使用： 在 PyTorch 中，nn.Parameter 是一个类，用于将张量包装成可学习的参数。它是 torch.Tensor 的子类，但被设计成可以被优化器更新的参数。通过将张量包装成 nn.Parameter，你可以告诉 PyTorch 这是一个模型参数，从而在训练时自动进行梯度计算和优化。
使用方法： 首先，你需要导入相应的模块：
import torch import torch.nn as nn 然后，可以使用 nn.Parameter 类来创建可学习的参数。以下是一个简单的示例：
class MyModel(nn.Module): def __init__(self): super(MyModel, self).__init__() # 创建一个可学习的参数，大小为 (3, 3) self.weight = nn.Parameter(torch.rand(3, 3)) def forward(self, x): # 在前向传播中使用参数 output = torch.matmul(x, self.weight) return output 在上面的示例中，self.weight 被定义为一个 nn.Parameter，它是一个 3x3 的矩阵。当你训练这个模型时，self.weight 将会被优化器更新。
为什么使用 nn.Parameter： 自动梯度计算： 将张量包装成 nn.Parameter 后，PyTorch 将会自动追踪对该参数的操作，从而可以进行自动梯度计算。
与优化器的集成： 在模型的 parameters() 方法中，nn.Parameter 对象会被自动识别为模型的参数，可以方便地与优化器集成。
清晰的模型定义： 将可学习的参数显式地声明为 nn.Parameter 使得模型的定义更加清晰和可读。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5febbefeed0da8b5dd3a021ec4891eba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d92dbe404a4b439514d7b3e6690810e/" rel="bookmark">
			腾讯云幻兽帕鲁4核16G/8核32G/16核64G服务器配置价格表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云幻兽帕鲁服务器4核16G、8核32G和16核64G配置可选，4核16G14M带宽66元一个月、277元3个月，8核32G22M配置115元1个月、345元3个月，16核64G35M配置580元年1个月、1740元3个月、6960元一年，腾讯云百科txybk.com分享腾讯云幻兽帕鲁Palworld服务器优惠价格表：
腾讯云幻兽帕鲁服务器配置价格
腾讯云幻兽帕鲁费用报价 根据Palworld官方提供的推荐配置为4核16G，最低4核8G，最佳4核32G，当然CPU内存配置越高游戏运行越流畅。如下图：
Palworld幻兽帕鲁服务器配置
腾讯云根据幻兽帕鲁服务器需求，专门推出了专属Palworld的服务器活动。
幻兽帕鲁服务器页面 txybk.com/go/palworld 活动打开如下图：
腾讯云幻兽帕鲁服务器价格
腾讯云百科整理配置报价表：
幻兽帕鲁服务器CPU内存公网带宽系统盘优惠价格腾讯云轻量4核16G14M14M带宽（2500GB月流量）220GB SSD盘66元/1个月腾讯云轻量4核16G14M14M带宽（2500GB月流量）220GB SSD盘277元/1个月腾讯云轻量4核16G14M14M带宽（2500GB月流量）220GB SSD盘1584元一年腾讯云轻量8核32G22M22M带宽（4500GB月流量）320GB SSD盘115元/1个月腾讯云轻量8核32G22M22M带宽（4500GB月流量）320GB SSD盘345元/1个月腾讯云轻量16核64G35M35M带宽（8000GB月流量）450GB SSD盘580元/1个月腾讯云轻量16核64G35M35M带宽（8000GB月流量）450GB SSD盘1740元/3个月腾讯云轻量16核64G35M35M带宽（8000GB月流量）450GB SSD盘6960元/1年 根据Palworld的服务器配置推荐，可以选择4核16G配置，支持32人在线，需要在服务器的防火墙中开通8211端口。更多关于腾讯云服务器的说明，可以参考腾讯云百科网。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3da765f32c1b75848a78af92f4759582/" rel="bookmark">
			Python.五.文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文件读取的操作 1.文件的打开 open(name,mode,encoding)
name:是要打开目标文件名的字符串，可以包含文件所在的具体路径
mode:设置打开文件的模式：只读 r 、写入 w 、追加 a encoding：编码格式 UTF-8
f=open("C:/test.txt","r",encoding="UTF-8") # 路径以及名字 操作 编码格式，默认都是这个 print(type(f)) 2.文件的读取 1. 文件.read(读取的字节) f=open("C:/test.txt","r",encoding="UTF-8") # 路径以及名字 操作 编码格式，默认都是这个 print(type(f)) print(f"读取十个字节的结果{f.read(10)}") 不指定参数就全部读取
f=open("C:/test.txt","r",encoding="UTF-8") # 路径以及名字 操作 编码格式，默认都是这个 print(type(f)) print(f"读取十个字节的结果{f.read()}") 连用多次read，后面的read会接着上一次read的结束位置读取
f=open("C:/test.txt","r",encoding="UTF-8") # 路径以及名字 操作 编码格式，默认都是这个 print(type(f)) print(f"读取十个字节的结果{f.read(10)}") print(f"读取十个字节的结果{f.read()}") 2. 文件.readlines() 读取全部行，封装到列表里面
f=open("C:/test.txt","r",encoding="UTF-8") # 路径以及名字 操作 编码格式，默认都是这个 print(type(f)) lines=f.readlines() print(f"lines类型是{type(lines)}") print(f"lines内容是{(lines)}") 3.文件.readline() 一次读取一行
4.for循环读取文件每一行 f=open("C:/test.txt","r",encoding="UTF-8") # 路径以及名字 操作 编码格式，默认都是这个 print(type(f)) for line in f: print(line) 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3da765f32c1b75848a78af92f4759582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e579f95fd1efa7f7d08ab4c6440e3cf/" rel="bookmark">
			【现代密码学基础】详解完美安全与香农定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 介绍
二. 完美安全的密钥与消息空间
三. 完美安全的密钥长度
四. 最优的完美安全方案
五. 香农定理
（1）理论分析
（2）严格的正向证明
（3）严格的反向证明
六. 小结
一. 介绍 一次一密方案，英语写做one time pad encryption scheme
一次一密方案可以实现完美安全（perfectly secret），但是这些方案是有局限性的，比如所有完美安全的方案密钥空间都要大于等于消息空间，这个定理待会我们会利用密码学专业术语进行证明。
如果假定密钥的长度固定，消息空间（message space）里的明文长度也固定的话，那么完美安全就要求密钥的长度大于等于消息的长度。当然，如果密钥和消息长度一样的话，就像一次一密那样，则是最优的情况。
除了这一个限制外，完美安全还要求密钥只能使用一次，具体证明则留给读者了。
二. 完美安全的密钥与消息空间 一个密码方案可以抽象成如下三个算法：
Gen,Enc,Dec
如果说该密码方案是完美安全的，他的消息空间为M，密钥空间为K，那么一定可得：
证明：
此处我们利用反证法。也就是证明，如果|K|&lt;|M|，那么该方案一定不是完美安全的。
首先假定|K|&lt;|M|。
不妨假设明文在M上是均匀分布的。从密文空间C中选择一个密文c，并且该密文的概率不为0，也就是：
对于该密文c来讲，使用不同的密钥k可能会得到不同的明文。我们将所有的可能性形成一个集合称之为M(c)，如下：
并不是每个密钥解密都有效，所以很容易可得该集合的空间小于等于密钥的空间，注意包含等于号就是恰好每个密钥都有效，那么可得：
大家可以把该过程的解密算法看成是确定性算法（deterministic）。
根据我们的条件假设，密钥空间小于明文空间，也就是|K|&lt;|M|，那么必然存在一部分的明文不在该集合中，也就是：
所以可得：
该概率代表已知密文c，不可能会解密得到m'，因为你已经尝试了所有的密钥。
但是m'在明文空间中是有概率的，也就可以得到：
从敌手的角度来讲，这就是泄露的信息。在已知密文情况下，明文的信息被泄露了一部分。所以很明显该方案不是完美安全的。
三. 完美安全的密钥长度 以上讨论告诉我们，完美安全不能无限降低密钥的长度，也可以将其看成完美安全的局限性。当然，现如今总是会出现一些非密码学的文章解释说设计出了一个新的加密方案，方案是无法攻破的，并且实现了类似一次一密的安全性，而且密钥的长度还小于明文的长度。很明显这类说法要么就是非严格密码学的局外人，要么就是方案本身是错的。
四. 最优的完美安全方案 在香农（Shannon）对完美安全的解释工作中，他指出密钥生成算法Gen要从所有可能的密钥中均匀输出密钥，就像一次一密方案。对于任意的明文m和密文c，都会存在唯一的密钥来匹配m和c，这个和一次一密方案也很类似。
这些有用的特征都可以用来证明方案的完美安全。换句话说，明文，密文和密钥的尺寸都是相等的，也就是：
|M|=|K|=|C|
在之前的证明中，我们已经严格证明完美安全要求：
借助映射定理，要想解密算法不出错，则要保证密文空间要大于等于明文空间，也就是：
通过以上的这些讨论我们不难得出，最优的完美安全方案需要保证：
|M|=|K|=|C|
五. 香农定理 将加密方案表示成：
(Gen,Enc,Dec)
其中消息空间为M，且满足：
|M|=|K|=|C|
那么如果方案满足如下两个条件，则可以说明他是完美安全的：
（1）Gen从密钥空间中输出密钥k，如下：
其对应的概率均相等，都为1/|K|
（2）任意选择明文m和密文c，也就是：
都能从密钥空间K中找到对应的密钥k，也就是：
使其满足：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e579f95fd1efa7f7d08ab4c6440e3cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe567eaaee95dbe22960a73ecc1ee0e8/" rel="bookmark">
			安全防御------SSL VPN篇_防范 ssl 隧道内部的攻击流量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、SSL工作过程
1.SSL握手协议的第一阶段
2.SSL握手协议的第二阶段
3.SSL握手协议的第三阶段​编辑
4.SSL握手协议的第四阶段​编辑
二、SSL预主密钥有什么作用？
三、SSL VPN主要用于那些场景？
四、SSL VPN的实现方式有哪些？
1.虚拟网关
2.WEB代理
3.文件共享
4.端口转发
5.网络扩展
五、SSL VPN客户端安全要求有哪些？
1.主机检查
2.缓存清除
3. 认证授权
六、SSL VPN的实现，防火墙需要放行哪些流量？
七、SSL VPN 功能总结​
一、SSL工作过程 SSL（Secure Sockets Layer）是一种用于保护网络通信安全的协议。SSL的工作过程如下：
客户端发起连接请求：客户端向服务器发送连接请求，请求建立一个安全的SSL连接。
服务器响应：服务器接收到客户端的连接请求后，如果支持SSL协议，就会返回一个数字证书。数字证书包含了服务器的公钥以及其他相关信息，用于证明服务器的身份。
客户端验证服务器的证书：客户端会验证服务器返回的证书的有效性和合法性。验证过程包括检查证书的签名是否可信、证书是否过期、域名是否匹配等。如果验证失败，客户端会中止连接，或者提示用户关于证书不受信任的信息。
客户端生成随机数和密钥：客户端会生成一个随机数作为对称加密算法的密钥，并使用服务器的公钥对该密钥进行加密。
服务器解密密钥：服务器使用自己的私钥来解密客户端发来的密钥。
确立加密算法和参数：客户端和服务器根据各自支持的加密算法列表，选择一个适用的对称加密算法和参数，用于之后的数据加密。之后，客户端和服务器都知道使用同一个对称密钥进行通信。
建立SSL连接：客户端通过对称密钥加密算法加密一条消息，并发送给服务器。服务器收到消息后，使用对称密钥解密，确认连接建立成功。此后，客户端和服务器之间的通信将使用对称密钥进行加密和解密。
安全通信：客户端和服务器使用对称密钥进行加密和解密，保证通信的机密性和完整性。加密数据在传输过程中，即使被截获，也无法理解其中的内容。
1.SSL****握手协议的第一阶段 客户端首先发送 client hello 消息到服务端，服务端收到 client hello 信息后，再发送server hello消息到客户端。 随机数： 32 位时间戳 +28 字节随机序列，用于计算摘要信息和预主密钥或主密钥的参数。
会话 ID ：一次性会话 ID ，防止重放攻击。
2.SSL****握手协议的第二阶段 服务器的证书：包含服务端公钥的证书，用于客户端给服务端发送信息时加密。
server key exchange 服务端密钥交换：决定密钥交换的方式，比如 DH,RSA ，会包含密钥交换所需的一系列参数。
3.SSL握手协议的第三阶段 client key exchange客户端密钥交换：根据服务端随机数算出一个pre-master，发给服务器，服务器收到后根据pre-master密钥生成一个main-matser。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe567eaaee95dbe22960a73ecc1ee0e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa7a0a5bca57192a6beb3e3acb9afa0e/" rel="bookmark">
			【网络奇遇记】揭秘计算机网络的性能指标：全面指南（汇总篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：聆风吟
🔥系列专栏：网络奇遇记、数据结构
🔖少年有梦不应止于心动，更要付诸行动。
文章目录 📋前言一. 速率1.1 数据量1.2 速率 二. 带宽三. 吞吐量四. 时延4.1 发送时延4.2 传播时延4.3 排队时延4.4 处理时延 五. 时延带宽积六. 往返时间七. 利用率八. 丢包率📝结语 📋前言 计算机网络的性能指标是用来衡量和评估网络的各种性能方面的指标。常用的有速率、带宽、吞吐量、时延、时延带宽积、往返时间、利用率及丢包率这8个性能指标。通过对这些指标的监测和优化，可以提升网络的性能和效率。
一. 速率 1.1 数据量 首先我们先来看看数据量的单位：
数据量的基本单位：比特（bit, 记为小写b）是计算机中数据量的基本单位，一个比特就是二进制数字中的一个0或1。
数据量的常用单位：字节（byte，记为B）、千字节（KB）、兆字节（MB）、吉字节（GB）以及太字节（TB）。
单位换算关系比特（b）基本单位字节（B）1 B = 8 bit千字节（KB）1 KB = 1024 B = 2^10 B兆字节（MB）1 MB = 1024 KB = 2^20 B吉字节（GB）1 GB = 1024 MB = 2^30 B太字节（TB）1 TB = 1024 GB = 2^40 B 1.2 速率 计算机网络中的速率是指数据的传送速率（即每秒传送多少个比特），也称为数据率或比特率。
速率的基本单位：比特/秒（bit/s，可简记为b/s。有时也记为bps，即bit per second)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa7a0a5bca57192a6beb3e3acb9afa0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/626c7852a7aef9e6ecbe26127c51f7be/" rel="bookmark">
			【网络奇遇记】揭秘计算机网络的性能指标：速率|带宽|吞吐量|时延
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：聆风吟
🔥系列专栏：网络奇遇记、数据结构
🔖少年有梦不应止于心动，更要付诸行动。
文章目录 📋前言一. 速率1.1 数据量1.2 速率 二. 带宽三. 吞吐量四. 时延4.1 发送时延4.2 传播时延4.3 排队时延4.4 处理时延 📝结语 📋前言 计算机网络的性能指标是用来衡量和评估网络的各种性能方面的指标。常用的有速率、带宽、吞吐量、时延、时延带宽积、往返时间、利用率及丢包率这8个性能指标。通过对这些指标的监测和优化，可以提升网络的性能和效率。
一. 速率 1.1 数据量 首先我们先来看看数据量的单位：
数据量的基本单位：比特（bit, 记为小写b）是计算机中数据量的基本单位，一个比特就是二进制数字中的一个0或1。
数据量的常用单位：字节（byte，记为B）、千字节（KB）、兆字节（MB）、吉字节（GB）以及太字节（TB）。
单位换算关系比特（b）基本单位字节（B）1 B = 8 bit千字节（KB）1 KB = 1024 B = 2^10 B兆字节（MB）1 MB = 1024 KB = 2^20 B吉字节（GB）1 GB = 1024 MB = 2^30 B太字节（TB）1 TB = 1024 GB = 2^40 B 1.2 速率 计算机网络中的速率是指数据的传送速率（即每秒传送多少个比特），也称为数据率或比特率。
速率的基本单位：比特/秒（bit/s，可简记为b/s。有时也记为bps，即bit per second)。
速率的常用单位：千比特/秒（kb/s）、兆比特/秒（Mb/s）、吉比特/秒（Gb/s）以及太比特/秒（Tb/s）。
单位换算关系比特/秒（b/s）基本单位千比特/秒（kb/s）1 kb/s = 10^3 b/s兆比特/秒（Mb/s）1 Mb/s = 10^3 kb/s = 10^6 b/s吉比特/秒（Gb/s）1 Gb/s = 10^3 Mb/s = 10^9 b/s太比特/秒（Tb/s）1 Tb/s = 10^3 Gb/s = 10^12 b/s 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/626c7852a7aef9e6ecbe26127c51f7be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6767ab7567d4d7733c78fcd7a91f553c/" rel="bookmark">
			【Vue】1-3、Webpack 中的 loader
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 在实际开发过程中，webpack 默认只能打包处理以 .js 后缀结尾的模块。
其他的非 .js 后缀名结尾的模块 webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错！
loader 加载器的作用：协助 webpack 打包处理特定的文件模块。
css-loader 可以打包处理 .css 相关文件
less-loader 可以打包处理 .less 相关文件
babel-loader 可以打包处理 webpack 无法处理的高级 js 语法
二、打包处理 css 文件 步骤：
1）运行 npm install style-loader@3.0.0 css-loader@5.2.6 -D 命令，安装处理 css 文件的 loader
2）在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下：
module:{	// 所有第三方文件模块的匹配规则 rules: [	// 文件后缀名的匹配规则 { test:/\.css$/, use:['style-loader','css-loader'] } ] } 其中，test 表示匹配的文件类型，use表示对应要调用的 loader
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6767ab7567d4d7733c78fcd7a91f553c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb0324e6d3b034ea6f6b727b8f4b1c11/" rel="bookmark">
			【Vue】1-2、Webpack 中的插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Webpack 插件的作用 通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。
二、两个常用插件 1）webpack-dev-server
类似于 node.js 使用的 nodemon 工具
每当修改了源代码，webpack 会自动进行项目的打包和构建
2）html-webapck-plugin
webapck 中的 html 插件（类似于一个模版引擎插件）
可以通过此插件自定制 index.html 页面的内容
命令行安装 webpack-dev-server 插件：npm install webpack-dev-server@3.11.2 -D
配置 webpack-dev-server
1）修改 package.json -&gt; scripts 中的 dev 命令如下：
"scripts": { "dev": "webpack serve"	// script 节点下的脚本可以通过 npm run 执行 } 2）再次运行 npm run dev 命令，重新进行项目的打包
3）在浏览器中访问 http://localhost:8080 地址，查看自动打包效果
webpack-dev-server 会启动一个实时打包的 http 服务器
注意：使用 webpack-dev-server 插件打包生成的 main.js 文件是存放在内存（项目的根目录）当中，而不是存放在硬盘中的 命令行安装 html-webapck-plugin
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb0324e6d3b034ea6f6b727b8f4b1c11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c809540256b15fb40acff17f6d34f47f/" rel="bookmark">
			跟着cherno手搓游戏引擎【11】静态库、警告消除(渲染预热）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		premake修改： SRC下的premake
workspace "YOTOEngine"	-- sln文件名 architecture "x64"	configurations{ "Debug", "Release", "Dist" } startproject "Sandbox" -- https://github.com/premake/premake-core/wiki/Tokens#value-tokens -- 组成输出目录:Debug-windows-x86_64 outputdir = "%{cfg.buildcfg}-%{cfg.system}-%{cfg.architecture}" -- 包含相对解决方案的目录 IncludeDir={} IncludeDir["GLFW"]="YOTOEngine/vendor/GLFW/include" IncludeDir["Glad"]="YOTOEngine/vendor/Glad/include" IncludeDir["ImGui"] ="YOTOEngine/vendor/imgui" IncludeDir["glm"] ="YOTOEngine/vendor/glm" --项目中包含某包 include "YOTOEngine/vendor/GLFW" include "YOTOEngine/vendor/Glad" include "YOTOEngine/vendor/imgui" project "YOTOEngine"	--YOTOEngine项目 location "YOTOEngine"--在sln所属文件夹下的YOTOEngine文件夹 kind "StaticLib"--修改为lib静态库 language "C++" targetdir ("bin/" .. outputdir .. "/%{prj.name}") -- 输出目录 objdir ("bin-int/" .. outputdir .. "/%{prj.name}")-- 中间目录 cppdialect "C++17" staticruntime "on"--打开 pchheader "ytpch.h" pchsource "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c809540256b15fb40acff17f6d34f47f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec735507d50f6e1dc9f1ba58304b9cf5/" rel="bookmark">
			【Vue】1-1、webpack的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是 Webpack 概念：
webpack 是前端项目工程化的具体解决方案。
主要功能：
它提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端 JavaScript 的兼容性、性能化等强大的功能。
好处：
让程序员把工作重心放到具体功能的实现上，提高了前端开发效率和项目的可维护性。
注意：
目前 Vue、React 等前端项目基本上都是基于 webpack 进行工程化开发的。
二、Demo 步骤：
1）新建项目空目录，并运行 npm init -y 命令，初始化包管理配置文件 package.json
2）新建 src 源代码目录
3）新建 src -&gt; index.html 首页和 src -&gt; index.js 脚本文件
4）初始化首页基本结构
5）运行 npm install jquery -S 命令，安装 jquery
6）通过 ES6 模块化的方式导入 jquery，实现列表隔行变色效果
执行完 npm install jquery -S 命令后会下载 jquery，并自动把 jquery 加载到 package.json 文件中
{ "name": "change-rows-color", "version": "1.0.0", "description": "", "main": "index.js", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec735507d50f6e1dc9f1ba58304b9cf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa2ce24ab5690f582617badaec1dc8ed/" rel="bookmark">
			jenkins&#43;gitlab实现iOS自动打包的坎坷之路（本文包含CI\CD过程中的一些坑点以及一些理解及建议）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文须知：本文成功案例是配置jekins所在服务器配置打包环境，并非在jenkins中配置打包环境。关于为何不采用在jenkins中配置打包环境将会在文中具体讲解。最后因为是基于jekins所在服务器配置的打包环境，按照本文所诉，实现ios自动打包将更易成功。
一.背景（重生之开局准备） 1.既然是ios项目实现自动打包，那么就必须对ios原来的打包方式及过程要有大概的了解，不同的ios项目其打包方式以及打包的一些参数都可能不相同（具体的可向开发人员询问清楚）。
以本人为例的话：2、4、5点是重点
1）.找iOS开发人员要证书和描述文件（打包需要这些。至于证书和描述文件是啥你可以有个大概的了解就行，比如证书的作用就是验证身份、应用程序签名等）
2）.简单了解一下钥匙串（知道钥匙串是啥，作用，以及在钥匙串中如何导入导出证书）
3）iOS开发人员使用的开发工具是啥。我的是Xcode。
4）找ios开发人员打包一个ipa的包给你，里面的ExportOptions.plist将对你有大用。（如果条件允许的话问问他们是否有使用过命令或者脚本打包过，如果能要到将减少你的工作量。努力做个资源咖）
5）找iOS开发人员观摩一下他们打包的过程，有些选项不同也会导致你的命令或脚本不同。
例如：For Me
如果勾选了对应的编译命令和导出ipa命令就应为（这只是命令，还要有正确配置好证书和描述文件，后面会阐述）
如果没有勾选的话 至于其他涉及到的选项只要你找开发人员要到ExportOptions.plist文件就不用单独去设置了而是像上面一样通过-exportOptionsPlist一样直接设置好了。
二.基本软件安装 软件安装网上有大量教程这里不再赘述。
1.gitlab 2.jenkins
3.Xcode(你需要xcode打包看看是否能打包，然后使用命令打包，然后使用脚本，最后才是jenkins打包，这样才能更容易定位问题，从最简单的开始，一步步来)
4.本地git安装
三.jekins实现ios自动打包的两种方式 1.插件安装
你需要安装的插件主要有：git、 gitlab、Xcode integration、keychains and Provisioning ,这里就不详细举例了，上述列出的必不可少。 方式二：问题分析下载keychains and Provisioning后，无法上传login.keychains-db文件，重命名为login.keychains后仍然无法上传，方式一就诞生了，即采用命令的方式授权访问login.keychains钥匙串。（方式二具体实现待补充）
方式一：在jekins所在服务器上配置ios的打包环境（推荐：方式二可能在新版jekins中存在钥匙串login.keychains无法上传的问题）
1.双击你从开发人员那里拿到的证书，然后证书就会被添加到钥匙串里。如果出现证书不受信任，可查看
iOS推送证书显示“此证书不受信任”_苹果手机邮箱证书显示不信任-CSDN博客
2.把描述文件添加到正确位置。
2.1 首先需要对描述文件重命名为 描述文件的UUID.mobileprovisiion
对于如何获取UUID可以参考
Xcode中描述文件的真实目录及查看描述文件的UUID_ios13.6 描述文件安装后存储路径-CSDN博客
2.2 将重命名后的文件拷贝到 /Users/用户名称/Library/MobileDevice/Provisioning Profiles
3.使用命令检查能否打包成功
建议：先使用Xcode打包一遍看看是否能否打包，然后再使用命令打包
双击xcodeproj文件就能使用xcode打开项目。可能你的项目根目录下是xcworkspace的类型文件，也没有关系
执行下面命令，你需要cd 到项目根目录
#ios编译前清理工程 xcodebuild clean -project iFoxESOP.xcodeproj \ #根目录下的xcodeproj文件 -scheme iFoxESOP \ -configuration Release #如果你的根目录是 xcworkspace类型文件 也没关系 -project 变为 -workspace xcodebuild clean -workspace iFoxESOP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa2ce24ab5690f582617badaec1dc8ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71b4753ce269a05281c408c529692640/" rel="bookmark">
			前端开发实战基础——http、https 基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List item 文章目录 http协议定义http 发展http/0.9--单行协议http/1.0--构建可扩展性httpshttp/1.1--标准化的协议http/2http/3 http 工作机制小结 http协议 定义 http ，全称为Hypertext Transfer Protocol，中文翻译过来就是 超文本传输协议。一种客户端——服务端协议，是一个简单的请求—响应协议。他是web上进行数据交换的基础。
我们日常上网冲浪浏览的网页，通常是有多个文件组合合成——包括HTML文件、JavaScript文件、CSS文件、图片资源等文件，经过浏览器构建出来的，才会最终以画面的形式展示到屏幕前。
这些文件是存储在远程的服务器（另一台电脑），我们浏览器通过发起一个请求，这个请求被封装在一个http 请求内部，服务器也是通过这个http 请求这个协议，解析出来服务器要返回什么内容作为响应。
接下来我们来了解一些http 的发展历史
http 发展 http/0.9–单行协议 最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位在 0.9 以区分后来的版本。HTTP/0.9 极其简单：请求由单行指令构成，以唯一可用方法 GET 开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。
例如下面的请求
HTTP/0.9 只需要 GET开头。后面跟随资源路径
GET /mypage.html 响应也极其简单的：只包含响应文档本身。那时候资源还是静态的。
&lt;html&gt; 这是一个非常简单的 HTML 页面 &lt;/html&gt; 0.9版本和后面版本很大不同，响应的内容不包含HTTP 头，这意味着只有HTML 文件可以传送，无法传输其他类型的文件。
有没有对应的状态码，一旦出现问题，一个特殊的包含问题描述信息的HTML文件将被发回，供人们查看，
http/1.0–构建可扩展性 因为http/0.9 有很大问题，http1.0 在其基础上有了优化，有一下的方面
增加协议版本号，这个版本号会随着每一次请求发送，追加在末尾（HTTP/1.0 会追加到get 行）增加HTTP 标头 的概念，无论是请求还是响应，允许传输元数据，使得协议更加灵活在http 标头的功能下，具备传输出纯超文本外，其他文件的能力(借助Content-Type 字段) 一个典型的请求类似这样
GET /mypage.html HTTP/1.0 User-Agent: NCSA_Mosaic/2.0 (Windows 3.1) 200 OK Date: Tue, 15 Nov 1994 08:12:31 GMT Server: CERN/3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71b4753ce269a05281c408c529692640/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eea0ea0def25af3d412a3ce7a2eb751/" rel="bookmark">
			浏览器——HTTP缓存机制与webpack打包优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要强缓存定义开启 关闭强缓存协商缓存工作机制通过Last-Modified + If-Modified-Since通过ETag + If-None-Match 不使用缓存前端利用缓存机制，修改打包方案webpack 打包webpack 打包名称优化webpack 默认的hash 值webapck其他hash 类型配置webpack打包 webpack 代码分割优化 小结 概要 在前端开发中，经常接触到JavaScript脚本文件、CSS、HTML文件，每一次开发后，我们需要重新编译，会导致文件名发生变化。这样使得浏览网页时候，需要重新加载资源
如果能合理利用浏览器的缓存，可以提高响应速度。
浏览器缓存涉及到客户端和服务器之间的交互，当浏览器请求一个资源的时候，他首先检查该资源是否已经存在于HTTP缓存中，如果存在，并且满足不过期条件，浏览器则会使用缓存的资源，而不会从服务器重新请求。这个就是缓存的作用。
在实际的项目开发中，浏览器为我们提供下面的三种缓存机制：强缓存、协商缓存和不使用缓存，下面针对以上三个类型进行说明。
强缓存 定义 强缓存，直接使用缓存文件，不请求服务器。
开启 要实现强缓存，可以通过设置HTTP响应头和cache-control 、Expires字段来实现
设置cache-control ：在服务器响应中添加Cache-Control:max-age=3600，这将告诉浏览器可以将对应http资源缓存3600秒。这个时间内，浏览器直接从本地缓存加载该资源，而不会向服务器发送请求。 HTTP/1.1 200 OK Date: Wed, 21 Oct 2025 07:28:00 GMT Cache-Control: max-age=3600 Content-Type: text/html; charset=utf-8 Content-Length: 131 设置 Expires：另一种设置方式就是使用Expire 字段，它的值是一个具体的时间，例如，Expires: Wed, 21 Oct 2025 07:28:00 GMT，表示资源将在2025 07:28:00之后过去 关闭强缓存 如果需要关闭强缓存，可以使用Cache-Control: no-cache，这将迫使浏览器每次都向服务器发送请求，通过协商机制来决定是否命中缓存。
当设置成为no-store时，则完全禁止使用任何缓存，不存在协商，直接拉取服务器资源，重新加载。
协商缓存 浏览器协商缓存，也称为弱缓存，是一种利用HTTP响应头中的Last-Modified 和Etag字段来验证资源是否修改的机制，来决定是否使用本地缓存。在使用协商缓时候，一定要设置cache-control：no-cache ，这样才能发起请求，向服务器确认资源是否被修改。
工作机制 通过Last-Modified + If-Modified-Since 1.当我们第一次请求的时候，浏览器会在头添加Last-Modified 字段，这个值表示资源最后修改的时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eea0ea0def25af3d412a3ce7a2eb751/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88ae4d4a8ea461ebe745abbb8784f387/" rel="bookmark">
			Mac Monitor：一款为macOS安全研究量身定制的高级独立系统监控工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Mac Monitor Mac Monitor是一款功能强大的高级独立系统安全监控工具，该工具专为macOS安全研究、恶意软件分类和系统故障排除而设计，主要基于Apple Endpoint Security（ES）实现其功能。
Mac Monitor能够收集各种类型的系统事件，然后以图形化的形式展示，并提供了一个可扩展的功能集，旨在过滤、查找和显示我们感兴趣的事件。该工具能够收集的遥测数据除了丰富的元数据外，还包括进程、进程间和文件事件，使用户可以轻松地将事件置于上下文中进行分析。
凭借直观的界面和丰富的分析功能，普通用户和安全专家都可以轻松检测针对macOS操作系统的各类威胁。
功能要求 1、处理器：我们建议在Apple Silicon上使用，但Intel并非不可；
2、系统内存：建议4GB+；
3、macOS版本：建议13.1+（Ventura）；
工具安装 Homebrew安装 brew install --cask red-canary-mac-monitor 普通安装 广大研究人员可以直接访问该项目的【Releases页面】下载最新版本的预编译Mac Monitor。
然后运行“Red Canary Mac Monitor.app”，同意工具所需的相关权限请求。
接下来，系统设置将会自动打开“全磁盘访问”，你需要在这里勾选启用“Red Canary Security Extension”。
最后，点击应用程序中的“Start”按钮即可开始使用Mac Monitor了。
源码获取 广大研究人员可以直接使用下列命令将该项目源码克隆至本地：
git clone https://github.com/redcanaryco/mac-monitor.git 工具卸载 brew uninstall red-canary-mac-monitor 工具使用演示 路径消除和事件订阅 事件详情查看
组件过滤
事件分布图表
代码构建
项目地址 Mac Monitor：【GitHub传送门】
参考资料 es_new_client | Apple Developer Documentation
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/13/">«</a>
	<span class="pagination__item pagination__item--current">14/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/15/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>