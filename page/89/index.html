<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a342382f6e8005b0ce05f5f0d92a84f/" rel="bookmark">
			MobaXterm简介与使用（连接Linux服务器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MobaXterm简介 MobaXterm 是用于远程计算的工具箱，作为一个 Windows 应用程序，它为程序员、网站管理员、IT管理员和几乎所有需要以更简单的方式处理远程工作的用户量身定制了大量功能。MobaXterm 提供了所有重要的远程网络工具(SSH, X11, RDP, VNC, FTP, MOSH，…)和 Unix 命令(bash, ls, cat, sed, grep, awk, rsync，…)。MobaXterm 还有很强的扩展能力，可以集成插件来运行 Gcc, Perl、Curl、Tcl / Tk / Expect 等程序。
MobaXterm 可以开启多个终端视窗，作为一个 All-In-One 网络应用程序，当我们使用 SSH 连接到远程服务器时，图形化SFTP浏览器会自动弹出，以便直接编辑远程文件。该远程应用程序还将使用嵌入式X服务器无缝地显示在 Windows 桌面上。我们可以不用安装虚拟机来使用虚拟环境，只要通过 MobaXterm 就可以使用大多数的 linux 命令。
二、使用MobaXterm连接Linux服务器 1. 软件安装 官网提供 MobaXterm 的免费开源版和收费专业版。免费开源版（Home Edition）又分绿色免安装版(解压即用)和安装版(需要安装)。
软件下载：https://mobaxterm.mobatek.net/download-home-edition.html
刚安装完，需要创建第一个SSH session。
2. 创建SSH session SSH最初由Tatu Ylonen于1995年开发，这是一种允许用户连接到远程计算机的网络协议，通常用于测试连接或远程管理服务器。如今，SSH 已成为许多组织远程访问的标准，系统管理员使用它来远程管理服务器或安全地连接到他们的个人计算机。SSH 也常用于通过不受信任的网络（例如公共 Wi-Fi 热点）传输流量。
点击菜单栏 Sessions 点击 New session 或直接点击 Session，即可弹出 session setting 对话框。
点选第一个SSH图标
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a342382f6e8005b0ce05f5f0d92a84f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d4d84a6aa5efb0d61110d881d644f2b/" rel="bookmark">
			Linux中vim编辑文件跳转指定的行和列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在Linux中使用vim编辑器修改文件，如果内容很多，那就需要定位到指定的行和列了。不同模式的跳转方式不一样，主要为正常模式和命令行模式的行号跳转。
如需设置vim编辑文件时显示行号，可参考教程【Linux中vim编辑文件显示行号（临时和永久两种方式）】。
本文由 @大白有点菜 原创，请勿盗用，转载请说明出处！如果觉得文章还不错，请点点赞，加关注，谢谢！
二、操作 1、正常模式下的跳转。什么是正常模式？使用 vim 打开一个文件，默认就是正常模式。（注意：禁止使用小键盘输入数字，会切换为编辑模式[INSERT]，误操作的话，按Esc返回到正常模式，输入 :q! 强制不保存退出即可）。 （1）输入两个小写 gg，光标会跳转到文件的第一行第一列（首行）。
gg （2）输入一个大写 G，光标会跳转到文件的最后一行第一列（末行）。
G （3）输入 ngg 或 nG，n 代表行号，光标会跳转到文件的第n行。例如 66gg 或 66G，光标会跳转到第66行。
ngg 或者
nG （4）输入数字 0 或竖杆符号 | ，光标会跳转到当前行（例如行号62）的行首。
0 或者
| （5）输入美元符号 $ ，光标会跳转到当前行（例如行号62）的行尾。
$ （5）输入 n| 或 0n| 命令（0 代表数字0，n 代表行号，| 代表竖杆符号），光标会跳转到当前行的第n列。例如 3| 会使光标跳转到当前行号62的第3列，即字符“s”位置。（注意：空格也算一列）
n| 或者
0n| （6）查看光标所在的当前行占总行数的百分比。
组合键：Ctrl + G 或 Ctrl + g 例如，总行数为 2276 行，如果在第166行，比例计算为：166 ÷ 2276 ≈ 0.0729 ≈ 7%；如果在第2276行，比例计算为：2276 ÷ 2276 = 1 = 100%。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d4d84a6aa5efb0d61110d881d644f2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52869292250103581ff94bfd97654b01/" rel="bookmark">
			2022亚马逊云科技re:Invent科创风尚，抢占下一个万亿赛道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新风向：重塑科技创投格局
面向未来增长，聚焦投资风向，演绎全新技术。11月28日至12月2日，2022亚马逊云科技re:Invent即将重磅来袭，在美国拉斯维加斯再度盛启。改变世界的全新云技术、不同领域的优选实践，都将再次影响产业变革、重新定义未来科技。
届时，现场将有二十余场面向全球初创公司的主题演讲和动手实验室，提供覆盖不同发展阶段的经营策略指导，在招聘、碳排放、上市筹备、开发者提效专题演讲中，邀请Petal、Persefoni、Braze、Drift等全球知名初创公司创始人，解读自身的创业经验，与您共启科创新格局。
新机遇：赋能中国初创公司
下一个万亿赛道面前，在中国这片创新沃土上，谁又会成为抢占风口、收获数字红利的独角兽？不如从2022亚马逊云科技re:Invent一窥全球成功初创公司带来的启示。
在云服务重塑不同行业增长模式趋势下，为支持新生创新力量凌云而上，亚马逊云科技长期赋能初创公司，已为全球数十万初创公司提供全方位的资源支持；在大中华区，亚马逊云科技累计支持及加速的初创公司数量也超过了一万家。
全生命周期前瞻未来
全新技术震撼面世，成功案例全球共享。为便于初创公司客户在re:Invent官网获取高估值、高增长企业的先锋探索，将精心编译全球13场创投专题演讲，内容覆盖初创全生命周期的优选实践：
● 规模化成长阶段：阐释高度可行、多元灵活的云服务节约计划，规避从融资到烧钱单向道，结合自身特点整合IaaS，提升IT投资回报率；应对团队规模增长，善用云服务和工具，提效内容开发、改进招聘策略。
● 持续化创新阶段：解读多项云成本优化策略、自动化安全合规路径、云开发模式的灵活实践。特邀Drift DevOps团队分享以精简组织规模，实现50倍流量增长、生产力飙升的数字方法论。
● 资本化运营阶段：分享更有利于提升估值的技术组合和架构策略，解读并购方视角下的组织模式与创新路径。Braze的联合创始人兼CTO现身说法，解读从准备到公开上市的全链路操作实践。
与一线VC驭云创新
12月和1月，亚马逊云科技还会携手国内头部风险投资机构，为初创公司提供线下面对面的交流会。届时，将邀请云服务专家，深度解读2022亚马逊云科技re:Invent发布的新技术将如何重塑行业生态，并在初创公司的安全合规、投融资、招聘、降本增效等方面展开分享。
生态化社群同频共振
为更好地共享资源、整合创新优势，亚马逊云科技还会发起系列创业社群活动。将联动十余家创投社群，将全球创新技术与实战案例带给超过一万家创业受众。此外，在接下来的亚马逊云科技大中华区re:Invent城市路演中，将邀请创投社群和不同发展阶段的初创公司参与其中，共鉴增长瓶颈、共谋跃迁路径、共塑全新生态。
新纪元：驱动初创增长飞轮
回顾亚马逊云科技的创业之旅，亚马逊云科技一直在践行、优化着自身的“飞轮理论”，也为初创公司成长各个周期量身定制了增长飞轮。
从2022亚马逊云科技re:Invent，到更多线上/线下初创企业的系列活动，亚马逊云科技对大中华区初创企业倾注多类别赋能资源。这包括知识资源包（管理经验、文化建设）、扶持资源包（快速上云的云创计划，补贴迁移成本的迁移计划）、GTM资源包（亚马逊企业客户，亚马逊电商等），以层层助推达成正反馈循环机制，全力加速初创公司飞速增长。
目前，在大中华区，亚马逊云科技战略合作的创投及创业孵化机构数量超过了200家，亚马逊云科技支持的初创公司在市场累计获得的融资金额超过了100亿美元。
未来已来，在充满创新机遇的数字新纪元面前，亚马逊云科技将与全球的成功初创公司以及创投伙伴凌云驭势、共享资源，有效缩短创新路径、规避荆棘暗丛，一起重构创业格局、重塑未来增长，助推全球数字经济精益发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e772d5ce442fd014f5739e9022dc78/" rel="bookmark">
			游戏DrawCall分析工具-SpectorJS入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. DrawCall简介 1.1、DrawCall是什么？ DrawCall 中⽂译为“绘制调⽤”或“绘图指令”。
DrawCall 是⼀种⾏为（指令），即CPU调⽤图形API，命
令GPU进⾏图形绘制。
1.2、为什么DrawCall多了会影响帧率? 在每次调⽤Draw Call之前，CPU需要向GPU发送很多内
容，包括数据，状态，命令等。在这⼀阶段，CPU需要
完成很多⼯作，例如检查渲染状态等。⽽⼀旦CPU完成
了这些准备⼯作，GPU就可以开始本次的渲染。GPU的
渲染能⼒是很强的，渲染300个和3000个三⻆⽹格通常
没有什么区别，因此渲染速度往往快于CPU提交命令的
速度。如果DrawCall的数量太多，CPU就会把⼤量时间
花费在提交DrawCall命令上，造成CPU的过载。
1.3、如何减少DrawCall？ 提交⼤量很⼩的DrawCall会造成CPU的性能瓶颈，即
CPU把时间都花费在准备DrawCall的⼯作上了。那么，
⼀个很显然的优化想法就是把很多⼩的DrawCall合并成
⼀个⼤的DrawCall,这就是批处理的思想。
2. Spector.js入门使用 2.1、什么是SpectorJS Spector.js是⼀个检测程序每⼀帧时间线渲染的内容、执
⾏的shader、以及WebGL接⼝调⽤情况。常⽤于分析
Drawcall 、 相机渲染内容 等场景。Spector.js⼀般提
供npm安装以及浏览器插件的形式。本⽂以chrome浏览
器插件为例。
2.2、安装SpectorJS 链接：https://pan.baidu.com/s/1ZA3vmbOfqzxx7BoH0rY3LQ?pwd=ix7x 提取码：ix7x 2.3、如何使用SpectorJS 以Chrome扩展程序为例子
点击这个红色图标，图标变成绿色， SpectorJS启动，将重新加载当前页面，并注入调试代码用来收集当前Web页面的渲染信息
点击这个窗口上方的红色圆圈，SpectorJS捕获帧渲染内容，并展示收集到的渲染信息
页面有3个DrawCall，则SpectorJS大约生成3-5张截图，从图中左侧图列可以看出，每一张截图对应一个DrawCall,每调用一次drawElements或WebGL其他draw函数，则增加一次DrawCall。对比指令绘制的内容差异，来决定是否可以将多个指令合并在一起绘制（例如合图或调整图片和文字地渲染顺序等），进而减少DrawCall，提升性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ee22eb9bfc705e29d45a2419feeb42/" rel="bookmark">
			强化学习——基本概念&#43;Q表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念 马尔可夫过程（MP）: 一个马尔科夫过程可以由一个元组组成 〈S,P〉
S 为（有限）的状态（state）集；P 为状态转移矩阵， 。所谓状态转移矩阵就是描述了一个状态到另一个状态发生的概率，所以矩阵每一行元素之和为1。 马尔可夫决策过程（MDP）： 相对于MP，MDP加入了瞬时奖励 R(Immediate reward）、动作集合 A 和折扣因子 γ （Discount factor）。MDP由元组 〈S,A,P,R,γ〉 定义。其中
S 为（有限）的状态（state）集；A 为有限的动作集；P 为状态转移矩阵。所谓状态转移矩阵就是描述了一个状态到另一个状态发生的概率。系统下一时刻的状态仅由当前时刻的状态决定，不依赖于以往的状态 R 为回报函数（reward function), 系统下一时刻的奖励仅由当前时刻的状态决定，不依赖于以往的状态 γ 为折扣因子，范围在[0,1]之间， 越大，说明agent看得越“远”。 回报 回报描述了从时间 t 起的总折扣奖励（区分奖励），用于衡量一个agent转移到一个state对于我们达到目的有“多有用”（how good）。即：
我们的最终的目标就是让回报的期望（expected return）最大。
状态值函数 值函数是在一个（一组）action下定义的，我们称之为策略（policy）。MDP中一个状态s在策略 π 下的值函数记为 ，它代表从s开始的回报的期望。
动作值函数（action-value function） 从状态s开始，并执行动作a，然后遵循策略 π 所获得的回报的期望
状态值函数和动作值函数的区别 这是两个概念，分别是状态价值V(s)和动作价值Q(s,a)，前者是对环境中某一个状态的价值大小做的评估，后者是对在某状态下的动作的价值大小的评估。概念类似，但主要区别应该是体现在用途以及算法上吧，比如对于离散型的动作空间，可以单纯基于动作Q值去寻优（DQN算法），如果是动作空间巨大或者动作是连续型的，那么可以判断状态价值并结合策略梯度来迭代优化（AC算法）......简单来说就是不同场景下我们会选择动作值函数或者状态值函数来寻找最优策略
贝尔曼方程 状态值函数可以分解为瞬时回报加上后续状态的折扣值，即
动作值函数也可以如此分解：
即：贝尔曼方程描述了当前状态值函数和其后续状态值函数之间的关系，即状态值函数（动作值函数）等于瞬时回报的期望加上下一状态的（折扣）状态值函数（动作值函数）的期望。
贝尔曼最优方程（Bellman Optimality Equation） 强化学习的目标是找到一个最优策略，使得回报最大。准确的说是使值函数最大，包括状态值函数和动作值函数，分别记为 和。对于任意一个MDPs，总是存在一个最优的策略 ，在使用这个策略时就能取得最优值函数，即 ， 策略分类 有模型策略：环境的状态转移概率和奖励函数已知
无模型策略：在未知的环境里，任何决策的概率函数和奖励函数是未知的。
即：在状态s下采取a行动的奖励以及转移到状态S'的概率是已知的
在状态s下采取a行动的奖励以及转移到状态S'的概率是无法获得的，在这种情况下，我们可以选择让主体不断与环境交互，采集大量的轨迹数据，从轨迹中获取信息来改进策略，从而获得更多的奖励。
Q表格 主体不断与环境交互的结果是，可以得到一张Q表格，它像是一本生活手册。里面的每一个Q函数（动作值函数）记录了在某个状态下选择某个动作，后续能够获得多少总奖励（回报期望）。最开始的时候表格会全部初始化为0。智能体会不断和环境交互得到不同的轨迹，当交互的次数足够多的时候，我们就可以估算出每一个状态下，每个动作的平均总奖励，进而更Q表格，表格的更新就是强化的过程。 强化是指我们可以用下一个状态的价值来更新当前状态的价值，其实就是强化学习里面自举的概念。
例子：悬崖行走问题 游戏规则：智能体从出发点S 出发，到达目的地G，同时避免掉进悬崖（cliff），每走一步就有−1 分的惩罚，掉进悬崖会有−100 分的惩罚。掉进悬崖游戏不会结束，智能体会回到出发点，游戏继续，直到到达目的地结束游戏。智能体需要尽快地到达目的地，为了到达目的地，智能体可以沿着例如蓝线和红线的路线行走。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28ee22eb9bfc705e29d45a2419feeb42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34e9fb41fe5dba5618e9233b763356bf/" rel="bookmark">
			文件绝对路径泄露
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绝对路径泄露漏洞 1.1.1.1 漏洞原理及危害 在网站系统对用户提交的非法请求回复错误信息，或HTML、JaveScript等源码书写疏忽等情况下，易发生服务器系统某些文件的绝对路径泄露。
通过制造报错使应用泄露出应用在主机中的绝对地址路径，攻击者可以通过泄露的绝对路径，分析网站结构，为后续上传恶意后门（如webshell等）创造了条件。
1.1.1.2 检测方法 1. 填入异常数据，制造应用报错，通过报错信息获取绝对路径；
2. 打开网页，查看源代码，查看图片等媒体的链接及超链接，有的会展示存储的绝对路径；
3. 针对目标系统的中间件或应用框架，尝试访问默认接口，获取绝对路径。
1.1.1.3 修复建议 总体修复方式：审计网站前端代码，删除注释等位置是否包含文件路径；关闭中间件或Web框架自带的默认页面等文件；删除报错信息响应页面包含的绝对路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4537972eaf271959414f94637e5da725/" rel="bookmark">
			排查Linux服务器是否被入侵步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个Linux运维工程师，能够清晰地鉴别异常机器是否已经被入侵了显得至关重要，以下是结合centos7.9操作系统进行排查Linux操作系统是否被入侵，其他Linux发行版的操作类似
1.入侵者可能会删除机器的日志信息
可以查看日志信息是否还存在或者是否被清空，相关命令
[root@master01 ~]# ls /var/log/*
/var/log/boot.log /var/log/dmesg.old /var/log/messages-20221113 /var/log/vmware-network.1.log
/var/log/btmp /var/log/maillog /var/log/secure-20221113 /var/log/vmware-vmsvc.3.log
/var/log/cron /var/log/maillog-20221106 /var/log/spooler /var/log/wtmp
/var/log/dmesg /var/log/messages-20221106 /var/log/tallylog
[root@master01 ~]# du -sh /var/log/
183M /var/log/
[root@master01 ~]# du -sh /var/log/*
2.6M /var/log/anaconda
39M /var/log/audit
0 /var/log/boot.log
20K /var/log/boot.log-20200417
12K /var/log/boot.log-20200816
24K /var/log/boot.log-20220216
12K /var/log/boot.log-20221001
8.0K /var/log/btmp
2.入侵者可能创建一个新的存放用户名及密码文件
可以查看/etc/passwd及/etc/shadow文件，相关命令：
[root@master01 ~]# ll /etc/pass*
-rw-r--r--. 1 root root 1022 Jan 25 2022 /etc/passwd
-rw-r--r--. 1 root root 986 Apr 16 2020 /etc/passwd-
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4537972eaf271959414f94637e5da725/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39834eff2b10dc78d619fb0033b1da5a/" rel="bookmark">
			Linux查看磁盘、文件系统、文件夹、文件大小的命令(lsblk、df、du、ll)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录：325
场景：在CentOS 7.9操作系统上，使用lsblk命令查看磁盘大小和磁盘挂载情况；使用df查看文件系统大小和挂载情况；使用du命令查看文件夹(目录)大小；使用ll和ls查看文件大小。
版本：
操作系统：CentOS 7.9
1.lsblk常用命令
(1)帮助命令
命令：lsblk --help
功能：查看lsblk支持全部命令和选项，在实际工作中，查看这个手册应该是必备之选。
(2)查看磁盘大小
命令：lsblk
命令：lsblk -a
功能：查看挂载磁盘信息，磁盘名称、大小、挂载目录等。
(2)查看磁盘文件系统信息
命令：lsblk -f
功能：查看挂载磁盘信息，磁盘名称、文件系统类型、UUID、挂载目录等。
2.df常用命令
(1)帮助命令
命令：df --help
功能：查看df支持全部命令和选项，在实际工作中，查看这个手册应该是必备之选。
(2)查看文件系统大小
命令：df -h
功能：查看文件系统信息，文件系统总容量、已用容量、可用容量、挂载目录等。
3.du常用命令
(1)帮助命令
命令：du --help
功能：查看du支持全部命令和选项，在实际工作中，查看这个手册应该是必备之选。
(2)查看文件夹(目录)大小
命令：du -h
功能：查看文件夹(目录)大小。
4.ll常用命令
(1)帮助命令
命令：ll --help
功能：查看ll支持全部命令和选项，在实际工作中，查看这个手册应该是必备之选。
(2)查看文件夹(目录)大小
命令：ll -h
功能：查看文件大小。
5.ls常用命令
(1)帮助命令
命令：ls --help
功能：查看ls支持全部命令和选项，在实际工作中，查看这个手册应该是必备之选。
(2)查看文件夹(目录)大小
命令：ls -lh
功能：查看文件大小。
6.命令和选项
6.1 lsblk命令
执行命令：lsblk --help，查看详细帮助手册。
Usage: lsblk [options] [&lt;device&gt; ...] Options: -a, --all print all devices -b, --bytes print SIZE in bytes rather than in human readable format -d, --nodeps don't print slaves or holders -D, --discard print discard capabilities -e, --exclude &lt;list&gt; exclude devices by major number (default: RAM disks) -I, --include &lt;list&gt; show only devices with specified major numbers -f, --fs output info about filesystems -h, --help usage information (this) -i, --ascii use ascii characters only -m, --perms output info about permissions -l, --list use list format output -n, --noheadings don't print headings -o, --output &lt;list&gt; output columns -p, --paths print complate device path -P, --pairs use key="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39834eff2b10dc78d619fb0033b1da5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7545f57245de1437505ad6897d4a8d22/" rel="bookmark">
			OFD转PDF ~java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OFD转PDF ~java实现 当你在查这个问题时，说明大家都已经接触到OFD这个新的版式文档了。OFD格式对标的是PDF，目前关于PDF的转换都比较成熟，但是当OFD出现后，却发现能实现转换却似乎有所困难。尝试网上搜了一下这方面的资料，大部分是只能支持在网页在线转换，但是如果想自己通过后台代码去实现转换却基本没有。
无意中发现“超阅云”这个平台，不仅支持网页在线转换，还支持API对接转换。果断验证一波！！
————————————————
准备工作 注册开发者账号，可直接微信扫码登录注册，一键搞定
进入个人中心，获取API开放秘钥，然后就需要购买套餐包。不过我当时直接咨询了一下他们客服，问小姐姐能不能后台先赠送我一个套餐包先体验调试下。小姐姐很热情，直接让后台发了个套餐包体验券给我，立马可以调试了。如果一开始就要付费调试，那成本确实有些高了。在这里感谢“超阅”客服小姐姐
开始开发 1、接口概述
（1）采用HTTP接口模式，编码UTF-8
（2）接口地址： https://surread.esign.cn
（3）接口请求前必须先申请成为开发者，并获取accessKey和secretKey
（4）接口请求头需要带上鉴权参数Authorization ，详情见“鉴权方式"
2、鉴权方式
（1）鉴权规则
第一步：参数签名signature
MD5(post + url + 请求时间戳 + 请求随机串 + MD5(ak+sk))
第二步：base64加密 Authorization
base64(method=post,url=xxx,timestamp=xxx,nonce_str=xxx,ak=%s,signature=xxx)
第三步： 将生成的Authorization作为参数放到请求头中
（2）代码示例
import cn.hutool.core.codec.Base64; import cn.hutool.core.util.RandomUtil; import cn.hutool.crypto.digest.DigestAlgorithm; import cn.hutool.crypto.digest.Digester; public class AuthorizationUtil { public static void main(String[] args) { String ak = "开发者标识"; String sk = "开发者秘钥"; // 生成 String requestMethod = "post".toUpperCase(); String url = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7545f57245de1437505ad6897d4a8d22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea50cb28489e20e7529f8c5031caf0e1/" rel="bookmark">
			PDF转OFD ~java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PDF转OFD ~java实现 上篇文章记录了一下我第一次对接“超阅云”实现了ofd转pdf功能，想了想，还是再写一篇pdf转ofd的实现，其实对接的API基本一样，如果你是第一次看，建议先看看上一篇文章-“ofd转pdf”
————————————————
准备工作 登录注册超阅云开发者账号，可直接微信扫码登录注册，一键搞定
进入个人中心，获取API开放秘钥
开始开发 1、接口概述
（1）采用HTTP接口模式，编码UTF-8
（2）接口地址： https://surread.esign.cn
（3）接口请求前必须先申请成为开发者，并获取accessKey和secretKey
（4）接口请求头需要带上鉴权参数Authorization ，详情见“鉴权方式"
2、鉴权方式
（1）鉴权规则
第一步：参数签名signature
MD5(post + url + 请求时间戳 + 请求随机串 + MD5(ak+sk))
第二步：base64加密 Authorization
base64(method=post,url=xxx,timestamp=xxx,nonce_str=xxx,ak=%s,signature=xxx)
第三步： 将生成的Authorization作为参数放到请求头中
（2）代码示例
import cn.hutool.core.codec.Base64; import cn.hutool.core.util.RandomUtil; import cn.hutool.crypto.digest.DigestAlgorithm; import cn.hutool.crypto.digest.Digester; public class AuthorizationUtil { public static void main(String[] args) { String ak = "开发者标识"; String sk = "开发者秘钥"; // 生成 String requestMethod = "post".toUpperCase(); String url = "/api/developer/convert/pdf2ofd"; Long timestamp = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea50cb28489e20e7529f8c5031caf0e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6246b7cf4aceed78528c18dfa27cfd36/" rel="bookmark">
			[Java反序列化]—SnakeYaml反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章首发于跳跳糖：SnakeYaml反序列化及不出网利用
SPI 正文之前先了解一下SPI机制。
SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件。 SPI的作用就是为这些被扩展的API寻找服务实现。
API （Application Programming Interface）在大多数情况下，都是实现方制定接口并完成对接口的实现，调用方仅仅依赖接口调用，且无权选择不同实现。 从使用人员上来说，API 直接被应用开发人员使用。SPI （Service Provider Interface）是调用方来制定接口规范，提供给外部来实现，调用方在调用时则选择自己需要的外部实现。 从使用人员上来说，SPI 被框架扩展人员使用。 简单实现 接口
package snakeYaml.SPI; public interface SpiService { public void say(); } 实现类
SPI1
package snakeYaml.SPI; public class SPI1 implements SpiService{ @Override public void say() { System.out.println("This is SPI-&gt;1"); } } SPI2
package snakeYaml.SPI; public class SPI2 implements SpiService{ @Override public void say() { System.out.println("This is SPI-&gt;2"); } } 在classpath下面创建目录META-INF/services/，在下面创建文件名是上述接口全限定名的文件，在此文件中写入此接口的实现类的全限定名：
测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6246b7cf4aceed78528c18dfa27cfd36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f80743af6ca2b44d6df4d7a519a3cf8/" rel="bookmark">
			Docker工作流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1。创建Dockerfile
#引用基本镜像 FROM node:18-alpine3.15 #指定容器工作目录 WORKDIR /EGG #将本机当前文件复制文件到镜像里面的EGG文件夹 COPY package.json . #运行指令 RUN npm install #复制其他文件到镜像 COPY . . #暴露端口号 EXPOSE 3000 #运行应用命令，用数组表示 CMD ["node","app.js"] 2。创建 .dockerignore 把不想复制到镜像的文件和文件夹都写进去
node_modules Dockerfile .dockerigore 3。创建镜像 docker build . 4。查看镜像
docker images 5。给镜像取名
docker tag 标签名 镜像名 6。登陆docker hub账号
docker login 7。推送镜像
docker push 镜像名 8。创建镜像时命名
docker build -t 镜像名 . 9。删除镜像
docker rmi -f 镜像名 10。拉取镜像
docker pull 11。运行镜像
docker run -d -p 主机端口:容器端口 --name 定义名字 容器 12。显示运行的容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f80743af6ca2b44d6df4d7a519a3cf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0638921b996255222be897e39911d2f/" rel="bookmark">
			前端加密与解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件加密 MD5加密（不可逆） MD5加密是不可逆的，相当于是插件加密，当然你也可以把他的方法抄过来自己实现。
MD5.js是通过前台js加密的方式对用户信息，密码等私密信息进行加密处理的工具，前端用的比较多。
MD5加密一共有6种方法
1, hex_md5(value)
2, b64_md5(value)
3, any_md5(s, e)
4, hex_hmac_md5(key, data)
5, b64_hmac_md5(key, data)
6, any_hmac_md5(key, data, e)
&lt;input id="urlInput" type="text" placeholder="请输入您要加密的内容"&gt; &lt;br/&gt; &lt;button id="btnEncrypt"&gt;加密&lt;/button&gt; &lt;br&gt; &lt;div&gt;加密后的内容是：&lt;/div&gt; &lt;input placeholder="加密后的内容" type="text" id="encryptContent" value=""&gt; var btnEncrypt = document.getElementById('btnEncrypt'); var urlInput = document.getElementById('urlInput'); var outPut = document.getElementById('encryptContent'); // var btnDecryption = document.getElementById('btnDecryption'); // var decryptionContent = document.getElementById('decryptionContent'); btnEncrypt.addEventListener('click', function() { // 获取用户输入的内容 /* 加密方法 1, hex_md5(value) 2, b64_md5(value) 3, any_md5(s, e) 4, hex_hmac_md5(key, data) 5, b64_hmac_md5(key, data) 6, any_hmac_md5(key, data, e) */ var str64 = b64_md5(urlInput.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0638921b996255222be897e39911d2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb1140d2d20293dfce6a7322ad5d0c7/" rel="bookmark">
			若依微服务增强swagger增强集成knife4j
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.项目pom.xml中增加
&lt;knife4j.version&gt;3.0.3&lt;/knife4j.version&gt; &lt;!-- knife4j --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-micro-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${knife4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${knife4j.version}&lt;/version&gt; &lt;/dependency&gt; 2.swagger服务pom.xml增加
&lt;!-- knife4j --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; 我这里不写版本号会报错，不能使用统一版本，只能手动写上版本号了
3.getway服务pom.xml增加
&lt;!-- knife4j --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-micro-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; 4.gateway服务中的SwaggerProvider 类上增加注解@Primary
如果不加项目启动报错：Parameter 0 of constructor in com.carbon.gateway.handler.SwaggerHandler required a single bean, but 2 were found:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e2294c478721e4f4fdba8d6153ea2d2/" rel="bookmark">
			【STM32单片机】贪吃蛇游戏设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、主要功能二、硬件资源1.硬件准备2.硬件连接 四、软件设计1.软件结构2.主要代码 五、实验现象联系作者 一、主要功能 系统运行后，TFTLCD触摸屏显示游戏界面，通过按键任意键进入游戏界面， 然后通过按键KEY_UP、KEY1、KEY2和KEY0键控住上下左右方向。 每当蛇吃到3个食物，速度就会提升一个等级，并且显示得分和等级，最高位5级。当游戏结束后可按任意键重新回到主界面开始。
二、硬件资源 1.硬件准备 项目所需要的硬件资源如下：
①STM32F103或STM32F407开发板1个
②TFTLCD液晶模块1个
③USB线1条（用于供电和程序下载）
④杜邦线若干
2.硬件连接 TFTLCD触摸屏模块--&gt;单片机IO 按键模块--&gt;单片机IO KEY_UP--&gt;PA0 KEY0--&gt;PE4 KEY1--&gt;PE3 KEY2--&gt;PE2 四、软件设计 1.软件结构 2.主要代码 主要代码如下：
/* 作者：嗨小易（QQ：3443792007） */ //游戏初始化 void GameInit() { u16 color=FRONT_COLOR; LCD_ShowPicture(0,(tftlcd_data.height-240)/2,320,240,(u8 *)gImage_picture); LCD_ShowFontHZ((tftlcd_data.width-7*32)/2,20,"贪吃蛇游戏设计"); while(1) { //如果有键按下则退出，重新开始 if(KEY_Scan(0)!=0) { LCD_Clear(BACK_COLOR); break; } } //绘制窗口 window.color=BLACK; window.x=(tftlcd_data.width-WIN_WIDTH)/2; window.y=(tftlcd_data.height-WIN_HEIGHT)/2-30; //初始化蛇 snake.num=3; snake.dir=RIGHT; snake.score=0; snake.size=10; snake.level=1; snake.coor[2].x=window.x+snake.size;snake.coor[2].y=window.y+snake.size; snake.coor[1].x=window.x+snake.size+snake.size;snake.coor[1].y=window.y+snake.size; snake.coor[0].x=window.x+snake.size+2*snake.size;snake.coor[0].y=window.y+snake.size; //初始化食物 food.fd.x=window.x+rand()%(WIN_WIDTH/snake.size)*snake.size; food.fd.y=window.y+rand()%(WIN_HEIGHT/snake.size)*snake.size; food.flag=1; food.color=RED; //得分显示 FRONT_COLOR=BLACK; LCD_ShowFontHZ((tftlcd_data.width-7*32)/2,20,"贪吃蛇游戏设计"); FRONT_COLOR=color; LCD_ShowString(window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e2294c478721e4f4fdba8d6153ea2d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c5a882d0a0410a0e8eb8a5962bc7354/" rel="bookmark">
			Python 考试练习题 3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关于Python的lambda函数,以下选项中描述错误的是 (B )
A、lambda函数将函数名作为函数结果返回
B、f = lambda x,y:x+y 执行后,f的类型为数字类型
C、lambda用于定义简单的、能够在一行内表示的函数
D、可以使用lambda函数定义列表的排序原则 1.lambda函数
1）称为匿名函数，函数的定义直接使用，不用起名
2）又称一句话函数，使用一行代码表达逻辑
3）用于简单的不会重复多次调用的场景
2.定义形式：sum = lambda x,y:x+y
s = lambda x,y:x+y print(s(1,2)) 3.列表的排序
1）列表排序方法1：list.sort(key = None,reverse=False)：使用key为基准排序，reverse表示正序或者逆序，默认False正序
list = [1,4,3,2] list.sort(reverse=True) print(list) 2）列表排序方法2：new_list = sorted(iterable,key=None,reverse=False):第一个参数是个list，返回一个新的list
其中的key参数，可以传入一个函数，指定排序的元素，对于这个函数，用lambda可以简化代码
4.排序演练:对学生数据按成绩进行排序 sgrade = [(1001,98),(1002,95),(1003,99),(1004,88)]
1）不可行方法：sgrade.sort() 只会按照第一项进行排序
2）方法1：sgrade.sort(key=lambda x:x[1])
sgrade = [(1001,98),(1002,95),(1003,99),(1004,88)] sgrade.sort(key=lambda x:x[1]) print(sgrade) 3)方法2：new_list=sorted(sgrade,key=lambda x:x[1])
sgrade = [(1001,98),(1002,95),(1003,99),(1004,88)] new_list = sorted(sgrade,key=lambda x:x[1]) print(new_list) x=[ {'name':'2','score':22}, {'name':'4','score':8}, {'name':'1','score':34}, {'name':'7','score':99} ] x.sort(key=lambda x:x['score'],reverse=True) print(x) y=[ (1,33), (3,65), (2,22) ] m=sorted(y,key=lambda x:x[0]) print(m) B：不一定是数字类型，只要是重载了‘+’运算符的都可以 f=lambda x,y:x+y print(type(f('a','b'))) 2、关于Python循环结构,以下选项中描述错误的是 ( A)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c5a882d0a0410a0e8eb8a5962bc7354/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74b045c659097eaaefabee11cc9d9e0e/" rel="bookmark">
			MatConvNet配置详解，吐血整理Win10&#43;MATLAB2019a&#43;VS2015&#43;cuda11.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工作
1、matconvnet深度学习工具包，我这里用的是最新版本matconvnet-1.0-beta25， matconvnet下载地址：Home - MatConvNet
下载好的文件解压，重命名为matconvnet放在C:\Program Files\Polyspace\R2019a\toolbox文件夹下
2、vs，推荐用VS2015及以上版本，我这里用的是VS2015，matconvnet在配置时需要用到这个软件里面的c++编译器，这里注意安装的时候要自定义安装勾选C++，不然不会生成cl.exe文件，如果忘记了也没事，安装好软件以后新建一个C++工程他就会自动生成cl.exe文件
3、matlab2019a（win64）
4、在安装cuda 11.0之前要先安装上自己显卡最新的官方驱动，驱动下载链接：
NVIDIA GeForce 驱动程序 - N 卡驱动 | NVIDIA
5、cuda+cudnn安装，默认路径安装（我这里使用的是cuda11.0，因为我的电脑显卡是RTX3060ti,网上说法是3060显卡只支持11.0以上的cuda算力），cuda版本和cudnn版本要一致，cuda下载连接CUDA Toolkit 11.8 Downloads | NVIDIA Developer
cudnn下载链接：Installation Guide :: NVIDIA Deep Learning cuDNN Documentation
二、matconvnet环境配置
1、cpu版本配置
输入命令mex -setup
运行vl_compilenn 程序，
这样vl_compilenn 程序成功编译
在命令行窗口输入vl_testnn命令
最后显示这个就成功了
2.配置GPU版本
（1）安装cuda，正常安装即可，没有特殊的要求，这里建议安装到默认路径，不要改变，防止之后填写环境变量的时候出现差错.
（2）设置环境变量：安装完毕后，在计算机上点右键，打开属性-&gt;高级系统设置-&gt;环境变量，可以看到系统中多了CUDA_PATH和CUDA_PATH_V11_0两个环境变量，接下来，还要在系统中添加以下几个环境变量：
如果是默认的CUDA安装路径，添加的路径分别是下面这样的：
CUDA_PATH
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0
CUDA_PATH_V11_0
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0
CUDA_SDK_PATH
C:\ProgramData\NVIDIA Corporation\CUDA Samples\v11.0
CUDA_LIB_PATH
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74b045c659097eaaefabee11cc9d9e0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b42d399533e3fc646326fa1cffeb3a0/" rel="bookmark">
			Windows系统之Yolov5的安装教程笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：安装Anaconda环境 可以在官网下载：Anaconda | The World's Most Popular Data Science Platform下载。
下载完成后会在开始菜单中多出一个快捷方式，和一些Anaconda的子程序。比如常用的“Anaconda Prompt（anaconda）”。
第二步：下载Yolov5的源码 Yolov5源码的 Github地址：https://github.com/ultralytics/yolov5 解压到自定义目录中。
第三步：下载Yolov5的预训练模型（yolov5s、yolov5m、yolov5l、yolov5x） 下载地址：https://github.com/ultralytics/yolov5/releases
（如果上面的链接下载不了，可以使用CSND里别人的共享文件：yolov5s.pt、yolov5x.pt、yolov5m.pt、yolov5l.pt_yolov5s和yolov5m的区别-深度学习文档类资源-CSDN下载）
下载完成之后将四个.pt文件放到Yolov5的根目录下
第四步：安装Yolov5 先安装Yolov5所需模块：
在命令行窗口打开Yolov5安装的根目录 ，如下：（安装比较慢，需要耐心等待）
第五步：测试Yolov5 1.图片测试 在源码中已有bus.jpg和zidane.jpg图片数据，路径如下：
在命令行中输入：
python detect.py --source ./data/images/bus.jpg python detect.py --source ./data/images/zidane.jpg 运行结果如下：
这两个模型输出的结果保存在文件夹detect中
2.视频测试 使用自己拍摄的一小段视频放入images文件夹中
在命令行中输入下面这行代码：
python detect.py --source ./data/images/IMG_7772.mp4 运行结果如下：
进行完以上的测试，说明Yolov5已经安装完成了。
-------今天不学习，明天变垃圾。-------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f24f472a8186f9d06a5ae5c76184f5f/" rel="bookmark">
			VS五子棋大战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本项目里面只是浅述了一下基本实现步骤，很多细节的地方都在注释中标注了，如需完整代码请去博主码云哦。zqy (zhang-qinyang1) - Gitee.com
目录
一、用到的关键技术点
二、主要模块
1.使用mybatis操作连接数据库
1.1修改spring配置文件
1.2创建实体类User
1.3创建Mapper接口
1.4实现mybatis相关的xml的配置
2.用户模块
2.1登录功能
2.2注册功能
2.3获取自身信息功能
3.匹配模块
3.1匹配功能
4.对战模块
4.1对战功能
先演示一下项目完成后的样子： ①登录页面：
②登录后进入的游戏大厅：
③我们在另一个浏览器上登录另一个用户李四，来实现博弈：
1.准备好双方：
2.双方开始匹配，并且开始博弈分出胜负：
3.比赛场数和天梯分数的变化：
一、用到的关键技术点 本文主要用到的关键技术点有：
Java,Spring/Spring Boot/Spring MVC,HTML,CSS,JS,AJAX,MySQL,MyBatis,WebSocket
然后在这里面我们很多内容我们在之前已经详细讲解过了，今天这里着重介绍一下WebSocket。
①为什么这里要用websocket:
因为我们之前学过的服务器开发，主要是以客户端发出请求，服务器响应这样的方式来进行的，如果客户端不发出请求，那么服务器是不会主动联系客户端的。而在我们这个五子棋项目中就会存在这样的问题，当客户端1下好了棋的位置的时候，就需要告诉服务器下在哪里了，而这个时候，如果靠客户端2每隔一段时间给服务器发送请求看客户端1是否下了棋的话，这样的开销将是很大的，就会浪费很多资源，我们就想着可不可以在服务器接收到客户端1棋的位置后，主动将位置发给客户端2。而websocket正是实现这种消息推送的一个主要方式。
②websocket的报文格式：
其中，我们主要对红色部分内容进行讲解：
（1）opcode:
描述了当前这个报文是什么类型。（比如说是一个文本帧，还是一个二进制帧，是一个ping帧，还是一个pong帧）
（2）Payload len:
表示的是当前数据报携带的数据载荷的长度，这个字段是非常长的，而websocket数据报能承载的载荷长度也是相当长的。
（3） Payload data：
表示的是报文实际要传输的数据载荷
③websocket握手建立连接的过程：
使用网页端，尝试和服务器建立websocket连接，网页端会先给服务器发送一个HTTP请求，这个请求会带有特殊的header，分别是Connection：Upgrade；Upgrade：Websocket；这两个header实际就是在告诉服务器，我们要进行协议的升级，如果这个时候，服务器支持websocket，就会返回一个特殊的HTTP响应，而这个响应的状态码就是101（切换协议），至此，客户端和服务器之间就开始使用websocket来进行通信了。
④实现一个简单的websocket代码：
（1）编写服务器（java）
1.现在java中创建一个类：（名为TestAPI的类）
a.让其继承自TextWebSocketHandler类，这个类是spring中提供的websocket类
b.继承好后，重写四个方法，分别是连接建立，客户端和服务器之间的交互，传输异常，连接被关闭这四个方法：
2.将刚刚创建这个TestAPI这个类注入到spring中去，我们创建一个新的类，命名为WebSocketConfig:
a.让这个类实现WebSocketConfigurer接口：
b.并在这个类中实现registerWebSocketHandlers这个方法，这个方法的含义就是能够注册一些handler到这个框架中去：
这行代码的含义就是当客户端连接这样一个路径的时候，就会触发到TestAPI(),然后调用执行到TestAPI中的相关方法。
除此之外，我们需要在这个类外添加两个注解，这样spring才能找到这个类，才能真正处理到这些websocket响应的请求：（第二个注解是开启websocket的关键注解）
（2）编写客户端（Js）
1.要保证这个路径和前端websocket中的路径保持一致：
2.需要给实例挂载一些回调函数，这里与前面服务器中的代码是非常相似的。
（此时和前端的四个部分是相互对应的，只是名字不同罢了）
3.实现点击按钮后通过websocket发送请求
（通过send（）方法实现发送消息）
二、主要模块 1.使用mybatis操作连接数据库 创建User表，用来表示用户的个人信息：
create database if not exists java_chess; use java_chess; drop table if exists user; create table user( userId int primary key auto_increment, username varchar(20) unique, password varchar(50), score int,--天梯积分 totalCount int,--比赛总场数 winCount int --获胜场数 ); insert into user values(null,'zhangsan','123',1000,0,0); insert into user values(null,'lisi','123',1000,0,0); insert into user values(null,'wangwu','123',1000,0,0); 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f24f472a8186f9d06a5ae5c76184f5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a21414eed54d503ead10c45ff1bbe737/" rel="bookmark">
			模数转换电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Exynos4412 A/D转换器概述
1. 概述
ADC(Analog-to-Digital Converter)，就是模数转换器。从字面上看，A我们称为模拟信号(Analog signal)，D我们称为数字信号(digital signal)。
模数转换器，在电子技术中即是将模拟信号转换成数字信号，也称为数字量化。当然还有一种叫DAC，就是数模转换，意思相反，即是将数字信号转换成模拟信号。
在我们的日常生活中，会遇到很多的物理量，遇到很多的物理参数，其中，我们经常遇到的物理参数，如电流、电压、温度、压力、速度等电量或非电量都是模拟量。
模拟量的大小是连续分布的，且经常也是时间上的连续函数。要使计算机或数字仪表能识别、处理这些信号，必须首先将这些模拟信号转换成数字信号；而经计算机分析、处理后输出的数字量也往往需要将其转换为相应模拟信号才能为执行机构所接受。这样，就需要一种能在模拟信号与数字信号之间起桥梁作用的电路—模数和数模转换器。
2. 分类
目前常见的A/D转换器中，有：权电阻网络D/A转换器、倒T型电阻网络D/A转换器、权电流型D/A转换器、权电容网络D/A转换器、开关树形D/A转换器。
3. A/D转换主要技术指标
1）分辨率
A/D转换器的分辨率用输出二进制数的位数表示，位数越多，误差越小，转换精度越高。
2）量化误差
在A/D转换中由于整量化产生的固有误差。量化误差在±1/2LSB（最低有效位）之间。
3）转换时间
转换时间是指A/D转换器完成一次转换所需的时间。转换时间是指从接到转换控制信号开始，到输出端得到稳定的数字输出信号所经过的这段时间。
4）偏移误差
输入信号为零时输出信号不为零的值，可外接电位器调至最小。
5）满刻度误差
满刻度输出时对应的输入信号与理想输入信号值之差。
6）线性度
实际转换器的转移函数与理想直线的最大偏移，不包括以上3种误差。
其他指标还有：绝对精度（Absolute Accuracy）、相对精度（Relative Accuracy）、微分非线性、单调性和无错码、总谐波失真（Total Harmonic Distortion，THD）和积分非线性。
二、Exynos 4412 A/D转换器简介
1.简述
10位或12位CMOS再循环式模拟数字转换器，它具有10通道输入，并可将模拟量转换至10位或12位二进制数。5Mhz A/D 转换时钟时，最大1Msps的转换速度。A/D转换具备片上采样保持功能，同时也支持待机工作模式。
2.特性
ADC接口包括如下特性。
1）10bit/12bit输出位可选。
2）微分误差 1.0LSB。
3）积分误差 2.0LSB。
4）最大转换速率5Msps.
5) 功耗少，电压输入1.8V。
6）电压输入范围 0~1.8V。
7）支持偏上样本保持功能。
8）通用转换模式。
3. A/D功能模块图
图1 ADC Functional Block Diagram
2. Exynos4412 A/D 控制器寄存器
1）A/D控制寄存器ADCCON
2）A/D数据寄存器
3）A/D通道Mux寄存器
三、A/D转换器实例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a21414eed54d503ead10c45ff1bbe737/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/88/">«</a>
	<span class="pagination__item pagination__item--current">89/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/90/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>