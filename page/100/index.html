<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb562aab24dfeaf8cc947fa1bfab636/" rel="bookmark">
			U盘装完系统后多出来的EFI盘复原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用u盘当作启动盘重装系统后，会发现u盘多出一个EFI分区，如何复原合并呢？ 其实我们只需要直接clean整个U盘，然后重新给U盘进行分区即可
(以win10为例)具体来看一下操作方法吧：
1.右击左下角Windows图标，点击Windows PowerShell(管理员)(A)。
2.输入diskpart，回车，启动对磁盘的分区管理。
3.输入list disk，回车，列出电脑的磁盘清单。
4.根据磁盘清单中的磁盘大小，找到自己U盘对应的磁盘编号(我这里是1，自己的编号是几就输入select disk 几)。输入select disk 1，回车，系统提示你选中了磁盘1。
注：建议反复确认一下，确保自己找对了U盘的磁盘编号，千万别选中其它的什么机械硬盘或者固态硬盘等。
5.输入clean，回车，然后就会看到清理成功，如果报错了那就再clean一遍，就会显示成功。
此时我们打开此电脑点击我们的U盘，会看到处于不可用状态，会提示你请插入U盘，这就代表clean成功。
6.右击此电脑，选择管理，点击存储列表下的磁盘管理，会看到一个未分配的可移动磁盘，就是你的U盘。
7.在磁盘上右击，选择新建简单卷，然后下一步，下一步，(然后随便给U盘选择一个驱动器号，也可以直接默认)，下一步，然后文件系统选择NTFS(默认)，不要选择FAT32(会无法读取4G大小以上的文件)，卷标就是给U盘起个名字，下一步，完成。
看完觉得有用的话，点个赞支持一下呗~~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b5d721abb1c038c7b5eb04c97b31585/" rel="bookmark">
			1. 快速入门C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C入门指导 (1) 环境安装 &amp; 运行第一个C(2) 程序组成(3) 数据类型 &amp; 变量1. 基本数据类型2. 浮点类型3. void类型4. 派生类型 (4) 运算符 &amp; 变量1. 变量2. 算术运算符3. 关系运算符4. 逻辑运算符5. 位运算6. C特有的运算符 (5) 判断 &amp; 循环(6) 数据结构1. 数组 (7) 函数(8) 存储类(9) 指针(10) 字符串(11) 文件和文件之间的沟通 (1) 环境安装 &amp; 运行第一个C 重点 自己百度安装、自己百度跑第一个程序
g++vs code 插件 C/C++插件 code runner (2) 程序组成 程序的组成是学习很多语言都必须了解的，了解之后会让你快速的建立一个整体的概念。在写C程序的时候，我们也会遵循这个组成规则
预处理器指令变量表达式
表达式包含：运算符 / 循环判断 / 数据结构 等…函数
函数也是一个指令集，下面会从 结构、定义、使用三个方面说明注释
不会被编译的文本。
通常格式是 ： // 或 /**/ /* * 这是一段注释 */ #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b5d721abb1c038c7b5eb04c97b31585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab9c61b288360078083ac197674c266/" rel="bookmark">
			nodejs中的fs模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.1 什么是fs文件系统模块 fs模块是Node.JS官方提供的、用来操作文件的模块。提供了一系列的方法和属性来满足用户对文件的操作需求
例如：
fs.readFile();//用来读取文件内容 fs.writeFile()//写入文件内容 如果要在JS代码中使用fs模块来操作文件 则需要使用以下的方式先导入它：
const fs = require（'fs'） 2.2 读取指定文件中的内容 1.fs.readFile()的语法格式；
使用fs.readFile()方法，可以读取指定文件中的内容，语法格式如下 fs.readFile(path,[option],callback) ​ path：必选参数，字符串，表示文件的路径
​ option：可选参数，决定读取文件的编码方式
​ callback：必选参数，文件读取后触发的回调函数
2.fs.readFile()的实例代码
实例代码： const fs = require('fs'); fs.readFile("./test.txt","utf-8",(err,data)=&gt;{ //如果读取成功 err为空 //如果读取失败 例如该路径没有指定文件 err为一个对象 用于展示错误信息 data为undefined console.log(err); console.log("----------------"); console.log(data); }) ​ 效果：
3.判断文件是否读取成功
​ 可以判断err对象是否为null，从而知晓文件读取的结果
如果err为null 读取成功 否则读取失败 err存放错误信息
2.3 向指定文件写入内容(覆盖式写入) fs.writeFile()的语法格式
fs.writeFile(file,data,[option],callback) file：必选参数，字符串，表示文件存放的路径
date：必选参数，表示要写入的内容
option：可选参数，以什么格式写入文件内容，默认为utf-8
callback：必选参数，写入完成后的回调函数
实例代码
fs.writeFile('./test.txt','我是通过fs插入的文字数据',(err)=&gt;{ console.log(err); }) 效果
判断文件是否写入成功
​ 可以判断err对象是否为null，从而知晓文件读取的结果
​ 如果err为null 写入成功 否则写入失败 err存放错误信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407a787f556ef95af1e9744044b08a8a/" rel="bookmark">
			Discarded invalid param(s) “myname“ when navigati
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		折腾了3天，遇到vue-router传递参数，使用router.push({name:'receive',params:{
userName:'wang',age:40
}})传递参数，使用useRoute接收参数，怎么都接收不到数据，而且还提示
Discarded invalid param(s) "myname" when navigati
在git上看它已经解决了这个问题，但是还是不行，
以前的版本
"vue": "^3.2.25",
"vue-router": "^4.1.5"，后来降低了vue-router的版本才可以
"vue": "^3.2.37",
"vue-router": "^4.0.3"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d5ddb55847b9e45532aa6b37bc8a29/" rel="bookmark">
			C&#43;&#43;三大特性之继承(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.继承的引入
2.继承的概念和定义
(1)继承的概念
(2)继承的定义
3.继承的访问限定符
(1)类中成员访问限定符回顾
(2)继承中的访问限定符及其验证
[1]验证子类是否继承了父类成员 [2]public继承
[3]protected继承
[4]private继承
(3)默认继承访问权限
[1]struct关键字定义类
[2]class关键字定义类
(4)访问限定符总结 4.基类和派生类对象赋值转换
(1)赋值转换规则
(2)规则理解
[1]规则1和2理解
[2]规则3理解
5.继承中的作用域
(1)作用域规则
(2)验证作用域规则
[1]规则1
[2]规则2和3
1.继承的引入 现实中的继承很好理解，例如回家继承家产。而C++中的继承则是继承代码。如下举个例子，这段代码较长，但非常好理解。(本文代码均在win10系统上的vs2019上验证)
代码一：这段代码定义了两个类，一个狗的类，一个猫的类。但可以发现里面的代码高度相似，狗和猫的很多行为都很像，只有个别行为不一样，比如狗喜欢吃骨头，猫喜欢吃鱼。这样就感觉代码复用性很低，有大量代码冗余。而继承就可以解决这种问题。
代码一：
//代码一 #include "iostream" using namespace std; class Dog { public: Dog(string name, int age) { _name = name; _age = age; Prin(); } void Prin() { cout &lt;&lt; _name &lt;&lt; "的年龄是" &lt;&lt; _age &lt;&lt; "岁" &lt;&lt; endl; } void Eat() { cout &lt;&lt; _name &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94d5ddb55847b9e45532aa6b37bc8a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a743ef86aa0dc6aaa3ea174afa347e/" rel="bookmark">
			2寸TFT屏幕，VCC max3.3V，VCCIO MAX2.8V 如果用3.3V供电会有什么影响。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VCI是2.6V—3.3V，VCCIO是1.65—2.8V，VCI和VCCIO并一起供电3.3V会有什么影响吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59b0503d71de162d0175616fc780245/" rel="bookmark">
			数据中台有什么用？_光点科技
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据中台炙手可热，然而很多人并不知道数据中台有什么作用，也不懂为什么人人都在谈论数据中台。简单来说，数据中台就是企业用户数据的链接枢纽，数据中台的搭建就是以数据创造价值的过程。
数据中台通过多维度、立体化的线上线下数据采集工具和方法，打破数据壁垒，搭建数据资产。同时，帮助企业进行数据加工、数据处理、数据分析和数据建模，让数据价值达到最大化。
数据中台是企业业务和数据的进一步沉淀，利用数据中台可以打通营销、销售、服务、售后、复购等环节，全面管理多源数据，进而打造出一套高效的用户管理体系，帮助企业进行用户管理，提升用户体验，推进营销数字化。
那么企业搭建数据中台的意义是什么？
1.更加深入了解客户
数据中台拥有提升数据的应用能力，可以将一般数据转化为高质量数据资产，为企业提供更优质的见解，更为客户提供更给个性和智能的产品和服务。此外，以数据中台为基础，数据化运营能实现提升客户留存度、复购度和忠诚度等等参数，获得大家的认可。
2.统一数据，提高数据的准确
云计算技术的成熟与应用，降低了数字化门槛，为中台的流行提供了技术基础。
传统的it技术会带来无意义的成本增加。而增加中台后，不仅能提升企业效率的同时还能节省成本。
3.节省成本，提升效率
云计算技术的成熟与应用，降低了数字化门槛，为中台的流行提供了技术基础。
传统的it技术会带来无意义的成本增加。而增加中台后，不仅能提升企业效率的同时还能节省成本。
4.创新力
创新是企业能持续发展的重要因素，中台不但能帮助企业实现创新，而且能实现量化的创新。IT团队更大、更专业，在创新上会有更多的优势，不但能帮助企业实现创新，而且能实现批量化、规模化的创新。
关于光点科技
光点科技是一家在政企数据治理、数据中台建设、数据可视化展示分析方面有着丰富经验的公司。作为国内专业的数据智能解决方案专家，光点科技自成立以来就一直专注于数据产品的研发和落地，服务的客户涉及智慧城市、园区、政府、集团企业、金融、制造、能源、电信、工程、教育、检验检测等多个行业。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e321c372b1bfc8eed8789a060a8449/" rel="bookmark">
			maven引用spire相关jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!--&lt;dependency&gt; &lt;groupId&gt;e-iceblue&lt;/groupId&gt; &lt;artifactId&gt;spire.doc&lt;/artifactId&gt; &lt;version&gt;5.4.2&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;e-iceblue&lt;/groupId&gt; &lt;artifactId&gt;spire.doc.free&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;com.e-iceblue&lt;/id&gt; &lt;name&gt;e-iceblue&lt;/name&gt; &lt;url&gt;https://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b72daefcda76cffe82a1da9c81bde4bb/" rel="bookmark">
			软件定义汽车之 Android Automotive OS 发展历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章旨在介绍专为汽车打造的 Android 操作系统，而非用来在车辆中连接 Android 设备的 Android Auto 平台。
翻译自 Wikipedia。
信息说明开发商Google系统家族Android官方网址https://www.android.com Android Automotive 全称是 Android Automotive OS，可简称为 AAOS，属于 Android 操作系统的变体，为车辆仪表、中控量身定制。
概述 该系统于 2017 年推出，除了 Google 主导，还有 Intel 芯片厂商的参与，同时还有传统汽车厂商：Volvo 和 Audi。这个项目目的是提供一个操作系统代码库，以便于汽车制造商开发他们自己的系统版本。（和各手机厂商开发独特的 Android OS 的思路完全一致）
除了发短信、导航、音乐播放等信息娱乐类任务，AAOS 还想要能够处理车辆专用的功能，比如控制空调等等。
与 Android Auto 不同，AAOS 并不依赖于智能手机的操作，是运行在车辆设备里的完整操作系统。
（本质上仍属于 Android，所以 ）AAOS 同样也是开源操作系统，这样的话汽车制造商可单独使用，即便不集成 GAS。 GAS 是多个 App 和服务（Google Map、Google Play、Google Assistant 等）的合集，汽车制造商需要获得 Google 的授权才能将其集成到车辆信息娱乐系统里去。（GAS 理解成车辆上 GMS 即可）
Volvo、Ford 和 GM（通用）均采用集成了 GAS 的 AAOS 方案，但 Stellantis 集团（菲亚特克莱斯勒汽车公司（FCA）与标致雪铁龙（PSA）两集团合并而来）没有集成 GAS 而是选择了（亚马逊的） Alexa 和荷兰的 TomTom 方案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b72daefcda76cffe82a1da9c81bde4bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d7644096021d0ff3df17a23fd11c569/" rel="bookmark">
			ASP 单文件上传无组件代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;%@LANGUAGE="VBSCRIPT" CODEPAGE="65001"%&gt; &lt;% '禁止缓存' Response.CacheControl="no-cache" Response.Expires=-1 Response.Charset="UTF-8" '配合第一行设定网页编码 if Request.TotalBytes then	'如果上传文件非空' set read_stream=createobject("adodb.stream")	'设置一个流' read_stream.Type=1	'这个流读二进制数据，如果Type=2则读文本数据' read_stream.Open	'打开流' read_stream.write Request.BinaryRead(Request.TotalBytes)	'将表单传过来的二进制数据写入流read_stream' '将流read_stream的所有数据读到binary_stream中，binary_stream相当于一个临时变量，接下来将对binary_stream进行切割，以免污染read_stream中的原数据' read_stream.Position=0 binary_stream=read_stream.Read enter=chrB(13)&amp;chrB(10)	'二进制流中的回车' first_enter=clng(instrb(binary_stream,enter))	'寻找第一个回车的位置' second_enter=instrb(first_enter+1,binary_stream,enter)	'寻找第二个回车的位置' set write_stream=createobject("adodb.stream")	'定义一个流write_stream' write_stream.type=1	'write_stream是处理二进制数据的' write_stream.open '将read_stream中文件信息部分写到write_stream' read_stream.Position=first_enter+1 read_stream.copyto write_stream,second_enter-first_enter-3 write_stream.Position=0 write_stream.type=2	'再将write_stream转为文本流' write_stream.CharSet="UTF-8" file_info=write_stream.readtext	'写到file_info这个字符串' write_stream.Close	'暂且关闭write_stream这个流，接下来对file_info这个字符串进行切割' file_name=mid(file_info,instrRev(file_info,"\")+1)	'取得全文件名' file_name=mid(file_name,instrRev(file_name,"=")+2) file_pre_suffix=left(file_name,instrRev(file_name,".")-1)	'取得文件前缀' suffix=mid(file_name,instrRev(file_name,"."))	'取得文件后缀，带.的' server_file_name=file_pre_suffix&amp;"_"&amp;datediff("s","1970-01-01 00:00:00",now)&amp;suffix	'在服务器保存的文件名就是“原文件前缀_时间戳.原文件后缀名”' delimiter=leftB(binary_stream,clng(instrb(binary_stream,enter))-1)	'取得文件分隔符，用于给字符串处理函数找到文件内容' third_enter=instrb(second_enter+1,binary_stream,enter)	'找第三个回车的位置' file_begin_position=clng(instrb(third_enter+1,binary_stream,enter))+1	'获取文件内容第一个字符之前的位置' file_end_position=clng(instrb(lenb(delimiter),binary_stream,delimiter))-3 '获取文件内容中最后一个字符的位置，就是第二个分隔符"delimiter"开始的前一个二进制字符' write_stream.type=1	'write_stream是处理二进制数据' write_stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d7644096021d0ff3df17a23fd11c569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16fd0944230481084c2748a4c8ca52bc/" rel="bookmark">
			代码迁移过程 -- Gitee to GitHub
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于最开始使用git绑定的是gitee，只能创建私仓，如果要公开还需要审核，而github可以直接创建公开仓，因此今天将代码转移到github上，记录一下踩坑经历。
1、创建github仓库 登录账号之后，点击网页右上角加号，New repository，新建一个仓库，如图：
输入新仓库的名称（例如：test）:
上面的选项根据自己需求改动，设置完毕点击Create repository进行确认创建，就可以看到下图所提示的命令符：
这些命令行一会在本地上传代码时需要用到，至此代码仓库创建完毕。
2、配置SSH key 2.1 首先检查一下本地主机是否存在ssh key
cd ~/.ssh //cd 为进入此目录下 ls //ls为查看目录文件，看下是否存在 id_rsa 和 id_rsa.pub文件，如果存在，说明已经有SSH Key 由于我之前绑定gitee时设置过SSH key ,因此是存在的，如下图：
如果存在，直接跳到第三步；
2.2 生成ssh key
如果不存在ssh key，使用如下命令生成：
ssh-keygen -t rsa -C "xxx@xxx.com" //执行后一直回车即可 生成完以后再用第一步命令，查看ssh key。
2.3 获取ssh key公钥内容
cd ~/.ssh cat id_rsa.pub //cat 为查看文件命令 执行命令结果如上图，复制上述内容即为SSH 的公钥部分；
2.4 将SSH Key添加到github
点击setting，找到SSH，点击New SSH Key，输入公钥即可。
2.5 判断SSH Key是否匹配成功
在桌面右键打开Git Bush，输入以下命令：
ssh -T git@github.com 第一次确认会让你输入yes or no ，输入yes之后看到 Hi + github的名字 即为成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16fd0944230481084c2748a4c8ca52bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b86a53518b34e88048ff412e52a6c239/" rel="bookmark">
			微信小程序image属性 mode 的几种模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mode 有 13 种模式，其中 4 种是缩放模式，9 种是裁剪模式。
模式 值 说明
缩放 scaleToFill 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素
缩放 aspectFit 保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。
缩放 aspectFill 保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。
缩放 widthFix 宽度不变，高度自动变化，保持原图宽高比不变
裁剪 top 不缩放图片，只显示图片的顶部区域
裁剪 bottom 不缩放图片，只显示图片的底部区域
裁剪 center 不缩放图片，只显示图片的中间区域
裁剪 left 不缩放图片，只显示图片的左边区域
裁剪 right 不缩放图片，只显示图片的右边区域
裁剪 top left 不缩放图片，只显示图片的左上边区域
裁剪 top right 不缩放图片，只显示图片的右上边区域
裁剪 bottom left 不缩放图片，只显示图片的左下边区域
裁剪 bottom right 不缩放图片，只显示图片的右下边区域
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07c12db1a51963819aa3809c7c992258/" rel="bookmark">
			使用plus.downloader.createDownload会把之前下载过的，重新下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用plus.downloader.createDownload下载图片，会把之前下载过的从下下载一遍。请大佬指教
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06cd477f99f7c35d589e0a5f01e4e382/" rel="bookmark">
			Python dict
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello，我是梁同学。今天来聊一下字典的处理。
1.字典格式
字典(dict)是一种可迭代的成对存储数据的方式。
Python中，字典由大括号（｛｝）划分，格式为键:值。每一个键值对后面都要加逗号。
例如下面的程序。
students = {100:"张三",101:"李四",102:"王五",103:"麻子"} 其中，100对应字符串张三，101对应字符串李四，以此类推。这就是字典。
2.获取键值对
获取键(key)和(value)的方法有如下两种
①通过键获取值
*以下示例均以students列表为例
具体方法如下。
students = {100:"张三",101:"李四",102:"王五",103:"麻子"} a = students[100] print(a)# "张三" 格式为:字典名[键]，返回键对应的值。
②使用keys和values函数
students = {100:"张三",101:"李四",102:"王五",103:"麻子"} a = list(students.keys()) b = list(students.values()) print(a,b)# [100,101,102,103] ["张三","李四","王五","麻子"] 具体方法如下。
格式为:字典名.keys()返回键，字典名.values()返回值。
注意⚠如果直接书写字典名.keys/values()，返回值不是列表，所以需要使用list函数转换为列表类型。
3.字典的添加
字典的添加较简单。直接书写字典名[要添加的键] = [要添加的值]就可以了。
​students = {100:"张三",101:"李四",102:"王五",103:"麻子"} students[104] = "董六" print(students)# {100:"张三",101:"李四",102:"王五",103:"麻子",104:"董六"} 4.字典的替换
字典的替换语法和字典添加完全相同，Python只会检查键是否已经在字典里存在，如果存在就替换，不存在就添加。
students = {100:"张三",101:"李四",102:"王五",103:"麻子",104:"董六"} students[103] = "KoKo" print(students)# {100:"张三",101:"李四",102:"王五",103:"KoKo",104:"董六"} 5.字典的删除
字典的删除需要用到关键字del，格式为del 字典[键]，删除键值对。
students = {100:"张三",101:"李四",102:"王五",103:"KoKo",104:"董六"} del students[100] print(students)# {101:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06cd477f99f7c35d589e0a5f01e4e382/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0dc924826049468dcbd70f2228029fc/" rel="bookmark">
			LeetCode 2382. 删除操作后的最大子段和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode 2382. 删除操作后的最大子段和
倒叙 + 并查集
typedef long long LL; class Solution { public: vector&lt;long long&gt; maximumSegmentSum(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; removeQueries) { int n = nums.size(); vector&lt;int&gt; p(n + 1); vector&lt;LL&gt; s(n + 1); for(int i = 0; i &lt; n; i ++) p[i] = i, s[i] = 0; function&lt;int(int)&gt; find = [&amp;](int x) -&gt; int{ if(p[x] != x) p[x] = find(p[x]); return p[x]; }; vector&lt;LL&gt; res; LL maxs = 0; for(int i = removeQueries.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0dc924826049468dcbd70f2228029fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f433ba8f874d06d8785043c6bc70d28e/" rel="bookmark">
			Python查看ASCII值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数使用方法如下。
#将字符串转换为其ASCII数值的Python函数是ord() ord('A')#返回65 ord('Z')#返回90 #它的逆函数为chr() chr(65)#返回'A' chr(90)#返回'Z' 制作一个暗号程序。
msg_lwr = input("Enter a message to encode or decode:") msg_upr = msg_lwr.upper() opt = "" for ltr in msg_upr: if ltr.isupper(): vle = ord(ltr) + 13 ltr = chr(vle) if not ltr.isupper(): vle -= 26 ltr = chr(vle) opt += ltr print("Output message:",end="") print(opt) 运行程序。
Enter a message to encode or decode:welcome to csdn!
Output message:JRYPBZR GB PFQA!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/336bc188d2eb54d1951864973397f1c8/" rel="bookmark">
			路由跳转三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方式一：router-link=to"跳转路径" path路径跳转 传值可以使用params 传值和query传值
(缺点:不能传引用数据类型-数组，对象等)
//写法1 &lt;router-link to="/artlist"&gt;小说列表&lt;/router-link&gt; //router-link解析出来其实是a标签 //写法2 &lt;router-link :to="path1"&gt;小说列表&lt;/router-link&gt; ... data() { return{ path1:'/artlist' } } 方式二：命名式路由跳转（name） 传值可以使用params和query传值
(优点:可以传基本数据类型和数组，对象)
&lt;router-link :to="{name:'shop',query:{city:cityObj}}"&gt;购物车&lt;/router-link&gt; ... //路由配置 { path:'/shop', //该path路径不能少。因为命名式路由跳转是通过name找到该path name:'shop', component:Shop } 方式三：编程式路由跳转(最常用的，不受时机、条件的限制) 传值可以用params 传值和query传值
(优点:可以传基本数据类型和数组，对象)
jumpHome() { this.$router.push({ path:"/home"， query:{ id:this.id } }) } ... //接收值如果进入另一个页面，一般在created中接收 this.$route.query.id //路由配置 { path: "/home", component: ()=&gt;import("../Home") } //或者name和params搭配,接收值 this.$route.params.id 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/999ca59ac4a5f72931a7bc33a8e6f3ea/" rel="bookmark">
			LeetCode：每日一题【第三周】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.15 ~ 8.21 尽量坚持刷力扣的每日一题，锻炼大脑思维。更新中~~
641. 设计循环双端队列【数组模拟】 思路 设置一个数组用来模拟循环队列，只需要对队头和队尾取模即可。front指的是队头，rear指队尾后一个，这样可以避免队列已满和队列为空冲突。
AC代码 class MyCircularDeque: def __init__(self, k: int): self.front = self.rear = 0 self.arr = [0] * (k + 1) def insertFront(self, value: int) -&gt; bool: if self.isFull(): return False self.front = (self.front - 1) % len(self.arr) self.arr[self.front] = value return True def insertLast(self, value: int) -&gt; bool: if self.isFull(): return False self.arr[self.rear] = value self.rear = (self.rear + 1) % len(self.arr) return True def deleteFront(self) -&gt; bool: if self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/999ca59ac4a5f72931a7bc33a8e6f3ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a96e4a131f282f8537529fadcc26b99/" rel="bookmark">
			leetcode 6159. 删除操作后的最大子段和 python3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入：nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]
输出：[14,7,2,2,0]
解释：用 0 表示被删除的元素，答案如下所示：
查询 1 ：删除第 0 个元素，nums 变成 [0,2,5,6,1] ，最大子段和为子段 [2,5,6,1] 的和 14 。
查询 2 ：删除第 3 个元素，nums 变成 [0,2,5,0,1] ，最大子段和为子段 [2,5] 的和 7 。
查询 3 ：删除第 2 个元素，nums 变成 [0,2,0,0,1] ，最大子段和为子段 [2] 的和 2 。
查询 4 ：删除第 4 个元素，nums 变成 [0,2,0,0,0] ，最大子段和为子段 [2] 的和 2 。
查询 5 ：删除第 1 个元素，nums 变成 [0,0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。
所以，我们返回 [14,7,2,2,0] 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a96e4a131f282f8537529fadcc26b99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73b29b6cdcbaf9aa037fd6f2715cbdc7/" rel="bookmark">
			前端学习笔记二.布局方式的选择与Flex布局示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
2022年了不用考虑其他布局了。就在Flex和Grid里选，考虑到Grid的兼容性问题，固然比Flex更强大但应该是未来的主流，目前还是先会用Flex性价比比较高。
Flex教程：阮一峰：Flex 布局教程
Grid教程：CSS Grid 网格布局教程 - 阮一峰的网络日志
一.Flex布局的含义和开启方法以及关于-webkit-flex的说明
Flex布局的容器中有两个轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。
可以通过属性的设置使得容器中的内容沿着水平或垂直的轴按照需求响应式排列。
Flex的开启方法：
.box{ display: -webkit-flex; /* Webkit 内核的浏览器，必须加上-webkit前缀。 */ display: flex; } 需要特别说明的是，webkit之类的浏览器前缀，只有在直接打开的html页面中才需要加上。
如果你的项目是打包后（webpack等）发布的，或者你使用框架开发发布（vue等），则不需要手动加上浏览器前缀。你可以仅保留 display: flex;
这是因为打包工具的Autoprefixer特性。
Autoprefixer是一个后处理程序，它适用于普通的CSS而不使用特定的语法。它在CSS编译后运行。会自动为你的css添加必要的浏览器前缀。
二.Flex布局示例。
参考博客：CSS学习笔记（12）--Flex 布局教程：实例篇
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/99/">«</a>
	<span class="pagination__item pagination__item--current">100/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/101/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>