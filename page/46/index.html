<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/485e7d11249759a3c535783b2fe982fc/" rel="bookmark">
			jq——页面滚动到显示区域，再执行动画——基础积累
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天郑大东同事向我显摆了一个他做的动画，效果如下：
jq——页面滚动到显示区域，再执行动画 使用场景`html`部分代码` css`部分代码`js`部分代码 使用场景 当页面滚动到相应区域时，再执行里面的动画，也就是下图中右侧的一层层的显示动画，无论是向上滚动页面还是向下滚动页面。
下面直接上代码：
html部分代码 &lt;div id="boxVue" class="boxLaminatedStructure"&gt; &lt;div class="li" id="dcAnm1"&gt; &lt;div class="t"&gt;&lt;i&gt;1&lt;/i&gt;&lt;b&gt;编号：JLC04161H-xxxx &lt;/b&gt;&lt;/div&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;类型&lt;/th&gt; &lt;th&gt;物料参数&lt;/th&gt; &lt;th&gt;/&lt;/th&gt; &lt;th&gt;厚度参数(mm)&lt;/th&gt; &lt;th&gt;压合参数(mm)&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="class"&gt;通红&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td&gt;/&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td rowspan="7" class="dcPic"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="class"&gt;橙黄&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td&gt;/&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内层&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td&gt;/&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="class"&gt;墨绿&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td&gt;/&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内层&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td&gt;/&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="class"&gt;橙黄&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td&gt;/&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;td&gt;参数&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/485e7d11249759a3c535783b2fe982fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d282d1c033669a6473f43b91f41c056/" rel="bookmark">
			使用U盘同步WSL2中的git项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、将U盘挂载到WSL2中 假设U盘在windows资源管理器中被识别为F盘，需要在WSL2中创建一个目录挂载U盘
sudo mkdir /mnt/f sudo mount -t drvfs F: /mnt/f 后续所有的操作都完成后，拔掉U盘前，可以使用下面的命令从WSL2中安全的移除U盘
umount /mnt/f 2 、在U盘中创建裸仓库 假如在/project目录下创建,（如果本地已经存在git项目了，仓库的名字最好和本地git仓库名称一致）
mkdir project &amp;&amp; cd project git init --bare git_repos 3、将本地所有的分支推送到U盘中的git_repos仓库 推送的必须是track过的分支或者是本地分支
git remote add udisk /mnt/f/project/git_repos git push udisk --all 4、从U盘仓库中拉取代码 假设U盘被挂载到了另一台电脑的D盘
git init local_project git remote add udisk D:/git_repos git pull udisk master 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60272a358643212b2b5c469722f7ae48/" rel="bookmark">
			Geotools对geojson的解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 GeoTools 中，对 GeoJSON 的支持是通过一个插件来完成的，用户同样可以在 Maven 的 pom.xml 配置文件中添加下述的依赖。
&lt;dependency&gt; &lt;groupId&gt;org.geotools&lt;/groupId&gt; &lt;artifactId&gt;gt-geojson&lt;/artifactId&gt; &lt;version&gt;${geotools.version}&lt;/version&gt; &lt;/dependency&gt; 有关插件导进来以后，就可以根据相关的接口对Geojson进行解析
GeometryJSON qison = new GeometryJSON() ; String json = "{\"type\":\"Point\",\"coordinates\":[100.1,0.1]}"; Reader reader = new StringReader(json); Point p = qison.readPoint( reader ) ; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7bf93b5947423b4911ed11b9d9e35c6/" rel="bookmark">
			手把手教你用VUE写个例子访问后端WebApi的接口获取数据并显示出来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文接着上文《手把手叫你用VS2019写个WebApi（可以供网页、手机、电脑三端连接使用）从网页访问后端并在后端通过EF获取sqlserver中的数据》
https://blog.csdn.net/weixin_43935474/article/details/132497256?spm=1001.2014.3001.5501
上文中介绍了如何创建一个WebApi后端接口的例子，现在来写个网页端访问这个后端接口的例子。
开发环境：Visual Studio Code
先打开VS Code，新建终端，在下方终端内先输入
cd E:\WebCode\FirstVueApp\ 表示我将在上述路径下创建项目。然后输入
npm create vue@latest 表示我要创建一个vue框架的项目，然后输入项目名，默认叫“vue-project”,也可以在此处输入自己取的项目名称
然后按下回车，会提示是否添加一些可选功能，我的选择如下：
然后点击资源管理器（界面左上角第一个菜单），点击“打开文件夹”，打开刚才创建项目的目录E:\WebCode\FirstVueApp\vue-project，即可显示项目相关的文件。
然后在终端输入npm install按下回车，再输入npm run dev按下回车，按住Ctrl键再点击Local:右侧的网址，即可打开浏览器显示这个vue项目的网站显示效果，
如下：
接些来，我们把网站页面上显示的内容改掉，换成从webapi后端访问接口拿到的数据，具体操作如下：
先关闭上述网页，然后在VS Code的终端按下Ctrl+C，结束命令。
然后输入
npm install axios 安装axios，用于访问后端接口。
然后把App.vue文件里面的内容换成如下代码：
&lt;script&gt; import { ref, onMounted } from 'vue' import axios from 'axios' export default { setup() { const data = ref('') const fetchData = async () =&gt; { try { const response = await axios.get('https://localhost:44364/api/GetUserData') data.value = response.data } catch (error) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7bf93b5947423b4911ed11b9d9e35c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f06ea111ba3c9d7efbe3f731f0058c7b/" rel="bookmark">
			微信小程序隐私协议相关接口实际使用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;view wx:if="{{showPrivacy}}" class="privacy"&gt; &lt;view class="popup"&gt; &lt;view&gt;隐私弹窗内容....&lt;/view&gt; &lt;view bindtap="openPrivacyAgreement"&gt;点击查看隐私协议&lt;/view&gt; &lt;button id="disagreeBtn" bindtap="disagreePrivacy"&gt;不同意&lt;/button&gt; &lt;button id="agreeBtn" open-type="agreePrivacyAuthorization" bindagreeprivacyauthorization="agreePrivacy"&gt;同意&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; 1、全局控制 页面加载时自动弹窗，同意后可以使用对应功能，不同意退出页面或者隐藏相关功能。
这种情况下，需要在onLoad里使用wx.getPrivacySetting获取隐私授权情况，没授权时弹出隐私弹窗。完整代码如下
Page({ data: { showPrivacy: false // 控制隐私弹窗是否展示 }, openPrivacyAgreement() { // 查看隐私协议 wx.openPrivacyContract() }, disagreePrivacy() { // 关闭隐私弹窗 this.setData({ showPrivacy: false }) // 这里是不同意隐私协议的后续操作，比如退出页面、隐藏相关功能等 }, agreePrivacy() { // 关闭隐私弹窗 this.setData({ showPrivacy: false }) // 这里是同意隐私协议的后续操作，比如展示被隐藏的相关功能 }, onLoad() { if (wx.getPrivacySetting) { wx.getPrivacySetting({ success: res =&gt; { if (res.needAuthorization) { // 打开隐私弹窗 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f06ea111ba3c9d7efbe3f731f0058c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/757fd3eb92c0464f9eee0440ad89e715/" rel="bookmark">
			Python爬虫——新手使用代理ip详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python代理IP爬虫是一种可以让爬虫拥有更多网络访问权限的技术。代理IP的作用是可以为爬虫提供多个IP地址，从而加快其爬取数据的速度，同时也可以避免因为访问频率过高而被网站封禁的问题。本文将介绍如何使用Python实现代理IP的爬取和使用。
一、代理IP的获取
首先我们需要找到一个可用的代理IP源。这里我们以站大爷代理ip为例，站大爷代理提供了收费代理和普通免费的代理IP，使用起来非常方便。
站大爷代理ip的API接口地址：https://www.zdaye.com/free/inha/1/
通过请求上面的API接口，我们可以获取到一页代理IP信息，包括IP地址和端口号。我们可以通过requests库的get方法获取到API返回的信息，示例代码如下：
import requests url = 'https://www.zdaye.com/free/inha/1/' response = requests.get(url) print(response.text) 上面代码执行后，我们可以看到获取到的代理IP信息。但是我们需要对返回值进行解析，只提取出有用的IP地址和端口。
import requests from bs4 import BeautifulSoup url = 'https://www.zdaye.com/free/inha/1/' response = requests.get(url) soup = BeautifulSoup(response.text, 'html.parser') proxies = [] for tr in soup.find_all('tr')[1:]: tds = tr.find_all('td') proxy = tds[0].text + ':' + tds[1].text proxies.append(proxy) print(proxies) 上面代码中，我们使用BeautifulSoup库对返回的HTML文本进行解析，获取到所有的&lt;tr&gt;标签，然后通过循环遍历每一个&lt;tr&gt;标签，提取出其中的IP地址和端口信息，并将其保存到一个列表中。
二、代理IP的验证
获取到代理IP后，我们需要进行测试，判断这些代理IP是否可用。这里我们通过requests库的get方法进行测试，如果返回200则说明该代理IP可用。我们使用代理IP的方法是通过向requests.get方法传入proxies参数来实现，示例代码如下：
import requests url = 'http://www.baidu.com' proxies = { 'http': 'http://222.74.237.246:808', 'https': 'https://222.74.237.246:808', } try: response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/757fd3eb92c0464f9eee0440ad89e715/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a613ed488754f75f248934dd2783e55/" rel="bookmark">
			vue3进阶(二)-封装utils方法——禁止输入框特殊字符校验 &amp; form表单特定字符校验 &amp; 自定义指令app.directive之防抖指令v-throttle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3进阶(二)-封装utils方法——禁止输入框特殊字符校验 &amp; form表单特定字符校验 &amp; 自定义指令app.directive之防抖指令v-throttle 4、引用的校验方法 src\utils\validate.ts
// 禁止输入框特殊字符校验 export function replaceCommonText(e: any) { if (!checkSpecificKeyWord(e)) { // 提交关键字 ElMessage({ message: '不能包含关键词： ' + wordKey, type: 'warning', }) const y = e.replace(wordKey, '') return y } else { const str = e.replace( /[`~!@#$%^&amp;*()_\-+=&lt;&gt;?:"{}|,./;'\\[\]·~！@#￥%……&amp;*（）——\-+={}|《》？：“” ]/g, '' ) const y = str.replace(/\s+/g, '') return y } } /** * @description form表单特定字符校验 * @param value * @returns {boolean} */ export function validateCommonText(rule: any, value: any, callback: any) { const noChars = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a613ed488754f75f248934dd2783e55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97525f87f3d3df822ea681c73cea6175/" rel="bookmark">
			关于ChatGPT等AIGC技术对人类社会的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		梗概
横空出世的ChatGPT作为新一代人工智能技术，开启了通用人工智能时代，标志着人工智能具有广泛的学习能力并在大多数领域达到或超过普通人类的水平，其社会影响将巨大而深远。面对这一新传播范式，对其原理架构与应用创新解析、风险认知、应对策略的相关研究刻不容缓。在第一章中，本论文将从生成式人工智能技术的背景出发，简介其原理、与内容创作模式的关系及其发展历程三大阶段的区分叙述。并通过剖析生成式人工智能技术国内外相关应用当前现状及其基本技术架构来从消费服务、产业发展、社会价值三个方面搭配具体案例来探讨其对社会的积极影响并补充综述目前存在的挑战与风险。而在第二章中，本论文将深度结合《计算机伦理学》一书中相关知识，从信息技术与知识产权、计算机技术与隐私保护、经济问题与计算机犯罪等多方面结合具体现象与案例针对生成式人工智能技术所涉及的伦理问题进行分析，并提出相应的解决方案与思考。在第三章中，本论文主要聚焦于针对生成式人工智能技术的个人阐述，包括但不限于通过其对社会的深远影响及应对策略来论述自己的观点和看法。同时将会结合实际生活中的案例，深度解析并论述新一代人工智能对个人及社会生活带来的深远影响。而在本论文的最后部分，将会注明相关的参考资料。
​​​​​​​
目录
一、生成式人工智能技术的发展历程及社会影响
1.1 生成式人工智能技术的发展简介
1.2 概述生成式人工智能技术的发展对社会的影响
二、生成式人工智能技术所涉及的伦理问题分析
2.1 生成式人工智能技术中的信息技术与知识产权 2.2 生成式人工智能技术中的计算机技术及隐私保护 2.3 生成式人工智能技术中的计算机犯罪 2.4 生成式人工智能技术中的计算机技术相关经济问题 2.5 生成式人工智能技术中的IT职业道德和社会责任 三、个人阐述
3.1 就生成式人工智能技术对社会的深远影响及应对策略来论述自己的观点和看法
3.2 搜索实际生活中案例，论述新一代人工智能对个人及社会生活带来哪些影响
3.2.1 新一代人工智能对个人及社会生活的渗透
3.2.2 新一代人工智能对产业模式的影响 3.2.3 新一代人工智能对社会价值的影响 3.2.4 新一代人工智能与计算机犯罪案件 3.2.5 新一代人工智能对社会就业的影响 四、参考资料
一、生成式人工智能技术的发展历程及社会影响 1.1 生成式人工智能技术的发展简介 2022年标志着以生成式人工智能技术为核心的AIGC（AI-Generated Content）爆火。其中，Stability AI发布了一款名为Stable Diffusion的开源模型，它能够根据用户输入的文字描述自动生成惊人的图像，这一创举引爆了AI作画领域，使AI作品在艺术界掀起了一股热潮。在同一年的12月，OpenAI的强大语言生成模型ChatGPT横空出世，其不仅能够高情商地进行对话，而且还能应用于生成代码、构思剧本和小说等多种场景。这一突破将人机对话推向了一个新的高度，开启了通用人工智能时代，并使相关技术成为全球关注的焦点与未来重点研究趋势。这一热潮迅速席卷全球科技企业，激发了各大公司积极拥抱AIGC的热情。各家企业纷纷推出相关技术、平台和应用，以满足市场的需求。从图像生成到音乐创作，从自动写作到虚拟角色设计，人工智能生成内容正在迅速丰富和改变我们的创作方式和娱乐体验，一些AIGC应用案例如图1所示。
图1 AIGC应用案例
ChatGPT等AIGC模型及应用本质上是人工智能生成内容的最新应用成果，其发展历程与内容创作模式是息息相关的，如图2所示。随着时间推移，内容数量逐渐增多，内容创作模式在AIGC之前经历了PGC（Professionally-Generated Content）、UGC（User-Generated Content）、AIUGC（Artificial Intelligence + User-Generated Content）三个主要阶段。除了内容数量，不同阶段的主要区别则是创作主体、专业度和内容质量等方面。如今AIGC生成内容的专业度和内容质量逐渐提高，达到类人或超人。而同时ChatGPT等AIGC模型及其应用代表了AI技术发展的新趋势，与传统的分析数据获取规律的人工智能技术不同，而是正在生成/创造新的东西。即其实现了人工智能从感知理解世界到生成创造世界的跃迁。因此，从这个意义上来看，广义的AIGC可以看作是像人类一样具备生成创造能力的AI技术，即生成式人工智能技术。根据不同方案的Prompt，生成式人工智能会基于算法、模型、规则创造出不一样的内容，包括但不限于文本、图片、声音、视频、代码，总的来说其在内容质量、创造性、数量等方面均存在极高的上限（参考[1]）。
图2 内容创作模式的发展历程[1]
2022年以来ChatGPT等生成式人工智能技术及应用因其优越的效果与广泛的应用场景出圈爆火，而其并非一个全新的概念，实际上1957年莱杰伦·希勒（Lejaren Hiller）和伦纳德·艾萨克森（Leon-ard Isaacson）完成了人类历史上第—支由计算机创作的音乐作品就可以看作是生成式人工智能技术的开端，距今已有65年，这期间随着计算机技术与硬件的发展以及数据的丰富，也不断有各种形式的生成模型、AI 生成作品出现。而根据生产式人工智能技术的核心原理，大致可以将其发展历程分为三个阶段：1）基于数学模型与统计方法的探索期，2）基于基础深度学习模型的发展期，3）基于预训练大模型的繁荣期，分阶段简介如下。
早期（1957-1990左右）的生成式人工智能技术主要受限于计算机的数据处理能力以及研究者相关创意的缺乏，主要还是集中在分析型人工智能的模型设计与实践。在生成式人工智能技术的探索部分，主要是将数学分析方法引入计算机中，基于规则和统计方法生成自然语言文本、简单图像与旋律等供数据增强与相关人员使用。同时，在简单应用场景使用中，探索期的生成式人工智能技术也为规划和排程问题、专家系统等领域提供了解决方案。早期生成的结果相对简单和有限。然而，这些早期的研究为后续生成式人工智能技术的发展打下了基础，并为今天更先进的生成模型和应用奠定了基本原理。
而随着计算机技术与硬件的发展，同时许多深度学习模型逐渐火热且被应用于各种计算机视觉、自然语言处理任务，生成式人工智能技术进入了发展期（1990-2018左右），一些经典的模型/技术总结于表1，同时也有大量真实应用与方案被提出。如Adobe的Sensei AI技术（参考[2]）提供了内容生成和修复功能，可以自动生成图像、修复图像缺陷并提供智能编辑建议，广泛应用于创意设计和图像处理领域。又如DeepMind的AlphaGo项目（参考[3]）开发出了世界级的围棋人工智能在2016年击败了围棋世界冠军李世石，引起了广泛的关注，展示了生成式人工智能技术在复杂策略游戏中的应用潜力。另外还有广为人知的ChatGPT的前身——来自OpenAI的GPT系列早期模型（如GPT-2，参考[4]）被广泛应用于自然语言处理领域，包括文本生成、简单问答等。它们能够根据输入的提示生成连贯、富有创意的文本内容。综上所述，生成式人工智能技术的发展期涌现了许多经典模型，生成结果已经相对合理，同时也积累了大量真实的应用案例。这些技术和应用不仅在计算机相关领域取得了重要突破，还在创意设计、图像处理、游戏和其他领域中展现了巨大的潜力。
表1 发展期生成式人工智能技术的经典模型/技术
模型
简介
循环神经网络（LSTM，GRU等）
一般具有较强的记忆能力和序列建模能力，被广泛应用于机器翻译、对话系统、文本生成等NLP任务。
变分自编码器（VAE）
一种学习数据潜在变量分布的生成模型，生成与原始数据相似的新样本。广泛应用于图像生成、图像修复和特征学习等任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97525f87f3d3df822ea681c73cea6175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61aa3cebbfa5520975f77fe95442e4b8/" rel="bookmark">
			【随想】复杂与简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 生活的教训 最近，家里的东西接二连三的出问题，挺闹心。
首先是家里卫生间洗手盆脱落掉在了洗手台下，挺吓人，还好没有砸到脚，下面有个柜子在支撑着。在群里问了下邻居，大家也都有这种情况，说明台下盆脱落比较常见。于是自己动手买了材料装了上去，又买了支撑架撑起来，估计能坚持一年。
然后是洗衣机洗完衣服莫名其妙的出现很多白色颗粒物，搜索之后了解到，这是洗烘一体机的弊病。白色粉末是烘干管道中的铝材被氧化了，拆开洗衣机顶盖，烘干风扇附近有非常多的颗粒，有的凝结成了鸡蛋大小，情况十分严重。折腾一上午，做了个清理。
这两件事对我有些触动。
首先，今后再装修卫生间，一定安装台上盆，简简单单，永不脱落。
其次，今后再买洗衣机，一定不买洗烘一体机，有条件各买洗衣机和烘干机，简单纯粹，专业机器做专业事。
2 感悟 这次生活中的麻烦，让我体会到简单的好处。
2.1 简单，功能简单 对用户的认知和使用要求就低，就能让更多的用户使用。这也是易用性。
2.2 简单，价格优惠 功能简单，不复杂，成本造价低，会有更多的用户购买。
2.3 简单，方便清理好维护 在现实生活中，这个是重中之重。当前，家电的清洗和简单维修，我觉得过于复杂了。
空调清洗、洗衣机清洗、抽油烟机清洗，这些家电还是构造有些复杂了，或者没有留下给用户自行清理的接口。
简单的家电，应该内部构造简洁，用户自己能动手清理和养护。
这次的洗衣机，因为有烘干功能，它拆起来非常麻烦。需要把滚筒拆了才能拆洗烘干管道，最后因过于麻烦而作罢，只清理了风扇。
3 软件 在软件领域，简单更显得必要。
3.1 简单好理解 修改自己很久之前的代码或者修改别人的代码都“情不自禁”的觉得是在改一坨狗屎，多半是因为难以快速的理解。
3.2 简单好复用 堆砌过的功能反而让人无法理清思路，无法自由删减。千头万绪，像离愁。谁愿意摊上这种事。
3.3 简单纯粹不易错 只做好一件事，比做好十件事自然会容易很多，质量也会得到保证。
3.4 利人利己 这种好事可不多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430574d422ce0fc07ce54bdc032e1f4f/" rel="bookmark">
			数据分析二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据处理 当数据量较大时，将数据所有信息输出到控制台中会显得过于冗杂，可通过查看部分数据信息，简要了解数据的特性。
（1）查看数据前5行和尾部倒数5行数据，列名和索引信息，数据行列形状
csv.head()#查看前几行 csv.tail()#查看后几行 csv.columns#查看列名 csv.index#查看索引 csv.shape#查看形状 (2)查看各列数据描述性统计信息，如最小值、最大值、均值、标准差等
csv.describe() （3）查看数据是否有缺失及每列数据的类型
csv.info() 缺失值处理
对Pandas做数据时不可避免会因为一些原因出现缺失值NaN（Not a number），比如两个DataFrame对象进行运算时对于无法匹配的位置就会出现缺失值。通过数据信息查看可知数据中存在缺失值，比如dataA、dataC、dataE各存在2个NaN，dataB、dataD、各存在1个NaN。
（1）Pandas包中isnull()和notnull()方法用于判断数据是否为缺失值，若是缺失值则isnull()返回值为True，notnull()返回值为False。
csv.isnull() (2）由于isnull()和notnull()方法判断缺失值生成的是所有数据的True/False矩阵，对于庞大的Dataframe数据，很难一眼看出缺失值位置，可在df_csvload.isnull()矩阵基础上结合数据转置方法.T和筛选满足True值条件列方法.any()，查找出含有NaN值所在的行。
csv.isnull().T.any().T]#查看NAN值所在行 （3）对缺失值的处理的方法有删除和填充，此处通过DataFrame.dropna()方法将所有值都为缺失值的行删除，DataFrame.fillna()方法在列方向上对缺失值前值填充。
csv = csv.dropna(axis=0,how='all')#NAN值删除 行所有为NAN删除 csv.fillna(method='ffill',axis=0,inplace=True)#NAN值填充 列方向前值填充 csv[csv.isnull().values==True]#查看NAN值删除填充后值 二、数据重塑 一、stack
stack的计算机术语是“栈”，那么应用到DataFrame上，可以理解为将所有的列全部进行“入栈”操作(push)。可以看到，我们的DataFrame有以下列：['语文','英语','数学','物理']，把它们全部入栈，就是挨着把这些列一个个的压进去，最终就形成了一个新的索引列：['学科']
我们可以把stack操作叫做压缩，stack压缩操作带来的效果是：
由列变成了行：['语文','英语','数学','物理']这些列的数据，全部都变成了每一行。数据由原来的“宽格式”变成了“厚格式”：也即全部的列宽度都压缩到了行厚度上面，全部的列名称组成了一列新的索引。 stack操作的时候，默认会滤除缺失NaN数据
二、unstack
unstack是stack的逆操作：出栈把“栈”里面的数据全部弹出来(pop)
我们可以把unstack操作叫做解压，同理unstack解压操作带来的效果就刚好和stack相反：
由行变成了列：['学科']索引列里面的每行数据，全部都变成了单独的一列。数据由原来的“厚格式”变成了“宽格式”：也即全部的行厚度都释放到了列宽度上面，索引列中的全部成员都被分解成了单独的一列。 四、pivot
pivot---数据透视。这是excel的一大杀器！
（一）、unstack实现无索引解压
前面讲过了，unstack操作的效果是：索引列中的全部成员都被分解成了单独的一列。所以，unstack操作一般是要求要有索引列。但是有些时候，数据是没有明显的索引列的，
（二）、pivot实现无索引解压
上面的过程稍显复杂，于是Pandas定义一种快捷方法pivot来实现
df=df.pivot(index=,columns=) pivot本质上就是unstack的一种快捷方式，并不是一种新的重塑方法。二者的等价关系是：
pivot(index='目标索引列',columns='需要解压的列'])
==等价于==
set_index(['目标索引列','需要解压的列']).unstack('需要解压的列')
（三）、melt
pivot是unstack的快捷方式，那stack有没有类似的快捷等价方式呢？有，那就是melt。
df=df.melt(id_vars=['学生'],var_name='科目',value_name='成绩') var_name参数用于指定压缩后的新列名称，value_name参数用于相应的数据列名称，通过这个操作，一步就直接到位
三、数据规整 数据连接
根据单个或者多个键(列)将不同的DataFrame的行进行连接
类似数据的连接操作
pd.merge:(left, right, how=‘inner’,on=None,left_on=None, right_on=None )
left:合并时左边的DataFrame
right:合并时右边的DataFrame
how:合并的方式,默认’inner’, ‘outer’, ‘left’, ‘right’
on:需要合并的列名,必须两边都有的列名，并以 left 和 right 中的列名的交集作为连接键
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/430574d422ce0fc07ce54bdc032e1f4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f74c324d28bb4fc29f30c49218df460c/" rel="bookmark">
			nginx 同一个端口支持http和https配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理：使用nginx的stream、 stream_ssl_preread模块 1.编译nginx
由于stream和stream_ssl_preread模块非默认引入，需要在编译安装nginx时引入；编译时添加配置参数 --with-stream --with-stream_ssl_preread_module
./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_stub_status_module --with-stream --with-stream_ssl_preread_module --with-stream_ssl_module
执行make &amp; make install
2.配置nginx.conf
添加stream配置，让其识别到http访问时默认走http,其余走https
stream { upstream http_gateway { server 127.0.0.1:8077; } upstream https_gateway { server 127.0.0.1:8076; } map $ssl_preread_protocol $upstreama{ default http_gateway; "TLSv1.0" https_gateway; "TLSv1.1" https_gateway; "TLSv1.2" https_gateway; "TLSv1.3" https_gateway; } server { listen 2345; ssl_preread on; proxy_pass $upstreama; } } http { ****** } 3.配置http和https访问资源
http { include mime.types; default_type application/octet-stream; sendfile on; upstream gateway_service{ server 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f74c324d28bb4fc29f30c49218df460c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa83441465d4892798eaecff980e02e/" rel="bookmark">
			Img标签的src地址自动拼接本地域名（localhost:8080）导致图片不显示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：做Vue+element ui项目的时候，发现使用element ui的upload上传图片时，不显示的问题。我项目的图片是上传到七牛云，长传成功后返回存储在七牛云中的地址。后面发现是因为返回的地址是外部地址，需要完整的URL，不然会被视为本地的绝对路径.解决方法是在链接前面加上 http:// ，可直接选择在后端处理拼接，减小前端修改代码次数。
1.问题描述 前端代码：
&lt;el-upload class="avatar-uploader" name="img" :action="uploadURL" :headers="MyHeader" :show-file-list="false" :on-success="handleAvatarSuccess" :before-upload="beforeAvatarUpload"&gt; &lt;img v-if="userInfoObj.avatar" :src="userInfoObj.avatar" :onerror="$store.state.errorImg" class="avatar"&gt; &lt;i v-else class="el-icon-plus avatar-uploader-icon"&gt;&lt;/i&gt; &lt;div slot="tip" class="el-upload__tip"&gt;点击上传头像，只能上传jpg/png文件，且不超过1mb&lt;/div&gt; &lt;/el-upload&gt; 前端请求示例：
只上传一张图片。
后端返回结果：
将data中的链接直接用浏览器访问是可以查看到图片。但项目页面图片不显示，如下图：
对页面元素进行检查，发现好像地址没问题：
可为啥就是访问不了呢，接下来直接复制没显示图片的地址，看它是否有问题，选中未显示图片，鼠标右键复制图片地址。
图片地址：
注意看，发现图片真正请求时竟然加上了本地域名localhost, 难怪访问不到图片，图片url被错误拼接了。
2.解决方法 因为返回的地址是外部地址，需要完整的URL，不然会被视为本地的绝对路径.
解决方法是在链接前面加上 http:// ，可直接选择在后端处理拼接，减小前端修改代码次数。
方法1:前端访问时，img src属性加上http//
方法2：后端地址拼接上http://后返回给前端，img src直接使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8adf517bdfce913a0ed7ff3c1d9950ed/" rel="bookmark">
			常见排序算法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.直接插入排序
2.希尔排序
3. 简单选择排序
4. 堆排序
5.冒泡排序
6. 快速排序
7. 2路归并
8.基数排序
9.数据测试
10.算法的稳定性
11.表格
1.直接插入排序 从前往后，每次在前面已经排好序的数组里找到自己的位置并插入；
public void sort(int[] arr) { for(int i=0;i&lt;arr.length;i++){ for(int j=i-1;j&gt;=0;j--){ if(arr[j]&gt;arr[j+1]) { swap(arr,j,j+1); }else{ break; } } } } 2.希尔排序 从len/2的间隔开始每次折半，每一次的排序，按照间隔将间隔特定距离的数按照直接插入排好；
public void sort(int[] arr,int k) { if(k==0) return; for(int j=k;j&lt;arr.length;j+=k){ for(int q=j-k;q&gt;=0;q-=k){ if(arr[q]&gt;arr[q+k]){ swap(arr,q,q+k); } } } sort(arr,k/2); } 3. 简单选择排序 每次选择未排序中的最小值，插入到已经排序的数列的末尾
public void sort(int[] arr) { for (int i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8adf517bdfce913a0ed7ff3c1d9950ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd5ba8e93de501beecb8685a378f6c73/" rel="bookmark">
			程序员推荐 Python编程：从入门到实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Python编程：从入门到实践》是一本适合初学者的Python编程教材。它以通俗易懂的方式引导读者逐步学习Python编程语言，并通过实践案例帮助巩固所学内容。
这本书首先介绍了Python的基本概念和语法，如变量、数据类型、条件语句和循环等。它使用简单明了的示例帮助读者理解这些概念，并提供练习题来加强记忆。
随着学习的深入，《Python编程：从入门到实践》开始介绍更高级的主题，如函数、模块、文件操作和异常处理等。通过这些内容，读者将学会如何编写模块化的代码，以及如何处理各种输入和输出。
这本书还集中讲解了Python编程的实践应用，包括数据可视化、Web开发、游戏开发等方面。通过实际案例，读者可以将所学的知识应用到实际项目中，提升自己的编程能力。
此外，这本书还强调了编程的最佳实践和良好的代码风格。它教授了一些常用的编程技巧和调试方法，帮助读者编写出可读性强、可维护性好的代码。
总而言之，《Python编程：从入门到实践》是一本循序渐进、注重实践的Python编程教材。它适合初学者入门和提高，通过理论与实践相结合的方式，帮助读者快速掌握Python编程基础，并能够应用于实际项目中。
送电子版原文地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0792928d2cf25e79dae0899f154e33be/" rel="bookmark">
			N皇后问题——回溯求解一般方法（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 八皇后问题十分经典，也就是每两个棋子之间不能处于同一行、同一列、同一对角线。
此类问题，可以视作在约束条件下进行先序（根）遍历，并在遍历过程中剪去那些不满足条件的分支。
如图，就是一个四皇后问题的棋盘状态树，可以看到，在递归过程中不仅有落子行为，还有剪枝行为。
二、问题思路 可以采用回溯求解的一般思路，以下是书本上的伪代码思路。
void Trial(int i, int n) { // 当进入本函数时，在nxn的棋盘的前i-1行已有满足条件的i-1个棋子 // 现从第i行开始为后续棋子选择位置 // 当i&gt;n时，即为合法布局，输出之 if(i&gt;=n) 出现符合的棋局，输出结果 else { for(j = 1; j&lt;=n; j++) { 在第i行j列放棋子 if(当前布局合规) Trial(i+1, n); 移除第i行j列的棋子 } } } 三、具体实现 其中 i 是行，从 0 开始计数；n 代表每行最大元素数目；board是棋盘数组，由于二维数组的存储可以视为一维数组，因此可以用 board[n*i +j] 表示第 (i, j) 号元素。
//到第 i 行都放了合规的棋子 void Queen(int i, int n, int* board) { if(i&gt;=n) { //出现符合的棋局，输出结果 sum += 1; //统计有多少解法 printf("result:%d\n", sum); for(int x = 0; x&lt;n*n; x++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0792928d2cf25e79dae0899f154e33be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ec8e267b1a23f612c410ddc3ddf576/" rel="bookmark">
			程序员推荐JavaScript高级程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《JavaScript高级程序设计》是一本非常经典的书籍，它帮助初学者逐步学习并深入了解JavaScript编程语言。这本书覆盖了广泛的主题，从基础知识到高级技术都有涉及。
首先，我们需要知道JavaScript是一种脚本语言，可以在网页上添加交互和动态效果。想象一下，在网页上有一个按钮，当你点击它时，会触发一些特定的操作，比如显示一条消息或改变页面的外观。这些都是JavaScript可以做到的事情。
《JavaScript高级程序设计》教你如何开始使用JavaScript，包括如何在HTML文件中嵌入JavaScript代码，并且解释了常用的语法和特性。你会学习如何声明变量、使用条件语句和循环，以及如何处理数组和对象等数据类型。
随着你的学习进度，书中将引导你了解更高级的主题，比如函数、闭包和面向对象编程。你将学习如何编写可重复使用的代码块，以及如何组织和管理代码。
此外，书中还介绍了浏览器对象模型（DOM）和文档对象模型（DOM），它们是JavaScript与网页交互的基础。你将学习如何通过JavaScript获取和修改网页上的元素，以及如何响应用户的交互。
另外一个重要的主题是异步编程，JavaScript中经常需要处理异步操作，比如从服务器获取数据或处理用户输入。《JavaScript高级程序设计》会向你解释如何使用回调函数、Promise和异步函数来处理这些情况。
总之，这本书以通俗易懂的方式介绍了JavaScript的各个方面，从基础知识到高级技术都有覆盖。它是学习JavaScript编程的良好指南，无论你是初学者还是有一些经验的开发者，都可以从中受益匪浅。
送电子版原文地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b362ef06612786aba194ad83def9fa/" rel="bookmark">
			记录一下：基于nginx配置的封禁真实IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx Situation（背景）Task（任务）Action（行动）1：方法1：使用nginx 自带的deny 和 allow 来实现2：方法2：添加配置 Result（结果） Situation（背景） 服务器正在被使用
Task（任务） 封禁指定网段的IP
Action（行动） 1：方法1：使用nginx 自带的deny 和 allow 来实现 由于nginx封禁的是抵达服务器前的那个代理的ip，并非真实IP所以失败了
2：方法2：添加配置 http { ... geo $ip_addr $real_ip { default ""; 219.248.141.0/24 "blocked"; } # 首先定义了一个名为 $ip_addr 的变量，它将从客户端请求中提取出 IP 地址； # 然后定义了一个名为 $real_ip 的变量，它将根据 $ip_addr 的值获取到对应的真实 IP 地址； # 接着通过 geo 块对真实 IP 进行判断，如果属于 219.248.141.0/24 网段，则将其设置为字符串 "blocked"，否则将其设置为默认值 ""； # 最后使用 map 块将 $real_ip 映射到一个变量 $block，如果 $real_ip 被设置为 "blocked"，则将 $block 设置为 1，否则设置为 0。 map $real_ip $block { default 0; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60b362ef06612786aba194ad83def9fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d38a62671660bbc72c71d2214963987/" rel="bookmark">
			Integer底层原理探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. int和Integer的区别
2. 前提知识：
3. 实验比较：
1. int和Integer的区别 ● int是基本数据类型，代表整型数据，默认值是0；
● Integer是 int的包装类，属于引用类型，默认值为null；
● int 和 Integer 都可以表示某一个整型数值；
● Integer变量实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值；
● Integer可以区分出未赋值和值为 0 的区别，而int 则无法表达出未赋值的情况；
● int 和 Integer 不能够互用，因为他们是两种不同的数据类型；
● int在初始化时，可以直接写成 int=1 的形式；
● 因为Integer是包装类型，使用时可以采用 Integer i = new Integer(1) 的形式，但因为Java中的自动装箱和拆箱机制，使得对Integer类的赋值也可以使用 Integer i= 1 的形式；
● 如果我们只是进行一些加减乘除的运算 或者 作为参数进行传递，那么就可以直接使用int这样的基本数据类型；但如果想按照对象来进行操作处理，那么就要使用Integer来声明一个对象。
2. 前提知识： 1，装箱存在的情况： int 赋值给Integer 即基本类型赋值给包装类型时
Integer i = 1; 等价于 Integer i = Integer.valueOf(1); java自动完成装箱操作,
2，拆箱存在的情况： int与Integer比较 及基本类型和包装类型比较时
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d38a62671660bbc72c71d2214963987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/990d09793588c48182175e29180f761a/" rel="bookmark">
			NodeJs-fs模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、fs简介二、文件写入2.1 writeFile 异步写入2.2 writeFileSync 同步写入2.3 appendFile / appendFileSync 追加写入2.4 createWriteStream 流式写入 三、文件读取3.1 readFile 异步读取3.2 readFileSync 同步读取3.3 createReadStream 流式读取 四、文件移动与重命名五、文件删除六、文件夹操作6.1 mkdir创建文件夹6.2 readdir 读取文件夹6.3 rmdir 删除文件夹 七、查看资源状态八、__dirname 和 path8.1 __dirname8.2 path 模块 一、fs简介 ~~~~~~ fs 全称为 file system ，称之为 文件系统 ，是 Node.js 中的 内置模块 ，可以对计算机中的磁盘进行操作。
主要介绍如下几个操作：
文件写入文件读取文件移动与重命名文件删除文件夹操作查看资源状态 二、文件写入 文件写入就是将 数据 保存到 文件 中，我们可以使用如下几个方法来实现该效果
方法说明writeFile异步写入writeFileSync同步写入appendFile /appendFileSync追加写入createWriteStream流式写入 2.1 writeFile 异步写入 语法： fs.writeFile(file, data[, options], callback)
参数说明：
file 文件名data 待写入的数据options 选项设置 （可选）callback 写入回调 返回值： undefined
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/990d09793588c48182175e29180f761a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d00445a7f7381771b2729088daad7b/" rel="bookmark">
			C语言的数据类型简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本类型
（1）六种基本类型
**字符串常量和字符常量的不同
1）‘a’为字符常量，”a”为字符串常量
2）每个字符串的结尾，编译器会自动添加一个结束标志位‘\0’
“a”包含两个字符’a’和’\0’
（2）测试
1）测试代码–各类型占用字节数和输出展示
#include &lt;stdio.h&gt; int main(int argc, char *argv[]) { //定义char，占用1个字节，输出使用%c char a = 'w'; printf("a = %c ,",a); printf("a %d byte\n ",sizeof(a)); //定义short，占用2字节，输出使用%d short b = 1; printf("b = %d ,",b); printf("b %d byte\n ",sizeof(b)); //定义int,占用4字节，输出使用%d int c = 2; printf("c = %d ,",c); printf("c %d byte\n ",sizeof(c)); //定义long,占用4字节，输出使用%ld long d = 3; printf("d = %ld ,",d); printf("d %d byte\n ",sizeof(d)); //定义float，占用4字节，输出使用%f float e = 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41d00445a7f7381771b2729088daad7b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/45/">«</a>
	<span class="pagination__item pagination__item--current">46/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/47/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>