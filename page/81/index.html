<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133b9d11522f965ada454a746d261b65/" rel="bookmark">
			软件课设（Ⅲ）——padavan-ng编译以及内核模块修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我记得今年的很多笔试面试都遇到了linux相关的操作，答题状况都挺……昂。算是补课吧，正好大四的毕业实习、软3还有研0的项目都需要linux的环境进行推进，记录一下，聊作纪念。
实验要求
编译系统，下载并提交，验收的时候，我会找MIPS板子，让大家下载验证。编译一个内核模块，内容任选，随系统提交，要求内容可体现在系统日志中。编译一个应用模块，内容任选，以固件形式随系统提交，要求可在自指定文件中有结果显示。trunk/linux-3.4.x/kernel/sched/core.c 是进程相关的一个核心文件，同学们在必要函数前加注释，画出大体调度流程。
trunk/linux-3.4.x/mm/page_alloc.c 是内存管理相关的一个核心文件，同学们在必要函数前加注释，画出大体分配流程。 1 虚拟机的安装以及环境配置 不一定非要是老师给的MV系统，但是ubuntu的版本建议用老师给的版本，不然可能安装过程会有一些比较头疼的事情。
但是老师给的是无图形界面的，对于大部分刚接触的同学而言，确实不够友好。所以这里也可以安装同版本的带UI版本。
我自己的话，是按照老师的流程走的，主要是当时虚拟机装了两个，内存不允许我再折腾UI版本的了😅。
2 实验一：编译系统 这个没什么好说的，就是按照老师给的流程走一遍，注意有一些包的安装，如果在编译的过程中报错说缺包，复制出错语句，搜索一下相关安装命令即可。
3 实验二 1、首先进入项目目录中的/trunk/linux-3.4.x/drivers目录下，新建一个自己的内核工程文件
cd ./trunk/linux-3.4.x/drivers # 进入drivers目录 mkdir ghykernel	# 新建自己的工程目录，这里我起名为ghykernel 2、接着，进入该目录，新建三个工程文件xx.c，Kconfig，Makefile
cd ghykernel touch ghykernel.c Kconfig Makefile # 第一个.c文件名称不限，Kconfig和Makefile需要严格按照这个名称，后面编译需要 接着可以在命令行输入ls命令，查看文件是否正常创建：
ls 成功创建如下：
3、接下来我们需要给三个文件分别写入相应的内容：
首先写入.c文件 vi ghykernel.c #进入文件的读写模式，同时回车后需要按下键盘上的”I“进入插入模式 像Windows一样写入文件即可
ghykernel.c内容如下：
#include&lt;linux/module.h&gt; MODULE_LICENSE("MIT"); MODULE_AUTHOR("GHY"); MODULE_DESCRIPTION("KERNEL EDIT EXAMINATION"); MODULE_VERSION("1.0"); //内核模块参数，加载时指定或者动态指定，以控制此模块的行为 static char *name ="GHY"; module_param(name,charp,S_IRUGO); NODULE_PARAM_DESC(name,"---------now it is a print test---------"); //初始化函数，在加载时调用，分配资源准备执行环境 static int __init ghy_print_init(void){ printk(KERN_INFO "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/133b9d11522f965ada454a746d261b65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2575387ee3ffd04b1b5207d304052d/" rel="bookmark">
			小白学C语言之返回值（return语句）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、返回值的概念 return 表示把程序流程从被调函数转向主调函数并把表达式的值带回主调函数，实现函数值的返回，返回时可附带一个返回值，由return后面的参数指定。 return通常是必要的，因为函数调用的时候计算结果通常是通过返回值带出的。 如果函数执行不需要返回计算结果，也经常需要返回一个状态码来表示函数执行的顺利与否（-1和0就是最常用的状态码），主调函数可以通过返回值判断被调函数的执行情况。
在这里放上函数调用的概念，帮助各位理解一下C语言中的函数调用：
函数调用https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/4127405?fromModule=lemma_inlink
上面的概念或许会过于抽象，用简洁一点的语言来表达就是，在C语言中，函数之间的互相调用是非常常见的，而为了防止调用的时候出错，就需要一个状态码来判断函数执行的顺利与否，这个状态码就被我们称为返回值。
二、return语句的作用 1.需要注意的是，返回值其实就是return语句后面的参数。
2.当函数进行到return语句时，就代表了让函数提前结束。
3.在C语言中，语法规定返回值不能有多个，只能有一个。
4.C语言几十年的发展历史中，有一些历史遗留问题，关于返回值也有这样一个问题：
程序正常执行时，返回值为零。
三、总结 关于return语句，我在努力学习中，只总结了这几点小内容，后续有学习到这方面的知识会再进行补充。
如果这篇博客有什么不足之处，欢迎各位在下方评论提出，希望能和C友们一起进步！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a74a89f16d98e414aff7d42c040613b/" rel="bookmark">
			【C语言】小白学浮点数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、浮点数的概念 浮点数也称小数或实数。 C语言中采用 float 和 double 关键字来定义小数, float称为单精度浮点型,double称为双精度浮点型。
另外，部分编译器支持更大精度的long double，但不是所有的编译器都支持。
二、浮点数的精度 float只能表达6 - 7位的有效数字，不能用“ == ”判断两个数字是否相等。
double能表达15 - 16位有效的数字，可以用“ == ”判断两个数字是否相等。
long double占用的内存有16 字节， 12字节，8字节。 其中16字节占大多数。
就拿我使用的编译器 Visual Studio 2022 来说吧
运行结果 由此不难看出，在C语言中，浮点类型的单精度值具有 4 个字节，而double的双精度值具有8个字节，long double类型则是由不同编译器来决定的。
值得一提的是，在C语言中，规定了以下标准：
float只能表达6 - 7位的有效数字，不能用“ == ”判断两个数字是否相等。
double能表达15 - 16位有效的数字，可以用“ == ”判断两个数字是否相等。
long double表达数据的精度和double相同。
三、浮点数的输出 不同于整型的 %d ，浮点数的输出为 %f 和 %lf 。其中，float类型对应 %f 格式的输出，而double 类型对应 %lf 格式的输出。
在浮点数的输出中，有几点需要注意的：
1.C语言中printf输出float和double都可以用 %f，而double型数据还可以用 %lf。
2.scanf当中若是对双精度的变量（对应double类型）赋值必须是%后跟lf,而printf当中可以用 %f 也可以用 %lf 没有限制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a74a89f16d98e414aff7d42c040613b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d27e600e46fead2018da3334573ab3/" rel="bookmark">
			Anaconda 更换镜像源、创建虚拟环境并安装 PyTorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.更换镜像源2.选择合适的 CUDA Runtime 版本2.1 CUDA Runtime 版本不能高于 CUDA Driver 版本2.2 根据显卡的算力和架构确定 CUDA Runtime 版本2.3 找到安装 PyTorch 的命令行 3.在 Anaconda 中管理虚拟环境并安装 PyTorch3.1 查看所有虚拟环境3.2 创建虚拟环境3.3 切换/激活虚拟环境3.4 查看当前环境下安装的所有包3.5 安装 PyTorch3.6 退出虚拟环境3.7 删除虚拟环境 1.更换镜像源 北京外国语大学开源软件镜像站：https://mirrors.bfsu.edu.cn/help/anaconda/
Windows 用户无法直接创建名为 .condarc 的文件，可先执行如下命令生成 .condarc 之后再修改。
conda config --set show_channel_urls yes 生成的 .condarc 存储在 C:\Users\账户名 目录下：
用记事本打开 .condarc，将镜像站提供的如下内容拷贝进去：
channels: - defaults show_channel_urls: true default_channels: - https://mirrors.bfsu.edu.cn/anaconda/pkgs/main - https://mirrors.bfsu.edu.cn/anaconda/pkgs/r - https://mirrors.bfsu.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.bfsu.edu.cn/anaconda/cloud msys2: https://mirrors.bfsu.edu.cn/anaconda/cloud bioconda: https://mirrors.bfsu.edu.cn/anaconda/cloud menpo: https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d27e600e46fead2018da3334573ab3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb73ceaebe7108454b237b36b1df76f/" rel="bookmark">
			Vs Code 配置使用 ssh remote
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vs Code 配置使用 ssh remote，实现远程写代码 1. 安装插件2. 配置ssh2.1 生成本地ssh密钥2.2 VS Code配置ssh信息 VS Code基础入门使用可查看： VS Code 基础入门使用（配置）教程
其他Vs Code 配置可关注查看： Vs Code 配置专栏
1. 安装插件 在VS code 拓展中安装Remote Development(包括其他官方remote方式，比如wsl)或Remote - SSH
2. 配置ssh 2.1 生成本地ssh密钥 首先终端中生成ssh密钥： ssh-keygen -t rsa 会询问保存ssh密钥的位置及密码，保持默认直接回车三次即可。
生成后可以查看结果： cd ~/.ssh # 进入ssh密钥目录 cat id_rsa.pub # 查看密钥内容 将配置文件复制到远程服务器 对于本地电脑为Linux用户
ssh-copy-id username@ip/domain_name -p port # 例如：ssh-copy-id username@/192.168.1.1 -p 22 # 例如：ssh-copy-id username@xxx.com -p 22 对于本地电脑为Windows用户:
type $env:USERPROFILE\.ssh\id_rsa.pub | ssh username@ip/domain_name "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bb73ceaebe7108454b237b36b1df76f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cab5d875cda8523ca47e86d4079552a/" rel="bookmark">
			MySQL - text字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、text属性 MySQL下的TEXT属性一种特殊的字符串，存储单位为字节，有四种类型
TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT
不同的是可以存储的字符串的长度以及空间占用大小
TINYTEXT最大存放长度为255个字符的字符串
TEXT最大存放长度为65535个字符的字符串
MEDIUMTEXT最大存放长度为16772150个字符的字符串（int最大值16M）
LONGTEXT最大存放长度为4294967295个字符的字符串(long最大值4G)
TEXT类型被用来存储非二进制字符集，二进制字符集使用blob类型的字段来存储。对于text列，插入时MySQL不会对它进行填充，并且select时不会删除任何末尾的字节
使用时不需要指定长度，因为已经有默认最大可存储字节数，长度可变
如果要存储字符，一个中文字符可能占用3个字节，存储选择哪种类型需要根据实际选择
允许的长度是指实际存健的字节数，而不是实际的完符介数。如假设一个中文字符占两个字节，那TEXT类型可存65535/2=32767个中文字符，而varchar(100)可存储100个中文字符，实际占200个字节，但varchar(65535)并不能存储65535个中文字符，因为巳超出表达范围。
以上各类型无须指定长度
#创建数据库表,e_text可存储255个字节,v_char可存储255个字符 &gt;mysql create table text_example(e_text tinytext, v_char varchar(255)); #插入失败,utf8mb4用3个字节表示一个中文汉字,会超出tinytext保存范围 &gt;mysql insert into char_example values(90个中文字符,90个中文字符); #插入成功 &gt;mysql&gt; insert into char_example values(80个中文字符,100个中文字符); 对比 1、char长度固定，即每条数据占用等长字节空间，适合用在身份证号码、手机号码等。超过255字节只能用varchar或者text
2、varchar可变长度，可以设置最大长度，适合已知最大可用长度的情况下，用在长度可变的属性。varchar可变长度，可以设置最大长度，适合用在长度可变的属性
3、text不设置长度，当不知道属性的最大长度时，适合用text，能用varchar的地方不用text
按照查询速度：char &gt; varchar &gt; text最慢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eb22600542506ab907d718e513b055a/" rel="bookmark">
			MySQL进阶篇之索引1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		02、索引 2.1、索引概述 1、介绍
索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。
2、演示
备注：上述二叉树索引结构只是一个示意图，并不是真实的索引结构。
3、优缺点
优势劣势提高数据检索的速率，降低数据库的IO成本索引列也是要占用空间的。通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。 2.2、索引结构 2.2.1、介绍 MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：
索引结构描述B+Tree索引最常见的索引类型，大部分引擎都支持B+树索引Hash索引底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询R-tree（空间索引）空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少Full-text（全文索引）是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solr，ES 索引InnoDBMyISAMMemoryB+Tree索引支持支持支持Hash索引不支持不支持支持R-tree索引不支持支持不支持Full-text5.6版本之后支持支持不支持 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。
2.2.2、BTree 1、二叉树
二叉树缺点：
① 顺序插入时，会形成一个链表，查询性能大大降低。
② 大数据量情况下，层级越深，检索速度慢。
2、红黑树
解决了二叉树的缺点①
红黑树缺点：
① 大数据量情况下，层级越深，检索速度慢。
3、BTree(多路平衡查找树)
① 例如：一棵最大度数（max-degree）为5（5阶）的BTree（每个节点最多存储4个key，5个指针）：
知识小贴士：树的度数指的是一个节点的子节点个数。
② 插入100、65、169、368、900、556、780、35、215、1200、234、888、158、90、1000、88、120、268、250数据为例
具体动态变化的过程可以参考网站：https://www.cs.usfca.edu/~galles/visualization/BTree.html
2.2.3、B+Tree 1、以一颗最大度数（max-degree）为4（4阶）的B+Tree（每个节点最多存储3个key，4个指针）为例：
2、 插入100、65、169、368、900、556、780、35、215、1200、234、888、158、90、1000、88、120、268、250数据为例
B+Tree与BTree区别（B+Tree的特点）：
所有的数据都会出现在叶子节点叶子结点构成一个单向有序链表 3、MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子结点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。
2.2.4、Hash 1、哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。
如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。
2、Hash索引特点：
Hash索引只能用于对等比较（=，in），不支持范围查询（between，&gt;，&lt;，…）无法利用索引完成排序操作查询效率高，通常只需要一次检索就可以了，效率通常要高于B+Tree索引 3、存储引擎支持
在MySQL中，支持Hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。
2.2.5、思考题 为什么InnoDB存储引擎选择使用B+Tree索引结构？
相对于二叉树，层级更少，搜索效率高；相对于BTree，无论是叶子结点还是非叶子结点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能的降低；相对于Hash索引，B+Tree支持范围匹配及排序操作。 2.3、索引分类 1、索引分类
分类含义特点关键字关键索引针对于表中主键创建的索引默认自动创建，只能有一个PRIMARY唯一索引避免同一个表中某数据列中的值重复可以有多个UNIQUE常规索引快速定位特定数据可以有多个全文索引全文索引查找的是文本中的关键词，而不是比较索引中的值可以有多个FULLTEXT 2、在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：
分类含义特点聚集索引（Clustered Index）将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据必须有，而且只有一个二级索引（Secondary Index）将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键可以存在多个 聚集索引的选取规则：
如果存在主键，主键索引就是聚集索引。如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。 具体使用：
回表查询：先根据条件在二级索引找到对应的主键值，再将主键值在聚集索引中查找，找到对应的行数据。
即：先根据name='Arm’在二级索引中找到对应的id值为10，再将id=10在聚集索引中查找，找到对应的row。
3、思考题
① 以下SQL语句，哪个执行效率高？为什么？
select * from user where id = 10; select * from user where name = 'Arm'; # 备注：id为主键，name字段创建的有索引; 答：第一个SQL语句执行效率高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eb22600542506ab907d718e513b055a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ebd30ac1ad6d418cd2ef6d0720b3537/" rel="bookmark">
			Python基础—分支结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分支结构 判断在Python中就是分支结构 分支结构需要用的系统关键字（系统保留字）：if，else、elif 一、单分支结构：只有是和否两种情况。 语法： if 条件： 代码块1 else: 代码块2 分支结构，只有一条分支能够被执行，某一条分支被执行了，其他分支不再执行。某一条分支被执行，就意味着这条分支的代码块被执行。 二、三目运算符 解决单分支结构臃肿的问题，使代码更美观，更具可读性。 语法： 结果1 if 条件 else 结果2 如果条件成立，答案为结果1；反之，答案为结果2。 例如： age = 17 -----&gt; 单分支结构 if age &gt;= 18: print('已成年') else: print('未成年') print('已成年' if age &gt;= 18 else '未成年') -----&gt; 三目运算符 三、多分支结构 语法： if 条件1: 代码块1 elif 条件2: 代码块2 elif 条件3: 代码块3 …… else: 代码块N 四、嵌套分支结构 分支结构是可以相互嵌套的。按照语法，每一条分支下面都有一个代码块。可以在代码块这里写无数行代码。 例如：判断一个数字，是否是偶数，如果是偶数，再判断其是否是4的倍数。 num = input("请输入一个数字：") if num % 2 == 0: print(f'{num}是偶数') if num % 4 == 0: print(f'{num}还是4的倍数') else: print(f'{num}是奇数') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae0ab40bb5ca4c466e79602290325d9b/" rel="bookmark">
			Python基础—格式化输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		格式化输出 含义：将字符串进行格式化，方便我们的阅读、使用。 只要放到引号中，所有的符号仅仅是一个符号，没有特殊含义 age = 18 name = '张三' print('age岁的name熟读《孙子兵法》') print(age, '岁的', name, '熟读《孙子兵法》') 将字符串进行格式化有三种方法： 一、旧式字符串格式化方法 %s、%d、%f等被称为占位符，%s对应字符串、%d对应整型、%f对应浮点型 %f --&gt; 默认保留6位小数 %.Nf --&gt; N为整数 %f --&gt; 四舍五入 pi = 3.1415 print('圆周率为：%f' % pi) -----&gt; 圆周率为：3.141500 print('圆周率为：%.3f' % pi) -----&gt; 圆周率为：3.142 二、format方法 在字符串中写{}，字符串外调用format方法，在format方法中传入值，按照一一对应的关系被写入对应的{} 作用为说明：后面的内容就是说明性的内容 age = 40 name = '海南军阀漠叔' str2 = '{}岁的{}在海南横行霸道'.format(age, name) print(str2) 三、格式化字符串字面值（f-字符串） 针对format方法的优化，将format简写为f或者F，数据直接写入{} 作用为说明：后面的内容就是说明性的内容 age = 18 name = '李华' edu = '清华大学' str3 = f'{age}岁的{name}考上了{edu}' print(str3) 更高级的格式化 一、保留小数位：如果默认保留六位小数，只需要写：f，区别于%.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae0ab40bb5ca4c466e79602290325d9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ede5704338a7e8302ef4ef280f71990/" rel="bookmark">
			NodeJS 之 fs 模块（文件操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NodeJS 之 fs 模块（文件系统模块） 参考描述fs（File System）文件读取fs.readFile()判断文件是否读取成功编码 写入fs.writeFile()覆盖 追加fs.appendFile() 移动fs.rename() 同步与异步区别后缀参数举个栗子 执行同步异步 错误同步异步 总结 更细致的文件操作fs.open()可能使用到的文件操作举个栗子 读取fs.read()举个栗子 写入fs.write() 关闭区别fs.readFile()、fs.readFileSync()、fs.writeFile() 及 fs.writeFileSync()fs.read()、fs.readSycn()、fs.write() 及 fs.writeSync() 参考 项目描述NodeJSNodeJS API 官方文档Node.js 权威指南陆凌牛哔哩哔哩黑马程序员 描述 项目描述操作系统Windows 10 专业版NodeJS18.13.0 fs（File System） fs 模块是 NodeJS 内置的文件系统模块，为开发者提供了许多用于文件及目录操作的 API。
在 NodeJS 中，我们可以通过如下代码来将该模块进行导入。
const fs = require('fs'); 文件 读取 fs.readFile() fs.readFile(path[, options], callback) 其中：
path 与 callback 为必选参数，而 options 为可选参数。
参数描述path需要读取的目标文件的路径。options指定对被读取文件中的内容使用的编码方式。callback用以指定文件操作执行完成后需要执行的回调函数。 判断文件是否读取成功 传递给 fs.readFile() 的回调函数可以提供两个形参来分别接收 文件读取失败后得到的错误对象 及 文件读取成功后得到的文件内容。
文件读取成功时，第一个形参将接收到的值（实参）为 null，因此可以利用这个特性来判断文件是否读取成功：
const fs = require('fs'); // 尝试读取当前工作目录下的 content.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ede5704338a7e8302ef4ef280f71990/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f24bab22746bff9507b8dfb1ef5caeb/" rel="bookmark">
			MySQL如何获取每个分组内前n条数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 用sql实现逻辑：对一份数据tb，按照字段a, b分组，然后每个分组按照字段x, y升序排序，每个分组取前n条数据。
解决方案： select * from ( select dt.*, @_rn := if(@_prev_a = a and @_prev_b = b, @_rn + 1, 1) as _rn, @_prev_a := dt.a as _prev_a, @_prev_b := dt.b as _prev_b from tb dt join (select @_rn:=0, @_prev_a:=null, @_prev_b:=null) tmp order by dt.a, dt.b, dt.x, dt.y ) where rn &lt;= n 样例与结果展示
解释 首先用分组字段+排序字段进行排序（order by dt.a, dt.b, dt.x, dt.y）初始化所有临时变量（select @_rn:=0, @_prev_a:=null, @_prev_b:=null）利用临时变量@_prev_a和@_prev_b来记录上一行分组字段的值用@_rn在每一个分组中递增+1，当到达新分组的时候置为1（@_rn := if(@_prev_a = a and @_prev_b = b, @_rn + 1, 1)） 注：@variable在mysql里代表临时变量，@variable:= value用来对临时变量进行赋值，变量在运算中会逐行按照当前值进行操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f24bab22746bff9507b8dfb1ef5caeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06030991578e5b6b6882f8030fab174b/" rel="bookmark">
			内网渗透-实战|手把手教你如何进行内网渗透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实战|手把手教你如何进行内网渗透 x00 Preface 内网渗透主要是基于前期外围打点getshell的webserver，通过收集webserver上的信息，然后对其他内网主机进行口令上的攻击，当然也有一些基于漏洞的攻击。
内网相关概念这里不再进行介绍，大家可以自行百度，诸如什么是域、域与工作组的区别、什么是DC、什么是AD等。当然，概念是生涩难懂的，结合实际环境会有助于理解。某内网靶场的详细教程：Vulnstack（一）
内网渗透过程中经常会涉及到内网穿透，如何理解内网穿透以及端口转发、端口映射等相关知识可以参考：如何从零构建对内网穿透的理解
实操部分写的比较草率，主要是为了增强认知、扩展思路、扩充知识面。实际上有很多优秀的集成化工具，很少会拆分开来单独使用这些方法。当然，大多数情况下是要考虑免杀的，免杀时可能会将某一步操作拆分出来，单独进行免杀和利用。
0x01 信息收集 查看系统详细信息，如OS版本、补丁安装情况，可以根据这些信息筛选可利用的漏洞：
systeminfo
查看启动进程，可以根据启动进程判断主机在域中扮演的角色：
net start
查看进程列表：
tasklist
#查看端口开放情况：
netstat -ano
判断是否存在域：
net view /domain
查看主机名、域DNS、IP：
ipconfig /all
查看域内主机：
net view
域内主机以域服务器时间为准，故该命令可用于判断DC：
net time /domain
查看IP：
nslookup 域名
查看登录信息：
net config workstation
查看用户信息：
whoami /all
查看域内用户，可以将其作为字典，对其他主机的密码进行爆破：
net user /domain
这个命令在DC上可以直接执行，在其他域主机上执行要求打开DC的RPC服务。
探针域内存活主机：
for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.52.%I | findstr “TTL=”
当然也可以借助nmap、masscan等第三方工具或empire、nishang等第三方脚本，但是使用系统命令的最大好处就是不用考虑免杀。
域内其实还有一台机器STU1，但它开了防火墙，所以是禁ping的，这可能也是前面net view时没有显示STU1的原因。我们关了防火墙再试一遍：
计算机用户Hash、明文获取：
mimikatz：Win；mimipenguin：Linux。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06030991578e5b6b6882f8030fab174b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf78a268605e2f0a96ce92a3ca8d6bc/" rel="bookmark">
			安全运维 | Windows常用系统指令及服务总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：本人坚决反对利用文章内容进行恶意攻击行为，一切错误行为必将受到惩罚，绿色网络需要靠我们共同维护，推荐大家在了解技术原理的前提下，更好的维护个人信息安全、企业安全、国家安全。
1、常用系统指令 dir //查看当前目录和子目录 tree 以图形模式显示驱动器或路径的目录结构 mkdir 创建目录 md 创建文件夹 rd 删除文件夹 move 将文件从一个目录转移到另一个目录 type 显示文本文件内容 copy 复制文件 del 删除文件 quser 查看当前登陆的用户 rename /ren 重命名文件/文件夹 ipconfig /all 获取ip地址 所在域 linux：ifconfig -a route print 路由信息 arp -a arp缓存 netsh firewall show config 查看防火墙规则 netsh firewall show state netstat -an 获取端口信息 whoami 当前用户权限 hostname 主机名称 set 环境变量 query user 查看远程终端在线用户 systeminfo 获取操作系统版本、类型、位数等相关信息、安装； tasklist \svc netstat -an | findstr "LISTENING" · -b：显示包含于常见每个链接或监听端口的可执行组件； · -o：显示与每个连接相关的所属进程ID； · -v：与b一起使用时将显示包含于为所有可执行组件创建连接或者监听端口的组件； netstat -anb 进程号、端口开放情况、开放端口程序、监听端口组件 netsata -ano tcp/udp协议信息、端口、进程号 netstat -anvb 进程号、端口所用协议、调用的可执行组件、第三方进程的系统路径等 tasklist /svc 获取运行的进程名称、服务、PID driverquery 查看已安装驱动程序列表 net start 查看已经启动的windows服务 msinfo32 获取更加详细的信息 taskkill 是windows自带的终止进程程序 tASKKILL [/S system [/U username [/P [password]]]]{ [/FI filter] [/PID processid | /IM imagename] } [/T] [/F] 例如：taskkill /pid 452 /f taskkill /im 360tray /f 用户管理命令： net user hack 123 /add 添加hack用户 密码为123 whoami 查询账号所属权限 whoami /all 查看sid值密码策略 net account 查看本地密码策略 net account /domain 查看域 netstat -an 网络连接查询 route print 路由打印 net user 查询本机用户列表 net session 查看当前会话 net start 获取服务信息利用第三方漏洞提权、关闭杀毒软件、防火墙、以及关闭某些防护进程 net stop servicesname 停止服务命 net start servicename 开启服务命令 net share 查看SMB指向的 net view 查询同一域内机器列表 net view /domain 查询域列表 nltest /dclist:bk 查询域控主机名 nltest /dclist:域名 nltest /domain_trusts 列出域之间的信任关系 net view /domain:Secwing 查看Secwing域中的列表 net time /domain 判断主域，主域都做时间列表 net config workstation 当前登录域 net group "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cf78a268605e2f0a96ce92a3ca8d6bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2bd2747c1024ce99ec8ef4b2dc43c34/" rel="bookmark">
			[简洁版]Windows命令行配置IP地址及DNS等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注：以下配置需要使用管理员运行cmd命令行执行 配置IP # 查看接口名称： netsh interface ip show interface netsh interface ip show config # 配置接口地址： netsh interface ipv4 set address name="以太网" static 192.168.10.10 255.255.255.0 192.168.1.1 # 配置dhcp自动获取ip netsh interface ipv4 set address name="以太网" source=dhcp 配置DNS # 配置DNS服务器 netsh interface ipv4 set dnsserver name="以太网" static 223.5.5.5 index=1 netsh interface ipv4 set dnsserver name="以太网" static 223.6.6.6 index=2 # 自动获取 netsh interface ipv4 set dnsserver name="以太网" source=dhcp 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c6e1246101b88f3690eae49f67f58d9/" rel="bookmark">
			libcurl简介及其编程应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为学习笔记，整合课程内容以及下列文章：
其中，libcurl函数库常用字段解读部分：
参考博文：原文地址
作者：冬冬他哥哥
目录
libcurl简介
libcurl的使用
学会开源包使用的一般步骤
包的解读
重点是看INSTALL文件
库的 配置 &gt; 编译 &gt; 安装
编程实例：访问百度主页
代码
编译注意：
libcurl函数库常用字段解读
一、调用curl_global_init()：初始化libcurl
二、调用curl_easy_init()：得到 easy interface型指针,拿到句柄
三、调用curl_easy_setopt(CURL *handle, CURLoption option, parameter)：设置传输选项
四、调用curl_easy_perform()：完成传输任务
五、调用curl_easy_cleanup()：释放内存
libcurl简介 在linux下用c语言做HTTP的编程有一种方法是依赖于这个libcurlv库，以后做跨平台网络协议相关的开发，第一个要想到的就是它。
libcurl是一个跨平台的网络协议库，支持http, https, ftp等协议，libcurl同样支持：
（1）HTTPS证书授权
（2）HTTP POST, HTTP PUT, FTP 上传
（3） HTTP基本表单上传，代理，cookies,和用户认证
库下载地址：库下载
然后发送到linux开发环境中。
libcurl的使用 学会开源包使用的一般步骤 我们是希望通过学会使用libcurl库来掌握一系列类似的库的使用方法，所谓触类旁通。
windows下载完库后拖拽到ubuntu，创建一个空文件，把库拉进来。
包的解读 解压下载的库
tar xvf curl-7.71.1.tar.bz2 进入文件夹
cd curl-7.71.1 对于这种开源的包，一定要学会它的使用：
先看README：
vi README 难受，看不懂
没关系，去看这个
docs文件夹很重要，一般是对README的补充
cd docs 不需要看太多，看类似于这个：提到的相关的API手册
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c6e1246101b88f3690eae49f67f58d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f77f0970fe286f5ec42c0bb32808dec/" rel="bookmark">
			【VSC插件】解决 VSC 中 Tailwind CSS IntelliSense v0.9.6 语法无法识别的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 解决 VSC 中 Tailwind CSS IntelliSense v0.9.6 插件语法无法识别的问题
解决 按照说明进行配置
在插件设置中进行设置
在如上扩展设置中，把 Tailwind CSS: Emmet Completions
选项勾选
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b93e9c61d0c86b9d176bfcadaef62aca/" rel="bookmark">
			mac docker 宿主机和容器间 ping不通的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 docker-connector 首先 Mac 端通过 brew 安装 docker-connector
brew install wenjunxiao/brew/docker-connector 然后执行以下命令把 docker 的所有 bridge 网络都添加到路由中
docker network ls --filter driver=bridge --format "{{.ID}}" | xargs docker network inspect --format "route {{range .IPAM.Config}}{{.Subnet}}{{end}}" &gt;&gt; /usr/local/etc/docker-connector.conf
也可以手动修改 /usr/local/etc/docker-connector.conf 文件中的路由，格式是
route 172.17.0.0/16 路由的子网决定了你能访问那些容器
配置完成，直接启动服务（需要 sudo，路由配置启动之后仍然可以修改，并且无需重启服务立即生效）
sudo brew services start docker-connector 然后使用以下命令在 docker 端运行 wenjunxiao/mac-docker-connector，需要使用 host 网络，并且允许 NET_ADMIN
docker run -it -d --restart always --net host --cap-add NET_ADMIN --name connector wenjunxiao/mac-docker-connector 如果需要将对应的网络共享给其他人访问，需要修改配置文件 /usr/local/etc/docker-connector.conf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b93e9c61d0c86b9d176bfcadaef62aca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/717c5a4f396ec85da0f124d5abc7b916/" rel="bookmark">
			【机器学习 - 3】：数据归一化（最值归一化、均值方差归一化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据归一化的使用最值归一化均值方差归一化（常用）在sklearn中调用归一化（鸢尾花数据归一化） 数据归一化的使用 为什么要使用数据归一化？
举个例子，例如我们要使用KNN算法来预测肿瘤为良性肿瘤或恶性肿瘤。以下是一些数据：
肿瘤大小（厘米）发现时间（天）肿瘤类型样本11200良性肿瘤样本25100恶性肿瘤样本32150良性肿瘤 根据以上数据，画出散点图
import numpy as np import matplotlib.pyplot as plt # 训练集数据 X_train = np.array([ [1, 200], [5, 100], [2, 150] ]) y_train = np.array([1,0,1]) # 1为良性，0为恶性 # 绘制散点图 plt.figure(dpi=100) plt.rcParams['font.sans-serif'] = ['SimHei'] # 设置中文 plt.scatter(X_train[y_train==1, 0], X_train[y_train==1,1], color='b') # 蓝色为良性 plt.scatter(X_train[y_train==0, 0], X_train[y_train==0,1], color='r') plt.xlabel("肿瘤大小（厘米）") plt.ylabel("发现时间（天）") plt.legend(loc="best") plt.show() 观察上图，并未发现任何问题。当我们计算样本1和样本2的距离时，公式为：
我们可发现纵坐标的数据远远大于横坐标的数据。这样在我们进行计算时，由于发现时间的影响远大于肿瘤大小的影响，所以预测相当于只采用了一个特征。
因此我们需要进行数据归一化
最值归一化 最值归一化：把所有数据映射到0-1之间。公式如下：
以上述例子为例：对发现时间的特征进行最值归一化。
import numpy as np X = np.array([ [1, 200], [5, 100], [2, 150] ]) X = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/717c5a4f396ec85da0f124d5abc7b916/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb34aa1946ed80fa171901a2f27e0616/" rel="bookmark">
			【web安全】SQL注入漏洞3--sqlmap工具教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 我们在前面的文章已经介绍了SQL注入的挖掘方法以及渗透利用方法，这篇文章，我们学习一下如何利用工具高效的进行sqlmap 的渗透利用。 我们知道，手工制作payload并渗透利用是最基本的能力，但是这种方式的进展缓慢，不利于在实战中快速高效的扩大战果， 那么，有没有快速利用的工具呢？ 答案是有的，前辈们早就开发了许多自动化利用的工具， 今天我们学习一个非常好用的SQL注入工具，sqlmap.
这篇文章主要关注如下内容：
只讲工具的利用思路，不会详细罗列工具的每个命令参数。以靶场为例来展开对sqlmap的使用介绍。 sqlmap教程 sqlmap的安装 sqlmap的安装还是比较简单的，网上一搜就可以搜到。 在linux操作系统和window操作系统都是可以安装的。
笔者在安装后遇到一个小问题，我是在本地搭建的一个sqli lab靶场，需要通过127.0.0.1本地访问才可以。 但是由于系统的代理问题，在cmd中无法直接访问靶场web页面，这里找到一个临时解决方案，就是代理地址删除掉即可
笔者使用的windows环境下的解决方案:
cmd中执行下面命令 set http_proxy= set https_proxy= sqlmap的使用 有了自动化工具，就方便了许多， 我们不需要再一个一个手工的构造payload 然后尝试在参数中添加符号进行测试；我们只需要在工具中输入一个url,sqlmap就可以自动识别url中的参数并构造payload探测。
例如， 我们在靶场中的url 为：
http://127.0.0.1/Less-1/?id=1 我们可以执行如下命令进行探测：
sqlmap.py -u http://127.0.0.1/Less-1/?id=1 如果有漏洞，则sqlmap会显示存在漏洞的具体参数。若有多个参数，可以按回车键依次进行sql注入漏洞的测试。 获取当前用户下的所有数据库： sqlmap.py -u http://127.0.0.1/Less-1/?id=1 --dbs 结果如下: available databases [7]: [*] challenges [*] dvwa [*] information_schema [*] mysql [*] performance_schema [*] security [*] sys 探测数据库中有几个表 python sqlmap.py -u http://127.0.0.1:81/Less-1?id=1 -D security --tables +----------+ | emails | | referers | | uagents | | users | +----------+ 探测表中有哪些字段 python sqlmap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb34aa1946ed80fa171901a2f27e0616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/581416ddf844251699c480bf122581ac/" rel="bookmark">
			第11章 EVENT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP32 EVENT ESP32系统默认的sys_evt任务产生事件。通常的做法是，把事件转移到app_task任务中处理。
这样做的好处：
可以防止长时间阻塞系统任务避免在系统任务中调用复杂的函数，可能导致系统任务爆栈 测试代码 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include "freertos/FreeRTOS.h" #include "freertos/task.h" #include "freertos/event_groups.h" #include "esp_log.h" #include "nvs.h" #include "nvs_flash.h" #include "esp_wifi.h" #include "esp_event.h" #define MAX_SCAN_NUM 30 #define STA_START BIT0 #define SCAN_DOWN BIT1 static EventGroupHandle_t wifi_event_group_hd = NULL; void wifi_scan_start(void) { wifi_country_t ccode_config = { .cc = "CN", .schan = 1, .nchan = 13, .policy = WIFI_COUNTRY_POLICY_AUTO, }; printf("WiFi scan start...\n"); esp_wifi_set_country(&amp;ccode_config); // false: WIFI扫描过程不要阻塞，扫描完成后以事件通知 esp_wifi_scan_start(NULL, false); } void wifi_scan_result(void) { uint16_t ap_count = 0; esp_wifi_scan_get_ap_num(&amp;ap_count); uint16_t number = MAX_SCAN_NUM; wifi_ap_record_t ap_records[MAX_SCAN_NUM]; memset(ap_records, 0x00, sizeof(ap_records)); esp_wifi_scan_get_ap_records(&amp;number, ap_records); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/581416ddf844251699c480bf122581ac/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/80/">«</a>
	<span class="pagination__item pagination__item--current">81/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/82/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>