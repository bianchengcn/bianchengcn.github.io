<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3c7b60b36679b201f133281d653ee1c/" rel="bookmark">
			mysql中tinyint(1)与tinyint(2)的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tinyint 型的字段如果设置为UNSIGNED类型，只能存储从0到255的整数,不能用来储存负数。
tinyint 型的字段如果不设置UNSIGNED类型,存储-128到127的整数。 1个tinyint型数据只占用一个字节;一个INT型数据占用四个字节。
这看起来似乎差别不大，但是在比较大的表中，字节数的增长是很快的。
tinyint(1)与tinyint(2)的区别可以从下面看出来
CREATE TABLE `test` ( `id` int(11) NOT NULL AUTO_INCREMENT, `str` varchar(255) NOT NULL, `state` tinyint(1) unsigned zerofill DEFAULT NULL, `state2` tinyint(2) unsigned zerofill DEFAULT NULL, `state3` tinyint(3) unsigned zerofill DEFAULT NULL, `state4` tinyint(4) unsigned zerofill DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=MyISAM AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 insert into test (str,state,state2,state3,state4) values('csdn',4,4,4,4);
select * from test;
结果：
id str state state2 state3 state4 1 csdn 4 04 004 0004 于是在dll里面channel` tinyint(2) unsigned zerofill DEFAULT ‘00’
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3c7b60b36679b201f133281d653ee1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70cd31a9da0a6a4c1fe7c93e13e7813f/" rel="bookmark">
			中间件漏洞及修复汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx文件解析漏洞 漏洞等级 高危
漏洞描述 nginx文件解析漏洞产生的原因是网站中间件版本过低，可将任意文件当作php可执行文件来执行，可导致攻击者执行恶意代码来控制服务器。
漏洞危害 机密数据被窃取；
核心业务数据被篡改；
网页被篡改；
数据库所在服务器被攻击变为傀儡主机，导致局域网(内网)被入侵。
修复方案 升级中间件版本
部署Web应用防火墙
对数据库操作进行监控
修改php.ini文件，将cgi.fix_pathinfo的值设置为0；
在Nginx配置文件中添加以下代码：
if( $fastcgi_script_name ~ ..*/.*php ) {return 403;} 这行代码的意思是当匹配到类似test.jpg/a.php的URL时，将返回403错误代码。
OPTIONS漏洞 漏洞描述 启用了不安全的http方法，Web服务器或应用程序服务器中间件是以不安全的方式配置 ，这些方法可能标识在服务器上启用了WebDAV，可能允许未授权的用户进行利用。此漏洞存在于IIS容器下，它扩展了HTTP协议，在GET/POST/HEAD等几个HTTP标准方法以外添加了一些新的方法，比如PUT/MOVE/COPY/DELETE方法，那么攻击者就可以通过PUT方法向服务器上传危险脚本。
漏洞测试 请求一个OPTIONS包，查看服务器所支持的HTTP方法。
OPTIONS / HTTP/1.1
Host:thief.one
漏洞危害 可能会在WEB服务器上上传、修改或删除WEB页面、脚本和文件，从而达到网页篡改，控制服务器的目的。
漏洞修复方案 如果服务器不需要支持WebDAV，请务必禁用此功能，或者禁止其不安全的HTTP请求方法。
Struts2远程命令执行 Struts2远程命令执行漏洞是指代码未对用户可控参数做过滤，导致直接带入执行命令的代码中，可被用来执行任意命令。
可带来如下危害：
攻击者可利用此漏洞直接执行操作系统命令获取WebShell，并且可通过该系统影响内网安全；
可被攻击者用来执行任意命令，写入后门等，进而完全控制服务器，造成严重后果。
修复建议：
将struts版本升级至最新版；
部署Web应用防火墙。
Tomcat远程部署漏洞 漏洞描述 这是JSP/PHP网站远程部署的一个工具，管理员只需要远程上传一个WAR格式的文件，便可以发布到网站，方便了开发人员部署代码的同时，也为黑客上传木马敞开了大门。
漏洞验证 通过访问：Http://localhost:8080/manager管理地址，尝试弱口令或默认口令，若能登陆成功，则存在此漏洞。
漏洞危害 导致被上传木马文件，控制服务器
漏洞修复 1.删除此管理页面
2.防火墙设置外网禁止访问此页面，或设置上传文件类型
3.中间件设置此页面访问权限
4.修改默认账号密码
5.升级tomcat为最新版本
JBoss远程部署漏洞 漏洞描述 JBoss这是一个基于JavaEE的应用服务器，与tomcat类似的是jboss也有远程部署平台，但不需要登陆。
漏洞验证 尝试访问http://localhost:8080 因为一般管理后台为8080端口
漏洞危害 上传恶意木马文件，控制服务器
漏洞修复 1.开启jmx-console密码认证
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70cd31a9da0a6a4c1fe7c93e13e7813f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4077469c08a9073f65354565880f453f/" rel="bookmark">
			分片技术（Sharding）：化整为零，分而治之
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前的区块练技术面临着一个巨大的瓶颈，那就是：如何有效地提升区块的吞吐量（TPS）。
区块链的扩展性一直是大多数公链发展过程中难以避开的一块拦路石，比特币因之有一段长达三年的扩容之争，以太坊一度因为一个小小的密码猫游戏而长时间拥堵不堪。
目前提出的问题解决思路主要有以下几种：治标不治本的扩容（扩大区块容量）、牺牲部分去中心化的DPoS和pBFT共识机制、不同于区块链的DAG、链下扩容（子链和侧链），以及分片。
分片（Sharding）技术，被认为是一种有效的、能够解决区块链吞吐量问题的解决方案。
起源 分片原本是一种数据库分区技术，能够将一个大型的数据库分割成小的数据碎片，并将这些碎片储存在不同的服务器上，使其能够更快更有效地管理数据。
而区块链中的分片技术，是在2015年初次提出的。当时新加坡国立大学的一对师生，在国际顶尖安全会议CCS上发表了一篇论文《A Secure Sharding Protocol For Open Blockchains》，首次提出了区块链领域中的分片概念。
后来，这对师生发展出了第一个分片技术的落地项目Zilliqa，它结合pBFT和PoW共识机制，有6个分片，3600个节点的测试网络，已经能够达到每秒处理2800次交易的速度，是目前公链中处理速度最快的。
珠玉在前，很多为扩展性烦恼不已的项目开始考虑将分片技术应用在自家的区块链上，比如以太坊，V神已经打算在以太坊的区块链上应用分片技术来扩大吞吐量了。此外，还有很多以此为核心技术的新项目正在出现，当然其中也不乏打着分片旗号挂羊头卖狗肉的项目。
不过，分片技术并不是那么容易掌握的。
分类和原理 分片技术，有这么几大类：网络分片、交易分片、状态分片。它们的基本原理，都是“化整为零，分而治之”，用多个分片同时处理不同的交易，最后汇总到主链上。
首先，网络分片。网络分片较为简单，但也最为重要，因为其他分片机制都必须建立在网络分片之上。网络分片首先要保证安全，预防网络攻击和恶意节点的干扰，随机抽取出特定数量的节点，创建成一个分片。当形成多个分片后，分片中自行建立共识，对交易进行确认。这些分片可以同时、平行地处理相互未建立连接的交易，提高网络并发量。
Zilliqa便是运用网络分片，然后配合网络分片的共识机制，即pBFT共识机制和PoW共识机制，来提升交易速度的。在其中，共识机制之所以重要，在于确认一笔交易，使用pBFT共识机制，可以提高确认速度；而在建立分片之前，要先对网络攻击进行防范，Zilliqa加入PoW机制，就可以有效地阻止女巫攻击（Sybil Attacks）和恶意节点的进入。
其次是交易分片。网络上创建好的分片处理不同的交易，划分为不同的交易分片，交易划分的依据可以是交易发起者的地址。
假设有人用一个地址向两个人发起相同的交易，即所谓的“双花”，一般情况下，这两笔交易将被划分到同一个分片进行处理，之后分片能够迅速识别出相同的发起地址，从而阻止双重花费。
而如果这两笔交易被分到了不同的分片，分片中的节点同样能够检测出来，将这笔交易拒绝。不过，要防止双花，在验证中就需要分片之间相互通信，这样就会出现跨片交易的情况，影响整个网络的运行和效益。所以，这里的分片最好采用UTXO交易模型，更加容易监测出双花，以保证效率。
但UTXO会对大宗交易额进行拆分，一定程度上会影响效率。不过，目前的交易分片技术已经较为成熟，能够允许多种共识机制运行。
最后是状态分片，这是最为复杂、最具有挑战性的一种分片机制。状态分片的核心在于，不同的分片能够储存不同的数据，也就是说，整个储存库被分开，分别放在了不同的分片上。每个分片储存自己分片中的所有数据，而不是整个区块链的状态。
这一分片机制的挑战在于：
首先，由于每个分片储存的状态不同，如果一笔交易的发起人和接收者处在两个不同的分片，那么这两个分片对于这笔交易的信息就应该进行共享，这样一来，跨片交易的现象又出现了，两个分片之间又得进行频繁的通信和状态互换，将会大大影响分片的效益和性能。
然后，当分片遭到攻击不得不进行脱机工作，其中的交易是无法被验证的。要解决这个问题，就必须在每个节点进行信息的存档和备份，以帮助系统修复数据，但这样的话，节点就必须要备份整个存储系统的状态，失去状态分片的意义，甚至还可能具有中心化的风险。
优势与阻碍 分片技术作为能解决区块链拓展性问题的新技术之一，具有非常强的技术优势和广阔的发展前景。通过分片处理交易和数据的方式来消除区块的拥堵，扩大吞吐量，结合其他技术加强安全性和效率，进行互补，是目前分片技术的主要运用趋势。
分片中安全性和性能的平衡是一个值得重视的问题，Zilliqa经过多次实验，决定用600个节点构建一个分片，这是因为600个节点能够到达性能和安全的最佳平衡。而如果为了提高TPS一味减少节点，对于分片的去中心化和安全性都是很不利的。
分片技术依然存在着很多难题需要解决，尤其是状态分片，计算机技术人员尚未研究出好的解决方案。同时，分片的原理不仅仅在于如何分片，更在于如何对每个分片进行安全有效的治理，很多项目一味追求其中的一个方面，忽视了区块链的基本治理问题，这也是需要注意的。
文章来源：BB财经
原文链接：http://www.bbcaijing.cn/article/news/20736.html
关注区块链技术，区块链资讯，数字货币行情
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19776b47fb631d6086fdf3a22b85ba88/" rel="bookmark">
			页面占位图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、为什么需要使用占位图？
1.1让用户感知此处正在加载一张图片，优化体验。
1.2实现文档更快的加载，js相应的更快。
1.3预占位，当图片加载完成后不改变文档结构布局（需要预占位图片与真实图片大小一致）。
2、
依据onload事件判断图片是否加载完成，然后显隐占位图。
&lt;div v-for="(activeItem, activeIndex) in activityList" :key="activeIndex" class="activity-wrap"&gt; &lt;div class="img-wrap"&gt; &lt;img :src="imgUrl + activeItem.Banner + '_0x0'" :alt="activeItem.ActivityName" @load="activityLoad (activeItem.Banner, activeIndex)" v-show="loadingImges[activeIndex]" &gt; &lt;img :src="loadingImgSrc" v-show="!loadingImges[activeIndex]" &gt; &lt;/div&gt; &lt;/div&gt; const loadingimg = require('../assets/images/category/activity-placeholder.png') data () { return { loadingImges: {}, loadingImgSrc: loadingimg, } } methods: { activityLoad (imgId, imgIndex) { if (imgId) { this.loadingImges[imgIndex] = true; } }, } 3、判断图片加载完成的方法
https://blog.csdn.net/zhuchunyan_aijia/article/details/52016962
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/070edf091495499152f15930e280a9ba/" rel="bookmark">
			[GAN学习系列] 初识GAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文大约 3800 字，阅读大约需要 8 分钟
要说最近几年在深度学习领域最火的莫过于生成对抗网络，即 Generative Adversarial Networks(GANs)了。它是 Ian Goodfellow 在 2014 年发表的，也是这四年来出现的各种 GAN 的变种的开山鼻祖了，下图表示这四年来有关 GAN 的论文的每个月发表数量，可以看出在 2014 年提出后到 2016 年相关的论文是比较少的，但是从 2016 年，或者是 2017 年到今年这两年的时间，相关的论文是真的呈现井喷式增长。
那么，GAN 究竟是什么呢，它为何会成为这几年这么火的一个研究领域呢？
GAN，即生成对抗网络，是一个生成模型，也是半监督和无监督学习模型，它可以在不需要大量标注数据的情况下学习深度表征。最大的特点就是提出了一种让两个深度网络对抗训练的方法。
目前机器学习按照数据集是否有标签可以分为三种，监督学习、半监督学习和无监督学习，发展最成熟，效果最好的目前还是监督学习的方法，但是在数据集数量要求更多更大的情况下，获取标签的成本也更加昂贵了，因此越来越多的研究人员都希望能够在无监督学习方面有更好的发展，而 GAN 的出现，一来它是不太需要很多标注数据，甚至可以不需要标签，二来它可以做到很多事情，目前对它的应用包括图像合成、图像编辑、风格迁移、图像超分辨率以及图像转换等。
比如字体的转换，在 zi2zi 这个项目中，给出了对中文文字的字体的变换，效果如下图所示，GAN 可以学习到不同字体，然后将其进行变换。
除了字体的学习，还有对图片的转换， pix2pix 就可以做到，其结果如下图所示，分割图变成真实照片，从黑白图变成彩色图，从线条画变成富含纹理、阴影和光泽的图等等，这些都是这个 pix2pixGAN 实现的结果。
CycleGAN 则可以做到风格迁移，其实现结果如下图所示，真实照片变成印象画，普通的马和斑马的互换，季节的变换等。
上述是 GAN 的一些应用例子，接下来会简单介绍 GAN 的原理以及其优缺点，当然也还有为啥等它提出两年后才开始有越来越多的 GAN 相关的论文发表。
1. 基本原理 GAN 的思想其实非常简单，就是生成器网络和判别器网络的彼此博弈。
GAN 主要就是两个网络组成，生成器网络(Generator)和判别器网络(Discriminator)，通过这两个网络的互相博弈，让生成器网络最终能够学习到输入数据的分布，这也就是 GAN 想达到的目的–学习输入数据的分布。其基本结构如下图所示，从下图可以更好理解G 和 D 的功能，分别为：
D 是判别器，负责对输入的真实数据和由 G 生成的假数据进行判断，其输出是 0 和 1，即它本质上是一个二值分类器，目标就是对输入为真实数据输出是 1，对假数据的输入，输出是 0；G 是生成器，它接收的是一个随机噪声，并生成图像。 在训练的过程中，G 的目标是尽可能生成足够真实的数据去迷惑 D，而 D 就是要将 G 生成的图片都辨别出来，这样两者就是互相博弈，最终是要达到一个平衡，也就是纳什均衡。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/070edf091495499152f15930e280a9ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d2144cb24ea1b02969b4bdf8fddd1ed/" rel="bookmark">
			CentOS7.2 安装mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.准备文件
官网下载mysql-5.7.23-1.el7.x86_64.rpm-bundle.tar， 安装的是5.7版本
2. 如果是第一次安装mysql需要卸载系统自带的mysql
yum remove mysql-libs
3. 解压和安装
tar -xvf mysql-5.7.23-1.el7.x86_64.rpm-bundle.tar
rpm -ivh mysql-community-common-5.7.23-1.el7.x86_64.rpm
rpm -ivh mysql-community-libs-5.7.23-1.el7.x86_64.rpm
rpm -ivh mysql-community-client-5.7.23-1.el7.x86_64.rpm
rpm -ivh mysql-community-server-5.7.23-1.el7.x86_64.rpm
注意这些是有安装顺序的
4.配置mysql
在vi /etc/my.cnf里 加入 skip-grant-tables
vim /etc/my.cnf
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock
# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0
log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid
skip-grant-tables
在配置文件中加入skip-grant-tables，就可以无密码登陆mysql
修改后保存，重启mysql服务
service mysqld restart
5. 修改密码
登陆之后，可以先使用 show databases 看下mysql是否安装正确
先修改密码：
update user set authentication_string=password('123456') where user="root";
退出，将之前的skip-grant-tables删掉 或 注释掉，再登陆:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d2144cb24ea1b02969b4bdf8fddd1ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8a625a76132a94368119e9d87fe0d9/" rel="bookmark">
			unity  实现轮盘方式的按钮滚动效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期在项目中，策划给出了一个需求就是，让按钮按照一个轮盘的轨迹进行滑动的效果，经过一番测试，实现了初步的效果。
我这里区分了横向滑动和纵向滑动，这里以纵向滑动为例子进行示范，实现按钮的滑动效果。
首先就是先进行位置初始化:
/// &lt;summary&gt; ///从大到小排序,Y轴 /// &lt;/summary&gt; private Comparison&lt;CircleScrollRectItemBase&gt; ComparisionY = delegate (CircleScrollRectItemBase itemA, CircleScrollRectItemBase itemB) { if (itemA.transform.localPosition.y == itemB.transform.localPosition.y) return 0; return (itemA.transform.localPosition.y &gt; itemB.transform.localPosition.y) ? -1 : 1; }; public void Init() { if (null == listItems || listItems.Length == 0) { return; } if (itemPostions != null &amp;&amp; itemPostions.Length &gt; 0) { for (int i = 0; i &lt; itemPostions.Length; i++) { listItems[i].transform.localPosition = itemPostions[i]; } } //XY轴排序按不同方式排序，可以统一使用共同的函数 if (horizontal) { //位置从小到大排序 Array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc8a625a76132a94368119e9d87fe0d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34e4d386187314e848525d2d945ea022/" rel="bookmark">
			LeetCode--下一个更大的元素（四种解法,最详细的解法！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。
nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。
示例 1:
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。
示例 2:
输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
对于num1中的数字2，第二个数组中的下一个较大数字是3。
对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。
注意:
nums1和nums2中所有元素是唯一的。
nums1和nums2 的数组大小都不超过1000。
思路描述：
思路一：利用栈去将nums1中满足小于相邻右边元素的元素存储在hash表中，key是该元素的值、value是该元素右边的相邻元素。从而利用哈希查找来实现输出。
思路二：不使用栈，直接利用哈希表，key是nums1中的值，value则是nums1中值对应的地址ID。
实现代码一：
class Solution { public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) { stack&lt;int&gt; s; unordered_map&lt;int, int&gt; m; for (int n : nums) { while (s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34e4d386187314e848525d2d945ea022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b192360def9c8711c426bb8661251e95/" rel="bookmark">
			netty4  服务端同步客户端返回的结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		netty是一个异步通信框架，在有的时候我们想使用服务端向客户端发送消息，服务端同步等待客户端返回结果然进行下一步的业务逻辑操作。那要怎么做才能同步获取客户端返回的数据呢？这里我用到了JDK中的闭锁等待 CountDownLatch，接下来看看代码如何实现：
服务端：
package com.example.demo.server; import com.example.demo.cache.ChannelMap; import com.example.demo.model.Result; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.Channel; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioServerSocketChannel; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.Lock; import lombok.extern.slf4j.Slf4j; /** * @ClassName: NettyServer * @Author: huangzf * @Date: 2018/9/25 15:40 * @Description: */ @Slf4j public class NettyServer { private NettyServerChannelInitializer serverChannelInitializer = null; private int port = 8000; public void bind() throws Exception { //配置服务端的NIO线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { serverChannelInitializer = new NettyServerChannelInitializer(); ServerBootstrap b = new ServerBootstrap(); b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b192360def9c8711c426bb8661251e95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b028f354f3015697f663a974b0e389e4/" rel="bookmark">
			运算符重载的正确用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt; using namespace std; class Complex { public: int a; int b; friend ostream&amp; operator&lt;&lt;(ostream &amp;out, Complex c3); public: Complex(int a=0,int b=0) { this-&gt;a = a; this-&gt;b = b; } void printfM() { cout &lt;&lt; "a:"&lt;&lt;this-&gt;a&lt;&lt;" b:"&lt;&lt;this-&gt;b&lt;&lt; endl; } Complex operator+ (Complex c) { Complex tmp(a + c.a, b + c.b); return tmp; } }; ostream&amp; operator&lt;&lt;(ostream &amp;out, Complex c3) { out &lt;&lt; "a="&lt;&lt;c3.a&lt;&lt;" b=" &lt;&lt; c3.b; return out; } //运算符重载的正确写法：&lt;&lt; &gt;&gt;使用友元函数 其他运算重载函数写在类的内部 void main() { Complex c1(1, 2); Complex c2(2, 3); Complex c3 = c1 + c2; //c3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b028f354f3015697f663a974b0e389e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c3f286d68b623f61ec86876ad5e890/" rel="bookmark">
			python: 用pygments给markdown文档染色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先你需要一个markdown解析器
比如有常见的markdown和markdown2，其他的可以参考这个网站的评价
我选择了mistune，自己继承写一个渲染的Renderer
mistune的doc也有提及基本写法
#!/usr/bin/env python # -*- coding: utf-8 -*- import mistune import sys from pygments import highlight from pygments.lexers import get_lexer_by_name from pygments.formatters import html class HighlightRenderer(mistune.Renderer): def block_code(self, code, lang): if not lang: return '\n&lt;pre&gt;&lt;code&gt;%s&lt;/code&gt;&lt;/pre&gt;\n' % \ mistune.escape(code) lexer = get_lexer_by_name(lang, stripall=True) formatter = html.HtmlFormatter() return highlight(code, lexer, formatter) def main(argv): name = argv[0] md_name = '%s.md' % (name) outfile = '%s.html' % (name) with open(md_name) as mdfile: md_text = mdfile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60c3f286d68b623f61ec86876ad5e890/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/455e4083da6846e27f385e4a30980431/" rel="bookmark">
			hml5&#43; Android创建快捷方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" /&gt; &lt;meta name="HandheldFriendly" content="true" /&gt; &lt;meta name="MobileOptimized" content="320" /&gt; &lt;title&gt;Hello H5+&lt;/title&gt; &lt;script type="text/javascript"&gt; /* * 首先是供参考对比的Android源代码，用Android的java代码创建手机桌面快捷方式 * import android.content.Intent; import android.graphics.BitmapFactory; import android.graphics.Bitmap; import android.app.Activity; // 获取主Activity Activity main = this; // 创建快捷方式意图 Intent shortcut = new Intent("com.android.launcher.action.INSTALL_SHORTCUT"); // 设置快捷方式的名称 shortcut.putExtra(Intent.EXTRA_SHORTCUT_NAME, "HelloH5+"); // 设置不可重复创建 shortcut.putExtra("duplicate",false); // 设置快捷方式图标 Bitmap bitmap = BitmapFactory.decodeFile("/sdcard/icon.png"); shortcut.putExtra(Intent.EXTRA_SHORTCUT_ICON, bitmap); // 设置快捷方式启动执行动作 Intent action = new Intent(Intent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/455e4083da6846e27f385e4a30980431/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f36c58c2c098e6c31d32cafaf5580afa/" rel="bookmark">
			html5&#43; downloader-下载管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		downloader-下载管理 Downloader模块管理网络文件下载任务，用于从服务器下载各种文件，并支持跨域访问操作。通过plus.downloader获取下载管理对象。Downloader下载使用HTTP的GET/POST方式请求下载文件，符合标准HTTP/HTTPS传输协议。
方法： createDownload: 新建下载任务enumerate: 枚举下载任务clear: 清除下载任务startAll: 开始所有下载任务 对象： Download: Download对象管理一个下载任务DownloadEvent: 下载任务事件类型DownloadState: 下载任务状态DownloadOptions: 下载任务参数 回调方法： DownloadCompletedCallback: 下载任务完成时的回调DownloadStateChangedCallback: 下载任务状态变化回调DownloadEnumerateCallback: 枚举下载任务回调 权限： 5+功能模块（permissions）
{ // ... "permissions":{ // ... "Downloader": { "description": "文件下载，管理文件下载任务" } } } Download Download对象管理一个下载任务
interface Download { readonly attribute String id; readonly attribute String url; readonly attribute Number state; readonly attribute DownloadOptions options; readonly attribute String filename; readonly attribute Number downloadedSize; readonly attribute Number totalSize; function void abort(); function void addEventListener( String event, function Callback listener, Boolean capture ); function String getAllResponseHeaders(); function String getResponseHeader( headerName ); function void pause(); function void resume(); function void setRequestHeader( String headerName, String headerValue ); function void start(); } 属性： id: 下载任务的标识url: 下载文件的地址state: 任务的状态options: 下载任务的参数filename: 下载的文件名称downloadedSize: 已完成下载文件的大小totalSize: 下载任务文件的总大小 方法： abort: 取消下载任务addEventListener: 添加下载任务事件监听器getAllResponseHeaders: 获取下载请求HTTP响应头部信息getResponseHeader: 获取下载请求指定的HTTP响应头部的值pause: 暂停下载任务resume: 恢复暂停的下载任务setRequestHeader: 设置下载请求的HTTP头数据start: 开始下载任务 DownloadEvent 下载任务事件类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f36c58c2c098e6c31d32cafaf5580afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de4c67ca09d3840b51247e88ad1c266/" rel="bookmark">
			移动互联网浩荡十年 有的升腾，有的陨落
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创： 颜西龙 猎云网 （ilieyun）1周前
中国移动互联网的十年，是波澜壮阔、荡气回肠的十年。本文回溯了这段历史，在这十年间里，有的企业升腾，有的企业陨落。
2011年8月16日，北京798艺术中心。
台上，雷军每公布一项技术参数，台下就传来一阵几乎要掀翻屋顶的声浪。
一位记者问：“这都是哪请来的托，太敬业了！”工作人员只得实话实说：“都是自己来的，我们也没想到。”
这一幕，像极了4年前乔布斯在旧金山。
“手机键盘、触控笔？谁要这些玩意儿呢？”在莫斯康尼会议中心举行的第一代iPhone发布会上，乔布斯向全世界宣布：苹果要重新发明手机！
这引来了台下的阵阵欢呼，但当时的大多数人应该都想不到，当天这款产品的发布，竟然很快就打败了整个行业。 （2007年第一代iPhone发布会）
1 iPhone的发布，并没有引起传统手机巨头特别的重视，却给了雷军极大的震撼。
因为与传统“能上网的手机”相比，iPhone是“能打电话的智能终端”，这是质的区别。
而紧接着Android的发布，则给了雷军更大的震撼。这让雷军开始思索，互联网之后的下一个热点会在哪里？
但此时的雷军，正带领着金山做上市前的最后冲刺。从22到38岁，从6号员工到CEO，雷军为金山工作了16年。
其实不仅仅是雷军，在中国的南方城市珠海，魅族创始人黄章也注意到了这款与众不同的手机。
过去的4年，黄章带领魅族成为了国内最好的MP3品牌之一，但黄章却觉得，MP3已经看不到发展方向了，他们站在山顶正无路可走。而此时iPhone的发布，则让他一下找到了方向，黄章决定转型做手机。
这与乔布斯最初做iPhone的初衷有些相似，2005年iPod的销量暴涨，但是乔布斯却愈发有些担忧，他总担心有什么会抢了他们的饭碗，想来想去，他觉得这个设备可能会是手机。
他的担心不无道理，因为当时的手机都开始配备摄像头，这直接导致了数码相机市场的急剧萎缩，而如果在手机中内置音乐播放器，那用户就没必要买iPod了。
不过，苹果最初并没有选择自己做手机，而是选择了与摩托罗拉合作，在其中内置iPod。但乔布斯实在无法忍受这款合作机型丑陋的外观以及混乱的操作方式，终于在一次产品会议上，他忍无可忍：“我受够了和这些愚蠢的公司打交道，我们自己来。”
就这样，在历数了各种手机的“脑残”设计后，一款革命性的手机诞生了。
iPhone与Android的横空出世，让雷军意识到，互联网还远远没有达到它应有的高度，移动互联网会创造更大的奇迹。
他隐约感觉到，一个新的时代可能要来临了。
2 出乎所有人意料的是，在带领金山成功上市2个月后，雷军选择了离开。
8年的上市准备，让他身心俱疲，那段时间他瘦的厉害，这个被认为是最勤奋的CEO，有点累了。
（雷军与金山创始人求伯君）
这年夏天，在距离金山总部不远的清华大学南门外，华清嘉园的一栋民居里，iPhone刚发售，王兴就买来研究。
就在半年前，由于融资不顺，他刚刚卖掉了自己和同学一手创办的校内网，这个决定给他留下了巨大的遗憾。
不过王兴他们也是幸运的，因为对于大多数创业公司来讲，投入过时间、金钱、精力后，也不过是竹篮打水一场空，没有任何回报。
他决定重新做一件事情，但绝不是为了某一天再把它卖掉。
机会很快就来了，2007年3月，一个名为Twitter的网站在美国一炮而红，用户可以通过电脑、手机在Twitter上发布140个字符以内的消息。
当时还在百度的穆荣均把新闻链接发给了王兴，恰巧王兴也在看这个网站，他随即向穆荣均发出了邀请，希望一起来做一款中国版的Twitter。
王兴当时还在千橡，如果此时离开就会损失一大笔钱。但王兴说：“钱不重要，时间对我很重要。”
很多人创业是为了钱，但王兴不是，他对钱看的很淡，这可能与他的家庭有关。王兴父亲在福建当地开的水泥厂，年销售额就超过几亿元。由于家庭富裕，王兴是当地最早拥有计算机，也是最早接触互联网的人。
王兴的高中班主任认为王兴能有今天的成就，家庭经济实力起了很大作用，允许他可以不为谋生而读书，也允许他失败。
而王兴的父亲则将自己的成功归功于赌对了中国大时代的脉搏，或许父亲的敏锐嗅觉也传给了儿子，王兴几次都精准的踩到了互联网创业的浪潮。
（王兴与穆荣均）
在经过了一次彻夜长谈之后，穆荣均终于下定决心。
就这样，在华清嘉园的一栋民居里，王兴开始了第二次创业，并为这个类似Twitter的网站取名“饭否”，为此他们翻了一星期的字典。
华清嘉园被誉为“民间硅谷”，这里曾先后走出了包括校内网、暴风影音、饭否、美团、酷讯、美丽说、酷我、快手、融360等一批知名互联网企业。
快手创始人宿华形容那是一段“楼上做无人机，楼下做团购”的日子。
宿华和王兴是校友，同样毕业于清华大学。2013年宿华在投资人的撮合下认识了程一笑，两人都很看好视频社交的未来，于是在华清嘉园一套三室一厅的房子里，做出了如今几亿“小镇青年”都在用的视频软件——快手。
3 在最开始的两年，饭否运营的不算成功。
因为大多数人都不知道140个字该发什么，所以用户增长一直缓慢，在此期间，王兴还尝试做了海内网。
直到2009年初，王兴又把饭否重新捡了起来，那段时间饭否用户突破了100万，增长势头很快，当年很多群体事件的第一消息源，都来自饭否。
当然，这也为饭否带来了麻烦。
很快，王兴的母亲在美国上网时发现，饭否停了。这让她非常担心，她说王兴从小要强，做事认真，这次对他的打击太大。
但王兴并没有过多的抱怨，他习惯于从自身找原因，他觉得是自己对这件事情认识不充分。因此后来在做美团的时候，他就很注意了。
不过即使在饭否被关停的时候，王兴的团队也没有散。只走了两个，其中一位长着一张娃娃脸的80后，是王兴的福建龙岩老乡。
这个年轻人，就是张一鸣。
张一鸣毕业于南开大学，读书时的张一鸣，不打牌、不玩游戏，这让他显得有些不合群。
但当大部分人还在用电脑聊天、打游戏的时候,张一鸣已经可以熟练使用搜索引擎了。在同学的印象中，他是个“技术型宅男”，但酷爱运动，尤其爱打羽毛球。
（创业早期的张一鸣）
张一鸣的第一份工作是在酷讯，当时酷讯想做下一代的搜索引擎，这让张一鸣很兴奋，虽然他也不知道该怎么做，但他很愿意去学。
遗憾的是，酷讯的两位创始人陈华和吴世春先后被资本赶出了公司，酷讯也因此在红极一时后迅速衰落，先是卖给了Expedia，后又被美团收购。
不过，酷讯在中国的互联网历史上却颇具传奇色彩，这家公司曾先后走出了包括张一鸣、陈华、吴世春等在内的30多位活跃的创业者。
虽然两次参与创业都失败了，但在酷讯和饭否的经历，却让张一鸣对信息分发形成了独到见解，也让他得到了酷讯投资人王琼的青睐。
饭否关闭后，张一鸣开始了自己的第一次独立创业，创办了九九房。
4 离开金山的这段时间，雷军在投资圈做的风生水起，先后投出了拉卡拉、凡客、YY等20多家公司。
但他总觉得自己缺少点什么，想来想去，他觉得自己缺少一家可以称得上伟大的企业。
雷军成名很早，他在金山担任总裁的时候，马化腾和丁磊还只是金山下面的站长。而如今腾讯已成长为中国市值最高的公司之一，网易也做的风生水起。
但上市后的金山，市值却只有主流互联网公司的零头，这让他开始反思。
18岁的时候，雷军曾经读过一本《硅谷之火》，这本书讲述的是比尔·盖茨和乔布斯等人通过创业改变世界的故事。
这给了雷军极大的触动，也彻底点燃了他的创业梦想，他希望自己有一天也能像乔布斯一样创办一家世界一流企业。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5de4c67ca09d3840b51247e88ad1c266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcfced322d90d3afa2baceb06e32414f/" rel="bookmark">
			pyppeteer 绕过selenium检测，实现淘宝登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，一切使用自动化框架的项目，或者说代码，或者说爬虫都会碰到某些网站刚刚打开页面就被判定为：非人类行为。为啥？？
----------因为很多网站有对selenium的js监测机制。比如：navigator.webdriver，navigator.languages，navigator.plugins.length......很多很多。
比如美团，大众，淘宝这些'无良'商家。。就有对window.navigator.webdriver的检测机制。正常情况下----&gt;
window.navigator.webdriver的值为undefined。
而当我们使用selenium 的时候----&gt;
window.navigator.webdriver的值为True。
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
主要说下破解的两种办法。第一张使用mitmproxy用中间人的方式截取服务器发送来的js，修改js里面函数的参值方式发送给服务器。相当于在browser和server之间做一层中介的拦截。不过此方法要对js非常熟悉的人才好实施。
第二种方法依旧通过selenium，不过是在服务器在第一次发送js并在本地验证的时候，做好‘第一次’的伪装，从而实现‘第一次登陆’有效。。方法简单，适合小白。
我们用第二种方式来实现淘宝的登陆吧------------------&gt;
pyppeteer 加 asyncio 绕过selenium检测，实现鼠标滑动后自动登陆（代码很简单。主要熟悉异步模块及pyppeteer模块。pyppeteer模块看不懂就去看puppeteer文档，pyppeteer只是在puppeteer之上稍微包装了下而已 ）。 1.main_py 文件作为主要运行的py：
import asyncio import time from pyppeteer.launcher import launch from alifunc import mouse_slide, input_time_random from exe_js import js1, js3, js4, js5 async def main(username, pwd, url): browser = await launch({'headless': False, 'args': ['--no-sandbox'], }) page = await browser.newPage() await page.setUserAgent( 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcfced322d90d3afa2baceb06e32414f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd532151785760454b9ce6ecb977e89/" rel="bookmark">
			C语言 将函数（有参、无参）作为参数传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习中遇到一个问题，就是要计算出一个函数的执行时间，但是我不可能每个函数都去执行一次clock，所以这里要想统一处理这个问题就需要把函数作为参数传入到方法内。
首先是是无参函数作为的传递：
void printTest_0() { printf("%s", "printTest_0"); } void printTest_1() { printf("%s", "printTest_1"); } void CalRunTime(void(*pri)()) { pri(); } 后面就是带参数函数的传递：
void printTest_2(int value) { printf("%s,value=%d\n", "printTest_2", value); } void printTest_3(int value) { printf("%s,value=%d\n", "printTest_3", value); } void CalRunTime(void(*pri)(int), int value) { pri(value); } 这里就是将函数作为参数传递的代码。
想了解更多可以添加QQ群：879354767 或者关注下方公众号了解更多信息：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4307bbd0196ceba02b63df9da380b314/" rel="bookmark">
			ssm&#43;shiro 实现无密码直接登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用shiro可以十分方便，有效的实现接口权限控制功能。
但是在开发中，会遇到了这样一种场景：
在微信公众号开发里，用户在公众号里输入用户名和密码绑定项目，绑定完成后，下次进入项目跳过登录 直接进入项目的首页。在这个过程中，用户第二次登录时是使用微信提供的openId直接登录，这是免密登录的。
由于shiro登录是默认需要账号密码才能生成token，进而进行登录验证功能的，所以需要改写。
注意，此时应该是密码和免密同时存在的，而不是直接粗暴的去掉密码验证。
查找了网上的资料后处理方式有2种
第一种：重写token，验证时发现为免密类型时直接返回true 整体思路： 自定义token，加入免密标识符，在进行授权时判断是密码登陆或无密码登陆，自定义密码认证方法，即写一个方法继承HashedCredentialsMatcher，重写其中的doCredentialsMatch，将其中的token改写为自定义的token，最后将自己写的密码认证方法注入shiro
1.shiro的配置文件里面有一个是&lt;bean id="credentialsMatcher" class="xxxxx.xxxMatcher"&gt;这需要一个继承HashedCredentialsMatcher的子类，重写doCredentialsMatch方法
2.自定义一个token，继承自UsernamePasswordToken，添加一个标识符表名是否免密登录。
3.Subject subject = SecurityUtils.getSubject();
EasyTypeToken token = new EasyTypeToken(loginName);
subject.login(token);
4.回到第一步 重写方法的第一行 直接强转 token 获取标识符 如果为免密登录 直接返回true
--------来自https://blog.csdn.net/Sil_sunday/article/details/81986025?utm_source=copy
他在这篇文章里有实现代码，但是我在实验的过程中发现 AuthenticationToken不能直接转换成EasyTypeToken类型，博主可能写掉了 重写createToken部分，我自己尝试重写，但是始终报错类型转换失败，这种方式我还是没有实现。但是这个思路是可行的。
第二种：在免密登录时，在后台写一个默认的登录密码 由于第一种方法的问题迟迟没有解决，就觉得考虑其他方法，后来发现有一种非常简单的方法：
在免密登录的情况下，写一个固定的密码生成token，并将它的MD5加密后的内容放到 SimpleAuthenticationInfo里，这样就直接可以登录成功了。
实现代码如下：
这是reaml文件 doGetAuthenticationInfo方法的代码
/** * Authentication(身份验证)：简称为“登录/绑定”，即证明用户是谁。 * @param token * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { // 1. 把AuthenticationToken转换为UsernamePasswordToken UsernamePasswordToken upToken = (UsernamePasswordToken) token; // 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4307bbd0196ceba02b63df9da380b314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35716b74fd53e5dc8c2f9dd42bee0651/" rel="bookmark">
			Java计算两个日期相差的月数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 获取两个日期相差的月数 */ public static int getMonthDiff(Date d1, Date d2) { Calendar c1 = Calendar.getInstance(); Calendar c2 = Calendar.getInstance(); c1.setTime(d1); c2.setTime(d2); int year1 = c1.get(Calendar.YEAR); int year2 = c2.get(Calendar.YEAR); int month1 = c1.get(Calendar.MONTH); int month2 = c2.get(Calendar.MONTH); int day1 = c1.get(Calendar.DAY_OF_MONTH); int day2 = c2.get(Calendar.DAY_OF_MONTH); // 获取年的差值 int yearInterval = year1 - year2; // 如果 d1的 月-日 小于 d2的 月-日 那么 yearInterval-- 这样就得到了相差的年数 if (month1 &lt; month2 || month1 == month2 &amp;&amp; day1 &lt; day2) { yearInterval--; } // 获取月数差值 int monthInterval = (month1 + 12) - month2; if (day1 &lt; day2) { monthInterval--; } monthInterval %= 12; int monthsDiff = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35716b74fd53e5dc8c2f9dd42bee0651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be51369b65c6782aa1ae1f70871df8d3/" rel="bookmark">
			网络基础相关名称解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IP地址
IP地址：Internet上每台主机都必须有一个唯一的地址以区别于其他主机，这个地址就是Internet地址，也称作IP地址；（相当于在中国公民身份证号）
IPv4（第四版本的IP协议）是构成现今互联网技术的基石协议；
IP地址的构成：
IP地址由32位二进制构成，共约40亿个，由网络地址和主机地址构成；
一个IP地址分为四段：a.b.c.d ，段与段之间用原点分开。
IP地址表示方法：二进制形式和点分十进制形式；
IP地址的分类：5类
A类地址，B类地址，C类地址，D类地址，E类地址
IP地址的分类是根据第一段（a字段，前8位）的取值范围来划分的；
A类地址：以0开头，前8位为网络地址，后24位为主机地址。A类地址第一段a字段的取值范围1~126。每一个A类地址中可以容纳的主机的数目约为1600万。
地址范围：1.0.0.0~126.255.255.255
B类地址：以10开头，前16位为网络地址，后16位为主机地址。B类地址第一段a字段取值范围为128~191。每一个B类地址中可以容纳主机数目约为65000。
地址范围：128.0.0.0~191.255.255.255
C类地址：以110开头，前24位为网络地址，后8位为主机地址。C类地址第一段a字段的取值范围是192~223。每一个C类地址可容纳主机的数目约为254。
地址范围：192.0.0.0~223.255.255.255
IPv6（第六版IP协议）：一个IP地址由128位二进制组成，采用冒分16进制。
特殊的IP地址：
1.专用IP地址：三类网络号，这些地址不会被Internet分配因此也不能被路由，
分别用于：
A类：1.0.0.0~10.255.255.255 （长度相当于1个A类IP地址）
B类：172.16.0.0~172.31.255.255 （长度相当于16个连续的B类IP地址）
C类：192.168.0.0~192.168.255.255 （长度相当于256个连续的C类IP地址）
2. 特殊IP地址：
0.0.0.0 是全零网络代表默认网络，帮助路由器发送路由表中无法查询的包。如果设置了全零网络路由，路由器中无法查询的包都会被送到全零网络的路由中去；
127.0.0.1 称作回送地址，属于环回地址，IP从127.0.0.0到127.255.255.255都将环回到本地主机中；
255.255.255.255 限制广播地址，对本机来说，这个地址指本网段内（同一广播域）所有主机；
二、子网掩码
子网掩码：是一个32位二进制的值，可以将IP地址分离出网络地址和主机地址，采用点分十进制的形式。子网掩码不能单独存在它必须结合IP地址一起使用。
子网掩码由1和0组成，且1和0分别连续。
子网掩码的长度也是32位。左边是网络为，用二进制数字1表示，1的数目等于网络位的长度；右边是主机位用2进制数字0表示，0的数目等于主机位的长度；
这样做的目的是为了让掩码与IP地址做与运算时用0遮住原主机数，而不改变网络段的数字；而且很容易通过0 的位数确定子网的主机数；
将32位IP地址与32位的子网掩码各位进制进行 '与' 运算，得到的是该IP地址的网络地址；
方法：
子网掩码可以判断两台计算机是否属于同一网段，将计算机10进制的IP地址和子网掩码转换为2进制的形式，然后进行 ‘与’ 运算，如果网络地址是相同的，那么两台计算机就属于同一网段；
子网掩码可分为缺省子网掩码和自定义子网掩码：
1. 缺省（默认）子网掩码：即为划分子网，对应的网络号都是1，主机号位都是0；
A类网络缺省（默认）子网掩码：255.0.0.0
B类网络缺省（默认）子网掩码：255.255.0.0
C类网络缺省（默认）子网掩码：255.255.255.0
2. 自定义子网掩码是将一个网络划分为几个子网，需要每一段使用不同的网络号或者子网号，实际上我们可以认为是将主机号分为两个部分：子网号和子网主机号。
形式如下：
未做子网划分的IP地址：网络号+主机号
做子网划分的IP地址：网络号+子网号+子网主机号
也即是说，IP地址在子网划分后，以前的主机号一部分给了子网号，剩下的是子网主机号；
三、详解子网掩码：
子网掩码，又称网络掩码、地址掩码、他是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位表示的是主机位的位掩码；
子网掩码不能单独存在，它必须结合IP地址一起使用，子网掩码的作用只有一个就是：将某个IP地址划分成网络地址和主机地址两部分；
子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上还是在远程网上。
利用子网掩码可以将打的网络划分成子网，即VLSM（可变长子网掩码），也可以将小的网络归并成大的网络，即超网；
IP地址的网络号和主机号各是多少位呢，如果不指定，就不知道哪些是网络好，哪些是主机号，这就需要子网掩码来实现。
方法：
在求子网掩码前，先要清楚要划分的子网的数目，以及每个子网的所需主机数目；
将子网数目转化为二进制来表示；取得该二进制的位数，为N取得IP地址的类子网掩码，将其主机地址部分前N位置为1即得到该IP地址划分子网的子网掩码； 例如：将B类IP地址168.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be51369b65c6782aa1ae1f70871df8d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a8fd1dff2ee0f708f08c8e4b34a1d01/" rel="bookmark">
			CentOS7.2安装mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载Mysql yum包 http://dev.mysql.com/downloads/repo/yum/
复制链接使用wget下载
wget http://repo.mysql.com/mysql57-community-release-el7-10.noarch.rpm 2. 安转软件源 rpm -Uvh mysql57-community-release-el7-10.noarch.rpm 3. 安装mysql服务端 yum install -y mysql-community-server 注意：这里需要较长时间下载
因为mysql5.7之后，安装完会设置一个初始密码，所以第一次是登录失败的，修改mysql的链接在https://www.cnblogs.com/wuotto/p/9682400.html
转载于:https://www.cnblogs.com/wuotto/p/9707019.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/192/">«</a>
	<span class="pagination__item pagination__item--current">193/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/194/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>