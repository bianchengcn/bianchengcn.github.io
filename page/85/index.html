<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3364ca358625c3ba0055184ba7159731/" rel="bookmark">
			Github Actions 自动同步到 Gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言具体方案 引言 平时开源代码一般已Github为主，但是会遇到网不好的情况，于是考虑将Github仓库自动同步到Gitee上，作为备份。考虑不能手动做这个事情，于是想到了Github Actions 自动化同步到Gitee中 具体方案 假设Github已经有了仓库，这里以RapidAI/YOLO2COCO仓库为例。
！！！注意：下图图文并不完全对应，以文字为主
在Github仓库下开通Actions的功能，点击Actions选项卡→ 点击右下角Create a new workflow，命名为SyncToGitee.yml即可。
编写workflow的yml代码, 可以复制如下代码到自己yml中，需要更改的地方，在代码中已经标出name: SyncToGitee on: push: branches: - main jobs: repo-sync: runs-on: ubuntu-latest steps: - name: Checkout source codes uses: actions/checkout@v3 - name: Mirror the Github organization repos to Gitee. uses: Yikun/hub-mirror-action@master with: src: 'github/RapidAI' # 这里改为自己github账号名称，如github/xiaoming dst: 'gitee/RapidAI' # 这里改为gitee上账号名称，如gitee/xiaoming dst_key: ${{ secrets.GITEE_PRIVATE_KEY }} # 这是生成的私钥，下面第3步会讲 dst_token: ${{ secrets.GITEE_TOKEN }} # 这是gitee上生成的token，下面会讲 force_update: true static_list: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3364ca358625c3ba0055184ba7159731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824beabda36787c8c8d14b9eef3c9797/" rel="bookmark">
			【由浅入深 - Java笔记】玩转List：List过滤和筛选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 List筛选/过滤，Stream和Filter1. 使用list的Stream进行筛选2. 增强for循环遍历元素，进行筛选3. 使用list.foreach遍历4. 使用iterator遍历5. 视频笔记 List筛选/过滤，Stream和Filter 花时间精力去凿许多浅井还不如花相当多的时间和精力去凿一口深井。
——罗曼·罗兰
在Java的编程中，如果要问，出现频率最高的Collection工具类是什么？毫无疑问，答案是List。本文分享几种在Java中，按照对象的属性，对List里面的元素进行过滤的常见方法。
1. 使用list的Stream进行筛选 /** * Java8以上，使用list的Stream进行筛选 * @param userBeanList 用户列表 * @return 筛选后满足条件的用户列表 */ public List&lt;UserBean&gt; filterByStream(List&lt;UserBean&gt; userBeanList) { return userBeanList.stream().filter(userBean -&gt; Objects.nonNull(userBean)) .filter(userBean -&gt; userBean.getAge() &gt;= 18) .collect(Collectors.toList()); } 2. 增强for循环遍历元素，进行筛选 /** * for循环遍历元素，进行筛选 * @param userBeanList 用户列表 * @return 筛选后满足条件的用户列表 */ public List&lt;UserBean&gt; filterByFor(List&lt;UserBean&gt; userBeanList) { List&lt;UserBean&gt; newUserBeanList = new ArrayList&lt;&gt;(); for (UserBean userBean : userBeanList) { if (userBean.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/824beabda36787c8c8d14b9eef3c9797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e884d5664f95b7281ed3cfa1338ed98/" rel="bookmark">
			软流水的方法--国科大体系结构 期末必考题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软流水的概念 软流水是通过重组循环体使得不同循环体指令并行执行，新循环体的每个操作来自不同的循环体，以分开数据相关的指令。
软流水后，循环体会变成装入、主体循环、排空三个部分。
在软流水后循环执行时，主要是主体循环部分在执行，装入和排空仅执行一次。因而可以通俗理解为：装入是为了让主体循环可以正确执行的预处理阶段，排空是保证主体循环执行后结果正确的收尾阶段。
之后会对这些概念有更深入的介绍。不想理解就直接看解题方法。
软流水的方法 写在前面，我会在指令前加序号，同时在分析时直接用序号来描述指令。
先看一个简单例子。
假设我们需要执行如下循环：
for(i = 1; i &lt;= 100; i++)	x[i] = x[i] + s;	假设 s 是一个常量,存在寄存器 F0 中，数组首地址在 R1 中，数组每个元素占 8 字节。且 R2 = R1 + 800。同时我们假设 R1 地址初始是0，在之后会用到这一点。
于是有如下指令段：
// 注： L.D S.D 有时候写成 LDC1 SDC1 L1: 1 L.D F2, 0(R1) // 取X[i] 2 ADD.D F4, F2, F0 // 计算X[i] + s 3 S.D F4, 0(R1)	// 存X[i] 4 DADDIU R1, R1, 8 // X的下标+1 5 BNE R1, R2, L1 // R1不等于R2，程序跳转到L1处继续执行 流水线延迟为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e884d5664f95b7281ed3cfa1338ed98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43697f2bdc6fd24db6d9957e55b3629c/" rel="bookmark">
			区块链北大肖老师学习笔记5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第六节
比特币网络
比特币工作在应用层(application layer:Bitcoin block chain)，它的底层是一个网络层(network layer:P2P overlay network)。
比特币的P2P网络是非常简单的，所有节点都是对等的。不像有的P2P网络有所谓的超级节点（super node）、主节点（master node）。
要加入P2P网络首先得知道至少有一个种子节点，然后你要跟种子节点联系，它会告诉你它所知道的网络中的其他节点，节点之间是通过TCP通信的，这样有利于穿透防火墙。当你要离开时不需要做任何操作，不用通知其他节点，退出应用程序就行了。别的节点没有听到你的信息，过一段时间之后就会把你删掉。
比特币网络的设计原则是:简单、鲁棒，而不是高效。每个节点维护一个零度节点的集合，消息传播在网络中采取flooding的方式。节点第一次听到某个消息的时候，把它传播给去他所有的零度节点，同时记录一下这个消息我已经收到过了。下次再收到这个消息的时候，就不用转发给零度节点了。
零度节点的选取是随机的，没有考虑底层的拓扑结构。比如一个在加利福尼亚的节点，它选的零度节点可能是在阿根廷的。这样设计的好处是增强鲁棒性，它没有考虑底层的拓扑结构，但是牺牲的是效率，你向身边的人转账和向美国的人转账速度是差不多的。
比特币系统中，每个节点要维护一个等待上链的交易的集合。假如一个集合的交易都是等待写入区块链里的，那么第一次听到某个交易的时候，把这个交易加入这个集合，并且转发这个交易给节点，以后再收到这个交易就不用转发了，这样避免交易会在网络上无线的传播下去。转发的前提是该交易是合法的。
这里有冲突的情况，有可能你会有两个有冲突的交易，差不多同时被广播到网络上。比如说A→B和A→C，这两个如果同时广播在网络上，那么每个节点根据在网络中的位置的不同，收到两个交易的先后顺序不同。
比如一个人先收到第一个交易，就写入到集合里，再收到第二个交易的时候就不会写入集合，因为跟上一个交易有冲突，就认定是非法的。假设这两个交易花的是同一个币，那么写入集合的交易就会被删掉。
比如说节点听到一个新发布的区块，里面包含了A→B的交易，那么这个交易就可以删掉了，因为已经写入到了区块链里。如果节点又听到了A→C的交易，该怎么办?这时候也要把A→B删掉。因为A→C如果已经被写入到了区块里，那么A→B就变成了非法交易，就变成了double spending，这就是冲突的情况。可能某个先收到A→C的节点，抢先挖到了矿，发布了区块。
新发布的区块在网络上的传播有很多方式，跟新发布的交易是类似的。每个节点除了要检查区块的内容合法性之外，还要查它是不是在最长合法链里。越是大的区块，在网络上传播速度越慢。
比特币协议对区块的大小有1M字节的限制。比特币系统采用的传播方式是非常耗费带宽的，带宽是瓶颈。按1M的区块大小限制来算的话，一个新发布的区块有可能需要几十秒，才能传输到网络大部分境地，这已经是挺长时间了，所以这个限制值不算小。
还需要注意的一点:我们讲的比特币网络的传播属于best effort 。一个交易发布到比特币网络上，不一定所以的节点都能收到，而且不同的节点收到这个交易的顺序也不一定是一样的。网络传播存在延迟，而且这个延迟有的时候可能会很长，有的节点也不一定按照比特币协议的要求进行转发。
可能有的该转发的不转发，导致某些合法的交易收不到，也有的节点可能转发一些不该转发发的消息，比如说有些不合法的交易也被转发了。这就是我们面临的一个实际问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aae383bdeff8769434ef57797a5de30/" rel="bookmark">
			54.Python的def语句自定义函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		54.def语句自定义函数 文章目录 54.def语句自定义函数1.课题导入—数学中的函数1.1 计算圆的面积1.2 计算不规则图形的面积 2. 什么是函数3. 函数分类3.1 内置函数3.2 自定义函数 4. 计算多个矩形的面积5. 自定义函数计算矩形的面积6.自定义函数的写法1.先写函数要实现的功能2.添加自定义函数语句3.调用函数 7. 自定义函数的语法8.缩进语法汇总 1.课题导入—数学中的函数 1.1 计算圆的面积 圆的计算公式：π*r**2
r**2表示r的平方。
print(5**2) 【终端输出】
25 r**3表示r的3次方。
print(5**3) 【终端输出】
125 【体验代码】
# 圆的半径为3 r = 3 # 输出圆的面积 print(3.14*r**2) 【终端输出】
28.26 1.2 计算不规则图形的面积 【目标任务】
上图中大圆的半径为5，小圆的半径为2，计算黄色部分的面积。
【思路解析】
圆的面积计算有现成的函数：π*r**2
上图黄色部分是不规则图形，计算该部分的面积，没有现成的函数。
我们可以自定义一个函数计算黄色部分的面积：
自定义一个函数：黄色部分的面积=大圆的面积-小圆的面积
【体验代码】
# 大圆的半径为5 R = 5 # 小圆的半径为2 r = 2 π = 3.14 # 自定义一个函数计算黄色部分的面积 s = π*R**2 - π*r**2 # 输出黄色部分的面积 print(s) 【终端输出】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aae383bdeff8769434ef57797a5de30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e128cc1952bc3c2bc02f3acfc70d2580/" rel="bookmark">
			用for循环，循环100
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		for i in range(100): print(i)
这是一个简单的 for 循环，它会循环 100 次。每次循环，变量 i 的值会增加 1，最后 i 的值会变成 100。在每次循环中，你可以在循环体内执行任何你想要的操作。
例如，你可以使用这个 for 循环来计算 1 到 100 的总和：
sum = 0 for i in range(100): sum += i print(sum)
或者，你可以使用 for 循环来打印 1 到 100 的所有数字：
for i in range(100): print(i)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f3e4e3cc0002361adba1c4d7ecf81b1/" rel="bookmark">
			记录我の秋招之旅【23届 CV算法岗】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 碎碎念春招实习华为实习魔幻秋招尘埃落定 碎碎念 今年(2022年)的秋招不能说"非常困难"吧，只能说是"地狱难度"，相信参与或者从侧面了解过的同学们也能感同身受。从今年的三月份开始着手秋招，期间也一直忙着实验室的科研任务，所以这段博客也更新比较少，回复大家的评论和私信也比较慢，这里说声抱歉。后续的话，我也继续写博客，分享自己对于论文和技术上的一些见解，并和大家进行交流。
先说说这次秋招的大体情况，我读研主要做的方向一直都是“计算机视觉-机器智能与模式识别”，所以未来想从事的职业也是跟计算机视觉相关的，俗称"CV算法岗"。众所周知，算法岗一直都很卷，CV算法那更是卷中卷，特别是这几年整体就业压力变大，所以网络上各大平台也都是各种劝退。再遇上今年这种就业形势，我整个求职过程可谓是"一波三折"。从4月份开始投实习，5月底拿到华为的实习offer，7月~10月实习同时一边秋招，11月底确定最终去向，12月初签完三方，正式结束秋招，最终顺利地上岸了阿里巴巴的CV算法岗。
这里先总结一下CV算法岗求职五大项：学历背景、大厂实习、学术论文、项目经历、算法竞赛。5个里面要有2~3个亮点，比如学历就是top2硕或者华五科班硕，大厂实习就是行业头部厂的实习产出，学术论文就是领域内的顶会顶刊，项目经历就是参与了大型的实际落地项目，算法竞赛就是天池、kaggle、A会workshop这类比赛top。
除此之外，还需要准备算法八股文(深度学习基础、机器学习基础、传统机器视觉算法等)、刷题(力扣题、思维逻辑题、概率题等)、并且掌握一定的计算机基础知识(数据结构、linux操作等)以及一颗强大的内心。所以我在这里也“劝退”大家一句，如果不是真的喜欢算法，还是不要来卷了，开发进大厂概率更大，未来发展也很不错。但如果真的喜欢，认定了“不撞南墙不回头”，那就努力努力在努力，好好准备，冲tmd！！！
废话不多说，下面就按照时间线记录"我の秋招之旅"。本文并不涉及到太多的笔经、面经，主要是记录个人经历和一些反思，给自己留一个纪念。在此之余，如果还能给大家提供一些参考就更好不过了。
春招实习 时间：四月初~五月初
我在去年(21年)就有过一段某中厂的CV实习经历，不过当时找实习比较匆忙，再加上当时个人实力还比较菜，所以实习期间成果并不突出。因此今年的目标就是好好准备，找一段大厂实习累积项目经验，如果还能转正留下就更好了。抱着这样的信念，我在科研之余就全力准备实习：简历、刷题、算法八股文等。
但到了实习开始的时候，总觉得自己没有准备好，所以在很多公司开启第一批招聘的时候，我迟迟没有投出简历。一直直到四月中旬的时候才投简历，这个时候能投的公司已经比较少了。并且考虑到很多公司一旦留下了不好的面评反而会影响到秋招（后面看来纯属是多虑了…），所以我实习一共就只投了5家公司[腾讯、华为、百度、网易、商汤]。其中4家给了笔试机会，只有2家给了面试机会，最后完整通过面试和拿到offer的只有华为一家。
值得一提的就是，华为的招聘节奏从实习就可见一斑了。四月底面完，直到五月底才最终确定offer。在等待的过程中，信心确实备受打击了，虽然我知道有自己策略上的失误，但是也不免对自己的能力产生了怀疑。当时心里想着就是秋招梭哈，不行就春招再转战C++开发。好在后面的华为offer也给我吃了一颗定心丸。
拿到offer之后，预约了七月份的入职，在这个期间把手上的科研任务进行收尾。
经验与反思
找一段靠谱实习：现在回过头来看，实习转正确实是一条很稳妥且安心的路。身边进大厂实习的同学大多数都成功转正，早早结束了秋招. (参考同学样本来自的公司：字节、阿里、蚂蚁、美团等 - 主要是后端开发岗位)一定要早投简历：当然不能在完全没准备的情况下投，但一定要知道永远没有完全准备好的时候。越早投越好，可以边准备边投，因为有些岗位到后面就招满了，特别是算法这种卷的岗位。实习也不存在所谓的补录，所以错过了就真的错过了。简历上的技术要深入：自己简历上的项目、比赛、论文等，其包含的技术细节一定要深入了解，熟悉每一点。参考STAR法则去讲述你的经历，并且反思可以提升和改进的点。信念感要强，不要气馁：当时在找实习无offer的时候，这篇博客时给了我很大的精神鼓舞：算法岗必须人手一篇顶会？超详细面经：无论文、无实习拿下腾讯CV算法岗（不过这是20年的博客了，仅供参考，腾讯今年是真不咋招人啊）。选对好努力的方向，一直坚持下去，总会达到自己的目标的！一定不要自暴自弃，机会永远都是留给有准备的人的。 华为实习 时间：七月中旬~十月中旬
7月8号刚把论文投出去，我10号就赶去深圳了（因为自己选的base就在深圳，也正是因为选了深圳才给了自己一个遇见爱情的机会hh，这里与秋招无关暂不提。愿天下有情人终成眷属！）
在华为的实习，很充实、很快乐，遇见了一群有趣的大佬们。组里有天才少年，北大毕业的年轻leader，还有一群实力过硬、乐于助人的同事们。在实习期间，我一共参与了两个项目，并在其中一个项目中担任了还算较为重要的角色。实习期间做的都是与图像算法相关的研发与预研工作，做得还算不错，离职时主管同事对我的评价也挺高的。最终，这个项目后续也顺利上线，并在今年的华为开发者大会上进行了展示。
在华为实习感受最深的几点，一是整体氛围较好，这个氛围不单指的是技术研究氛围，也包括了与同事一起相处的工作氛围，很舒服很自在；二是大厂做项目的严谨，其中听得最多的一个词"拉通对齐"，因为一个落地项目往往不单是一个组几个人就能解决的，而是要拉通上游下游一起解决。并且每个环节都是需要经过严格设计、研发、测试的，这也是和实验室项目、比赛最大的不同；三是平台技术实力，大公司平台会提供很多硬件、软件上的支持，比如部署用的框架就是华为自研的"MindSpore"，合作的对象也是各行业、高校的大牛；四是工作强度并没有网上说的那么大，什么每天加班到11点之类的。至少我在的部门，正常双休(除了月末周六)，周三周五17点30下班，剩下三天就算加班也很少超过21点。当然这是跟你的工作进度和项目紧急程度挂钩的，我个人的话不反对加班，反对的是为了加班而加班。
华为的整体福利也都不错，我在深圳龙岗区的坂田总部，园区内的配套设施很完善，食堂、健身房、篮球场等等。有一说一，菊厂的伙食是真不错，晚上的夜宵也很丰盛，在实习期间算是大饱了口福。租房的话，因为是华为实习生的身份，所以在周围的公寓里短租可以免违约金。
所以经过这次实习，对华为的整体印象还是非常不错的。虽然华为每年的招聘操作很迷，但还是衷心还是希望华为都能突破封锁，王者归来！
魔幻秋招 时间：六月底 ~ 十一月底
我个人秋招的流程可以从十一月底追溯到六月底，整整五个月。我在六月底的时候就已经开始投递简历，迎来了"秋招提前批"，当时投递了几家中厂，其中也顺利拿到一些意向，比如联发科、科大讯飞等，这对于稳定心态非常重要，俗称"保底offer"。当然，在提前批阶段我也投了不少大厂，包括腾讯、字节、百度、大疆等，要么是海笔无后文，要么就是二面挂。
我印象最深的是字节，当时是面的抖音下的一个业务部，第一面体验感非常差，记得反问的时候问面试官，想让他介绍一下具体所做的业务，他就说了四个字"图像理解"… 二面的时候我个人感觉非常好，从手撕到八股到项目，我都感觉面得非常不错，最后面试官也说觉得我不错，结果面完5分钟HR就给我说挂了。我问HR为啥，她张口就来"刷题的问题"，我无语了，寻思着10min手撕出一道hard题还不够吗？… …
不过后面在面蚂蚁的时候，面试官说了一段话也让我想通了，大概意思就是“面试算法岗的同学都非常优秀，所以大家在同等面试表现下，比拼的就是其他方面了”。这个其他方面指的有很多，比如你的软件开发能力、计算机基础能力，比如你发表论文的等级，比如你的学校…
所以一开始面试受挫的时候一定不要气馁，因为不是你太弱，而是对手太强… 因为这个阶段，大厂主要招的就是精英，主要是各大公司的一些头部计划，比如腾讯大咖，阿里星，美团北斗等等。这是大佬们的“集邮时刻”，我们能做的主要就是调整心态，认真准备每一场笔试、每一次面试，等待机会。
提前批结束，唯一通过的大厂就是华为了，相信这也是大多数人的真实写照。因为华为的笔试刷人少、进面多，并且按照往年的情况来看，不少人能走完终面。当时我投递的也是我实习的部门，所以也非常顺利地通过了面试，而且部门内部从leader、主管到部长也都对我有过口头允诺。在顺利通过华为的提前批面试后，后面秋招开启时，我基本就只投递大厂和部分感兴趣的中厂了，这也是我秋招过程中犯的最大的一个错。
在秋招机会最好的那段时间(金9银10)，我正在实习，并且已经通过华为的面试，所以我在心态上有些松懈。有时候为了赶进度或者听分享会，拒绝了不少笔试甚至一些面试机会。直到十一月时，华为突然传出了“暂停招聘”的传闻… … 让我开始意识到事情不对劲起来了… … 虽然后面联系了华为HR，她进行了辟谣。但我也开始重新认真准备起来了，因为这距离我通过面试已经快3个月了，我，有点慌了。还好在十一月的时候，正好也得到了部分公司的面试机会[其中就包括了阿里、商汤等]。
再进行面试时基本已经是秋招末尾了，机会和坑位也越好越少了。不过之前集邮的大佬们也基本上做出了自己的选择，所以这段时间的面试机会一定要好好把握。这个时候面试的流程推得比较快，基本上当天面完隔天就能得到结果并且马上约下一面。好在自己也一直有在好好准备，加上那几周面试时的整体状态也还不错，所以最后顺利拿到了阿里和其他几家公司的意向。
但要注意的是，秋招末期并不意味着面试难度就降低了，题还是那些题，对你的能力要求不会变。还是那句话，认真地去准备每一场笔试，对待每一场面试，机会永远是留给有准备的人。就像足球评论员贺炜说的那样，“成年人的世界里，从没有 “容易”二字，哪有什么无心插柳，只有努力过后的水到渠成”。
经验与反思
对于大厂，在没有拿到意向书的那一刻，结果都是不可控的。对于中厂，在没有拿到正式offer的那一刻，结果都是不可控的。对于小厂，在没有签约的那一刻，结果都是不可控的。对于初创公司，在没有入职的那一刻，结果都是不可控… … （结论及其主观，仅供参考，本人不负任何责任）；永远都要保持学习、保持进步：无论是offer缠身还是0 offer，永远不要停止学习停止进步，你要清楚自己的最终目标是什么，一直前进，机会都是留给有准备的人. 尘埃落定 在等华为开奖的过程中已经拒了几家公司的offer了，但在11月底的时候，特别是拿到阿里的offer后，我明白必须要做出一个选择了。尽管经过实习后对华为增加了不少好感，但时间总是会慢慢浇灭热情。冷静下来后，综合考虑了发展前景、平台、技术实力以及薪资待遇，最后还是选择了阿里巴巴。
从最开始实习碰壁、产生自我怀疑，到后面进华为实习、顺利通过提前批面试，再到华为暂停招聘风波，最后再到上岸阿里巴巴，可以说是一波三折。我相信每个经过秋招磨练的人，内心都会变得更强大，会更加认清自己想要的、自己追求的到底是什么。
有一句诗在我读研阶段给了我很大的精神支持，送给看完这篇博客的各位，也送给未来的自己。
长风破浪会有时，直挂云帆济沧海 最后再多嘴一下，就是未来博客的更新方向可能会偏向视频处理的相关算法，和我未来的工作方向相关。此外，以前没有更新完的系列可能不会再更了，十分抱歉~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/907a0ad99e5da25b1fd0a2d2a1db5afb/" rel="bookmark">
			html修改文字颜色代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在 HTML 中修改文字的颜色，你可以使用 style 属性并设置 color 属性。
例如：
&lt;p style="color:red"&gt;这是一段红色文字&lt;/p&gt; 你还可以使用 16 进制颜色值或者颜色名称来指定颜色。例如：
&lt;p style="color:#FF0000"&gt;这是一段红色文字&lt;/p&gt; &lt;p style="color:orange"&gt;这是一段橙色文字&lt;/p&gt; 你也可以在外部 CSS 样式表中定义文字颜色，然后使用 class 或 id 属性在 HTML 中应用。例如：
.red-text { color: red; } #orange-text { color: orange; } &lt;p class="red-text"&gt;这是一段红色文字&lt;/p&gt; &lt;p id="orange-text"&gt;这是一段橙色文字&lt;/p&gt; 注意，在 HTML 中使用 style 属性通常被视为不好的编码实践，因为它把样式与内容混在一起，这会使代码难以维护和扩展。最好的做法是使用外部 CSS 样式表来统一定义样式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80531473c80aa720ce46a5de39fc0e3f/" rel="bookmark">
			接口请求常见返回状态码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口请求常见返回状态码 接口请求、http状态码
调用后端API接口，返回的HTTP状态码，方便前端快速定位错误。常见的如下：
1XX（表示临时响应并需要请求者继续执行操作）
100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的
第一部分，正在等待其余部分。
101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。
2XX （请求成功）表示成功处理了请求的状态代码。
200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
201 （已创建） 请求成功并且服务器创建了新的资源。
202 （已接受） 服务器已接受请求，但尚未处理。
203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。
204 （无内容） 服务器成功处理了请求，但没有返回任何内容。
205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。
206 （部分内容） 服务器成功处理了部分 GET 请求。
3XX （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80531473c80aa720ce46a5de39fc0e3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da04c64c1f1fa1e25488ce2651d7aa08/" rel="bookmark">
			5*5几何均值滤波器python代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这是一个使用 Python 实现 5*5 几何均值滤波器的例子：
import numpy as np def geometric_mean_filter(image, kernel_size): # 创建一个零图像，用于存储滤波后的图像 filtered_image = np.zeros(image.shape) # 获取图像的行数和列数 rows, cols = image.shape # 获取滤波器的大小 kernel_size = kernel_size # 计算滤波器的半径 kernel_radius 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/975a98bc62ef69a8ec72454d746bb058/" rel="bookmark">
			el-select 选择器 当value有值但label为空，默认value值作为下拉框值时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人在写项目时发现，当 el-select 下拉框的值，value 有值的时候，label 为空时，下拉默认展示的数据是 value 值，且选中传值也是 value 值，而不是我想要的 label 空值
至于为什么会默认展示value值，暂未知晓，谁知道可以告诉我一下，我记录一下。
经过网络参考
我的做法是给他个默认的label值(toStr)：
&lt;el-select size="small" v-model="drugs.drug_type2" allow-create filterable default-first-option clearable placeholder="药品分类2" @change=" (val) =&gt; { category(val, options2); } " &gt; &lt;el-option v-for="item in options2" :key="item.value" :label="toStr(item.label)" :value="item.value" &gt; &lt;/el-option &gt;&lt;/el-select&gt; // 当label值为空，想要选中空的label值 toStr(str) { let data; if (str) { data = encodeURI(str); } else { data = "暂无名称"; } data = data.replace(/&amp;nbsp;/g, "%20"); return decodeURI(data); }, 这样展示的数据 label为 空的时候展示出来的就是“暂无数据”，且使用的时候，得到的相对应的数据也是我想要的 “空值”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a897351acf5b5d4387d218b6d512871/" rel="bookmark">
			【OpenCV&#43;Qt】使用车牌识别系统EasyPR识别车牌号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyPR是一个中文的开源车牌识别系统，其车牌识别划分为了两个过程：即车牌检测（Plate Detection）和字符识别（Chars Recognition）两个过程：
车牌检测（Plate Detection）：对一个包含车牌的图像进行分析，最终截取出只包含车牌的一个图块；
字符识别（Chars Recognition）：从上一个车牌检测步骤中获取到的车牌图像，进行光学字符识别（OCR）这个过程
效果：
如果还没有搭环境，可参考
Ubuntu+Qt下配置车牌识别系统EasyPR1.6环境_logani的博客-CSDN博客
1.在线程中循环捕获视频帧，发送到窗口进行显示 2.CPlateRecognize进行初始化 识别车牌和颜色，最多可同时识别4个
3.从帧图片中获取车牌信息CPlate存入容器中 如果为0，就是获取到
4.获取容器第一个车牌转成Mat进行显示 第一次转换是将二值化、灰度化后的单通道转成三通道，
第二次转换才是将Mat的BGR转换成RGB
5.获取车牌的文字信息，转换成QString到linneEdit进行显示 源码
#include "widget.h" #include "ui_widget.h" Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget) { ui-&gt;setupUi(this); pvideothread=new videothread("carinput.mp4"); connect(pvideothread,SIGNAL(sendFrame(Mat)),this,SLOT(receiveFrame(Mat)),Qt::BlockingQueuedConnection);//接收每一帧Mat //初始化 pr.setDetectType(PR_DETECT_CMSER|PR_DETECT_COLOR);//识别车牌和颜色 pr.setMaxPlates(4); pr.setResultShow(false); } Widget::~Widget() { delete ui; } void Widget::receiveFrame(Mat frame) { this-&gt;frame=frame.clone();//克隆一个做显示和检测车牌 cvtColor(this-&gt;frame, this-&gt;frame, CV_BGR2RGB); this-&gt;img1 = QImage(this-&gt;frame.data,this-&gt;frame.cols,this-&gt;frame.rows,QImage::Format_RGB888); this-&gt;img1 = this-&gt;img1.scaled(ui-&gt;label_2-&gt;width(),ui-&gt;label_2-&gt;height()); update(); } void Widget::on_pushButton_clicked()//播放 { pvideothread-&gt;start(); } void Widget::on_pushButton_2_clicked() { Mat carNum; int res=pr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a897351acf5b5d4387d218b6d512871/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79685f8ea39d90b0d7eacfec11b801d8/" rel="bookmark">
			xss漏洞攻防
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XSS基本概念和原理说明 基本概念 XSS又叫CSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意的特殊目的。XSS属于被动式的攻击，因为其被动且不好利用，所以许多人常呼略其危害性。xss是一种发生在web前端的漏洞，所以其危害的对象也主要是前端用户
在WEB2.0时代，强调的是互动，使得用户输入信息的机会大增，在这个情况下，我们作为开发者，在开发的时候，要提高警惕。
xss漏洞可以用来进行钓鱼攻击，前端js挖矿，用户cookie获取。甚至可以结合浏览器自身的漏洞对用户主机进行远程控制。
XSS攻击的主要途径 XSS攻击方法只是利用HTML的属性，作各种的尝试，找出注入的方法。现在对三种主要方式进行分析。
1.第一种：对普通的用户输入，页面原样输出，用户通过对JSCODE的伪装，经过一些操作就会跳出一个木马界面，取得登录用户的Cookie.
2.第二种：在代码区里有用户输入的内容
原则就是，代码区中，绝对不应含有用户输入的东西。
3.第三种：允许用户输入HTML标签的页面。
用户可以提交一些自定义的HTML代码，这种情况是最危险的。因为，IE浏览器默认采用的是UNICODE编码，HTML编码可以用&amp;#ASCII方式来写，又可以使用”/”连接16进制字符串来写，使得过滤变得异常复杂，如下面的四个例子，都可以在IE中运行。
反射性XSS &lt;非持久化&gt; 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。
反射型xss(get)
1.首先输入 &gt;'''&lt;&gt; 并提交，发现可以正常输出。
图3.3.1.1 输入数据
2.查看源码，发现我们的输入全部输出到了p标签中。
图2.1 查看源码
3.之后我们输入payload:&lt;script&gt;alert("xss")&lt;/script&gt;，发现输入框中容不下这么长的数据。
图2.2 进行验证
4.按F12，去改maxlength的值，改完后我们的payload执行成功。
图2.3 改变长度
图2.4 查看结果
3.3.2 反射性xss(post)
1.admin/123456 进行登录。
图2.5 进行登录
图2.6 登录成功
2.输入payload： &lt;script&gt;alert('xss')&lt;/script&gt;。
图2.7 返回结果
3.以POST形式提交，URL中不会显示参数内容，所以我们不能把恶意代码嵌入URL中，我们先进行抓包。
图2.8 进行抓包
4.右键-&gt;Engagement Tools-&gt;Generate CSRF Poc，复制这段代码到记事本，命名为xss.html。
图2.9 查看代码
5.当我们点开这个网址，点击按钮。
图2.10 点击按钮
6.测验成功！
图2.11 成功
存储型XSS 1.存储型的XSS与反射型的XSS一样，但它是将脚本存在了后台储存起来，构成更持久的危害，也称为永久性xss。
2.在留言框中输入进行留言。
图3.1 进行留言
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79685f8ea39d90b0d7eacfec11b801d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283c8d9c1cdd8f6647cfb3475643d095/" rel="bookmark">
			windows密码获取凭证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，Windows HASH
hash
windows HASH简介
二，Windows认证基础
Windows本地认证
LM-HASH
LM-HASH简介
LM-HASH生成原理
Mysql数据库密码破解
1. MYSQL数据库文件类型
2. Mysql加密方式
一，Windows HASH hash Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
windows HASH简介 Windows 加密过的密码口令，我们称之为 hash
Windows 系统使用两种方法对用户的密码进行哈希处理，它们分别是 LAN Manager（LM） 哈希和 NT
LAN Manager（NTLM） 哈希。
现在已经有了更新的 NTLMv2 以及 Kerberos 验证体系。
二，Windows认证基础 Windows的认证包括三个部分：
本地认证：用户直接操作计算机登录账户
网络认证：远程连接到工作组中的某个设备
域认证：登陆到域环境中的某个设备
Windows本地认证 用户输入密码系统收到密码后将用户输入的密码计算成NTLM Hash与sam数据库（%SystemRoot%\system32\config\sam）中该用户的哈希比对匹配则登陆成功，不匹配则登陆失败 Windows本地认证采用sam hash比对的形式来判断用户密码是否正确，计算机本地用户的所有密码被加密存储在%SystemRoot%\system32\config\sam文件中，当我们登录系统的时候,系统会自动地读取SAM文件中的“密码”与我们输入的密码进行比对，如果相同，证明认证成功.
LM-HASH LM-HASH简介 LAN Manager（LM）哈希是Windows系统所用的第一种密码哈希算法，是一种较古老的Hash，在LAN
Manager协议中使用，非常容易通过暴力破解获取明文凭据。
它只有唯一一个版本且一直用到了 NT LAN Manager（NTLM） 哈希的出现，
在 Windows XP / Windows Server 2003 之前， 它是Windows上占主导地位的密码存储算法。
从 Windows Vista / Windows Server 2008 开始，默认情况下已禁用该算法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/283c8d9c1cdd8f6647cfb3475643d095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/598fc0596fada19a6c22238a2e490f58/" rel="bookmark">
			用HTML写一段表白代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你好！
如果你想用 HTML 写一段表白代码，可以这样写：
&lt;div&gt; &lt;p&gt;亲爱的，&lt;/p&gt; &lt;p&gt;我一直都在你身边，看着你成长，看着你变得越来越美。我想对你说，我喜欢你。&lt;/p&gt; &lt;p&gt;我知道，我不是你最理想的对象，但是我会努力变得更好，成为你能够依靠的人。&lt;/p&gt; &lt;p&gt;希望你能给我一个机会，让我好好爱你。&lt;/p&gt; &lt;p&gt;爱你的，&lt;/p&gt; &lt;p&gt;[你的名字]&lt;/p&gt; &lt;/div&gt; 这段代码会在网页上显示一段表白的文字。你可以自己修改文字内容，让它更加真挚和个性化。
希望这能帮到你！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409e35d9f1fdaa206174b5a342a3c856/" rel="bookmark">
			Ubuntu&#43;Qt下配置车牌识别系统EasyPR1.6环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.将EasyPR_v1.6.zip拷贝到虚拟机Ubuntu中 最好是在opt文件夹中 ，可使用
VMware tools
共享文件夹
远程连接工具
2.解压得到EasyPR文件夹 修改文件权限
chmod -R 777 EasyPR 3.查找/opt/EasyPR/include/easypr/config.h中 这边告诉我们，如果opencv版本超过3.2以上可以使用CV_VERSION_THREE_TWO
所以把该文件开头的宏定义CV_VERSION_THREE_ZERO的ZERO改为TWO
4.在EasyPR下执行./build.sh 当100%时会生成一个demo文件，然后执行./demo就可以使用了
测试一下车牌检测
测试成功可以运行，接下来可以在Qt中配置环境
5. 创建Qt工程修改pro文件 添加OpenCV环境配置添加EasyPR 环境配置 为什么不直接使用EasyPR配置好的依赖库文件呢，经过实测在Ubuntu的Qt中是运行不了的，所以只能手动添加
1.在pro中添加cpp文件： /opt/EasyPR/src/core/chars_identify.cpp \ /opt/EasyPR/src/core/chars_recognise.cpp \ /opt/EasyPR/src/core/chars_segment.cpp \ /opt/EasyPR/src/core/core_func.cpp \ /opt/EasyPR/src/core/feature.cpp \ /opt/EasyPR/src/core/params.cpp \ /opt/EasyPR/src/core/plate_detect.cpp \ /opt/EasyPR/src/core/plate_judge.cpp \ /opt/EasyPR/src/core/plate_locate.cpp \ /opt/EasyPR/src/core/plate_recognize.cpp \ /opt/EasyPR/src/train/ann_train.cpp \ /opt/EasyPR/src/train/annCh_train.cpp \ /opt/EasyPR/src/train/create_data.cpp \ /opt/EasyPR/src/train/svm_train.cpp \ /opt/EasyPR/src/train/train.cpp \ /opt/EasyPR/src/util/kv.cpp \ /opt/EasyPR/src/util/program_options.cpp \ /opt/EasyPR/src/util/util.cpp \ /opt/EasyPR/thirdparty/LBP/helper.cpp \ /opt/EasyPR/thirdparty/LBP/lbp.cpp \ /opt/EasyPR/thirdparty/mser/mser2.cpp \ /opt/EasyPR/thirdparty/svm/corrected_svm.cpp \ /opt/EasyPR/thirdparty/textDetect/erfilter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409e35d9f1fdaa206174b5a342a3c856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/739f81f0d96e03bdbe0911451777e1b1/" rel="bookmark">
			【FFmpeg&#43;Qt】视频进度条控制——点击跳转和拖动跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先进度条采用Qslider，设置进度条主要有两点，一是当前视频总时长，二是当前播放时长，需要通过FFmpeg转码成mp4文件才能获取相应的时长数据；
往期回顾：
【Qt+FFmpeg】视频转码详细流程_logani的博客-CSDN博客_qt+ffmpeg视频流
【Qt+FFmpeg】编码视频详细流程_logani的博客-CSDN博客_qt 视频编码
【Qt+FFmpeg】解码播放本地视频（一）_logani的博客-CSDN博客_ffmpeg 打开本地视频
1.获取视频总时长
视频时长就封装在 AVFormatContext *formatContext 编解码上下文环境结构体的 duration 结构体成员中 ;AVFormatContext 中提取的 duration获取总视频总时长，单位是微秒；
2.获取当前时长：
AVFrame 结构体中封装的 best_effort_timestamp 元素值，就是当前视频帧的相对播放时间，其单位是AVRational，需要转换成秒，可以用视频流中提供的时间基
3.进行拖动跳转
在知道如何做之前，我们要先了解Qslider的几个信号，我们拖动时就需要用到点击、滑动和释放信号：
1.移动滑动条时发出的信号
void sliderMove(int value);
2.点击滑动条时所发出的信号
void sliderPressed();
3.释放时所发出的信号
void sliderReleased();
拖动跳转主要用到滑动信号和释放信号； 调用av_seek_frame函数查找进度条点击或拖动位置的帧数并跳转到该帧开始播放 ;
由于上述的播放时间已转成了秒为单位，所以这边将传入的秒转为微秒 av_seek_frame ( ) 函数原型 : 查找第 stream_index 个媒体流的 timestamp 微秒附近的关键帧 , 并跳转到该帧开始播放 ;
① AVFormatContext **ps 参数 : 封装了文件格式相关信息的结构体 , 如视频宽高 , 音频采样率等信息 ; 该参数是 二级指针 , 意味着在方法中会修改该指针的指向 , 该参数的实际作用是当做返回值用的 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/739f81f0d96e03bdbe0911451777e1b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f927952059ce9f2c8d580f681ba528c/" rel="bookmark">
			【bat批处理】手把手教你批量打开软件、文件、网页等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【bat批处理】打开软件、文件等 0- 前言1- start 命令用法1.0 注释1.1 start 命令说明1.2 启动软件1.3 打开文件1.4 打开文件夹1.5 打开网页 2-实战2.0 怎么创建bat批处理文件2.1 打开软件、文件、网页2.2 微信多开2.3 定时关机2.4 取消定时关机2.5 显示桌面图标 3 小结 0- 前言 有时候干一件事，总是要固定打开一些 软件、文档，时间长了就感觉麻烦
比如学个linux，得开网页、开word、开VM、开xshell
1- start 命令用法 1.0 注释 :: 两个冒号，给自己看的 :: 不写注释的话，三天后我也不知道写的啥 1.1 start 命令说明 格式1
start 要用什么软件启动(放空即用默认软件打开) 路径
格式2
start 路径
:: ---格式1--- :: 解释：使用 默认软件(这里未指定软件即默认) 打开"D:\HN\桌面\MySQL\MySQL.docx"文件 start "" "D:\HN\桌面\MySQL\MySQL.docx" :: ---格式2--- start "D:\HN\桌面\MySQL\MySQL.docx" 解释
start : 启动
“” : 想用什么软件打开，放空即用默认软件打开，也可以不写
路径：“D:\HN\桌面\MySQL\MySQL.docx”
1.2 启动软件 :: 启动数据库 start C:\"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f927952059ce9f2c8d580f681ba528c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38f6ad941a5a4dbb6286001018e64a1b/" rel="bookmark">
			Anaconda国内镜像源配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用Anaconda进行一些框架等安装时，如果使用默认的源地址下载很慢，更换到国内的镜像地址就很快，我这里记录下方便更换主机或者服务器的时候使用。这里可以看到清华大学对于Anaconda镜像的使用帮助。
一、你需要一个Anaconda 官方下载地址
清华大学地址
二、使用命令配置镜像源 Windows和Linux 对于conda修改镜像源的方法一样。Windows下安装好后在开始菜单打开 Anaconda prompt 输入命令。
1.查看已经存在的镜像源 conda config --show channels 2.添加清华大学镜像源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch Anaconda 仓库与第三方源（conda-forge、msys2、pytorch等）的镜像，各系统都可以通过修改用户目录下的 .condarc 文件。Windows 用户无法直接创建名为 .condarc 的文件，可先执行 conda config --set show_channel_urls yes 生成该文件之后再修改。
3.设置搜索时显示通道地址 conda config --set show_channel_urls yes 4.删除已经存在的镜像源 conda config --remove-key channels 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004e7fffa8d1b0ffaa5d13fae3d8dbf8/" rel="bookmark">
			Vue使用md5加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在登陆注册的业务中，往往需要对密码进行加密，用加密后的字符串发送给后端，如何在项目中使用md5加密呢
首先先npm来安装md5插件
npm install --save js-md5 然后在main.js中引入，并挂载到Vue的prototype上
// 引入md5加密 import md5 from 'js-md5'; Vue.prototype.$md5 = md5; 在代码中使用
var data = { phone: this.loginPhone, password: this.$md5(this.loginPassword) } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/84/">«</a>
	<span class="pagination__item pagination__item--current">85/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/86/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>