<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e001107f17f054ece2cbfadaa2834260/" rel="bookmark">
			*javascript:使用对象保存数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;title&gt;使用对象保存数据&lt;/title&gt; &lt;body&gt; &lt;!-- 代码放在body中，可运行 --&gt; &lt;script type="text/javascript"&gt; //自定义名片对象 function Card(name,address,telephone,work){ this.na=name; this.ad=address; this.tel=telephone; this.wo=work; this.printCard(); } //扩展对象Card的printCard()方法 Card.prototype={ printCard:function(){ line1="&lt;b&gt;Name:&lt;/b&gt;"+this.na+"&lt;br&gt;\n"; line2="&lt;b&gt;Address:&lt;/b&gt;"+this.ad+"&lt;br&gt;\n"; line3="&lt;b&gt;Telephone:&lt;/b&gt;"+this.tel+"&lt;br&gt;\n"; line4="&lt;b&gt;Work:&lt;/b&gt;"+this.wo+"&lt;br&gt;\n"; document.write(line1,line2,line3,line4); } } //测试 //创建Card对象 allen=new Card("吴冠中","中国广东省广州市","15626299383","著名画家"); &lt;/script&gt; &lt;/body&gt; 结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b3e9e1b2fcda6e51480f3083e59e5c/" rel="bookmark">
			*Http详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#1. HTTP简介
HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。
#2. 计算机相互之间的通信
互联网的关键技术就是TCP/IP协议。两台计算机之间的通信是通过TCP/IP协议在因特网上进行的。
IP：计算机之间的通信 ###TCP : 应用程序之间的通信
#3.HTTP请求响应模型
HTTP是一个无状态的协议。无状态是指客户机（Web浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。
#4. HTTP工作过程
####1 ) 、地址解析
如用客户端浏览器请求这个页面：http://localhost.com:8080/index.htm
从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：
协议名：http
主机名：localhost.com
端口：8080
对象路径：/index.htm
在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。
####2）、封装HTTP请求数据包
把以上部分结合本机自己的信息，封装成一个HTTP请求数据包
####3）封装成TCP包，建立TCP连接（TCP的三次握手）
在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议。
根据规则，只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口。
4）客户机发送请求命令 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。 ####5）服务器响应
服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。
实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据
####6）服务器关闭TCP连接
一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码
Connection:keep-alive
TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。
#5.HTTP协议栈中各层数据流
首先我们看看客户端请求的时候，数据在各层协议的数据组织如下图： ####更多知识请点击这里。。。。。。。。。。。。。。。。。。。。。
##请求：
##响应
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a5725c8ee71ecdf4163ee8ef75bc7f/" rel="bookmark">
			记录一次Vue2迁移Vue3的基本流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现有一个基于vue-cli2的项目（不支持ES新语法，使用ElementUI组件库），目前vue-cli已经迭代到4版本，且已经处于维护模式；vue2在2023年底终止支持，vue2.7是最后一个版本。所以打算即升级现有项目至vue3（使用ElementPlus组件库）。
技术分析 GoGoCode是一个由阿里妈妈开源的基于 AST 的 JavaScript/Typescript/HTML 代码转换工具，通过分析词法分析、语法分析、语义分析等，直接编译Vue2代码至Vue3。
根据GoGoCode文档介绍，目前 GoGoCode 仅支持新版本 vue-cli ，对于 vue-cli2 的项目不能进行编译处理，所以处理思路就是：
vue-cli2 ---(手动复制文件并解决错误)---&gt; vue-cli4 ---(使用gogocode编译)---&gt; Vue3 根据GoGoCode官网给出文档vue-cli2的项目升级到vue-cli4做了哪些事情手动复制文件升级至vue-cli4，根据Vue2 到 Vue3 升级指南及Element UI 到 Element Plus 升级指南升级至Vue3
主要流程 升级vue-cli2至vue-cli4 流程 拿到源码新建分支vuecli4，在vuecli4分支使用 vue create 命令新建一个vuecli4的空项目（必须是vuecli4的项目），把vuecli2项目中的 src 源码目录及 index.html 模版复制到vuecli4项目中直接运行项目，根据报错提示进行反复重启（安装依赖、webpack配置、eslint配置等） 期间遇到的问题 Cant’t resolve ‘xxxx’ in filename
直接安装相应依赖，再次运行项目（使用less需要同时安装less和less-loader、）
error in ./node/modules/stompjs.js Cant’t resolve ‘net’
直接安装 net 依赖模块，参考：https://www.cnblogs.com/sphjy/p/15500806.html
eslint问题：Parsing error: ‘import’ and ‘export’ may appear only with ‘sourceType: module’
// 要添加eslint配置，不限制import使用位置 module.exports = { root: true, env: { node: true, }, extends: [], rules: {}, parser: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14a5725c8ee71ecdf4163ee8ef75bc7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b08bbf1539c37b2766fe0fba008f983f/" rel="bookmark">
			用Python写的自动答题脚本，正确率99%，刷课必备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		咱们上学的时候，有些课程，不是很重要所以没去看，但是又要刷题，这时候，自动答题脚本就很关键，全程全自动，正确率还嘎嘎高！
所以咱们今天来用Python写一个自动答题脚本，正确率99%！
话不多说直接开始
准备工作 使用的环境
Python 3.10 解释器Pycharm 编辑器 模块使用
from selenium import webdriver —&gt; 自动测试模块 第三方模块需要手动安装， pip install selenium==3.141.0 &lt;指定版本安装&gt;
selenium是自动化测试模块，模拟人的行为去操作浏览器 &lt;网页自动化操作&gt;
搭配对应浏览器和浏览器驱动去使用
本次用到的浏览器是谷歌浏览器，大家需要下载谷歌驱动，浏览器是什么版本，驱动就下载什么版本的，下载好后解压文件将 chromedriver.exe 文件放到python安装目录下面即可。
驱动下载地址：谷歌驱动下载
本次目标地址：目标地址
答题流程操作
打开浏览器访问答题网页读题进行答案选择提交试卷 答题网站: 首先得有题库
单选多选随机抽取题目 代码展示
打开浏览器访问网站
driver = webdriver.Chrome() url = 'https://www.***网址屏了*不过审*.com/kmy-mnks' driver.get(url) driver.implicitly_wait(10) 通过元素定位: 获取答案 / 进行答题操作
lis = driver.find_elements_by_css_selector('.Content li') for li in lis: answer = li.get_attribute('k') if answer == 'E': answer = '错误' elif answer == 'R': answer = '正确' bs = li.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b08bbf1539c37b2766fe0fba008f983f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc8ef5ee72d731326e6bc713c4c64de/" rel="bookmark">
			【腾讯云HAI】都2023年了，HAI没玩过AIGC？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		:::info
腾讯云高性能应用服务(Hyper Application lnventor，HA)，是一款面向 Al、科学计算的 GPU 应用服务产品，为开发者量身打造的澎湃算力平台。无需复杂配置，便可享受即开即用的GPU云服务体验。在 HA] 中，根据应用智能匹配并推选出最适合的 GPU 算力资源，以确保您在数据科学、LLM、AI作画等高性能应用中获得最佳性价比此外，HAI的一键部署特性让您可以在短短几分钟内构建如 StableDifusion、ChatGLM 等热门模型的应用环境。而对于 Al 研究者，我们的直观图形界面大大降低了调试的复杂度，支持jupyterlab、webui 等多种连接方式，助您轻松探索与创新。现在，只需打开浏览器，HAI 便为您打开了一片无限可能的高性能应用领域。
:::
活动简介 本次活动是由腾讯云和CSDN联合推出的开发者技术实践活动。我们将通过技术交流直播、动手实验、有奖征文等形式，带您深入沉浸式体验腾讯云高性能应用服务 HAI 。活动将覆盖多个应用场景，无论您是技术新手还是经验丰富的开发者，我们相信您都会从活动中汲取到技术上的精华。在本次活动中，只要完成各个环节任务，您不仅可以参与AIGC创作抽奖、优秀博文的评选，还可以获取相应的积分，参加最终的积分排行榜。小米13系列手机、大疆D川机甲大师编程机器人、Apple iPad 9、OPPO Watch3运动手表、惠尔顿净水器加热直饮一体机、小米Redmi投影仪2、小米(M)智能积木猎户座六足泰坦、戴森V8 Fluffy Plus吸尘器 等大牌礼品等你来拿！
活动详情介绍：https://marketing.csdn.net/p/b18dedb1166a0d94583db1877e49b039
活动报名页面：https://jinshuju.net/f/dHxwJ7?x_field_1=maktHAI
产品体验地址：https://cloud.tencent.com/act/pro/hai
控制台预览 **腾讯云HAI控制台： **https://console.cloud.tencent.com/hai
动手实践 在动手实践环节，其实官方有准备三个实验手册，分别是
使用HAI创建Stable Diffusion环境，TXT2Image图生文使用HAI创建ChatGLM2 6B环境，直接与AI对话，然后通过腾讯云Cloud Studio上面直接部署精美的前端页面，直接调用HAI这边部署好的API接口使用HAI创建PyTorch环境，使用官方案例对 第一个实验手册：如何利用HAI轻松拿捏AI作画 https://csdn-res-1253910586.cos.ap-nanjing.myqcloud.com/HAI-AIGC.html 第二个实验手册：未来对话：HAI创作个人专属的知识宇宙 https://csdn-res-1253910586.cos.ap-nanjing.myqcloud.com/HAI-ChatGLM2.html 第三个实验手册：融合创新：HAI推动Pytorch2.0 AI框架新时代 https://csdn-res-1253910586.cos.ap-nanjing.myqcloud.com/HAI-Pytorch2.0.html 特别提醒完成【实验如何利用HAI轻松拿捏AI作画】时，可以利用本次实验搭建的环境参与AIGC创作。 本次博文要演示的是如何使用腾讯云高性能计算服务HAI创作视频，也就是文生视频的样子，这里我们会使用HAI创建Stable Diffusion环境，在其基础上安装一些插件实现文字生成视频
前置需求 启用学术加速
文字出视频：Deforum Deforum插件是一种基于stable diffusion的动画生成工具，它可以根据文本描述或参考视频生成连续的图像序列，并将它们拼接成视频。Deforum插件使用了一种叫做image-to-image function的技术，它可以对图像帧进行微小的变换，并用stable diffusion生成下一帧。由于帧之间的变化很小，因此会产生连续视频的感觉。
安装拓展 首先修改下pip源
mkdir -p ~/.config/pip vi ~/.config/pip/pip.conf # 填充如下内容 [global] trusted-host=mirrors.cloud.tencent.com index-url = https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dc8ef5ee72d731326e6bc713c4c64de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a07d914f49ec01e9d0a6d75bd5cf3f/" rel="bookmark">
			node.js 常用fs文件系统和path路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		__dirname： 获得当前执行文件所在目录的完整目录名
__filename： 获得当前执行文件的带有完整绝对路径的文件名
process.cwd()：获得当前执行node命令时候的文件夹目录名
path.join：使用特定于平台的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。 path.join(__dirname, 'test.json')
path.basename(path)：提取文件名
fs.exists(path)：判断是否存在文件（不推荐已弃用）
fs.accessSync(path)：判断是否存在文件，没有文件会将抛出 Error
fs.copyFileSync(path，newpath)：复制文件
fs.unlinkSync(path)：删除文件
fs.readFile()：读取文件内容
fs.readFile(path, 'utf8',(err,data)=&gt;{
if (err) throw err;
console.log('读取内容',data);
})
注意，如果不加 'utf8'（未指定编码），则返回原始缓冲区。
fs.writeFileSync()：写入文件
fs.writeFileSync(newPath, JSON.stringify({name:'chen}), 'utf8');
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48896e1faa336a5e1f5eff5cbd88f7e2/" rel="bookmark">
			Anaconda（4.2.0）和Tensorflow（2.9.1）安装教程（使用中科大镜像，清华镜像没有tensorflow了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Anaconda安装
1、搜索清华镜像（网址：https://mirrors.tuna.tsinghua.edu.cn/）
2、找到anaconda并选择版本（我选择的版本是4.2.0的window64位版本）
3、安装包下载完后根据提示就能成功安装Anaconda了。
二、Tensorflow的安装
1、先看一下python版本：
2、使用pip安装，网上的用conda的命令安装我也没有成功。
3、查看tensorflow是否安装成功.
我在安装tensorflow的过程中总是遇到了很多问题，报错也不知道原因，在摸索下最后还是成功安装了tensorflow环境。仅供参考，希望对读者有用，毕竟深知安装过程之痛苦，我好几天去网上找安装方法都没有成功。
以下是我的安装过程，希望能够让你成功安装。
一、Anaconda安装 由于官网下载速度缓慢并且我觉得复杂，对于Anaconda我选择使用清华镜像下载。目前仍可以通过清华镜像下载Anaconda，但是我不能成功下载tensorflow。
1、搜索清华镜像（网址：https://mirrors.tuna.tsinghua.edu.cn/） 2、找到anaconda并选择版本（我选择的版本是4.2.0的window64位版本） 我选择的版本比较老，你也可以选择新版的，但是后续tensorflow安装过程出现错误那我也不知道为什么了。因为我们电脑里安装的python版本可能过高，tensorflow版本太低就不能支持，挺麻烦的。目前按照我的方法pyhton版本3.8.5的可以安装tensorflow。
3、安装包下载完后根据提示就能成功安装Anaconda了。 anaconda的安装挺简单的，基本上正常都不会有问题。
二、Tensorflow的安装 Tensorflow的安装过程经常有些莫名其妙的问题。最重要的是我搜索tensorflow的安装过程网上大部分都是通过清华镜像网站下载，问题是现在清华镜像好像不支持Tensorflow的下载了，所以我使用其他镜像网站。Tensorflow官网的下载也有教程，不过我总是失败了。
1、先看一下python版本： 打开电脑命令提示符，输入：
pyhton --version 我的python版本是3.8.5。
2、使用pip安装，网上的用conda的命令安装我也没有成功。 pip的安装和升级教程去百度一下看看吧。
我使用的是中国科学技术大学的镜像源来代替清华镜像（因为清华镜像没有tensorflow了）
在命令提示符里输入：
pip3 install -i https://pypi.mirrors.ustc.edu.cn/simple/ --upgrade tensorflow 其他镜像源网址如下：（替换网址就行）
清华镜像：https://mirrors.tuna.tsinghua.edu.cn/
中国科学技术大学：https://pypi.mirrors.ustc.edu.cn/
阿里云镜像：https://developer.aliyun.com/mirror/
等待之后tensorflow应该就安装好了，因为确实是过了一段时间了，当时遇到的安装问题忘了一些，如果这样还没有安装成功可以评论留言，或者移步别人的博客，因为我也是误打误撞的。
3、查看tensorflow是否安装成功. 打开命令提示符，输入：
jupyter notebook 需要先安装Anaconda，回车后会进入jupyter。
创建新的notebook并在命令格中输入：
import tensorflow as tf tf.__version__ 回车后，如果tensorflow安装成功会显示出它的版本，如果失败了就会提示找不到tensorflow。
肯定有很多人无法下载成功，那就只能多找找别人的方法了，我这也是误打误撞的，希望能够让你安装成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d80a58caa73e3df6d0631f801746b8c/" rel="bookmark">
			qt实现播放视屏的时候，加载外挂字幕(.srt文件解析)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前用qt写了一个在windows下播放视频的软件，具体介绍参见qt编写的视频播放器，windows下使用，精致小巧_GreenHandBruce的博客-CSDN博客
后来发现有些视频没有内嵌字幕，需要外挂字幕，这时候，我就想着把加载外挂字幕的功能加上。如下图：
这里先做了解析.srt字幕文件的功能。具体实现如下
1.先在窗口放一个label，将label调整到界面底部，设置字体，颜色
//显示字幕用的label; labelSubTitle = new myLabel(this); // labelSubTitle-&gt;setText("这里显示字幕文件"); QFont font("微软雅黑",15,QFont::Bold); QPalette palette = labelSubTitle-&gt;palette(); palette.setColor(QPalette::WindowText,Qt::white); labelSubTitle-&gt;setPalette(palette); labelSubTitle-&gt;setFont(font); labelSubTitle-&gt;setAlignment(Qt::AlignCenter); 2.在打开视频文件的时候找到同文件夹下的.srt文件
int nIndex = fileName.lastIndexOf('.');//寻找‘.’符号在字符串中的id nIndex++; QString srtfile =fileName.mid(0,nIndex); //截取‘.’符号后面的字符串，这是为了获取文件后缀名 srtfile +="srt"; EncodingFormat code = FileCharacterEncoding(srtfile); QFile file(srtfile); if(!file.open(QIODevice::ReadOnly)) { qDebug()&lt;&lt;"未找到外挂字幕文件："&lt;&lt;srtfile&lt;&lt;endl; } 3.解析.srt文件，先看一下.srt字幕文件格式如下：
然后写个结构体用来存放解析之后的srt内容，如下：
struct SrtInfo { qint16 Num; QTime dtStart; QTime dtEnd; QString strSubTitle; }; 然后解析，在解析的时候要注意.srt的编码格式，（编码格式这块参见我上一篇文章qt按照不同编码格式读取文字(UTF-16LE,UTF-8,UTF-8BOM,UTF-16BE)-CSDN博客）
void VideoPlayer::ParseSubTitle(QString fileName) { int nIndex = fileName.lastIndexOf('.');//寻找‘.’符号在字符串中的id nIndex++; QString srtfile =fileName.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d80a58caa73e3df6d0631f801746b8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/487171f0aab3ebdd7816cc1a1d671e10/" rel="bookmark">
			SQL 常见函数整理 _ DATEPART() 从日期时间表达式中提取指定的日期部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 用法
用于从日期时间表达式中提取指定的日期部分。
2. 语法
DATEPART (datepart, date) 3. 应用示例
--示例 SELECT DATEPART(datepart,'2020-5-20 13:14:32.1234567 +05:10') datepart缩写形式返回值yearyy,yyyy2020quarterqq,q2monthmm,m5dayofyeardy,y141daydd,d20weekSQL Server ： wk,ww MySQL ：w Oracle ： wk21weekdaydw4hourhh13minuten14secondss,s32millisecondms123microsecondmcs123456nanosecondns3456700tzoffsettz310iso_weekisowk,isoww21 注意：
① 当DATEPART ( weekday, date ) 的值等于1或者7时，是周末。
--返回值： 1 SELECT DATEPART(weekday,'2023-10-08 13:14:32.1234567 +05:10') ② 分钟的简写是n ,Month 的缩写是mm,这和format 函数的应用要区别开来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e5c45790bdd6c641466bac167cb80c5/" rel="bookmark">
			PhpStudy下载安装使用教程，图文教程（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PhpStudy 一、官网下载二、安装三、简单使用 PhpStudy：让天下没有难配的服务器环境。
学习网络安全经常需要搭建各种各样的Web环境，而PphStudy（简称“小皮”）可以一键搭建环境，节省下载、配置环境的时间。
一、官网下载 1）访问PhpStudy官网：https://www.xp.cn/
2）【首页】选择Windows版。
3）跳转到新页面，点立即下载。
3）弹出确认窗口，点击64位下载（大部分都是64位，如果你的是32位，就选32位下载）
4）下载完成，是一个压缩包
二、安装 1）解压后，点进去，双击exe安装程序，开始安装（注意安装路径不要包含中文或空格）。
2）弹出安装界面，点击立即安装（点右下角可以选择安装路径）。
提示：这一步如果报错（无报错请往下滑），安装向导无法创建文件夹“D:\phpstudy_pro” ，可能是你的电脑没有D盘（PhpStudy默认安装路径是D盘），重新运行安装程序，手动选择安装路径即可。
3）等待安装完成即可。
三、简单使用 1）【首页】显示下小皮自带的工具，红色表示未启动，这里我们启动一个Apache。
2）打开浏览器，访问 localhost，访问成功。
3）【网站】这一栏，可以看到Web目录。
4）把网站文件拖到WWW目录下，输入路径，就能访问了。
读者福利：知道你对网络安全感兴趣，便准备了这套网络安全的学习资料
对于0基础小白入门：
如果你是零基础小白，想快速入门网络安全是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以找到适合自己的学习方案
包括： 网络渗透、逆向分析、漏洞攻击、内核安全、移动安全、破解PWN等众多子方向。 带你从零基础系统性的学好网络安全！
👉网安学习成长路线图、网安视频合集👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉精品网安学习书籍👈 当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
👉网络安全源码合集+工具包👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉CTF项目实战👈 学习网安技术最忌讳纸上谈兵，而在项目实战中，既能学习又能获得报酬的CTF比赛无疑是最好的试金石！
👉网络安全面试题板块👈 这份完整版的学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
👉[[[CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源》免费分享]]]（安全链接，放心点击）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cadcfe37279007966782e992a90e9e2/" rel="bookmark">
			PyTorch基本操作和工作流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. PyTorch基础 张量（Tensors）： 学习 PyTorch 中表示数据的基本单元。了解如何创建、操作和使用张量。
自动微分（Autograd）： 了解 PyTorch 的自动微分机制，这是训练神经网络的核心。
模型定义和训练： 学习如何使用 PyTorch 定义神经网络模型、损失函数和优化器，并进行训练。
2. 数据处理和加载 数据加载器（DataLoader）： 了解如何使用 DataLoader 加载训练和测试数据。
数据预处理： 学习对数据进行预处理的常见方法，如变换、标准化等。
3. 模型保存和加载 模型保存和加载： 学会如何保存和加载 PyTorch 模型的权重。
模型转换（Model Conversion）： 了解如何将 PyTorch 模型转换为其他格式，以便在不同平台上部署。
4. 调试和可视化 调试工具： 掌握使用 PyTorch 的调试工具，如打印、调试器等。
可视化工具： 了解如何使用 TensorBoard 或其他可视化工具来监视训练过程。
5. PyTorch生态系统 Torchvision： 学习使用 Torchvision 进行计算机视觉任务的常见操作。
Transforms： 了解如何使用 PyTorch 的 Transforms 进行数据增强。
学习更多： PyTorch官方文档Fast.ai深度学习教程 在学习过程中，通过动手实践，尝试构建和训练简单的神经网络，熟悉 PyTorch 的基本操作和工作流程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c34a0446f3e9dacad5f3786b6c3d6fd3/" rel="bookmark">
			Spring框架学习 -- 读取和存储Bean对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 🚀🚀
回顾
getBean()方法的使用 根据name来获取对象
再谈getBean()
(1) 配置扫描路径
(2) 添加注解
① spring注解简介 ② 对类注解的使用
③ 注解Bean对象的命名问题
④ 方法加Bean注解
(3) @Bean 注解的重命名
(4) 获取Bean对象 -- 对象装配 属性注入
属性注入优缺点
setter注入 setter注入优缺点
构造方法注入 (官方推荐)
构造方法优缺点
(5) 另外一种注入关键字: @Resource
(6) 同一个变量多个@Bean注入报错
总结 😍创作不易多多支持🫡 回顾 回忆一下我们之前是如何存储和使用Bean对象的, 首先我们需要在spring配置文件写入Bean对象, 或者说是spring容器中注入Bean对象:
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="user1" class="org.example.User"&gt;&lt;/bean&gt; &lt;bean id="user2" class="org.example.User"&gt;&lt;/bean&gt; &lt;/beans&gt; 然后在启动类中new出一个上下文对象, 要么使用BeanFactory, 要么使用ApplicationContext, 然后调用上下文对象中的getBean方法, 来获取到对应的Bean对象. 但是我每次使用都要去在spring配置文件中写入bean标签, 然后写上对应id和类. 这些步骤过于繁琐, 于是spring的作者就创造出了一种更简单的方式, 那就是直接在对应的类下面写上注解, 注解中填入id, 就省去了写路径的痛苦.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c34a0446f3e9dacad5f3786b6c3d6fd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a4983190540506f1d1142c467ea1e0/" rel="bookmark">
			qt按照不同编码格式读取文字(UTF-16LE,UTF-8,UTF-8BOM,UTF-16BE)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		enum class EncodingFormat : int { ANSI = 0,//GBK UTF16LE, UTF16BE, UTF8, UTF8BOM, }; EncodingFormat VideoPlayer::FileCharacterEncoding(const QString &amp;fileName) { //假定默认编码utf8 EncodingFormat code = EncodingFormat::UTF8; QFile file(fileName); if (file.open(QIODevice::ReadOnly)) { //读取3字节用于判断 QByteArray buffer = file.read(3); quint8 sz1st = buffer.at(0); quint8 sz2nd = buffer.at(1); quint8 sz3rd = buffer.at(2); if (sz1st == 0xFF &amp;&amp; sz2nd == 0xFE) { code = EncodingFormat::UTF16LE; } else if (sz1st == 0xFE &amp;&amp; sz2nd == 0xFF) { code = EncodingFormat::UTF16BE; } else if (sz1st == 0xEF &amp;&amp; sz2nd == 0xBB &amp;&amp; sz3rd == 0xBF) { code = EncodingFormat::UTF8BOM; } else { //尝试用utf8转换,如果无效字符数大于0,则表示是ansi编码 QTextCodec::ConverterState cs; QTextCodec* tc = QTextCodec::codecForName("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14a4983190540506f1d1142c467ea1e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df8510d95943e8fe8e8b512db8fc9775/" rel="bookmark">
			Linux虚拟机安装和开发环境配置(Ubuntu 22.04)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对于高性能的服务器开发，Linux系统是必不可少的，本篇文章就从最基本的Linux虚拟机安装和开发环境配置，让初学Linux系统的大佬们，来熟悉一下Linux环境
制作Linux虚拟机(Ubuntu 22.04) 下载镜像 官网下载Ubuntu的镜像
https://ubuntu.com/download/desktop
LTS为Long Time Support长时间支持的意思
下载好后，就需要用VMware来创建Linux虚拟机
制作虚拟机 打开VM→点击文件选择新建虚拟机
点击下一步（使用默认的）
选择Linux镜像文件
设置虚拟机的用户名和密码
选择虚拟机位置
设置虚拟磁盘，尽量大点，选择单个文件
虚拟机配置：4G运行、4个内核、磁盘100G
安装中
安装完成
打开Linux命令行窗口 桌面鼠标右键→选择Open in Terminal打开命令行窗口
设置root密码 root用户的密码可以用sudo passwd来设置，首先需要知道当前用户的密码
解决虚拟机安装好后无网问题 首先ping一下www.baidu.com判断虚拟机是否与外界连通
如果不能ping通百度的地址，首先输入ifconfig命令查看网络是否配置（ifconfig命令在Ubuntu虚拟机上可能没有默认安装）。直接输入sudo dhclient '网卡名'（默认网卡名为ens33）命令让虚拟机自动配置网络。
ens33表示虚拟机上的虚拟网卡，在你的虚拟机上可能不叫这个名字，那就把上面命令的ens33换成你对应的网卡名字。
等待虚拟机配置好后，再次输入命令ping www.baidu.com，如果还是ping不通那就只能重置VM的网卡配置了
重置VM虚拟网卡设置 首先先关闭Ubuntu虚拟机，点击编辑选择虚拟网络编辑器→点击更改设置→选择还原默认设置
等待还原配置完成点击确定，再次启动Ubuntu虚拟机重新输入sudo dhclient '网卡名'（默认网卡名为ens33）命令等待配置完成就好使了。
修改下载源 由于下载源的问题，下载速度非常慢，所以要修改一下下载源
注意：在Ubuntu20大版本以后就不需要修改下载源了，国内的下载速度已经是正常的网速了
首先把/etc/apt/sources.list修改为全有写的权限
指令：chmod 666 sources.list修改文件权限
之后就可以用Text Editor软件修改文件
访问清华镜像站获取下载源（个人感觉这个比较好用，可以自己选择）
清华大学开源软件镜像站 | Tsinghua Open Source Mirror
点击第一个，然后目录往下翻找到Ubuntu
修改为提供的下载源，点击保存
修改后用sudo apt-get update指令更新源列表
安装net-tools Linux下非常好用的工具集，比如ifconfig命令
安装指令：sudo apt install net-tools
未安装：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df8510d95943e8fe8e8b512db8fc9775/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b086063f60c7e6210181d89258b8ded/" rel="bookmark">
			网络唤醒原理浅析(Wake On LAN)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 将唤醒魔术包发送的被唤醒机器的网卡上，魔术包指AMD公司开发的唤醒数据包，具有远程唤醒的网卡都支持这个标准，用16进制表示如下：
6对“FF”前缀+16次重复MAC地址,举个例子假如我的网卡MAC地址是：AA:BB:CC:DD:EE:FF
那么魔术包就是:
0xFFFFFFFFFFAABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11 但是传送的时候必须封包成二进制格式才可以传送，简单来说，我们抽2个区段分析：
FFFFFFFFFFF 转成： 11111111 11111111 11111111 11111111 11111111 11111111
AABBCCDDEEFF11 转成：‭10101010 10111011 11001100 11011101 11101110 11111111 00010001‬
那么封包后就是把每个字节连接在一起：
11111111 11111111 11111111 11111111 11111111 11111111 10101010 10111011 11001100 11011101 11101110 11111111 00010001‬ ……..10101010 10111011 11001100 11011101 11101110 11111111 00010001‬（第16次） 开发实现 关键代码（Java）:
private String Wake(String name, String host, String mac, int port) { try { byte[] macBytes = getMacBytes(mac);//转成字节类型 byte[] bytes = new byte[6 + 16 * macBytes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b086063f60c7e6210181d89258b8ded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a094e470efcb57a9036e85c07fe6ddc/" rel="bookmark">
			【前端】实际开发案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发案例 1. 奔跑的熊2. 旋转木马3. 背景换肤4. tab栏切换5. 下拉菜单6. 发布留言1）原生JS实现2）vue 实现 7. 动态生成表格8. 图片跟随鼠标移动9. 定时器实现10. 获取URL参数数据11. 拖动模态框(登陆界面)12. 放大镜效果13. 仿淘宝固定侧边栏14. 轮播图15. 导航栏背景图移动16. 记住用户名17. 手风琴效果18. 可视化示例图 1. 奔跑的熊 &lt;!DOCTYPE html&gt; &lt;html lang="Cn_zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=divdiv, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .ss { width: 100%; height: 450px; background-image: url(/Picture/静态合集/山峰.jpg); } .ss .ss1 { position: absolute; width: 185px; height: 100px; top: 64%; background: url(/Picture/静态合集/熊.png) no-repeat; animation: xiong 1s steps(8) infinite, zhongxin 3s forwards; } @keyframes xiong { 0% { background-position: 0 0; } 100% { background-position: -1500px 0; } } @keyframes zhongxin { 0% { left:0; } 100% { left:45%; transform: translateX(-50%); } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a094e470efcb57a9036e85c07fe6ddc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1fed916f082773aecc0a4138750481c/" rel="bookmark">
			【SDN】最新！手把手零基础在Ubuntu 20.04搭建SDN环境（全网最详细）/Floodlight/Mininet/sFlow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想在Linux下搭建SDN环境，几乎把中文互联网所有相关教程都看了，用了一周时间才弄好，写下这篇文章帮助大家排坑。包括搭建Floodlight和Mininet，sFlow。
1.安装ubuntu 20.04 网上教程很多，就不展开了。
2.安装JDK8 参考了
Unbuntu下Java环境搭建-CSDN博客 Linux之Ubuntu20.04安装Java JDK8的两种方式-CSDN博客
一 更新软件包列表
sudo apt-get update 二 安装 OpenJDK 8
sudo apt-get install openjdk-8-jdk 三 检查 Java 版本
java -version 如果发现不对，必须要手动到官网下载 Java Downloads | Oracle
一 创建jvm目录
sudo mkdir /usr/lib/jvm 二 解压 JDK 压缩文件到 jvm 目录（注意文件名）
sudo tar -zxvf jdk-8u391-linux-x64.tar.gz -C /usr/lib/jvm 三 (无法解压需要切换到 root 用户)
sudo passwd root su root 四 创建 Java 目录并移动压缩文件
cd /opt sudo mkdir java mv jdk-8u391-linux-x64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1fed916f082773aecc0a4138750481c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b2db907e7bedef91bd322570936729e/" rel="bookmark">
			Laravel/Lumen 任务调度简易入门说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提 Laravel 中任务调度简化了服务器系统中 Cron 的操作，使得 计划任务 的实现更为简便。
这里主要以 Laravel 自带的消息队列进行说明，了解其间运行关系可以让我们更清晰的进行代码实现。
下方代码以 Lumen 9.x 框架进行举例，与 Laravel 应无二致。
中文参考文档：任务调度 - Laravel 9.x
定义任务调度 我们称之为 计划任务、周期性任务 均可。因为他的目的即是如此。
首先编辑 App\Console\Kernel 类，默认内容如下：
&lt;?php namespace App\Console; use Illuminate\Console\Scheduling\Schedule; use Laravel\Lumen\Console\Kernel as ConsoleKernel; class Kernel extends ConsoleKernel { /** * The Artisan commands provided by your application. * * @var array */ protected $commands = [ ]; /** * Define the application's command schedule. * * @param Schedule $schedule * * @return void */ protected function schedule(Schedule $schedule): void { // TODO: } } 例如我们需要在 每周一凌晨时段 执行业务统计任务（假设统计上一周订单量、销售额）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b2db907e7bedef91bd322570936729e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88729032344f9b34ff2bdd3ca129f36d/" rel="bookmark">
			（论文阅读）TiDB：一款基于Raft的HTAP数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 混合事务分析处理（HTAP）数据库要求隔离处理事务查询和分析查询，以消除它们之间的干扰。要实现这一点，有必要维护为这两种查询类型指定的数据的不同副本。然而，为存储系统中的分布式副本提供一致的视图是一项挑战，在存储系统中，分析请求可以大规模地、高可用性地从事务工作负载中高效地读取一致的新数据。
为了应对这一挑战，我们建议扩展基于复制状态机的一致性算法，为HTAP工作负载提供一致的副本。基于这种新颖的思想，我们提出了一个基于raft的HTAP数据库:TiDB。在数据库中，我们设计了一个由行存储和列存储组成的multi-Raft存储系统。行存储是基于Raft算法构建的。它是可伸缩的，可以实现高可用性事务请求的更新。特别是，它异步地将Raft日志复制到learners中，learners将元组的行格式转换为列格式，形成一个可实时更新的列存储。列存储允许分析查询有效地读取新鲜且一致的数据，并且与行存储上的事务具有很强的隔离性。基于该存储系统，我们构建了一个SQL引擎来处理大规模分布式事务和昂贵的分析查询。SQL引擎最佳地访问行格式和列格式的数据副本。我们还包括一个强大的分析引擎TiSpark，以帮助TiDB连接到Hadoop生态系统。综合实验表明，TiDB在一个专注于HTAP工作负载的基准测试下实现了各自的高性能。
1 介绍 关系数据库管理系统(RDBMS)因其关系模型、强大的事务保证和SQL接口而流行。它们在传统应用程序(如业务系统)中被广泛采用。但是，老的RDBMS不提供可伸缩性和高可用性。因此，在21世纪初，互联网应用程序更喜欢NoSQL系统，如谷歌Bigtable和DynamoDB。NoSQL系统放宽了一致性要求，并提供了高可伸缩性和可替代的数据模型，如键值对、图和文档。然而，许多应用程序还需要强大的事务、数据一致性和SQL接口，因此出现了NewSQL系统。像CockroachDB和谷歌Spanner这样的NewSQL系统为联机事务处理(OLTP)读/写工作负载提供了NoSQL的高可伸缩性，并且仍然为事务保持ACID保证。此外，基于sql的联机分析处理(OLAP)系统正在迅速发展，就像许多SQL-on-Hadoop系统一样。
这些系统遵循“one size does not fit all”范式，为OLAP和OLTP的不同目的使用不同的数据模型和技术。然而，开发、部署和维护多个系统的成本非常高。此外，实时分析最新版本的数据也很有吸引力。这在工业界和学术界产生了混合OLTP和OLAP (HTAP)系统。HTAP系统应该像NewSQL系统一样实现可伸缩性、高可用性和事务一致性。此外，HTAP系统需要有效地读取最新数据，以保证OLTP和OLAP请求在新鲜度和隔离性两个额外要求下的吞吐量和延迟。
新鲜度表示分析查询如何处理最近的数据。实时分析最新数据具有巨大的商业价值。但是，在一些HTAP解决方案中，例如基于提取-转换-加载(ETL)处理的解决方案，不能保证这一点。通过ETL进程，OLTP系统定期刷新一批最新的数据到OLAP系统。ETL耗时数小时或数天，因此无法提供实时分析。ETL阶段可以通过将最新的更新流式传输到OLAP系统来取代，以减少同步时间。然而，由于这两种方法缺乏全局数据治理模型，因此考虑一致性语义更为复杂。与多个系统接口会带来额外的开销。
隔离性指的是为单独的OLTP和OLAP查询保证隔离的性能。一些内存数据库(如HyPer)允许分析查询从同一服务器上的事务处理中读取最新版本的数据。尽管这种方法提供了新的数据，但它不能同时实现OLTP和OLAP的高性能。这是由于数据同步损失和工作负载干扰造成的。通过在HyPer和SAP HANA上运行HTAP基准测试CH-benCHmark来研究这种影响。研究发现，当系统协同运行分析查询时，其可达到的最大OLTP吞吐量会显著降低。SAP HANA吞吐量降低了至少三倍，HyPer降低了至少五倍。在MemSQL中也得到了类似的结果。此外，如果内存数据库仅部署在单个服务器上，则无法提供高可用性和可伸缩性。
为了保证独立的性能，有必要在不同的硬件资源上运行OLTP和OLAP请求。主要的困难是在单个系统中维护来自OLTP工作负载的OLAP请求的最新副本。此外，系统需要在多个副本之间保持数据一致性。注意，维护一致的副本也是可用性所必需的。高可用性可以使用众所周知的共识算法来实现，例如Paxos和Raft。它们基于复制状态机来同步副本。可以扩展这些一致性算法，为HTAP工作负载提供一致的副本。据我们所知，这个想法以前还没有被研究过。
根据这个想法，我们提出了一个基于raft的HTAP数据库:TiDB。它为Raft共识算法引入了专用节点(称为learners)。Learners异步复制来自leader节点的事务日志，为OLAP查询构造新的副本。特别是，learners将日志中的行格式元组转换为列格式，以便副本更适合于分析查询。这种日志复制对运行在领导节点上的事务性查询的开销很小。而且，这种复制的延迟非常短，可以保证OLAP的数据新鲜度。我们使用不同的数据副本分别处理OLAP和OLTP请求，以避免它们之间的干扰。我们还可以基于行格式和列格式的数据副本来优化HTAP请求。TiDB基于Raft协议，提供高可用性、可伸缩性和数据一致性。
TiDB提供了一种创新的解决方案，帮助基于共识算法的NewSQL系统进化为HTAP系统。NewSQL系统通过复制其数据库(如谷歌Spanner和CockroachDB)来确保OLTP请求的高可用性、可伸缩性和数据持久性。它们通过来自共识算法的复制机制在数据副本之间同步数据。基于日志复制，NewSQL系统可以提供专用于OLAP请求的列式副本，这样它们就可以像TiDB一样隔离地支持HTAP请求。我们的贡献总结如下。
我们提出建立一个基于共识算法的HTAP系统，并实现了一个基于raft的HTAP数据库TiDB。它是一个开源项目，为HTAP工作负载提供高可用性、一致性、可伸缩性、数据新鲜度和隔离性。我们将learner角色引入到Raft算法中，为实时OLAP查询生成列式存储。我们实现了一个multi-Raft存储系统，并优化了它的读写，以便系统在扩展到更多节点时提供高性能。我们为大规模HTAP查询定制了一个SQL引擎。引擎可以最佳地选择使用基于行的存储和列式存储。我们进行了全面的实验，使用HTAP基准测试来评估TiDB在OLTP、OLAP和HTAP方面的性能。 本文的其余部分组织如下。我们在第2节中描述了主要思想——基于raft的HTAP，并在第3节中说明了TiDB的体系结构。TiDB的multi-Raft存储和HTAP引擎将在第4节和第5节详细介绍。实验评估在第6节中提出。我们在第7节中总结了相关工作。最后，我们在第8节对本文进行总结。
2 基于RAFT的HTAP Raft和Paxos等共识算法是构建一致、可扩展和高可用性分布式系统的基础。它们的优势在于，可以使用复制状态机在服务器之间实时可靠地复制数据。我们调整了这个功能，以便针对不同的HTAP工作负载将数据复制到不同的服务器上。通过这种方式，我们保证OLTP和OLAP工作负载彼此隔离，而且OLAP请求具有最新的一致的数据视图。据我们所知，以前没有使用这些共识算法来构建HTAP数据库的工作。
由于Raft算法被设计为易于理解和实现，因此我们将重点放在实现可用于生产上的HTAP数据库的Raft扩展上。在高层次上，我们的想法如下：使用行格式将数据存储在多个Raft组中，以提供事务性查询。每个小组由一个领导和追随者组成。我们为每个组添加了一个learner角色，异步复制来自leader的数据。这种方法开销低，并且保持数据一致性。复制到learner的数据被转换为基于列的格式。扩展了查询优化器，以探索访问基于行和基于列的副本的物理计划。
在标准的Raft组中，每个follower都可以成为leader来处理和编写请求。因此，简单地增加更多的追随者不会独立资源。此外，添加更多的追随者将影响组的性能，因为leader必须等待来自更大的quorum节点的响应才能响应客户机。因此，我们在Raft共识算法中引入了一个learner角色。learner不参与leader选举，也不是日志复制的法定人数的一部分。从leader到learner的日志复制是异步的；在响应客户端之前，leader不需要等待成功。在读取时，leader和learner之间的强一致性被强制执行。通过设计，leader和learner之间的日志复制滞后很低。
事务性查询需要高效的数据更新，而连接或聚合等分析查询需要读取列的子集，但这些列需要读取大量的行。基于行的格式可以利用索引有效地服务于事务性查询。基于列的格式可以有效地利用数据压缩和矢量化处理。因此，在复制到Raft learner时，数据从基于行的格式转换为基于列的格式。此外，learner可以部署在单独的物理资源中。因此，事务查询和分析查询在隔离的资源中处理。
图-Raft组中增加列存learners角色
我们的设计还提供了新的优化机会。由于数据在基于行的格式和基于列的格式之间保持一致，因此我们的查询优化器可以生成访问其中一个或两个存储的物理计划。
我们提出了扩展Raft以满足HTAP数据库的新鲜度和隔离性要求的想法。为了使HTAP数据库能用于生产，我们克服了许多工程挑战，主要包括:
如何构建一个可扩展的Raft存储系统来支持高度并发的读/写?如果数据量超过了Raft算法管理的每个节点上的可用空间，我们需要一个分区策略来在服务器上分发数据。此外，在基本的Raft流程中，请求是顺序处理的，任何请求都必须经过Raft节点的仲裁批准才能响应客户端。此过程涉及网络和磁盘操作，因此非常耗时。这种开销使得leader成为处理请求的瓶颈，特别是在大型数据集上。如何以低延迟将日志同步到learner中以保持数据新鲜?正在进行的事务可能会生成一些非常大的日志。这些日志需要在learner中快速重播和具体化，以便可以读取新的数据。将日志数据转换为列格式可能会由于模式不匹配而遇到错误。这可能会延迟日志同步。如何在保证性能的情况下高效地处理事务性和分析性查询?大型事务性查询需要读写分布在多个服务器上的大量数据。分析查询也消耗大量资源，不应该影响在线事务。为了减少执行开销，他们还需要在行格式存储和列格式存储上选择最优计划。 在下面的部分中，我们将详细介绍TiDB的设计和实现，以解决这些挑战。
3 架构 在本节中，我们将描述TiDB的高级结构。TiDB支持MySQL协议，可以被MySQL兼容的客户端访问。它有三个核心组件:分布式存储层、Placement Driver(PD)和计算引擎层。
图-TiDB架构
分布式存储层由行存储(TiKV)和列存储(TiFlash)组成。逻辑上，存储在TiKV中的数据是一个有序的键值映射。每个元组被映射成一个键值对。键由它的表ID和行ID组成，值是实际的行数据，其中表ID和行ID是唯一的整数，行ID来自主键列。例如，包含四列的元组被编码为:
Key:{table{tableID} record{rowID}} Value: {col0, col1, col2, col3} 为了向外扩展，我们采用范围分区策略，将大的键值映射拆分为许多连续的范围，每个范围称为一个Region。每个区域都有多个副本，以实现高可用性。Raft共识算法用于保持每个Region的副本之间的一致性，形成Raft组。不同Raft组的领导将数据从TiKV异步复制到TiFlash。TiKV和TiFlash可以部署在单独的物理资源中，从而在处理事务查询和分析查询时提供隔离。
Placement Driver(PD)负责管理Regions，包括提供每个键的Region和物理位置，并自动移动Region以平衡工作负载。PD也是我们的时间戳oracle（TSO），提供严格递增和全局唯一的时间戳。这些时间戳也用作我们的事务ID。为了增强鲁棒性和性能，PD可以包含多个PD成员。PD没有持久状态，并且在启动时，PD成员从其他成员和TiKV节点收集所有必要的数据。
计算引擎层是无状态的，是可扩展的。我们定制的SQL引擎有一个基于成本的查询优化器和一个分布式查询执行器。TiDB实现了一个基于Percolator的两阶段提交(2PC)协议，以支持事务处理。查询优化器可以根据查询最优地选择从TiKV和TiFlash中读取。
TiDB的体系结构满足HTAP数据库的要求。TiDB的每个组件都设计为具有高可用性和可伸缩性。存储层使用Raft算法来实现数据副本之间的一致性。TiKV和TiFlash之间的低延迟复制使分析查询可以获得新数据。查询优化器以及TiKV和TiFlash之间的强一致性数据提供了快速的分析查询处理，对事务处理的影响很小。
除上述组件外，TiDB还集成了Spark，有助于将TiDB中的数据与HDFS (Hadoop Distributed File System)进行集成。TiDB有一组丰富的生态系统工具，用于向TiDB导入数据和从TiDB导出数据，以及将数据从其他数据库迁移到TiDB。
在下面几节中，我们将深入研究分布式存储层、SQL引擎和TiSpark，以演示TiDB(一个可用于生产的HTAP数据库)的功能。
4 Multi-Raft 存储 上图显示了TiDB中分布式存储层的体系结构，其中具有相同形状的对象扮演相同的角色。存储层由基于行的存储TiKV和基于列的存储TiFlash组成。存储将一个大的表映射成一个大的键值映射，这个键值映射被分成许多Region，存储在TiKV中。每个Region使用Raft一致性算法来保持副本之间的一致性，以实现高可用性。在将数据复制到TiFlash时，可以将多个Region合并为一个分区，以方便进行表扫描。TiKV和TiFlash之间的数据通过异步日志复制保持一致。由于多个Raft组在分布式存储层中管理数据，因此我们称之为multi-Raft存储。在接下来的部分中，我们将详细描述TiKV和TiFlash，重点介绍使TiDB成为可用于生产的HTAP数据库的优化。
图-multi-Raft存储架构
4.1 行存储（TiKV） TiKV部署由许多TiKV服务器组成。使用Raft在TiKV服务器之间复制Regions。每个TiKV服务器都可以是不同Region的Raft leader或follower。在每个TiKV服务器上，数据和元数据被持久化到RocksDB，这是一个可嵌入的、持久化的键值存储。每个Region都有一个可配置的最大大小，默认96 MB。Raft leader的TiKV服务器处理相应Region的读/写请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88729032344f9b34ff2bdd3ca129f36d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef887d46d3e61c6a70c1ce068088f08/" rel="bookmark">
			2023.11.21使用＜button＞元素来触发form表单和数据提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023.11.21使用＜button＞元素来触发form表单和数据提交
除了使用&lt;input&gt;中的submit方式进行form表单和数据提交，还可以使用button方式，两种方式视使用场景，各有优点。
方法一：可以将&lt;button&gt;放在&lt;form&gt;元素中，并将type属性设置为"submit"。这样当用户点击按钮时，就会触发表单的提交操作。如下示例代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Form Submission&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="/submit-form" method="post"&gt; &lt;input type="text" name="username" placeholder="用户名"&gt; &lt;input type="password" name="password" placeholder="密码"&gt; &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 方法二：使用button元素进行传值。
将button元素包含在form标签中，并设置一个隐藏的input元素来存储值。当用户点击按钮时，表单会提交并将值传递给服务器。
html
&lt;form action="your-action-url" method="post"&gt; &lt;input type="hidden" name="value" value="your-value" /&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt; &lt;/form&gt; 方法三：使用JavaScript处理按钮的点击事件，并通过JavaScript将值传递给其他地方，比如存储在变量中或者发送给服务器。
&lt;button onclick="getValue('your-value')"&gt;Click&lt;/button&gt; &lt;script&gt; function getValue(value) { // 处理传递的值 console.log(value); // 或者将值发送到服务器 } &lt;/script&gt; 方法四：使用data-属性：使用data-*属性来存储值，并通过JavaScript获取该值。
&lt;button id="myButton" data-value="your-value"&gt;Click&lt;/button&gt; &lt;script&gt; var button = document.getElementById('myButton'); var value = button.dataset.value; console.log(value); &lt;/script&gt; 方法五：通过JavaScript动态创建了一个表单元素，并将要传递的参数作为隐藏字段添加到表单中。然后，将表单添加到页面中并提交表单，实现将image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ef887d46d3e61c6a70c1ce068088f08/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/34/">«</a>
	<span class="pagination__item pagination__item--current">35/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/36/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>