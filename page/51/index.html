<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0812f099face107fa196b4179d49ab05/" rel="bookmark">
			JMeter 测试脚本编写技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JMeter 是一款开源软件，用于进行负载测试、性能测试及功能测试。测试人员可以使用 JMeter 编写测试脚本，模拟多种不同的负载情况，从而评估系统的性能和稳定性。以下是编写 JMeter 测试脚本的步骤。
第 1 步：创建测试计划 在JMeter中，测试计划是测试的最高级别，它包含了各种元素和配置，如线程组、断言、监听器等。测试人员需要在JMeter中创建一个新的测试计划，并添加必要的元素和配置。
要创建新的测试计划，请选择： 文件 &gt; 新建 &gt; 填写计划名称。
第 2 步：添加线程组 在测试计划中，测试人员需要添加一个或多个线程组。线程组是测试的基本单位，它定义了测试的并发用户数量、持续时间和其他属性。测试人员需要根据需求设置线程组的属性。
要创建线程组，请右击测试计划并选择： 添加 &gt; 线程(用户) &gt; 线程组。
填写线程组信息。
线程数：10 个线程就是模拟 10 个用户。Ramp-Up 时间 (秒)：线程准备时长。如果线程数为 10，准备时长为 10，那么需要 1秒钟启动 1 个线程。循环次数。如果线程数为 10，循环次数为 10，那么每个线程发送 10 次请求。总请求数为 10*10 =
100。如果勾选了“永远”，那么所有线程会一直发送请求，直到手动停止。 第 3 步：添加取样器 取样器 是 JMeter 测试的核心组件，它模拟了用户执行的操作。测试人员需要添加一个或多个取样器，并设置它们的属性。常见的取样器类型包括 HTTP 请求、TCP 请求、FTP 请求、JDBC 请求等。
这边以添加 HTTP 请求为例。添加 HTTP 请求，右击线程组并选择：添加 &gt; 取样器 &gt; HTTP 请求。
填写 HTTP 的调用信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0812f099face107fa196b4179d49ab05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f580e073d8cfed0f3ffe4b2a7cd9f6d2/" rel="bookmark">
			文创产品火出圈，熊猫伴伴受到大家喜爱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在各种IP火遍网络的同时，其衍生出来的各种文创产品也凭借着自身的特点火到出圈，不仅爆红于网络上，就连线下的各种商店也有着其具象化的商品售卖。例如最近深受年轻人喜爱的熊猫伴伴，就凭借着其可爱的外表，受到了很多人的欢迎。
熊猫伴伴是最近很火的一款动画片的主人公，有着圆滚滚的身体和黑白相间的皮毛，它圆圆的小脸上还有着一双闪闪发光的眼睛。该动画片一上映，熊猫伴伴就在网络上爆火，目前在网络上的热度非常高。除了在网络上有着超高人气，就连其线下售卖的文创产品也遭到疯抢，常常是卖断货的状态。甚至网上还掀起了一股“代购风”，许多代购在网上发布代购信息，还有很多黄牛将买来的文创产品高价售卖，市场上出现着各种各样的乱象。
作为一款普通的文创产品，熊猫伴伴为什么如此受到大家的欢迎？首先，作为一个深受大家喜爱的动画片主人公，它有着超高的人气，知名度和国民度都很高，所以人们对它的喜爱程度也就越来越高。其次，商家抓住了这一点，利用它的人气，制作出具象化的文创产品，诱导消费者进行购买，从而获得更多的利润。最后，实物的出现在一定程度上刺激了消费者的购买欲，人们通过购买文创产品，能够获得精神上的享受，这也是文创产品受到人们喜爱的原因。
购买自己喜爱的文创产品无可厚非，但在购买的时候一定要量力而行，购买自己需要的数量即可，注意保持消费市场的秩序和安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e161078afbb8135d85caf163c93cf5ad/" rel="bookmark">
			基于javaweb的在线宠物商店系统(java&#43;SSM&#43;mysql&#43;maven&#43;tomcat)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目简述
功能：本系统分用户前台和管理员后台。 系统包括用户的注册登录，狗狗的展示购物车添加以及下 单支付购买，后台有管理员用户，可以操作狗狗的品种， 狗狗的信息维护以及发货等等。 另外：系统采用MVC架构思想
二、项目运行
环境配置： Jdk1.8 + Tomcat8.5 + mysql + Eclispe (IntelliJ IDEA,Eclispe,MyEclispe,Sts 都支持)
项目技术： JSP +Spring + SpringMVC + MyBatis + html+ css + JavaScript + JQuery + Ajax + layui+ maven等等。
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
/** * 添加推荐 * @return */ @RequestMapping("/topSave") public @ResponseBody String topSave(Tops tops, @RequestParam(required=false, defaultValue="0")byte status, @RequestParam(required=false, defaultValue="1") int page) { int id = topService.add(tops); return id &gt; 0 ? "ok" : null; } /** * 删除推荐 * @return */ @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e161078afbb8135d85caf163c93cf5ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82de6226597573b5b9b3b776501debe2/" rel="bookmark">
			使用FFmpeg读取视频流并保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近接触到FFmpeg，需要实现一个将rtsp协议的码流读取并能显示的程序。在网上搬运代码的同时，也写一些对FFmpeg，Qt这些工具的理解。
准备 首先定义宏，其作用是避免‘UINT64_C’ was not declared in this scope的错误。
#ifndef INT64_C #define INT64_C(c) (c ## LL) #define UINT64_C(c) (c ## ULL) #endif 加入FFmpeg和C++头文件
extern "C" { /*Include ffmpeg header file*/ #include &lt;libavformat/avformat.h&gt; #include &lt;libavcodec/avcodec.h&gt; #include &lt;libswscale/swscale.h&gt; #include &lt;libavutil/imgutils.h&gt; #include &lt;libavutil/opt.h&gt; #include &lt;libavutil/mathematics.h&gt; #include &lt;libavutil/samplefmt.h&gt; } #include &lt;iostream&gt; using namespace std; 主函数
首先，定义输入输出AVFormatContext结构体，这类结构体存储音视频数据,也就是音视频文件的一种抽象和封装，注意在FFmpeg开发者只能使用指针。随后定义输入输出文件名，输入就是rtsp协议的地址，这里我用的是我自己的海康摄像头地址。输出保存为一个flv文件。avformat_network_init函数顾名思义是初始化网络。
int main(void) { AVFormatContext* ifmt_ctx = NULL, * ofmt_ctx = NULL; const char* in_filename, * out_filename; in_filename = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82de6226597573b5b9b3b776501debe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c393a4e4a4623a33457f4b5e090a478/" rel="bookmark">
			ChatGLM2-6B 模型本地部署及基于 P-Tuning v2 的微调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.说明 ChatGLM2-6B 是开源中英双语对话模型 ChatGLM-6B 的第二代版本，在保留了初代模型对话流畅、部署门槛较低等众多优秀特性的基础之上，还引入了更强大的性能、更强大的性能、更高效的推理、更高效的推理四大特性，本文将详细阐述如何本地部署、P-Tuning微调及在微调的效果。
2. 显卡驱动安装(仅适用于Ubuntu) 如果不确定本机的显卡驱动是否是最合适的，最好显卡驱动也重装一下
下载驱动 NVIDIA显卡驱动官方下载地址
下载好对应驱动并放在某个目录下，我这里放在/usr/local
禁用nouveau 首先，编辑黑名单配置。
vim /etc/modprobe.d/blacklist.conf
在文件的最后添加下面两行。
blacklist nouveau
options nouveau modeset=0
然后，输入下面的命令更新并重启。
update-initramfs -u
reboot
重启后输入下面的命令验证是否禁用成功，成功的话这行命令不会有输出。
lsmod | grep nouveau
驱动安装 首先，使用apt卸载已有的驱动，命令如下。
apt-get purge nvidia*
进入驱动所在路径，赋予执行权限，并执行安装命令
chmod +x NVIDIA-Linux-x86_64-535.86.05.run
./NVIDIA-Linux-x86_64-535.86.05.run
注：具体文件根据下载的驱动来填写
nvidia-smi
3. CUDA安装 显卡驱动版本 nvidia-smi
需要关注两个地方：
1.显卡驱动版本：535.86.05
2.显卡支持最高的CUDA版本：12.2
官网下载并安装对应版本CUDA 根据系统支持版本下载对应版本的CUDA Toolkit，作者此处选择CUDA10.2。官网链接选择所需版本，通过对应命令进行下载安装（注意此处需要记住下载文件的目录,之后需要找到） 注：在输入第二条命令之后，经过短暂的等待，会出现用户安装界面，其中包括是否选择安装Nvidia显卡驱动，如果本地已有驱动，可选择不安装（将光标移至Driver，点击Enter即可），之后移至Install处，点击Enter即可进行安装。
3.配置环境变量
编辑 /etc/profile 结尾添加如下
export CUDA_HOME=/usr/local/cuda-12.2` export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64 PATH="$CUDA_HOME/bin:$PATH" 使生效
sorce /etc/profile
4.测试CUDA安装是否成功
nvcc -V
显示如上图表示成功！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c393a4e4a4623a33457f4b5e090a478/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee43816c40c72df21e50e5adbc9b4d0/" rel="bookmark">
			centos7安装jdk1.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一 1.下载安装
yum search java|grep jdk yum install java-1.8.0-openjdk 配置环境变量 vim /etc/profile export JAVA_HOME=/usr/lib/jvm/java export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/jre/lib/rt.jar export PATH=$PATH:$JAVA_HOME/bin 方法二 下载
官网：下载地址
度盘：https://pan.baidu.com/s/1VYxJVY-P1UamN3pJ6wsMqA 提取码：x8pn上传： 找到你的文件放压缩包的位置上，rz 回车解压：tar -zxvf jdk-8u161-linux-x64.tar.gz修改配置文件 vim /etc/profile JAVA_HOME后面放自己的安装路径 export JAVA_HOME=/usr/local/jdk/jdk1.8.0_161 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tool.jar export PATH=$PATH:$JAVA_HOME/bin 生效配置文件 source /etc/profile检验 java -version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c722a9e18be3823137b54369e116bfc0/" rel="bookmark">
			关于 @microsoft/fetch-event-source 的 EventSource 反复重连的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景🙄 本来今天高高兴兴，用 Server-sent events 小小的一个做了 AI 聊天功能，没想到突然发现一个对话被重复请求了很多次，资源都被弄没了！这对本就不富裕的家庭来了狠狠的一巴掌！可恶啊！这到底是怎么回事！它怎么重复请求了这么多次！😫😫😫
复现😵‍💫 打开页面使用 @microsoft/fetch-event-source 发送一个 EventSource 请求在请求没完成前切换页面（不管是切换浏览器 tag 还是直接隐藏浏览器）再切换回页面（此时请求也没完成）就会发现多了一个跟发送的请求一模一样的 EventSource 请求不管隐藏显示多少次，只要请求没完成，就会出现多少次的重连请求
解决👌 那不得先问一波 ChatGPT ？？？然而问了，没有得到有效方案在网上查阅一大波资料，有的说是 EventSource 本身的机制导致的，需要服务端做无限重连什么的，很复杂也很乱，没找到有效信息看官方 Github 上的文档，也没有说这种情况需要这么解决，只是看到它示例里有一个说在 onerror 里返回重试什么的，但是其实并没有用，如下图
于是直接拉官方源码阅读看看能不能解决，然后就发现了 openWhenHidden ，直接设置为 true 就可以了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f7af05b5b526f6c6a602dfaa2a90bed/" rel="bookmark">
			mybatis入参为对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.对象传参方式一 Dao接口中方法
/** * 根据对象中保存的属性查询emp对象 * @param emp * @return */ List&lt;Emp&gt; findByEmp(Emp emp); mapper文件
&lt;select id="findByEmp" resultType="com.example.domain.Emp" parameterType="com.example.domain.Emp"&gt; select * from emp where name = #{name} or salary=#{salary} or job_id = #{job_id} &lt;/select&gt; 结论：一个java对象作为方法的参数，使用对象的属性作为参数值使用。简单的语法：#{属性名}，mybatis调用此属性的getXxx()方法获取属性值
2.对象传参方式二 编写接口，指定@Param注解参数(建议不要指定)
public interface LoginMapper { /** * 使用账号和密码登录 获取用户信息 * * @param login 登录参数 account password * @return */ Person selectPersonByAccountAndPassword01(@Param("login") Login login); } 编写映射配置文件：
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f7af05b5b526f6c6a602dfaa2a90bed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d017988c5e691d2dae108511278a07/" rel="bookmark">
			Java基础 - Java环境及编译运行原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Java环境1.JDK（Java Development Kit）2.环境变量 二、Java文件的编译及运行1、编译及运行过程：2、反编译过程： 一、Java环境 Java组成可以理解为：“一个平台”：JVM；“一套工具”：编译；“一套库”：JDK；“一套规范”：Java源代码和jvm指令集规范表。
1.JDK（Java Development Kit） 1.1定义： JDK是Java开发者工具，有开发Java程序、编译、运行、反编译、DeBug、监控后台等功能。
1.2具体内容：
JRE(Java Runtime Environment): 是Java 运行环境，其中包含： Java源代码库java.exe - 执行Java程序(Java解释器。用于解释执行Java字节码文件（.class文件），然后启动Java虚拟机解释并执行) JVM(Java Virtual Machine):是运行所有Java程序的抽象计算机(虚拟机)，其中： 每一个Java程序运行就会启动一个虚拟机每个虚拟机管理每个Java程序的资源、内存、代码和对于主机的操作资源 javac.exe - 编译Java项目代码(javac:全称java compiler。javac工具读由java语言编写的类和接口的定义，并将它们编译成二进制的字节代码的class文件)javap.exe - 反编译Java的字节码((javap:全称 java printer。用于分解class文件,反编译为java源代码，也可以查看java编译器生成的字节码)，代码测试进行优化的时候常用反编译javadoc.exe -项目文档导出等… 2.环境变量 环境变量是操作系统运行环境中的一个参数。配置java环境变量后能够在系统中的任何位置使用java及javac命令，执行命令时不再需要进入java安装目录下的bin目录下。
二、Java文件的编译及运行 1、编译及运行过程： 编写java源代码，进行编译生成class文件（算是一个中间代码二进制代码 - “机器码”），编译后得到class文件（Java虚拟机JVM中运行。将二进制代码，扔进CPU进行运行 - 汇编指令，因为cpu只能识别汇编代码），最后运行class文件得到结果。
如下图：
编写java源代码 打开终端切换到代码文件所在位置 编译代码 此时会出现一个编译成字节代码的class文件
运行程序
启动Java虚拟机解释并执行字节代码的class文件，得到执行结果 多文件程序的代码编译运行 - 只需要编译有主函数的类
范例：
2、反编译过程： 将java.class进行反编译，反编译后得到java源文件(源代码)。代码测试进行优化的时候常用反编译
反编译
详细指令版本(javap -v exe)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b4bb92cfe41ec21730728bea8e52696/" rel="bookmark">
			Unity3D实现页面的滑动切换功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 根据需要 使用 //初始化ScrollRect 位置（回到初始位置） for (int i = 1; i &lt; NeiRongList.childCount-1; i++) { NeiRongList.GetChild(i).GetChild(0).GetComponent&lt;ScrollRect&gt;().normalizedPosition = new Vector2(0, 1); } //刷新（有时候需要收到刷新）注意：需要Content的显影为true 才有效 LayoutRebuilder.ForceRebuildLayoutImmediate(Content.GetComponent&lt;RectTransform&gt;()); // Content.GetComponent&lt;GridLayoutGroup&gt;().spacing = new Vector2(0, n); 初始位置 GetComponent&lt;ScrollRect&gt;().normalizedPosition = new Vector2(0, 1); 滑动到最后一页 GetComponent&lt;ScrollRect&gt;().normalizedPosition = new Vector2(0, 0); //挂在 在有ScrollRect 组件 的UI 上
using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using UnityEngine.EventSystems; using System; using UnityEngine.Events; [System.Serializable] public class MyIntEvent : UnityEvent&lt;int&gt; { } /// &lt;summary&gt; /// 滑动页面效果 /// &lt;/summary&gt; public class PageView : MonoBehaviour, IBeginDragHandler, IEndDragHandler { public static PageView pageViewIn; private ScrollRect rect; private float targethorizontal = 0; private List&lt;float&gt; posList = new List&lt;float&gt;();//存四张图片的位置(0, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b4bb92cfe41ec21730728bea8e52696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19283bc996ac68d0864d0926b4a6b775/" rel="bookmark">
			使用cglib中Enhancer在运行时根据某个给定的类创建子类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class MsProxyBuilder { /** * 创建obj的代理对象 * @param obj 被代理对象 * @param interfaces 代理对象实现的接口数组 * @return 返回代理对象 */ public static Object buildProxy(Object obj, Class... interfaces) { if (obj == null || interfaces == null || interfaces.length == 0) { return obj; } Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(obj.getClass()); enhancer.setInterfaces(interfaces); MsMethodInterceptor methodInterceptor = new MsMethodInterceptor(); enhancer.setCallback(methodInterceptor); methodInterceptor.setTarget(obj); Object proxy = enhancer.create(); return proxy; } }
public interface Message_t {} public interface IMessage {} (IMessage) MsProxyBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19283bc996ac68d0864d0926b4a6b775/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ada8432cde7623416e7625524c3290/" rel="bookmark">
			h2数据库使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 修改数据库密码 //sa 为用户名 'nms'为修改的密码(可以'') ALTER USER sa SET { PASSWORD 'nms' } 12 创建用户
//bob为用户名 'x'为密码(可以'') CREATE USER IF NOT EXISTS bob { PASSWORD 'x' } 123 删除用户
//bob为用户名 DROP USER [IF EXISTS] bob 12 修改用户权限
ALTER USER bob ADMIN { TRUE } 1 重命名用户
//把bob重命名为json ALTER USER bob RENAME TO json 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d50b48d713db6f7e5cd92268820627a/" rel="bookmark">
			使用makefile,编译多文件夹动态库学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.动态库基础编译
先介绍最简单的动态库编译：这里有一个头文件：so_test.h，三个.c文件：test_a.c、test_b.c、test_c.c，我们将这几个文件编译成一个动态库：libtest.so。
so_test.h：
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void test_a();
void test_b();
void test_c();
---------------------------------------------------
test_a.c：
#include "so_test.h"
void test_a()
{
printf("this is in test_a...\n");
}
----------------------------------------------------
test_b.c：
#include "so_test.h"
void test_b()
{
printf("this is in test_b...\n");
}
---------------------------------------------------
test_a.c：
#include "so_test.h"
void test_c()
{
printf("this is in test_c...\n");
}
--------------------------------------------------
将这几个文件编译成一个动态库：libtest.so
$ gcc test_a.c test_b.c test_c.c -fPIC -shared -o libtest.so 注：这里 -fPIC 告诉编译器产生与位置无关代码，
则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意
位置，都可以正确的执行。-shared 选项指定源文件生成.so的动态库文件.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5172f4c178b90b5cf081031f18ec7d1/" rel="bookmark">
			gitee如何同步gitHub上的项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitee如何同步gitHub上的项目 1、登录gitee后、右上角【+】从GitHub/GitLab导入仓库
2、选择第二个tab页选择要导入的项目进行导入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe658677acda77646ab4615f41b5a1d/" rel="bookmark">
			C&#43;&#43; 虚函数表解析，及对象内存布局（转自csdn陈皓专栏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 虚函数表解析
C++ 虚函数表解析_c++ 虚表详解_haoel的博客-CSDN博客
C++ 对象内存布局(上)
C++ 对象的内存布局（上）_虚函数表和虚基类表_haoel的博客-CSDN博客
C++ 对象内存布局(下)
C++ 对象的内存布局（下）_haoel的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c671dee0818eb6da1474b0643aa4311d/" rel="bookmark">
			Java可变参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本概念 Java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。
二、基本语法 访问修饰符 返回类型方法名(数据类型... 形参名){ } 三、注意事项 可变参数的实参可以为0个或者任意多个；
可变参数的实参可以为数据；
可变参数的实质就是数组；
可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后；
一个形参列表只能出现一个可变参数。
四、示例 public class VarParameters { public static void main(String[] args) { // TODO Auto-generated method stub int count = VarParameters.soutint(1, 2, 3, 4); System.out.println("count=["+count+"]"); } // 将输入的参数依次打印在控制台，并返回和 public static int soutint(int... ii) { System.out.println("soutint传入参数总个数=["+ii.length+"]内容为："); int count = 0; for(int i = 0; i &lt; ii.length; i++) { count += ii[i]; System.out.printf("%d ", ii[i]); } System.out.println(); return count; } } 输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c671dee0818eb6da1474b0643aa4311d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f66e86526f9a699c514e97c63c958fd5/" rel="bookmark">
			APP自动化测试-环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装jdk 1、安装JDK(1.8版本)
2、配置环境变量
a、JAVA_HOME jdk的安装路径;
b、classpath .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
c、path %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
3、运行cmd，输入java-version检查是否安装成功
二、安装Android SDK 国内下载SDK的网址https://www.androiddevtools.cn/默认官网地址https://developer.android.com/sdk/index.html
“我的电脑”右击，点击“属性”，进入设置页面，点击“高级系统设置”，进入系统属性页面，点击“高级”，配置环境变量。
1、系统变量➡新建ANDROID_HOME 变量➡变量值填写sdk的安装目录
2、系统变量“path”➡追加配置
%ANDROID_HOME%\platform-tools
%ANDROID_HOME%\tools
%ANDROID_HOME%\build-tools\29.0.3
3、在cmd窗口输入 adb version 来检测是否配置成功，如果下面的信息显示版本号则配置成功
三、安装Appium Desktop（初级） https://github.com/appium/appium-desktop/releases
傻瓜式安装即可
四、安装Appium Server（命令行版本） 1、下载node.js
https://nodejs.org/en/download
2、打开cmd窗口，输入 node -v 以及 npm -v 检测，出现版本号则成功
3、指定npm安装的全局模块和缓存的路径，如果不指定则默认C盘
a、在nodejs目录下新建“node_cache”和“node_global”目录
b、在cmd窗口输入命令：
npm config set prefix "D:\software\nodejs\node_global" npm config set cache "D:\software\nodejs\node_cache" c、查看全局安装的模块所在目录：npm root -g
d、查看npm缓存默认存放路径：npm get cache
4、配置node.js 环境变量
a、系统变量➡新建NODE_PATH 变量➡变量值“D:\tools\nodejs\node_global\node_modules”
b、系统变量“path”➡追加配置“%NODE_PATH%”
c、将用户变量“path”中原来的“C:\Users\Administrator\AppData\Roaming\npm”
修改为“D:\tools\nodejs\node_global”
5、安装Appium Sever
a、设置npm淘宝镜像地址:
npm config set registry https://registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f66e86526f9a699c514e97c63c958fd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/190b659d944b94851209a0a02f3987e8/" rel="bookmark">
			【论文简述】GeoMVSNet: Learning Multi-View Stereo with Geometry Perception（CVPR 2023）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、论文简述 1. 第一作者：Zhe Zhang
2. 发表年份：2023
3. 发表期刊：CVPR
4. 关键词：MVS、级联结构、几何感知、频域增强、高斯混合模型
5. 探索动机：基于级联的结构以从粗到细的方式计算不同分辨率的深度图，并逐步缩小假设平面指导，以降低计算复杂度。然而，这些方法并不考虑早期阶段所包含的有价值的洞察，只考虑像素级深度属性。 一些方法，例如基于可变形核和基于transformer，引入了更精细的设计过的外部结构来进行特征提取，但没有充分利用嵌入MVS场景中的几何线索。
6. 工作目标：虽然最近的一些工作试图通过变形卷积或多尺度信息聚合来获得大上下文，但对于MVS，还没有探索在每个视图中挖掘全局上下文的解决方案。此外，探索一种获取三维一致性特征的方法对于MVS中鲁棒可靠的匹配至关重要。
7. 核心思想：
We propose the geometric prior guided feature fusion and the probability volume geometry embedding approaches for robust cost matching.We enhance geometry awareness via the frequency domain filtering strategy and adopt the idea of curriculum learning for progressively introducing geometric clues
from easy to difficult.We model the depth distribution of MVS scenarios using the Gaussian-Mixture Model assumption and build the full-scene geometry perception loss function.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/190b659d944b94851209a0a02f3987e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05aff88f9726ed9d0c6e081a73cb0d7b/" rel="bookmark">
			java记录H2数据库的操作指令日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#数据库连接配置
url=jdbc:h2:./conf/embedded/afc_hangzhou;schema=afc_hangzhou;RECOVER=1;FILE_LOCK=SOCKET;TRACE_LEVEL_FILE=3;TRACE_LEVEL_SYSTEM_OUT=3;
#url=jdbc:h2:./../conf/embedded/afc_hangzhou;schema=afc_hangzhou;RECOVER=1;FILE_LOCK=SOCKET
username=afc_hangzhou
password=afcapp
增加url中TRACE_LEVEL_FILE=3;TRACE_LEVEL_SYSTEM_OUT=3;可以输出所有的h2数据库操作日志，日志会写在*.trace.db文件内，数字表示写入日志的级别
每个级别都对应了每个数字，如下：
OFF：0
ERROR：1
INFO：2
DEBUG：3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea935902de44137dcba870fba1c5017c/" rel="bookmark">
			selenium知识点大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		selenium知识点大全 在使用selenium之前必须先配置浏览器对应版本的webdriver。
1. 初始化浏览器对象 from selenium.webdriver import Chrome # 创建浏览器对象，并且打开一个空的页面 browser = Chrome() # 关闭浏览器 browser.close() 2. 访问指定网页 from selenium import webdriver # 初始化浏览器为chrome浏览器 browser = webdriver.Chrome() # 访问百度首页 browser.get(r'https://www.baidu.com/') # 浏览器截图 browser.get_screenshot_as_file('截图.png') # 关闭浏览器 browser.close() 3. 设置浏览器大小 from selenium import webdriver import time browser = webdriver.Chrome() # 设置浏览器大小：全屏 browser.maximize_window() browser.get(r'https://www.baidu.com') time.sleep(2) # 设置分辨率 500*500 browser.set_window_size(500, 500) time.sleep(2) # 设置分辨率 1000*800 browser.set_window_size(1000, 800) time.sleep(2) # 关闭浏览器 browser.close() 4. 刷新页面 from selenium import webdriver import time browser = webdriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea935902de44137dcba870fba1c5017c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/50/">«</a>
	<span class="pagination__item pagination__item--current">51/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/52/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>