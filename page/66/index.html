<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fadf4cc97048329be04e4bd107224ac2/" rel="bookmark">
			vue2&#43;elementUI 下拉树形多选框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如图所示：
1.新建el-select-tree.vue组件
&lt;!-- * 下拉树形选择 --&gt; &lt;template&gt; &lt;el-select ref="selectTree" :value="value" v-model="valueName" :multiple="multiple" :clearable="clearable" @clear="clearHandle" @change="changeValue"&gt; &lt;el-option :value="valueName" class="options"&gt; &lt;el-tree id="tree-option" ref="selectTree" :accordion="accordion" :data="options" :props="props" :node-key="props.value" @node-click="handleNodeClick"&gt; &lt;span slot-scope="{ data }"&gt; &lt;i :class="[data.color != null ? 'ification_col' : '']" :style="{ 'background-color': data.color }"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;{{ data.name }} &lt;/span&gt; &lt;/el-tree&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/template&gt; &lt;script&gt; export default { name: "el-tree-select", props: { // 配置项 props: { type: Object, default: () =&gt; { return { value: 'id', children: 'children', label: 'name' } } }, // 选项列表数据(树形结构的对象数组) options: { type: Array, default: () =&gt; { return [] } }, // 初始值（单选） value: { type: Object, default: () =&gt; { return {} } }, // 初始值（多选） valueMultiple: { type: Array, default: () =&gt; { return [] } }, // 可清空选项 clearable: { type: Boolean, default: true }, // 自动收起 accordion: { type: Boolean, default: false }, // 是否多选 multiple: { type: Boolean, default: false } }, data() { return { resultValue: [], // 传给父组件的数组对象值 valueName: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fadf4cc97048329be04e4bd107224ac2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a60020d92d0a40c29d75692c17c6040/" rel="bookmark">
			python的数据库Class写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class dbUtil():
def init(self):
conn, cursor = self.get_conn()
self.conn = conn
self.cursor = cursor
def get_time(self): time_str = time.strftime("%Y{}%m{}%d{} %X") return time_str.format("年", "月", "日") def get_conn(self): # 建立连接 conn = pymysql.connect(host="localhost", port=3306,user="root", password="xx", db="weather", charset="utf8") # c创建游标A cursor = conn.cursor() return conn, cursor def close_commit(self): self.conn.commit() if self.cursor: self.cursor.close() if self.conn: self.conn.close() def close(self): self.conn.commit() if self.cursor: self.cursor.close() if self.conn: self.conn.close() def query(self, sql, *args): self.cursor.execute(sql, args) res = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a60020d92d0a40c29d75692c17c6040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab72da26829e81a01ee977ddd131d2a/" rel="bookmark">
			GoJS Beginner Tutorial #1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.关系图：
gojs部件由一个或多个gojs面板组成，这些面板包含和组织各种gojs图形对象
通常使用go.GraphObject.make创建一个GraphObject，我们通过使用$符号变量缩短了该函数的名称
这个函数的第一个参数，往往是你想要制作的GraphObject的类型，所以如果你想制作一个Shape
第一个参数将是 go.Shape。
所有的GraphObject可以接受一个额外的参数来指定一些属性，
1.例如将字符串作为第二个参数传递给TextBlock构造函数指定为TextBlock GraphObject的默认文本。
2.还可以将 JavaScript 对象作为参数。其中包含描述GraphObject各种属性的键值对 对于图形对象，
面板负责保存和组织各种 gojs GraphObject，我们这些组成的GraphObject称之为面板的元素 请注意，
parts 实际上是panel 面板的
panel类型将决定其GraphObject在构建部件时的组织方式
当构建parts或panel你可以将面板类型指定为第二个参数，如果没有指定面板类型，则它充当一个
位置面板
gojs 中有许多panel类型
下面将观察五个最常见的面板类型，看看它们如何排列元素的
---------------------------------------------------------------------------------------------------------------------------------
为了展示这些panel types，我们将使用带有两个元素的part模板
记住part是panel的子类，所以即使你在代码中的任何地方都看不到panel这个词，
part也充当panel并根据我们指定的面板类型组织它的元素，部件作为顶级面板，该部件的所有其他面板都将包含在其中
我们部件构造函数中的第一个参数是与面板类型对应的字符串
接下来的两个是面板元素：部件的第一个元素是一个形状，我们使用其第二个参数进行设置它的图形
我们将在整个视频中，我们将使用RoundedRectangle图作为我们的Shape。
第二个元素是一个TextBlock，我们使用第二个参数设置其文本
另外我们可以在options数据对象参数提供一些关于Part元素属性的一些信息
比如：这里为我们的形状设置了填充属性，我们将为这些元素设置其他属性，以便对常用属性进行更深入的讨论，请先查看我们的视频 gojs GraphObject属性，
每个元素的位置由为每个图形对象元素指定的位置属性确定，如果没有定义位置属性，元素
位于 （0,0), 所有位置都在面板自己的坐标系位置内, 可能包括负坐标.
--------------------------------------------------------------------------------------------------------------------------------
首先确保
我们的面板类型是位置我们将
通过定位文本块元素来检查此面板类型的工作方式
现在让我们不为
我们的文本块提供位置值看看我们有
什么 形状和文本块出现
在面板的左上角，这
是有道理的，因为默认位置是 0
0
现在让我们继续并将
文本块的位置属性设置为新的
Godot 点值，比如 50 20 现在看
文本 块出现在右上角 50 像素
和左上角下方 20 像素处，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eab72da26829e81a01ee977ddd131d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98428f6065e55cec9bad715504a4ded/" rel="bookmark">
			深度学习实战——循环神经网络（RNN、LSTM、GRU）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		忆如完整项目/代码详见github：https://github.com/yiru1225（转载标明出处 勿白嫖 star for projects thanks）
目录
系列文章目录
一、实验综述
1.实验工具及内容
2.实验数据
3.实验目标
4.实验步骤
二、循环神经网络综述
1.循环神经网络简介
1.1 循环神经网络背景
1.2 循环神经网络概念与原理
1.3 循环神经网络发展历程
2.循环神经网络相关知识导入
2.1 序列模型
2.2 文本预处理
2.3 语言模型
2.4 数据集
三、经典循环神经网络原理、实现与优化
1.RNN
1.1 原理
1.2 代码实现（自购建）
1.3 代码实现（API）
1.4 消融实验
1.4.1 num_hiddens
1.4.2 num_steps
1.4.3 batch_size
1.4.4 lr
1.4.5 epoch
1.4.6 综述
2.LSTM
2.1 原理
2.2 代码实现
2.3 消融实验
3.GRU
3.1 原理
3.2 代码实现
3.3 消融实验
4.对比分析
四、高级循环神经网络架构介绍与选择实现
1.深度循环神经网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a98428f6065e55cec9bad715504a4ded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f004b098705a5a88c32d000da7b43e0/" rel="bookmark">
			记一次使用replaceAll的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用replaceAll替换一个图片地址的时候发现没有替换到 需求是需要把网络上的图片上传到本地服务器，然后把图片地址替换成自己的地址，结果出现图片上传成功，却没有替换的情况。 搜了一下发现是由于replaceAll会匹配正则字符，所以导致当url里面出现？的时候就会匹配不到，导致匹配失效。 使用raplace直接替换 其实这里我们直接使用replace直接替换就好了，会去完全匹配。 因为一直以为replace是匹配第一次，而replaceAll是匹配所有。一直出现理解错误！！ 使用replaceFirst()替换第一次出现 这个方法只替换第一次出现的，也可以匹配正则表达式。 总结：replace与replaceAll的区别主要是replaceAll支持正则！他们都会全部替换！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f596550b2e29e01cab43e4284941d060/" rel="bookmark">
			精通Spring AOP和IOC：原理、应用场景与实战代码示例一网打尽！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接下来我将详细解释一下Spring AOP和IOC的原理和应用场景。
一、SringAOP 1. Spring AOP的原理和应用场景 Spring AOP是Spring框架中的一个重要组成部分，它是基于代理的面向对象编程技术。在运行时，Spring AOP可以动态地将代码织入到应用程序的特定点，以提供额外的功能，例如日志记录、性能检测等。Spring AOP的实现基于切面（Aspect）和通知（Advice）这两个概念。
切面是类似于日志记录和性能检测等“横切逻辑”的代码片段。它是一个包含通知和切点的Java类，其中通知定义了要执行的逻辑代码，而切点定义了何时执行该代码。
通知是要执行的逻辑代码，Spring AOP提供了以下五种通知类型：
前置通知（Before Advice）：在目标方法执行前执行通知代码。后置通知（After Advice）：在目标方法执行后执行通知代码，无论方法是正常执行还是异常退出。返回通知（After Returning Advice）：在目标方法成功执行后执行通知代码。抛出通知（After Throwing Advice）：在目标方法抛出异常后，执行通知代码。环绕通知（Around Advice）：在目标方法执行前后，可以自定义通知代码来代替目标方法的执行。
Spring AOP通过代理来实现动态织入代码。Spring框架提供了两种代理方式：JDK动态代理和CGLIB代理。对于接口实现类，Spring AOP使用JDK动态代理生成代理对象，对于没有实现接口的类，Spring AOP使用CGLIB代理来生成代理对象。 2.Spring AOP的应用场景包括： 日志处理：记录方法调用日志或错误日志，例如记录用户登录或操作记录。安全控制：控制用户访问权限，例如控制用户角色或访问URL权限。声明式事务管理：管理数据库事务，例如声明式地控制事务的开始和提交等操作。 3. Spring AOP的代码示例 首先，定义一个切面类，用于在目标方法执行前后打印日志。
@Aspect @Component public class LoggingAspect { private static final Logger LOGGER = LoggerFactory.getLogger(LoggingAspect.class); @Before("execution(public * com.example.demo.*.*(..))") public void logBefore(JoinPoint joinPoint) throws Throwable { LOGGER.info("Logging aspect: Before " + joinPoint.getSignature().getName() + " method execution."); } @After("execution(public * com.example.demo.*.*(..))") public void logAfter(JoinPoint joinPoint) throws Throwable { LOGGER.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f596550b2e29e01cab43e4284941d060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2c00f3f9225b16b6ad40a8b4f25b76/" rel="bookmark">
			【Java】定义一个盒子类Box，包括3个私有变量（width,length,height),一个构造方法和showBox()方法。构造方法用来初始化变量，showBox()方法无参数，用于输出变量.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
题目：
代码：
结果：
题目： 定义一个盒子类Box
包括3个私有变量（width,length,height),一个构造方法和showBox()方法。
构造方法用来初始化变量，showBox()方法无参数，用于输出变量(width,length和height)
的值。
代码： 步骤 1.首先定义一个公共类Box
2.在类中定义三个私有变量：width，length和height。
3.定义一个构造方法
Box(double width,double length,double height），用来初始化这三个变量值。 4.定义了一个shouBox()方法，用于输出变量
package test2; public class Box { private double width; private double length; private double height; public Box(double width,double length,double height){ this.width=width; this.length=length; this.height=height; } public void showBox(){ System.out.println("Box dimensions:width="+width+",length="+length+",height="+height); } } package test2; public class main { public static void main(String[] args) { Box b=new Box(1.5,2.0,3.0); b.showBox(); } } 这段代码创建了一个 Box 对象b，调用了其中的showBox()方法，输出该对象的宽，长和高
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf2c00f3f9225b16b6ad40a8b4f25b76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc7ebb636798385d39e5b61ea112ff9/" rel="bookmark">
			Qt5.PlainTextEdit文本框清空操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.widget.h代码如下
private: void init(); int connectALL(); //定义槽函数 2.widget.cpp connect函数代码如下
Widget::Widget(QWidget * parent) : QDialog(parent), ui(new Ui::Widget) { ui-&gt;setupUi(this); //去掉原widget窗口边框 setWindowFlags(Qt::MSWindowsFixedSizeDialogHint); //初始化 init();	} //初始化connect函数 void Widget::init() { connectALL(); } //connect槽函数编写 int Widget::connectALL() { connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [=]() { ui-&gt;plainTextEdit-&gt;clear(); }); return true; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f4d31246c8031b273077f9b9c83ed9/" rel="bookmark">
			C#通过MQTT与其他物联网设备通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQTT（Message Queuing Telemetry Transport）是一种轻量级的消息传输协议，常用于物联网设备之间的通信。在C#中，我们可以使用MQTT库来实现与其他物联网设备之间的通信，本文将介绍如何使用C#中的MQTT库进行通信。
一、安装MQTT库
C#中有多个MQTT库可供选择，例如M2Mqtt、MQTTnet等，本文以MQTTnet为例进行讲解。在Visual Studio中，可以使用NuGet包管理器安装MQTTnet库，或者通过命令行安装，具体如下：
使用NuGet包管理器安装：在Visual Studio中，右键单击项目，选择“管理NuGet程序包”，在搜索框中搜索MQTTnet，选择MQTTnet库进行安装。
使用命令行安装：在Visual Studio中，打开“工具”菜单，选择“NuGet包管理器”，选择“程序包管理器控制台”，在控制台中输入以下命令进行安装：
Install-Package MQTTnet
安装完成后，就可以在项目中使用MQTTnet库了。
二、连接MQTT服务器
在使用MQTT进行通信之前，需要先连接MQTT服务器。连接MQTT服务器需要指定MQTT服务器的地址、端口、客户端ID等信息。下面是一个示例代码，展示如何连接MQTT服务器：
using MQTTnet; using MQTTnet.Client; using MQTTnet.Client.Options; var factory = new MqttFactory(); var client = factory.CreateMqttClient(); var options = new MqttClientOptionsBuilder() .WithTcpServer("localhost", 1883) .WithClientId("client1") .Build(); await client.ConnectAsync(options); 在上面的代码中，我们创建了一个MQTT客户端，并指定了MQTT服务器的地址和端口。其中，WithTcpServer方法指定了MQTT服务器的地址和端口，WithClientId方法指定了客户端ID。最后，使用await client.ConnectAsync(options)方法连接MQTT服务器。
三、发布MQTT消息
连接到MQTT服务器后，就可以开始发布消息了。使用MQTTnet库可以轻松地发布MQTT消息。下面是一个示例代码，展示如何发布MQTT消息：
var message = new MqttApplicationMessageBuilder() .WithTopic("topic1") .WithPayload("Hello MQTT") .WithQualityOfServiceLevel(MqttQualityOfServiceLevel.AtMostOnce) .WithRetainFlag(false) .Build(); await client.PublishAsync(message); 在上面的代码中，我们创建了一个MQTT消息，指定了消息的主题、负载、服务质量等信息，并使用await client.PublishAsync(message)方法发布消息。
四、订阅MQTT消息
订阅MQTT消息可以接收其他物联网设备发布的消息。使用MQTTnet库可以轻松地订阅MQTT消息。下面是一个示例代码，展示如何订阅MQTT消息：
var mqttClient = new MqttFactory().CreateMqttClient(); mqttClient.UseConnectedHandler(async e =&gt; { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0f4d31246c8031b273077f9b9c83ed9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3566af6d05b5a3a89ba25e4665a028/" rel="bookmark">
			Windows删除某文件夹下面所有重复的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;bits/stdc++.h&gt; #include &lt;io.h&gt; #include &lt;stdio.h&gt; #include &lt;windows.h&gt; using namespace std; typedef long long LL; unordered_set&lt;string&gt; postfix; unordered_set&lt;string&gt; files; bool flg = false; bool TraverseDirectory(string path) { LL Handle; struct __finddata64_t FileInfo; string strFind = path + "\\*"; if ((Handle = _findfirst64(strFind.c_str(), &amp;FileInfo)) == -1L) { printf("没有找到匹配的项目\n"); return false; } do { //判断是否有子目录 if (FileInfo.attrib &amp; _A_SUBDIR) { //判断是子文件夹 //下面的判断条件很重要，过滤 . 和 .. if ((strcmp(FileInfo.name, ".") != 0) &amp;&amp; (strcmp(FileInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3566af6d05b5a3a89ba25e4665a028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004951c324f4eb69b3a0e086a975d093/" rel="bookmark">
			pytorch与cuda版本匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确保环境可以运行cuda版本的pytorch 1.使用nividia-smi确保有cuda。
根据cuda版本号选择对应的pytorch。
Previous PyTorch Versions | PyTorch
pip3 install torch==1.10.1+cu102 torchvision==0.11.2+cu102 -f https://download.pytorch.org/whl/cu102/torch_stable.html 你可以通过以下Python代码测试CUDA是否可以正常工作：
python import torch torch.cuda.is_available() 返回True，则说明CUDA可以正常工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad277b317f78cc90f140ff1fea6434ee/" rel="bookmark">
			qt编写的视频播放器，windows下使用，精致小巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qtCreator4.11.1，qt版本5.14.1,系统win10
1.基于qt自带的QMediaPlayer和QVideoWidget类编写
2.有暂停播放功能、视频进度条拉动功能，最大化、最小化、还原功能
3.按住界面上、下、左、右、右下的边界，可实现拉伸缩放软件窗口，窗口最小可缩小致100*100像素。 （摸鱼必备哦！）
4.无论当前界面是最大化还是正常大小，若鼠标不在窗口内，可自动隐藏标题栏，进度条，播放暂停等所有界面按钮，实现整个界面只有视频画面，没有任何影响观影的按钮等控件！
5.可使拖动文件到软件界面后播放
注意！请在编译运行本程序前，安装K-Lite解码器（资源压缩包内就有），因为qt自带的QMediaPlayer类是基于本地解码器来解码播放视屏的，如果不安装解码器，会出现视频无法播放或者播放时卡顿花屏等问题！！！
源码下载链接：
https://download.csdn.net/download/weixin_43935474/87698997
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed46b0352a792c3576e856fca077976d/" rel="bookmark">
			Unity 3D 小小冒险者视频教程下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity 3D Little Adventurer
查看视频简介
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa2ee0e3dff5b52293c0c3bbe80110a4/" rel="bookmark">
			（2）elasticsearch环境搭建(win10)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装jdk 版本选择：最好是java 8、java11或者java14
jdk兼容性：https://www.elastic.co/cn/support/matrix#matrix_jvm
操作系统兼容性：https://www.elastic.co/cn/support/matrix
自身兼容性：https://www.elastic.co/cn/support/matrix#matrix_compatibility
安装elasticsearch 下载elasticsearch-7.10.0
https://www.elastic.co/cn/downloads/elasticsearch
https://elasticsearch.cn/download/
下载之后解压到一个位置
目录名称描述bin可执行脚本文件，包括启动elasticsearch服务、插件管理、函数命令等。config配置文件目录，如elasticsearch配置、角色配置、jvm配置等。libelasticsearch所依赖的java库。data默认的数据存放目录，包含节点、分片、索引、文档的所有数据，生产环境要求必须修改。不建议放在elasticsearch目录。logs默认的日志文件存储路径，生产环境务必修改。不建议放在elasticsearch目录。modules包含所有的Elasticsearch模块，如Cluster、Discovery、Indices等。plugins已经安装的插件的目录。jdk/jdk.app7.0以后才有，自带的java环境。 修改elasticsearch.yml
修改config目录下的elasticsearch.yml配置文件cluster.name、path.data、path.logs等（可以参照后边的启动参数）
当然也可以不用修改，在后边的启动的时候进行设置启动参数。
贴个常见的配置文件，可以认识配置。
# 集群名称，三台集群，要配置相同的集群名称！！！ cluster.name: my-application # 节点名称，没有配置的话，默认是当前主机名 node.name: node-1 # 是否有资格被选举为master，ES默认集群中第一台机器为主节点 node.master: true # 是否存储数据 node.data: true #最⼤集群节点数，为了避免脑裂，集群节点数最少为 半数+1 node.max_local_storage_nodes: 3 # 数据目录 path.data: /usr/local/node-1/data # log目录 path.logs: /usr/local/node-1/logs # 修改 network.host 为 0.0.0.0，表示对外开放，如对特定ip开放则改为指定ip network.host: 0.0.0.0 # 设置对外服务http端口，默认为9200 http.port: 9200 # 内部节点之间沟通端⼝ transport.tcp.port: 9300 # 写⼊候选主节点的设备地址，在开启服务后可以被选为主节点 discovery.seed_hosts: ["localhost:9300", "localhost:9301", "localhost:9302"] # 初始化⼀个新的集群时需要此配置来选举master cluster.initial_master_nodes: ["node-1", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa2ee0e3dff5b52293c0c3bbe80110a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50cb61b5aa2a26408ab70b4491a50b2e/" rel="bookmark">
			python依次运行多个代码遇到的同步与异步问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、要实现在一个Python代码运行完后紧接着运行另一个Python代码，可以使用Python的subprocess模块。该模块可以创建新进程并与之交互，可以用于在Python代码中启动新的程序或脚本。
下面是一个示例代码，用于在运行完code1.py后紧接着运行code2.py：
import subprocess subprocess.run(['python', 'code1.py'], check=True) subprocess.run(['python', 'code2.py'], check=True) 以上代码将在主进程中依次运行两个子进程，第一个子进程运行code1.py，当其结束后，主进程开始运行第二个子进程，即运行code2.py。
其中，check=True参数表示在子进程运行期间如果出现错误会抛出异常，如果不设置该参数则不会抛出异常。
2、要在 Python 中自动为 input 输入框中输入一个字符并回车，可以使用 subprocess 模块中的 Popen() 方法启动一个新进程，然后将要发送到标准输入流的数据传递给该进程。
以下是一个示例代码，作为演示：
import subprocess # 启动一个新的子进程 process = subprocess.Popen(['python'], stdin=subprocess.PIPE, stdout=subprocess.PIPE) # 将要输入的数据写入标准输入流，并换行 process.stdin.write(b'a\n') # 刷新缓冲区 process.stdin.flush() # 读取并打印子进程输入 output, errors = process.communicate() print(output.decode('utf-8')) 可以看到，run换成了Popen，Popen的作用是启动一个新进程，然后将要发送到标准输入流的数据传递给该进程。
假如我们的需求是：对于有的代码能：运行结束后运行下一个：那么用run就行
对于别的代码，我们需要它只运行一定时间，运行到这个时间后就shutdown后接着运行下一个 对于这样的需求，我们用Popen就行
但是我们遇到了问题： Popen运行后还会启动后面的代码，因为其是同步线程 会启动线程来运行，所以原来的线程会继续运行，而run是异步运行，运行完了才会接着运行下一个，所以问题就出在了Popen，我们要解决Popen运行未结束就运行run的代码的问题
例：
p1 = subprocess.Popen(['python', r"测试run和Popen01.py"]) # time.sleep(2) # shutdown_chromes("Chrome") # p1.terminate() p1.wait() subprocess.run(['python', r"测试run和Popen02.py"], input=b"q\n") # shutdown_chromes("Chrome") p3 = subprocess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50cb61b5aa2a26408ab70b4491a50b2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a13e3eb8b6a13ad52193a718d8ad89/" rel="bookmark">
			Windows添加自定义右键菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows添加自定义右键菜单 应用场景 最近在用c4d建模做动画的时候，图片合成视频用到了ffmpeg命令，每次做一个动画，就需要打开cmd重新敲命令，不是很便捷，想着把这个命令，以bat的形式放在鼠标右键，这样就可以方便一点。
方法教程 1.Win+R打开运行： 2.输入regedit,点击确定： 3.打开计算机\HKEY_CLASSES_ROOT\Directory\Background\shell 4.右键shell新建项： 5.右键新建项： 6.右键修改 找到你的bat位置，复制它的地址，例如F:\Bat\a.bat:
输入 F:\Bat\a.bat
点击确定，即完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e06120e8786f3485d9732ce3626a8770/" rel="bookmark">
			MySQL的varchar字段最大长度真的是65535吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在mysql建表sql里，我们经常会有定义字符串类型的需求。
CREATE TABLE `user` ( `name` varchar(100) NOT NULL DEFAULT '' COMMENT '名字' ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ; 比方说user表里的名字，就是个字符串。mysql里有两个类型比较适合这个场景。
char和varchar。
声明它们都需要在字段边上加个数组，比如char(100)和varchar(100)，这个100是指当前字段能放的最大字符数。
char和varchar的区别在于，varchar虽然声明了最大能放100个字符，但一开始不需要分配100个字符的空间，可以根据需要慢慢增加空间。而char一开始声明是多少，就固定预留多少空间。
所以，varchar比起char更省空间，一般没啥大事，大家都爱用varchar。
那问题来了，声明varchar字段时，它的最大长度是多少呢？
相信大家应该听说过varchar字段的最大长度是65535吧。
没听过也没关系，你现在听到了。
但实际上是这样吗？
我们来做个实验。
varchar最大值是多少 我们直接拿65535来试一下。
长度为65535的varchar报错 很明显报错了。
报错内容也说了, 由于列长度过大导致报错，最长是16383。
把上面的65535改成 16383，确实是成功了。
哦？所以说varchar最大值是16383？
当然不是。
这其实还有好几个因素影响这这个最大值。
不同字符集的影响 varchar里放的是字符串，而字符串看起来可以是英文字母，也可以是数字或中文。但不管怎么样，都可以把这样的中英文数字转成二进制的01串。
按照一定规则把符号和二进制码对应起来，这就是编码。而把n多这种已经编码的字符聚在一起，就是我们常说的字符集。
建表语句里有个CHARSET，这里填的是字符集。
不同的字符集要求使用的字节个数也不同，我们可以通过 show charset; 看到mysql支持哪些字符集，以及这些字符集里存储一个字符所需的最大字节数（Maxlen）。
查看mysql支持哪些charset 我们尝试下把建表sql语句里的CHARSET改一改，比如改成utf8mb3。
我们再执行下，会发现，最大值又不一样了。
utf8mb3下的报错 并且，上面虽然提示max=21845，但要是真执行起来会发现还是报错。在改为21844之后才成功。
不讲武德。
再把字符集改为 latin1。会发现，最大值会是 65533。
varchar为65533时创建成功 这里渐渐可以发现规律。
utf8mb4的maxlen=4，对应varchar最大长度=16383。4*16383 = 65532。
utf8mb3的maxlen=3，对应varchar最大长度=21844。3*21844 = 65532。
latin1的maxlen=1，对应varchar最大长度=65533。 1 * 65533 = 65533。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e06120e8786f3485d9732ce3626a8770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65695b1c058c71919978791eb52fd218/" rel="bookmark">
			实验一：Shamir 秘密共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验一：Shamir 秘密共享 一、问题描述：
实现一个（k,n）-Shamir 秘密共享方案，其中 k=3，n=4，包含以下功能：
（1） 给定一个数字，可以计算出对应的 share
（2） 给定 k 个 share, 能够重构出秘密值。
二、实验环境：
系统：Windows 10
IDE：pycharm
编译语言：python
三、程序代码与结果分析：
（1）解Shamir算法部分
Shamir秘密共享算法是基于拉格朗日插值计算来实现的秘密共享，他核心是在人数未达到门限值之前，没有人能够恢复秘密，下面我们来简单介绍一下秘密共享算法的实现过程：
首先是类的初定义，我们需要提供秘密即info，门限值k，秘密共享人数p给类，然后定义了大素数，我们调用创建大素数函数，最开始创建一个16位的大素数，然后进行一些类对象的初始化，最后执行检查，检查主要是检查大素数是否大于秘密的值，如果没有进行这一步，那么就无法恢复秘密，因为拉格朗日插值计算要在大素数域内计算，如果你的消息值大于这个数，那么肯定无法还原，接下来我们看一下创建以及检查函数的实现。
下面是创建大素数函数，这个函数就是简单使用随机函数创建一个对应位数的值然后如果这个是素数就返回，否则，再创建一个大素数。check函数则是检查密码是否小于大素数，我们这里先对秘密进行判断，检查它是str类型还是int类型，字符类型的话就转化为大端整数，并标记，这一步在恢复秘密的时候需要用到，判断是否需要转化为字符串。如果秘密大于大素数，就按照之前定义好的位数依次调高，直到大于秘密值为止，下面简单简述一下判断素数的过程。 我们这里运用了Miller-Rabin算法，首先对初始状态进行判断，之后计算出公式当中的将n-1表示为2^k * m中的k和m，然后进行判断，随机从1到n-1选出一个数，计算他的m次方在该素数域下，如果b的值是1或者n-1那么进行进一步循环，最多循环n-1次。找出b^2在素数域下的值，如果这个值等于n-1则认为可能是素数，否则，肯定是合数，这样循环10次（这个10次是自己定的，因为这个算法只是计算是素数的概率，重复10次都可能是素数，那么它是素数的概率就很大了）
当准备好这些数之后，就开始分发秘密，首先多项式的第一个值是秘密值，其他值就是随机选取1到大素数减一，然后开始分发秘密，这个秘密就是多项式的值，这个多项式的系数是定好的系数，次数最高是门限减一，这里简单的把1， 2等作为x分配给人员，没人得到一个分享。
之后就是恢复秘密，我们首先判断是否满足最低门限要求，如果没有提示错误，如果满足，则按找拉格朗日插值进行恢复秘密
这里我将拉格朗日插值的累加和累乘分开来写了
最后检查秘密的类型，还原秘密，并输出。
（2）GUI部分
GUI采用了tkinter库，由于有很多组件，详细代码见后文，这里不再赘述，仅简述一下功能性的方面下面是生成秘密的按钮的功能，我们这里按照秘密分享的人数生成对应个数的框，每个框可以进行勾选，表示是否参与恢复秘密，框内会展示秘密的分享值，这里对于用户的输入也进行了检查，不合法的会弹出提示或者错误框。
下面是恢复秘密的按钮函数，也是进行了一些判定，如果合法则会在对应的地方输出秘密。至此，代码简述结束，下面在下一节展示运行结果。
代码运行结果实例 一开始会出现这样的样式
之后我们输入
恢复秘密
还有一些错误提示不再展示。
实验中遇到的问题以及实验体会： 本次实验是第一个密码学实验，了解了一些秘密分享的加密算法，在实验中，也遇到了很多问题，比如说素数的情况，最开始我选择的固定一个素数，但是不小心秘密值大于了素数值，结果检查了很久，还有就是多项式的计算是在素数域下进行，最开始我没有注意，结果也花了不少时间检查。
这次试验对于我对这种密码算法也有了更深入的了解，对于拉格朗日插值计算也有了深入的理解，在一些python编程的小技巧上也有了更深的理解，比如进行求逆计算等。
通过这次实验，也极大的锻炼了我的编程能力，在于图形化界面的编写，也更加熟练了。
附录：代码
https://download.csdn.net/download/dxxmsl/87699285
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/735c7e007a9f48b63b337b4604728099/" rel="bookmark">
			看书标记【R语言数据分析与挖掘实战】13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十三章 基于数据挖掘技术的市政收入分析预测模型 13.1 背景与挖掘目标 正确处理地方财政与经济的相互关系具有十分重要的意义，建模目标：1）梳理影响地方财政收入的关键特征，分析、识别影响地方财政收入的关键特征的选择模型；2）结合目标1的因素分析，对广州2015年的财政总收入及各个类别收入进行预测。
13.2 分析方法与过程 常用多元线性回归模型，运用最小二乘估计对回归模型系数进行估计，以系数是否通过检验来验证其相关关系。这样得到的结果往往对数据的依赖程度很大，且OLS求得到的解往往是局部最优解，其相关检验可能会失去意义。针对预测变量过多，子集选择的计算过程操作不易问题，Lasso 成为了被广泛应用于参数估计和变量选择的方法之一。书中的案例选用了Adaptive-Lasso 方法探究地方财政收入与各因素之间的关系。lasso是由Tibshirani提出的将参数估计与变量选择同时进行的一种正则化方法，其参数估计定义如下：
β ^ ( l a s s o ) = arg ⁡ min ⁡ β ∣ ∣ y − ∑ j = 1 p x j β j ∣ ∣ 2 + λ ∑ j = 1 p ∣ β j ∣ \hat{\beta}(lasso)={\arg \min}_\beta||y-\sum_{j=1}^{p}x_j\beta_j||^2+\lambda \sum_{j=1}^{p}|\beta_j| β^​(lasso)=argminβ​∣∣y−∑j=1p​xj​βj​∣∣2+λ∑j=1p​∣βj​∣，lambda为非负正则参数，后一项为惩罚项。lasso本身有一些严苛的条件，之后Zou给不同的系数加上不同的权重，被称为Adaptive-Lasso方法：
β ∗ ^ ( l a s s o ) = arg ⁡ min ⁡ β ∣ ∣ y − ∑ j = 1 p x j β j ∣ ∣ 2 + λ n ∑ j = 1 p w ^ j ∣ β j ∣ , w ^ j = 1 ∣ β ^ j ∣ γ \hat{\beta^*}(lasso)={\arg \min}_\beta||y-\sum_{j=1}^{p}x_j\beta_j||^2+\lambda_n \sum_{j=1}^{p}\hat{w}_j|\beta_j|,\hat{w}_j=\frac{1}{|\hat{\beta}_j|^\gamma} β∗^​(lasso)=argminβ​∣∣y−∑j=1p​xj​βj​∣∣2+λn​∑j=1p​w^j​∣βj​∣,w^j​=∣β^​j​∣γ1​，hat beta为OLS得到的系数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/735c7e007a9f48b63b337b4604728099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a06e54b99206af34bc6d80ea5e0679/" rel="bookmark">
			Netty同步获取返回结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍netty client发送请求后，如何阻塞获取结果的一种方法
文章目录 前言一、netty使用方式pom：Server端：client端 二、原理细化阻塞对象 总结 前言 众所周知，Netty是异步的、基于事件驱动的网络应用框架，它以高性能、高并发著称。基于事件驱动，简单点说就是 Netty 会根据客户端的连接请求、读、写等事件 做出相应的响应。
但实际使用场景中避免不了需要同步获取server返回值的情况，经过小小的修改后可以实现阻塞式获取response的效果
一、netty使用方式 pom： &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.72.Final&lt;/version&gt; &lt;/dependency&gt; Server端： @Slf4j public class NettyServer { //启动netty服务端 public static void start(int port) { EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); final NettyServerHandler nettyServerHandler = new NettyServerHandler(); final NettyServerHandler2 nettyServerHandler2 = new NettyServerHandler2(); final NettyOutBoundHandler nettyOutBoundHandler = new NettyOutBoundHandler(); final NettyOutBoundHandler2 nettyOutBoundHandler2 = new NettyOutBoundHandler2(); try { //创建服务端的启动对象，并使用链式编程来设置参数 ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a06e54b99206af34bc6d80ea5e0679/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/65/">«</a>
	<span class="pagination__item pagination__item--current">66/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/67/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>