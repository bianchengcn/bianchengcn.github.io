<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4bfbebfb92004f3e3359e527bb8e10d/" rel="bookmark">
			组队竞赛问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目说明 时间限制：1秒空间限制：32768K 牛牛举办了一次编程比赛, 参加比赛的有3*n个选手,
每个选手都有一个水平值a_i.现在要将这些选手进行组队, 一共组成n个队伍,
即每个队伍3人.牛牛发现队伍的水平值等于该队伍队员中第二高水平值。 例如 : 一个队伍三个队员的水平值分别是3, 3,
3.那么队伍的水平值是3 一个队伍三个队员的水平值分别是3, 2, 3.那么队伍的水平值是3 一个队伍三个队员的水平值分别是1, 5, 2.那么队伍的水平值是2 为了让比赛更有看点, 牛牛想安排队伍使所有队伍的水平值总和最大。 如样例所示 : 如果牛牛把6个队员划分到两个队伍 如果方案为 : team1: {1, 2, 5}, team2 : {5, 5, 8}, 这时候水平值总和为7. 而如果方案为 :
team1 : {2, 5, 8}, team2 : {1, 5, 5}, 这时候水平值总和为10. 没有比总和为10更大的方案,
所以输出10.
输入描述 : 输入的第一行为一个正整数n(1 ≤ n ≤ 10 ^ 5) 第二行包括3*n个整数a_i(1 ≤ a_i ≤ 10 ^ 9),
表示每个参赛选手的水平值.
输出描述 : 输出一个整数表示所有队伍的水平值总和最大值.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4bfbebfb92004f3e3359e527bb8e10d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8acf91ccdab31822579db583d3729c/" rel="bookmark">
			GIT更新失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们使用idea对git上的项目进行提交的时候，我们必须要先更新我们的项目，当我们的项目正在运行的时候更新项目是会更新失败的。
项目更新失败错误信息 错误原因 正在运行的项目直接更新会出现如上所示的错误。
解决办法 把正在运行的项目停止运行，然后我们再次点击更新，可以看到IDEA的项目已经通过git更新成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1395610d294c933b2e4607c71a352ec6/" rel="bookmark">
			【学习】PSI、IV、WOE的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PSI PSI（模型分布稳定性）:稳定度指标(population stability index ,PSI)可衡量测试样本及模型开发样本评分的的分布差异，为最常见的模型稳定度评估指针。其实PSI表示的就是按分数分档后，针对不同样本，或者不同时间的样本，population分布是否有变化，就是看各个分数区间内人数占总人数的占比是否有显著变化。
其中，bins是分箱数量，Actual是实际占比，Expected是预期占比。
一般来说，PSI小于0.1模型稳定性较高，0.1至0.2之间稳定性一般，大于0.2建议重新迭代模型。
对于模型稳定性，即考虑在不同数据集上。公式： psi = sum(（实际占比-预期占比）* ln(实际占比/预期占比))
举个例子解释下，比如训练一个logistic回归模型，预测时候会有个类概率输出，p。在你的测试数据集上的输出设定为p1，将它从小到大排序后将数据集10等分（每组样本数一直，此为等宽分组），计算每等分组的最大最小预测的类概率值。
现在你用这个模型去对新的样本进行预测，预测结果叫p2，利用刚才在测试数据集上得到的10等分每等分的上下界。按p2将新样本划分为10分（不一定等分了哦）。实际占比就是新样本通过p2落在p1划分出来的每等分界限内的占比，预期占比就是测试数据集上各等分样本的占比。
意义就是如果模型更稳定，那么在新的数据上预测所得类概率应该更建模分布一致，这样落在建模数据集所得的类概率所划分的等分区间上的样本占比应该和建模时一样，否则说明模型变化，一般来自预测变量结构变化。通常用作模型效果监测。
一般认为PSI小于0.1时候模型稳定性很高，0.1-0.2一般，需要进一步研究，大于0.2模型稳定性差，建议修复。 参考地址
数据样本分布稳定性，psi = sum(（样本A分布占比-样本B分布占比）* ln(样本A分布占比/样本B分布占比))
WOE 参考地址
WOE(Weight Of Evidence 证据权重)是一种对自变量编码的方法，需注意的是在WOE编码前需对数据进行分箱（分组或离散化）操作。
对于特征每个分组WOE的计算方法：
其中，pyi是分组i中正样本(响应客户，目标列Y=1)占所有正样本的比例，pni是分组i中负样本(未响应客户，目标列Y=0)占所有负样本的比例，yi是分组i中正样本数量，yT是所有正样本数量，ni是分组i中负样本数量，nT是所有负样本数量。从公式可以看出，WOE即分组内正负占比与样本整体正负占比的差异。WOE越大，这种差异越大，这个分箱里的样本响应的可能性就越大，WOE越小，分箱内样本响应的可能想性越低。
# 逻辑代码 import math def cal_woe(df, col, y = 'xxx'): """ df:数据集 col:特征名 y:样本定义根据的列名（1:黑样本，0:白样本） """ # 黑样本 black_cnt = df.groupby(col)[y].sum() # 白样本 white_cnt = df.groupby(col)[y].sum() #所有黑样本 black_cnt_total = df[y].sum() #所有白样本 white_cnt_total = df.shape(0) - df[y].sum() #pyi pyi = black_cnt / black_cnt_total #pni pni = white_cnt / white_cnt_total #woe woe = (pyi / pni).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1395610d294c933b2e4607c71a352ec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10dbfca44305efeb5604edd8581b0a67/" rel="bookmark">
			单一职责、接口隔离、依赖倒转、里氏替换、开闭原则、迪米特、合成复用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用抽象构建架构，用实现扩展细节。
单一职责原则：实现类要职责单一；接口隔离原则：在设计接口的时候要精简单一；依赖倒转原则：面向接口编程；里氏替换原则：不要破坏继承关系；开闭原则原则：对扩展开发，对修改关闭；迪米特法则：最少知道原则；合成复用原则：先考虑组合或聚合，后考虑继承； 一、单一职责原则 1、目的 降低代码复杂度、降低系统耦合度、提高可读性
2、定义 对于一个类，只有一个引起该类变化的原因；该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。
3、具体实现 将不同的职责封装到不同的类或者模块中，当有新的需求将现有的职责分为颗粒度更小的职责的时候，应该及时对现有代码进行重构。
4、优点 （1）降低类的复杂度，一个类只负责一个职责。这样写出来的代码逻辑肯定要比负责多项职责简单得多。
（2）提高类的可读性，提高系统的可维护性。
（3）降低变更引起的风险。变更是必然的，如果单一职责原则遵守得好，当修改一个功能的时候可以显著降低对其他功能的影响。
5、注意事项和细节 （1）降低类的复杂度，一个类只负责一项职责；
（2）提高类的可读性，可维护性；
（3）降低变更引起的风险；
（4）通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单、才可以在代码级违反单一职责原则，只有类中的方法足够少，才可以在类中保持方法级别的单一职责原则。
二、接口隔离原则 1、目的 避免接口过于臃肿
2、定义 客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。
3、具体实现 适度细化接口，将臃肿的接口拆分为独立的几个接口。
4、优点 （1）将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
（2）接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
（3）使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
（4）能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。
5、注意事项和细节 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
三、依赖倒转原则 1、目的 避免需求变化导致过多的维护工作
2、定义 高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块(一般是接口，抽象类)，原子逻辑的组装就是高层模块。在Java语言中，抽象就是指接口和或抽象类，两者都不能被直接实例化。细节就是实现类，实现接口或继承抽象类而产生的类就是细节，可以被直接实例化。
3、具体实现 面向接口编程，使用接口或者抽象类制定好规范和契约，而不去设计任何具体的操作，把展现细节的任务交给他们的实现类去完成。
4、DIP的好处 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。
5、DIP的几种写法 （1）接口声明依赖对象；
（2）构造函数传递依赖对象；
在类中通过构造函数声明依赖对象（好比spring中的构造器注入），采用构造器注入。
（3）Setter方法传递依赖对象
在抽象中设置setter方法声明依赖对象（spring中的方法注入）
6、深入理解 依赖倒转原则的本质就是通过抽象使各个类或模块实现彼此独立，不互相影响，实现模块间的松耦合。
在项目中使用这个规则需要以下原则：
（1）每个类尽量都要有接口或抽象类：依赖倒转的基本要求，有抽象才能依赖倒转；
（2）变量的表明类型尽量是接口或者抽象类；
（3）任何类都不应该从具体类派生；
（4）尽量不要重写基类已经写好的方法（里氏替换原则）；
（5）结合里氏替换原则来使用：
接口负责定义public属性和方法，并且声明与其他对象的依赖关系；
抽象类负责公共构造部分的实现；
实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化；
一句话，依赖倒转原则就是面向接口编程。
四、里氏替换原则 1、目的 避免系统继承体系被破坏
2、定义 所有引用基类的地方必须能透明地使用其子类的对象。
3、具体实现 （1）子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法；
（2）子类可以增加自己特有的方法；
（3）当子类覆盖或实现父类的抽象方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松；方法的后置条件（即方法的返回值）要比父类更严格。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10dbfca44305efeb5604edd8581b0a67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b104ec0543291ba74ffdeac6fd483533/" rel="bookmark">
			CentOS7.3镜像下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7.3，是CentOS-7系列的第四个发行版本，官方版本号为7.3.1611。该版本的安装映像只有 64 位，具体的安装映像有以下几种：
DVD版 推荐（迅雷下载）：http://archive.kernel.org/centos-vault/7.3.1611/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso迅雷种子下载： CentOS7.3 64位DVD版映像下载 假若你不清楚用哪个映像，就选择DVD版本映像，此版本可以让你选择需要安装的组件，并包含所有在图像安装界面内可选择的组件。
Everything版 推荐（迅雷下载）：http://archive.kernel.org/centos-vault/7.3.1611/isos/x86_64/CentOS-7-x86_64-Everything-1611.iso迅雷种子下载： CentOS7.3 64位Everything版映像下载 everything 映像内收录了 CentOS-7 提供的所有组件，包括那些不能通过安装程序直接安装的组件。
LiveGnome版 推荐（迅雷下载）：http://archive.kernel.org/centos-vault/7.3.1611/isos/x86_64/CentOS-7-x86_64-LiveGNOME-1611.iso迅雷种子下载： CentOS7.3 64位LiveGnome版映像下载 该版本允许你通过以DVD或USB开机的方式来测试CentOS系统。你可以将live映像上的系统安装到映像，但是此版本会安装live映像内包含的所有的组件。
LiveKDE版 推荐（迅雷下载）：http://archive.kernel.org/centos-vault/7.3.1611/isos/x86_64/CentOS-7-x86_64-LiveKDE-1611.iso迅雷种子下载： CentOS7.3 64位LiveKDE版映像下载 此版本同GnomeLive版本类似。
Minimal版 推荐（迅雷下载）：http://archive.kernel.org/centos-vault/7.3.1611/isos/x86_64/CentOS-7-x86_64-Minimal-1611.iso迅雷种子下载： CentOS7.3 64位minimal版映像下载 NetInstall版 推荐（迅雷下载）：http://archive.kernel.org/centos-vault/7.3.1611/isos/x86_64/CentOS-7-x86_64-NetInstall-1611.iso迅雷种子下载： CentOS7.3 64位NetInstall版映像下载 CentOS 7.3.1611版系统说明 此版本相比较之前的版本，所做的主要改动，大体上有以下几点：
此版本添加了一些新的组件，包括：python-gssapi、python-netifaces、mod_auth_openidc、pidgin 及 Qt5。CentOS7.3 支持第 7 代 Core i3、i5及i7 Intel处理器及第6代Core处理器上的12C。该版本中的某些组件已经改版，例如：有 samba、squid、systemd、krb5、gcc-libraries、binutils、gfs-utils、libreoffice、GIMP、SELinux、firewalld、libreswan、tomcat 及 open-vm-tools。OpenLDAP 已支持 SHA2，同时，virt-p2v 已全面获支持。virt-v2v 及 virt-p2v 已支持最新版 windows。 注意：CentOS-7（1611）的安装及应用至少需要1024 MB的内存。利用 Live 映像进行安装时，若内存只有 1024 MB，会拖慢安装进度，甚至令安装失败。推荐至少采用 1344 MB 内存进行 LiveGNOME 或 LiveKDE 的安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b104ec0543291ba74ffdeac6fd483533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378b0d08b3b65e580427092a2972a20c/" rel="bookmark">
			PowerDesigner详细安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装PowerDesigner之前我们要准备好相应的文件，那么我们都需要那些文件的呢？
准备的文件 1、PowerDesigner.exe：安装文件
2、pdflm16.dll：破解文件
3、PowerDesigner汉化文件
PowerDesigner详细安装教程： 1、解压PowerDesigner安装文件，并双击PowerDesigner.exe。
2、欢迎来到PowerDesigner安装界面，点击 Next。
3、选择Trial，再点击Next，不要选择其它，这一步如果选择错，后面破解是不行的。
4、选择Hong Kong，点击I AGREE，再点击Next。
5、选择一个合适的安装目录，默认是安装在C盘。再点击Next。
6、点击General和Notaion（即全部选中），再点击Next。
7、直接点击Next，进入正在安装界面。
8、点击Finish（安装完成）。
PowerDesigner破解步骤： 1、将PowerDesigner破解文件解压，然后你能看到一个“pdflm16.dll”文件。
2、将“pdflm16.dll”复制并覆盖到你软件安装的目录中，一定要是此软件的安装根目录。
PowerDesigner汉化步骤： 1、将PowerDesigner汉化文件解压，然后你能看到很多文件。
2、Ctrl+A（全选）所有文件，复制并覆盖到你软件安装的目录中。
3、如果点击PdShell16.exe不能正常启动，请点击pdlegacyshell16.exe启动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9727001f280c3b2ed11855d61fa8905/" rel="bookmark">
			【JDBC】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【JDBC】 JDBC的基本概念 概念：Java Database Connectivity，Java 数据库连接，Java语言操作数据库。
JDBC本质：希望使用统一的一套Java代码可以操作所有的关系型数据库**，JDBC定义了一套操作所有关系型数据库的规则（即接口），每一个数据库厂商都去实现这套接口，提供数据库驱动jar包，我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。**
快速入门 步骤：
导入驱动jar包 mysql-connector-java-8.0.11.jar 复制jar包到项目的libs目录下右键 --&gt; Add as Library 注册驱动获取数据库的连接对象 Connection定义sql获取执行sql语句的对象 Statement执行sql，接收返回的结果处理结果释放资源 /** * JDBC快读入门 */ public class JdbcDemo01 { public static void main(String[] args) throws ClassNotFoundException, SQLException { //1. 导入驱动jar包 `mysql-connector-java-8.0.11.jar` // - 复制jar包到项目的libs目录下 // - 右键 --&gt; Add as Library //2. 注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //3. 获取数据库的连接对象 Connection Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/practise?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT", "root", "root"); //4. 定义sql String sql = "UPDATE account SET balance = 1000 WHERE id = 1"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9727001f280c3b2ed11855d61fa8905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35668c74133cdd9fb8c8a800e6bbe87d/" rel="bookmark">
			谈“堆栈”与“队列”的认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谈“堆栈”与“队列”的认识
开发工具与关键技术：Visual Studio 2015 谈“栈”的认识
作者：李国旭
撰写时间：2020年5月28日
刚刚接触这个“堆栈”，简称——栈。它呢是我在这个《数据结构与算法》中第一次看到的一个陌生的词，也是我学编程的这一段时间以来的第一次接触；对于初学者的我们来说就会疑问了，什么是“栈”？在电视上我们看得那些古装剧里面就有这个客栈，而我们说的并不是这个；它们的意义上可以说是一个意思，我就是这样理解这个栈的，而且它这个栈呢有进栈有出栈等等。
下面我们来看一下栈的定义：堆栈简称为栈，是限定只能在表的一端进行插入和删除操作的线性表。在表中，允许插入和删除的一端称作“栈顶”而另一端呢称作“栈底”。通常将元素插入栈顶的操作称作为“入栈”（进栈或压栈），称删除栈顶元素的操作为“出栈”。如下图所示：（图来自唐懿芳老师）
在我们删除的时候呢为了避免删除了找不到，所以我们就需要一个备份
public Object delete(int i)throws Exception { index(i-1);//定位 Object obj=current.next.getElement();//取元素 current.setNext(current.next.next); size--;//元素个数减1 return obj; } 接着上面的就是栈的储存结构了，它分为俩种存储结构：
（1）顺序栈——采用顺序结构存储
（2）链栈——采用链式结构存储
#define MaxSize 堆栈可能达到的最大长度 typedef struct{ ElementType elem[MaxSize]; int top;//栈顶位置 }SeqStack //入栈 public void push(Object obj)throws Exception { if(top==maxSize-1){ throw new Exception("堆栈已满！"); } top++; stack[top]=obj; } //出栈 public Object pop()throws Exception { if(top==-1){ throw new Exception("堆栈已空！"); } Object obj=stack[top] top--; return obj; } 如下图所示出栈和入栈的情况，出栈就一个放入备用空间，防止找不到，入栈就增加一个空间，例如：就好像我们家里碗柜的摆放都是叠着的，我们拿的时候呢就只能从上面开始拿，不能从下面开始拿这是肯定的，如果我们从下开始那么那些上面的盘子就会掉，都是同样的道理（下图来自唐懿芳老师）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35668c74133cdd9fb8c8a800e6bbe87d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74dc11baf9ab4824cab5e190fd8ae97/" rel="bookmark">
			C&#43;&#43; 打开文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境： Win7 x64,VS2015
目标 : 打开指定文件夹，支持空格中文路径，字符集支持Unicode/多字节
代码：
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;Windows.h&gt; using namespace std; std::wstring StringToWString(const std::string &amp;str) { std::wstring wContext = L""; int len = MultiByteToWideChar(CP_ACP, 0, str.c_str(), str.size(), NULL, 0); WCHAR* buffer = new WCHAR[len + 1]; MultiByteToWideChar(CP_ACP, 0, str.c_str(), str.size(), buffer, len); buffer[len] = '\0'; wContext.append(buffer); delete[] buffer; return wContext; } void OpenFolder(const string &amp;path) { //字符集 支持Unicode 和 多字节 #ifdef _UNICODE std::wstring tmp = StringToWString(path); LPCWSTR dir = tmp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e74dc11baf9ab4824cab5e190fd8ae97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a412a5ea698edcf861bd5c8ce8bc31f/" rel="bookmark">
			977.有序数组的平方 给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆排序代码 /** * Note: The returned array must be malloced, assume caller calls free(). */ int* sortedSquares(int* A, int ASize, int* returnSize){ int bucket[10001]; memset(bucket, 0, sizeof(int)*10001); for(int i=0;i&lt;ASize;i++) { if(A[i]&lt;0) A[i] = -1 * A[i]; bucket[A[i]]++; } int *answer, count = 0; answer = (int*)malloc(sizeof(int) * ASize); for(int i=0;i&lt;10001;i++) { if(bucket[i]&gt;0) { while(bucket[i]!=0) { answer[count] = i * i; bucket[i]--; count++; } } } *returnSize = ASize; return answer; } 基本思路 先将数组中负数转化为正数，进行桶排序，输出其平方。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a412a5ea698edcf861bd5c8ce8bc31f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582bbb83cd8a53ddb9950908f8100257/" rel="bookmark">
			TortoiseGit的介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git是什么，相信大家都很清楚。Git不就是分布式版本控制系统嘛？那你知道TortoiseGit是什么吗？下面我们就介绍一下TortoiseGit它是什么？如何使用？
TortoiseGit其实是一款开源的git的版本控制系统，也叫海龟git。TortoiseGit提供了人性化的图形化界面，不用像Git一样输入许多语句，像git init、git add、git commit这些语句就通通不用记了。轻松使用鼠标，就可以完成代码的提交和上传。对于使用本地Git的新手来说，TortoiseGit更加简便，更加容易上手。
Git的流程分为一个大循环和一个小循环。工作区就是我们一开始文件所存在的区域，然后选择添加文件后，文件就进入了暂存区，选择提交文件后，文件就进入了本地仓库，这是一个小循环。当从远程仓库拉取代码时，代码会直接拉取到工作区，然后我们要添加、提交，然后才可以把拉取的代码放入本地仓库，本地仓库的代码可以通过推送，推送到远程仓库，这是一个大循环。
下面我用TortoiseGit来演示一些我们常用的git操作。
创建仓库
添加、提交文件到本地仓库
新建一个111.txt文件，点击添加
成功添加后，文件变成蓝色字样
选择文件，点击提交
输入提交的信息后，点击提交
提交成功后，文件变成绿色字样
当文件被修改后，文件变成红色字样
查看、回溯历史版本
多次提交后，我们可以查看每次提交的信息，并且可以选择版本进行回溯
选择需要追溯的版本
选择切换版本，把文件还原到之前的版本
还原误删文件
当把已经提交的文件误删了，可以进行还原
上传、下载文件
在这里输入你的仓库的https连接
点击推送，可以上传文件；点击拉取，可以下载文件
在推送和拉取文件时，可能会出现冲突。什么是冲突呢，就是你远程仓库的代码发生了改变，也就是你本地仓库的代码并不是最新的代码。举个例子，学生项目由A和B共同开发，此时的代码是1版本。A拉取了远程仓库1版本的代码，然后B也拉取了，B修改了代码然后重新上传到远程仓库，此时是2版本。然后A修改了，A想上传代码，发现冲突了，原因是A依靠的是1版本的代码进行了修改，而此时远程仓库的代码是2版本，这样当然会产生冲突。
解决冲突的办法就是，先把远程仓库的2版本的代码进行拉取，然后TortoiseGit会列出冲突的文件代码，然后自己手动解决、选择自己需要的代码，右键选择解决冲突，最后再重新上传就可以了。
创建、切换、合并分支
我们先解释一下分支的概念，一开始的分支是master分支，master分支是创建仓库时自动创建的分支，也是默认分支。Git通过HEAD指针的指向，来查看当前是哪个分支。master指针指向的是master分支，当master分支版本更新的时候，master指针就会后移，指向最新版本。
假如我们新创建了一个dev分支，新创建的分支一开始是和当前的master分支的版本内容都是一样的。我们切换到dev分支，HEAD指针也会指向dev分支。
不同分支之间的开发，是并行开发，互不影响的。我们也可以对分支进行合并，这叫做合并分支，把两个不同分支合并起来。
下面我们来演示一下具体操作。
创建分支
切换分支
合并分支：选择分支与当前分支合并，合并后的分支为当前分支
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c7022b63e960b7984e6df7077b69b6e/" rel="bookmark">
			使用freeshd连接，提示Permission denied, please try again
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载安装好freeshd，一路默认就好
2.配置ssh，选用本机ip
3.配置Authentication ，password选required，Public Key选disabled
4.sftp自己根据需要设置根目录
5.User添加用户，选用password登录
配置好启动
1.提示“The sepcified address is already in use”，
原因：安装freeshd的时候，会有提示是否开机启动，选择是后sshd会自动启动，22端口被占用，打开任务管理器，关闭服务，重新启动就可以了。
2.使用sftp admin@127.16.100.248测试登录提示Permission denied, please try again.
原因：在authentication中 将Password那项选为required 将public key选为disable，设置好重启服务，还是不行，原因是因为 windons 上运行 freesshd 没以管理员权限运行，关闭服务，以管理员身份运行，连接成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/912126497aab4d110c545573ae785b1d/" rel="bookmark">
			【API、匿名对象、ArrayList类】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【API、匿名对象、ArrayList类】 API的概述及使用步骤 **API：**Application Programming Interface.应用程序编程接口。Java API是一本程序员的字典，是JDK 中提供给我们使用的类的说明文档，这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。
API使用步骤 1.打开帮助文档；2.点击显示，找到索引，看到输入框；3.你要找谁？在输入框里输入，然后回车；4.看包。Java.lang下的类不需要导包，其他需要；5.看类的解释和说明；6.学习构造方法；7.使用成品方法。 Scanner类的概述及其使用步骤 引用数据类型一般使用步骤：
1.导包 import 包名称.类名称; 如果需要使用的目标类，和当前类位于同一包下，则可以省略导包语句不写；只有java.lang包下的内容不需要导包，其他的包都需要import语句。 2.创建 类名称 对象名 = new 类名称（参数（如有））; 3.使用 对象名.成员方法名（）; Scanner是一个可以解析基本类型和字符串的简单文本扫描器。
例如：以下代码使用能够从 System.in 中读取一个数：
import java.util.Scanner;//1.导包 public class MyScanner { public static void main(String[] args) { //2.创建Scanner类的实例对象sc Scanner sc = new Scanner(System.in);//System.in系统输入指的是通过键盘录入数据 //3.获取键盘输入的int数字 int l = sc.nextInt();//使用，赋值调用 System.out.println("输入的数字是"+num); //4.获取键盘输入的字符串 String str = sc.next();//使用，赋值调用 System.out.println("输入的字符串是"+str); } } tips：sc.next()相当于把输入的字符串直接作为返回值，sc.nextInt()相当于把输入的字符串转化为int数据类型然后作为返回值。
匿名对象的说明 创建对象的标准格式：
类名称 对象名 = new 类名称（）；
匿名对象就是只有右边的对象，没有左边的名字和赋值运算符：
new 类名称（）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/912126497aab4d110c545573ae785b1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a1d804289211cb57d38d52a9c222e2/" rel="bookmark">
			Ubuntu下监视 NVIDIA 显卡状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在终端输入：
watch nvidia-smi 如果想设置刷新时间可用以下命令（下面设置每10秒刷新一次）
watch -n 10 nvidia-smi 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86958d62a911e30281bb18eb99a30b86/" rel="bookmark">
			[翻译] [Overleaf] LaTeX 中的粗体、斜体、下划线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原 文：Bold, italics and underlining
译 者：Xovee
翻译时间：2020年5月25日
LaTeX 中的粗体、斜体、下划线 在一个文档中，简单的文字排版可以对某些概念进行重点描述，增强其可读性。使用粗体、斜体、或者下划线，可以带给读者不同的感觉。
文章目录 LaTeX 中的粗体、斜体、下划线介绍斜体粗体下划线强调文字延伸阅读 介绍 在这篇文章中，我们将会学习三种不同的基础文字排版：斜体、粗体、下划线。让我们首先看一个例子：
Some of the \textbf{greatest} discoveries in \underline{science} were made by \textbf{\textit{accident}}. 你可以看到，我们使用了三种基础指令，它们可以互相嵌套来产生不同的效果。注意：命令\it和\bf也可以用来生成粗体、斜体，不过我们并不推荐使用它们，因为它们不能处理文字之前的样式。这意味着，你不能同时定义一个粗斜体。
在Overleaf中打开这个例子。
斜体 使用斜体是非常简单的，使用\emph或者\textit命令：
Some of the greatest discoveries in science were made by \emph{accident}. 在Overleaf中打开这个例子。
粗体 使用\textbf指令来对文字进行加粗：
Some of the \textbf{greatest} discoveries in science were made by accident. 在Overleaf中打开这个例子。
下划线 使用\underline来对文字添加下划线：
Some of the greatest discoveries in \underline{science} were made by accident.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86958d62a911e30281bb18eb99a30b86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4de944ffe0042f6f53279c39f124ca21/" rel="bookmark">
			LaTeX 中的段落和换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原 文：Paragraphs and new lines
译 者：Xovee
翻译时间：2020年5月24日
LaTeX 中的段落和换行 LaTeX 默认的排版已经是很好的了，不过我们有时候也需要一些定制化。本篇文章将会告诉你如何排版段落、改变文字对齐、以及添加空白的行。
文章目录 LaTeX 中的段落和换行介绍新段落段落对齐（文字对齐）段落缩进延伸阅读 介绍 让我们用一个例子开始：
\begin{center} Example 1: The following paragraph (given in quotes) is an example of Center Alignment using the center environment. ``LaTeX is a document preparation system and document markup language. LaTeX uses the TeX typesetting program for formatting its output, and is itself written in the TeX macro language. LaTeX is not the name of a particular editing program, but refers to the encoding or tagging conventions that are used in LaTeX documents"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4de944ffe0042f6f53279c39f124ca21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec44389ce12dce6221c688f910ca1827/" rel="bookmark">
			MXNET深度学习框架-29-语义分割(FCN)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语义分割计算机视觉领域中的一个重要模块，它与之前的图像分类、目标检测任务不同，它是一个精细到每个像素块的一个图像任务，当然，它包括分类和定位。更多关于语义分割的方法和原理请读者自行搜索相关论文和博文，本文不做过多阐述。
1、数据集
在计算机视觉领域，Pascal VOC 2012 数据集是比较经典的，该数据集包含了目标检测、对象分割的数据及相关标签，本文使用的语义分割数据集就是来自于VOC2012。首先，需要下载该数据集：官网下载链接，注意，该数据集大概有2个G的大小，建议提前下载。
2、读取数据集
写一段程序来读取并显示一下相关数据图片及其标签：
def show_images(imgs, num_rows, num_cols, scale=2): """Plot a list of images.""" figsize = (num_cols * scale, num_rows * scale) _, axes = plt.subplots(num_rows, num_cols, figsize=figsize) for i in range(num_rows): for j in range(num_cols): axes[i][j].imshow(imgs[i * num_cols + j].asnumpy()) axes[i][j].axes.get_xaxis().set_visible(False) axes[i][j].axes.get_yaxis().set_visible(False) plt.show() root='F:/test/VOC2012_dataset/VOCtrainval_11-May-2012/VOCdevkit/VOC2012' # 1、将训练图片和标注图标读进内存 def read_images(root,train=True): if train: txt_fname=root+"/ImageSets/Segmentation/train.txt" else: txt_fname = root + "/ImageSets/Segmentation/val.txt" with open(txt_fname,'r') as f: images=f.read().split() features, labels = [None] * len(images), [None] * len(images) for i, fname in enumerate(images): features[i] = image_deal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec44389ce12dce6221c688f910ca1827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efe2dcd56506821cb747dbf98ba5a7ba/" rel="bookmark">
			图形类设计——c&#43;&#43;圆、矩形、三角形类的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目要求：
设计三个图形类：Circle（圆）、Rectangle（矩形）、Triangle（三角形）；
1、Cirlce 类基本信息：圆心坐标、半径；
Rectangle 类基本信息：长、宽；
Triangle 类基本信息：三个顶点坐标；
其中：成员变量为 private 属性，成员函数为 public 属性；
2、每个图形类有多个构造函数：缺省构造函数、带参数的构造函数；
3、每个图形类有计算图形的面积 GetArea()，显示图形的基本信息函数 Show()，修改基
本信息的函数 Set(形参)。以 Circle 类为例：通过 GetArea()计算圆的面积，Show()函数中显
示圆心坐标、直径、周长、面积等基本信息；Set(int x,int y, int r)函数可以修改圆心坐标和半
径。
这是我们学校的一道作业，其中有很多构造函数在测试用例上是用不到的，如果想调用编写好的构造函数还要在main函数那里进行一些修改。不过代码的大体上已经实现题目的要求了。
#include &lt;iostream&gt; #include&lt;cmath&gt; #define PI 3.14 using namespace std; class Cirlce { public: Cirlce() { x = 0; y = 0; r = 1; } Cirlce(float r0) { x = 0; y = 0; r = r0; } Cirlce(float x0, float y0, float r0) { x = x0; y = y0; r = r0; } float GetArea(); void c_show(); void c_set( float x0, float y0, float r0); private: float x; float y; float r; }; float Cirlce::GetArea() { return PI * r * r; } void Cirlce::c_show() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efe2dcd56506821cb747dbf98ba5a7ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adfc1e4ef89d151b4c38946cec4edf80/" rel="bookmark">
			使用yolo对图片,视频,连接相机进行物体检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近要用yolov4进行物体检测,把其中的一些问题写下来,
首先按照要求安装yolov4需要的各种东西opencv,cudnn,cuda版本等等,去官网学习怎么安装,然后将源码下载下来编译,将makefile里要用的改为=1,然后make,下载对应的权重weight
一.终端输入命令检测:
在终端运行:以下的v3也可以用v4的权重
1.检测视频MP4或者avi
./darknet detector demo cfg/coco.data cfg/yolov3.cfg yolov3.weights &lt;filename…&gt;
2.网络相机实时检测
./darknet detector demo cfg/coco.data cfg/yolov3.cfg yolov3.weights rtsp://admin:password@192.168.1.64(相机ip地址),这种方法的延迟很严重
3.检测示例图片
./darknet detect cfg/yolov3.cfg yolov3.weights data/giraffe.jpg(路径加图片名称)
二.调用Python脚本实时检测
更改darknet_video.py里的line82/83,根据需要选择是读取视频还是相机实时检测,注释不要的那一行;
运行ls /dev/video*看USB接口的相机是第几个,一般0代表
用自带Python运行检测,更改括号里面的数字,0一般代表笔记本前置摄像头,1和2代表其他相机摄像头;
如果搞不清要写几,终端运行ls /dev/video*.我的会出来/dev/video0 /dev/video1 /dev/video2
三个, 不知道为什么那么多,我把参数改为2就可以调用usb口的摄像头,但是我要连接网络相机(网线接口),暂时还没搞出来怎弄.
终端输入运行python darknet_video.py
有时候会报错,换成python3 darknet_video.py
然后也许还有错(python:10196): GStreamer-CRITICAL **: gst_caps_get_structure: assertion ‘index &lt; GST CAPS LEN (caps)’ failed
改一下这个
给cv2.so改个名字
cd /opt/ros/kinetic/lib/python2.7/dist-packages/
sudo mv cv2.so cv2_ros.so
因为可能安装Python和cv的时候有弄混的情况,根据情况改
如果视频卡顿,更改yolov3.cfg/yolov4.cfg里的width和height,改小一点416足够(32的倍数);
Python脚本运行实时检测网络摄像头更新
用yolo实时调用海康威视云台相机进行物体检测用自带Python脚本运行
将前面的 更改darknet_video.py里的line82/83,改为
cap = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adfc1e4ef89d151b4c38946cec4edf80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b4846a966347c080f9c1261c30c5e4/" rel="bookmark">
			基于AutoJs的抖音短视频养号Apk文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：https://pan.baidu.com/s/1hp7kJaFmmFe1_V2HPMuubw 提取码：o7r7
为啥要养号：
1、提高账号得权重，保证发个视频系统会推荐（成为热门得质量高，或者找个工作室给你点赞关注）。
2、让抖音短视频平台觉得你是一个正常的号码，评论成为热评的概率高。
养号的步骤：
1、每天稳定登陆持续一周。
2、刷首页推荐、刷同城推荐、看直播总计时间30分钟就好。
3、翻一翻抖音的热搜榜单、挑战。
4、关注几个自己喜欢的账号。（偶尔看一下推荐）
5、无论是首页、推荐、同城、直播均需要点赞和评论切记要看完后点赞评论。
养号七宗罪：
1、来回切换手机，或者在同一个手机上多个抖音号。
2、个人信息要稳定。
3、发的视频要专一，切记抖音不是朋友圈。（你要当朋友圈也行）
4、大量点赞，甚至很多视频不看完就赞。
5、发第一个视频不要使用wifi要用4G。
6、养号的一周内不要发视频。
7、不用wx和QQ登录，更不要再抖音上留wx号
把整体代码都更新了一下，
增加了贝塞尔曲线滑动屏幕，
将控制台放到中间位置，
增加自定义评论内容，（以前评论内容是系统预定义的）
另外还单独搞了一个小米手机版，小米手机比较特殊。
贝塞尔曲线代码：
链接：https://pan.baidu.com/s/1hp7kJaFmmFe1_V2HPMuubw 提取码：o7r7
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/168/">«</a>
	<span class="pagination__item pagination__item--current">169/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/170/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>