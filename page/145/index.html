<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/099c3605b812265ca5ac5a3ecab6485e/" rel="bookmark">
			linux下root切换普通用户,linux之普通用户与root用户之间切换方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux之普通用户与root用户之间切换方法
如下所示：
以上就是小编为大家带来的linux之普通用户与root用户之间切换方法全部内容了，希望大家多多支持我们~
时间： 2016-12-22
1. 首先进入单用户模式: 1). ubuntu : 上述情况可以在grub界面选择第二项修复,但没有grub可以参考: 1.重启ubuntu,随即长按shirft进入grub菜单: 2.选择recovery mode,按"e"键进入编辑页面:如下: 非恢复模式为: 3.将ro recovery nomodeset替换为"rw single init=/bin/bash" (上述的界面中将改为rw single init=/bin/bash) 4.按ctrl+x
一.概述 为禁止普通用户su至root,需要分别修改/etc/pam.d/su和/etc/login.defs两个配置文件. 二.详细配置 (1)去除/etc/pam.d/su文件中如下行的注释: #auth required pam_wheel.so use_uid (2)在/etc/login.defs文件中加入如下配置项: SU_WHEEL_ONLY yes 经过上述配置后,普通用户将被禁止su至root,如果希望指定普通用户su至root,可以执行如下命令将该用户添加至wheel组中:
[root@ok ~]# vim /etc/pam.d/su 下面是/etc/pam.d/su文件的内容 #%PAM-1.0 auth sufficient pam_rootok.so # Uncomment the following line to implicitly trust users in the "wheel" group. #auth sufficient pam_wheel.so trust use_uid # Uncomment the following lin
问题假设用户名为:ali如果用户名没有超级用户权限,当输入 sudo + 命令 时, 系统提示: 复制代码 代码如下: ali is not in the sudoers file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/099c3605b812265ca5ac5a3ecab6485e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e61336bf26652a967333504e5744ab73/" rel="bookmark">
			linux rm命令 安装,Linux rm 命令 command not found rm 命令详解 rm 命令未找到 rm 命令安装 - CommandNotFound ⚡️ 坑否...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示行号
|
选择喜欢的代码风格
默认
GitHub
Dune
LakeSide
Plateau
Vibrant
Blue
Eighties
Tranquil
rm 命令用于删除给定的文件和目录。rm 删除命令行上指定的每个文件。 默认情况下，它不会删除目录。这不像是在 Windows 回收站中添加内容; 一旦你是一个文件或目录，就无法撤消它。当使用 -r 或 -R 选项执行 rm 时，它会递归删除任何匹配的目录，它们的子目录以及它们包含的所有文件。
rm 命令安装：
-bash: rm: command not found
#Debian
apt-get install coreutils
#Ubuntu
apt-get install coreutils
#Alpine
apk add coreutils
#Arch Linux
pacman -S coreutils
#Kali Linux
apt-get install coreutils
#CentOS
yum install coreutils
#Fedora
dnf install coreutils
#OS X
brew install coreutils
#Raspbian
apt-get install coreutils
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e61336bf26652a967333504e5744ab73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ca0296bc37df04c9a09059df46917b/" rel="bookmark">
			腾讯云轻量云服务器体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建议直接在我的博客中阅读，有更好的排版，点击进入：https://www.xuxusheng.com 最近云服务器要到期了，但是续费就不能再用新用户优惠了。
考虑到我已经将所有的服务都迁移到了家里的小机器上，云服务器只是起到一个流量入口的作用，所以并不需要太好的配置。
这时候就需要选择一款配置一般、带宽足够、价钱便宜的云服务器了，正好腾讯云轻量云服务器有新用户优惠，完美。
过程记录一下，下次再过期的时候就可以不用动脑啦。
传送门，点击这里直接查看：
【腾讯云】轻量应用服务器Lighthouse，新朋友「轻」松上云，老朋友免费加「量」，1核2G5M限时低至99元/年起
一、购买 1核2G5M 的配置完美符合了我只需要一个便宜点的流量入口的需求，这里需要注意第一次购买的时候是优惠价 99 一年，后期续费就恢复成原价了，建议一次购买 3 年。
等待一会儿就能在控制台看到机器啦。
二、系统配置 1. 密码重置 服务器初始化好之后，会自动创建 ubuntu 和 lighthouse 两个用户，后者用于在网页中远程登录时使用。
首先在网页控制台中将 ubuntu 和 root 密码进行重置，由于系统默认禁止了 root 用户通过密码远程 ssh 登录，所以我们先使用 ubuntu 用户登录，然后通过 su 命令切换到 root 用户。
2. 修改默认编辑器 将系统默认编辑器修改为 vim。
使用 update-alternatives --config* editor 命令，并输入相应的编号即可。
3. vim 配置 默认的 vim 配置并没有开启一些高亮缩进之类的功能，不怎么方便使用。
参考：https://github.com/amix/vimrc
既然是作为服务器使用，那么选择其中的 basic 方案就行了。
将此文件 https://github.com/amix/vimrc/blob/master/vimrcs/basic.vim 内容复制到 ~/.vimrc 中即可。
4. 用户创建 不建议使用 root 用户进行操作，这里我们创建一个新的 work 用户。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59ca0296bc37df04c9a09059df46917b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b34cb2ed32da4b592a205add2bf385/" rel="bookmark">
			RealSR真实场景超分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Camera Lens Super-Resolution 本文主要解决RealSR的数据问题，通过控制镜头到物体的距离产生成对的真实数据（Real paired SR data）。
（1）出发点 现有的超分方法通常采用合成退化模型，如双三次（Bicubic）或高斯降采样。
（2）主要工作 本文主要从真实成对数据获取方面解决RealSR问题。
为缓解现实成像系统中分辨率R和视场V之间的内在权衡，利用相机镜头的R-V退化，用于现实成像系统中的SR建模。创建City100数据集，包含两种新的获取LR-HR图像对的策略，分别用来描述在单反相机和智能手机相机下的R-V退化。利用实际数据对常用的综合退化模型进行定量分析。一种有效的解决方案，即CameraSR，在现实成像系统中推广现有的基于学习的SR方法。
二、Zoom to Learn, Learn to Zoom 本文主要解决RealSR的数据问题，通过控制相机变焦，产生成对的真实数据（Real paired SR data）。
（1）主要工作 使用真实的高比特传感器数据进行计算缩放，相比于处理过的8位RGB图像或合成传感器模型更有效。创建新的数据集，SR-RAW，他是第一个从原始数据超分辨率的数据集，具有光学地面真理。SR-RAW使用变焦镜头拍摄。用长焦距拍摄的图像作为较短焦距拍摄的图像的光学真实。提出了一种新的上下文双边损失(CoBi)处理轻微失调的图像对。
CoBi通过加权空间意识来考虑局部上下文相似性。 （2）不同焦距产生的图像 （3）数据对齐问题（Misalignment Analysis） （B1）角度偏差；（B2）景深偏差；（B3）对齐偏差
为解决以上问题，本文提出上下文双边损失（Contextual Bilateral Loss）。
三、Toward Real-World Single Image Super-Resolution: A New Benchmark and A New Model （ICCV2019） 详细介绍 （1）主要工作 本文通过镜头变焦+图像配准建立数据集RealSR。提出拉普拉斯金字塔核预测网络（Laplacian pyramid based kernel prediction network (LP-KPN)）解决RealSR问题。 （2）数据收集 物距、像距、焦距示意图：
图像配准
为了获得精确的图像对配准，本文设计了一种同时考虑亮度调整的像素级配准算法（pixel-wise registration algorithm ）。 （3）KPN结构 分三层进行核（kernel）预测，目的是减少计算量、增大感受野。
四、Frequency Separation for Real-World Super-Resolution（ICCV2019） 本文利用GAN合成跟接近于真实场景下的LR-HR图像对，然后利用该数据训练SR模型，在Real-World数据上获得了较好的重建结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60b34cb2ed32da4b592a205add2bf385/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f870481342abf4d2a3589f10ef7da3/" rel="bookmark">
			linux下jcmd命令没找到,Linux exec 命令 command not found exec 命令详解 exec 命令未找到 exec 命令安装 - CommandNotFound ⚡️ ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示行号
|
选择喜欢的代码风格
默认
GitHub
Dune
LakeSide
Plateau
Vibrant
Blue
Eighties
Tranquil
exec 命令调用并执行指定的命令。
exec 命令安装：
-bash: exec: command not found
#Debian
apt-get install execline
#Ubuntu
apt-get install execline
#Alpine
apk add execline
#Kali Linux
apt-get install execline
#Fedora
dnf install R-core
#Docker
docker run cmd.cat/exec exec
exec 命令补充说明：
exec 命令用于调用并执行指令的命令。exec 命令通常用在 Shell 脚本程序中，可以调用其他的命令。如果在当前终端中使用命令，则当指定的命令执行完毕后会立即退出终端。
exec 命令语法：
exec [-cl] [-a name] [command [arguments]]
exec 命令选项：
-c：在空环境中执行指定的命令。
-l：在传递给command的第零个arg的开头放置一个破折号。
(这是login程序的工作。)
-a：Shell将name作为第零个参数传递给command。
exec 命令参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69f870481342abf4d2a3589f10ef7da3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a83726770e96bf1438e39546194c6116/" rel="bookmark">
			linux 查找木马文件,Linux木马pscan2查找与清除步骤，linuxpscan2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux木马pscan2查找与清除步骤，linuxpscan2
这篇文章主要介绍了Linux木马pscan2查找与清除步骤,需要的朋友可以参考下
一、现象
AH现场的程序是分布式部署，除了程序的配置文件不同外，并无其他不同。最近地市sz频繁发生工单处理错误的故障，而其他地市运行一直很稳定。
二、 因此，对sz的主机进行了检查，步骤如下：1、重启应用，发现应用的端口3456已经被占用，通过命令 lsof -i:3456 ，发现是用户tel的进程占用了该端口。
2、通过命令ps，发现用户tel的进程熟非常多，但在我们的系统中，并未创建过用户tel。
3、使用top命令，结果如下：
top - 09:58:54 up 524 days, 14:31, 4 users, load average: 3.44, 4.98, 5.75
Tasks: 1715 total, 7 running, 1699 sleeping, 0 stopped, 9 zombie
Cpu(s): 23.3% us, 12.3% sy, 0.0% ni, 64.4% id, 0.0% wa, 0.0% hi, 0.0% si
Mem: 4147208k total, 2740256k used, 1406952k free, 23976k buffers
Swap: 4079600k total, 779100k used, 3300500k free, 638748k cached
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a83726770e96bf1438e39546194c6116/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eceef4d0c936a31d08c33bce9423eda9/" rel="bookmark">
			linux重启网卡的命令行,linux系统怎么重启网卡？linux重启网卡的三种教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际工作中，经常会遇到Linux系统进行重启网卡的操作。在这里整理一下，进行多种方法的网卡重启。
一、service network restart
1、首先用CRT工具连接到Linux命令行界面。 或者进入操作系统界面，选择终端输入。
2、如果我们对所有的网卡进行重启操作。 可以尝试输入：service network restart 命令进行操作。
3、样就完成了用service network restart命令重启网卡的操作。
二、ifconfig eth0 down / ifconfig eth0 up
1、连接到命令行界面，输入ifconfig查看网卡的基本信息。
2、查看到eth3的网卡信息。 输入ifconfig eth3 down ,卸载eth3网卡。
3、输入ifconfig eth3 up,重新加载eth3网卡。
三、ifdown eth0 / ifup eth0
1、连接到命令行界面。输入ifdown eth3,对网卡eth3进行卸载。
2、输入ifup eth3,对网卡eth3进行重新加载。
3、这样就完成了对网卡的重启操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5f848adfee6bff71e66d7055667747/" rel="bookmark">
			linux 父子进程结束,Linux下让父进程结束后，子进程自动结束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在多进程编程的时候，经常会遇到这样的情况。父进程创建了一堆子进程，当遇到错误或者操作失误的时候把父进程关闭了，但是子进程还在跑，不得不一个一个地杀死子进程，或者使用ps,grep,awk,kill来配合批量杀死。
之前在写 xxfpm(一个PHP-CGI的进程管理) 的时候，在Linux下使用父进程给子进程信号通知的方式来达到用户杀死父进程时，子进程也随即关闭。但是这种方法不太完美。例如，如果父进程被KILL信号杀死，完全没有机会给子进程发送信号了。
在网上搜了一下，用Linux下libc的prctl设置PR_SET_PDEATHSIG属性，似乎可以让子进程在父进程自动结束后接收到信号。这个方法似乎很完美！！！
PR_SET_PDEATHSIG (since Linux 2.1.57)
Set the parent process death signal of the calling process to arg2
(either a signal value in the range 1..maxsig, or 0 to clear). This is
the signal that the calling process will get when its parent dies.
This value is cleared for the child of a fork(2).
测试代码：
view plaincopy to clipboardprint?
01.#!/usr/bin/env python
02.
03.import os
04.import ctypes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd5f848adfee6bff71e66d7055667747/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e3ef454ae54463c15c52ba4baeead0/" rel="bookmark">
			React Ts 项目配置 Axios
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React Hooks Ts Axios React项目Ts版，使用Hooks API。本示例主要是配置Axios并使用Eggjs写了两个接口进行测试。
主要看 ./src/api 和 ./src/model 目录。
├── src │ ├── api │ │ ├── api.ts │ │ └── status.ts │ ├── model │ │ └── login.ts ./src/api/api.ts
import axios, {AxiosInstance, AxiosRequestConfig, AxiosResponse} from 'axios'; import qs from 'qs' import { showMessage } from "./status"; import { message, Spin } from 'antd'; import { ILogin, IUser } from 'model/login'; // 返回res.data的interface export interface IResponse { code: number | string; data: any; msg: string; } let axiosInstance:AxiosInstance = axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28e3ef454ae54463c15c52ba4baeead0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f517e39512e5011392208589141d1b11/" rel="bookmark">
			PE文件格式（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 PE文件是Windows操作系统下使用的可执行文件格式
PE文件指的是32位的可执行文件，也称作PE32；64位的可执行文件称作PE+或PE32+（注意不是PE64），这是PE文件的一种扩展形式。
PE文件种类
可执行系列：EXE、SCR
驱动程序系列：SYS、VXD
库系列：DLL、OCX、CPL、DRV
对象文件系列：OBJ
除了OBJ之外的文件都是可执行的，有些虽然不能直接在Shell（Explorer.exe)中运行，但是可以使用调试器等来运行。不过，根据PE文件规范，OBJ也是做是PE文件 （虽然它确实是文件本身不能以任何形式执行）。
由于文件运行的所以信息，诸如如何加载到内存，何处开始运行以及运行中需要的DLL和多大的堆栈内存等都以结构体的形式存储在PE头中，故而，学习PE文件格式就是学习PE头中的结构体。
PE文件基本结构
从DOS头到节区头（Section header）是PE头部分，其下的节区合称PE体。
文件中使用偏移（offset），内存中使用虚拟地址（VA）来表示位置。
文件的内容一般可以分为代码（.text）、数据（.data）、资源（.rsrc）节，分别保存。各个节区头定义了各节区在文件或内存中的大小、位置、属性等等。
PE头与各节区的尾部存在NULL填充，因为文件/内存中节区的起始位置应该在各文件/内存最小单位的倍数位置上，空白区域将用NULL填充。
VA&amp;RVA
VA指的是进程虚拟内存的绝对地址，RVA（相对虚拟地址）指的是从某个基准位置（ImageBase）开始的相对地址。
RVA+ImageBase=VA PE头内部信息大多是以RVA形式存在，因为重定位的原因。
PE头 DOS头 PE头的最前面添加了一个IMAGE_DOS_HEADER结构体，用来扩展已有的DOS EXE头
IMAGE_DOS_HEADER结构体的大小为40个字节，结构体中有两个重要成员
e_magic:DOS签名（4D5A–&gt;ASCII值“MZ”）
e_lfanew:指示NT头的偏移（根据不同文件拥有可变值）
我们把记事本拖进WinHEX看一看
64字节（共4行）的DOS头，第一个成员两个字节是可执行文件的标志信息；最后一个成员4字节是PE头的偏移地址为000000F8H，我们可以根据000000F8H来获取PE头的地址。
可见开头的e_magic：MZ，以及e_lfanew的值为000000F8（因为Intel系列的CPU以逆序存储数据，小端序）
这里说一下为什么MZ没有倒着读
再写PE文件查看器的时候，根据Windows的宏定义
IMAGE_DOS_SIGNATURE = 0x5A4D 所以查看的时候自己倒过来了成了4D 5A，故而我们直接读MZ作为标志就行了
DOS存根 DOS存根在DOS头下方，是个可选项，即使没有，文件也能够运行，它的大小不固定
可以利用DOSBOX运行这段-u查看汇编指令
NT头 NT头IMAGE_NT_HEADERS
这个结构体由3个成员组成，第一个是签名，值为50450000H（“PE”00），另外两个分别是文件头和可选头
IMAGE_NT_HEADERS结构体大小为F8
文件头 文件头是表现文件大致属性的IMAGE_FILE_HEADER结构体
它有4类重要成员，如果它们设置的不正确，将导致文件无法正常运行
包括PE头在内的24个字节
Machine
每个CPU都有唯一的Machine码，不同的表示可以运行在什么样的CPU上
兼容32位Intel x86 的是14C x64:8664
关于CPU型号的疑惑看这里
64位 winhex 打开如下图为 8664，即为 x64程序。
NumberOfEsctions
NumberOfEsctions指文件中存在的节区数量，也就是节表中的项数。该值一定要大于0，且当定义的节区数与实际不符时，将发生运行错误。
值为 0070，代表有 7 个节表
SizeOfOptionalHeader
SizeOfOptionalHeader用来指出IMAGE_OPTIONAL_HEADER32结构体的长度。PE装载器需要查看SizeOfOptionalHeader的值，从而识别IMAGE_OPTIONAL_HEADER32结构体的大小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f517e39512e5011392208589141d1b11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bada1824f088ee067d7c219b0cd398a5/" rel="bookmark">
			Zmapv6源码安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Zmapv6 首先上代码， git官网的源码缺少v6模块，当时看的md里写的支持v6，结果src下根本没有对应的module，后来找了好久发现就是缺少，在这个链接下才有v6的探测模块：
第二家zmap. 然后按照说明书，首先安装依赖，cmake、build-essential之类的，我是用的Ubuntu18.04，反正apt装的时候会报错，显示依赖包冲突的，这个没关系，采取aptitude来解决依赖问题。
报错代码已经被zmap刷掉了，问题出现在’cmake .’ 这一步，预编译的时候报错，显示cmake error 2，经查这个意思是我的源代码里报错。
这时我心想全世界用的一份代码不可能啊，结果是自己的系统缺少头文件，依次少的是，unistr.c、unistr.h、pcap/pcap.h，这几个头文件一般是编译依赖库安装时配置好的，但是因为我们刚才依赖问题解决出错，因此没有安装成功，这时使用aptitude来解决依赖问题。
unistr.c、.h是libunistring-dev库下的，直接
sudo aptitude install libunistring-dev 这里别选错了，当前默认的选项是直接忽略依赖，不对这个dev进行安装，因此需要调整为n：
同上，安装pcap.h同上，此处安装的库为libpcap-dev
sudo apt-get install libpcap-dev 我的cmake只报了这两次错误，如有类似的，查看cmake报错信息，针对性的解决即可。
接着对zmap编译即可完成安装：
cmake . sudo make -j4 sudo make install 检验成功与否 运行一次zmap即可：
zmap --bandwidth=10M --target-port=80 --max-targets=10000 --output-file=results.csv 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c0352669679a72880f74e627d54436/" rel="bookmark">
			kali更新源失败解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kali更新源失败 哪怕是更换了多家的镜像站，但是依旧失败，并且etc/apt/source.list.d下并无文件 而后搜寻资料，得知可以通过更新本地虚拟机内的密钥来解决此问题：
show u the code：
sudo apt-key adv --keyserver hkp://keys.gnupg.net --recv-keys 7D8D0BF6 或者新的办法，来自博客里大佬的启发：
wget -q -O - https://archive.kali.org/archive-key.asc | apt-key add 参考资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f4703c45bf2ce3f19de623ff8b5800/" rel="bookmark">
			冯诺依曼结构、哈佛结构、改进型哈佛结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冯诺依曼结构
冯·诺依曼结构，又称为普林斯顿体系结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。取指令和取操作数都在同一总线上，通过分时复用的方式进行；缺点是在高速运行时，不能达到同时取指令和取操作数，从而形成了传输过程的瓶颈。由于程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同。
冯·诺依曼结构处理器具有以下几个特点：
必须有一个存储器；
必须有一个控制器；
必须有一个运算器，用于完成算术运算和逻辑运算；
必须有输入和输出设备，用于进行人机通信。
冯·诺依曼的主要贡献就是提出并实现了“存储程序”的概念。由于指令和数据都是二进制码，指令和操作数的地址又密切相关，因此，当初选择这种结构是自然的。但是，这种指令和数据共享同一总线的结构，使得信息流的传输成为限制计算机性能的瓶颈，影响了数据处理速度的提高。
在典型情况下，完成一条指令需要3个步骤，即：取指令、指令译码和执行指令。从指令流的定时关系也可看出冯·诺依曼结构与哈佛结构处理方式的差别。举一个最简单的对存储器进行读写操作的指令，指令1至指令3均为存、取数指令，对冯·诺依曼结构处理器，由于取指令和存取数据要从同一个存储空间存取，经由同一总线传输，因而它们无法重叠执行，只有一个完成后再进行下一个。
例如最常见的卷积运算中， 一条指令同时取两个操作数， 在流水线处理时， 同时还有一个取指操作， 如果程序和数据通过一条总线访问， 取指和取数必会产生冲突， 而这对大运算量的循环的执行效率是很不利的。
哈佛结构
哈佛结构是一种将程序指令存储和数据存储分开的存储器结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问，目的是为了减轻程序运行时的访存瓶颈。
哈佛结构能基本上解决取指和取数的冲突问题。
哈佛结构的中央处理器首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据，并进行下一步的操作（通常是执行）。程序指令储存和数据储存分开，数据和指令的储存可以同时进行，可以使指令和数据有不同的数据宽度，如Microchip公司的PIC16芯片的程序指令是14位宽度，而数据是8位宽度。
如果采用哈佛结构处理以上同样的3条存取数指令，由于取指令和存取数据分别经由不同的存储空间和不同的总线，使得各条指令可以重叠执行，这样，也就克服了数据流传输的瓶颈，提高了运算速度。
哈佛结构处理器有两个明显的特点：
(1).使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；
(2).使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。
改进型哈佛结构
改进型哈佛结构虽然也使用两个不同的存储器：程序存储器和数据存储器，但它把两个存储器的地址总线合并了，数据总线也进行了合并，即原来的哈佛结构需要４条不同的总线，改进后需要两条总线。
改进的哈佛结构，其结构特点为：
(1).使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；
(2).具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；
(3).两条总线由程序存储器和数据存储器分时共用。
改进型哈佛结构其结构特点为：
使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存，以便实现并行处理；
具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；
两条总线由程序存储器和数据存储器分时共用。
各结构对比分析
总结
总得来说，哈佛机构的高性能体现在在单片机、DSP芯片平台上运行的程序种类和花样较少，因为各个电子娱乐产品中的软件升级比较少，应用程序可以用汇编作为内核，最高效率的利用流水线技术，获得最高的效率。
冯诺依曼结构主要是基于电脑购买者对电脑的使用途径不同—-各种娱乐型用户、各种专业开发用户等，且安装的软件的种类繁多，升级频繁，多种软件同时运行时处理的优先级比较模糊，因特尔芯片不具备彻底智能分配各程序优先级和流水线的机制，机械的分配优先和流水线反而容易使用户不便。
冯氏结构简单、易实现、成本低，但效率偏低；哈佛结构效率高但复杂，对外围设备的连接与处理要求高，十分不适合外围存储器的扩展。现在的处理器，依托CACHE的存在，已经很好的将二者统一起来了。现在的处理器虽然外部总线上看是诺依曼结构的，但是由于内部CACHE的存在，因此实际上内部来看已经类似改进型哈佛结构的了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1210ed2a05c47c910c8f213eb7d2d8b/" rel="bookmark">
			vue &#43; websocket &#43; element  Notification 消息推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue+ element Notification消息推送 业务需求：
登录后进入页面，将后端推送过来的【待审批】的消息，用$notify弹出，并且，此推送消息的弹窗可以点击，跳转到审批页面，且展示这条【待审批】的详情弹窗，以供用户审批
首先：登录进入页面后，消息可以显示在任何页面，所以，这个消息推送的【通知】写在了App.vue页面中
然后：既然是消息推送，我们用到的是websocket，实时接收消息
再然后：消息推送的【通知】使用的是element的Notification
再然后~~ 上代码
// App.vue &lt;template&gt; &lt;div id="app"&gt; &lt;transition name="fade" mode="out-in"&gt; &lt;router-view/&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Cookie from "js-cookie"; export default { name: "App", data() { return { socUrl: "localhost:8080" }; }, created() { this.initWebSocket(); }, methods: { initWebSocket() { this.$http .service({ method: "get", url: "/user/current", data: { user: Cookie.get("user") } }) .then(res =&gt; { const resData = res.data.data; // ws是一定要写的，this.socUrl ：是后端的IP // "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1210ed2a05c47c910c8f213eb7d2d8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb6f156e5bb42231c91297f0243206c/" rel="bookmark">
			vue3.0 ts版项目配置axios
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前介绍过一篇《typescript 配置 axios》。那个版本用了class语法，本次介绍 vue3.0 普通的写法，最后用 eggjs 测试通过登录接口。
./src/api 目录下需要 api.ts、status.ts、type.ts 三个文件。
├── src │ ├── api │ │ ├── api.ts │ │ ├── status.ts │ │ └── type.ts ./src/api/api.ts
import axios, {AxiosInstance, AxiosRequestConfig, AxiosResponse} from 'axios'; import qs from 'qs' import { showMessage } from "./status"; import { ElMessage } from 'element-plus' import { IResponse, ILogin } from './type'; let axiosInstance:AxiosInstance = axios.create({ baseURL: process.env.VUE_APP_BASE_URL + "/api/v1/", headers: { Accept: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb6f156e5bb42231c91297f0243206c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e967c9dd9a6cf627441634ae52a3ded/" rel="bookmark">
			mysql 报错：ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it ca
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql 报错：ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement 这个问题是由于不允许导入导出文件引起的错误，如果使用命令查看：
show global variables like '%secure_file_priv%'; 就能看到此时是这样的：
解决办法：
1.修改my.ini（我的这个文件的位置是C:\ProgramData\MySQL\MySQL Server 8.0\my.ini,注意可能是隐藏文件）
添加secure-file-priv="C:/ProgramData/MySQL/MySQL Server 8.0/Uploads"（就是要导入的文件所在位置）
网上说设成空好像可以任意导入导出，
secure_file_priv='' 我这里修改了半天my.ini都不能保存，右键也修改不了安全设置，最后的解决方法是：
先以管理员身份运行记事本，然后再打开my.ini，这样修改之后就可以保存了。
2.重启mysql服务
我的电脑--&gt;右键 【管理】--&gt;【服务】--&gt;重启动mysql服务
3.不知道大家重启后行了不，如果可以了就……鼓掌。不行的话可能是这个毛病
就是这里没有设置：
这里不设置一下的话，mysql的启动就不会加载那个my.ini配置文件，所以上面的重启也是无效的了。
如何设置？
Win+R 弹出运行窗口，输入 regedit
在注册表编辑器依次打开：HKEY_LOCAL_MACHINE----&gt;SYSTEM----&gt;CurrentControlSet----&gt;Services----&gt;MySQL
根据路径找到 ImagePath，双击，弹出编辑字符串
我这里原来应该是"C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqld" MySQL
现在把它换成：
"C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqld" --defaults-file="C:\ProgramData\MySQL\MySQL Server 8.0\my.ini" MySQL 中间的那个路径就是my.ini所在路径。然后确定。再次按照第2步重启mysql服务，终于ok:
现在要导入这个路径下的文件也可以了：
参考：
https://zhuanlan.zhihu.com/p/181675602
https://blog.csdn.net/jav0a0/article/details/90712089
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d079e26ffb895e993a15bf38449dbd/" rel="bookmark">
			【每日一题】day06_01  不要二，二货小易有一个W*H的网格盒子，网格的行编号为0~H-1，网格的列编号为0~W-1。每个格子至多可以放一块蛋糕，任意两块蛋糕的欧几里得距离不能等于2。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标： 目标：熟练运用Java所学知识
学习内容： 本文内容：使用java解决 不要二
文章目录 学习目标：学习内容：题目描述解题思路实现代码 题目描述 二货小易有一个W*H的网格盒子，网格的行编号为0H-1，网格的列编号为0W-1。每个格子至多可以放一块蛋糕，任意两块蛋糕的欧几里得距离不能等于2。
对于两个格子坐标(x1,y1),(x2,y2)的欧几里得距离为: ( (x1-x2) * (x1-x2) + (y1-y2) *
(y1-y2) ) 的算术平方根 小易想知道最多可以放多少块蛋糕在网格盒子里。
输入描述:
每组数组包含网格长宽W,H，用空格分割.(1 ≤ W、H ≤ 1000)
输出描述:
输出一个最多可以放的蛋糕数
示例1
输入
3 2
输出 4
解题思路 这是一个比较简单的题目
观察这个公式( (x1-x2) * (x1-x2) + (y1-y2) *(y1-y2) ) ，我们会发现就是要找两个数的平方和为4，
而这两个数是坐标差，也就是整数，两个整数的平方和为4，那么只可能是0和2这两个数，
那么接下来就简单了，创建一个二维数组，0表示可以方蛋糕，1表示不可以放蛋糕，遍历一遍数组，将横坐标或纵坐标差为2的两个位置分别赋值为1或0
实现代码 public class NoTwo { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int list = sc.nextInt(); int line = sc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0d079e26ffb895e993a15bf38449dbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4983fe637011294e36d9ddafcf7860b2/" rel="bookmark">
			全选反选小案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理： 当点击全选按钮时，其对应的元素将被去全部选中；当点击反选按钮时，会选中没有选中的元素，之前选中的元素将失去选中；当点击全不选按钮时，其对应的元素都将失去选中状态
核心： 主要就是改变input标签的checked属性
具体代码如下：
&lt;input type="button" id="All" value="全选" /&gt; &lt;input type="button" id="uncheck" value="不选" /&gt; &lt;input type="button" id="othercheck" value="反选" /&gt; &lt;div id="div"&gt; &lt;input type="checkbox" /&gt;电视&lt;br/&gt; &lt;input type="checkbox" /&gt;电视&lt;br/&gt; &lt;input type="checkbox" /&gt;电视&lt;br/&gt; &lt;input type="checkbox" /&gt;电视&lt;br/&gt; &lt;input type="checkbox" /&gt;电视&lt;br/&gt; &lt;input type="checkbox" /&gt;电视&lt;br/&gt; &lt;input type="checkbox" /&gt;电视&lt;br/&gt; &lt;input type="checkbox" /&gt;电视&lt;br/&gt; &lt;input type="checkbox" /&gt;电视&lt;br/&gt; &lt;/div&gt; &lt;script&gt; window.onload = function(){ //选中元素 var checkAll = document.getElementById('All'); var uncheck = document.getElementById('uncheck'); var othercheck = document.getElementById('othercheck'); var div = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4983fe637011294e36d9ddafcf7860b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b7d3c3dcb3897a6eb3c238a2b93b19/" rel="bookmark">
			【每日一题】day04_02   给定一个十进制数M，以及需要转换的进制数N。将十进制数M转化为N进制数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习目标： 目标：熟练运用Java所学知识
学习内容： 本文内容：使用java解决 给定一个十进制数M，以及需要转换的进制数N。将十进制数M转化为N进制数
文章目录 学习目标：学习内容：题目描述解题思路实现代码 题目描述 【进制转换】给定一个十进制数M，以及需要转换的进制数N。将十进制数M转化为N进制数
输入描述：
输入为一行，M(32位整数)、N(2 ≤ N ≤ 16)，以空格隔开。
输出描述：
为每个测试实例输出转换后的数，每个输出占一行。如果N大于9，则对应的数字规则参考16进制（比如，10用A表示，等等）
示例1：
输入
7 2
输出
111
解题思路 思路比较简单，一个十进制数M转化整N进制数，就是先让M对N进行求模保存下得到的数字，在让M除以N，进行下一次循环将每次保存的数使用字符串拼接起来，在进行一次反转就是最终的结果
实现代码 public class HexBinDecOct { public static void main(String[] args){ Scanner sc=new Scanner(System.in); int num=sc.nextInt(); int n=sc.nextInt(); char[] temp={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}; boolean b=false;//表示正数 if(num&lt;0){ b=true;//表示负数 num=0-num; } StringBuffer strBuf=new StringBuffer(); while(num&gt;0){ //num%n得到转化后的每一位数字， // 十六进制大于10需要得到A,B,C,D,E,F所以需要用到上面定义的数组 strBuf.append(temp[num%n]); num/=n; } if(b){ //如果原数字是负数 strBuf.append('-'); } System.out.println(strBuf.reverse());//反转并输出 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e9f24289ec94ccc6650c43aa80e6ec0/" rel="bookmark">
			【每日一题】day02_1   排序子序列，牛牛定义排序子序列为一个数组中一段连续的子序列,并且这段子序列是非递增或者非递减排序的。牛牛想知道他最少可以把这个数组分为几段排序子序列.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标： 目标：熟练运用Java所学知识
学习内容： 本文内容：使用java解决 ：排序子序列
文章目录 学习目标：学习内容：题目描述解题思路实现代码 题目描述 牛牛定义排序子序列为一个数组中一段连续的子序列,并且这段子序列是非递增或者非递减排序的。牛牛有一个长度为n的整数数组A,他现在有一个任务是把数组A分为若干段排序子序列,牛牛想知道他最少可以把这个数组分为几段排序子序列.
如样例所示,牛牛可以把数组A划分为[1,2,3]和[2,2,1]两个排序子序列,至少需要划分为2个排序子序列,所以输出2
输入描述:
输入的第一行为一个正整数n(1 ≤ n ≤ 10^5) 第二行包括n个整数A_i(1 ≤ A_i ≤ 10^9),表示数组A的每个数字。
输出描述:
输出一个整数表示牛牛可以将A最少划分为多少段排序子序列
示例1
输入
6
1 2 3 2 2 1
输出
2
解题思路 这个题目需要遍历比较相邻数字的大小，所以一共会出现三种情况
ary[i]=ary[i+1]
这种情况不进行操作，因为相等不属于递增也不属于递减，所以continue，进行下一次遍历ary[i]&lt;ary[i+1]
这种情况属于递增区间，需要嵌套while循环继续向后遍历，直到出现ary[i]&gt;ary[i+1],则该区间结束，count++；ary[i]&gt;ary[i+1]
这种情况属于递减区间，需要嵌套while循环继续向后遍历，直到出现ary[i]&lt;ary[i+1],则该区间结束，count++； 需要注意的是遍历时需要遍历到数组最后一个元素，而不能只遍历到倒数第二个元素，因为只遍历到倒数第二个元素一下情况会出错
1 2 1 2 1 2 1 2 1
正确答案会输出5，但是如果只遍历到倒数第二个元素则只会判断出前4个区间，会将最后一个元素 1 默认归为第四个区间，会输出4
所以我们的解决方案是在创建数组时初始大小创建为n+1，也就是比实际数组元素多一，这样我们就可以遍历到最后一个元素且保证ary[i+1]不会越界
实现代码 public class MinDivided { public static void main(String[] args) { Scanner sc = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e9f24289ec94ccc6650c43aa80e6ec0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/144/">«</a>
	<span class="pagination__item pagination__item--current">145/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/146/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>