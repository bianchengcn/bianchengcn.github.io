<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966850880d4becd2bae62abcfe41614d/" rel="bookmark">
			【Vue】Vue3项目使用 amfe-flexible &#43; postcss-pxtorem 完成移动端的rem布局适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Vue】Vue3项目使用 amfe-flexible + postcss-pxtorem 完成移动端的rem布局适配 一、amfe-flexible 的使用 1、安装amfe-flexible 和 postcss-pxtorem 依赖
npm install amfe-flexible postcss-pxtorem -D 2、vite.config.js中引入插件及配置
import { defineConfig } from 'vite' import postCssPxToRem from 'postcss-pxtorem' defineConfig({ css: { // 配置 CSS modules 的行为。选项将被传递给 postcss-modules modules: {}, // 内联的 PostCSS 配置（格式同 postcss.config.js） postcss: { plugins: [ postCssPxToRem({ rootValue: 37.5, // 1rem 的大小 propList: ['*'], // 需要转换的属性，*(全部转换) unitPrecision: 6 // 转换精度，保留的小数位数 }) ] } } }) 3、main.js中引入amfe-flexible
import 'amfe-flexible' // rem 布局适配 启动项目后，从浏览器调试工具中可以看到html根字体已变成了37.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/966850880d4becd2bae62abcfe41614d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43262107ab074ab121524584542adff2/" rel="bookmark">
			【Python】Jupyter远程配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先主机和服务器要可以ping通哦（应该吧 =_=）
1 远程服务器端操作（Linux） 假如想用Jupyter Lab，先pip： pip install jupyterlab 假如没有生成配置文件，先生成一下： jupyter notebook --generate-config 或 jupyter lab --generate-config 修改配置文件 vi ~/.jupyter/jupyter_notebook_config.py 或 vi ~/.jupyter/jupyter_lab_config.py 使用/关键词查找下面内容，把前面的#去掉：
# 下面的xxx就是配置文件里的Notebook（对于Jupyter Notebook而言）或Server（对于Jupyter lab而言） c.xxxApp.ip = '远程服务器地址' # 设置为'*'也行，但是建议设置远程服务器地址，否则你就有可能会和我一样成为怨种 c.xxxApp.port = 8888 # 端口号 c.xxxApp.open_browser = False # 设置为False它就不会一启动就给你弹出界面 比如：
/App.ip+回车查找到 c.NotebookApp.ip按i进入编辑模式，设置 c.NotebookApp.ip = ‘*’Esc+:wq+回车保存并退出 启动jupyter jupyter notebook 或 jupyter lab 复制链接 启动Jupyter后，会有提示：
Or copy and paste ont of these URLs: https://远程服务器地址:端口号/?token=某个token 2 本地终端操作 在本地浏览器粘贴：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43262107ab074ab121524584542adff2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb28a7eb6f7f276f5393de4fe68f6ae/" rel="bookmark">
			for i in range()使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		for i in range()
作用：
遍历不可变的数字序列 ，通常用于在 for 循环中循环指定的次数。
比如
for i in range(3)
那么就是从0开始 0，1，2依次赋值给i
for i in range(1,3)
那么就是将1 和 2 依次赋值给i
也可以跳着取
range(start,stop[,step])
for i in range(1,9,2) 分别表示起始 、结束 和步长
1，3，5，7，9
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe433b2d0de1beb7d2d760e20b1755a/" rel="bookmark">
			java生成json发送到前端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfa20b81296e78c0daf5c2d19a83cccf/" rel="bookmark">
			Java开发注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		restful风格：简洁、高效、安全
有视图解析器，默认情况下是转发，没有视图解析器，使用redirect进行地址变换
乱码处理“
方法一：自定义过滤器 配置文件
方法二：直接配置
方法三：tomcat配置
方法四：大神写的
package com.kuang.filter; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.Map; /** * 解决get和post请求 全部乱码的过滤器 */ public class GenericEncodingFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType("text/html;charset=UTF-8"); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfa20b81296e78c0daf5c2d19a83cccf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59c8e58cfeb58ac7a19232431e93b10/" rel="bookmark">
			application.yml和bootstrap.yml关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bootstrap.yml（bootstrap.properties）用来在程序引导时执行，应用于更加早期配置信息读取，如可以使用来配置application.yml中使用到参数等。
application.yml（application.properties) 应用程序特有配置信息，可以用来配置后续各个模块中需使用的公共参数等。
bootstrap.yml 先于 application.yml加载。
原文链接：https://blog.csdn.net/bxg_kyjgs/article/details/125149618
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08569997ffa74e3e8e3c4862f8c27a1/" rel="bookmark">
			Box-Muller变换：学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法说明 Box-Muller变换是通过服从均匀分布的随机变量，来构建服从高斯分布的随机变量的一种方法。具体的描述为：选取两个服从 [ 0 , 1 ] [0,1] [0,1]上均匀分布的随机变 U 1 U_1 U1​和 U 2 U_2 U2​，使得 X X X， Y Y Y满足高斯分布
X = σ cos ⁡ ( 2 π U 1 ) − 2 ln ⁡ U 2 + μ . , Y = σ sin ⁡ ( 2 π U 1 ) − 2 ln ⁡ U 2 + μ . X = \sigma \cos (2\pi {U_1})\sqrt { - 2\ln {U_2}} + \mu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c08569997ffa74e3e8e3c4862f8c27a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e18503d6f1930d459ad1d653836cd0/" rel="bookmark">
			阿里云域名搭建DNSLOG
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DNSlog简介 DNSLOG在测试无回显漏洞，如SQL盲注、无回显SSRF、无回显XXE、无回显RCE等漏洞时，是必不可少的工具。
在互联网上，有很多优秀的在线DNSLOG平台可供我们日常渗透测试使用，如www.dnslog.cn、ceye.io等。但正是由于这些在线DNSLOG平台被过多的使用，现在很多安全设备以及甲方自建的安全策略都将这些在线DNSLOG平台的域名、ip等加入了黑名单拦截策略库。所以，搭建一个自有的DNSLOG平台是非常有必要的。
二、搭建DNSLOG平台 1、域名准备 （1）本文使用阿里云平台域名，首先进入自定义DNSHost，然后创建两个DNS服务器 （2）进入DNS修改，将DNS服务器修改为上一步在自定义DNS Host内配置的DNS服务器，目的是指将当前域名的解析DNS服务器更换为你即将搭建的DNS服务器(下文会配置)，由修改后的DNS服务器负责域名解析服务。修改后一般需要24小时才会生效。 (3) 进入域名解析，添加三条域名解析记录，首先添加一条A记录，主机记录为log，记录值为你的服务器公网IP，然后添加两个NS记录，主机记录为ns1,ns2，记录值为log.(你的域名) 到此阿里云域名设置结束 2、服务器准备 本文使用的是华为云的免费试用的弹性ECS，首先需要找到服务器的公网IP，上面域名配置需要。接着只需要配置一下安全组(可以新建一个名为dnslog的安全组)，开放UDP和TCP的53端口，还有前端需要的8000的端口，还有开放一些调试需要的端口（或者直接全部开放）。 到此服务器准备工作结束 3、代码部署 参考开源项目DNSlog-GO：https://github.com/lanyi1998/DNSlog-GO 下载第一个linux版本，上传至服务器。 （1）服务器安装go环境 wget -c https://studygolang.com/dl/golang/go1.17.5.linux-amd64.tar.gz tar -xzf go1.17.5.linux-amd64.tar.gz -C /usr/local vim /etc/profile 在文件内容后面加上 export PATH=$PATH:/usr/local/go/bin后保存 source /etc/profile 完成上述步骤后输入go version，返回安装的go版本即为安装成功。 （2）解压zip，并配置config.yaml vim config.yaml 一共需要配置4个地方，（1）为前端开放的8000端口、（2）为你设置的登录token、（3）为你在阿里云域名出配置的ns1或ns2，此处我就设置为ns1，所以以后DNS解析都需使用ns1作为三级域名、(4)domain处设置为你的域名，保存退出。 （3）使用./main启动，出现如下图所示代表能够正常启动，访问服务器8000端口即可查看到DNSLOG前端。 输入config.yaml里设置的token值即可访问，接下来就可以正常ping，进行DNS解析。 如果第二次登录出现如下8000端口被占用，只需kill掉8000端口的进程即可。 ------------------------------------------------------------------ 第一次启动可能会有一个坑，默认情况下，Ubuntu在端口53上侦听systemd-resolved。如果您运行自己的DNS服务器，则因为端口53已被使用而无法执行。因此，发生以下错误。 “侦听tcp 0.0.0.0:53：bind：地址已在使用中”。 使用netstat -tlunp|grep 53查看53端口是不是systemd-resolved占用了。如果是，下面是解决方法可以试试看对你有没有帮助。 1、先停用 systemd-resolved 服务 systemctl stop systemd-resolved 2、编辑 /etc/systemd/resolved.conf 文件 vi /etc/systemd/resolved.conf 3、换下面说明更改，然后按一下“esc”键，再输入“:wq”（不要输入引号），回车保存即可。 [Resolve] DNS=127.0.0.1 #取消注释，此处填写127.0.0.1，配置为使用本地解析DNS #FallbackDNS= #Domains= #LLMNR=no #MulticastDNS=no #DNSSEC=no #Cache=yes DNSStubListener=no #取消注释，把yes改为no 4、最后运行下面命令即可。 ln -sf /run/systemd/resolve/resolv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e18503d6f1930d459ad1d653836cd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cfe8f73e1ec9775d6b4e21da3294497/" rel="bookmark">
			JavaScript入门级语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期主要给大家讲解js的语法~~~
目录
一、简介JS
1.什么是JS
2.JS、HTML、CSS的联系
3.JS的组成
二、JS的基本操作
1.JS的书写形式
1.1行内式
1.2内嵌式
1.3外部式
2.JS的输入输出
2.1输入
2.2输出
三、JS的基础语法
1.变量的使用
1.1变量的基本用法
1.2几种基本数据类型
2.运算符
2.1相等运算符
2.2逻辑运算符
3.数组
3.1创建数组
3.2获取数组元素
3.3获取数组长度
3.4使用push对元素进行插入
3.5删除元素
4.函数
4.1函数的基本形式
4.2函数的表达形式
4.3函数的作用域
4.4函数的参数
5.对象
5.1对象的创建
一、简介JS 1.什么是JS 是世界上最流行的编程语言之一 。是一个脚本语言, 通过解释器运行，主要在客户端( 浏览器 ) 上运行 , 现在也可以基于 node.js 在服务器端运行。即JS主要是用于前端开发。 2.JS、HTML、CSS的联系 我们前面说到，如果把整个前端比喻成一个人的话，那么JS就是这个人的骨架，而CSS就是这个人的外表（皮相），那么JS就可以形容成这个人的行为（或者说是灵魂）。用下面这个图生动地进行一个表示
3.JS的组成 ①ECMAScript( 简称 ES): JavaScript核心 语法 ②DOM API: 浏览器提供的操作页面元素的一组API ③BOM API : 浏览器提供的操作浏览器窗口的一组API 二、JS的基本操作 运行在浏览器中的JS是离不开HTML的，因此JS通常是在HTML中来展开写。
1.JS的书写形式 1.1行内式 ①什么是行内式： 直接嵌入到 html 元素内部。即把js直接写在HTML元素的内部。 ②演示： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cfe8f73e1ec9775d6b4e21da3294497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41bbbb6139e19885ae6a901fda35c157/" rel="bookmark">
			rabbitmq消息阻塞情况分析；自动重试处理异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象描述 消费者因为代码问题出现了异常，此时默认是自动提交的消息，这个RuntimException会导致消息直接重新入队，再次投递（进入队首），此时会导致后面的消息被阻塞.
分析 auto自动确认分四种情况，第一种就是正常消费，其他三种则为异常情况
消息成功被消费，没有抛出异常，则自动确认，回复ack。不涉及requeue，毕竟已经成功了。requeue是对被拒绝的消息生效。当抛出ImmediateAcknowledgeAmqpException异常，则视为成功消费，确认该消息。当抛出AmqpRejectAndDontRequeueException异常的时候，则消息会被拒绝，且requeue = false(该异常会在重试超过限制后抛出)其他的异常，则消息会被拒绝，且requeue = true 我遇到的是第四种情况，导致mq消息阻塞，并且消费者一直在消费同一条消息，然后抛异常，此时就进入了死循环，cpu和磁盘io直接拉高.
解决方案 1-在消费者消费逻辑外面套个catch，把异常吃掉，然后把当前异常的消息再做额外处理
2-把mq重新入队关闭
3-抛出ImmediateAcknowledgeAmqpException/AmqpRejectAndDontRequeueException异常
我的解决方案 使用spring-retry重试3次后还是失败就记录到mysql中，作为后续补偿的记录.
需要依赖如下
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; 启动类加上@EnableRetry注解
实现自动重试代码demo
package com.fchan.mq.process; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.amqp.AmqpRejectAndDontRequeueException; import org.springframework.retry.annotation.Backoff; import org.springframework.retry.annotation.Recover; import org.springframework.retry.annotation.Retryable; import org.springframework.stereotype.Component; import java.util.Map; import java.util.Objects; /** * ClassName: MyRabbitConsume &lt;br/&gt; * Description: &lt;br/&gt; * date: 2022/7/18 17:07&lt;br/&gt; * * @author fchen&lt;br /&gt; */ @Component public class MyRabbitNormalMessageProcess{ Logger log = LoggerFactory.getLogger(MyRabbitNormalMessageProcess.class); //默认的重试就是3次，maxAttempts = 第一次正常请求 + 后续异常重试次数 @Retryable(value = AmqpRejectAndDontRequeueException.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41bbbb6139e19885ae6a901fda35c157/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/732c7249aab9461e4480f65d46108db7/" rel="bookmark">
			Kaggle注册方法，解决人机验证问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用于解决Kaggle注册无法获取人机验证
1.打开浏览器，点击右上角的三个点
2.点击扩展
3.打开加载项
4.搜索框中输入header editor，选择图中标记的这个，点击获取
5.下载好后，选择管理扩展
6.点击详细信息
7.点击扩展选项
8.点击导出和导入
9.在下载规则的URL中输入下面链接，然后点击右侧的下载
https://azurezeng.github.io/static/HE-GoogleRedirect.json
下载完成后点击页面下面的保存，然后再刷新注册界面就可以收到人机验证了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8be36f55e9e36ba3aca07ed138fff500/" rel="bookmark">
			西门子博图安装期间反复重启的问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.处理方法
安装博途要求反复重启， 进入注册表（开始菜单中的运行中输入regedit并确定）。
删除HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager下面的键值PendingFileRenameOperations。
2.安装完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5ceadbaf37ad335259fb48e089ecf31/" rel="bookmark">
			Xcelium XRUN用户手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xcelium XRUN User Guide
Product Version 22.09
September 2022
Document Last Updated: May 2022
Contents
1 Overview
1.1 How xrun Works
1.2 File Type Support
1.3 Recompilation and Re-Elaboration
1.3.1 Debugging Recompilation and Re-Elaboration
1.4 Displaying and Replaying the xrun History
1.4.1 Saving the xrun History
1.4.2 Disabling the xrun History
1.5 IP Protection
1.6 Running xrun in Prep Mode
1.7 Support for Compressed Files
2 Getting Help on XRUN
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5ceadbaf37ad335259fb48e089ecf31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc89175bfdb5f9cdad0b2173e9d6be36/" rel="bookmark">
			工具类代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Mybatis获取Sqlsession执行sql语句： package com.zmy.util; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; //sqlSessionFactory==》sqlSession public class MybatisUtil { private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis获取sqlSessionFactory对象 String resource = "mybatis-config.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了SqlSessionFactory，顾名思义，我们就可以从中获得SqlSession 的实例了。 // sqlSession完全包含了面向数据库执行sQL命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1a606e855a902bc131d50044ca41f7b/" rel="bookmark">
			log c语言宏定义版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #define LOG(Severity, format, ...) printf("[%s]%s:%d: " format "\n", #Severity, __FILE__, __LINE__, ##__VA_ARGS__); #define LOGD(...) LOG(DEBUG, __VA_ARGS__) #define LOGI(...) LOG(INFOR, __VA_ARGS__) #define LOGW(...) LOG(WARRING, __VA_ARGS__) #define LOGE(...) LOG(ERROR, __VA_ARGS__) #define LOGF(...) LOG(FALT, __VA_ARGS__) abort(); # LOGI("Test Log, index: %d", 0); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ae4486381fe81c5922aee75d0fa9fea/" rel="bookmark">
			stm32 LWIP开发-1-LWIP 无操作系统移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 网卡基础概念 1. 开发板需要实现网络功能的话，需要两个条件，
1. 硬件，外置网络芯片或者MCU有网络功能（比如：stm32F1 + DM9000(MAC+PHY), stm32F4(内置MAC层)+PHY层芯片）。
2. 支持TCP/IP协议栈。
2. stm32F4 芯片里只内置了MAC内核。PHY层芯片是纯模拟电路，不做进stm32F4是为了减少体积，减少功耗等原因。
3. MAC 和 PHY 之间通信使用的是MII接口/RMII接口，MDIO接口（SMI接口）配置和管理PHY设备。
2. TCP／IP 协议 3. DM9000 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69e7f3c2cfa89020aedea52c45f42dd2/" rel="bookmark">
			Visual Studio新功能：针对Linux平台的新版SSH终端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在最新版本的Visual Studio 2022 预览版里，用户可以通过一项新的集成化的终端来从Windows中访问目标开发平台。这次更新的终端还包含了一个交互式的SSH外壳。用户可以通过Visual Studio中的[视图 -&gt; 终端]来打开它，如下图所示：
现在，你无需在 PowerShell 或 WSL 中启动 SSH 会话并重新进行身份验证，而是只需单击一下即可选择现有连接之一。集成化终端从连接管理器中建立的存储连接中提取。 你只需在添加存储连接时进行一次身份验证，然后此身份验证信息将保留在 Visual Studio 中，从而减少管理已超时的 SSH 连接所花费的停机时间，如下图所示：
在集成终端的左上角，您可以单击选定的 SSH 连接，然后查看可用的配置文件下拉框，这些条目显示从你的连接管理器中已经保存好的连接，如下图所示：
当您从下拉列表中单击一个连接时，终端将生成一个新的终端实例，该实例将在下面的选项卡中保持停靠在当前的终端实例旁边。
此外，新的集成终端现在支持从 VS 内部操作文件、运行后台任务、配置远程系统和测试部署的代码，而不必使用外部 SSH 客户端。 该终端还支持颜色和命令序列，例如，复制、粘贴和查找快捷方式以及 vim 等交互式程序都可以使用。
总结 老大哥你可还行啊，卷吧，捎带着把人Linux Terminal的市场给也卷走了。
但我就喜欢看你大包大揽的样子。
最后 Microsoft Visual C++团队的博客是我非常喜欢的博客之一，里面有很多关于Visual C++的知识和最新开发进展。大浪淘沙，如果你对Visual C++这门古老的技术还是那么感兴趣，则可以经常去他们那(或者我这)逛逛。
本文来自：《Integrated Terminal in Visual Studio: New SSH integration for Linux targeting》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eda633dc5cd8071226e3b32e26d5a0c/" rel="bookmark">
			Win10开启沙盒功能和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 什么是沙盒？
在计算机安全领域，沙盒（英语：sandbox，又译为沙箱 ）是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供用后即回收的磁盘及内存空间。在沙盒中，网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是严格限制。从这个角度来说，沙盒属于虚拟化 的一种。
沙盒中的所有改动对操作系统不会造成任何损失。通常，这种技术被计算机技术人员广泛用于测试可能带毒的程序或是其他的恶意代码。---------来自百度百科
相比虚拟机和第三方的沙盒软件，Windows Sandbox启用后仅占用100MB硬盘空间，还能与物理机安全地共享部分内存空间。简单来说就是易用、免费、不卡机！
由于要保证沙盒内的数据不泄露并影响物理系统，所有文件读写都经过了重定向，所以沙盒虚拟化对存储性能影响较大，建议用固态。
注意：1.只有专业版和企业版系统支持沙盒；2.沙盒每次关闭都会自动清零；
开启沙盒 利用win10的搜索功能 -&gt; 直接搜索启用或关闭Windows功能 -&gt; 找到Windows沙盒，勾选它，然后点确定 -&gt; 重启电脑
使用沙盒 打开沙盒（在开始菜单中） 在开始菜单中找到Windows Sandbox ，打开。
使用沙盒 直接将要运行的程序，不确定安全性的程序复制粘贴进沙盒中运行就可以。
关闭后提示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64180ab1da983accdc0554337c9035a0/" rel="bookmark">
			C&#43;&#43;基础知识点（2）关于输入输出，结构体，类的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.基本格式
头文件#include&lt;iostream&gt; using namespace std; int main { } 二.输入输出
1.cout输出
#include &lt;iostream&gt; using namespace std; int main() { int a=123; double b=3.13; const char *p="hello"; cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;"b="&lt;&lt;b&lt;&lt;"p="&lt;&lt;p&lt;&lt;"\n"; while(1); } 运行
a=123b=3.13p=hello
2.cin输入
#include &lt;iostream&gt; using namespace std; int main() { int a=123; double b=3.13; char buf[10]; cin&gt;&gt;a&gt;&gt;b&gt;&gt;buf; cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;"b="&lt;&lt;b&lt;&lt;"buf="&lt;&lt;buf&lt;&lt;"\n"; return 0; } 键盘输入2 0.1 cxy
输出a=2b=0.1buf=cxy
三.结构体定义和类
1.结构体
（1）先构造后定义
例如
struct student { int number; char name[5]; }; int main() { struct student stu1; struct student stu2; } (2)构造的同时定义
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64180ab1da983accdc0554337c9035a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ffd10be35cab7a1942271ed3f3d3075/" rel="bookmark">
			日志审计Graylog审计华为交换机用户登录日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上期讲解了日志审计graylog安装，这期讲解graylog的部分实用功能的使用。
上期内容链接：https://blog.csdn.net/weixin_43886932/article/details/125678301?spm=1001.2014.3001.5501
1、读取日志 日志基本上都存放在Streams — All messages中
进入ALL messages看到的日志并非很直观，如下图所示，我们登录的交换机日志都看不到是什么IP，解决方法是可以通过创建新的Stream来过滤所需要的的信息，创建仪表板Dashboards来显示需要的数据。
2、创建Stream 进入Create Stream，创建一个新的Stream，标题自定义，教程中为“78”，描述为“登录信息”。
配置Manage Rules
创建一个Stream rule
字段Field，选择远程IP（gl2_remote_ip），上期教程介绍了我们登录的交换机IP是172.16.1.254，如下图：
点击Strart Stream，开启“78”Stream。
点击运行，如下图：
上期教程已经配置好交换机，现在登录交换机获取到一些登录日志信息。
通过CRT登录交换机如下图：
日志审计GRAYLOG获取到的日志如下图：
我们获取一段交换机发给日志服务器的登录日志如下：
“Jul 6 2022 09:18:59 +78 %%01SHELL/5/LOGIN(s)[257]:The user succeeded in logging in to VTY0. (UserType=SSH, UserName=78, AuthenticationMethod=“Local-user”, Ip=172.16.1.60, VpnName=)”
从日志中得出，关键字如下：
登录成功：The user succeeded in logging in to VTY0
登录时间：Jul 6 2022 09:18:59
登录协议：UserType=SSH
登录用户：UserName=78
登录用户IP：Ip=172.16.1.60
进入提取器并创建新的字段，每添加1个字段，该步骤需要重复一次，点开需要提前的消息，如下图：
点开子菜单，如下图：
选择正则表达式Regular expression，如下图：
创建字段登录协议字段UserType：
正则表达式：UserType=(.?),
创建字段登录用户字段UserName：
正则表达式：UserName=(.?),
创建字段登录IP字段Ip：
正则表达式：Ip=(.?),
创建字段登录成功字段login：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ffd10be35cab7a1942271ed3f3d3075/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/103/">«</a>
	<span class="pagination__item pagination__item--current">104/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/105/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>