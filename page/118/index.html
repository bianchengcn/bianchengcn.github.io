<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f2c86bcdbb6bf95b9e77b9ba15e13a/" rel="bookmark">
			浅解一下BS和CS的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、CS二、BS总结 前言 本文章记录BS和CS的区别和优缺点
一、CS CS：客户端服务器架构模式
优点：充分利用客户端机器的资源,减轻服务器的负荷(一部分安全要求不高的计算任务存储任务放在客户端执行 ,不需要把所有的计算和存储都在服务器端执行,从而能够减轻服务器的压力,也能够减轻网络负荷)
缺点：需要安装;升级维护成本较高
例如：就像平时玩游戏，假如它不是CS模式是BS模式，通过网页的方式展示的。如果你的网络有些卡，你正在跑毒网络一卡，或者是服务器没来得及给你计算去更新地图和敌人。里面的人物定位还没更新过来，你这边一直在显示原地跑，卡了一两秒，你就被别人爆头了。就是因为网络有延迟，所以CS可以去减少服务器端计算的压力，去进行一些安全要求不高的计算任务。
二、BS BS：浏览器服务器架构模式
优点:客户端不需要安装;维护成本较低
缺点:所有的计算和存储任务都是放在服务器端的.服务器的负荷较重;在服务端计算完成之后把结果再传输给客户端,因此客户端和服务器端会进行非常频繁的数据通信,从而网络负荷较重
例如：就像是抖音，百度等等软件，一到节日他们就在他们的图标中去添加节日特色。但他们更新我们并不需要去升级浏览器什么的，所以他们维护成本比较低。例如4399小游戏里面的游戏，我们并不需要下载就可以玩，只要我们可以上网就行。这些游戏都是BS模式。
总结 以上就是今天要讲的内容，本文仅仅简单介绍了BS和CS的大概优缺点和例子。希望大家能够更好的去学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63b51c54617f22dad6b7266f6432f306/" rel="bookmark">
			评分卡：WOE、IV、PSI计算及ROC和KS曲线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公式定义和原理解释见：
风控模型—WOE与IV指标的深入理解应用 - 知乎
风控模型—群体稳定性指标(PSI)深入理解应用 - 知乎
1、WOE和IV 延伸：分箱后求 WOE 和 IV
1. WOE describes the relationship between a predictive variable and a binary target variable.
2. IV measures the strength of that relationship.
# Autor chenfeng #!/usr/bin/env Python # coding=utf-8 ''' 学习demo： 皮尔逊相关系数，woe计算 ''' import pandas as pd import numpy as np from scipy import stats # 从正太分布种抽取20个随机数 x = np.array(np.random.randn((20))) print(type(x)) X = pd.DataFrame(x, columns=['x']) # 生成范围在[0, 2)的20个整数 y = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63b51c54617f22dad6b7266f6432f306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2e4248921861715500a6ead02cafae/" rel="bookmark">
			vue-router的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue 的特性是一个html页面 完成一个应用
那么我们如何通过一个html来完成一个应用呢？
前面我们学习了vue的组件，今天我们利用组件模板化，和vue-router路由来实现一个小小的案例
&lt;body&gt; &lt;!-- vue 的特性是只能一个html.,然后根据路由来区分模板处理 --&gt; &lt;div id="app"&gt; &lt;!-- &lt;a href="#"&gt;首页&lt;/a&gt; &lt;a href="#"&gt;商品&lt;/a&gt; &lt;div&gt;Hello,vue-router学习&lt;/div&gt; &lt;ul&gt; &lt;li&gt;1.小米11&lt;/li&gt; &lt;li&gt;2.小米12&lt;/li&gt; &lt;/ul&gt; --&gt; &lt;!-- 专门用于跳转的，可代替a标签的跳转 --&gt; &lt;router-link to="/index"&gt;首页&lt;/router-link&gt; &lt;router-link to="/product"&gt;商品&lt;/router-link&gt; &lt;!-- 作用于将模板放入并渲染 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;script src="./node_modules/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; &lt;!-- 要根据不同的url ，连接到不同的页面 需要使用模板来实现，将模板绑定对应的路由地址 --&gt; &lt;script&gt; // 创建vue组件模板 let index = Vue.component("index",{ template:`&lt;div&gt;Hello,vue-router学习&lt;/div&gt;` }) let product = Vue.component("product", { template:`&lt;ul&gt; &lt;li&gt;1.小米11&lt;/li&gt; &lt;li&gt;2.小米12&lt;/li&gt; &lt;/ul&gt;` }) // 使用路由来管理模板 将url 跟模板进行绑定 const router = new VueRouter({ routes: [ //path 路由地址 component： vue模板地址 {path:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f2e4248921861715500a6ead02cafae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0967b16c4991f258baec1b039dcebfc/" rel="bookmark">
			阿里云域名解析设置自定义DNS服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 阿里云购买的域名服务支持解析自定义的的DNS服务器，可以通过自己配置的DNS服务器实现CDN请求分发。
详细的设置步骤如下：
首先登陆阿里云平台，然后在工作台中选择域名，进入域名服务页面：
1、设置自定义DNS Host 点击进入域名列表：
再点击管理进入该域名的管理页面：
点击左侧的 自定义 DNS Host 菜单，打开DNS服务器列表（之前没有创建的时候列表是空的）：
点击创建DNS服务器，添加服务器
假如你的域名是mydomain.com，这里DNS服务器填写dns表示你添加了一个DNS服务器，其对外的名称就叫 dns.mydomain.com，DNS服务器的IP地址是 10.56.254.68。
2、添加自定义DNS服务器的解析记录 回到域名列表页面，点击解析按钮，进入域名解析页面
点击列表上方的添加记录按钮
按照自定义 DNS Host 填写的信息，添加一条A记录，实现对 dns.mydomain.com 的解析。
3、添加其他解析记录 自定义DNS服务器的解析记录添加后，就可以选择NS记录类型使用自定义的DNS服务添加其他任意想要的解析记录了。
如想要使用自定义的DNS服务器解析 www.mydomain.com 就可以按照以下格式添加：
通常 www.mydomain.com 还是使用 A 记录 类型，交由平台解析，而对个别的的 child.mydomain.com 才使用 NS 记录类型由 自定义的DNS服务器 进行解析。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed6f48d809e4c148f3f540b4cf28bb61/" rel="bookmark">
			Linux配置nginx开机自启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.先创建开机自启脚本
cd /etc/systemd/system vi nginx.service 内容：
[Unit] Description=nginx service After=network.target [Service] Type=forking ExecStart=/usr/local/nginx/sbin/nginx ExecReload=/usr/local/nginx/sbin/nginx -s reload ExecStop=/usr/local/nginx/sbin/nginx -s quit PrivateTmp=true [Install] WantedBy=multi-user.target 2.设置开机自启动
systemctl enable nginx 3.启动nginx服务
systemctl start nginx.service 重新启动服务
systemctl restart nginx.service 查看服务当前状态
systemctl status nginx.service 停止开机自启动
systemctl disable nginx.service 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83fe94a1cb2f5c17ce0f52a3fcc4cd82/" rel="bookmark">
			IDEA dependencies全爆红解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA dependencies全爆红
第一步：在项目的pom.xml文件把dependency标签下的注释掉
第二步：重新加载，就看见红线消失
第三步：将注释掉的标签和数据都放回去，右键点击project----&gt;maven------&gt;reimport.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef9fbd9ebd710db7a49b2cd58d723a0a/" rel="bookmark">
			jQuery学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 初始JQuery1.1 原生js的缺点1.2 体验jQuery 2. JQuery的基础2.1 jQuery的入口函数2.2 $是一个函数2.3 DOM对象和jQuery对象 3. jQuery元素设置3.1 设置获取文本内容text()3.2 设置获取样式css()3.3 设置类名class()3.4 设置属性attr()3.5 prop()操作布尔类型的属性 4. 选择器4.1 基本选择器4.2 层级选择器4.3 过滤选择器-隔行变色4.4 筛选选择器(方法) 5. 动画5.1 基本动画5.1.1 显示show()与隐藏hide()5.1.2 滑入slideDown()与滑出slideUp()5.1.3 淡入fadeIn()与淡出fadeOut() 5.2 自定义动画5.3 动画队列-以及stop参数的含义 6. 插件6.1 jQuery插件介绍-颜色插件6.2 插件使用-省市联动6.3 插件的使用-UI6.4 自己开发jQuery插件6.5 表格插件6.6 tab栏切换插件 7. 结点操作7.1 动态创建元素-html()和$()7.2 jquery添加节点7.3 清空节点empty()与移除节点remove()7.4 克隆节点clone() 8. 特殊属性操作8.1 val()获取或设置表单元素内容8.2 width方法和height方法8.3 offset方法与position方法8.4 scrollLfet()和scrollTop() 9. 事件机制9.1 mouseenter和mouseleave9.2 jQuery时间发展历程及on9.3 事件解绑off()9.4 事件触发trigger()9.5 jQuery事件对象 10. 补充知识点10.1 链式编程与end10.2 显示迭代each()10.3 多库共存 1. 初始JQuery 1.1 原生js的缺点 不能添加多个入口函数(window.onload)，如果添加了多个，后面的会把前面的覆盖原生js的api名字都太长原生js有的时候代码冗余原生js中有些属性或者方法有浏览器兼容问题原生js容错率比较低，前面的代码出了问题，后面的代码执行不了 1.2 体验jQuery &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef9fbd9ebd710db7a49b2cd58d723a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17bcb121ed5d784a17224e484217e217/" rel="bookmark">
			vue：el-select同时获取多个值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 el-select获取的是value的值。如果想同时获取多个值，可以试试如下方法：
&lt;el-form-item label="所属角色" prop="roleName"&gt; &lt;el-select v-model="temp.roleName" placeholder="角色" @change="handleRoleChange"&gt; &lt;el-option v-for="item in roleList" :key="item.role_id" :label="item.role_name" :value="`${item.role_id},${item.role_name}`" &gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; const handleRoleChange = (val) =&gt; { let [id,name] = val.split(',') state.temp.roleId = id state.temp.roleName = name } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e58c4506b045bbe8316ba32c611c6041/" rel="bookmark">
			靶机渗透日记 Billu_b0x
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		端口
访问 80 端口
目录扫描
/add.php 文件下存在文件上传
没有上传成功
/test.php
缺少 file 参数，构造URL
http://ip/test.php?file=/etc/passwd 尝试不行，使用 post 方式
依次读取目录扫描到的文件
//add.php &lt;?php echo '&lt;form method="post" enctype="multipart/form-data"&gt; Select image to upload: &lt;input type="file" name=image&gt; &lt;input type=text name=name value="name"&gt; &lt;input type=text name=address value="address"&gt; &lt;input type=text name=id value=1337 &gt; &lt;input type="submit" value="upload" name="upload"&gt; &lt;/form&gt;'; ?&gt; //index.php &lt;?php session_start(); include('c.php'); include('head.php'); if(@$_SESSION['logged']!=true) { $_SESSION['logged']=''; } if($_SESSION['logged']==true &amp;&amp; $_SESSION['admin']!='') { echo "you are logged in :)"; header('Location: panel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e58c4506b045bbe8316ba32c611c6041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89c4febf4e31c3d82c144315de6c9e9/" rel="bookmark">
			总线之地址总线、数据总线、控制总线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/codexlx/p/13252705.html
1.地址总线： CPU是通过地址总线来指定存储单元的，因此总线地址上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址
一个CPU有N根地址线，那么可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元
2.数据总线： CPU与内存或者其他器件之间的数据传输时通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传输速度。
8根数据总线一次即可传送8位二进制数据（1个字节）；16位即可一次传送两个字节
8位数据总线：
16位数据总线：
16根数据总线一次传16位数据，位则需要传两次数据
3.控制总线 CPU对外部器件的控制时通过控制总线进行的。这里控制总线是一个统称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味这CPU提供了对外部器件的多少中控制。
前面所讲的内存读或写命令是由几根控制线综合发出的，其中有一根称为“读信号输出”的控制銭负责由CPU向外传送读值号，CPU向该控制线上输出低电平表示将要读取数据；有一根称为“写信号输出”的控制线则负责传送写信号.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b6c2730117e55db82a93e09078ee21a/" rel="bookmark">
			python导包出现 Import “torch.backends.cudnn“ could not be resolved PylancereportMissingImports 没有可用的快速修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先检查是不是下载了该包
pip list
如果没有下载该包，通过下面这个命令下载：
pip install torch=1.2.0 torchvision=0.4.0 -f https://download.pytorch.org/whl/torch_stable.html
如果下载了该包，说明你配置了多个python环境，而编辑器目前所在的python环境没有下载该包，可以选择更换编辑器环境或者重新在编辑器的环境下下载
更换环境步骤：ctrl+shift+p --&gt;输入：python:select interpreter选择下载了该包的环境
over✌
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a35ac24c1253401cd9ed20be141e588/" rel="bookmark">
			小菜鸡的学习笔记——sql注入之sqli-lab边学边练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结合sqli-lab靶场的sql注入学习笔记&lt;持续更新&gt; 第一关Way1：字符型联合注入Way2：报错型注入 第二关：get数值型联合注入第三关：字符型闭合注入第四关：字符型闭合注入第五关：报错注入第六关：字符型报错注入第七关：导出文件GET字符型注入第八关：布尔型盲注第九关：单引号时间型注入 第一关 Way1：字符型联合注入 测试语句id=1 and1=1 /1=2页面无区别 说明不是数字型注入
尝试字符型注入，因为我们猜测是基于select 查询方式的注入
由于数据库语句一般是下图格式
所以数据库查询语句就变成了：select’1 and 1=2’ LIMIT 0,1
使用字符型注入 id=1’ and 1=1/1=2测试 界面仍然没有变化
思考一下就知道了是因为$id后的语句没有被注释掉（注意这里要使用 --+ 使用#不行）
使用–+进行注入是因为+会被自动解析成 （空格）本来的注释是-- 空格有时会被省略
可以看到下图1的周围都是单引号，所以我们要将它闭合 id=1’ and ‘1’=‘1
这样sql语句就变成了 select ‘(从这开始就是我们写的语句了)1’ and ‘1’=‘1(后面的单引号是我们需要闭合的最后一个单引号)’
添加–+注释：
id=1’ and 1=1 --+ 与id=1’ and 1=2 --+ 回显不同 证明存在字符型注入
或使用： http://localhost/sqli-labs-master/Less-1/?id=1’ and ‘1’ =‘2
使用order by 查询到4时发生了报错，所以临界点为3
然后进行报错准备
使用1=2 或id=不存在的数都是可以的
使用union select 进行查询
http://localhost/sqli-labs-master/Less-1/?id=1’ and 1=2 union select 1,2,3 --+
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a35ac24c1253401cd9ed20be141e588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4e3325e16ba82a234c33dea4f2d4050/" rel="bookmark">
			子进程、僵尸进程、孤儿进程(个人总结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明: 1. 本文为我的个人复习总结, 并非那种从零基础开始普及知识 内容详细全面, 言辞官方的文章
2. 由于是个人总结, 所以用最精简的话语来写文章
3. 若有错误不当之处, 请指出
子进程:
由fork( )创建, 该函数被调用一次，但返回两次(子进程的返回值是0，而父进程的返回值是子进程id)
子进程得到的只是父进程的拷贝(拷贝其内存空间, 代码空间, 数据空间, 程序计数器pc值)，而不是父进程本身
僵尸进程:
子进程结束了, 但父进程暂未对其资源进行回收; task_struct结构还保存在进程列表中
孤儿进程:
在回收僵尸进程之前, 如果父进程结束了，则僵尸进程变为孤儿进程，进而被init进程接管、回收
注意: ps出来以Z开头的便是僵尸进程, kill -9 并不能直接死僵尸进程
为什么需要僵尸进程(保留task_struct)?
因为task_struct里面保存了进程的pid、退出码、以及一些统计信息, 父进程可能会关心这些信息
如何处理僵尸进程？
三个方案:
父进程调用wait( )/waitpid( )
缺点: wait调用是阻塞的, 如果调用wait时子进程还没有退出, 将阻塞住父进程 影响性能
kill父进程
使僵尸进程变为孤儿进程, 从而被init进程接管、回收
缺点: 父进程可能还有作用, 不该随随便便杀死
通过进程通信的信号机制 异步回调通知进行回收 (最佳)
编写程序时, 子进程退出前向父进程发送SIGCHLD信号; 父进程回调函数收到SIGCHLD信号后 便去调用wait( )/waitpid( ) 回收 子僵尸进程
什么时候会发生 僵尸进程一直不被回收 的情况?
在采用第三种方案时, 如果父进程是一个循环 永久不会结束, 那么子进程就会一直保持僵尸状态
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45220ccef5ff6dca5f152a342dfc1c6/" rel="bookmark">
			简单自定义协议的封包和解包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单自定义协议的封包和解包 一、通信协议1 百度百科的解释2 过于简单的通信协议引发的问题3 通信协议常见内容1.帧头2.设备地址/类型3.命令/指令4.命令类型/功能码5.数据长度6.数据7.帧尾8.校验码 4 通信协议代码实现（DGUS串口屏的例子）1.消息数据发送2.消息数据接收 5 最后最后强调两点： 二、怎样用串口发送结构体-简单协议的封包和解包定义要发送的结构体下位机封包发送1、拆分2、封包3、发送 上位机接收数据并解包1、读取数据2、找到一个完整的数据包3、解析数据 三、嵌入式硬件通信接口协议-UART（五）数据包设计与解析应用层数据包设计思路项目案例常规解析过程构建查表方式解析 四、DL-T 645协议格式或者DL-T 698协议格式的数据帧的串口解析思路串口解析思路 五、Qt 实现数据协议控制--组帧、组包、解析帧、解析包数据传输中的组帧和组包一、数据帧，数据包的概念二、 程序实现：2.1、frame(帧)类的实现： 六、如何用串口解析出协议帧，并解决分包，组包，粘包问题？七、串口协议包的接收及解析处理 原文链接：https://blog.csdn.net/sinat_16643223/article/details/118830297
一、通信协议 有一些初学者总觉得通信协议是一个很复杂的知识，把它想的很高深，导致不知道该怎么学。
同时，偶尔有读者问关于串口自定义通信协议相关的问题，今天就来写写串口通信协议，并不是你想想中的那么难？
1什么通信协议？
通信协议不难理解，就是两个（或多个）设备之间进行通信，必须要遵循的一种协议。
1 百度百科的解释 通信协议是指双方实体完成通信或服务所必须遵循的规则和约定。通过通信信道和设备互连起来的多个不同地理位置的数据通信系统，要使其能协同工作实现信息交换和资源共享，它们之间必须具有共同的语言。交流什么、怎样交流及何时交流，都必须遵循某种互相都能接受的规则。这个规则就是通信协议。
相应该有很多读者都买过一些基于串口通信的模块，市面上很多基于串口通信的模块都是自定义通信协议，有的比较简单，有的相对复杂一点。
举一个很简单的串口通信协议的例子：比如只传输一个温度值，只有三个字节的通信协议：
这种看起来是不是很简单？它也是一种通信协议。
只是说这种通信协议应用的场合相对比较简单（一对一两个设备之间），同时，它存在很多弊端。
2 过于简单的通信协议引发的问题 上面那种只有三个字节的通信协议，相信大家都看明白了。虽然它也能通信，也能传输数据，但它存在一系列的问题。
比如：多个设备连接在一条总线（比如485）上，怎么判断传输给谁？（没有设备信息）
还比如：处于一个干扰环境，你能保障传输数据正确吗？（没有校验信息）
再比如：我想传输多个不确定长度的数据，该怎么办？（没有长度信息）。
上面这一系列问题，相信做过自定义通信的朋友都了解。
所以，在通信协议里面要约定更多的“协议信息”，这样才能保证通信的完整。
3 通信协议常见内容 基于串口的通信协议通常不能太复杂，因为串口通信速率、抗干扰能力以及其他各方面原因，相对于TCP/IP这种通信协议，是一种很轻量级的通信协议。
所以，基于串口的通信，除了一些通用的通信协议（比如：Modubs、MAVLink）之外，很多时候，工程师都会根据自己项目情况，自定义通信协议。
下面简单描述下常见自定义通信协议的一些要点内容。
（这是一些常见的协议内容，可能不同情况，其协议内容不同）
1.帧头 帧头，就是一帧通信数据的开头。
有的通信协议帧头只有一个，有的有两个，比如：5A、A5作为帧头。
2.设备地址/类型 设备地址或者设备类型，通常是用于多种设备之间，为了方便区分不同设备。
这种情况，需要在协议或者附录中要描述各种设备类型信息，方便开发者编码查询。
当然，有些固定的两种设备之间通信，可能没有这个选项。
3.命令/指令 命令/指令比较常见，一般是不同的操作，用不同的命令来区分。
举例：温度：0x01；湿度：0x02；
4.命令类型/功能码 这个选项对命令进一步补充。比如：读、写操作。
举例：读Flash：0x01； 写Flash：0x02；
5.数据长度 数据长度这个选项，可能有的协议会把该选项提到前面设备地址位置，把命令这些信息算在“长度”里面。
这个主要是方便协议（接收）解析的时候，统计接收数据长度。
比如：有时候传输一个有效数据，有时候要传输多个有效数据，甚至传输一个数组的数据。这个时候，传输的一帧数据就是不定长数据，就必须要有【数据长度】来约束。
有的长度是一个字节，其范围：0x01 ~ 0xFF，有的可能要求一次性传输更多，就用两个字节表示，其范围0x0001 ~ 0xFFFFF。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e45220ccef5ff6dca5f152a342dfc1c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576a4fb6a2d607c9e7c3156e590cc6d2/" rel="bookmark">
			关于FPGA的多功能引脚(multi-function pin)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 多功能引脚组成 多功能引脚（multi-function pin），名字以 IO_LXXY_ZZZ_# 或 IO_XX_ZZZ_# 为前缀，zzz 代表其除用户I/O功能外的其他具体功能含义。如果多功能引脚没有用于其特定功能作用，则作为普通的用户I/O功能外的其他具体功能含义使用。
以 XC7K410T-FF900 为例，多功能引脚的位置：
可见主要集中在bank 14 与 15。
主要包含：
ADV_BFCS_BFOE_BMOSIFWE_BDOUT_CSO_BCSI_BPUDC_BRDWR_BRS0-RS1AD 0-15 P/NEMCCLKVRNVRPVERFD 00-31A 00-28DQSMRCCSRCC multi-function pin 作为配置引脚来使用的。
2 多功能引脚作用 多功能引脚的具体使用与否是根据 FPGA 的配置模式来决定的，7系列FPGA有 5 种配置模式，具体使用哪种由 FPGA 的专用引脚（Dedicated Pin）中的 M[2:0] 决定：
具体配置模式与使用的多功能引脚的关系为：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad7c6709cfc6249b6d116731b7da3cd/" rel="bookmark">
			vue跨域问题：The value of the ‘Access-Control-Allow-Credentials‘ header in the response is...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨域报错如下：
由于我在封装axios时，设置了这个：
//允许跨域携带cookie信息 axios.defaults.withCredentials = true; 这一条允许在请求头里带上cookie信息。
如果前端配置了withCredentials=true，后端设置Access-Control-Allow-Origin不能为 " * ",而必须是你的源地址。
header("Access-Control-Allow-Origin","源地址"; header("Access-Control-Allow-Credentials", "true"); 后来查询得知：可能是处于安全性考虑，*是所有的域名都可以读取到数据，可能会读取到cookie等敏感数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0d4bd5d7603a78bfb546fc862699df/" rel="bookmark">
			国科大.模式识别与机器学习.期末复习笔记手稿&#43;复习大纲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写在最前 这是博主复习《模式识别与机器学习》这门课程时的手稿。本文基本覆盖了这门课程的所有知识点，认真复习的话90分以上没有什么问题，如果有哪里的字体难以辨认，请评论区留言。
另外，需要历年考试真题的同学可以在评论区留言，祝考试顺利！
复习大纲 第二章统计判别
贝叶斯判别准则最小风险判别正态分布模式的贝叶斯分类器： 类先验分布参数估计类条件分布参数估计 第三章判别函数
线性判别的原理Fisher线性判别感知器算法经典迭代训练算法 第四章特征选择和提取
特征选择主要方法概念K-L变换（主成分分析PCA）原理和流程 第五章统计学习理论基础
过拟合与正则化泛化能力分析 第六章监督学习
判别式分类模型：逻辑回归LR生成式分类模型：高斯判别分析、朴素贝叶斯分类器参数估计：极大似然估计（MLE）、最大后验估计（MAP） 第七章支持向量机
SVM原型问题的形式化SVM对偶问题的形式化 第八章聚类：经典聚类算法的基本原理和适用场景
K均值聚类GMM层次聚类基于密度聚类（DBSCAN） 第九章降维
线性降维：PCA流程非线性降维：核PCA基本概念流形模型：全局嵌入和局部嵌入的代表性方法 第十章半监督学习
半监督学习的常用假设常用方法的基本概念 自我训练多视角学习基于GMM的生成模型S3VM（TSVM） 第十一章概率图模型
有向概率图模型的表示条件独立性判断隐马尔可夫模型（HMM）的原理Viterbi 解码 第十二章集成学习
偏差与方差分析欠拟合与过拟合的判断和改进Bagging原理Boosting原理 第十三章深度学习
神经元基本模型常用激活函数及其特性：Sigmoid、ReLU卷积神经网络CNN原理深度网络参数训练技巧、深度模型避免过拟合的策略 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4d8833c899c0cdc995091672c48028/" rel="bookmark">
			时序数据库InfluxDB介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时序数据库InfluxDB介绍 1 .什么是InfluxDB2.那么时序数据有什么特点呢？3.对于时序数据，我们总结了以下特点：4.业务方常见需求5.时序数据库为了解决什么问题？6.InfluxDB的优势实时数据库与时序数据库DBengine 排名第一时序数据库，阿里云数据库 InfluxDB 正式商业化！排名前十的时序数据库 原文链接：https://blog.csdn.net/weixin_43135178/article/details/108809344
1 .什么是InfluxDB InfluxDB是一个开源的、高性能的时序型数据库，在时序型数据库DB-Engines Ranking上排名第一。
在介绍InfluxDB之前，先来介绍下时序数据。按照时间顺序记录系统、设备状态变化的数据被称为时序数据（Time Series Data），如CPU利用率、某一时间的环境温度等。
时序数据以时间作为主要的查询纬度，通常会将连续的多个时序数据绘制成线，制作基于时间的多纬度报表，用于揭示数据背后的趋势、规律、异常，进行实时在线预测和预警，时序数据普遍存在于IT基础设施、运维监控系统和物联网中。随着物联网时代的到来，时序数据的数据量呈井喷式爆发，针对于这一数据细分的优化存储显得越来越重要。
最初，使用通用存储系统存储时序数据，如MySQL。第一代时序平台，如KDB +、RRDtool、Graphite等，在20年前就推出了，主要用于存储和分析数据中心的时序数据，以及高频金融数据、股票波动率等。
根据DB-Engines等数据库趋势跟踪和行业分析网站发布的信息，时序型数据库是数据库市场中份额增长最快的部分。原因很明显，计算机虚拟世界，如数据库、网络、容器、系统、应用程序等，和物理世界，如家用设备、城市基础设施、工厂机器、电力设施等，正在创建海量的时序数据。
现在更多的企业会通过时序存储和数据分析来获得预测能力和实时决策能力，从而为客户提供更好的使用体验。这意味着底层数据平台需要发展以应对新的工作负载的挑战，以及更多的数据点、数据源、监控维度、控制策略和精度更高的实时响应，对下一代时序中台提出了更高的要求
2.那么时序数据有什么特点呢？ ​ 时序数据有这几个属性：
​ 度量的数据集（measurement），类似于关系型数据库中的 table；
​ 一个数据点（point），类似于关系型数据库中的 row；
​ 时间戳（timestamp），表征采集到数据的时间点；
​ 维度列（tag），代表数据的归属、属性，表明是哪个设备/模块产生的，一般不随着时间变化，供查询使用；
​ 指标列（field），代表数据的测量值，随时间平滑波动。
​ 如下图所示的数据：
3.对于时序数据，我们总结了以下特点： 1.数据特点：数据量大，数据随着时间增长，相同维度重复取值，指标平滑变化（某辆车的某个设备上传上来平滑变化的轨迹坐标）。
2.写入特点：高并发写入，且不会更新（轨迹不会更新）【基本上都是插入，没有更新的需求】。
3.查询特点：按不同维度对指标进行统计分析，存在明显的冷热数据，一般只会查询近期数据（一般我们只会关心近期的轨迹数据）。
数据基本上都有时间属性，随着时间的推移不断产生新的数据。
数据量大，每秒钟需要写入千万、上亿条数据
4.业务方常见需求 获取最新状态，查询最近的数据(例如传感器最新的状态)
展示区间统计，指定时间范围，查询统计信息，例如平均值，最大值，最小值，计数等。。。
获取异常数据，根据指定条件，筛选异常数据
举例：
监控软件系统： 虚拟机、容器、服务、应用
监控物理系统： 水文监控、制造业工厂中的设备监控、国家安全相关的数据监控、通讯监控、传感器数据、血糖仪、血压变化、心率等
资产跟踪应用： 汽车、卡车、物理容器、运货托盘
金融交易系统： 传统证券、新兴的加密数字货币
事件应用程序： 跟踪用户、客户的交互数据
商业智能工具： 跟踪关键指标和业务的总体健康情况
在互联网行业中，也有着非常多的时序数据，例如用户访问网站的行为轨迹，应用程序产生的日志数据等等
5.时序数据库为了解决什么问题？ 传统数据库通常记录数据的当前值，时序型数据库则记录所有的历史数据，在处理当前时序数据时又要不断接收新的时序数据，同时时序数据的查询也总是以时间为基础查询条件，并专注于解决以下海量数据场景的问题：
专为时序存储和高性能读写而设计：计算机虚拟世界的各种系统和应用，以及物理世界的IoT设备等都在创建海量的时序数据，每秒千万级的数据吞吐量是很常见的，而且这些数据还需要可以以非阻塞方式接收并且可压缩以节省有限的存储资源。如何支持千万级/秒数据的写入。如何支持千万级/秒数据的聚合和查询。
专为实时操作而设计：预测能力和实时决策能力，需要收到数据后，就能实时输出最新的数据分析结果，执行预定义的操作。
专为高可用性而设计：现代软件系统需要全天候可用，除了基本的集群能力，还需要根据需求自动扩容和缩容，支持柔性可用等。
成本敏感：海量数据存储带来的是成本问题，如何更低成本地存储这些数据，是时序型数据库需要解决的关键问题。
6.InfluxDB的优势 InfluxData选择从头开始构建InfluxDB以支持下一代时序中台的需求，InfluxDB通过实现高度可扩展的数据接收和存储引擎，可以高效地实时收集、存储、查询、可视化显示和执行预定义操作。它通过连续查询提升查询效率和缩短延迟，通过数据保留策略，及时高效地删除过期冷数据，提升存储效率。
为什么通用数据库在时序场景上不是最优的选择呢？许多通用数据库正在为时序数据添加一些支持，虽然可能很容易使用，但它们基本上都不是针对海量时序数据的吞吐量和实时操作而设计的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d4d8833c899c0cdc995091672c48028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9621916ec2788d139c155a172b22fa6a/" rel="bookmark">
			IDEA&#43;Java&#43;JSP&#43;Mysql&#43;Tomcat实现Web学生宿舍信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、系统介绍
1.开发环境
2.技术选型
3.系统功能
4.数据库文件
5.系统截图
二、系统展示
1.登录系统
2.系统主页
3.新增宿舍
4.修改宿舍
三、部分代码 AdminDaoImpl
DormDaoImpl
dorm-add.jsp
dorm-add-do.jsp
四、其他
1.更多系统
Java+JSP系统系列实现
Java+Servlet系统系列实现
Java+SSM系统系列实现
Java+SSH系统系列实现
Java+Springboot系统系列实现
2.源码下载
3.运行项目
4.备注
5.支持博主
一、系统介绍 1.开发环境 开发工具：IDEA2018
JDK版本：Jdk1.8
Mysql版本：8.0.13
2.技术选型 Java+Jsp+Mysql
3.系统功能 1.登录系统；
2.管理员对宿舍信息的增删改查。
4.数据库文件 /* Navicat Premium Data Transfer Source Server : MYSQL Source Server Type : MySQL Source Server Version : 80013 Source Host : localhost:3306 Source Schema : jsp_dorm_management Target Server Type : MySQL Target Server Version : 80013 File Encoding : 65001 Date: 28/02/2022 17:24:06 */ SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for admin -- ---------------------------- DROP TABLE IF EXISTS `admin`; CREATE TABLE `admin` ( `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL, `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC; -- ---------------------------- -- Records of admin -- ---------------------------- INSERT INTO `admin` VALUES ('admin', 'admin'); -- ---------------------------- -- Table structure for dorm -- ---------------------------- DROP TABLE IF EXISTS `dorm`; CREATE TABLE `dorm` ( `id` int(11) NOT NULL, `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `num` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `head` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL ) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic; -- ---------------------------- -- Records of dorm -- ---------------------------- INSERT INTO `dorm` VALUES (1001, '燕园一栋', '4', '张三'); INSERT INTO `dorm` VALUES (1002, '燕园二栋', '4', '李四'); INSERT INTO `dorm` VALUES (1003, '燕园三栋', '4', '王五'); INSERT INTO `dorm` VALUES (1004, '燕园四栋', '4', '赵六'); SET FOREIGN_KEY_CHECKS = 1; 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9621916ec2788d139c155a172b22fa6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6cde713e111980717d0120fe9642a6a/" rel="bookmark">
			某城市的出租车计费标准为起步价10元（3公里内含3公里），在3公里到10公里（含10公里）之间每公里2.1元，超过10公里部分每公里3元。编写程序，用Python实现输入行车距离x，输出车费。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sum =0 sum= eval(input("请输入行车距离：")) total=0 if 0&lt;sum &lt;=3: total=10; elif 3 &lt;sum&lt;=10: temp =sum-3 total =10 +temp*2.1 elif sum&gt;10: temp1= sum -10 total =10+ 7*2.1 + temp1*10 if 0 &lt;sum: print( "您输入的行车距离需要的行车费用大概为：",total ) else: print("请输入正确的行车距离") 分析题意 判断行车距离大概在什么区间内 sum在0-3公里之内为10块 ； 0&lt;sum&lt;10,超过3的部分为2.1块每公里；超过10公里的，每公里3块 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/117/">«</a>
	<span class="pagination__item pagination__item--current">118/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/119/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>