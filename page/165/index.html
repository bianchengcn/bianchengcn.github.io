<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43627d43a59de097c41a5a8b6c6e36df/" rel="bookmark">
			查找两个数组中的相同元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一、循环遍历
两个for循环遍历，执行次数最多，效率较低
public static List&lt;Integer&gt; findCommon(int[] arr1, int[] arr2) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (arr1 == null || arr2 == null || arr1.length == 0 || arr2.length == 0) { return list; } for(int i=0;i&lt;arr1.length;i++) { for(int j=0;j&lt;arr2.length;j++) if(arr1[i]==arr2[j]) { list.add(arr1[i]); } } return list; } 方法二、归并思想
归并的思想，复杂度为O(M+N),M和N分别为两个数组的长度，所以这种方法效率是比遍历高很多，但是前提是有序，如果不有序，那么先对其进行排序，而且此种方法适用于两个数组存在重复元素的情况。
这种方法设置两个数组指针，在相等的时候同时后移，如果不相等，谁小谁++，你追我赶，遍历完任何一个数组，那么就可以结束。
public static List&lt;Integer&gt; findCommon(int[] arr1, int[] arr2) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (arr1 == null || arr2 == null || arr1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43627d43a59de097c41a5a8b6c6e36df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d58818e47542d53d66ec630377fc4567/" rel="bookmark">
			Spleeter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于需要研究声源分离方向,然后拿效果比较好的spleeter开始研究.
由于想要弄清楚里面的步骤,所以采用debug的模式来跟踪程序执行的过程.
然后
走的坑1:从命令行运行和从脚本运行的结果不同
原因:从命令行运行的程序是我使用pip安装的spleeter,而从脚本运行的是我从github上面下的代码.
由于需要debug,不打习惯从命令行调试,所以搞清楚输入的变量是什么之后,就直接将它赋值给了argv.
坑 2 :spleeter里面自带了musdb18数据集的csv文件,然后musdb18数据集里面是MP4文件.之前没处理的时候,跑训练过程都是提示获取的数据是空值,压根就没有训练模型.然而,当我将这些值转化成wav之后,跑训练过程还是说输入可能是空值什么的.
可能原因:①硬盘里面容量不够了,当时硬盘的利用率已经98%了,在我无意中将硬盘里面的内容清空掉,然后回来执行程序的时候发现是可以执行的（但是现在从命令行进行训练，好像还是不行，后面会继续跟进）.
坑3:程序一直在运行，但是看不到任何的打印输出信息．
修改了部分代码，我把spleeter/__main__.py里面的一些代码屏蔽掉了，所以没能看见打印出来的信息．
from spleeter.utils.logging import enable_logging,enable_verbose_logging 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d0bdc7a62001b27e125bcd8649b3d3/" rel="bookmark">
			idea编辑器关闭重复代码检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IntelliJ IDEA默认都开启重复代码的检查，代码下方会出现波浪线，对于强迫症的来说简直不能忍。通过以下操作可以设置关闭。
File -&gt; Settings -&gt; Editor -&gt; Inspections 把这个地方的√去掉
按OK退出即可
如果其他项目也要关闭这项检查，打开File-&gt;Other Settings-&gt;Settings For New Projects，再操作一遍即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3426a585e61e940b9f8bdeeb5421cd69/" rel="bookmark">
			2020.08最新必看 pytorch&#43;cuda10.2（或10.1）&#43;python3.7版 30min完成安装（五小时血泪经验）亲测可用！！防坑！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主之前电脑显卡为A卡一直在用cpu版本的，由于新换了一台1660ti卡的笔记本于是研究了一下怎么装gpu版本的pytorch下面进入正文，只有显卡为N卡才能装pytorch的cuda的版本，其他卡只能用CPU的版本。
Anaconda是一个开源的包、环境管理器，可以用于在同一个电脑上安装不同版本的软件包，并能够在不同的环境之间切换，Anaconda不是语言，它只是python的一个集成管理工具或系统，我们只需要安装Anaconda就可以了，甚至不用单独去安装python。
我们在使用过程中会出现conda，实际上这是一个可执行的命令，它的重要的功能就是包管理与环境管理，包管理也就是下载众多packages和科学计算工具等，环境管理就是用户可以安装不同版本的python来进行快速切换。安装anaconda让我们省去了大量下载模块包的时间，更加方便。
一、Anaconda的安装 1：下载地址：官网（国内速度较慢100M网速自测200kb/s）：https://www.anaconda.com/products/individual.
建议使用：清华大学开源软件镜像站（速度较快100M网速自测10mb/s）：
链接: 清华大学开源软件镜像站.
官网界面如下：
清华大学开源软件镜像站界面如下：
请下载Windows Python3.8版本的，64位还是32位根据自己电脑情况，一般为64位，右击我的电脑属性可以查看。
2.anaconda安装过程一路next,这里建议just me
3.这里建议不安装在C盘，占用空间过大。但是不要安装在包含空格和中文的路径下
4.不建议勾选第一项，勾选的话能直接在cmd中使用conda、jupyter、ipython等命令，不勾选的话，也可以在之后使用Anaconda提供的命令行工具进行操作，这个其实勾不勾选问题都不大，建议不勾选，未勾选的话后续进行环境变量的配置不会出现问题。
5.最后完成安装，选中learn会弹出页面可以取消。
二、检查显卡设备 首先我们要确定电脑是否有独立显卡，可以在计算机-管理-设备管理器-显示适配器中，查看是否有独立显卡，可以看到我的电脑有两个显卡，一块集成显卡一块独立显卡N卡。
其次要知道的是高版本的cuda是可以兼容低版本的cuda的，比如我的电脑支持cuda11.0，我就可以安装cuda10.0/cuda10.1/cuda10.2等，但是如果我的电脑只支持cuda10.0那就不可以反过来安装cuda10.1。
打开NVIDIA控制面板，点击 帮助——系统信息——组件，查看自己电脑支持的cuda版本，我的笔记本显卡为GTX1660ti可以看到CUDA为11.0，那么我们可以安装cuda为10.1或10.2版本的pytorch，cudnn的版本只需要与需要用到的cuda版本对应即可后续说明。
三、安装并配置CUDA 1。到链接: 英伟达官网.官网下载对应的CUDA版本。我下载的版本是CUDA10.2
我选择的是exe[network]也就是在线安装，最后下载，下载完成后双击exe文件。
2。安装CUDA：双击执行下载的exe文件，会先解压文件到临时目录（不是安装目录），保持默认即可
3。这里需要选择自定义安装
4。这里要把图示圈起来的对勾去掉
5。这三个地址十分重要，后续我们将进行环境变量的配置，不要改变路径。
6。之后等待安装完成即可。
7。配置CUDA环境变量
首先右键我的电脑-属性-高级系统设置-环境变量
在Path中手动添加如下路径：
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\lib\x64
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\include
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\extras\CUPTI\lib64
C:\ProgramData\NVIDIA Corporation\CUDA Samples\v10.2\bin\win64
C:\ProgramData\NVIDIA Corporation\CUDA Samples\v10.2\common\lib\x64
8。我们可以验证一下cuda是否成功，按win+R 输入cmd
输入命令`
nvcc -V 安装成功10.2版本
四、安装cuDNN 到链接: 英伟达.下载与CUDA对应的cuDNN，这里需要我们注册一个账号，然后登录下载，下载时一定注意与CUDA的版本对应，如果你下载的CUDA为10.2则下载第二个。
下载之后，解压缩，将CUDNN文件夹中的各自的bin、clude、lib文件夹中的内容，直接复制添加到CUDA的刚刚安装目录的对应相同名字的文件夹下。
五、pytorch安装 1。打开链接: pytorch官网.找到匹配的版本，我选择的是win10下的CUDA为10.2的版本，很多教程使用conda下载，我强烈建议使用pip下载，在经历五个小时找bug后使用pip下载，各种错误直接消失很快装好
可以看到给出了命令，但是在国内不翻墙的情况下，下载速度极慢并且容易卡顿，我修改了一下命令，可以使用国内的清华源进行下载，速度较快。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3426a585e61e940b9f8bdeeb5421cd69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f809af6e12058c063a8a01ed32cd94b9/" rel="bookmark">
			Asp.net WebApi 项目示例（增删改查）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Asp.net WebApi 项目示例（增删改查） 1.WebApi是什么
ASP.NET Web API 是一种框架，用于轻松构建可以由多种客户端（包括浏览器和移动设备）访问的 HTTP 服务。ASP.NET Web API 是一种用于在 .NET Framework 上构建 RESTful 应用程序的理想平台。
可以把WebApi看成Asp.Net项目类型中的一种，其他项目类型诸如我们熟知的WebForm项目，Windows窗体项目，控制台应用程序等。
WebApi类型项目的最大优势就是，开发者再也不用担心客户端和服务器之间传输的数据的序列化和反序列化问题，因为WebApi是强类型的，可以自动进行序列化和反序列化，一会儿项目中会见到。
下面我们建立了一个WebApi类型的项目，项目中对产品Product进行增删改查，Product的数据存放在List&lt;&gt;列表（即内存）中。
2.页面运行效果
如图所示，可以添加一条记录; 输入记录的Id，查询出该记录的其它信息； 修改该Id的记录； 删除该Id的记录。
开始建项目
1）新建一个“ASP.NET Web API项目：
2）和MVC类型的项目相似，构建程序的过程是先建立数据模型（Model）用于存取数据,
这里我们先在Models文件夹中建立产品Product类： Product.cs，如下：
using System; using System.Collections.Generic; using System.Linq; using System.Web; namespace WebApplication7.Models { public class Product { public int Id { get; set; } public string Name { get; set; } public string Category { get; set; } public decimal Price { get; set; } } } 3）试想，我们目前只有一个Product类型的对象，我们要编写一个类对其实现增删改查，以后我们可能会增加其他的类型的对象，再需要编写一个对新类型的对象进行增删改查的类，为了便于拓展和调用，我们在Product之上构造一个接口，使这个接口约定增删改查的方法名称和参数，所以我们在Models文件夹中新建一个接口： IProductRepository.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f809af6e12058c063a8a01ed32cd94b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3733ed4b84974441663d13e0b0893566/" rel="bookmark">
			揭秘三大运营商在5G专网的布局！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专网通信市场规模逐年增长
专网通信是指通过建设安全可靠的无线服务的专业网络，为特定的部门或群体如政府与公共安全等行业提供应急通信、指挥调度、日常工作通信等服务。
专网通信可以有效弥补了公网通信所无法涉及的领域。根据2018年3月十三届全国人大一次会议第四次全体会议，国务院提出拟组建应急管理部，提升专网需求。国家政策的支持也推动我国专网通信行业市场发展。
另外，随着国家经济快速发展，对于公共安全的重视程度也在不断加深，带动了对于专网通信的需求。
我国专网通信行业市场规模不断增长，据中国产业信息网数据，2009-2018年我国专网通信行业在不断扩大发展，2018年专网通讯市场规模的市场规模超过200亿元，专网通讯产值超过500亿元。
代表着专网通信由于自身安全可靠、自主控制、保密性高等特点带来需求端的高景气度。专网通信系统在不断发展的同时也面临着一些问题。
5G专网能解决传统专网的哪些问题？
5G专用网络（private 5G network）是一种局域网（LAN），它将使用5G技术创建具有统一连接性、优化服务和特定区域内安全通信方式的专用网络 。
结合5G通信自身具备的低时延、高速率和广连接三大特征，5G专网实现了信息安全性，网络专有性及可靠性等特点，完善了专网带宽低、时延长、安全性相对较差等弊端。
说明将传统专网向5G专网的升级存在解决当前专网通信长期存在问题的较大可能性。
第一，我国频谱资源大部分已经划分给了公网，这使得能够划分给专网的频谱资源十分有限。特别是宽带专网通信对频谱的需求较大。然而对于具有网络专有性的5G专网，国家可能会释放专门的5G专网频谱。
第二，许多垂直行业如公安、轨道交通、军队等对网络通信的要求越来越高，具有覆盖范围广、高带宽、高保密性等需求，5G专网在这些方面能很好的满足。另外，虽然宽带通信在不断发展，但网络资源频率在目前是受限的，然而大数据时代对于数据的需求在不断增加。在这种情况下，5G大带宽低时延的优点使得5G专网占有优势。
此前，机构曾预测2020年全球5G专网市场规模将达到9.197亿美元， 2020年至2027年间的复合年增长率将达到37.8％。而北美将以31.2％的份额在5G专网市场中占主导地位。
三大运营商关于专网的布局
5G时代专网建设方法主分为自建独立物理5G专网及依靠运营商，利用边缘计算、网络切片技术建立虚拟专网两种。
国际上主流为向企业分配专网频段并自建专网，德国、日本、英国、荷兰、法国等国家已允许企业自建5G专用网络且为垂直行业分配了5G专网频段，企业只需支付一定的费用即可使用。
我国主要为依靠运营商，利用边缘计算、网络切片技术建立虚拟专网，目前运营商正积极与各行各业合作建设虚拟5G专网，三大运营商中国移动、中国联通、中国电信皆推出自身专网解决方案及发展路径。
01、中国移动为5G专网为行业客户提供一站式全流程服务
中国移动5G专网建设布局较早，推出专网平台，网络定制化能力较强。2019年11月18日，中国移动发布《5G 行业专网研究报告》，根据无线建网方式差异提出面向行业客户的5G M.V.P 三类行业无线专网方案。
（a）M混合专网提供高性能、高隔离的解决方案;
（b）V虚拟专网提供低成本增强性能的解决方案;
（c）P物理专网提供极致性能极致隔离的解决方案；
2020年7月22日，中国移动正式发布5G专网产品、技术、运营三大体系与运营平台，明确5G行业专网的组网需求、网络架构及网络端到端的主要技术需求，帮助行业客户快速构建安全可靠、性能稳定、服务可视的定制化专属网络。
中国移动5G行业专网可以使用公网资源
中国移动5G专网逻辑网络架构与国际主流接轨 中国移动专网采取边缘计算+虚拟组网技术，ToB端同ToC端各自独立建设AMF/SMF/UDM/UPF等单元并进行必要的互通，整体共用无线，仅在特定需求场景下建设基站以提供专用无线资源；共用传输网络，通过SPN软、硬隔离手段为ToB应用按需划分传输资源。
中国移动专网预计2021年H2具备商用能力
02、中国电信凭借自身云优势开展云网融合，专网应用领域多元化
中国电信在5G专网发展方面重视技术验证及网络基础稳定。中国电信于2019年4月携手华为完成了业界首个基于5G SA网络切片的验证，并开通5G云专线，为不同行业下游客户提供更加可靠更低时延的端到端切片行业云专网。中国电信旨在增强电网与电力用户间的双向互动，有效提升在突发电网负荷超载的情况下对电网末端小颗粒度负荷单元的精准管理能力，进而将因停电所造成的经济、社会影响降至最低。
中国电信将云网与5G专网结合，正逐步探索5G专网应用领域多元化。2019年6月27日，中国电信在上海举办行业客户5G云网发布会，发布了媒体、医疗、教育、金融、物联、视频六大5G行业云网方案，推动5G与垂直行业相结合的业务创新。
其中物联方面尤为受到业内关注，中国电信通过5G、NB、光网融合搭建物联专网，与互联网完全隔离，帮助水务、消防、车联网等客户应用及终端模组间提供数据的安全采集和高效传输，为客户提供更便捷地一站式服务体验。
2020年7月3日，中国电信与三一重工签署战略合作协议。中国电信将为三一规划建设以总部为中心，构建辐射全国厂区的工业互联网精品云专网，同时为三一各个厂区构建5G专网，为三一在工业互联网领域的发展奠定良好的网络基础。
03、中国联通5G专网以行业应用为主联通方面
5G专网扩张重点在于拓宽应用行业。公司从2018年开始在新媒体、工业互联网、交通、教育、医疗、文旅等重点行业与行业头部客户打造典型5G应用场景，目前正逐步拓宽5G专网应用行业。
中国联通在山西霍州庞庞塔煤矿800米的井下，搭建了全国第一张井下5G专网，解决了煤矿行业安全生产的问题。
中国联通也与湛江钢铁案合作，业务首先通过基站专用无线通道到达企业的5G核心网，然后路由到了自己的业务服务器，从而实现了企业业务和公网业务的隔离。
湛江钢铁通过投建5G核心网打造了智能化钢铁工厂技术平台，目前已实现了炼钢厂风机在线检测与诊断、焦炉四大车、硅钢移动操控、机器人远程操控、智能头盔远程指导等应用场景的落地。
据人民邮电报数据显示，通过部署5G网络，湛江钢铁车辆自动化率可提升至99%，每年可节省设备通信费用约460万，每天可减少员工工作时间约1小时通过5G网络。
本文由5G产业圈编辑整理自开源证券《5G专网助力产业横向拓展，打开5G纵向新空间》
文件下载
如需下载开源证券《5G专网助力产业横向拓展，打开5G纵向新空间》PDF文件，请前往我们公众号对话框回复“ 817 ”。
本次分享仅供学习交流，不作商业用途，如有问题，请留言。若转载，请注明来源。
一张表全面了解各省市5G建设目标
2020中国新基建409家细分领域龙头企业全名单！
35省/市5G建设最新进展与规划一览
附下载｜《网络安全先进技术与应用发展系列报告——零信任技术（Zero Trust）》正式发布 我叫“5G产业圈”
长按扫码关注
最新5G资讯都在这里！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/499f1c8dea18015820f11c000a2560ee/" rel="bookmark">
			Tomcat 高并发之道原理拆解与性能调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上帝视角拆解 Tomcat 架构设计，在了解整个组件设计思路之后。我们需要下凡深入了解每个组件的细节实现。从远到近，架构给人以宏观思维，细节展现饱满的美。关注「码哥字节」获取更多硬核，你，准备好了么？
上回「码哥字节」站在上帝视角给大家拆解了 Tomcat 架构设计，分析 Tomcat 如何实现启动、停止，通过设计连接池与容器两大组件完成了一个请求的接受与响应。连接器负责对外交流，处理 socket 连接，容器对内负责，加载 Servlet 以及处理具体 Request 请求与响应。详情点我进入传输门：Tomcat 架构解析到工作借鉴。
高并发拆解核心准备 这回，再次拆解，专注 Tomcat 高并发设计之道与性能调优，让大家对整个架构有更高层次的了解与感悟。其中设计的每个组件思路都是将 Java 面向对象、面向接口、如何封装变与不变，如何根据实际需求抽象不同组件分工合作，如何设计类实现单一职责，怎么做到将相似功能高内聚低耦合，设计模式运用到极致的学习借鉴。
这次主要涉及到的是 I/O 模型，以及线程池的基础内容。
在学习之前，希望大家积累以下一些技术内容，很多内容「码哥字节」也在历史文章中分享过。大家可爬楼回顾……。希望大家重视如下几个知识点，在掌握以下知识点再来拆解 Tomcat，就会事半功倍，否则很容易迷失方向不得其法。
一起来看 Tomcat 如何实现并发连接处理以及任务处理，性能的优化是每一个组件都起到对应的作用，如何使用最少的内存，最快的速度执行是我们的目标。
设计模式 模板方法模式：抽象算法流程在抽象类中，封装流程中的变化与不变点。将变化点延迟到子类实现，达到代码复用，开闭原则。
观察者模式：针对事件不同组件有不同响应机制的需求场景，达到解耦灵活通知下游。
责任链模式：将对象连接成一条链，将沿着这条链传递请求。在 Tomcat 中的 Valve 就是该设计模式的运用。
更多设计模式可查看「码哥字节」之前的设计模式专辑。
I/O 模型 Tomcat 实现高并发接收连接，必然涉及到 I/O 模型的运用，了解同步阻塞、异步阻塞、I/O 多路复用，异步非阻塞相关概念以及 Java NIO 包的运用很有必要。本文也会带大家着重说明 I/O 是如何在 Tomcat 运用实现高并发连接。大家通过本文我相信对 I/O 模型也会有一个深刻认识。
Java 并发编程 实现高并发，除了整体每个组件的优雅设计、设计模式的合理、I/O 的运用，还需要线程模型，如何高效的并发编程技巧。在高并发过程中，不可避免的会出现多个线程对共享变量的访问，需要加锁实现，如何高效的降低锁冲突。因此作为程序员，要有意识的尽量避免锁的使用，比如可以使用原子类 CAS 或者并发集合来代替。如果万不得已需要用到锁，也要尽量缩小锁的范围和锁的强度。
对于并发相关的基础知识，如果读者感兴趣「码哥字节」后面也给大家安排上，目前也写了部分并发专辑，大家可移步到历史文章或者专辑翻阅，主要讲解了并发实现的原理、什么是内存可见性，JMM 内存模模型、读写锁等并发知识点。
Tomcat 总体架构 再次回顾下 Tomcat 整体架构设计，主要设计了 connector 连接器处理 TCP/IP 连接，container 容器作为 Servlet 容器，处理具体的业务请求。对外对内分别抽象两个组件实现拓展。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/499f1c8dea18015820f11c000a2560ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c913765024d888f05487dc6eb5500def/" rel="bookmark">
			org.codehaus.plexus.archiver.jar.Manifest.write(java.io.PrintWriter)最新解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上很多链接都已经失效了，这个是我最新发现可以用的。
help -&gt; Install New Software -&gt; add
在add里面直接复制上下面的链接就可以
https://repo1.maven.org/maven2/.m2e/connectors/m2eclipse-mavenarchiver/0.17.2/N/LATEST/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ff7990c72480bef433dce60f961170/" rel="bookmark">
			HTML&#43;CSS&#43;JS 表白代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 案例一 爱你到天昏地暗案例二 带有音乐的表白代码案例三 带有图片旋转的表白案例源码 案例一 爱你到天昏地暗 &lt;html&gt; &lt;style type="text/css"&gt; &lt;!-- .STYLE1 {font-size: medium} --&gt; &lt;/style&gt; &lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;HEAD&gt; &lt;title&gt;恋爱表白神器&lt;/title&gt; &lt;h1 id="r1"&gt;在未来的日子里，也许什么都无法确定，但唯一可以确定的是，我爱的人是你&lt;/h1&gt; &lt;style type="text/css"&gt; /* Circle Text Styles */ #outerCircleText { /* Optional - DO NOT SET FONT-SIZE HERE, SET IT IN THE SCRIPT */ font-style: italic; font-weight: bold; font-family: 'comic sans ms', verdana, arial; color: #1400FF; &lt;/style&gt; &lt;script type="text/javascript"&gt; ;(function(){ // Your message here (QUOTED STRING) var msg = "某某某 我爱你 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ff7990c72480bef433dce60f961170/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b03eb375e5b6a6d3cb9809f62da44c7/" rel="bookmark">
			优先级队列PriorityQueue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在小顶堆或是大顶堆堆操作中经常会用到优先级队列PriorityQueue。网上有篇文章讲的不错，转载一波梭哈。
一、什么是优先级队列 1、概念 我们都知道队列，队列的核心思想就是先进先出，这个优先级队列有点不太一样。优先级队列中，数据按关键词有序排列，插入新数据的时候，会自动插入到合适的位置保证队列有序。（顺序有两种形式：升序或者是降序）
来一个标准点的定义：
PriorityQueue类在Java1.5中引入。PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。
比如我们往队列里面插入1 3 2，插入2的时候，就会在内部调整为1 2 3（默认顺序是升序）。正是由于这个优良特性可以帮助我们实现一系列问题。我们先看一个例子，体会一下他的优点，然后再看一下为什么能够实现这样的功能。
我们看到就算是我们随意插入数据，但是输出的结果总是有序的，这样一来优先级队列就可以有了很多个使用场景。下面给出一道力扣题。体会一下他的优点。
2、案例演示特性 Leetcode215题：在未排序的数组中找到第 k个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
输入：3,2,3,1,2,4,5,5,6，k = 4。输出就是5，因此重复的并不考虑。我们一般情况下一般首先想到冒泡排序。每一次都冒出来一个最小的元素，这样冒K次，就是我们想要的结果。
其实冒泡排序还可以解决另外一个问题，那就是返回Z倒数第K大的元素，方法是每次冒出来一个最大的元素即可。
这样做很简单，但是需要我们自己手写冒泡排序，下面我们看使用优先级队列如何解决的。
就这几行代码就搞定了，是不是超级简单。为什么优先级队列能够实现呢？下面我们来分析一下他的数据结构：
3、数据结构 优先级队列底层的数据结构其实是一颗二叉堆，什么是二叉堆呢？我们来看看
在这里我们会发现以下特征：
（1）二叉堆是一个完全二叉树
（2）根节点总是大于左右子节点（大顶堆），或者是小于左右子节点（小顶堆）。
如果我们要插入一个节点怎么办呢？
自己使用画图工具画的，能看懂就行，不要在意那些细节兄弟。过程如下：
（1）找到待插入位置：满足完全二叉树的特点，依次插入
（2）插入之后判断是否满足二叉堆的性质，不满足那就调整
（3）1&lt;–&gt;6交换，发现不满足，1&lt;–&gt;4交换，满足即停止。
对于我们的优先级队列就是这样的一种数据结构，因此我们在插入的时候保证了数据的有序性。
OK。到这基本上我们能够体会到优先级队列的思想了。来一个小结：
优先级队列使用二叉堆的特点，可以使得插入的数据自动排序（升序或者是降序）。
现在我们知道了这些，还没讲源码。从源码的角度来体会一下：
二、源码分析（基于jdk1.8） 源码分析一般的顺序都是先类属性、构造方法、普通方法。在编译器中鼠标定位到这个PriorityQueue上，ctrl+鼠标左键就可以进入到这个集合的源码里面。
1、属性 2、构造方法 （1）默认构造方法：PriorityQueue()
使用默认的初始容量（11）创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。
（2）包含集合元素：PriorityQueue(Collection c)
创建包含指定 collection 中元素的 PriorityQueue。
（3）指定初始容量：PriorityQueue(int initialCapacity)
使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。
（4）指定初始容量和比较器：PriorityQueue(int initialCapacity, Comparator comparator)
使用指定的初始容量创建一个 PriorityQueue，并根据指定的比较器对元素进行排序。
（5）包含优先级元素：PriorityQueue(PriorityQueue c)
创建包含指定优先级队列元素的 PriorityQueue。
（6）包含set元素：PriorityQueue(SortedSet c)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b03eb375e5b6a6d3cb9809f62da44c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbd64e33d151105f44e0d3f798aa5871/" rel="bookmark">
			mybatis plus collection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先看下 mybatis 怎么做 collection
https://blog.csdn.net/weixin_41147129/article/details/107916742
最大的不同在于，mybatis plus 里面会根据数据库 自动生成 entity.xxxx
在 dao的mapper里面 extends了这个 基础的entity 就可以用mybatis plus的一些基础查询语句
比如 selectone之类的 简单增删改查
当你需要自定义一些数据类型，表里面没的 比如 collection的child
/** * 满足collection，增加list */ @TableField(exist = false) private List&lt;Channel&gt; children = new ArrayList&lt;Channel&gt;(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a43043d4879b60726e1413c8efb4e2/" rel="bookmark">
			Netty 客户端发送消息并同步获取结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 曾文冲
推荐理由 详尽并有图与代码对应的讲解，本月有分享。
UDP Client代码如下:
private NioEventLoopGroup nioEventLoopGroup; @Autowired private UdpHandler handler; @PostConstruct public void initClient() { nioEventLoopGroup = new NioEventLoopGroup(); Bootstrap bootstrap = new Bootstrap(); try { bootstrap.channel(NioDatagramChannel.class); bootstrap.group(nioEventLoopGroup); bootstrap.handler(new LoggingHandler(LogLevel.INFO)); bootstrap.handler(handler); // 监听端口 ChannelFuture sync = bootstrap.bind(0).sync(); sync.channel(); }catch (Exception e){ log.error("创建RFID UDP 客户端出现错我" ,e); nioEventLoopGroup.shutdownGracefully(); } } @PreDestroy public void close(){ if(!ObjectUtils.isEmpty(nioEventLoopGroup)) { nioEventLoopGroup.shutdownGracefully(); } } UdpHandler如下:
@Slf4j @Component public class UdpHandler extends SimpleChannelInboundHandler&lt;DatagramPacket&gt; { private ChannelHandlerContext ctx; private ChannelPromise promise; private NettyResponse response; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, DatagramPacket datagramPacket) throws Exception { ByteBuf content = datagramPacket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11a43043d4879b60726e1413c8efb4e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1735cb07e6fad14cc8ec809ef3b0e28e/" rel="bookmark">
			总结：那些热门的开源游戏服务器框架，还不看你就out了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##前言
作为一名业内资深的游戏开发人员，经常会遇到实习的新同事在工作中会问到这样的问题：
工作中到底有哪些开源游戏服务器框架，该去值得学习呢？
囊括到node.js 、java、C#、golang 、c++、python 等技术栈有各种各样的游戏框架。
本文给大家总结了一些github上star和fork比较常用的且有一定数量的较为完整的框架做了一个说明，大家可以往下看。
###skynet
云风大神的框架这个基本上使用很多的， c+lua的框架。 skynet只能算是网络层的轮子但是因为其众多的用户还是很不错的
地址：https://github.com/cloudwu/skynet
基于此引擎开发的游戏众多，很多棋牌小企业在用，例如简悦的陌陌争霸、食物战争等等很多产品…
###pomelo
网易开源的框架，支持分布式， 周边完善
一个用于Node.js的快速，可扩展的分布式游戏服务器框架
地址：https://github.com/NetEase/pomelo
一花科技等棋牌在用
###NoahGameFrame
几月c++支持c#/lua，是一个轻量级，快速，可扩展的分布式插件框架，基于Bigworld的思想，可用作MMO RPG / MOBA游戏旖旎情 、
地址：https://github.com/ketoo/NoahGameFrame
代表作全民无双
###kbengine
c++和python实现的MMOG游戏服务器框架，这个已经被电魂千万收购
地址：https://github.com/kbengine/kbengine
已经被电魂网络收购
###ET
Unity3d 客户端c#服务器框架，支持分布式客户端服务器共享代码
地址：https://github.com/egametang/ET
经过产品验证并且教程比较完善
###pitaya
基于golang,可伸缩的分布式游戏服务器框架
使用的技术比较先进 ETCD实现服务发现 NATS GRPC实现rpc可以docker部署， 国外公司TFG Co 开源项目
地址：https://github.com/topfreegames/pitaya
zooba appstroe排行很高的moba、吃鸡类游戏
总结：以上框架自己基本上都运行部署并且了解过大致的框架结构，经过项目内的了解，相信对上手这块难度也会比较简单，
如果看完了，别犹豫，试着自己去实操一下吧！！！
但是，像c++类的框架对新手要求较高。
亦或者node.js类框架性能确实差一些，毕竟它是针对io密集型。
阿博自己的话使用的是pitaya这套框架。毕竟支持分布式使用的技术比较新，也经过各种验证。其他的就先不做评价，留着给大家发表一下意见。
毕竟，只要适合自己的才是最好的。
是的不…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f131756d28b29a919a99286f76c7fa17/" rel="bookmark">
			IDEA中maven项目dependencies报错飘红问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若是从其他地方导入的新工程，右边 maven 管理工具中 dependencies 若出现红色波浪线。通常用以下方式尝试解决。
第一步
0.导入外部项目，先配置jdk。
1.（检查maven仓库配置是否正确）File --&gt; settings 输入maven，检查Maven directory，local repository的配置和settings.xml中配置的仓库地址。
2.（重新导包）打开编译器右边的maven管理工具，点击reimport all maven projects。
3.（改动pom文件）install报红的项目，从maven库下载需要的包，如果还不能解决，去maven项目所在的pom文件，把相应包去掉，然后撤回，一般就自动下包了（或者把pom.xml文件的dependencies标签全部选中剪切，粘贴回去,之后保存），如果没有好，reimport一下。
第二步
若还是出现红色波浪线，则有极大可能是maven引用的jar包有版本冲突，这时就需要exclude某个版本。
解决办法
打开pom.xml文件，右键选择 diagrams --&gt; show dependencies ,在这个关联图中可以看到所有包的所有依赖关系。
找到标有红线的包位置（通常可以结合 maven 管理工具中 dependencies 红线位置可以精准定位），点击该依赖包，可以看到与之有冲突的不同版本的包。这时exclude其中一个就好了。
注意： exclude其中一个的时候，注意查看 repository 中，是哪一个版本的包不存在，则exclude该版本。若是所依赖的版本都不存在，则需要单独添加该maven 包了。
第三步
若右边maven 管理工具中，点开出问题的包，会看到该包无法继续展开下一级，同时在左边项目的external libraries 中会找不到该出问题的包。
这种情况，查看repository相应版本包的依赖，可以看到该包只有.pom .sha1等文件，而没有jar包。这是一个错误的依赖包，而且通常靠第一种办法是无法解决的，并不能reimport解决。
解决办法
找一个网络好一点的地方，删掉repository中的该包所有相关文件，再在项目中reimport操作。
若是局域网的话，可以在外面下好后再拷贝进局域网repository中去。
第四步
如果还没有好，重启。
如果不行还是飘红，那么可能是你pom文件有问题，或者是maven本身有问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa79af3f7fff23a01582004cb96ef00/" rel="bookmark">
			flask SSTI漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一章 Flask ssti漏洞的代码（长什么样子）1.1 代码1.2 正常测试1.3 利用漏洞测试1.3.1 获取字典中的密钥1.3.2 获取整个person 字典中的内容1.3.3 获取服务器端敏感的配置参数 1.4 预防敏感信息泄露 第二章 前言（基础知识储备）2.1 flask基础2.2 程序分析2.3 注册路由2.4 装饰器2.5 本地运行程序2.6 Flask变量规则2.7 渲染方法 第三章 服务器端模板（SST）3.1 为什么需要服务器端模板（SST)(why)3.2 什么是服务器端模板（SST)（what) 第四章 服务器模板注入（SSTI）4.1 什么是服务器模板注入4.2 模板注入原理4.3 模板注入检测 第五章 例子（CTF)5.1 构造payload5.2这个题目是TWCTF的题目，源码如下 第五章 如何防御服务器模板注入参考资料附录 第一章 Flask ssti漏洞的代码（长什么样子） 1.1 代码 from flask import Flask from flask import request from flask import render_template_string from flask import render_template app = Flask(__name__) @app.route('/login') def hello_ssti(): person = { 'name': 'hello', 'secret': '7d793037a0760186574b0282f2f435e7' } if request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa79af3f7fff23a01582004cb96ef00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9f76c9f5fefde8f02b8e2632980e8a6/" rel="bookmark">
			数据中台架构实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据中台架构实践】：点击下载
一、数据中台定义 数据中台是一套可持续“让企业的数据用起来”的机制，一种战略选择和组织形式，是依据企业特有的业务模式和组织架构，通过有形的产品和实施方法论支撑，构建一套持续不断把数据变成资产并服务于业务的机制。
二、数据中台必须具备4个核心能力 数据中台需要具备数据汇聚整合、数据提纯加工、数据服务可视化、数据价值变现４个核心能力，让企业员工、客户、伙伴能够方便地应用数据
2.1、汇聚整合（数据治理-数据整合和管理能力）
数据丰富和完善：多样的数据源进行合并和完善管理易用：可视化任务配置、丰富的监控管理功能*数据集成运营：数据接入、转换、写入或缓存内部来源的各来源数据*数据目录与治理：用户可以方便定位所需数据，理解数据（技术/业务治理）*数据安全：确保数据的访问权限*数据可用：用户可简便、可扩展的访问异构数据，可用性和易用性高部署灵活：本地、公有云、私有云等多种署方式 2.2、提纯加工（数据资产化——数据提炼与分析加工能力）
完善的安全访问控制完善的数据质量保障体系规范的、紧密结合业务的可扩展的标签体系面向业务主题的资产平台智能的数据映射能力，简化数据资产生成 2.3、服务可视化（数据资产服务化能力）
提供自然语言等人工智能服务提供丰富的数据分析功能提供友好的数据可视化服务便捷、快速的服务开发环境，方便业务人员开发数据应用提供实时流数据分析提供预测分析、机器学习等高级服务、 2.4、价值变现
提供数据应用的管理能力提供数据洞察直接驱动业务行动的通路提供跨行业务场景的能力提供跨部门的普适性业务价值能力提供基于场景的数据应用提供业务行动效果评估功能 数据中台优点
3.1业务价值（业务创新，形成核心壁垒）
1、以客户为中心，用洞察驱动企业稳健行动
2、以数据为基础，直系大规模商业模式创新
3、盘活全量数据，构筑坚实壁垒已持续领先
3.2技术价值（成本低、能力多、应用广）
1、应对多数据处理的需求
2、丰富标签数据，减低管理成本
3、数据价值能体现业务系统效果而不仅是准确度
4、支持跨主题域访问数据
5、数据可以快速复用、不仅是复制
总结：数据中台是把业务生产资料转变为数据生产力，同时数据生产力反哺业务，不断迭代循环的闭环过程——数据驱动决策、运营
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f843b10d586a66e6550a71532b2e57f/" rel="bookmark">
			13.5-“制作一款私有IAP串口下载小工具”之STM32的Bootloader代码编写（包含源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开发环境与工具 STM32CubeMX、TrueSTUDIO、J-Flash V6.32f
芯片：STM32L072KBUx
二、使用CubeMx新建工程与配置说明 使用CubeMX通过芯片型号新建工程。需要配置如下内容：
配置系统时钟下载程序的SWD口一个定时器（开启中断）一个串口（开启接收中断） 配置过程及详细参数如以下截图所示：
注意：只要能实现同样功能即可，不强制必须使用串口1或定时器7。
三、通信协议构架代码 在单片中需要接收来自上位机的数据，并安装协议规定格式反馈数据。比上位机端简单一些。
把串口接收到的每1byte数据，依次传递给以下这个“协议识别函数”来进行“封包”识别：
void APP_UartProcess(uint8_t uart_data) { if(IsStartRecvCommand == true) { UartRxCache[UartRxCacheIndex++] = uart_data; uint16_t TempCacheLen = UartRxCacheIndex; if(TempCacheLen &gt; 4 &amp;&amp; UartRxCache[TempCacheLen - 4] == TAIL[0] &amp;&amp; UartRxCache[TempCacheLen - 3] == TAIL[1] &amp;&amp; UartRxCache[TempCacheLen - 2] == TAIL[2] &amp;&amp; UartRxCache[TempCacheLen - 1] == TAIL[3] &amp;&amp; UartRxCache[sizeof (HEAD)] + sizeof (HEAD) + sizeof (TAIL) == TempCacheLen //check pkg len ) { //检测到一包接收完成 ProcessAFinishedPackage(); UartRxCacheIndex = 0; IsStartRecvCommand = false; } } else if(uart_data == HEAD[0] &amp;&amp; IsStartRecvCommand == false) { //only receiving command when start with a head IsStartRecvCommand = true; UartRxCache[UartRxCacheIndex++] = uart_data; } } 当单片机需要给上位机反馈命令的时候，使用以下函数计算出“反馈封包”：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f843b10d586a66e6550a71532b2e57f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7d54dce4cc330aae97d265b8a8fd6e/" rel="bookmark">
			完全二叉树、平衡二叉树、二叉查找树（二叉排序树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完全二叉树 完全二叉树是一种特殊的二叉树，满足以下要求：
所有叶子节点都出现在 k 或者 k-1 层，而且从 1 到 k-1 层必须达到最大节点数；第 k 层可以不是满的，但是第 k 层的所有节点必须集中在最左边。需要注意的是不要把完全二叉树和“满二叉树”搞混了，完全二叉树不要求所有树都有左右子树，但它要求： 任何一个节点不能只有左子树没有右子树叶子节点出现在最后一层或者倒数第二层，不能再往上 用一张图对比下“完全二叉树”和“满二叉树”：
当我们用数组实现一个完全二叉树时，叶子节点可以按从上到下、从左到右的顺序依次添加到数组中，然后知道一个节点的位置，就可以轻松地算出它的父节点、孩子节点的位置。
以上面图中完全二叉树为例，标号为 2 的节点，它在数组中的位置也是 2，它的父节点就是 (k/2 = 1)，它的孩子节点分别是 (2k=4) 和 (2k+1=5)，别的节点也是类似。
完全二叉树使用场景 根据前面的学习，我们了解到完全二叉树的特点是：“叶子节点的位置比较规律”。因此在对数据进行排序或者查找时可以用到它，比如堆排序就使用了它，后面学到了再详细介绍。
二叉查找树（二叉排序树） 二叉树的提出其实主要就是为了提高查找效率，比如我们常用的 HashMap 在处理哈希冲突严重时，拉链过长导致查找效率降低，就引入了红黑树。
我们知道，二分查找可以缩短查找的时间，但是它要求 查找的数据必须是有序的。每次查找、操作时都要维护一个有序的数据集，于是有了二叉查找树这个概念。
二叉查找树（又叫二叉排序树），它是具有下列性质的二叉树：
若左子树不空，则左子树上所有结点的值均小于它的根结点的值；若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；左、右子树也分别为二叉排序树。 如下图所示：
也就是说，二叉查找树中，左子树都比节点小，右子树都比节点大，递归定义。
根据二叉排序树这个特点我们可以知道：二叉排序树的中序遍历一定是从小到大的。
比如上图，中序遍历结果是：
1 3 4 6 7 8 10 13 14 二叉排序树的性能 在最好的情况下，二叉排序树的查找效率比较高，是 O(logn)，其访问性能近似于折半查找；
但最差时候会是 O(n)，比如插入的元素是有序的，生成的二叉排序树就是一个链表，这种情况下，需要遍历全部元素才行（见下图 b）。
如果我们可以保证二叉排序树不出现上面提到的极端情况（插入的元素是有序的，导致变成一个链表），就可以保证很高的效率了。
但这在插入有序的元素时不太好控制，按二叉排序树的定义，我们无法判断当前的树是否需要调整。
因此就要用到平衡二叉树（AVL 树）了。
平衡二叉树 平衡二叉树的提出就是为了保证树不至于太倾斜，尽量保证两边平衡。因此它的定义如下：
平衡二叉树要么是一棵空树要么保证左右子树的高度之差不大于 1子树也必须是一颗平衡二叉树 也就是说，树的两个左子树的高度差别不会太大。
那我们接着看前面的极端情况的二叉排序树，现在用它来构造一棵平衡二叉树。
以 12 为根节点，当添加 24 为它的右子树后，根节点的左右子树高度差为 1，这时还算平衡，这时再添加一个元素 28：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b7d54dce4cc330aae97d265b8a8fd6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/626cee5928e19d7948f075f2968176ce/" rel="bookmark">
			【计算机网络】孤儿进程和僵尸进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于孤儿进程和僵尸进程的定义与解释来自大佬：https://www.cnblogs.com/Anker/p/3271773.html
1、什么是孤儿进程和僵尸进程 我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。
孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
2、僵尸进程有什么危害 unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。
孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。
任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。
例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。
3、如何解决僵尸进程 主要有三种方法销毁僵尸进程
(1)调用wait函数 父进程调用此函数时如果子进程已经退出，则将子进程的返回值存入statloc指向的内存单元中(exit(?)的返回值或者return返回值)，如果调用此函数时子进程还未结束，则父进程堵塞在这个函数中直至子进程退出。但statloc指向的内存中不只返回值还有其他信息，一般我们通过宏将其分离。
WIFEXITED(statloc)：子进程正常终止时返回true；
WEXITSTATUS:返回子进程的返回值；
(2)调用waitpid函数 pid：待终止的子进程的pid，若-1，则为任意子进程；
statloc：子进程返回值将存储到此参数保存的内存空间；
options：一般为常量WNOHANG，若调用此函数时没有已终止的子进程，则waitpid函数不会堵塞，而是直接返回0；
所以调用waitpid函数时，需不停的用while循环判断是否有终止的子进程。
(3)信号处理 信号处理就是将一个信号与某个函数进行绑定，当这个信号出现时操作系统自动执行被绑定的函数。当然也可以不绑定自己写的函数，而在func处填入函数默认值，如：
典型的signo信号有：
SIGALARM：alarm函数倒计时结束时的信号；关于alarm()函数的解释：https://blog.csdn.net/csdn_kou/article/details/81093324
SIGINT：交互式注意信号，输入CTRL+C；
SIGCHLD：子进程终止；
注意：信号发生时将唤醒由于调用sleep()函数而进入阻塞状态的进程，并且一旦被唤醒就不会再进入睡眠状态。
#include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;unistd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/626cee5928e19d7948f075f2968176ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c57ee759ec42b938aff4e6dda1cbbcbf/" rel="bookmark">
			module ‘cv2‘ has no attribute ‘VideoCapture‘，统计视频的FPS输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		module 'cv2' has no attribute 'VideoCapture' 在运行OpenCV的代码包中视频的统计FPS的程序时，报错以上错误，原因是因为把.py的代码文件也命名成了“cv2”，这样相当于对导入代码文件本身，当然不会有videocapture模块。
再将代码文件进行更改后，有报错了以下信息：
报错原因是因为文件路径的格式表达不对，需要用"//"进行分开，
修改前：
修改后：
输出的视频FPS
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/164/">«</a>
	<span class="pagination__item pagination__item--current">165/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/166/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>