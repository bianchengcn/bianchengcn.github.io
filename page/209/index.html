<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6e4c4fd8e55fde82b9d4212759af39/" rel="bookmark">
			常见的web漏洞及其防范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SQL注入漏洞 SQL注入攻击（SQL Injection），简称注入攻击、SQL注入，被广泛用于非法获取网站控制权，是发生在应用程序的数据库层上的安全漏洞。在设计程序，忽略了对输入字符串中夹带的SQL指令的检查，被数据库误认为是正常的SQL指令而运行，从而使数据库受到攻击，可能导致数据被窃取、更改、删除，以及进一步导致网站被嵌入恶意代码、被植入后门程序等危害。 通常情况下，SQL注入的位置包括： （1）表单提交，主要是POST请求，也包括GET请求； （2）URL参数提交，主要为GET请求参数； （3）Cookie参数提交； （4）HTTP请求头部的一些可修改的值，比如Referer、User_Agent等； （5）一些边缘的输入点，比如.mp3文件的一些文件信息等。 常见的防范方法 （1）所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。 （2）对进入数据库的特殊字符（’”&lt;&gt;&amp;*;等）进行转义处理，或编码转换。 （3）确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。 （4）数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。 （5）网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。 （6）严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。 （7）避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。 （8）在网站发布之前建议使用一些专业的SQL注入检测工具进行检测，及时修补这些SQL注入漏洞。
二、跨站脚本漏洞 跨站脚本攻击（Cross-site scripting，通常简称为XSS）发生在客户端，可被用于进行窃取隐私、钓鱼欺骗、窃取密码、传播恶意代码等攻击。 XSS攻击使用到的技术主要为HTML和Javascript，也包括VBScript和ActionScript等。XSS攻击对WEB服务器虽无直接危害，但是它借助网站进行传播，使网站的使用用户受到攻击，导致网站用户帐号被窃取，从而对网站也产生了较严重的危害。 XSS类型包括： （1）非持久型跨站：即反射型跨站脚本漏洞，是目前最普遍的跨站类型。跨站代码一般存在于链接中，请求这样的链接时，跨站代码经过服务端反射回来，这类跨站的代码不存储到服务端（比如数据库中）。上面章节所举的例子就是这类情况。 （2）持久型跨站：这是危害最直接的跨站类型，跨站代码存储于服务端（比如数据库中）。常见情况是某用户在论坛发贴，如果论坛没有过滤用户输入的Javascript代码数据，就会导致其他浏览此贴的用户的浏览器会执行发贴人所嵌入的Javascript代码。 （3）DOM跨站（DOM XSS）：是一种发生在客户端DOM（Document Object Model文档对象模型）中的跨站漏洞，很大原因是因为客户端脚本处理逻辑导致的安全问题。 常用的防止XSS技术包括： （1）与SQL注入防护的建议一样，假定所有输入都是可疑的，必须对所有输入中的script、iframe等字样进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。 （2）不仅要验证数据的类型，还要验证其格式、长度、范围和内容。 （3）不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。 （4）对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行安全检查。 （5）在发布应用程序之前测试所有已知的威胁。
三、弱口令漏洞 弱口令(weak password) 没有严格和准确的定义，通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。设置密码通常遵循以下原则： （1）不使用空口令或系统缺省的口令，这些口令众所周之，为典型的弱口令。 （2）口令长度不小于8个字符。 （3）口令不应该为连续的某个字符（例如：AAAAAAAA）或重复某些字符的组合（例如：tzf.tzf.）。 （4）口令应该为以下四类字符的组合，大写字母(A-Z)、小写字母(a-z)、数字(0-9)和特殊字符。每类字符至少包含一个。如果某类字符只包含一个，那么该字符不应为首字符或尾字符。 （5）口令中不应包含本人、父母、子女和配偶的姓名和出生日期、纪念日期、登录名、E-mail地址等等与本人有关的信息，以及字典中的单词。 （6）口令不应该为用数字或符号代替某些字母的单词。 （7）口令应该易记且可以快速输入，防止他人从你身后很容易看到你的输入。 （8）至少90天内更换一次口令，防止未被发现的入侵者继续使用该口令。
四、HTTP报头追踪漏洞 HTTP/1.1（RFC2616）规范定义了HTTP TRACE方法，主要是用于客户端通过向Web服务器提交TRACE请求来进行测试或获得诊断信息。当Web服务器启用TRACE时，提交的请求头会在服务器响应的内容（Body）中完整的返回，其中HTTP头很可能包括Session Token、Cookies或其它认证信息。攻击者可以利用此漏洞来欺骗合法用户并得到他们的私人信息。该漏洞往往与其它方式配合来进行有效攻击，由于HTTP TRACE请求可以通过客户浏览器脚本发起（如XMLHttpRequest），并可以通过DOM接口来访问，因此很容易被攻击者利用。 防御HTTP报头追踪漏洞的方法通常禁用HTTP TRACE方法。
五、Struts2远程命令执行漏洞 ApacheStruts是一款建立Java web应用程序的开放源代码架构。Apache Struts存在一个输入过滤错误，如果遇到转换错误可被利用注入和执行任意Java代码。 网站存在远程代码执行漏洞的大部分原因是由于网站采用了Apache Struts Xwork作为网站应用框架，由于该软件存在远程代码执高危漏洞，导致网站面临安全风险。CNVD处置过诸多此类漏洞，例如：“GPS车载卫星定位系统”网站存在远程命令执行漏洞(CNVD-2012-13934)；Aspcms留言本远程代码执行漏洞（CNVD-2012-11590）等。 修复此类漏洞，只需到Apache官网升级Apache Struts到最新版本：http://struts.apache.org
六、文件上传漏洞 文件上传漏洞通常由于网页代码中的文件上传路径变量过滤不严造成的，如果文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，攻击者可通过 Web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器。 因此，在开发网站及应用程序过程中，需严格限制和校验上传的文件，禁止上传恶意代码的文件。同时限制相关目录的执行权限，防范webshell攻击。
七、私有IP地址泄露漏洞 IP地址是网络用户的重要标示，是攻击者进行攻击前需要了解的。获取的方法较多，攻击者也会因不同的网络情况采取不同的方法，如：在局域网内使用Ping指令，Ping对方在网络中的名称而获得IP；在Internet上使用IP版的QQ直接显示。最有效的办法是截获并分析对方的网络数据包。攻击者可以找到并直接通过软件解析截获后的数据包的IP包头信息，再根据这些信息了解具体的IP。 针对最有效的“数据包分析方法”而言，就可以安装能够自动去掉发送数据包包头IP信息的一些软件。不过使用这些软件有些缺点，譬如：耗费资源严重，降低计算机性能；访问一些论坛或者网站时会受影响；不适合网吧用户使用等等。现在的个人用户采用最普及隐藏IP的方法应该是使用代理，由于使用代理服务器后，“转址服务”会对发送出去的数据包有所修改，致使“数据包分析”的方法失效。一些容易泄漏用户IP的网络软件(QQ、MSN、IE等)都支持使用代理方式连接Internet，特别是QQ使用“ezProxy”等代理软件连接后，IP版的QQ都无法显示该IP地址。虽然代理可以有效地隐藏用户IP，但攻击者亦可以绕过代理，查找到对方的真实IP地址，用户在何种情况下使用何种方法隐藏IP，也要因情况而论。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff6e4c4fd8e55fde82b9d4212759af39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb4eb90342d8c69c4528fc272a65dce/" rel="bookmark">
			2.3从尾到头输出单链表每个结点的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个可以用栈来实现，遍历单链表，将数值存到栈上，遍历完之后，再输出栈中的数据
能用栈解决，就可以联想到使用递归来解决了，每当访问一个结点，先递归输出他后面的结点，然后再输出本身，这样链表就反向输出了。
//从尾到头输出结点说的值 #include &lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; using namespace std; typedef struct LNode { int data; struct LNode *next; } LNode,*LinkList; void R_Print(LinkList L) { if(L-&gt;next!=NULL) { R_Print(L-&gt;next) ; } printf("%d",L-&gt;data); } int main() { return 0; } 转载于:https://www.cnblogs.com/zhuoyuezai/p/5736514.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446a22101bb2cd4bf35be551af595d68/" rel="bookmark">
			中标麒麟操作系统设置或修改root密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天安装了中标麒麟桌面版，需要用root身份执行一些命令，但安装时并未设置root密码，仅仅创建了一个普通账户，通过下面的命令可以直接将root密码修改成自己需要的样子。
sudo passwd root 执行该命令后会首先提示输入当前普通用户的密码，之后再输入自己想要的设置的root密码就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991861d0f78060ed4ddfc0528e7f44f0/" rel="bookmark">
			if (i%4 ==0 ) 逻辑的魅力 在于 这里
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div class="course_height"&gt; &lt;/div&gt; &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; var i=0; var s1 = "&lt;ul class='intelliGence'&gt;"; var s3 = "&lt;/ul&gt;"; var shtml = ""; for(i=0;i&lt;20;i++){ var s2='&lt;li&gt;'+i+'&lt;/li&gt;'; if(i%4 == 0){ shtml += s1; } shtml += s2; if((i+1)%4 == 0){ shtml += s3; } } shtml += s3; var recbody = $(".course_height"); recbody.text(""); recbody.append(shtml); &lt;/script&gt; 转载于:https://www.cnblogs.com/alone2015/p/5709878.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80435997429e7c686527079b0f01847d/" rel="bookmark">
			EasyTouch实现图片移动旋转拉大放小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上面只能对图片进行双手指拉大放小功能以及双手指扭动进行旋转，要想对图片进行单手指移动，还需要做下面操作
到此为止，我们利用easytouch提供的脚本，没有写一行代码就轻松实现图片的双手指拉大放小及扭动旋转功能和单手指拖动移动图片效果，是不是很简单吧！
下面看看EasyTouch给我们提供的一个很重要的脚本Photo,这个脚本也是很有意思：
同时还可以看出，手势插件都是对外提供一些手势事件的接口，我们程序员要做的就是为这些事件绑定方法
FR:海涛高软 （QQ群：386476712）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa9a56652c6b98e24b40636e99f151c/" rel="bookmark">
			二叉树中完全二叉树、满二叉树、二叉排序树、平衡二叉树的区别和联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，完全二叉树：
只有最下面的两层结点度小于2，并且最下面一层的结点都集中在该层最左边的若干位置。
2，满二叉树：
是一颗完全二叉树；
除了叶结点外每一个结点都有左右子叶且叶结点都处在最底层。深度为k，且有2的(k)次方－1个节点。
3，堆： 是一颗完全二叉树；
大根堆：左右子树的结点值都小于根结点值，左右子树都是大根堆。
小根堆：左右子树的结点值都大于根结点值，左右子树都是小根堆。
4，二叉排序树（二叉查找树）：
左子树上的值都小于根结点的值，右子树上的值都大于根结点得值，左右子树都是二叉排序树。
5，平衡二叉树（ALV）：
是一颗二叉排序树；
左子树和右子树的差值不超过1，左右子树都为平衡二叉树。
常用算法有红黑树、AVL、Treap
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a5670f2adcb1aa4c94c9c1424ed1f87/" rel="bookmark">
			页式存储（已知系统为32位实地址，采用48位虚拟地址，页面大小4KB，页表项大小为8B；每段最大为4GB。）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		页式存储（清华大学）
已知系统为32位实地址，采用48位虚拟地址，页面大小4KB，页表项大小为8B；每段最大为4GB。
（1）假设系统使用纯页式存储，则要采用多少级页表，页内偏移多少位？
（2）假设系统采用一级页表，TLB命中率为98%，TLB访问时间为10ns，内存访问时间为100ns，并假设当TLB访问失败后才访问内存，问平均页面访问时间是多少？
（3）如果是二级页表，页面平均访问时间是多少？
（4）上题中，如果要满足访问时间&lt;=120ns，那么命中率需要至少多少？
（5）若系统采用段页式存储，则每用户最多可以有多少段？段内采用几级页表？ 参考答案：
（1）首先，页面大小为4KB，故页内偏移需要12位来表示。其次，系统虚拟地址一共48位，所以剩下的48-12=36位可以用来表示虚页号。每一个页面可以容纳的页表项为：4KB/8B=29（也就是可以最多表示到9位长的页号），而虚页号的长度为36位，所以需要的页表级数为：36/9=4级。
（2）当进行页面访问时，首先应该先读取页面对应的页表项，98%的情况可以在TLB中直接得到得到页表项，直接将逻辑地址转化为物理地址，访问内存中的页面。如果TLB未命中，则要通过一次内存访问来读取页表项，所以页面平均访问时间是：
98%×（10+100）ns+2%×（10+100+100）ns=112ns
（3）二级页表的情况下：
如果TLB命中，和（2）的情况一样，如果TLB没有命中，采用二级页表需要访问3次内存，所以页面平均访问时间是：
98%×（10+100）ns+2%×（10+100+100+100）ns=114ns
（4）假设快表的命中率为p，应该满足以下式子：
p×（10+100）ns+（1-p）×（10+100+100+100）ns&lt;=120ns
可以解得：p&gt;=95%，所以如果要满足访问时间&lt;=120ns，那么命中率至少为95%。总结知识点：在多级页表的情况下，如果TLB没有命中，则需要从虚拟地址的高位起，每N位（其中N就是类似于（1）中的9）逐级访问各级页表，以第（1）问为例，如果快表未命中，则需要访问5次内存才能得到所需页面。
转载于:https://www.cnblogs.com/zhuhengjie/p/5966887.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d7b073592022490ae7c12e0dd697304/" rel="bookmark">
			基于用户的协同过滤算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了Mahout的基于用户的协同过滤算法的实现
推荐主要包含以下步骤：
1、根据用户对于物品的已有偏好值，计算各个用户之间的相似度（如，皮尔逊相关系数）
2、获取当前用户的最相似的N个用户
3、获取当前用户没有给出偏好的，N个用户已给出偏好的物品集合
4、通过(SUM(当前用户偏好值x与当前用户相似度)/总相似度)计算物品对于N个用户的平均偏好
5、获取TopN个物品作为用户的推荐结果返回
评分的主要步骤：
1、根据用户对于物品的已有偏好值，计算各个用户之间的相似度（如，皮尔逊相关系数）
2、获取当前用户的最相似的N个用户
3、将数据集分为训练集和验证集
4、使用训练集，通过(SUM(当前用户偏好值x与当前用户相似度)/总相似度)计算物品对于N个用户的平均偏好，即预测值
5、与验证集进行比较，计算验证集与预测值偏好的差值的平均值
计算准确率、召回率、散落率
1、根据当前用户的物品的偏好，确定阈值（偏好均值+偏好标准差）
2、获取当前用户大于阈值的好的物品个数
3、根据其他用户的物品和当前用户的非好物品，计算at个推荐物品（见上推荐的步骤）
4、求2中个数和3中个数的交集，计算准确率、召回率、散落率
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e59a4b749d7d2ae0d4c35de5d9ec421/" rel="bookmark">
			解决QCombobox使用调用clear()崩溃的问题（currentIndexChanged信号问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用QCombobox调用clear()来清除下拉框选项时，会出现程序崩溃的现象，而经过调试发现，问题出在
connect (ui-&gt;comboBox,SIGNAL(currentIndexChanged(int)),this,SLOT(slotNameCom(int)))中的槽函数，槽函数slotNameCom如下所示：
void C_Del_user::slotNameCom(int index) { Name_select = vecindex[index].name; } 调试时发现，当程序执行ui-&gt;comboBox-&gt;clear ()时，会触发currentIndexChanged(int)信号，槽函数slotNameCom()就会执行，且执行时槽函数中参数index为-1，显而易见，vecindex[-1]会导出程序崩溃（越界）。此时在槽函数中加入限制条件即可：
void C_Del_user::slotNameCom(int index) { if(index &gt;= 0 &amp;&amp; index &lt; vecindex.size()) { Name_select = vecindex[index].name; } } 也可以使用其他方法，在调用clear()前，先执行disconnect,此时就不会触发信号，在clear()之后再connect。
如下：
disconnect(ui-&gt;comboBox,SIGNAL(currentIndexChanged(int)),this,SLOT(slotNameCom(int))); ui-&gt;comboBox-&gt;clear(); connect(ui-&gt;comboBox,SIGNAL(currentIndexChanged(int)),this,SLOT(slotNameCom(int))) 最近发现了屏蔽函数，也可以适用：
ui-&gt;comboBox-&gt;blockSignals(true);//true屏蔽信号 ui-&gt;comboBox-&gt;clear(); ui-&gt;comboBox-&gt;blockSignals(false); 结尾 只为记录，只为分享! 愿所写能对你有所帮助。不忘记点个赞，谢谢~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291964dd2f765dba517601a18c3040c7/" rel="bookmark">
			touch 规定范围放大缩小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using UnityEngine;
using System.Collections;
public class TouchMoveTest : MonoBehaviour {
private Touch oldTouch1; //上次触摸点1(手指1)
private Touch oldTouch2; //上次触摸点2(手指2)
private float offset;
private float scaleFactor;
private Vector3 localScale;
private Vector3 scale;
void Start()
{
}
void Update()
{
//没有触摸
if (Input.touchCount &lt;= 0)
{
return;
}
//单点触摸， 水平上下旋转
if (Input.touchCount==1)
{
Touch touch = Input.GetTouch(0);
Vector2 deltaPos = touch.deltaPosition;
transform.Rotate(Vector3.down * deltaPos.x, Space.World);
transform.Rotate(Vector3.right * deltaPos.y, Space.World);
}
//多点触摸, 放大缩小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/291964dd2f765dba517601a18c3040c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b9f89b8091f7321c206648710591717/" rel="bookmark">
			数据传输效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据的传输效率是指发送的应用层数据除以所发送的总数据（即应用层数据加上各种首部和尾部的额外开销），[1] 是对方发送数据流量的控制，使其发送效率不致超过接受方所能承受的能力。它并不是数据链路层特有的功能，许多高层协议也提供流量控制功能。
例子： 长度为100字节的应用层数据交给运输层传送，需加上20字节的TCP首部，再交给网络层，需加上20字节的IP首部，最后交给数据链路层的以太网传送，需加上首部和尾部共18字节。试求数据的传输效率。数据的传输效率是指发送的应用层数据除以所发送的总数据（即应用数据加上各种首部和尾部的额外开销）。若应用层数据长度为1000字节，这数据的传输效率是多少？
答： 100/（100+20+20+18）=100/158=63.3% 1000/（1000+20+20+18）=1000/1058=94.5%
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7528844c1272f959d59773511c87fe8/" rel="bookmark">
			【Mysql】求两个表（查询结果）的差集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求两个查询结果的差集，Mysql直接提供了关键字not in，但是not in的效率极其低下，出现例如求一个上千查询结果在上万查询结果的差集，那么使用not in来查询的查询速度极其缓慢，这是必须使用左链接的方式求查询。
先从简单的说起，比如在表blog的id情况是这样的：
在表usertable的id情况是这样的：
现在要求这两个结果的差集，可以使用如下的语句：
select id from usertable where id not in (select id from blog) 但是，not in的查询效率是极度低下的，主要是去到上万，仅仅是上万级的数据查询就会出现在查询的时候死机，无法查询的情况，因此还不得不得换做左链接查询的方式，具体如下： select id FROM usertable LEFT JOIN (select id as i from blog) as t1 ON usertable.id=t1.i where t1.i IS NULL 这里blog的id，也就是t1中的id，还必须换成i，或者其它变量名，不然连接的时候会出现混乱，出现如下的报错：
这种左链接的查询方式得出来结果与not in一样，但是查询时间与效率，却是复杂的左链接远远快于not in：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d9da7cc3db1ab77ab74ca7baac172e/" rel="bookmark">
			LaTeX多行注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LaTeX中单行注释用%
方法1：
每行添加一个%，工作量大，取消注释也得一个个删掉%，效率低
方法2：
多行注释可以用iffalse和fi包含，如下：
iffalse
多
行
注
释
内
容
fi
方法3：
在WinEdt中，选中要注释掉的多行内容，【右键】-【Insert Comment】，WinEdt会自动为每行添加%，即可注释多行内容。
取消多行注释时，选中要取消注释掉的多行内容，【右键】-【Remove Comment】，WinEdt会自动为每行去掉%，即可取消注释。
方法4：
在导言区使用包：
\usepackage{verbatim}
注释：
\begin{comment}
多
行
注
释
内
容
\end{comment} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc44e758e3c4a8ac34dccdc19bad7109/" rel="bookmark">
			windows 自启动脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一： （一）
例如我们要开机自启动一个脚本：C:\abc\script.bat。 如果直接开机启动该脚本会弹出一个黑框，我们希望能后台执行它。 此时我们需要建一个.vbs脚本来后台执行该脚本，脚本内容为： 复制代码代码如下: set ws=WScript.CreateObject("WScript.Shell") ws.Run "C:\abc\script.bat /start",0 然后将该文件保存为script.vbs，放入“开始 --&gt; 所有程序 --&gt; 启动”内即可。
（二）
打开运行对话框（win键+R），输入命令
shell:startup
会直接弹出启动项对应的目录，然后像前面方法一样把应用程序快捷方式复制到启动目录
第二： 直接写一个普通批处理文件，如果是需要让它在系统启动时运行， 就将它放在C:\Windows\System32\GroupPolicy\Machine\Scripts\Startup目录下，
如果是需要它在系统注销或关机时运行，就将它放在C:\Windows\System32\Grouppolicy\Machine\Scripts\Shutdown目录下。
放好之后就要进行指派。
单击“开始→运行”，在运行命令框中输入“gpedit.msc”，回车执行，打开“组策略”窗口。 然后在组策略左侧的控制面板树窗格中，如图所示，依次展开“计算机配置→Windows设置→脚本（启动/关机）”节点， 双击右侧详细资料窗格中的“启动”（或者“关机”）项目，在弹出的“启动属性”（“关机属性”）对话框中单击“添加”按钮， 将你所写的批处理文件添加为新的计算机启动（关机）脚本。设置完成后，退出组策略窗口。以后启动（关闭）电脑时，相应命令会自动执行 开关机脚本除了支持.bat格式的批处理脚本文件以外，还支持.wsf、.vbs、.js格式的脚本文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fef7ed11db411cc94ac5148b2e79c3e8/" rel="bookmark">
			Java做界面思路整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说起大一就学过C++，但从未接触过VC++，至于做界面也是直到学java才开始，所以自己还是个新手啊。。。
步入正题，通过自己写的两个小程序，对做界面的思路进行一下整理。
首先，构想出自己想要实现的界面是什么样子。可以在纸上画出个轮廓（我是这么干的。。。），尽量详尽，比如点击按钮后的实现一个页面的跳转，跳转之后的页面也画出来。为什么要这样呢？都知道界面是由控件和容器组成的，画的目的就是清楚要用哪些组件，并且根据自己的界面，然后组织容器，再进而组织布局。对于布局可能会比较麻烦一点，这要根据你的窗口是固定不变的大小，还是大小可变的。如果窗口是固定大小，那就好弄点，因为不用考虑窗口大小的改变对组件位置的影响。如果是窗口大小可变的话，就尽量避免使用null布局，null布局我称其为绝对布局（web css里面有绝对布局，当然跟那个不大一样，反正就这么叫了。。。），null布局位置不会改变，采用null布局内的控件大小不会改变，所以窗口可变的话，就很难看了。。。不过根据实际情况，有些地方也是可以用的。布局有很多种，一般都是嵌套使用。每种布局都有自己的优缺点，网格布局可将面板分成n*m的小方格，每个格子中的控件大小一样，并且随着窗口的改变，控件大小跟着变，但相对位置保持不变；流式布局，根据对齐方式不同，可将组件挨个排序，该行排满换行，窗口大小改变后，控件位置就像流水一样顺着动。其他方式还没去具体实践，就不说了。
然后，构想完界面，声明完控件，然后就开始编界面吧。对于界面，首先是一个Frame框架，对于Frame，可以设置它的标题setTitle();（标题也可以创建的时候在构造函数中确定标题。），然后是窗口大小，这个可能对新手而言很头疼，到底要设置多大呢？其实也很简单，在java核心卷一中讲到一个函数，可以得到该pc窗口的实际大小，根据这个值来调整就行。（代码附下面了。。）然后设置是否可见，关闭属性等。。到这里框架已经建好，下面开始添加容器。
//得到pc窗口大小 Toolkit kit = Toolkit.getDefaultToolkit(); Dimension screenSize = kit.getScreenSize(); int screenWidth = screenSize.width; int screenHeight = screenSize.height; frame = new JFrame("Java小课堂"); frame.setBounds(screenWidth / 3, screenHeight / 4, 450, 300); // 设置位置及大小 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.getContentPane().setBackground(Color.lightGray); frame.getContentPane().setLayout(null); // 使用绝对布局 frame.setResizable(false); // 设置窗口大小不可变 对于容器也没什么难理解的，如果把框架比作画板，那么容器就相当于画纸，纸是在板表面的，所以有层次之分，重点是你要时刻知道是哪张纸位于最上边。这里的纸就是 JPanel ，跟Frame差不多了，设置大小，设置布局，设置背景颜色，设置位置。其实创建任何一个组件也都是一个套路，位置，大小，内容，颜色等。如果前边做的比较好，那么对于布局，就是一个劲的添东西就行了。 下面附上两个程序的代码
import java.awt.Color; import java.awt.Frame; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.BufferedReader; import java.io.File; import java.io.FileReader; import java.io.IOException; import javax.swing.ButtonGroup; import javax.swing.JButton; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fef7ed11db411cc94ac5148b2e79c3e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42fedd181bf735f758b63c90b2d05497/" rel="bookmark">
			CKEditor全部配置参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载了完整的程序之后，先要对程序中的不必要的东西进行删除。凡是文件名或文件夹名前面有”_”的文件或文件夹都可以删除，这些文件是一些说明文件或者实例文件。另外，./lang文件夹中，只保留：zh_cn.js文件即可，这个文件夹是程序的语言包，因为其它语言大家用不到，放在那里也占用空间，所以索性删掉。./skins文件夹是编辑器的界面，根据情况保留至少一个文件夹即可，其中kama是可自定颜色UI的文件，建议保留，当然如果不在乎空间大小的话，也可以全部上传。 接下来，就是配置自己的编辑器啦～ 配置的方式有三种： 笔者喜欢使用config.js的方式来使用，下面以此为例，介绍其配置参数。（所示为默认值）
//当提交包含有此编辑器的表单时，是否自动更新元素内的数据 config.autoUpdateElement = true //编辑器的z-index值 config.baseFloatZIndex = 10000 //设置是使用绝对目录还是相对目录，为空为相对目录 config.baseHref = '' //设置快捷键 从上往下依次是：获取焦点，元素焦点，文本菜单，撤销，重做，重做，链接，粗体，斜体，下划线 config.keystrokes = [ [ CKEDITOR.ALT + 121 /*F10*/, 'toolbarFocus' ], [ CKEDITOR.ALT + 122 /*F11*/, 'elementsPathFocus' ], [ CKEDITOR.SHIFT + 121 /*F10*/, 'contextMenu' ], [ CKEDITOR.CTRL + 90 /*Z*/, 'undo' ], [ CKEDITOR.CTRL + 89 /*Y*/, 'redo' ], [ CKEDITOR.CTRL + CKEDITOR.SHIFT + 90 /*Z*/, 'redo' ], [ CKEDITOR.CTRL + 76 /*L*/, 'link' ], [ CKEDITOR.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42fedd181bf735f758b63c90b2d05497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e40949bf35365fee0997d715ead78c/" rel="bookmark">
			jQuery学习和知识点总结归纳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、jQuery简介 jQuery是一个实用的JavaScript库。jQuery极大地简化了JS对DOM的操作，实现一些常用的方法，jQuery还可以链式操作。
2、jQuery的基本用法
//引入jQuery文件，可以本地也可以远程 &lt;script type="text/javascript" src="jQuery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; //当文档完成加载完时触发，避免获取dom对象时，dom对象还没有加载 $(document).ready(function(){ //写js语句或者jQuery函数 $("p").click(function(){ $(this).hide(); }); }); &lt;/script&gt; 3、jQuery常用的选择器和事件，和CSS的选择器很相似。 $() – 使用CSS选择器匹配元素 jQuery的事件和JS的事件基本相同，在使用的时候，去掉JS事件前面的on即可。 jQuery常用的事件： load：当文档加载时运行脚本 blur：当窗口失去焦点时运行脚本 focus：当窗口获得焦点时运行脚本 change：当元素改变时运行脚本 submit：当提交表单时运行脚本 keydown：当按下按键时运行脚本 keypress：当按下并松开按键时运行脚本 keyup：当松开按键时运行脚本 click：当单击鼠标时运行脚本 dblclick：当双击鼠标时运行脚本 mousedown：当按下鼠标按钮时运行脚本 mousemove：当鼠标指针移动时运行脚本 mouseout：当鼠标指针移出元素时运行脚本 mouseover：当鼠标指针移至元素之上时运行脚本 mouseup：当松开鼠标按钮时运行脚本 abort：当发生中止事件时运行脚本
4、jQuery常用的效果方法 $(selector).hide() – 隐藏被选的元素 $(selector).show() – 显示被选的元素 $(selector).toggle() – 对被选元素进行隐藏和显示的切换 $(selector).slideDown() – 通过调整高度来滑动显示被选元素 $(selector).slideToggle() – 对被选元素进行滑动隐藏和滑动显示的切换 $(selector).slideUp() – 通过调整高度来滑动隐藏被选元素 $(selector).fadeIn() – 逐渐改变被选元素的不透明度，从隐藏到可见 $(selector).fadeOut() – 逐渐改变被选元素的不透明度，从可见到隐藏 $(selector).fadeTo() – 把被选元素逐渐改变至给定的不透明度 $(selector).animate() – 对被选元素应用“自定义”的动画
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20e40949bf35365fee0997d715ead78c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f4071d999c95d06cfd226209584e405/" rel="bookmark">
			磁带库概念理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁带库概念 磁带库是更高级的自动化备份设备,它可以用于进行网络备份系统工作. 它增加了: (1).磁带槽位多, 容量最大; (2).带激光条码读写器的机械手臂;这样一来,通过条码读写器读磁带上的条码,根据备份管理软件就能知道该盘磁带的内容了; (3).磁带库需要专业备份软件来管理,进行网络备份,一般需要网络上有一台专门的备份管理服务器, (4).磁带驱动器(即磁带机,在这里叫驱动器)可以&gt;2个; 以上就是几种设备的区别. 简单的比喻： 你们家的衣柜有6个抽屉；100个小格，这些小格平时是放衣服什么的。现在你用手把衣服放到抽屉里去。 你的手，抽屉，小格以及构衣桂柜的东西就是磁带库，你的手是磁带库中的机械手，抽屉就是磁带库中磁带机，小格就是磁带库中的磁带架，衣服就是磁带。 能够安装多个磁带机的是磁带库；有一些只能安装一到二个磁带机的叫做自动加载机。
http://bbs.51cto.com/thread-829312-1.html
如何获取带库驱动器（Tape Drive）Element 首先需要配置好带库，然后在AIX上认到设备。（请先安装Atape驱动） １＞获取设备信息 # lsdev -Cc tape rmt0 Available 08-08-00-1,0 LVD SCSI 4mm Tape Drive rmt1 Available 0H-08-01 IBM 3590 Tape Drive and Medium Changer (FCP) rmt2 Available 0H-08-01 IBM 3590 Tape Drive and Medium Changer (FCP) rmt3 Available 0H-08-01 IBM 3590 Tape Drive and Medium Changer (FCP) rmt4 Available 0H-08-01 IBM 3580 Ultrium Tape Drive (FCP) rmt5 Available 0H-08-01 IBM 3580 Ultrium Tape Drive (FCP) smc0 Available 0H-08-01 IBM 3576 Library Medium Changer (FCP) # 其中smc0对应3576带库。rmt4 和rmt5分别对应带库中的两个驱动器 ２＞查询带库信息 # tapeutil -f /dev/smc0 inventory Drive Address 256 Drive State .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f4071d999c95d06cfd226209584e405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d5a337c23558b8406fb4efce38ae2d/" rel="bookmark">
			QtCreator：项目中文件按类别放入不同子文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们的工程比较庞大 有很多头文件和源文件时候 我们希望可以把他们按照类别放入不同的文件夹 以一个目录树的形式呈现给开发者 这样会比较清楚的找到我们要的文件夹
如下图所示：
为了实现这样的操作，我们有两种方式。
较为简单的一种：在你的工程所在的文件夹下新建你要作为分组项的文件夹 然后就对应的头文件和源文件移入到该项目中 。然后用QtCreator打开项目 选择如下：
这种方式形成的目录结构如下：
另外一种方式： 通过给工程文件pro添加pri文件实现 具体操作减参考文献【1】
注意： 两种方式都要注意 我们在添加头文件时 要写清楚目录地址 例如 include" GUI/filebrowser"
参考文献：
【1】Qt: Qt Creator中按目录结构显示工程文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a80364b6ab272c8209c7208a8e985c8/" rel="bookmark">
			nrf51822开发指导之静态密钥配对--在SDK9.0的ble_app_uart例程修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.定义配对过程使用到的参数
#define SEC_PARAM_BOND 0 #define SEC_PARAM_MITM 1 #define SEC_PARAM_IO_CAPABILITIES BLE_GAP_IO_CAPS_DISPLAY_ONLY #define SEC_PARAM_OOB 0 #define SEC_PARAM_MIN_KEY_SIZE 7 #define SEC_PARAM_MAX_KEY_SIZE 16 static ble_gap_sec_params_t sec_param;
2.静态密钥初始化，初始化协议栈之后可以调用该函数
static void static_passkey_pair_init(void)
{
uint32_t err_code;
sec_param.bond = SEC_PARAM_BOND;
sec_param.mitm = SEC_PARAM_MITM;
sec_param.io_caps = SEC_PARAM_IO_CAPABILITIES;
sec_param.oob = SEC_PARAM_OOB;
sec_param.min_key_size = SEC_PARAM_MIN_KEY_SIZE;
sec_param.max_key_size = SEC_PARAM_MAX_KEY_SIZE;
static uint8_t passkey[]="123456";
static ble_opt_t m_ble_opt;
m_ble_opt.gap_opt.passkey.p_passkey = &amp;passkey[0]; err_code = sd_ble_opt_set(BLE_GAP_OPT_PASSKEY,&amp;m_ble_opt);
APP_ERROR_CHECK(err_code);
}
3.配对过程处理
static void on_ble_evt(ble_evt_t * p_ble_evt)
{
uint32_t err_code;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a80364b6ab272c8209c7208a8e985c8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/208/">«</a>
	<span class="pagination__item pagination__item--current">209/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/210/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>