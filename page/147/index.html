<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c3403b631f88f526fc37bba48e739b/" rel="bookmark">
			Building Worlds In Unreal 学习笔记——12-14 瀑布/雾与光/总结与展望
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Building Worlds In Unreal 学习笔记——12 瀑布 Lec12 瀑布 WaterfallsLec12.1 瀑布—场景设置与建模 Scene Setup and Meshes1 参考2 导出几何体/maya建模 Lec12.2 瀑布—法线动画 Animated NormalsLec12.3 瀑布—透明与反射 Opacity and RefractionLec12.4 瀑布—顶点位移动画 World Position OffsetLec12.5 瀑布—泡沫与收尾 Foam and Finishing Touches1 顶点色控制泡沫2 顶点色控制位移 Lec12.6 瀑布总结1 着色器2 多种方法联动/效果展示 Lec13 雾气与光束 Fog and Light Shafts1 参数2 小展示 Lec14 小场景制作回顾总结&amp;未来展望1 回顾总结2 未来展望——程序化 本系列学习资料来源，Ben Cloward的油管空间，B站的搬运翻译
关于瀑布这节，Ben佬委托给了tharlevfx来制作，在tharlevfx的油管空间分为好几个小节
Lec12 瀑布 Waterfalls Lec12.1 瀑布—场景设置与建模 Scene Setup and Meshes 1 参考 第一件事，看参考
静态参考
动态参考
2 导出几何体/maya建模 于是接下来可以做一些瀑布的网格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59c3403b631f88f526fc37bba48e739b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef091acc26f5201408c11ba4e783f5c/" rel="bookmark">
			C程序设计实现高内聚低耦合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要做到高内聚低耦合，重点并不是代码的编写，而是整体程序的设计阶段。
程序设计时，要先将要实现的功能列出来，然后设计模块。
模块设计后，再进行代码实现。
要做到高内聚低耦合，设计模块时需要做到：
1 各个模块之间的功能必须明确；
2 各个功能模块间实现的功能不可以有交叉；
3 不允许出现模块间的相互调用；
4 如果必须出现模块间调用，那么只允许单向调用，即A可以调用B，B不可以调用A。
只要做到以上效果，就可以实现高内聚低耦合，在代码实现过程中，可能会额外增加一些代码的复杂度，但为了降低维护难度，这样做是很有必要的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d118a202b20024f3f80d1c8fb775802/" rel="bookmark">
			百度-字符串匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
牛牛有两个字符串A和B,其中A串是一个01串,B串中除了可能有0和1,还可能有’?’,B中的’?'可以确定为0或者1。 寻找一个字符串T是否在字符串S中出现的过程,称为字符串匹配。牛牛现在考虑所有可能的字符串B,有多少种可以在字符串A中完成匹配。
例如:A = “00010001”, B = “??”
字符串B可能的字符串是"00",“01”,“10”,“11”,只有"11"没有出现在字符串A中,所以输出3
输入描述:
输入包括两行,第一行一个字符串A,字符串A长度length(1 ≤ length ≤ 50),A中每个字符都是’0’或者’1’。
第二行一个字符串B,字符串B长度length(1 ≤ length ≤ 50),B中的字符包括’0’,‘1’和’?’。
输出描述:
输出一个整数,表示能完成匹配的字符串种数。
示例1
输入
00010001
??
输出
3
//遍历A串 将所有匹配的B串的都加进set set自动去重 返回set大小 import java.util.Scanner; import java.util.HashSet; public class Main{ public static void main(String[] args){ Scanner scan = new Scanner(System.in); String A = scan.nextLine(); String B = scan.nextLine(); HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); int La = A.length(); int Lb = B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d118a202b20024f3f80d1c8fb775802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77113216bc70252ca84b4472580e88f5/" rel="bookmark">
			【LeetCode每日一题】Array题解-11盛最多水的容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 【11】盛最多水的容器思路代码 【11】盛最多水的容器 思路 代码 class Solution: def maxArea(self, height: List[int]) -&gt; int: """ # 法一：穷举法 maxArea = 0 for i in range(len(height)-1): for j in range(i+1, len(height)): if (j-i)*min(height[i], height[j]) &gt; maxArea: maxArea = (j-i)*min(height[i], height[j]) return maxArea """ # 法二：双指针法 i, j, maxArea = 0, len(height)-1, 0 while i != j: maxArea = max((j-i)*min(height[i], height[j]), maxArea) if height[i] &lt; height[j]: i += 1 else: j -= 1 return maxArea 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b12ffdd18cafaf0a493703813a13fac/" rel="bookmark">
			Vue 动态引入图片报错: Error in render: “Error: Cannot find module ‘./avatar.png‘“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题原因 图片路径是一个变量, 要使用 require 引入图片.
正常在页面引入 图片是可以正常显示, 路径是被 loader 处理过的
正常页面路径引入 使用变量 上面两种方法都是正常显示.
如果根据数据来引入图片就会出现问题 模拟 变量&lt;这个变量是相对路径&gt;引入 我把这个变量放到 created 声明周期中演示一下
这个时候页面就会报错
报错原因: require 里面必须是一个路径, 现在变量是字符串格式. 正确的引入方式 图片变量不使用 路径, 而使用图片的名称
require 路径使用拼接的方式, 前面使用图片文件夹路径, 后面拼接图片名称. 和后缀
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089e24711752d4e24a11139f27840d40/" rel="bookmark">
			华为交换机命令基础入门学习，小白也能看得懂！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注「开源Linux」，选择“设为星标”
回复「学习」，有我为您特别筛选的学习资料~
01
—
基础配置命令
1、用户模式
登陆设备后，直接进入用户模式，尖括号表示用户模式，在这个模式下只能执行少量查看配置的命令；
2、视图模式
用户模式下，输入system-view或者sys进入视图模式，方括号表示视图模式，可执行设备全局配置的命令；
3、交换机改名
这个提示信息，比较烦人。每次更改了什么配置都会显示出来，影响调试。可以使用下面的命令关闭掉
4、进入接口
5、退出此端口
02
—
创建vlan并将端口加入vlan
1、创建vlan
创建单个vlan
批量创建vlan
2、更改端口的链接类型
由于华为交换机的端口出厂时默认都是hybrid类型或auto类型的，所以无法立即加入vlan，需要更改端口的link-type后，才可以加入vlan。单个端口更改方式如下：
为何要选择access类型？？
因为我们是终端PC与交换机相连，要求PC只能只能和上级交换机通信，所以必须只属于1个vlan
以太网端口的链路类型有三种：
Access 类型：端口只能属于1 个VLAN，一般用于交换机与终端用户之间的连接；
Trunk 类型：端口可以属于多个VLAN，可以接收和发送多个VLAN 的报文，一般用于交换机 之间的连接；
Hybrid 类型：端口可以属于多个VLAN，可以接收和发送多个VLAN 的报文，可以用于交换 机之间连接，也可以用于连接用户的计算机。Hybrid 端口可以允许多个VLAN 的报文发送时不携带标签，而Trunk 端口只允许缺省VLAN 的报文，发送时不携带标签。
trunk端口用于交换机相连，pvid必须一致。
access 类型只能属于1 个vlan
规模较大的企业局域网，不建议使用vlan1，所以trunk端口不允许vlan1通过
3、端口加入vlan
以上的操作是单个操作，如果配置端口比较多就很麻烦，下面我们来批量操作。
4、端口的批量操作——端口组
原理就是创建一个端口组，把要更改的端口加入到端口组中，然后统一更改类型加入vlan。也可以理解为群组端口，统一配置类型加入vlan.
批量更改，先更改端口类型，再统一加入某个vlan，如下：
5、vlan的查看
全局查看vlan信息
查看端口与vlan对应关系
6、允许所有vlan通过
03
—
首次登入交换机或路由器
第一次上电和恢复出厂是一样的，我们先说一下恢复出厂设置。
1、恢复出厂设置
注意Y和N的选项，不要输错。
2、设置新密码
新交换机第一次上电，或恢复出厂设置后，要求设置新密码
出厂自带的用户名是admin，密码是admin@huawei.com
3、首次保存配置
第一次保存设置时，需输入文件名，只需按回车
4、设置日期和时间
设置console口的连接方式，可设置为无，仅密码，用户名密码等方式
5、开启必要的服务和功能
开启telnet服务，stp功能，http服务
6、设置vty，telnet登录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/089e24711752d4e24a11139f27840d40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8ef6ea12a9645e0b0bee72fb896c87/" rel="bookmark">
			【牛客】判断链表是否有环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
判断给定的链表中是否有环。如果有环则返回true，否则返回false。
求解思路
链表是否有环问题相当于数学中的相遇问题，但在一个环内不能像普通求解相遇问题那样判断路程相等，可以通过定义快慢指针来进行求解，在一个圆内两指针终归会指向同一个结点，且慢指针走的路程小于等于圆环的长度。
初始化两个指针使其都指向head 结点，每次让慢指针走一步而快指针走两步，循环判断两节点是否相等，如果相等则证明有环，否则判断无环。
完整代码如下所示：
public boolean hasCycle(ListNode head) { if(head == null || head.next == null){ return false; } ListNode fast = head; ListNode slow = head; while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; slow = slow.next; if(fast == slow){ return true; } } return false; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c401367f248fe12bde6b7425eb02f6/" rel="bookmark">
			8种MySQL分页方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在做数据库练习的时候由于数据有点多，一下全部显示出来不好看，看着比较乱，所以在查了一下怎么让MySQL分页找到了一篇不错的文章，在这里分享给大家。如果有帮到大家麻烦点个赞。谢谢。
方法1: 直接使用数据库提供的SQL语句
—语句样式: MySQL中,可用如下方法: SELECT * FROM 表名称 LIMIT M,N。
—适应场景: 适用于数据量较少的情况(元组百/千级)。
—原因/缺点: 全表扫描,速度会很慢 且 有的数据库结果集返回不稳定(如某次返回1,2,3,另外的一次返回2,1,3)。Limit限制的是从结果集的M位置处取出N条输出,其余抛弃。
方法2: 建立主键或唯一索引, 利用索引(假设每页10条)
—语句样式: MySQL中,可用如下方法:
复制代码 代码如下:
SELECT * FROM 表名称 WHERE id_pk &gt; (pageNum*10) LIMIT M。
—适应场景: 适用于数据量多的情况(元组数上万)。
—原因: 索引扫描,速度会很快。有朋友提出因为数据查询出来并不是按照pk_id排序的，所以会有漏掉数据的情况，只能方法3。
方法3: 基于索引再排序
—语句样式: MySQL中,可用如下方法: SELECT * FROM 表名称 WHERE id_pk &gt; (pageNum*10) ORDER BY id_pk ASC LIMIT M。
—适应场景: 适用于数据量多的情况(元组数上万). 最好ORDER BY后的列对象是主键或唯一所以,使得ORDERBY操作能利用索引被消除但结果集是稳定的(稳定的含义,参见方法1)。
—原因: 索引扫描,速度会很快. 但MySQL的排序操作,只有ASC没有DESC(DESC是假的,未来会做真正的DESC,期待)。
方法4: 基于索引使用prepare（第一个问号表示pageNum，第二个？表示每页元组数）
—语句样式: MySQL中,可用如下方法:
复制代码 代码如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67c401367f248fe12bde6b7425eb02f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0092e63c7a00d75d4bd5226ac52e3ea/" rel="bookmark">
			java  菜单列表转菜单树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求中经常遇到菜单列表转菜单树的情况，如果知道顶级菜单的话，有工具类可以使用，还是很方便的，hutool有一个TreeUtil类可以帮我们实现此功能，代码如下：
1.menu对象
@Data @EqualsAndHashCode(callSuper = false) @Accessors(chain = true) @ApiModel(value = "Menu对象", description = "菜单表") public class Menu implements Serializable { private static final long serialVersionUID = 1L; @TableId(value = "id", type = IdType.ASSIGN_ID) private String id; @ApiModelProperty(value = "上级id") private String parentId; @ApiModelProperty(value = "名称") private String name; @ApiModelProperty(value = "路径") private String url; @ApiModelProperty(value = "类型") private Integer type; @ApiModelProperty(value = "排序") private Integer sort; @ApiModelProperty(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0092e63c7a00d75d4bd5226ac52e3ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e23c489ab06d44efbd4e44b3faa4b1/" rel="bookmark">
			centos7.2安装mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos7.2安装mysql Step1.检测系统是否安装mysql yum list installed | grep mysql Step2.删除系统自带的mysql及其依赖 yum -y remove xxxxxx Step3.安装Yum Repo # 由于CentOS 的yum源中没有mysql，需要到mysql的官网下载yum repo配置文件 wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm rpm -ivh mysql57-community-release-el7-9.noarch.rpm Step4.安装MySQL yum install mysql-server Step5.启动msyql systemctl start mysqld Step6.获取安装时的临时密码 grep 'temporary password' /var/log/mysqld.log Step7.登录成功后修改密码 mysql -u root -p set password=password("newpassword"); exit; Step8.设置安全选项 mysql_secure_installation Step9.mysql启动关闭命令 systemctl stop mysqld #关闭MySQL systemctl restart mysqld #重启MySQL systemctl status mysqld #查看MySQL运行状态 systemctl enable mysqld #设置开机启动 systemctl disable mysqld #关闭开机启动 Step10.开启远程控制 # 数据库名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02e23c489ab06d44efbd4e44b3faa4b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8689a5ed78b8db26b3a0c0a2841492f/" rel="bookmark">
			ER图转关系模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）实体类型的转换 将每个实体类型转换成一个关系模式，实体的 属性 即为关系的 属性，实体标识符即为关系的键。
（2）联系类型的转换 实体间的关系是1对1 在实体类型转换成两个关系模式中的任意一个关系模式的属性中加入另一个关系模式的键和联系类型的属性。
实体间的联系是1对N 则在N端实体类型转换成的关系模式中加入1端 实体类主键。
如实体间的联系是M对N 单独将 联系类型 也转换成关系模式。将M和N端的主键都加进去。
示例：该ER图转换为关系模型 商店 和 职工是一对多关系，一个商店有多个职工，而一个职工只能属于一家商店；即职工是多端，在职工的关系模型中加入商店的主键，作为职工关系模型的外键
商店（商店编号，商店名，地址）
职工（职工编号，姓名，性别，商店编号）商店和商品是多对多，可以将二者的联系类型 销售 也转换成关系模型
商品（商品号，商品名，规格，单价）
销售（商店编号，商品号，月销售量） 一般主键加下划线，外键加波浪线；markdown没有这个语法，所以这里就没加，如果是笔试题，需要加。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caccc6dab9eec4ea5ffcfc5e2bed7f6f/" rel="bookmark">
			spring Boot2 —— 异常处理机制详细源码分析（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常处理 文章目录 异常处理一、错误处理1、默认规则2、源码分析3、定制错误处理逻辑（1）自定义错误页（2）统一异常处理相关注解介绍（3）ErrorViewResolver 实现自定义处理异常； 二、异常处理自动配置原理1、自动配置异常处理规则2、异常处理步骤流程 一、错误处理 1、默认规则 （1）默认情况下，Spring Boot提供/error处理所有错误的映射
（2）对于机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据
（3）要对其进行自定义，添加View解析为error
（4）要完全替换默认行为，可以实现 ErrorController 并注册该类型的Bean定义，或添加ErrorAttributes类型的组件以使用现有机制但替换其内容。
（5）error/下的4xx，5xx页面会被自动解析；
2、源码分析 Spring Boot的异常处理过程分析，从ErrorMvcAutoConfiguration开始。
源码中最为核心的几个组件是：
DefaultErrorAttributes：
BasicErrorController：
ErrorPageCustomizer：
DefaultErrorViewResolver：
异常处理步骤：
（1）系统发生4xx或5xx错误时，ErrorPageCustomizer就会生效（定制错误的响应规则，获取配置文件中的error.path的值，如果没有配置，默认使用/error路径）即，系统出现错误后来到/error请求进行处理。
“/error” 请求则是由BasicErrorController处理：
BasicErrorController分别实现了html和JSON格式的返回数据，通过不同客户端发送请求头之间的区别实现自适应
浏览器发送的请求头是“Accept： text/html”；而客户端的请求头为“Accept: * / *”。
响应页面的处理：
根据HttpStatus去调用resolveErrorView选择相对应的视图和Model（页面内容）
具体去到那个页面则由DefaultErrorViewResolver解析得到：
public class DefaultErrorViewResolver implements ErrorViewResolver, Ordered { private static final Map&lt;Series, String&gt; SERIES_VIEWS; static { Map&lt;Series, String&gt; views = new EnumMap&lt;&gt;(Series.class); //4开头的页面都可匹配，如有精确匹配则匹配精确页面 views.put(Series.CLIENT_ERROR, "4xx"); //5开头的页面都可匹配，如有精确匹配则匹配精确页面 views.put(Series.SERVER_ERROR, "5xx"); SERIES_VIEWS = Collections.unmodifiableMap(views); } ... @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { ModelAndView modelAndView = resolve(String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caccc6dab9eec4ea5ffcfc5e2bed7f6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/585e06aace85394a7e728e43beced684/" rel="bookmark">
			Linux速查(二) 系统常用目录路径规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统目录基本组成 Linux系统通常有很多系统目录。
系统目录通常包含三个部分：
/usr/local/share/emacs /usr/local 表示目录的范围/share 表示目录的类别/emacs 表示应用程序 范围 目录路径的范围用于描述整个目录层次的用途。
常见的范围：
常见范围用途/Linux提供的系统文件/usrLinux提供的更多系统文件/usr/Linux本地开发的系统文件，供组织的计算机货你的个人电脑使用 例如像lib这样的类别，Linux系统中相应的目录为/lib、/usr/lib、/usr/local/lib、/usr/games/lib等。
实际上，/和/usr之间并没有明确的区别，前者跟接近于操作系统。所以通常/bin中的程序要比/usr/bin中的跟基础、更通用，比如ls和cat等命令，以此类推还有库目录lib等等。
注：这些只是惯例，不是硬性规定
类别 类别的作用是指出目录中文件的类型。
例如某个目录的类别是bin，那么里面存放的都是程序。
常见的类别
程序类别用途bin程序，通常是二进制文件sbin程序，通常是二进制文件，由超级用户运行lib程序使用的代码库 文件类别用途doc文档infoemacs内置帮助系统的文档资料man供man程序使用的文档，手册页。通常是经过压缩、排版处理的share于特定程序相关的文件，如示例和安装说明 配置类别用途etc系统和其他杂项的配置文件init.d用于启动Linux的配置文件rc.d用于启动Linux的配置文件，此外还有rc1.d、rc2.d、…… 编程类别用途include编程时用到的头文件src程序的源代码 编程类别用途cgi-bin在Web页面上运行的脚本或程序htmlWeb页面public_htmlWeb页面，通常位于用户的主目录中wwwWeb页面 显示类别用途Fonts字体XllX窗口系统 硬件类别用途dev用来连接磁盘和其他硬件设备的设备文件media挂载点，提供磁盘访问的目录mnt挂载点，提供磁盘访问的目录 硬件类别用途var与本计算机密切相关的文件，他们是在计算机运行时创建和更新的lock由程序创建的锁文件，表示正在运行。log日志文件mail邮箱runPID文件，其中存放正在运行进程的IDspool处于排队或传输状态的文件，如发出的邮件、打印作业和计划作业tmp临时存储程序和系统或人员使用的文件的目录proc操作系统状态 应用程序 通常来说，目录路径的应用程序部分，通常是程序名称。
在范围和类别后面，程序也可以拥有自己的子目录，用来存放所需的文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99b8b2c6384ad7e4717dcc2bd3962b6a/" rel="bookmark">
			matlab文件相互调用,matlab中怎么同时运行多个M文件,这些文件怎么相互调用!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		楼主你好你的证明确实是在这样的，我也试验了下，个人认为是当matlab开始运行后，就将所有代码都读入内存，就算运行之中通过其他软件-例如记事本修改了正在运行的代码，也不会影响内存中的计算。个人见解，欢迎讨论www.mh456.com防采集。
function SIN=drawSin(x)%放在2113第一个m文件中5261SIN=sin(x);plot(x,y,'g*');function COS=drawCos(x)%放在第二个m文件中COS=sin(x);plot(x,y,'r*');function Main()%放在第三个4102m文件中,drawSin，drawCos是子程1653序x=-pi:0.1:pi;drawSin(x)drawCos(x)
我想你是要实现matlab并行计算。以前实现比较麻烦，新版本的matlab很容易了 matlabpool(2) parfor i=1:2 eval(['myfun' num2str(i)';']);end
一般情况下matlab都是一句一句代码执行的，你想要同时运行两个指令，要么双开matlab，要么利用matlab并行算法，例如parfor,spmd架构等，请详细说明你这样做的目的，好让我们分析解决你的问题内容来自www.mh456.com请勿采集。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30adc88202cbc48bcb0e3cca47db7622/" rel="bookmark">
			Kali镜像站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kali镜像站 http://cdimage.kali.org/kali-2021.1/
如图，这是一个免费的镜像站，需要其他版本的kali镜像，点击第一个“Parent Directory”即可
Ps：网站做的比较简陋，这里还支持目录访问，安全性有待提高
下载速度使用浏览器能到2MB，迅雷加持下能给到10MB的速度
图中选择amd64或是i386分别为x64架构和x86架构的系统镜像，cloud版本的暂不清楚，第2、3、4个文件是直接安装版的，内含有部分常见常用的软件，需要的也可以在安装时连接网络，在线更新最新的安装包。
netinst版本的则只包含了基础的kali系统，所有的软件均需通过网络在线下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177240f64a5b0c89371f7a06b69be0a6/" rel="bookmark">
			java如何构造ajax回调参数,ajax回调函数怎么使用？ajax回调函数的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于做Javaweb开发的小伙伴们来说，ajax应该很熟悉吧，每一个网站的数据交互都有可能用到它，那么，你们知道ajax的回调函数怎么用吗?今天我们就来讲一下ajax的回调函数。
首先我们要知道什么是回调函数?
回调函数就是一个通过函数指针调用的函数。如果你把函数的指针(地址)作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。
回调方法 是 任何一个 被 以该回调方法为其第一个参数 的 其它方法 调用 的方法。很多时候，回调是一个当某些事件发生时被调用的方法。
Ajax的回调函数，如下：
beforeSend
在发送请求之前调用，并且传入一个 XMLHttpRequest 作为参数。
error
在请求出错时调用。传入 XMLHttpRequest 对象，描述错误类型的字符串以及一个异常对象(如果有的话)
dataFilter
在请求成功之后调用。传入返回的数据以及 "dataType" 参数的值。并且必须返回新的数据(可能是处理过的)传递给 success 回调函数。
success
当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。
complete
当请求完成之后调用这个函数，无论成功或失败。传入 XMLHttpRequest 对象，以及一个包含成功或错误代码的字符串。
在与后台交互的时候，一般是使用到jquery的$.ajax()方法来请求数据。回调函数用的比较多的是success，但是beforeSend、complete、error函数也是很有用的。
例： $.ajax({
url: "pro/test.php",
type: "post",
timeout: 5000,
async: true,
cache: true,
data: $('#jsForm').serialize(),
dataType: "json",
contentType: "application/x-www-form-urlencoded",
beforeSend: function(XMLHttpRequest){
console.log(this);
$("#inp").val("正在获取数据...");
},
success: function(data){
console.log(data);
$(".display").html("获取到的数据:");
$(".display").append("总条数:"+data.data.all_count);
$("#inp").val("点击获取数据");
},
complete: function(XMLHttpRequest,textStatus){
if(textStatus=='timeout'){
var xmlhttp = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177240f64a5b0c89371f7a06b69be0a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261ef71de1050e461d1536997576ca69/" rel="bookmark">
			使用递归方法计算1-n之间的和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package Day12.Demo8; import java.util.Scanner; public class TestRecurisonSum { public static void main(String[] args) { Scanner sc=new Scanner(System.in); System.out.println("请输入1-n求和的最大值n："); int s=sum(sc.nextInt()); System.out.println(s); } public static int sum(int n){ /*定义一个方法，使用递归计算1-n之间的和 * n+(n-1)+(n-2).+.(n-n) * 已知最大值：n 最小值1 * 使用递归必须明确：1.递归的结束条件，获取到1的时候结束 * 2.递归的目的：获取下一个被加数字（n-1）*/ if(n==1){ return 1; } //获取下一个被加的数字（n-1） return n+sum(n-1); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c38897ca04a13827c28c691d0d44ca1/" rel="bookmark">
			输入一个链表的头节点，从尾到头反过来返回每个节点的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
方法一：递归方法,每次都是head.next+head.val
class Solution: def reversePrint(self, head: ListNode) -&gt; List[int]: if head: return self.reversePrint(head.next)+[head.val] else: return [] 方法二：转化为list后再逆向输出
class Solution: def reversePrint(self, head: ListNode) -&gt; List[int]: a=[] while head: a.append(head.val) head=head.next return a[::-1] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f32086a79c8d76ce46852891f11525/" rel="bookmark">
			二叉搜索树以及完全二叉树判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：
这里只讲完全二叉树的思路，搜索二叉树可以看我这篇博客，请点击！
完全二叉树按照以下步骤解题即可：
按层序遍历，从每层的左边向右边依次遍历所有的节点如果当前的节点有右孩子节点，但是没有左孩子节点，直接返回false如果当前节点并不是左右孩子节点全有，那么之后的节点必须都为叶节点，否则直接返回false遍历过程中如果不返回false，则遍历结束以后返回true 代码：
/** * struct TreeNode { *	int val; *	struct TreeNode *left; *	struct TreeNode *right; * }; */ class Solution { public: vector&lt;bool&gt; judgeIt(TreeNode* root) { // write code here vector&lt;bool&gt; res{true,true}; if (!root) return res; inOrder(root); for(int i = 1;i&lt;midSeq.size();++i) //检查是否升序序列 if (midSeq[i] &lt; midSeq[i - 1]) { res[0] = false; break; } res[1] = isComplete(root); return res; } void inOrder(TreeNode* root) { //中序遍历 if (root == nullptr) return; inOrder(root-&gt;left); midSeq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f32086a79c8d76ce46852891f11525/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/372582259da8a308aeafe81e7d5c6d88/" rel="bookmark">
			前端服务请求后台接口，返回跨域报错问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决此类问题的方法很多，有需要客户端和服务端都要更改的，例如jsonp，iframe等等；有只需要客户端更改的，这种情况只能出现在hybrid app开发中，即通过调用native方法来进行网络请求；有只需要服务端配置的，下面介绍3种服务端配置的方法。
第一种 如果您使用的mvc框架是spring4.2以上的话，一个@CrossOrigin就可以搞定。将@CrossOrigin加到Controller上，那么这个Controller所有的请求都是支持跨域的，代码如下：
@Controller @CrossOrigin public class GreetingController { 将@CrossOrigin加到请求方法上，那么这个请求是支持跨域的，代码如下
@CrossOrigin @RequestMapping("/greeting") public @ResponseBody Greeting greeting(@RequestParam(required=false, defaultValue="World") String name) { 更详细的@CrossOrigin介绍，请参看这里
第二种 全局配置，也需要spring4.2以上。
@Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurerAdapter() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping("/greeting-javaconfig").allowedOrigins("http://localhost:9000"); } }; } .addCorsMappings()中的参数代表支持跨域的url，.allowedOrigins()中的参数代表可以访问该接口的域名，设置为”*”可支持所有域。
第三种 这种方法就跟框架无关了，需要两个jar包，点击这里进行下载，两个jar包可以放的程序里，也可以放到tomcat中，然后将下面的配置写到web.xml中就可以了
&lt; filter &gt;
&lt; filter-name &gt; CORS &lt;/ filter-name &gt;
&lt; filter-class &gt; com.thetransactioncompany.cors.CORSFilter &lt;/ filter-class &gt; &lt; init-param &gt; &lt; param-name &gt; cors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/372582259da8a308aeafe81e7d5c6d88/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/146/">«</a>
	<span class="pagination__item pagination__item--current">147/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/148/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>