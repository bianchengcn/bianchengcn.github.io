<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5221b8085f4454fff273bddf8d6b2522/" rel="bookmark">
			Ceisum绘制雷达效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在绘制圆锥的基础上加上Primitive的材质渲染（GLSL语言）。
//初始化雷达波 initRadarRiationWave() { // 雷达的高度 let length = 40000; let centerOnEllipsoid = Cesium.Cartesian3.fromDegrees(110, 26, length * 0.5); this.map.camera.flyToBoundingSphere(new Cesium.BoundingSphere(centerOnEllipsoid, length)); // 矩阵计算 let modelMatrix = Cesium.Matrix4.multiplyByTranslation( Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(110, 26)), new Cesium.Cartesian3(0.0, 0.0, length * 0.5), new Cesium.Matrix4() ); let geometry = new Cesium.CylinderGeometry({ length, topRadius: 0.0, bottomRadius: length * 0.3, vertexFormat: Cesium.MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat }); // 创建GeometryInstance let geometryInstances = new Cesium.GeometryInstance({ geometry, modelMatrix, }); // 创建雷达图Primitive let radar = viewer.scene.primitives.add(new Cesium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5221b8085f4454fff273bddf8d6b2522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b84367fa82a6a454d885dee8893f51/" rel="bookmark">
			K8S图像化工具rancher
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Rancher是一个开源的企业级多集群的k8s管理平台
Rancher和k8s的区别
都是为了容器的调度和编排系统，但是rancher不仅能够调度，还能挂历k8s集群，自带监控（普罗米修斯），你哪怕不知带k8s是什么，一样轻松的部署容器到k8s到集群中，大公司都是图形化
[root@master01 ~]# docker pull rancher/rancher-agent:v2.5.7 [root@node01 ~]# docker pull rancher/rancher-agent:v2.5.7 [root@node02 ~]# docker pull rancher/rancher-agent:v2.5.7 [root@k8s4 ~]# docker pull rancher/rancher:v2.5.7 [root@k8s4 ~]# docker run -d --restart=unless-stopped -p 80:80 -p 443:443 --privileged --name rancher rancher/rancher:v2.5.7 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9841d6b5516348aad98d16a946f5de2/" rel="bookmark">
			2022算法岗秋招面试总结——CV基础（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022秋招已经结束，这是我从去年8月份投简历以来，面试被问到的一些问题做了总结，方便自己以后回顾，现将一部分分享给大家，后面想起来继续更新，如有问题，还请纠正。
CV基础——深度学习 1、YOLOv4相对于YOLOv3做了哪些改进？2、目标检测中的NMS，介绍一下？3、关于K-means算法，讲讲？4、在模型训练的过程中，遇到了一些情况如何收敛loss的？5、 如何提高目标检测模型的置信度，提高map？6、目标检测正负样本不均衡怎么解决？7、卷积核的大小，如何选取？感受野概念具体做法 8、有哪些方法可以提高CNN的泛化能力？9、围绕BN层问的一些问题由来原理训练和测试阶段的不同注意点 10、深度学习炼丹有哪些可以调的超参数？11、Focal Loss的作用？12、目标检测中如何解决遮挡问题？13、算法开发阶段涉及到加速，具体讲讲？14、pytorch中nn.module和nn.functional的区别？ 1、YOLOv4相对于YOLOv3做了哪些改进？ 输入端：主要是训练时对输入的改进，主要包括Mosaic数据增强、标签平滑、SAT自对抗训练；BackBone主干网络：将各种新的方式结合起来，包括：CSPDarknet53、Mish激活函数；Neck：目标检测网络在BackBone后面添加的一些层，比如Yolov4中的SPP模块、FPN+PAN结构；Prediction：输出层的锚框机制和Yolov3相同，主要改进的是训练时的损失函数CIOU_Loss，以及预测框筛选的nms变为DIOU_nms;损失函数组成：回归框的预测误差、分类误差、置信度误差； 2、目标检测中的NMS，介绍一下？ NMS就是非极大值抑制，具体算法流程如下：
设定一个阈值，将低于该阈值的预测框进行剔除；将所有框的按照得分进行排序，选中最高分及其对应的框；遍历其余的框，如果和当前最高分框的重叠面积(IOU)大于一定阈值，我们就将框删除。（删除是因为超过设定阈值，认为两个框的里面的物体属于同一个类别，比如都属于狗这个类别。）从未处理的框中继续选一个得分最高的，重复上述过程，找到所有被保留下来的框。如果有很多框的话，说明检测场景中有多个类别。 3、关于K-means算法，讲讲？ 算法思想：
根据给定的n个数据对象的数据集，构建k个划分聚类的方法，每个划分聚类即为一个簇。该方法将数据划分为n个簇，每个簇至少有一个数据对象，每个数据对象必须属于而且只能属于一个簇，同时要满足同一簇中的数据对象相似度高，不同簇中的数据对象相似度较小，聚类相似度是利用各簇中对象的均值来进行计算的。
操作流程：
首先，如果已经知道要分为2类，随机选取样本空间的2个数据点作为起始点，计算其余的点分别到2个起始点的距离，接着将距离最近的点归为一类；接着，将分好的两个类别中，找到对应的质心，计算其余点到两个质心的距离，按照距离远近进行分类，距离最近的归为一类；最后，重复上述操作，直到分出来的类，与上一次的结果一致，分类结束。 **K值的确定：**Kmeans聚类的评估方法是看误差项平方和，就是计算所有点到相应簇中心的距离均值，k值越大，误差项平方和(SEE)越小，我们就是要求出随着k值的变化SSE的变化规律，找到SSE减幅最小的k值，或者看SEE曲线变化一阶导数变化最大的地方对应的K值。
4、在模型训练的过程中，遇到了一些情况如何收敛loss的？ loss曲线在整体趋势为下降时，如果出现起伏，也就是一上一下开始震荡，如下图所示，为了减少这种起伏状态，可以增加batch_size来缩小综合梯度方向摆动范围。
当解决完上述情况，当loss整体趋于平缓时，但是还有起伏，如下图所示，可以降低学习率进一步收敛。
如果起伏不可观时，可以提前终止训练防止过拟合。
5、 如何提高目标检测模型的置信度，提高map？ 概念梳理：
map：mean average precision 即所有类别AP的平均值。
TP：True Positive，与目标框(ground truth)的IOU &gt; 0.5的检测框数量；
FP：False Positive，与目标框(ground truth)的IOU &lt; 0.5的检测框数量;
Precision：所有预测正确的框与所有预测出来的框的比例，这里所有预测出来的框即经过置信度阈值筛选后出来的框。
Recall：所有预测正确的框与所有真实框（ground truth）的比例。
具体解决方法：
调小score_threshold，在验证阶段调小score_threshold，可以快速将map提升，但是实际上模型的预测结果和置信度还是很低；调小batch_size，同时增大学习率，batch_size小了，即每次学习到的内容数量少，但是理解得比较深刻，总的花费时间也变久了，最终模型训练的结果也较好，map变高；调高nms阶段的score_threshold，表示只预测超过该概率的预测结果，可以提高map,可以慢慢调，从0.01调到0.05，再0.1；选择合适的优化器； 6、目标检测正负样本不均衡怎么解决？ 重加权：可以修改损失函数前面的权重来解决，经典的损失函数focal loss 就是这样，比如YOLOv3中，对于检测到的目标权重系数给的是5，对于非目标权重系数给的是0.5。重采样：少样本过采样，但容易过拟合，无法学习到更加鲁棒的特征；多样本欠采样，但容易丢失主要信息，欠拟合；数据合成：生成和少样本相似的新数据，对任意选取的少类样本用k近邻选取其相似样本，通过对样本线性插值得到新样本； 7、卷积核的大小，如何选取？ 最常用的是3∗3大小的卷积核，两个3∗3卷积核和一个5∗5卷积核的感受野相同；
感受野概念 神经网络中神经元看到的输入图像区域，在卷积神经网络的计算中，相当于特征图中某个元素受输入图像某个区域的影响，因为经过层层卷积得到最终的特征图，在之前卷积核扫过的输入图像的区域。
具体做法 用两个33的卷积核代替一个55的卷积核，可以减少了参数量和计算量，加快了模型训练。与此同时由于卷积核的增加，模型的非线性表达能力大大增强。
两个33卷积核参数量计算：2（33+1）=20
一个55卷积核参数量计算：5*5+1=26
计算量如何计算，涉及到得到的特征图大小，在参数量基础上乘特征图宽高。
8、有哪些方法可以提高CNN的泛化能力？ 采集更多的数据，数据的上限决定算法的上限；优化数据分布，均衡各种类别的数据；对数据集进行数据增强；选用合适的损失函数；选择合适的优化器；设计合理的网络结构；运用好权重初始化；引入dropout，以一定的概率失活神经元，简化了网络结构；权值正则化，在损失函数后面加一些惩罚项，如l1或者l2范数。 9、围绕BN层问的一些问题 由来 神经网络在做非线性变换之前的输入值随着网络深度的加深，其特征层的分布会逐渐发生偏移，一般整体分布会逐渐往非线性激活函数取值区间的上下限两侧偏移，最终导致反向传播时低层神经网络出现梯度消失的问题，这就是训练深层神经网络收敛越来越慢的本质原因。
原理 BN的作用就是通过一定的正则化的手段，将每一个神经元的响应值进行标准化，所谓标准化就是把每层神经网络任意神经元的输入值分布强行拉回到均值为0方差为1 的标准正态分布，这样就避免了因为激活函数导致的梯度弥散的问题。
训练和测试阶段的不同 训练阶段：在训练阶段，BN层是对每个batch的训练数据进行标准化，即用到每一批数据的均值和方差，在把标准化后的分布值乘以γ加上β，每一个神经元训练一组γ、β，这两组参数均是训练阶段需要学习的参数；
测试阶段：测试阶段的话，因为只输入一个测试样本，没有batch的概念，均值、方差还有γ。β、都用整个数据集训练后的。
注意点 BN的本质是利用优化学习来不断改变方差和均值，在CNN中，BN的处理是以特征图为单位进行处理的，而不是以维度，这是和LN，也就是LayerNorm区别的地方；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9841d6b5516348aad98d16a946f5de2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ebf2274b428bb9ecf5db4045d61f49/" rel="bookmark">
			Node.js中fs模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fs模块是Node.js中的一个核心模块，全称为File System（文件管理系统）。该模块专门用来操作系统中的文件，常用的操作方式是对文件的读取和写入。
fs模块的API大都提供三种操作方式： 同步操作文件：代码会被阻塞，不会继续执行。异步回调函数操作文件：代码不会被阻塞，需要传入回调函数，当获取到结果时，回调函数执行。异步Promise操作文件：代码不会被阻塞，通过fs.promises调用方法操作，会返回一个Promise。 常用的fs模块方法名称： fs.readFile：读取文件内容。fs.writeFile：将数据写入文件。fs.appendFile：将数据追加到文件末尾。fs.readFileSync：同步读取文件内容。fs.writeFileSync：同步将数据写入文件。fs.appendFileSync：同步将数据追加到文件末尾。fs.exists：检查文件或目录是否存在。fs.existsSync：同步检查文件或目录是否存在。fs.mkdir：创建新目录。fs.mkdirSync：同步创建新目录。fs.readdir：读取目录中的文件和子目录列表。fs.readdirSync：同步读取目录中的文件和子目录列表。fs.unlink：删除文件或目录。fs.unlinkSync：同步删除文件或目录。fs.rmdir：删除目录。fs.rmdirSync：同步删除目录。fs.rename：重命名文件或目录。fs.renameSync：同步重命名文件或目录。fs.stat：获取文件或目录的状态信息。fs.statSync：同步获取文件或目录的状态信息。 这些方法提供了对文件和目录的基本操作，如读取、写入、删除、重命名等。在使用这些方法时，通常需要提供文件或目录的路径作为参数，并根据需要传递回调函数来处理异步操作的结果。
除了fs模块，Node.js还提供了其他与文件系统相关的模块，如path模块用于处理文件路径，stream模块用于处理流数据等。这些模块共同构成了Node.js强大的文件系统处理能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d407c8c1618e3665c46bdbcfe382db62/" rel="bookmark">
			休闲时间利用Python轻松接单，实现财务自由它不香吗！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先分享几个思路 兼职费用足够学费+生活费
恰巧上学期间接过一些外包，恩，足够我和我媳妇的学费以及生活费，以及xx各种费用。
主要干过以下几种：
游戏外挂： 主要开发工具 为按键精灵，赚的不多，但是属于持续性收入，基本上可以覆盖整个游戏的生命周期，但随着监管力度增大，风险越来越高，本人已经退出这个行业。
开发网站： 大学期间主要是WordPress还有Django撸了几个小站，搞搞前端基本就能过关，大概每个站能赚3-5千，投入产出比很高，但是不是经常能碰到这种活。
爬虫： 16年之前也就是我还未毕业的时候，曾经用scrapy抓了很多数据，卖给过不少公司，最大一次是百度地图。哈哈哈哈。基本上13年到16年主要就是靠卖数据生存，刚毕业那会外包收入一度比工资多，但是！请注意！近两年爬虫门槛降低很厉害，很多公司已经有了专职的IT爬虫人员，市面上需求大大降低！个人认为随着八爪鱼等软件的兴起，低端爬虫相关工作会越发的薪酬降低。
数据挖掘： 外包工作极少，但是目前找工作还是蛮好找的，个人认为以后工作前景不错，如果愿意可以发展一下。
公众号开发： 类似的开发外包。
看一下通过兼职的收益 近两年开辟副业兼职赚钱的人越来越多，我们似乎进入了一个全民副业的时代，毕竟，在面对越来越大的资金需求时，不能指望资本家给涨工资，做副业更明智。
Python兼职订单记录
得益于人工智能、大数据与物联网的爆火，互联网对Python技术服务的需求越来越迫切，相应的服务报酬也越来越丰厚。特别是数据采集与分析服务，供不应求早已是常态！
虽说各类甲方对爬虫服务有着很迫切的需求，但其对技术的要求却并未因此降低。通常，那些高报酬的爬虫项目都需要攻破各类反爬虫措施才能完成，破不了反爬虫就赚不到钱。
反爬虫措施是大家兼职赚钱的拦路虎，每天都有很多人来咨询，包括但不限于：动静态Cookie破解、进制流参数逆向、对称加密算法逆向、混淆与无混淆JS逆向在内的，爬虫破解相关技术问题。大家都在期待一套能快速进阶的技术速成方案。
-END-
读者福利：如果大家对Python感兴趣，这套python学习资料一定对你有用
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以根据这些资料规划好学习计划和方向。
包括：Python激活码+安装包、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习、Python量化交易等习教程。带你从零基础系统性的学好Python！
零基础Python学习资源介绍 ① Python所有方向的学习路线图，清楚各个方向要学什么东西
② 600多节Python课程视频，涵盖必备基础、爬虫和数据分析
③ 100多个Python实战案例，含50个超大型项目详解，学习不再是只会理论
④ 20款主流手游迫解 爬虫手游逆行迫解教程包
⑤ 爬虫与反爬虫攻防教程包，含15个大型网站迫解
⑥ 爬虫APP逆向实战教程包，含45项绝密技术详解
⑦ 超300本Python电子好书，从入门到高阶应有尽有
⑧ 华为出品独家Python漫画教程，手机也能学习
⑨ 历年互联网企业Python面试真题,复习时非常方便
👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉100道Python练习题👈 检查学习结果。
👉面试刷题👈 资料领取 这份完整版的Python全套学习资料已为大家备好，朋友们如果需要可以微信扫描下方二维码添加，输入"领取资料" 可免费领取全套资料【有什么需要协作的还可以随时联系我】朋友圈也会不定时的更新最前言python知识。↓↓↓
或者
【点此链接】领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b1b388b7dd62442f1b9bd40be298566/" rel="bookmark">
			小程序系列--12使用 npm 包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Vant Weapp 1. 什么是 Vant WeappVant Weapp 是有赞前端团队开源的一套小程序 UI 组件库，助力开发者快速搭建小程序应用。它所使用的是 MIT 开源许可协议，对商业使用比较友好。
官方文档地址 https://youzan.github.io/vant-weapp 2. 安装 Vant 组件库 详细的操作步骤，大家可以参考 Vant 官方提供的快速上手教程： https://youzan.github.io/vant-weapp/#/quickstart#an-zhuang 3. 使用 Vant 组件 4. 定制全局主题样式 Vant Weapp 使用 CSS 变量来实现定制主题。 关于 CSS 变量的基本用法，请参考 MDN 文档： https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties 所有可用的颜色变量，请参考 Vant 官方提供的配置文件： https://github.com/youzan/vant-weapp/blob/dev/packages/common/style/var.less 二、API Promise化 1. 基于回调函数的异步 API 的缺点 2. 什么是 API Promise 化 3. 实现 API Promise 化 4. 调用 Promise 化之后的异步 API 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf1566b03e5f91a4eb48709ebeb0e674/" rel="bookmark">
			每日一题 力扣2865 美丽塔Ⅰ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2865. 美丽塔 I 题目描述： 给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。
你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。
如果以下条件满足，我们称这些塔是 美丽 的：
1 &lt;= heights[i] &lt;= maxHeights[i]heights 是一个 山脉 数组。 如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：
对于所有 0 &lt; j &lt;= i ，都有 heights[j - 1] &lt;= heights[j]对于所有 i &lt;= k &lt; n - 1 ，都有 heights[k + 1] &lt;= heights[k] 请你返回满足 美丽塔 要求的方案中，高度和的最大值 。
示例 1：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf1566b03e5f91a4eb48709ebeb0e674/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4966443e96c4f3e7e88475b5c16d783/" rel="bookmark">
			el-tabs切换el-table多级表头清空sort排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;el-table :key="random" :data="tableData" style="width: 100%"&gt; &lt;el-table-column prop="date" label="Date" width="150" /&gt; &lt;el-table-column label="Delivery Info"&gt; &lt;el-table-column prop="name" label="Name" width="120" /&gt; &lt;el-table-column label="Address Info"&gt; &lt;el-table-column prop="state" label="State" width="120" /&gt; &lt;el-table-column prop="city" label="City" width="120" /&gt; &lt;el-table-column prop="address" label="Address" /&gt; &lt;el-table-column prop="zip" label="Zip" width="120" /&gt; &lt;/el-table-column&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; const tableData = [ { date: '2016-05-03', name: 'Tom', state: 'California', city: 'Los Angeles', address: 'No. 189, Grove St, Los Angeles', zip: 'CA 90036', }, { date: '2016-05-02', name: 'Tom', state: 'California', city: 'Los Angeles', address: 'No.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4966443e96c4f3e7e88475b5c16d783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0300406759e666850e4024ab08498d14/" rel="bookmark">
			RSA 加密解密，中文不乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import lombok.extern.slf4j.Slf4j; import org.apache.commons.codec.binary.Base64; import javax.crypto.Cipher; import java.security.*; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; @Slf4j public class RSAEncrypt { public static void main(String[] args) throws Exception { String point = "xxx"; //生成公钥和私钥 Map&lt;String, String&gt; keyMap = new HashMap&lt;&gt;();//genKeyPair(); keyMap.put("publicKey", "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDOUDwJVY1JMY4oSHM1+VKeYZ5T2LjQ4wvENnt0TlRoOYDrUen4Nm3GbVKiGTot76gu7xYL1X9PQvDnYLpUVu0mA2oLrXWZj2ByTW83Ehdc5Y9aLXtNzmm4e6PXtuEtXk2sqUZz+XtBBAUMAne4J9G9DAZVPLFxUUJyzVb9cnK6NQIDAQAB"); keyMap.put("privateKey", "MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAM5QPAlVjUkxjihIczX5Up5hnlPYuNDjC8Q2e3ROVGg5gOtR6fg2bcZtUqIZOi3vqC7vFgvVf09C8OdgulRW7SYDagutdZmPYHJNbzcSF1zlj1ote03Oabh7o9e24S1eTaypRnP5e0EEBQwCd7gn0b0MBlU8sXFRQnLNVv1ycro1AgMBAAECgYAKkJlCcRsXEG6TKYKc1POiIKWW7ZYpPDcyCQgxYIF6BNfRNRSiHUdpzddZbalJCOi33o5mdLxcNrVXY+CmyPzDyeyNWWX8UcL2Wud8vRlWU7kQ+YcCVyS/nqRLBpHb0QgW7bqzb7fRpnmqhfj+A9hzRaoKxsZ8EWQfvN5UcdmQgQJBAPyTXzHcicK6gsgaXVo8awXsKxT6/bVAq7+FO/F4ckflS3oyABFNnqVRTC3nuQsU6nq3fu1kDwa03NcAa5zZaykCQQDRHEw4N0pnGKdecKTjBlD95B9WI0KCMWHpSOTIZJUIEvKXANX5BFaGHY01BNxDmwVcuecHgG2XH/WyIzVeJEQtAkEA8WM/NX4aQvrRhsB7u4PGnPBq9DA0TQeznOSOt2ZvgfrIOc6TdfYCyuh5r92oYcjpl8LLEcHxAm3UKb8DGfJIkQJAAjyYQB2vSQ0FdUglK1x870pKX4R/CJ94maMy90XEJlL1j1Ht9/zo5ARa509G/94fn49JflYMVgp8eUxRHNGsfQJBAKm39ZUaFyuDSpRINHZNHfldasmy9hLyXdTb3sLFj/bPaq0MyORAZPqq6XCu+nnIhVKVyADbXb+8T5kn70lzIbg="); String publicKey = keyMap.get("publicKey"); String privateKey = keyMap.get("privateKey"); System.out.println(publicKey); System.out.println(privateKey); //加密字符串 String message = "这是亲前端请求的入参"; System.out.println("-------------------------------------------------------"); System.out.println("前端请求的原数据 ："
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0300406759e666850e4024ab08498d14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f1b7865f6eb010f6bf89bfa5ee6b63/" rel="bookmark">
			Python 字符串不可变性的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、优点
内存效率
安全性
简洁性
二、缺点
灵活性受限
内存占用增加
性能开销
三、实际应用中的影响
四、结论
Python中的字符串具有不可变性，这意味着一旦创建了一个字符串对象，就不能更改其内容。这一特性对字符串操作带来了一些优势和劣势。下面我们将深入探讨Python字符串不可变性的优缺点，以及在实际应用中的影响。
一、优点 内存效率 由于字符串是不可变的，Python可以重复使用字符串对象。当创建一个新字符串时，如果该字符串与已存在的字符串对象相同，Python可以重用该对象，而不是创建一个新的对象。这有助于减少内存占用，特别是在处理大量字符串时。
例如：
s1 = "hello" s2 = "hello" # s1和s2实际上指向同一个字符串对象 print(s1 is s2) # 输出：True 这种特性在处理大量字符串时特别有用，可以有效减少内存使用，提高程序的运行效率。
安全性 由于字符串不可变，因此可以确保字符串内容的稳定性。这意味着在处理敏感数据或配置信息时，可以更安全地使用字符串。一旦一个字符串被创建，其内容就不能被修改，从而避免了潜在的安全风险。
例如，在处理用户输入或配置文件时，不可变的字符串可以防止意外修改，确保数据的一致性和安全性。
简洁性 不可变性使得字符串的处理更为简单明了。程序员不必担心字符串在操作过程中被意外修改，这有助于减少错误和提高代码的可读性。在编写代码时，可以更专注于字符串本身的逻辑处理，而不是担心其可变性。
二、缺点 灵活性受限 由于字符串是不可变的，某些操作可能会变得复杂或低效。例如，如果要在一个字符串中替换某个子串，需要创建一个新的字符串对象，这可能会消耗更多的计算资源。
此外，对于需要频繁修改的字符串操作，如拼接、替换或删除等，不可变性可能导致频繁的内存分配和垃圾回收，从而影响程序的性能。
内存占用增加 虽然重复使用的字符串可以减少内存占用，但在某些情况下，不可变性可能会导致额外的内存占用。例如，当需要频繁修改字符串时，每次修改都需要创建一个新的字符串对象，这可能导致大量的内存分配和垃圾回收。这种情况在处理大量数据或文本时尤为明显。
性能开销 由于字符串是不可变的，某些操作可能会比在可变类型上执行时更慢。例如，连接大量字符串时，使用可变类型可能会更高效。另外，对于需要频繁修改字符串的操作，不可变性可能导致额外的性能开销。由于每次修改都需要创建新的字符串对象，这会增加程序运行的时间复杂度。在处理大量数据或文本时，这种性能开销可能会变得显著。
三、实际应用中的影响 在实际应用中，Python字符串不可变性的优缺点取决于具体的使用场景。在许多情况下，不可变性带来的优点更为突出。例如，在处理敏感数据或配置文件时，不可变性确保了数据的安全性和稳定性。此外，对于需要大量重复使用的短字符串，不可变性有助于提高内存效率。然而，在某些情况下，不可变性可能会成为问题。例如，在处理大量数据或文本时，频繁创建新的字符串对象可能会导致性能下降。在这种情况下，可以考虑使用其他数据结构（如列表）来存储和处理文本数据，然后在需要时将其转换为字符串。
四、结论 总的来说，Python中字符串的不可变性既有优点也有缺点。在实际应用中，应根据具体需求和场景来权衡使用不可变字符串的利弊。在某些情况下，不可变性可以提高内存效率、安全性并简化代码；而在其他情况下，可能需要采取措施来克服其带来的限制和性能问题。了解这些优缺点有助于更好地选择合适的数据结构和操作方法来满足实际需求。
以下是一些建议，可以帮助在使用Python时更好地利用字符串不可变性的优点并避免其缺点：
合理使用字符串：在需要处理字符串时，尽量合理使用字符串，避免不必要的频繁修改。如果需要对字符串进行修改，可以考虑使用其他数据结构（如列表）来存储和处理文本数据，然后在需要时将它们转换为字符串。优化性能：对于需要频繁修改字符串的情况，可以采取一些性能优化措施。例如，可以使用字符串的子串操作来避免创建过多的新字符串对象，或者使用缓存机制来重复利用已创建的字符串对象。了解内存管理：了解Python的内存管理机制可以帮助更好地利用字符串不可变性的优点。例如，可以合理使用垃圾回收机制来自动回收不再使用的字符串对象，从而减少内存占用。可变替代方案：如果需要频繁修改字符串，可以考虑使用其他可变的数据结构，如列表或集合，来存储和处理文本数据。这些数据结构允许更灵活的操作，并且可能提供更好的性能。利用第三方库：Python有许多第三方库可用于处理字符串，其中一些库可能提供了更好的性能和更灵活的操作。例如，可以使用正则表达式库来高效地处理复杂的字符串模式匹配和替换操作。 总之，了解Python字符串不可变性的优缺点是编写高效、安全和可维护代码的关键。在实际应用中，需要根据具体的需求和场景来选择合适的数据结构和操作方法，以充分利用字符串不可变性的优点并避免其缺点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a72c09b35e5ef042f4a75df65c2116/" rel="bookmark">
			如何统计百万用户在线状态-bitmap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 经常你会听到，说我们的网站日活是多少，每天在线人数多少等等，那他是怎么实现的？
bitmap介绍 BitMap 原本的含义是用一个比特位来映射某个元素的状态。由于一个比特位只能表示 0 和 1 两种状态，所以 BitMap 能映射的状态有限，但是使用比特位的优势是能大量的节省内存空间。
在 Redis 中，可以把 Bitmaps 想象成一个以比特位为单位的数组，数组的每个单元只能存储0和1，数组的下标在 Bitmaps 中叫做偏移量。
位图不是实际的数据类型，而是在 String 类型上定义的一组面向位的操作，将其视为位向量。由于字符串是二进制安全 blob，其最大长度为 512 MB，因此它们适合设置最多 2^32 个不同位。
基本使用 SETBIT 语法
SETBIT key offset value 设置或者清空 key 的 value 在 offset 处的 bit 值（只能是 0 或者 1）。
警告：当设置最后一个可能的位（偏移量等于2^32 -1）并且存储在key处的字符串值尚未保存字符串值，或者保存一个小的字符串值时，Redis需要分配所有可能阻塞的中间内存服务器一段时间了。在 2010 MacBook Pro 上，设置位号 2^32 -1（512MB 分配）需要约 300ms，设置位号 2^30 -1（128MB 分配）需要约 80ms，设置位号 2^28 -1（32MB 分配）需要约 30 毫秒，设置位数 2^26 -1（8MB 分配）需要约 8 毫秒。请注意，一旦完成第一次分配，后续对同一键的 SETBIT 调用将不会产生分配开销。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40a72c09b35e5ef042f4a75df65c2116/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22644b89aa22a48dbcf4d46ebe3433cb/" rel="bookmark">
			汤姆·齐格弗里德《纳什均衡与博弈论》笔记（7）博弈论与概率论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十一章 帕斯卡的赌注——博弈、概率、信息与无知 在与费马就这个问题的通信过程中，帕斯卡创造出了概率论。另外，帕斯卡在进行严谨的宗教反思中，得出了概率这个概念，它在此几百年后，成为一个关键的、对博弈论的提出有重要意义的数学概念。
帕斯卡观察到，当下注开赌的时候，仅仅知道输赢的概率是多少是远远不够的，你还必须知道什么是风险。举个例子，如果赢的概率很小，但如果赢了，回报很高。那么这时，你就可能愿意去冒险。或者你会追求安全，即使回报很低，也把赌注压在确定会赢的牌上。然而如果知道回报不高，却将赌注押在一手不那么容易赢的牌上就显得很不明智了。
帕斯卡在其宗教著作中勾勒出了这个问题的框架，特别是关于是否存在上帝的赌博情况中。选择相信上帝就像下了个赌注，他说。如果你相信有上帝，而且这个信念最终被证明是错误的，你也不会失去什么。如果上帝的确存在，信仰上帝会使你赢得一生的无尚幸福感。纵使上帝的存在是一个低概率的神的存在，而相信他存在的回报确是那么的巨大（基本上是无限大的）。无论如何，他确实是一个很好的赌注。“让我们来衡量一下在上帝是否存在的博弈中的得失，”他写道，“让我们来判断一下这两种情况。如果你赢了，你会得到所有；如果你输了，你什么也没有失去。那么，毫不犹豫，他就是个赌博。”
帕斯卡的推理也许是在神学上过分简单化了，但是确实在数学方面很吸引人。关于一个经济决策进行“数学期望”的计算启示了这种推理方式——你用产出的概率乘以产出本身的价值。理性的选择一定是那个计算结果给出最高期望值的决策。帕斯卡的赌博经常被引用作最早的基于数学方法的决策论的例子。
批注：期望的分布。
在真实生活中，当然，人们不会总是简单地通过这种计算来做决定。并且当你的最佳决策依赖于他人是如何决策的时候，简单的决策论就不管用了——做出最佳决策便成为博弈论的一个问题（一些专家认为，决策论仅仅是博弈论的一个特例，因为在决策论中是一个参与者和自然在博弈）。而且，概率和预期收益仍然以深远且复杂的方式与博弈论有着千丝万缕的联系。由于这个缘故，所有的科学都和概率论有着深层次的缠结——整个观察、实验和测量过程，以及其后将这些数据和理论进行比较都是必需的。而且概率不仅发生在测量和假设检验中，也会发生在对物理现象的精确描述中，尤其是在统计物理学的范畴中。
在社会科学中，当然，概率论也是不可或缺的，就像阿道夫·凯特勒在大约两百年前说的一样。因此，我敢打赌，博弈论和概率的密切联系是博弈论之所以被广泛地应用在这么多不同科学领域的原因。并且，毫无疑问，正是博弈论的这个方面使其居于一个如此战略性的位置，作为一种原动力促使社会学与统计物理学融合形成社会物理学——有些像阿西莫夫的心理史学或自然法典。
到目前为止，策划运用社会物理学来描述社会的尝试绝大多数并不以博弈论为基础，而是以统计物理学为基础的（如阿西莫夫的小说的心理史学）。但是博弈论中混合策略/概率方程式表现出其与统计物理学中概率分布的惊人相似。事实上，为达到纳什均衡的博弈参与者所使用的混合策略正是概率分布，准确地说，正如统计物理学里定量表示气体中分子的分布情况。这个认识推出了一个非凡的结论——即，从某种意义上说，博弈论和统计物理学是互相的他我。意即，它们能够用相同的数学语言来表述。更确切地说，你不得不承认博弈论中某些模型与统计物理学中一些特殊公式在数学上是一致的，且其中还存在深层次的内在联系。只不过，几乎很少人意识到这一点。
统计学和博弈 博弈涉及的是参与者；物理学涉及的是分子。于是沃尔波特就研究能够体现参与者策略的数学方法，就像物理学中体现分子动态一样。所有参与者策略的混合体就像统计物理学中通常描述的所有原子动态的集合。他提出的公式，在给定对参与者的有限了解的情况下，可允许你计算出在博弈中任何个体参与者策略的真实集合的接近的近似值。你可以用同样的方法来计算出所有博弈参与者的混合策略。基本上，沃尔波特展示了统计物理学中的数学方法如何最终与有着有限理性参与者的博弈中所使用的数学方法是相同的。“那些论题根本上是同一的，”他在他的文章中写道，“这个证明增加了将一些统计物理学中已发展得很强大的数学技术转移到分析非合作博弈理论中的潜能。”
沃尔波特的数学图谋植根于“最大熵”理论（maximum entropy，或者叫“maxent”），一个联系标准统计物理学与信息理论的原理，用于量化发送与收到讯息的数学。最大熵的理论是由特立独行的物理学家艾德文·杰尼斯(Edwin Jaynes)在他于1957年发表的文章中创立的，此理论被很多物理学家所接受，但同时也被其他很多物理学家所忽视。当时，沃尔波特称杰尼斯的工作“多么光辉而美丽”，并且认为这才是科学家们必须为了“将博弈论带入21世纪”所需的东西。
杰尼斯原理吸引人的同时也使人产生挫败感。它看起来本质上简单，然而却隐含着错综复杂的关系。它与物理概念——熵有着紧密的联系，但仍有着细微的不同。无论如何，它的解释需要对概率论与信息理论的本质进行简要的探寻，也就是将博弈论与统计物理学结合到一起的本质联系。
概率和信息 几个世纪以来，科学家与数学家都在争论概率的含义。即便今天，仍然存在着不同学派的概率思想，通常简单表示为“客观派”与“主观派”。但是那些标签隐藏了次论据与技术上的细微的差别，使概率论成为一个数学与自然科学中最充满争议和困惑的领域。
多少有点令人吃惊，概率论的确是基于自然科学的基础，扮演着分析实验数据和理论检验过程中的核心角色。这就是科学所要做的一切。你会认为到如今他们已把问题全部解决。但是，建立科学的秩序有些类似为伊拉克建立一套宪法。研究科学的原理和方法纷繁复杂。事实上，科学（不像数学）不是建立在不可约规则的坚实基础上的。科学就像语法。语法是由使用该语言的本族人在创造词汇和联系词汇时发展出来的规律。一个真正的语法学家不会告诉人们他们应该怎么说，而是整理出人们实际上是如何说的。科学并不是烹调书，提供揭露自然奥秘的菜谱；科学源于方法的集合，成功诠释自然。这就是为什么科学不完全是实验，也不完全是理论，而是两者相互影响的复合体。不过，归根结底，理论和实验必须紧密结合在一起，如果科学家对于自然的构想是有意义且有用的。那么在大多数科学领域里你需要数学来验证它们的结合。概率论就是实施检验的工具（对于如何实施检验的不同想法会导致不同的概率概念）。
在麦克斯韦之前，科学中的概率论主要局限于定量计算诸如测量错误等情况。拉普拉斯和其他学者展示了一种方法来评估在一个确切的置信度下，你的测量值和真实值之间相差多远。拉普拉斯自己运用此方法测量了土星的质量，并推断出真实的土星质量会偏离当前的测量值超过1%的情况只有一万一千分之一(1/11000)的发生概率（而结果是，当今最好的测量方法与拉普拉斯时代最好的方法精确度只相差0.6%）。概率论已经发展成为一个进行评估的相当精确的方法。
然而，概率本身究竟意味着什么？如果你问那些应该懂的人，你会得到不同的答案。客观主义派坚持认为，一个事件发生的概率是该事件本身的性质。你观察所有情况中事件发生的片断，并籍此测量出它的客观概率。另一方面，主观派的观点认为，概率是一种对于某事件可能会怎么发生的信念。主观派主张测量某事件多久发生一次得到一个频率，而非概率。探究这两种论点相对优劣性的辩论并无意义。一些书籍却致力于这些争论，这与博弈论相当无关。事实是，今天流行的观点，至少是在物理学家中，是主观派方法包含了对科学数据进行合理评估的要素。
主观派统计学经常臣服在贝叶斯的名下。托马斯·贝叶斯是一名英国牧师，于1763年（在他去世后两年）发表的一篇文章中探讨了研究自然的方法。今天被人们熟知的贝叶斯定律的公式就是实践主观派统计学方法的核心之所在（尽管精确的定律实际上是拉普拉斯创立的）。无论如何，贝叶斯的观点在今天都被发扬光大，而且也有很多关于它应该如何被理解和应用的争论（也许是因为，毕竟它是主观的）。但是，从实践的观点来看，客观派和主观派概率论的数学方法在任何基础层面上并没有实质性的区别，只是在理解上有差异。正如杰尼斯在半个世纪前指出的，只是在一些情况下使用其中一种而非另一种是因为感觉方便，或更合适些。
信息和无知 在他1957年的文章中，杰尼斯在概率的辩论中支持了主观派的观点。他认为，这两种观点，主观派和客观派，物理学都需要，但是对于一些类型的问题只有主观派方法能解决。
他争辩道，即便当你对感兴趣的体系一无所知、无从下手的时候，主观派的方法仍然适用。如果给你一个装满了微粒的盒子，而你对它们毫不知情——不知道它们的质量，不知道它们的组成，也不知道它们的内部结构——你对它们的状态也不甚了解。你知道很多物理定律，但是你不知道对于这个体系该使用哪个定律。换言之，你对于这些微粒的状态的无知已经到达了顶点。创立概率论的早期开拓者，如雅格布·伯努利和拉普拉斯，认为，在这种情况下，你必须简单地假设所有的可能性出现的概率是相同的——直到你有理由去做不同的假设。那么，这也许有助于计算，但是假设所有可能性出现概率相同有确实的（理论）基础吗？除了些可以肯定的情况，很明显两种可能性发生概率相同（像硬币有两面一样完美的平衡），杰尼斯说，很多其他的假设可能被同样证明是合理的（或者如他惯称的，任何其他的假设都是同样主观的）。
批注：其实就是为这种想法提供理论基础吧。
然而，借助了在当时来说相当新的信息理论，杰尼斯发现了一种应对这种情形的方法，那个理论正是贝尔实验室的克劳德·夏农(Claude Shannon)创立的。夏农对如何量化通信很感兴趣，特别是发送信息；通过这种定量方式可以帮助工程师们找到使通信更有效率的办法（毕竟，他供职于一家电信公司）。他发现如果你将通信视作对不确定性的降低过程，那么数学方法就可以很精确地量化信息。在通信开始前，收到任何信息都是可能的，因此不确定性很高；当信息确实被接收后，不确定性就降低了。
夏农将这种数学方法广泛应用到任何一个信号传导系统中，从摩斯密码到烟雾信号。但是假设，例如你所想要做的就是发送给某人一条单字信息（这个字是从一本标准未删节的字典里选出的，大概字典里收录了50万字）。如果你告诉接收者这个信息中的单字来自该字典的前半部分，那么你就将这个字出现的可能性从50万字减少到了25万字。换言之，你将不确定性减半（这碰巧与一比特信息相符）。基于信息降低不确定性的想法，夏农通过它来展示如何量化所有的通信。他发现了一个精确衡量不确定性的量的公式——不确定性越大，量就越大。夏农称其为熵，一个有意与统计物理学及热力学里使用的物理专业术语熵类似的概念。
物理学家使用的熵是用来度量物理体系混乱度。假设你有一个房间，里面包括分隔开的两个隔间，而且你在左边的隔间里放了100亿个氧分子，而在右边隔间里放了400亿的氮分子。然后你移除隔间之间的分隔物。这些分子就会全部迅速混合到一起——更加无序——所以这个体系的熵就增加了。但是其他一些事也会随之发生——你不再知道这些分子在哪了。你对它们位置的无知随着熵的增大而增加。夏农展示出他计算通信中熵的公式——作为对无知或不确定性的量度——和统计物理学中描述微粒集合体中增加熵的公式完全如出一辙。熵，换言之，与无知几乎等同。熵也是不确定性的同义词。信息理论提供了一种在概率分布中计算不确定性的新的精确的方法。
因此，当你对于你要研究的体系中的概率一无所知的时候，这里有一条线索指引你该如何去做。选择一个使熵值最大的概率分布！最大熵意味着最大的无知，而且如果你什么都不知道，无知就被限定为最大。假设出最大熵/无知不仅仅是假设；它是对你所处情况的真实陈述。杰尼斯提出，这个最大无知的概念应该被提升到作为科学地描述任何事物的基本准则的层面。以他的观点，统计物理学本身便成为对于一个体系进行统计推论的系统。通过使用最大熵的方法，你仍可以使用所有统计物理学提供的计算规则，而无需在基本物理学方面假设任何前提。特别地，你现在能够证明这个观念，即所有的可能性出现的概率都是等同的。整体思想为，没有任何一种概率（只要是遵守物理定律的）会被排除。你所获得的信息中没有被明确排除的任何情况都将被视为存在发生的可能（在标准的统计物理学中，这种特征是无需证据而简单地被假设出的——整体的概率分布基于所有的分子均遵循各自的可能运动状态的概念）。而且，如果你一无所知，你不能说任何一个概率相较于另一个概率更可能出现——这是常识。当然，如果你了解一些关于概率的知识，你可以将其融入你使用的概率分布去预测将来的未知。但是如果你对此一无所知，那供你用来预测将来的未知的就只剩一种概率分布了：这就是最大熵、最大不确定性、最大无知。毕竟，这种做法还是有意义的，因为一无所知，事实上，即最大无知。
听起来有些神奇，即使对面前的物体或人一无所知，你仍然可能做出预测。当然，你的预测可能不一定正确。但是，那仍然是当你不知从何做起时，你所能做的最好预测，你所能找寻的最近似的答案。“概率分布将受制于某些限制的熵最大化，这成为解释分布推理使用的关键，”杰尼斯写道，“无论结果是否符合实验，它们仍然代表基于可用信息所能做的最佳预估。”
但是“熵的最大化”确切的含义是什么呢？简单的解释是，选择那些源于一切符合自然法则的可能性集合中的概率分布（既然你一无所知，你也就不能丢下任何可能的情况）。这里有一个简单的例子。
假设你想预测一个有100名学生的班级所有人的平均成绩。你所知道的只有一般规则（即，自然法则）——每人都会得到一个成绩，且成绩被定为A、B、C、D或F（不允许任何未评）。你对学生的水平和努力程度一无所知。那么你对班里孩子们平均成绩的最好预测是什么呢？换言之，你如何找到一个成绩的概率分布来告诉你哪个平均成绩最有可能是真实的？运用最大熵或最大无知原理，你简单假设成绩能分布的所有可能情况——所有可能组合出现的概率均等。例如，一种可能的分布是100个A而没有别的情况出现。另一种可能是全部的F。也可能是每种成绩都分别由20人获得。也可能是50个C、20个B、20个D、5个A和5个F。所有的组合情况全部加和到一起成为一个概率的集合，该集合由符合最大无知原理——对于班级以及学生和学生成绩的完全无知的所有概率分布组成。
在统计物理学里，这种情况被称之为“典范系综”——系统中分子的所有可能状态的集合。每一种组合都是一个微观状态。许多不同可能的微观状态（成绩的分布）与相同的平均值（宏观状态）一致。不要试图列出所有可能的组合，那会消耗你大量的时间（你所涉及的数字可能大得接近10的70次方级别）。但是你能计算出，或者甚至可以凭直觉看出，最有可能的平均成绩就是C。在所有可能的微观状态组合中，出现平均成绩为C的概率比任何其他成绩的概率都要大很多。例如，只有一种情况下能得到完美的平均成绩为A——所有的100个学生都得到A。但是你得到平均成绩是C的情况却有很多——100个C、50个A和50个F，5个级别的成绩各有20人得到，等等。
就像扔硬币，一次扔4枚硬币，头像朝上的硬币数量相对于上例中的成绩（0就是F，4就是A）。在100次试验中，许多组合的平均值为2，而只有很少的情况平均值为0或4。因此，基于一无所知，你的预测为平均成绩是C。
博弈论与概率分布 过去科学家们没有真正将博弈参与者们当作统计物理学中的微粒来考虑，至少没有从正确的角度去考虑。如果你真的考虑过这一点，你就会意识到没有一个物理学家在计算气体热力学性质时考虑单个分子的状态。这个观点是为了计算出整个分子集合体的全面特征。你不可能知道单个分子在干什么，但是你能够统计计算出结合在一起的所有分子的宏观表现。博弈和气体之间的联系应该很清楚了。统计物理学研究气体，并不知道单个分子的活动，而博弈论学家同样不知道单个参与者是如何思考的。但是物理学家确实知道分子集合体的表现可能是怎样的——统计学意义上的——并且能针对气体的性质给出较好的预测。类似地，博弈论学家应该能对博弈中将会发生的事件作出统计学预测。
正如沃尔波特反复强调的，这就是科学通常的处理方式。科学家们对他们研究的体系相关的信息进行限制，并试着基于他们手上已有的信息做出可能的最优预测。就像一场博弈中的一个参与者仅仅对这个博弈中可能出现的策略组合持有不完整信息，那么科学家们就研究在拥有不完整信息情况下的博弈，信息包括参与者们都知道些什么以及他们是如何思考的（切记，不同的个人在博弈时使用的思路是不同的）。
所有的科学都面对这种问题——对于一个体系知道一些情况，然后就根据这有限的知识，试图去预测将会发生什么，沃尔波特指出。“那么科学将如何着手来回答这些问题呢？在你所致力研究的每个独立的科学领域中，这种尝试的结果将是一个概率分布。”
从这一点看，概率论就引进了另一种混合策略。不仅仅是参与者持有混合策略，备选的可行概率分布也会变化。科学家描述博弈持有一种“混合策略”，那就是对于博弈结果的可行预测。“当你想到这个的时候，觉得显而易见，”沃尔波特说，“如果给你一场真人参加的博弈，不，你就不会总是得到同一种结果。你会得到不止一种可能出现的结果……他们不可能总是以完全一样的那套混合策略去结束博弈。对于他们使用的混合策略会出现一个分布现象，就像在其他科学问题中一样”。
……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c311636d227bdb85915dde3dec56d1a/" rel="bookmark">
			Python数据分析教程（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 1、为什么选择Python进行数据分析? Python是一门动态的、面向对象的脚本语言，同时也是一门简约，通俗易懂的编程语言。Python入门简单，代码可读性强，一段好的Python代码，阅读起来像是在读一篇外语文章。Python这种特性称为 伪代码 ，它可以使你只关心完成什么样的工作任务，而不是纠结于Python的语法。
另外，Python是开源的，它拥有非常多优秀的库，可以用于数据分析及其他领域。更重要的是，Python与开源大数据平台Hadoop具有很好的兼容性。因此，学习Python对于有志于向大数据分析岗位发展的数据分析师来说，是一件非常节省学习成本的事。
Python的众多优点让它成为受欢迎的程序设计语言之一，国内外许多公司也已经在使用Python，例YouTube，Google，阿里云等等。
2、编程基础 要学习如何用Python进行数据分析， 笔者建议第一步是要了解一些Python的编程基础，知道Python的数据结构，什么是向量、列表、数组、字典等等；了解Python的各种函数及模块。下图整理了这一阶段要掌握的知识点：
3、数据分析流程 Python是数据分析利器，掌握了Python的编程基础后，就可以逐渐进入数据分析的奇妙世界。笔者认为一个完整的数据分析项目大致可分为以下五个流程：
1. 数据获取
一般有数据分析师岗位需求的公司都会有自己的数据库，数据分析师可以通过SQL查询语句来获取数据库中想要数据。Python已经具有连接sql server、mysql、orcale等主流数据库的接口包，比如pymssql、pymysql、cx_Oracle等。
而获取外部数据主要有两种获取方式，一种是获取国内一些网站上公开的数据资料；一种是通过编写爬虫代码自动爬取数据。如果希望使用Python爬虫来获取数据，我们可以使用以下Python工具：
Requests-主要用于爬取数据时发出请求操作。
BeautifulSoup-用于爬取数据时读取XML和HTML类型的数据，解析为对象进而处理。
Scapy-一个处理交互式数据的包，可以解码大部分网络协议的数据包
2. 数据存储
对于数据量不大的项目，可以使用excel来进行存储和处理，但对于数据量过万的项目，使用数据库来存储与管理会更高效便捷。
3. 数据预处理
数据预处理也称数据清洗。大多数情况下，我们拿到手的数据是格式不一致，存在异常值、缺失值等问题的，而不同项目数据预处理步骤的方法也不一样。笔者认为数据分析有80%的工作都在处理数据。如果选择Python作为数据清洗的工具的话，我们可以使用Numpy和Pandas这两个工具库：
Numpy- 用于Python中的科学计算。它非常适用于与线性代数，傅里叶变换和随机数相关的运算。它可以很好地处理多维数据，并兼容各种数据库。
Pandas–Pandas是基于Numpy扩展而来的，可以提供一系列函数来处理数据结构和运算，如时间序列等。
4. 建模与分析
这一阶段首先要清楚数据的结构，结合项目需求来选取模型。
常见的数据挖掘模型有：
在这一阶段，Python也具有很好的工具库支持我们的建模工作：
scikit-learn-适用Python实现的机器学习算法库。scikit-learn可以实现数据预处理、分类、回归、降维、模型选择等常用的机器学习算法。
Tensorflow-适用于深度学习且数据处理需求不高的项目。这类项目往往数据量较大，且最终需要的精度更高。
5. 可视化分析
数据分析最后一步是撰写数据分析报告，这也是数据可视化的一个过程。在数据可视化方面，Python目前主流的可视化工具有：
Matplotlib-主要用于二维绘图，它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。
Seaborn-是基于matplotlib产生的一个模块，专攻于统计可视化，可以和Pandas进行无缝连接。
按照这个流程，每个阶段所涉及的知识点可以细分如下：
从上图我们也可以得知，在整个数据分析流程，无论是数据提取、数据预处理、数据建模和分析，还是数据可视化，Python目前已经可以很好地支持我们的数据分析工作。
-END-
读者福利：如果大家对Python感兴趣，这套python学习资料一定对你有用
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以根据这些资料规划好学习计划和方向。
包括：Python激活码+安装包、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习、Python量化交易等习教程。带你从零基础系统性的学好Python！
零基础Python学习资源介绍 ① Python所有方向的学习路线图，清楚各个方向要学什么东西
② 600多节Python课程视频，涵盖必备基础、爬虫和数据分析
③ 100多个Python实战案例，含50个超大型项目详解，学习不再是只会理论
④ 20款主流手游迫解 爬虫手游逆行迫解教程包
⑤ 爬虫与反爬虫攻防教程包，含15个大型网站迫解
⑥ 爬虫APP逆向实战教程包，含45项绝密技术详解
⑦ 超300本Python电子好书，从入门到高阶应有尽有
⑧ 华为出品独家Python漫画教程，手机也能学习
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c311636d227bdb85915dde3dec56d1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316d3c37799f90c4cf017c4025b1aa4b/" rel="bookmark">
			密码学的100个基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密码学作为信息安全的基础，极为重要,本文分为上下两部分，总计10个章节，回顾了密码学的100个基本概念，供小伙伴们学习参考。本文将先介绍前五个章节的内容。
一、密码学历史
二、密码学基础
三、分组密码
四、序列密码
五、哈希函数
一、密码学历史 1.密码学
密码学（cryptography）源于希腊语kryptós“隐藏的”和gráphein“书写”，是研究信息安全保密的学科，涉及密码编码与密码分析。
2.古典密码
古典密码主要采用代换（Substitution）和置换（Permutation）的方式，并通过手工或简单器械实现，其使用阶段从古代到19世纪末，长达上千年，包括棋盘密码、凯撒密码等。
3.凯撒密码
凯撒密码是罗马皇帝朱利尤斯·凯撒(Julius Caesar)在公元前约50年发明的一种用于战时秘密通信的方法。凯撒密码将字母按字母表的顺序构成一个字母序列链，然后将最后一个字母与第一个字母相连成环，加密方法是将明文中的每个字母用其后的第个字母代替。
4.近代密码
近代密码一般指20世纪初到20世纪50年代，通过机械或电动设备实现的加密方式，虽然技术上有了很大进步，但加密仍然依靠替代及置换的方式，包括单表代换密码（如仿射密码）、多表代换密码（如Vigenère密码和Hill密码等）。
5.现代密码
1949年香农发表《保密系统的通信理论》（Communication Theory of Secrecy System），标志着现代密码学的开端。香农将信息论引入到密码学研究中，利用概率统计的观点和熵的概念对信息源、密钥源、传输的密文和密码系统的安全性进行了数学描述和定量分析，并提出了对称码体制的模型，为现代密码学奠定了数学基础，这是密码学的第一次飞跃。
1976年，Diffie和Hellman发表的经典论文《密码学的新方向》（New Directions in Cryptography）提出了公钥密码体制思想，为现代密码学的发展开辟了崭新的方向，带来了密码学的第二次飞跃。
二、密码学基础 6.中断
中断(Interruption)也称拒绝服务，是指阻止或禁止通信设施的正常使用或管理，这是对可用性攻击。这种攻击一般有两种形式:一是攻击者删除通过某一连接的所有协议数据单元，从而抑制所有的消息指向某个特殊的目的地;二是使整个网络瘫痪或崩溃，可能采取的手段是滥发消息使之过载，使网络不能正常工作。
7.截取
截取(Interception)是未授权地窃听或监测传输的消息，从而获得对某个资源的访问，这是对机密性的攻击。攻击者一般通过在网络中“搭线”窃听，以获取他们通信的内容。
8.篡改
篡改(Modification)也就是修改数据流，对一个合法消息的某些部分被改变、消息被延迟或改变顺序，以产生一个未授权、有特殊目的的消息，是针对连接的协议数据单元的真实性、完整性和有序性的攻击。
9.伪造
伪造(Fabrication)是指将一个非法实体假装成一个合法的实体，是对身份真实性的攻击，通常与其他主动攻击形式结合在一起才具有攻击效果，如攻击者重放以前合法连接初始化序列的记录，从而获得自己本身没有的某些特权。
10.重放
重放(Replay)将一个数据单元截获后进行重传，产生一个未授权的消息。在这种攻击中，攻击者记录下某次通信会话，然后在以后某个时刻重放整个会话或其中的一部分。
11.机密性
机密性(Confidentiality)是指保证信息不泄露给非授权的用户或实体，确保存储的信息和被传输的信息仅能被授权的各方得到，而非授权用户即使得到信息也无法知晓信息内容。通常通过访问控制阻止非授权用户获得机密信息，通过加密阻止非授权用户获知信息内容。
12.完整性
完整性(Integrity)是指信息未经授权不能进行篡改的特征，确保信息的一致性，即信息在生成、传输、存储和使用过程中不应发生人为或非人为的非授权篡改(插人、修改、删除、重排序等)。一般通过访问控制阻止篡改行为，同时通过消息摘要算法来检验。
13.认证性
认证性(Authentication)，或称真实性，指确保一个消息的来源或消息本身被正确地标识，同时确保该标识没有被伪造，通过数字签名、消息认证码（MAC）等方式实现。认证分为消息认证和实体认证。
消息认证是指能向接收方保证该消息确实来自于它所宣称的源，
实体认证是指在连接发起时能确保这两个实体是可信的，即每个实体确实是它们宣称的那个实体，第三方也不能假冒这两个合法方中的任何一方。
14.不可否认性
不可否认性(Non-Repudiation)是指能保障用户无法在事后否认曾经对信息进行的生成、签发、接收等行为，是针对通信各方信息真实性、一致性的安全要求。为了防止发送方或接收方抵赖所传输的消息，要求发送方和接收方都不能抵赖所进行的行为。通过数字签名来提供抗否认服务。
当发送一个消息时，接收方能证实该消息确实是由既定的发送方发来的，称为源不可否认性
当接收方收到一个消息时，发送方能够证实该消息确实已经送到了指定的接收方，称为宿不可否认性。
15.可用性
可用性(Availability)是指保障信息资源随时可提供服务的能力特性，即授权用户根据需要可以防时访问所需信息，保证合法用户对信息资源的使用不被非法拒绝。
16.密码系统
一个密码系统（体制）至少由明文、密文、加密算法和解密算法、密钥五部分组成。
17.明文
信息的原始形式成为明文（Plaintext）。
18.密文
经过变换加密的明文称为密文（Ciphertext)。
19.加密
对明文进行编码生成密文的过程称为加密（Encryption）， 编码的规则称为加密算法。
20.解密
将密文恢复出明文的过程称为解密（Decryption），解密的规则称为解密算法。
21.密钥
密钥（Key）是唯一能控制明文与密文之间变换的关键，分为加密密钥和解密密钥。
22.柯克霍夫假设
柯克霍夫假设(Kerckhoffs Assumption)，又称柯克霍夫原则(KerckhoffsPrinciple)或柯克霍夫公理(Kerckhoffs Axiom)是荷兰密码学家奥古斯特·柯克霍夫(Auguste Kerckhoffs)于1883年在其名著《军事密码学》中阐明的关于密码分析的一个基本假设：密码系统的安全性不应取决于不易改变的算法，而应取决于可随时改变的密钥，这就是设计和使用密码系统时必须遵守的。即加密和解密算法的安全性取决于密钥的安全性，而加密/解密的算法是公开的，只要密钥是安全的，则攻击者就无法推导出明文。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316d3c37799f90c4cf017c4025b1aa4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b7c8d413d6b2cf63ae16dcc68f19641/" rel="bookmark">
			「优选算法刷题」：四数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
0 &lt;= a, b, c, d &lt; na、b、c 和 d 互不相同nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。
示例 1：
输入：nums = [1,0,-1,0,-2,2], target = 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2：
输入：nums = [2,2,2,2,2], target = 8 输出：[[2,2,2,2]] 二、思路解析 这道题是 “三数之和” 的进阶版，本题的改动仅是一些细节部分。
所以，具体算法在👇，相比起三数之和多了一个数要固定而已
更详细的解答步骤请移步：
「优选算法刷题」：三数之和http://t.csdnimg.cn/8ip5t
三、完整代码 class Solution { public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b7c8d413d6b2cf63ae16dcc68f19641/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/285ac9eac272e62b044e9abe5dd3e307/" rel="bookmark">
			安装miniconda、tensorflow、libcudnn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
安装miniconda 安装tensorflow
安装 libcudnn 安装miniconda wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh &amp;&amp; bash Miniconda3-latest-Linux-x86_64.sh 安装tensorflow tensorflow官网，查看版本对应
https://tensorflow.google.cn/install?hl=en
pip install tensorflow-gpu==2.9.0 -i https://pypi.tuna.tsinghua.edu.cn/simple 使用 print(tf.config.list_physical_devices('GPU')) 查看GPU时报错 2024-01-23 14:37:14.298095: W tensorflow/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library 'libcudnn.so.8'; dlerror: libcudnn.so.8: cannot open shared object file: No such file or directory; LD_LIBRARY_PATH: /usr/local/cuda-11.7/lib64:/usr/local/cuda-11.7/lib64:/usr/local/cuda-11.7/lib64
2024-01-23 14:37:14.298127: W tensorflow/core/common_runtime/gpu/gpu_device.cc:1850] Cannot dlopen some GPU libraries. Please make sure the missing libraries mentioned above are installed properly if you would like to use GPU.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/285ac9eac272e62b044e9abe5dd3e307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8a5a4577384fbc4e5e8908c6a8fe9ff/" rel="bookmark">
			Vue3水印（Watermark）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		APIs 参数说明类型默认值必传width水印的宽度，默认值为 content 自身的宽度numberundefinedfalseheight水印的高度，默认值为 content 自身的高度numberundefinedfalselayout水印的布局方式：平行布局 parallel; 交替布局 alternate‘parallel’ | ‘alternate’‘alternate’falserotate水印绘制时，旋转的角度，单位 °number-22falsezIndex追加的水印元素的 z-indexnumber9falseimage图片源，建议使用 2 倍或 3 倍图，优先级高于文字stringundefinedfalsecontent水印文字内容string | string[]‘’falsefullscreen是否展示全屏booleanfalsefalsecolor字体颜色string‘rgba(0,0,0,.15)’falsefontSize字体大小，单位pxnumber16falsefontWeight字体粗细‘normal’ | ‘light’ | ‘weight’ | number‘normal’falsefontFamily字体类型string‘sans-serif’falsefontStyle字体样式‘none’ | ‘normal’ | ‘italic’ | ‘oblique’‘normal’falsegap水印之间的间距[number, number][100, 100]falseoffset水印距离容器左上角的偏移量，默认为 gap/2[number, number][50, 50]false 效果如下图：在线预览 创建水印组件Watermark.vue &lt;script setup lang="ts"&gt; import { unref, shallowRef, computed, watch, onMounted, onBeforeUnmount } from 'vue' import type { CSSProperties } from 'vue' interface Props { width?: number // 水印的宽度，默认值为 content 自身的宽度 height?: number // 水印的高度，默认值为 content 自身的高度 layout?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8a5a4577384fbc4e5e8908c6a8fe9ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb86b3a39958249a7882c4c45ff62d1/" rel="bookmark">
			VS2019的安装和使用（也附2022链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载，安装 （1）下载
在浏览器上搜索Visual Studio
点击进入后，你会发现只有2022版本的
但会用起来不够稳定，所以在上方搜索栏搜索Visual Studio2019
搜索后点击以下按钮，点击后
附VS2019链接：Visual Studio 较旧的下载 - 2019、2017、2015 和以前的版本 选择这个版本，是免费个人版（Visual Studio Community 2019） VS2022版本链接: Downloads &amp; Keys - Visual Studio Subscriptions 需登录微软账号
我这里是有账号了，没账号需要进行注册
2022版本在官网下载方法相同（以下方法是相似的）
点击下载后，登录，登录完成后，下载安装
（2）安装，打开Visual Studio installer
勾选上.Net桌面开发，这是我右边勾选的东西
如果后续想使用VS进行unity开发的话，勾选上unity的游戏开发
如果是虚幻开发，那么需要多勾选两个，Unreal Engine安装程序和适用于Unreal引擎的Android IDE支持，如图：
下方位置可对存放位置进行更改，最好不要存储在c盘，这是我的存储路径
以上处理完毕后，点击右下角修改
等待完成
2.使用 安装完成后，可在搜索栏搜索visual
点击打开
点击创建新项目，进入后，选择C#，看清后面是Windows和所有项目类型
选择控制台应用程序后，点击下一步
点击三个点，更改存储位置
不建议放在c盘，虽然读取更快，但容易让电脑速度变慢，可在d盘或e盘新建文件夹存放
更改名称，我更改的为Hello
以上操作完成后，点击下一步，随后点击创建
系统会自动生成一段代码
点击绿色三角或按F5可运行程序
第一个程序运行完成
3.小结 用了VS这么多年，却没有去写过一个自己的总结，今天开始想对自己所学知识进行一个梳理,如果有遇到不对的地方，望指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fdf841b38fd038908cc4cdd16053fc6/" rel="bookmark">
			「优选算法刷题」：长度最小的子数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
示例 1：
输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2：
输入：target = 4, nums = [1,4,4] 输出：1 示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 二、思路解析 这道题也是一道很经典的 “滑动窗口” 例题，需要利用单调性，使用 “同向双指针” 来对暴力解法 「会超时」进行优化，以让时间复杂度达到要求。
但是，为何使用滑动窗口呢？
回到我们的分析对象，是「⼀段连续的区间」，我就是根据这个条件去判别的。
让滑动窗⼝满⾜：从 i 位置开始，窗⼝内所有元素的和⼩于 target （那么当窗⼝内元素之和
第⼀次⼤于等于⽬标值的时候，就是 i 位置开始，满⾜条件的最⼩⻓度）。
具体做法是，将右端元素划⼊窗⼝中，统计出此时窗⼝内元素的和：
▪ 如果窗⼝内元素之和⼤于等于? target ：更新结果，并且将左端元素划出去的同时继续判
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fdf841b38fd038908cc4cdd16053fc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c7f7dc234edab3ec0a93f92a8e1f11/" rel="bookmark">
			vue 视频上传组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件：
&lt;template&gt; &lt;div class="upload-box"&gt; &lt;div class="avatar-uploader-box"&gt; &lt;!-- 图片预览 --&gt; &lt;div :key="index" class="video-preview" v-for="(item, index) in videoList"&gt; &lt;video v-if="item.videoLink" :src="`${videoBaseUrl}${item.videoLink}`" @mouseover.stop="item.isShowPopup = true" class="avatar"&gt; 您的浏览器不支持视频播放 &lt;/video&gt; &lt;video v-else :src="item.url" @mouseover.stop="item.isShowPopup = true" class="avatar"&gt; 您的浏览器不支持视频播放 &lt;/video&gt; &lt;!-- 显示查看和删除的按钮弹窗 --&gt; &lt;div @mouseleave="item.isShowPopup = false" class="avatar-uploader-popup" v-show="(item.videoLink || item.url) &amp;&amp; item.isShowPopup" &gt; &lt;i @click="previewVideo(item)" class="el-icon-zoom-in"&gt;&lt;/i&gt; &lt;i @click="deleteVideo(index)" class="el-icon-delete"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 方框样式 --&gt; &lt;el-upload :action="actionUrl" :auto-upload="false" :on-change="handleAvatarChange" :show-file-list="false" class="avatar-uploader" ref="avatarUploader" v-show="uploadShow" &gt; &lt;span element-loading-background="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25c7f7dc234edab3ec0a93f92a8e1f11/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/19/">«</a>
	<span class="pagination__item pagination__item--current">20/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/21/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>