<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685a594113f8db9f24b4fe886d522d0c/" rel="bookmark">
			node基础 fs(文件系统模块)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node.js 引入fs模块
const fs = require('fs') 1. fs.stat() 检测是文件还是目录 语法格式：fs.stat(path, callback)
stat 参数说明：
第一个path是文件路径第二个callback是回调函数，fs.stat(path)执行后，会将stats类的实例返回给其回调函数，例子中分别使用 isFile 和 isDirectory 来判断当前操作的是文件还是目录，取值为 true 和 false const fs = require('fs') //判断 ./test/text.txt 是文件还是目录 fs.stat('./test/text.txt', (err, dataStr) =&gt; { if (err) { return console.log('获取失败:'+ err.message) } console.log(`是文件:${dataStr.isFile()}`) console.log(`是目录:${dataStr.isDirectory()}`) }) 2. fs.writeFile 写入文件 (若该文件已存在则会覆盖该文件) 语法格式: fs.writeFile(file, data[, options], callback)
writeFile 参数说明：
file 文件名或文件描述符data 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象options 是一个对象，包含以下参数 encoding(String | null) 默认值 utf8mode 默认值 0666flag 默认值 wcallback 回调函数，返回错误信息参数(err) const fs = require('fs') // 写入文件 fs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/685a594113f8db9f24b4fe886d522d0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6742c327991821fa1cd805fce94fed8e/" rel="bookmark">
			Vue | vuex安装失败解决的方法实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vuex是一个专为Vue.js应用程序开发的状态管理模式
下面这篇文章主要给大家介绍了关于vuex安装失败解决的方法,文中通过图文介绍的非常详细,需要的朋友可以参考下
1、报错信息： npm ERR! code ERESOLVE npm ERR! ERESOLVE unable to resolve dependency tree npm ERR! npm ERR! While resolving: vue-base-rooter@0.1.0 npm ERR! Found: vue@2.6.14 npm ERR! node_modules/vue npm ERR! vue@"^2.6.11" from the root project npm ERR! npm ERR! Could not resolve dependency: npm ERR! peer vue@"^3.0.2" from vuex@4.0.2 npm ERR! node_modules/vuex npm ERR! npm ERR! Fix the upstream dependency conflict, or retry npm ERR! this command with --force, or --legacy-peer-deps npm ERR!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6742c327991821fa1cd805fce94fed8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10176c0cbb19d0eb9502fbe5fb59d7d4/" rel="bookmark">
			WPS表格Excel：截取中间内容、截取两符号之间内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPS表格Excel：截取中间内容、截取两符号之间内容 原始数据和目标 观察得知：我们需要截取冒号和右中括号之间的内容
方法一：WPS智能填充（一次性方式） 先给wps举个例子
选中需要填充的区域Ctrl+E
这种方式没有复用性，数据过于复杂时需要多给wps举几个例子才可以取数据取得相对准确
方法二：使用MID()公式 MID公式的格式和参数可以理解为从那个字符串里截取，从哪开始截取，往后截取几个字符
从哪个字符串里截取肯定是从原始数据中截取喽
从哪开始截取
这里我们需要从“：”后开始截取，为了获取到“：”的位置，我们需要用到第二个公式FIND()
要查找的字符串是“：”，被查找的字符串是原始数据，开始位置是用中括号包起来的可以不写，默认从第一个字符开始
取到冒号的位置后我们还需要+1，因为是从冒号后边的一个字符开始截取的
截取几个字符
我们可以看到我们需要得到的内容的字数不是一个固定值，也是需要计算才可以得到
这个字数经过观察可知：字数= 原始数据字符串的长度-冒号的位置-1
这里我们用LEN这个公式来获取原始数据字符串的长度
冒号的位置同样用FIND获取
所有参数都有了之后我们别忘了加后括号，WPS在输入公式时经常会丢失后括号，所以需要我们手动补一下
公式输入完成后我们回车，然后下拉就可以了，公式的话可以重复利用，原始数据改变，公式取值也会随着变。
公式=MID(A2,FIND(“：”,A2)+1,LEN(A2)-FIND(“：”,A2)-1)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62cc38ec905d98bd3768920644c6533/" rel="bookmark">
			JavaScript 基础语法速过 [适合速刷复习]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：不适合0基础小白 小白快速入门请移步另一篇文章
JavaScript快速入门
js变量类型和方法 js 定义变量 var js 输出变量 alert(); 窗口弹出 document.write(); 页面打印 js 变量类型 字符串 整型 浮点 布尔 数组 对象 json对象 NaN null undefined js相关对象 1.js对象
obj=new Object(); 2.dom对象
eleobj=document; 3.json对象
jsobi={ 'username':'小林', 'age':20， 'say':function(){ alert(1); // 对象的方法 } }; alert(jsobi.age); alert(jsobj.say()); // 别忘了加圆括号 变量类型相关 1.JavaScript 变量作用域
记住 函数里面带var的是局部变量 其余的(不带var)都是全局变量. 2.变量类型测试 typeof()
typeof() 变量类型判断函数 内置的函数 arr instanceof Array 判断当前的arr是否是Array生产出来的 arr = [1,2,3]; alert(arr instanceof Array); // true 顶级全局方法（系统内部函数） parseInt(); // 强制转整形 parseFloat(); // 强制转浮点 eval(); //执行字符串中的表达式[进行运算] Number(); // 转整型 String(); // 转字符串 Boolean(); // 转布尔类型 eval() 实例 s='a=1*10*10'; // 一串字符串 alert(s); eval(s); //执行字符串中的表达式[进行运算] alert(a); // 会算出来a的运算值 JS变量类型转换相关
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c62cc38ec905d98bd3768920644c6533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/584e63454360c57e49e8b87dc27061a7/" rel="bookmark">
			数据库技术-01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据库DB：数据的介质，具有结构形式并存放的的存储介质内，是多种应该用数据的集成，并且按数据所提供的数据模型存放。
数据库应用系统Database Application System,简称DBAS =数据库系统+应用软件+界面
2.DBAS的生命周期由项目规划、需求分析、系统设计、实现与部署、运行管理和维护等五个基本活动组成。
3.数据库系统三级模式结构，DBAS设计阶段分为概念设计、逻辑设计、物理设计三个步骤。
4.规划与分析的主要工作内容：
​ 系统规划与定义：任务陈述、确定任务目标、确定范围和边界、确定用户视图
​ 可行性分析：技术、经济、操作可行性及开发方案选择
​ 项目规划：项目团队、环境、活动、成本预算、进度计划
5.需求分析的内容
数据需求分析：描述用户需要组织的信息内容形成数据字典
​ 功能需求分析：描述系统做什么，数据处理需求分析+业务规则需求分析
​ 性能需求分析：描述系统应当做到什么程度，数据操作需要时间、系统吞吐量、硬件资源
​ 其他需求：存储需求、安全性需求、备份与恢复
6.系统设计
​ 概念设计：数据库概念模型设计、系统总体设计
​ 逻辑设计：数据库逻辑结构设计、应用程序概念设计、数据库事务概要设计
​ 物理设计：数据库物理结构设计、数据库事务概念设计、应用程序详细设计
7.实现与部署
包括建立数据库结构，数据加载，事务和应用程序的的编码及测试，系统集成。测试与运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e65d2cc1f89b95ff66cf8532623619d/" rel="bookmark">
			如何做安全测试？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天一起来学习下如何做安全测试。
什么是安全测试? 安全测试是一种软件测试类型，用于发现软件应用程序中的漏洞、威胁和风险，并防止来自入侵者的恶意攻击。安全测试的目的是查明软件系统中所有可能导致本公司员工或外部人员损失信息、收入和声誉的漏洞和薄弱地方。
为什么安全测试很重要? 安全测试的主要目标是识别系统中的威胁，并测量其潜在的漏洞，以便在遇到威胁时，系统不会停止工作或不会被利用。它还有助于检测系统中所有可能的安全风险，并帮助开发人员通过编码解决问题。
软件测试中的安全测试类型 根据开源安全测试方法手册，有七种主要类型的安全测试。
漏洞扫描:这是通过自动化软件根据已知的漏洞特征扫描系统来完成的。
扫描:包括识别网络和系统的弱点，然后提供降低这些风险的解决方案。此扫描可用于手动和自动扫描。
渗透测试:这种测试模拟来自恶意黑客的攻击。这种测试包括对特定系统的分析，以检查外部黑客攻击的潜在漏洞。
风险评估:该测试包括对组织中观察到的安全风险的分析。风险分为低、中、高。该测试建议控制和措施，以降低风险。
安全审计:这是对应用程序和操作系统安全缺陷的内部检查。审计也可以通过逐行检查代码来完成
道德黑客:它是入侵一个组织的软件系统。不像恶意黑客为了自己的利益而窃取，他们的目的是暴露系统中的安全漏洞。
安全状态评估:它结合了安全扫描、道德黑客和风险评估，以显示组织的整体安全态势。
如何进行安全测试 大家一致认为，如果我们将安全测试推迟到软件实现阶段或部署之后，成本会更高。因此，有必要在SDLC生命周期的早期阶段进行安全测试。
让我们研究一下SDLC中每个阶段所采用的相应安全流程
SDLC阶段安全过程需求安全分析，检查滥用/误用情况设计设计时的安全风险分析。制定测试计划，包括安全测试编码和单元测试静态和动态测试以及安全白盒测试集成测试黑盒测试系统测试黑盒测试和漏洞扫描实施渗透测试，漏洞扫描支持补丁影响分析 测试计划应该包括
与安全相关的测试用例或场景
Test安全测试相关数据
测试安全测试所需的工具
分析来自不同安全工具的各种测试输出
安全测试场景示例 安全测试场景，让您了解安全测试用例-
密码必须采用加密格式
应用程序或系统不应该允许无效用户
检查应用程序的cookie和会话时间
对于金融网站，浏览器的后退按钮不应该工作。
安全测试的方法/方法/技术 在安全测试中，会采用不同的测试方法，具体方法如下:
虎盒:这种黑客通常是在笔记本电脑上进行的，它有一个操作系统和黑客工具的集合。该测试帮助渗透测试人员和安全测试人员进行漏洞评估和攻击。
黑盒:测试人员被授权对网络拓扑和技术的所有方面进行测试。
灰盒:关于系统的部分信息被提供给测试人员，它是白盒模型和黑盒模型的混合。
安全测试角色 黑客-未经授权进入计算机系统或网络
攻击者——侵入系统窃取或破坏数据
道德黑客-执行大部分破坏活动，但得到所有者的许可
脚本Kiddies或猴子测试（随机测试）-缺乏经验的黑客与编程语言技能
安全测试工具 1) Acunetix
直观和易于使用，Acunetix由Invicti帮助中小型组织确保他们的web应用程序是安全的，从昂贵的数据泄露。它通过检测各种网络安全问题并帮助安全和开发专业人员快速采取行动来解决这些问题。
特点:
高级扫描7000 + web漏洞，包括OWASP前10名，如SQLi和XSS
自动发现web资产，用于识别废弃或遗忘的网站
先进的爬虫最复杂的网络应用程序，包括。多形式和密码保护的领域
结合交互式和动态应用程序安全测试，以发现其他工具遗漏的漏洞
为许多类型的漏洞提供了利用证明
通过集成流行的问题跟踪和CI/CD工具实现DevOps自动化
监管标准的合规报告，如PCI DSS、NIST、HIPAA、ISO 27001等。
2)入侵者
入侵者是一个强大的自动渗透测试工具，可以发现您IT环境中的安全弱点。提供行业领先的安全检查，持续监控和易于使用的平台，入侵者使各种规模的企业免受黑客攻击。
特点:
一流的威胁覆盖，超过10,000个安全检查
检查配置缺陷、缺失补丁、应用程序缺陷(如SQL注入和跨站脚本)等
自动分析和优先级扫描结果
直观的界面，快速设置和运行您的第一次扫描
主动监控最新的安全漏洞
AWS、Azure和谷歌云连接器
API与您的CI/CD管道集成
3) Owasp
开放Web应用程序安全项目(OWASP)是一个全球性的非营利组织，致力于提高软件的安全性。该项目有多个工具来测试各种软件环境和协议。项目的旗舰工具包括
Zed Attack Proxy (ZAP -集成渗透测试工具)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e65d2cc1f89b95ff66cf8532623619d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e80fd7ec6912508c9706331011b5fa/" rel="bookmark">
			异常处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常处理器：统一集中处理，执行过程中抛出的异常
DefaultHandlerExceptionResolver
SimpleMappingExceptionResolver
@RestControllerAdvice public class ProjectControllerAdvice { @ExceptionHandler(Exception.class)// 定义处理哪种异常 public Result doException(Exception ex){ System.out.println("异常被我抓住"); return new Result(666,null,"异常在我这儿"); } } @RestControllerAdvice
类注解
为Rest风格开发的控制器类做增强
该注解自带@ResponseBody注解和@Component注解，具备对应的功能
@ExceptionHandler
方法注解
设置指定异常的处理方案
出现异常后，终止原始控制器执行，并转入当前方法执行
自定义异常 继承RuntimeException，出现以后它自动向上抛，不用去throws
如果继承Exception，则每一个方法后都要throws BusinessException
public class SystemException extends RuntimeException{ private Integer code; public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public SystemException(Integer code, String message) { super(message); this.code = code; } public SystemException(Integer code, String message, Throwable cause) { super(message, cause); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6e80fd7ec6912508c9706331011b5fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8645d97bdf5ec68f4d31b93997f891a5/" rel="bookmark">
			Chrome浏览器快捷键大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器标签页和窗口快捷键：
Ctrl+N 打开新窗口。
Ctrl+T 打开新标签页。
Ctrl+Shift+N 在隐身模式下打开新窗口。
Ctrl+O，然后选择文件。 在 Google Chrome 浏览器中打开计算机中的文件。
按住 Ctrl 键的同时点击链接。或用鼠标中键(或鼠标滚轮)点击链接。 从后台在新标签页中打开链接。
按住 Ctrl+Shift 的同时点击链接。或按住 Shift 键的同时用鼠标中键(或鼠标滚轮)点击链接。 在新标签页中打开链接并切换到刚打开的标签页。
按住 Shift 键的同时点击链接。 在新窗口中打开链接。
Ctrl+Shift+T 重新打开上次关闭的标签页。Google Chrome 浏览器可记住最近关闭的 10 个标签页。
将链接拖到标签页中。 在标签页中打开链接。
将链接拖到标签栏的空白区域。 在新标签页中打开链接。
将标签页拖出标签栏。 在新窗口中打开标签页。
将标签页从标签栏拖到现有窗口中。 在现有窗口中打开标签页。
拖动标签页时按 Esc 键。 将标签页恢复到原先的位置。
Ctrl+1 到 Ctrl+8 切换到标签栏中指定位置编号所对应的标签页。
Ctrl+9 切换到最后一个标签页。
Ctrl+Tab 或 Ctrl+PgDown 切换到下一个标签页。
Ctrl+Shift+Tab 或 Ctrl+PgUp 切换到上一个标签页。
Alt+F4 关闭当前窗口。
Ctrl+W 或 Ctrl+F4 关闭当前标签页或弹出窗口。
用鼠标中键(或鼠标滚轮)点击标签页。 关闭所点击的标签页。
右键点击或者点击并按住浏览器工具栏中的“后退”或“前进”箭头。 在新标签页中显示浏览历史记录。
按 Backspace 键，或同时按 Alt 和向左箭头键。 转到当前标签页的上一页浏览历史记录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8645d97bdf5ec68f4d31b93997f891a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c5486b3ab17e897e088e9dad9501bdd/" rel="bookmark">
			登录逻辑漏洞整理集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、任意用户注册
1.未验证邮箱/手机号
2、不安全验证邮箱/手机号
3.批量注册
4.个人信息伪造
5.前端验证审核绕过
6.用户名覆盖
二、任意用户登录
1、万能密码
2、验证码、密码回显
3、登录检测不安全
三、任意账号重置
1、重置账号名
2、验证码
3、MVC数据对象自动绑定
4、Unicode字符处理
四、任意用户查看
1、cookie未鉴权
2、cookie鉴权
2、接口中参数
一、任意用户注册 1.未验证邮箱/手机号 情景：应用为了方便用户记录用户名，使用邮箱和手机号作为用户名（因此很多应用在注册的时候就要求用户填写，多数时候都会给用户发送激活信息，激活后才能登录） 缺陷： 1、未审核邮箱/手机号是否有效（及未发送验证信息），从而实现任意注册账号 2、未验证数据库中是否已经存在相同的用户名（导致同一账号，有2个密码，且用户数据产生读取问题） 2、不安全验证邮箱/手机号 用户注册邮箱/手机号提交后，会通过发验证码等方法对其真实性进行验证 缺陷： 1、返回的验证码：验证码信息会隐藏在返回包中，或hidden属性隐藏，或者是可以伪zao该信息，劫chi到验证信息 2、分布验证/多步填写等情况：第一步填写的时候验证完成以后，后面并未对账号进行再次验证，通过修改数据包中已验证的邮箱/手机 3、验证未绑定：使用自己邮箱/手机获取验证码后，在其他账号上使用 3.批量注册 （提示：危害不足） 通常由于无验证码或者验证码不安全，再对用户名进行爆破即可 4.个人信息伪造 （提示：有的行业会危害不足，防沉迷可能不一样） 需填写身份证等信息，可任意构造绕过身份证与姓名（一般网站危害不足） 如果是防沉迷系统存在此类问题（危害应该足了） 5.前端验证审核绕过 1、任意填写注册信息，服务器会对信息进行审核，并通过返回状态给前端判断（如检测是否存在恶意标签等，对返回的状态可修改绕过） 2、步骤 使用正常账号或合规操作执行，拦截返回信息（判断信息） 使用需要绕过检测的操作，并将服务器返回判断信息替换为正确时的 6.用户名覆盖 未对数据库中的账号进行核对是否已经存在 利用地方：注册账号、修改个人信息 二、任意用户登录 1、万能密码 对万能密码需要有一定的了解，并不是真的万能 有时候也得考虑 字符型 or 数值型 单引号 or 双引号 asp aspx万能密码 1："or "a"="a 2：'.).or.('.a.'='.a 3：or 1=1-- 4：'or 1=1-- 5：a'or' 1=1-- 6："
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c5486b3ab17e897e088e9dad9501bdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d684836397ff992a5fe74c6426e331/" rel="bookmark">
			前端加密/解密方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加密/解密应用场景 前言： 通常在前后端之间数据传输经常会涉及到一些敏感数据、cookie携带的token加密等问题。
提到加密，相对于后台开发来说，遇到最多的需要加密处理的应用场景应该是接口的加密签名校验了。不过这种一般都用于服务端与服务端之间的相互调用。因为没有暴露在外的代码这种加密校验相对比较安全。但javaScript不一样，它是运行在浏览器端的一种脚本语言。基本除了在sojson.v6加密过的js代码，黑客可以通过逆向分析你的js代码来盗取一些数据。
常用的js加密： 对称加密(AES)：用的同一个密钥进行加解密的
优点: 速度快
缺点: 在传输密钥过程中,这个密钥容易被拦截,导致密钥泄漏,安全性不高
非对称加密(RSA): 生成密钥,分别为公钥和秘钥,公钥对数据进行加密,私钥对数据进行解密
优点: 只需要服务端把公钥,传递给前端,前端通过公钥进行加密,服务端通过私钥解密,安全性很高
缺点: 速度慢
1、 js内置api（escape和unescape） const code = 'hello world'; const _enCode = escape(code); // 加密 const _unescapeCode = unescape(code); // 解密 console.log('加密code前：', code); // 加密code前： hello world console.log('加密code后：',_enCode); // 加密code后：hello%20world console.log('解密code后：', _unescapeCode); // 解密code后： hello world 由此可以看到用escape函数加密后，字符变成了%开头形式的特殊编码。需要用unescape反编译回来。escape/unescape通常应用于url中携带数据加密较为多些。
2、md5加密 我这里演示借助了crypto插件（项目里安装了），没有的话可以自行安装一下,安装地址: https://github.com/brix/crypto-js
import Crypto from "crypto"; const user_key = 'md5_121212'; const passWord = Crypto.createHash('md5').update(`${user_key}\n`).digest('hex'); console.log('passWord:', passWord); MD5码以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。md5加密一般用于确保文件和代码的唯一性，可以根据计算代码的md5值来判断代码是否被改变。不过md5属于对称加密范畴。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55d684836397ff992a5fe74c6426e331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d00c70f145894e07e91e594214a6bdf/" rel="bookmark">
			PyQt5的SpinBox、DoubleSpinBox和ProgressBar控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：PyQt5 + VSCode 在Qt Designer中新建Main Window。将Input Widgets中的Spin Box、Double Spin Box和Display Widgets中的Progress Bar拖拽入窗口中。保存文件为pyqt4.ui。如下图。
新建文件pyqt4.py。
import sys from Ui_pyqt4 import Ui_MainWindow from PyQt5.QtWidgets import QApplication, QMainWindow class MyMainWindow(QMainWindow, Ui_MainWindow): def __init__(self, parent=None): #parent 参数 super(MyMainWindow, self).__init__(parent) self.setupUi(self) self.spinBox.setRange(0,10) #设置取值范围(最大值, 最小值) self.spinBox.setValue(1) #设置当前值 self.spinBox.setSingleStep(1) #步长，每按一下按钮改变的值 self.doubleSpinBox.setRange(0,10) #设置取值范围(最大值, 最小值) self.doubleSpinBox.setValue(2) #设置当前值 self.doubleSpinBox.setDecimals(1) #设置小数点后位数 self.doubleSpinBox.setSingleStep(0.5) #步长，每按一下按钮改变的值 self.progressBar.setRange(0,10) #设置取值范围(最大值, 最小值) self.progressBar.setValue(1) #设置当前值 self.progressBar_2.setRange(0,100) #设置取值范围(最大值, 最小值)。取值只取整数，乘10得到整数 self.progressBar_2.setValue(2*10) #设置当前值，乘10得到整数 self.spinBox.valueChanged.connect(self.func1) #值改变时 self.doubleSpinBox.valueChanged.connect(self.func2) #值改变时 def func1(self): self.progressBar.setValue(self.spinBox.value()) #value()获得当前值 def func2(self): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d00c70f145894e07e91e594214a6bdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75f26a2a8cde7c4bfd6a0cc376bb4f68/" rel="bookmark">
			linux 重启网卡命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关闭网卡：ifdown em4（网卡名） 打开网卡：ifup em4 重启网卡： ifdown em4 &amp; ifup em4 重启所有网卡：systemctl restart network 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/147d128822741b4d7c2c3479fdb244a2/" rel="bookmark">
			漏洞等级标准参考建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SRC漏洞定级标准
分资产，核心资产，一般资产，边缘资产
严重漏洞：
1.不需要登录直接获取设备root权限的漏洞，包括但不限于上传Webshell，任意代码执行，远程命令执行等
2.不需要登录直接导致严重的信息泄露漏洞，包括但不限于重要数据库的SQL注入、系统权限控制不严格等导致的敏感数据泄露漏洞等
3.不需要登录直接导致严重影响的逻辑漏洞，包括但不限于核心账户体系的帐密校验逻辑、支付逻辑漏洞等
高危漏洞：
1.需要登录的重要业务敏感数据信息泄露漏洞，包括但不限于重要用户信息、配置信息、数据文件信息等
2.需要登录的重要业务逻辑漏洞，包括但不限于权限绕过等
3.包含重要业务铭感信息的非授权访问，包括但不限于绕过认证直接访问管理后台、后台弱密码、可直接获取大量内网铭感信息的SSRF等
4.影响应用服务正常运转，包括但不限于应用层拒绝服务等
中危漏洞：
1.不需要交互对用户产生危害的安全漏洞，包括但不限于一般页面存储型XSS等
2.普通信息泄露漏洞，包括但不限于用户信息泄露和业务敏感信息泄露等
3.普通的逻辑设计缺陷和流程缺陷，包括但不限于越权查看非核心系统的订单信息、记录等
4.其他操作中度影响的漏洞，例如：没有敏感信息的SQL注入、无法回显的SSRF等
低危漏洞:
1.轻微信息泄露，包括但不限于路径信息泄露、svn信息泄露、phpinfo、日志文件、配置信息等
2.本地拒绝服务，包括但不限于客户端本地拒绝服务等引起的问题
3.可能存在安全隐患但利用成本很高的漏洞，包括但不限于需要用户连续交互的敏感安全漏洞，例如：解析漏洞、可被暴力破解接口等
无效:
1.不涉及安全问题的bug，包括但不限于功能缺陷、网页乱码、样式混乱、静态文件遍历、应用兼容性等问题
2.无法利用的漏洞，包括但不限于self-xss、无敏感操作的CSRF、无意义的异常堆栈、内网IP地址/域名泄露
3.不能直接反映漏洞存在的其他问题，包括但不限于纯属猜测的问题
扫描器的漏洞定级按照扫描的标准执行即可
第三方组件CVE漏洞的分级标准，可以采用CVSS（弱点评价体系）评分标准
https://www.first.org/cvss/calculator/3.1
常见漏洞定级标准
SQL注入漏洞
定级标准：
严重：能够利用SQL注入获取webshell
高危：能够验证存在的SQL注入
XSS漏洞
定级标准：
存储型XSS：高危
反射型XSS：低危
命令执行漏洞
定级标准：
严重：能够执行命令，能够验证出来
低危：无法验证出来，或者参数不可控
风险：无法验证出来，或者参数不可控
CRLF漏洞
定级标准：中危
HOST注入攻击
定级标准：低危
文件上传漏洞
定级标准：
严重：能够利用文件上传漏洞，或者租户其他漏洞，能够获取设备权限
高危：能够绕过防御规则，能执行js探针，给产品线演示出效果
中危：能够绕过防御规则，成功上传文件，但是文件重命名了。文件路径、文件名很难找到，或者需要利用条件竞争子类的漏洞去触发
低危：能够任意文件上传，但是没有执行权限，无法造成伤害
目录遍历漏洞
定级标准：中危
硬编码
定级标准：高危
目录穿越/任意文件读取/下载漏洞
定级标准：
高危：任意读取文件
中危：读取文件有限制
任意文件删除
定级标准：
严重：能够越目录删除任意文件
高危：被限制在web目录，能删除任意web文件
SSRF漏洞
定级标准：
严重：能够利用租户其他漏洞，获取设备权限
高危：能够结合各种协议造成实际伤害
中危：能够证明存在SSRF，可以利用漏洞探测内网
低危：证明存在SSRF，但是无法利用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/147d128822741b4d7c2c3479fdb244a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24a5d123febe807cad57e50a48c05d92/" rel="bookmark">
			git中git push origin master推送远程操作失败,报错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错图片如下所示:
解决方案:
使用下面代码进行本地与远程仓库的链接: git remote add origin http://xxxxx///xxx(https://gitee.com/peach-fog/shopping-cart-car-warehouse.git) 链接完成之后就会输出:fatal: remote origin already exists.
链接完成之后就需要使用git branch查看一下你所处是哪个分支上面
查看是否是要你要合并的那个分支使用git merge 分支 进行合并查看完成,这个时候不要急着直接合并我们需要先将远程仓库中的分支拉取到本地才可以进行合并,可以使用git pull origin war --allow-unrelated-histories进行拉取( --allow-unrelated-histories 是强制合并的意思)原因是因为gitee只是一个网址不可以进行一些复杂的操作.接下来我们就可以进行推送了git push origin 分支总结:以上就是解决git合并的一些报错和解决方案有何不懂的可以再评论区或者私信问我呦 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f9ddf43ce06c1b657053e8ec778ef9/" rel="bookmark">
			招聘 | 微软小冰-实习生-NLP、CV等算法岗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发布招聘—&gt;加我即可
小冰AI招算法实习生啦！
1.参与面向虚拟人社交对话应用场景的需求分析及算法应用研究；
2.参与大规模预训练模型的架构设计，针对其在小样本/零样本/增量学习问题的应用潜力展开研究；
3.负责配合算法工程师和项目经理把研究成果转化到产品；
4.发表技术创新文章到顶级学术领域，推动行业发展及提高业界影响力。
任职要求：
1.统招硕士及以上学历，计算机/数学/统计等相关专业；
2.熟练掌握NLP/多模态领域常用的算法模型原理和常用工具，熟悉Pytorch、Tensorflow等深度学习框架；
3.有实际深度学习项目经验者优先，熟悉ChatGPT, Lamda, BlenderBot等模型优先；
4.在NLP或CV等领域顶会(ACL/EMNLP/NIPS/ICML/AAAI/CVPR/ECCV等)有发表过论文者优先；
5.实习时间：至少3个月及以上，一周3天及以上；实习地点：上海、北京、苏州，特殊情况可接受远程。
简历投递：lianyixin@xiaobing.ai
公司简介：
小冰公司的前身是微软亚洲互联网工程院的人工智能小冰团队。该团队于2013年12月在北京组建，2014年9月在日本东京建立了研发分部。
目前整个团队分布于北京、上海、苏州和东京四地。作为微软全球首个以中国为总部的人工智能产品线，小冰历经多年发展已经成为了微软最有价值的人工智能技术框架之一。
发布招聘—&gt;加我即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a6a33e6f850495a997e86d03fa50ce0/" rel="bookmark">
			Windows使用ssh协议远程连接ubuntu linux系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows使用ssh协议远程连接ubuntu linux系统 一、Windows远程连接ubuntu linux系统二、开启ubuntu ssh服务三、获取ubuntu子系统的ip地址四、从windows上通过ssh连接到ubuntu子系统五、设置ubuntu系统ssh自启动（18.04） 一、Windows远程连接ubuntu linux系统 当我们在windows上安装好ubuntu子系统后，肯定是需要远程进行连接的，比如我想用filezilla通过sftp协议传输点文件上去之类的，或者我使用vscode直接通过ssh协议进行远程登录开发等等，那么还是需要一点额外的配置的，以及使用Windows终端连接时，均需要一些配置。
远程连接前提：
ubuntu子系统开启了ssh服务ubuntu子系统的ip地址 二、开启ubuntu ssh服务 我们先直接打开ubuntu子系统，尝试启动ssh服务：
service ssh start 如果时精简本版，没有安装自带的SSH服务，自行安装即可
使用apt命令进行安装，因为ubuntu是作为服务器，我们这里只安装server就行了，client的话有需求的可以自行安装。
sudo apt install openssh-server 这里如果出现环境依赖关系，就先去尝试安装对应的环境版本，如果发现还是有问题，直接卸载相应的环境，再进行安装即可，亲测有效
安装完毕后，再次尝试启动ssh服务，可以看到启动成功。
三、获取ubuntu子系统的ip地址 终端输入
ifconfig 发现找不到相关服务，原因同上，因为ubuntu并没有自带这个命令，需要自己安装。
执行以下命令进行安装即可
sudo apt install net-tools 安装完毕后，重新使用ifconfig命令查看ip地址
ip地址标识：np4s0 —&gt; inet
四、从windows上通过ssh连接到ubuntu子系统 需要传输文件时，通过sftp协议即可，此处以FileZilla为例, 打开连接向导，输入ip地址，用户名和密码，即可
正常来讲，配置密钥后，进入ubuntu系统不需要输入密码，使用FileZilla工具时选择密钥登录，找到对应id_rsa文件即可
五、设置ubuntu系统ssh自启动（18.04） # 开机自动启动ssh命令 sudo systemctl enable ssh # 关闭ssh开机自动启动命令 sudo systemctl disable ssh # 单次开启ssh sudo systemctl start ssh # 单次关闭ssh sudo systemctl stop ssh # 设置好后重启系统 reboot #查看ssh是否启动，看到Active: active (running)即表示成功 sudo systemctl status ssh 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de75396214174e65b9c97a849204dad/" rel="bookmark">
			数据结构——算法的时间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌇个人主页：_麦麦_
📚今日名言：生命中曾经有过的所有灿烂，都终究需要用寂寞来偿还。——《百年孤独》
目录
一、前言
二、正文
1.算法效率
1.1如何衡量一个算法的好坏
1.2算法的复杂度
2. 时间复杂度
2.1时间复杂度的概念
2.3 常见时间复杂度计算举例
三、结语
一、前言 小伙伴们好呀，今天为大家带来的是算法的相关知识，主要围绕算法的效率和时间复杂度并伴有一定的题目练习，希望能够为读者们带来一定的收获。
二、正文 1.算法效率 1.1如何衡量一个算法的好坏 相信在座的小伙伴们一定见识了许多题目，也一定想出了相应的解决方案。不可否认的是，在面对同一道题目，同一个需求，不同的人也会写出不同的解决方案，那么到底如何如何评判这些解决方案的好坏呢？
有的小伙伴可能会说这还不简单嘛，之间看谁的算法跑的快，也就是依据时间效率的高低来评判算法的好坏。不过在实际中，由于算法的运行环境不同，例如在不同的设备上同一算法的时间效率都可能是不一样的，更遑论是不同的算法了。显然，用时间效率来衡量一个算法的好坏是不可能的，那么有什么更好的方法呢？
1.2算法的复杂度 算法在编写成可执行程序后，运行时需要耗费时间资源和空间（内存）资源。因此衡量一个算法的好坏主要是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。
时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算器发展的早起，计算机的存储容量很小，所以对空间复杂度很是在乎，但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今应经不需要特别关注一个算法的空间复杂度。
2. 时间复杂度 2.1时间复杂度的概念 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上是不能算出来的，只有把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是都可以上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。
即：找到某条基本语句与问题规模N之间的数学表达式，就是算出来该算法的时间复杂度。
说了这么多，纸上得来终觉浅，下面给小伙伴们举一些计算时间复杂度的例子，帮助大家更好地理解时间复杂度这一概念。
//请计算一下Func1中++count语句总共执行了多少次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N; ++i) { for (int j = 0; j &lt; N; ++j) { ++count; } } for (int k = 0; k &lt; 2 * N; ++k) { ++count; } int M = 10; while (M--) { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7de75396214174e65b9c97a849204dad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6071afa9906b794bf550a05c5610417c/" rel="bookmark">
			nodemon的安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、为什么使用 nodemon 在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。现在，我们可以使用 nodemon 工具包 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试。
2、使用 nodemon 当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 node app.js 命令，来启动项目。这样做的坏处是：代码被修改之后，需要手动重启项目。
现在，我们可以将 node 命令替换为 nodemon 命令，使用 nodemon app.js 来启动项目。这样做的好处是：代码被修改之后，会被 nodemon 监听到，从而实现自动重启项目的效果，提高了开发效率。
3、安装nodemon npm install -g nodemon 查看是否安装成功，出现版号即可
nodemon -v 4、nodemon的使用 以启动serve.js为例
nodemon serve.js 启动完成
若启动失败，则在启动命令前加上npx
npx nodemon serve.js 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77197af4aa88091b67e97cc44966b9c0/" rel="bookmark">
			JavaScript语法快速入门[0基础]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript基础 基础语法快速入门 1.基本要素
​ 每个语句以（;）结束
​ 语句块用{…}进行包裹
2.赋值语句
var x=1;建议一行一句话
3.注释方式
1.第一种 //
2.第二种 /* … */
数据类型和变量 1.数据类型
number JavaScript 不区分整数和浮点数 123 0.456 1.2345e3都是合法的number数字类型
2.字符串 单引号或者双引号
3.布尔值 true和false
&amp;&amp;运算是与运算 只有结果都为true是才为true
|| 运算 只要一个为true就为true
!单目运算符 !true 就是flase !（2&gt;5）结果为true
4.比较运算符
== 自动转换数据类型再进行比较`
=== 不自动转换类型 如果数据类型不一致的时候 则会返回false 一般使用这个 注意浮点数的比较方式 利用作差的方式进行比较alert(Math.abs(1/3-(1-2/3))&lt;0.0000001);注意！！！！浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：
5.数组
数组是一种按顺序排列的集合，集合的每个值称之为元素。
数组用[]表示 元素之间用，进行分割 两种方式 1.[123,‘小林子’,true] 2.new Array(1,2,3);建议使用第一种方式 注意索引值为0 访问方式 数组名字[索引序号]
6.对象
JavaScript对象是一组由键值对组成的无序集合
var person={` name:'bob', age:20, tags:['js','web','mobile'] }; 获取对象的方式 对象变量.属性名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77197af4aa88091b67e97cc44966b9c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f6707b7dd50b34e142087f7c7d9bd7a/" rel="bookmark">
			python去除图片水印的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你可以参考以下代码，它可以帮你去除图片水印：from PIL import Image def remove_watermark(img): width, height = img.size pixdata = img.load() for y in range(height): for x in range(width): if pixdata[x, y] == (0, 0, 0): pixdata[x, y] = (255, 255, 255) return img im
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/75/">«</a>
	<span class="pagination__item pagination__item--current">76/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/77/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>