<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4ee4a2a0573da285af453600bfbc3f1/" rel="bookmark">
			mysql text 长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BLOB TEXT 一个BLOB或TEXT列，最大长度为65535(2^16-1)个字符。
MEDIUMBLOB MEDIUMTEXT 一个BLOB或TEXT列，最大长度为16777215(2^24-1)个字符。
LONGBLOB LONGTEXT 一个BLOB或TEXT列，最大长度为4294967295(2^32-1)个字符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a159c2968ad866457541911bdb6402d8/" rel="bookmark">
			日记090605
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天上午图形学检查实验，昨晚将近两点才睡，看网上有人说把MySQL安装、配置什么的花了一个晚上都没弄好，心里好受点了，哈哈
早上八点左右居然神奇般的自然醒了，最近一个星期都能在这个时候自动醒来，嗯，不错，不用闹钟了，不过怎么感觉是渴醒的呢？
检查后呆了一会就回寝室了，回来后没干什么事，看到一个帖子，楼主絮絮叨叨的讲了个公主、驴、王子的故事，可能我是年轻时还比较单纯的驴吧...
下午忍着没睡觉搞MFC，在一个问题上卡了很久，晚饭也没吃，没胃口啊没胃口，到晚上才发现是L下的数据库类有问题，晕，仔细看了会改过来后，终于正常了，还是经验不足啊，对一些API不够了解。
然后到9点多，和L分下工后，终于忍不住了，困，而且VS的界面也看不下去了，于是开始干别的，非正事。
再然后把别人给我写的选修课论文改了下，就到23：41了
睡觉吧，晚安
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b81b5ab65f70306dfbe92f9a3c55ef/" rel="bookmark">
			c# ToString()格式大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符型转换为字符串
// C 货币 2.5.ToString("C"); // ￥2.50 // D 10进制数 25.ToString("D5"); // 25000 // E 科学型 25000.ToString("E"); // 2.500000E+005 // F 固定点 25.ToString("F2"); // 25.00 "F?"表示保持几位小数 // G 常规 2.5.ToString("G"); // 2.5 // N 数字 2500000.ToString("N"); // 2,500,000.00 // X 16进制 255.ToString("X"); // FF // C# 日期格式 DateTime dt = DateTime.Now; dt.ToString();//2005-11-5 13:21:25 dt.ToFileTime().ToString();//127756416859912816 dt.ToFileTimeUtc().ToString();//127756704859912816 dt.ToLocalTime().ToString();//2005-11-5 21:21:25 dt.ToLongDateString().ToString();//2005年11月5日 dt.ToLongTimeString().ToString();//13:21:25 dt.ToOADate().ToString();//38661.5565508218 dt.ToShortDateString().ToString();//2005-11-5 dt.ToShortTimeString().ToString();//13:21 dt.ToUniversalTime().ToString();//2005-11-5 5:21:25 dt.Year.ToString();//2005 dt.Date.ToString();//2005-11-5 0:00:00 dt.DayOfWeek.ToString();//Saturday dt.DayOfYear.ToString();//309 dt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b81b5ab65f70306dfbe92f9a3c55ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57326b0f6f160de1fd4ff875098fd046/" rel="bookmark">
			DSP 中断寄存器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.PC是用来指示下一条要执行的指令的，即存放的是下一条要执行的指令的地址。
几乎所有的MCU都不允许MOV指令修改PC值，这是一个常识。
2.中断服务表指针寄存器ISTP（interrupt servicetable pointer）用于确定中断服务程序在中断服务表中的地址。ISTP中的字段ISTB确定IST的地址的基值，另一字段HPEINT确定特定的中断，并给出这一特定中断取指包在IST中的位置。
3.IFR（中断标志寄存器）：显示出有终端请求但尚未得到服务的中断。
4.IER（中断使能寄存器）：使能后禁止中断处理。
5.IRP（可屏蔽中断返回指针寄存器）：包含从可屏蔽中断返回的地址，该中断返回通过指令BIRP完成。
6.NRP（不可屏蔽中断返回指针寄存器）：包含从不可屏蔽中断返回的地址，该中断返回通过指令BNRP完成。
7.CSR（控制状态寄存器）：控制全局使能或禁止中断。
8.AMR（寻址模式寄存器）：制定是否使用线性或循环寻址，若循环寻址还指定循环地址大小。
9.EN（端结方式）：1=小端终结；0=大端终结。
10.Event Encoder （事件编码器）：事件寄存器ER（包括ERL和ERH）用于捕获对应于64个EDMA通道的事件。在事件编码器中只是负责提交请求，事件的优先局依赖于EDMA通道参数的设定，并且在Transfer Crossbar中才正式排定。 11.协处理器控制位
CR0中的位1~4分别标记位MP（算术存在位）、EM（模拟位）、TS（任务切换位）和ET（扩展类型位），它们控制浮点协处理器的操作。
EM位控制浮点指令的执行是用软件模拟，还是由硬件执行。EM=0时，硬件控制浮点指令传送到协处理器；EM=1时，浮点指令由软件模拟。 12.中断描述符表寄存器IDTR
IDTR长48位，高32位存段基址，低16位存段界线。由于80386只支持256个中断/异常，所以IDT表的最大长度是2K，以字节位单位的段界线为7FFH。IDTR表示IDT表的方式与GDTR表示GDT表的方式相同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0d1564f875d39b646f9c9712ea961b/" rel="bookmark">
			诛仙练气心得（持续更新中……）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏针对每个ID在每个不同时段的练气成功率完全不一样，练气时不要赌气，特别是在连续不成功的时候。练气成功率比较高的时候还是在23:30-8:00之间。
1. 练气连续不成功时，千万要不要赌气，+5都上不了的时候赶紧离线等待。
2. 运气比较好的时候如果连续上到+5，千万不要再继续练。但可尝试换线练其他装备到+5。
3. 练+6及+6以上装备时，不管什么情况要带好足够的完毕，千万不要冒险+6以上。
4. 准备5个105级以上的帐号，一个帐号运气不好切换到另外一个帐号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11342c5fe924704d0d3842a9707f489e/" rel="bookmark">
			DAO设计模式笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DAO设计模式
DAO(Data Access Object)模式实际上是两个模式的组合，即Data Accessor 模式和 Active Domain Object 模式，其中 Data Accessor 模式实现了数据访问和业务逻辑的分离，而Active Domain Object 模式，其中Data Accessor模式实现了数据访问和业务逻辑的分离，而Active Domain Object 模式实现了业务数据的对象化封装，一般我们将这两个模式组合使用，因此，考虑到这些因素，这里将其作为同一个主题加以讨论。如图展示了DAO模式的实现层次。
DAO模式通过对业务层提供数据抽象层接口，实现了以下目标：
1. 数据存储逻辑的分离 通过对数据访问逻辑进行抽象，为上层机构提供抽象化的数据访问接口。业务层无需关心具体的select,insert,update操作，这样，一方面避免了业务代码中混杂JDBC调用语句，使得业务落实实现更加清晰，另一方面，由于数据访问几口语数据访问实现分离，也使得开发人员的专业划分成为可能。某些精通数据库操作技术的开发人员可以根据接口提供数据库访问的最优化实现，而精通业务的开发人员则可以抛开数据曾德繁琐细节，专注于业务逻辑编码。
2. 数据访问底层实现的分离 DAO模式通过将数据访问计划分为抽象曾和实现曾，从而分离了数据使用和数据访问的地称实现细节。这意味着业务层与数据访问的底层细节无关，也就是说，我们可以在保持上层机构不变得情况下，通过切换底层实现来修改数据访问的具体机制，常见的一个例子就是，我们可以通过仅仅替换数据访问曾实现，将我们的系统部署在不同的数据库平台之上。
3. 资源管理和调度的分离 在数据库操作中，资源的管理和调度是一个非常值得关注的主题。大多数系统的性能瓶颈往往并非集中于业务逻辑处理本身。在系统涉及的各种资源调度过程中，往往存在着最大的性能黑洞，而数据库作为业务系统中最重要的系统资源，自然也成为关注的焦点。DAO模式将数据访问逻辑从业务逻辑中脱离开来，使得在数据访问层实现统一的资源调度成为可能，通过数据库连接池以及各种缓存机制(Statement Cache,Data Cache等，缓存的使用是高性能系统实现的一个关键所在)的配合使用，往往可以保持上层系统不变的情况下，大幅度提升系统性能。
4．数据抽象 在直接基于JDBC调用的代码中，程序员面对的数据往往是原始的RecordSet数据集，诚然这样的数据集可以提供足够的信息，但对于业务逻辑开发过程而言，如此琐碎和缺乏寓意的字段型数据实在令人厌倦。 DAO 模式通过对底层数据的封装，为业务曾提供一个面向对象的接口，使得业务逻辑开发员可以面向业务中的实体进行编码。通过引入DAO模式，业务逻辑更加清晰，且富于形象性和描述性，这将为日后的维护带来极大的便利。试想，在业务曾通过Customer.getName方法获得客户姓名，相对于直接通过SQL语句访问数据库表并从ResultSet中获得某个字符型字段而言，哪种方式更加易于业务逻辑的形象化和简洁化？
空洞地谈些理论固然没有什么价值，我们需要看到的是通过对应用设计模式之后，我们的代码到底有怎样的改观，进而才能对设计带来的优劣有所感悟。下面让我们来看看代码：
代码 Public BigDecimal calcAmount(String customerID,BigDecimal amount){ //根据客户ID获得客户记录 Customer customer = CustomerDAO.getCustomer(customerID); //根据客户登记获得打折规则 Promotion promotion = PromotionDAO.getPromotion(customer.getLevel()); //累积客户总消费额，并保存累计结果 Customer.setSumAmount(customer.getSumAmount().add(amount)); CustomerDAO.save(customer); //返回打折后金额 Return amount.multiply(promotion.getRatio()); } &lt;script&gt;render_code();&lt;/script&gt; 这样的代码相信已经足够明晰，即使对于缺乏数据库技术基础的读者也可以轻松阅读。 从上面这段代码中，我们可以看到，通过DAO模式对各个数据库对象进行封装，我们对业务层屏蔽了数据库访问的底层实现，业务曾仅包含与本领域相关的逻辑对象和算法，这样对于业务逻辑开发人员(以及日后专注于业务逻辑的代码阅读者)而言，面对的是一个简洁明快的逻辑实现结构。业务层的开发和维护将变得更加简单。 DAO模式中，数据库访问层实现被隐藏到Data Accessor中，前面说过，DAO模式实际上是两个模式的组合，即Data Accessor 和 Domain Object模式。 何谓 Data Accessor?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11342c5fe924704d0d3842a9707f489e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2fab2326a8278e8c52029b97afd041e/" rel="bookmark">
			常见网络诊断命令解析及示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见网络诊断命令解析及示例 Sailor_forever sailing_9806@163.com 转载请注明 http://blog.csdn.net/sailor_8318/archive/ 2008/12/06 /3460567.aspx 我们常常要检测服务器和客户机之间是否连接成功、希望检查本地计算机和某个远程计算机之间的路径、检查TCP/IP的统计情况以及系统使用DHCP分配IP地址时掌握当前所有的TCP/IP网络配置情况，以便及时了解整个网络的运行情况，以确保网络的连通性，保证整个网络的正常运行。 网络诊断的一个例子可见： http://blog.csdn.net/sailor_8318/archive/2007/08/03/1724477.aspx
http://blog.csdn.net/sailor_8318/archive/2008/04/16/2295603.aspx
以下是网络诊断的基本工具和步骤： 第一步：查看网络配置ipconfig 为了避免为一个个客户端分配静止的IP地址而增加工作量和减少重复分配的错误，在局域网中常常架设一台DHCP服务器，以便动态的、自动的为客户端分配IP地址。但是在网络维护和调试过程中，我们有时又需要知道当前所有TCP/IP网络配置信息，这时，ipconfig命令就显得很有意义。 其将显示所有网络适配器的完整配置信息，包括：主机名、所有DNS服务器列表、节点类型、系统的IP路由选择状态、IP地址、子网掩码等信息。该命令在运行 DHCP 系统上的特殊用途，允许用户查询DHCP 配置的 TCP/IP 配置值。 ipconfig [/all | /renew [adapter] | /release [adapter]] 参数 ：/all 显示所有网络接口状态 在没有该开关的情况下 ipconfig 只显示 IP 地址、子网掩码和每个网卡的默认网关值。 C:/Documents and Settings/dding&gt;ipconfig /all Windows IP Configuration Host Name . . . . . . . . . . . . : ding Primary Dns Suffix . . . . . . . : Node Type .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2fab2326a8278e8c52029b97afd041e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68186b9db6383b020e261064a6286172/" rel="bookmark">
			Netbeans 6.5 发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大半夜的真不容易，netbeans 6.5 已经正式发布了，今天下午的时候我还憨憨的去下了dev版。具体更新看这里。主要是是一直都在用开发版，所以看着发现不了什么明显的变化，其实和6.1相比还是... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfab0d898970a2a849158aeb6c6b44b0/" rel="bookmark">
			Tasque——RTM的linux客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 RTM就是Remember the milk，一个很受欢迎的任务管理服务，相关的client服务基本上都是属于pro account（付费账户）才能使用的，但是Tasque是一个免费的程序。 Tasque实现了RTM的基本功能，显示task... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ffbfc533eef1c8300ce423bce0f2075/" rel="bookmark">
			Nike广告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d2ec8200512e33907b760f2b4a00d0/" rel="bookmark">
			近期软件更新小节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这几个星期都在被WPF折腾，心里开始仇恨IBM，卖这么死贵的东西也不知道做得好点。 近日软件更新关注， Ubuntu 8.10 正式发布，这个要等我回来之后再进行更新。8.10和8.04对比其实没有... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92b90f4e72fda1ccdedf62223a8b9c93/" rel="bookmark">
			童话般的readme 文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载来源：http://linux.solidot.org/article.pl?sid=08/08/01/096205&amp;from=rss gnome-cups-manager是Gnome桌面中的打印机属性管理工具。但是它的自述文件（README File） 可能比程序本身更令人感兴趣： 很久很久以前，有一个打印机居住森林里。它很孤独，因为没人知道如何配置它。它希望有人能和它一起玩。 一天，风吹过打印机的小屋，“呼，呼”。打印机开始兴奋起来，也许风可成为它的朋友。 “你愿意做我的朋友吗？”打印机问。 “呼，呼”，风回答。 “什么意思”，打印机问。 “呼，呼”，风回答，它消失了。 打印机搞糊涂了，它把这天剩余的时间都花在思考上，打印纸被卡住了(小小打印机迷糊时就会这么做)。 第二天，一场暴风雨来临。大雨倾盆而下，使早晨的天空变暗，还破坏了打印机的花园。小小打印机很苦恼。“为什么这样对我？”它问。 “噼里啪啦，噼里啪啦，”雨回答。 “你将做我的朋友？”打印机害羞的问道。 “噼里啪啦，噼里啪啦，”雨回答。然后它离开了，太阳露出了脸。 打印机很悲伤，这天剩余的时间它都呆在里面，哭泣，悄悄的打着光信号（小小打印机悲伤时就会这么做）。 又有一天，一个小女孩无意闯入了打印机的领地。打印机看着这种奇特的情景，不知道怎么办。 “你愿意做我的朋友吗？”小女孩问。 “愿意，”打印机回答。 “你叫什么名字？”小女孩问。 “HP 4100TN”，打印机回答。 “我的名字叫gnome-cups-manager”，小女孩说。 打印机很快乐，剩下的时间它在玩和打印文档。小小打印机开心时就会如此。 And followed is the English version: gnome-cups-manager
——————
Once upon a time there was a printer who lived in the woods. He was a lonely printer, because nobody knew how to configure him. He hoped and hoped for someone to play with.
One day, the wind passed by the printer’s cottage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92b90f4e72fda1ccdedf62223a8b9c93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd440cd8300e9994e78bf0a25f72577d/" rel="bookmark">
			ajaxtags的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、ajax:links标签
相当于html中的&lt;a&gt;标签
例子:
&lt;ajax:links cssClass="test" targetId="ajaxFrame" sourceId="ajaxData"&gt;
&lt;a href="index.jsp" class="test" &gt; AjaxLink &lt;/a&gt;&lt;br/&gt;
&lt;a href="index.jsp" class="test2" &gt; This is not an AjaxLink&lt;/a&gt;
&lt;/ajax:links&gt;
&lt;div id="ajaxFrame"&gt;&lt;/div&gt;
ajax:links参数说明：
参数 参数说明 cssClass 可以使用在cssClass里定义过的样式 elementId 可以使用在elementId里定义过的elementId
sourceId 作为区分用的标记id targetId href页面在哪里显示 ajax:links中的a标签参数说明：
参数 参数说明
source 等同sourceId的功能 target 等同targetId的功能（如果是ajax链接） href 目标链接 必需的
2、ajax:autocomplete
自动弹出和输入的字符相同的一系列值，用下拉菜单的形式表示 例子:
&lt;ajax:autocomplete &gt;
&lt;input type="text" value="test" minimumcharacters="3" url="autocomplete.jsp?test={test}" autocomplete="on" id="test" /&gt;
&lt;/ajax:autocomplete&gt;
参数 参数说明
minimumCharacters 必须输入多少个字符以后才会执行自动完成功能
url 请求数据的地址
内部参数 参数说明
url 等同于url
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd440cd8300e9994e78bf0a25f72577d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee60b0d4c39f515e749647369b9ea9c/" rel="bookmark">
			程序员面试题精选（31）：从尾到头遍历链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：输入一个链表的头结点，从尾到头反过来输出每个结点的值。链表结点定义如下： struct ListNode { int m_nKey; ListNode* m_pNext; }; 分析：这是一道很有意思的面试题。该题以及它的变体经常出现在各大公司的面试、笔试题中。 看到这道题后，第一反应是从头到尾输出比较简单。于是很自然地想到把链表中链接结点的指针反转过来，改变链表的方向。然后就可以从头到尾输出了。反转链表的算法详见本人面试题精选系列的第19题，在此不再细述。但该方法需要额外的操作，应该还有更好的方法。 接下来的想法是从头到尾遍历链表，每经过一个结点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始输出结点的值，此时输出的结点的顺序已经反转过来了。该方法需要维护一个额外的栈，实现起来比较麻烦。 既然想到了栈来实现这个函数，而递归本质上就是一个栈结构。于是很自然的又想到了用递归来实现。要实现反过来输出链表，我们每访问到一个结点的时候，先递归输出它后面的结点，再输出该结点自身，这样链表的输出结果就反过来了。 基于这样的思路，不难写出如下代码： /// // Print a list from end to beginning // Input: pListHead - the head of list /// void PrintListReversely(ListNode* pListHead) { if(pListHead != NULL) { // Print the next node first if (pListHead-&gt;m_pNext != NULL) { PrintListReversely(pListHead-&gt;m_pNext); } // Print this node printf("%d", pListHead-&gt;m_nKey); } } 扩展：该题还有两个常见的变体： 1. 从尾到头输出一个字符串； 2. 定义一个函数求字符串的长度，要求该函数体内不能声明任何变量。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3871f3b53744dba02ee36348ca5350d2/" rel="bookmark">
			&lt;引&gt;Makefile教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 STLChina也是转帖的，不过排版比较好。所以就放置到它网站的链接。这篇教程写得很不错，看完一遍，最起码简单的Makefile写起来不是问题了。 [url=http://www.stlchina.org/twiki/bin/view.pl/ScriptProgram/LearnMakefile]Click and Go![/url] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be22b80c979f3c451e9bcdaedbcfaca/" rel="bookmark">
			Windows XP系统注册表的恢复(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows XP系统注册表的恢复(转)[@more@] 在备份了的情况下，我们可以通过以下五种方法对系统进行恢复！具体如下： A、用MS Backup恢复注册表
1．首先打开“开始/程序/附件/系统工具”菜单中的“备份”程序，程序运行后单击“还原”选项卡。
2．单击你以前创建的备份旁边的+号，再选中“系统状态”的复选框。
3．选择“工具”菜单中的“选项”，显示对话框。
4．在“还原”选项卡上选择“无条件替换计算机上的文件”单选框。
5．在“畚份日志”选项卡上，选择“详细数据”。
6．设置完成后按“确定”，返回程序主界面。并确定“将文件还原到”选项框中的选项“原位置”。
7．设置完成后，单击“开始还原”按钮，并确定弹出的“警告”对话框。
8．继续确定“确认还原”提示框。
9．在“输入备份文件名”后在对话框中单击“确定”。最后程序开始还原备份的饿注册表，完成后程序提示重新启动计算机时按“确定”
B、从复制的注册表进行恢复
你可以复制注册表，创建与注册表完全相同的拷贝文件，然后就可以把他们再复制到原先的位置。这种方法需要你使用第二个操作系统把那些注册表文件复制回来。用copy和 xcopy命令所做的注册表畚份需要用与畚份相反的方式进行恢复。按以下的步骤从已创建的畚份来恢复注册表：
1．启动另一个操作系统，对FAT用Windows XP/NT、DOS或Windows 98/Me：而对NTFS则使用Windows XP/NT.
2．为了防止根本不只注册表的问题，把当前注册表保存到安全的位置。
3．复制所保存的注册表到当前注册表的位置。
4．启动有疑问的Windows XP版本，并测试和观察所做的恢复是否正常工作。如果不是，请往下看。
C、使用Setup来恢复
Windows XP的Backup程序也把注册表保存到%SystemRoot%Repair的目录下，你今后可以使用Windows XP的Backup程序来恢复这个文件。从Repair目录和ASR硬盘正确的恢复系统注册表需要运行Windows XP的Backup程序。当Setup启动后，它将检查坏硬盘以及查找已经安装的Windows XP系统和他们的Repair目录。一旦检查完成，Setup将给出一些选项，其中包括按F2键以运行ASR。如果你不能运行ASR，Windows XP的Setup程序将给你三种选择：
1．现在开始安装Windows XP ，按Enter。
2．利用Recovery Console修复Windows XP，按R键。
3．终止安装Windows XP而退出Setup，按F3。
按R键选择修复选项，然后进入修复模式并继续进行，下一不屏幕显示四个选项，一般默认情况都为选中，你也可以根据需要选择。接下来Setup进行设备的检测，显示信息正被检测的设备，屏幕下方的状态显示器会显示出此过程。一旦注册表更新完成，Setup程序会提示你拿走启动器中的软盘并重新启动计算机。若一切正常，计算机将启动并正常运行。
D、加载一个.reg文件
你可以RegEdit用把注册表保存为一个带有.reg扩展名的文本文件。Windows XP 知道这是一个注册表文件。如果在文件浏览器或桌面上双击此文件，就会自动加载此文件到注册表。在命令提示状态下，输入命令start filename.reg，其中filename是注册表畚份文件的文件名。注意的是要确认所用的编辑器支持Unicode，Notepad写字板可以很好的工作。如果你不能启动或运行Windows，你就不能用这种方法。
为了修复的注册表起作用，必须重新启动 Windows XP（Windows XP在运行时高速缓存了大多数注册表内容）。只有重新启动之后，许多注册表的变化才被重新载入。
E、从磁带恢复注册表
你可以使用备份程序来复制注册表文件到一盘磁带或者其他连机或脱机的地方。该备份程序然后会把注册表文件恢复到原先的位置。这种方法很简单。
1．从磁带恢复
当你使用与Windows XP兼容的备份和恢复程序时，要确保所作的选择是恢复本地注册表，还要判断是恢复注册表唯一被破坏的文件，还是要恢复其他的文件。
2．从Backup所支持的其他介质上恢复
使用Windows XP的Backup程序从备份的列表清单中选择System State来进行恢复。System State含有三项内容：引导文件，COM+注册类和注册表（注：不可能部分恢复System State的数据，只能全部恢复它）。你的ASR备份 除了包括System State之外还包括其他的文件，你可以根据需要进行恢复。当Active Directory正在运行时，是不能恢复System State的。在大多数备份和恢复程序之间的主要差异是在用户界面和介质的兼容性方面。千万不要忘记，通常各种磁带只能用创建此磁带备份的相同程序来进行恢复工作。
来自 “ ITPUB博客 ” ，链接：http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4be22b80c979f3c451e9bcdaedbcfaca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/198118f83aaf91595c1482f7f828cfa0/" rel="bookmark">
			usertype的详细解释和使用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import net.sf.hibernate.HibernateException;
/**
* @author hy-he
*
*/
public interface UserType {
/**
* 返回UserType所映射字段的SQL类型（java.sql.Types)
* 返回类型为int[]，其中包含了映射个字段的SQL类型代码
* (UserType可以映射到一个或者多个字段)
* @return
*/
public int[]sqlTypes();
/**
* UserType.nullSafeGet()所返回的自定义数据类型
* @return
*/
public Class returnedClass();
/**
* 自定义数据类型的比对方法
* 此方法将用作脏数据检查，参数x、y分别为数据的两个副本
* 如果equals方法返回false,则Hibernate将认为数据发生变化,并将变化更新到数据库表中
* @param x
* @param y
* @return
* @throws HibernateException
*/
public boolean equals(Object x,Object y)throws HibernateException;
/**
* 从JDBC ResultSet读取数据,将其转换为自定义类型后返回
* (此方法要求对克能出现null值进行处理)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/198118f83aaf91595c1482f7f828cfa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a047438f5bcfc679aaa495c3df1e08/" rel="bookmark">
			iReport
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一系列的文章大概这样安排：前面两篇先对
iReport和JasperReport进行简单的介绍，目的是把值得注意的地方提一下，免得后来者少走弯路。后面的几个文章将详细介绍一个使用Struts+Hibernate+Spring+iReport+JasperReport+Oracle联合报表（两个父子表联合）的设计过程，以及交叉表的设计过程。 下面先是iReport的简单介绍，希望很多地方能通过一两句话就减少你大半天的摸索。
第一节．准备工作
首先要做的事情，是到官方网站http://ireport.sourceforge.net下载最新版本的iReport,目前我用的是iReport-1.3.1-windows-installer.exe，好象现在已经出了1.3.2。下载后和普通的软件一样点下一步安装，这些就不用多说了。
安装完毕后第一次打开时可能菜单会出些乱码，在Options-&gt;选项-&gt;general-&gt;语言，选择最上面的中文（中国），如果还不行的话就重启一下iReport一般都没问题了。
第二节．创建报表
可以通过文件-&gt;报表精灵按照提示一步步来新建一个报表，速度相当快，但那样能选择的样式比较少，而且往往不能符合我们的需求，到时候改起来也很痛苦。所以我主要介绍的是从零开始自己来设计的过程。
首先开启新档，填上报表名称、选好尺寸，如果要横向报表的话在“定位”那里选择“Landscape”。如果怕出现中文乱码问题，在i18n-&gt;XML编码，填上GB2312。其它的根据需要改改，然后OK。
新建的空白报表分为八个部分，具体每个部分的作用我就不多说了，网上的文章大把，找来看看，大概了解一下就可以。
第三节．连接数据源
以Oracle数据库为例。（因为在iReport里不管用什么作为连接，如jdbc,JavaBeans还是Hibernate等，生成的报表文件都是一样的，应用到项目中只要字段名对上号，用什么方法填充都可以。所以为了简单起见，建议这里用jdbc就行。笔者开始时为了Spring Loading Hibernate Connection作为连接花费了不少时间才成功，白费劲）
1． 添加Classpath。在Options-&gt;Classpath,，然后Add JAR，把ojdbc14.jar添加进来。
2． 连接/资料来源。在Data-&gt;连接/资料来源，然后new。随便填上Name，在Type of Connection选择DataBase JDBC connection，其它的填写如图3.1所示。记得有空把Sava Password的勾给打上。最后点击Test出现成功提示就可以Save了。
(图3.1)
3． 设定动态连接。在Data-&gt;设定动态连接，选择刚才填写的Name，点OK即可。
4． 报表查询。在Data-&gt;报表查询，填上查询的SQL语句，如图3.2，下面能出现字段名和字段类型就没问题。
(图3.2)
第四节．设计报表
1． 画线。如果需要画线，就选中该字段，右击-&gt;属性-&gt;Border,建议每个字段的左边和下边画上线，最后一字段就左边、下边和右边都画上线，这样就不会看上去两根线重复。
2． 自动变量。如果需要增加一个自动增加的序号，可在预览-&gt;报表变量，随便起个名字，变量类型选择java.lang.Integer，Caculation type选择Count，Reset type选择Report，其余的默认，完了以后把该变量拖拉到你喜欢的位置设计下就OK了。(如图4.1)
(图4.1)
3． 自动换行。如果不处理一下，有些字段的内容太长了就会显示不全。选中该字段，右击-&gt;属性，在Text Field把Stretch with overflow勾上。同时把该行所有的字段选上，右击-&gt;属性，在Common的Stretch Type选择Relative to tallest object。（如图4.2）
(图4.2)
4． 待补充。
还有很多细节，其实多用用就会熟悉了。
第五节．预览
点击建立，选择JRViewer预览，然后使用动态连接执行报表就可以了。
Trackback: http://tb.blog.csdn.net/TrackBack.aspx?PostId=1583763
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e046f3ecd2a6069c6cdd318167943660/" rel="bookmark">
			系统设计模式一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我要介绍的第一个模式,很多人应该都很熟悉，就是MVC。
在大师们的设计模式书籍中都有提及该模式。而我只是要总结一下，在系统设计中的应用。
MVC是Model/View/Control的缩写，指的是模型/视图/控制。
模型，通常我们指数据模型。
视图，我们指的是与用户的交互界面。
控制，我们指业务逻辑。
最经典的例子是MFC中的Document/View模型。该模型将业务逻辑混合在视图和模型之中，只是将视图与模型独立开。这样，你可以用折线图表示数据，也可以用表格表示数据，而不需要修改模型。这是我们在编程过程中对该模式最常使用的方式。
那么，我们还有别的使用方式吗？
答案是有的。
当我们把眼界从一个程序扩展到一个应用时，我们会发现MVC模式产生了一种魔法效应。让我们看看WinCVS、WinRAR这些应用。打开这些应用的文件夹，他们由几个应用程序组成，WinRAR，RAR，UnRAR。其中RAR、UnRAR就是模式中的MC。WinRAR就是模式中的View。用户在操作WinRAR压缩或解压缩文件的时候，实际是在调用RAR和UnRAR。你也可以直接使用RAR、UnRAR的命令行方式操作文件。
这种方式的好处在于，直接将开发者的关注焦点从繁琐的界面编程中解脱出来。把精力集中到真正的业务逻辑中去。并且使得交互界面逻辑独立、修改更方便。且不会影响业务核心。其实使用这种模式的不仅仅是小软件，如VC中的编译器与IDE系统的分离，也是该模式的经典例子。
让我们再把眼界放置到一个系统中。最为典型的莫过于Web系统。其首先是一个B/S模式（该模式后面应该还会专门提到），但它其实也是MVC模式。其服务器端的数据库正是MVC中的模型。而服务器端运行的PHP、JSP、ASP等脚本则是MVC中的控制。客户端的浏览器和页面就是MVC中的视图。在这个模型中，我和大多数人一样，都会有个误区，就是把视图中用于视图展现的逻辑归结为控制，如多级菜单的显示。其实这些都只是我们展现数据的方式，无论是用AJAX或者Frame框架或者别的什么花哨的技术，这些都只是数据展现的方式，而不是业务逻辑，所以它们都只是视图。在这里，我们使用MVC模式得到了分布式运算的好处。
其实在Vasta中，微软利用xaml和它的C#、VB更是把该模式发挥到了极致。有兴趣的，可以进一步研究一下。^_^！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbcd4d98b57ca6472b03571abc96e4ac/" rel="bookmark">
			datepart函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DatePart Basic 语法和 Crystal 语法。
重载 DatePart (intervalType, inputDateTime) DatePart (intervalType, inputDateTime, firstDayOfWeek) DatePart (intervalType, inputDateTime, firstDayOfWeek, firstWeekOfYear) 参数 intervalType 是一个字符串表达式，用来指定要返回的日期部分。可能的值为： 间隔类型值 说明 yyyy
提取年份
q
季度（结果是 1、2、3 或 4）
m
月（结果是从 1 到 12 之间的数)
y
一年中的某天（从 1 到 365，闰年是从 1 到 366）
d
日期的天部分（1 到 31）
w
一周中的某天（1 到 7，其结果取决于 firstDayOfWeek）
ww
一年中的某周（1 到 53，firstDayOfWeek 和 firstWeekOfYear 确定一年中第一个日历周的确切天数）
h
提取给定日期时间的小时部分（0 到 23）
n
分钟部分（0 到 59）
s
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbcd4d98b57ca6472b03571abc96e4ac/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/218/">«</a>
	<span class="pagination__item pagination__item--current">219/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/220/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>