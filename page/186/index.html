<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7babb727b875f1e58eb360fe0f2c90/" rel="bookmark">
			安装西门子博图总是提示重启电脑的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我所安装的软件为：SIMATIC STEP 7 Professional
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a4facda529307741badeb997abaf7d4/" rel="bookmark">
			多线程实现快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程排序，主要是将整个排序的序列分成若干份，每一个线程排序一份，所以线程排序完成之后，就进行归并，相当于多个有序序列合并成一个有序序列。
这里就需要用到线程屏障，也就是 pthread_barrier 系列函数。
屏障，通俗的说就是一个比赛跑步的过程，所以队员就绪了，才能进行比赛。
多线程排序也是，需要每个线程都是排序完成后，才能进行合并的过程。
代码：
#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;sys/time.h&gt; #include &lt;pthread.h&gt; #include &lt;algorithm&gt; using namespace std; const long MAX = 1e7L; // max num in array const long long MAX_NUM = 1e8L; // num of element to sort const int thread = 100; const int thread_num = MAX_NUM / thread; int num[MAX_NUM]; int tmp_num[MAX_NUM]; pthread_barrier_t barrier; // barrier //Initialized Data void init() { srand(1); for (int i = 0; i &lt; MAX_NUM; ++i) { num[i] = rand() % MAX; } } //Quick sort function void qsorts(int* start, int* end) { int nums = end - start; if (nums &gt; 0) { int flag = start[0]; int i = 0; int j = nums; while (i &lt; j) { while (j &gt; i &amp;&amp; start[j] &gt; flag) { --j; } start[i] = start[j]; while (i &lt; j &amp;&amp; start[i] &lt;= flag) { ++i; } start[j] = start[i]; } start[i] = flag; qsorts(start, start + i - 1); qsorts(start + i + 1, end); } } void* work(void* arg) { long index = (long)arg; qsorts(num+index, num+index+thread_num-1); pthread_barrier_wait(&amp;barrier); pthread_exit(NULL); } void meger() { long index[thread]; for (int i = 0; i &lt; thread; ++i) { index[i] = i * thread_num; } for(long i = 0; i &lt; MAX_NUM; ++i) { long min_index; long min_num = MAX; for(int j = 0; j &lt; thread; ++j) { if((index[j] &lt; (j + 1) * thread_num) &amp;&amp; (num[index[j]] &lt; min_num)) { min_index = j; min_num = num[index[j]]; } } tmp_num[i] = num[index[min_index]]; index[min_index]++; } } int main(int argc, char *argv[]) { init(); struct timeval start, end; pthread_t ptid; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a4facda529307741badeb997abaf7d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9530ee4cd36a6c140b089fe5bcc3bc99/" rel="bookmark">
			Linux -- 基础命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 命令的用法：
命令名 【功能选项】【源操作对象】【目标操作对象】
常用基本命令： 1） ls 显示目录或文件
-a 列出目录下所有文件包括以 . 开头的隐藏文件-d 将目录像文件一样显示，但不显示其下文件-i 列出文件并显示 inode 号-r 逆序打印-l 列出文件的详细信息-k 以k字节的形式表示文件的大小-n 用数字UID, GID代表名称-F 在每个文件名后面附一个字符说明该文件的类型 2）pwd 显示用户当前所在的目录
3）cd 进入指定目录
cd **…**返回上级目录cd ~ 进入家目录cd / 进入根目录cd - 返回最近访问目录 4）touch 刷新文件的时间戳，如果这个文件不存在，则创建这个文件
-a 只更改存取时间-c 不创建任何文档-d 指定日期时间 5 )mkdir 创建一个目录
-p 递归创建多个目录
mkdir -p testspace/test/test1
//如果没有这个目录将从第一个目录递归创建这三个目录
6）rmdir &amp;&amp; rm
rmdir 删除目录 -p 如果这个目录被删除后父目录为空，就把父目录一并删除。
rm 可以删除文件或目录
-r 递归删除
-f 忽略提示信息删除
7）cp 拷贝一个文件到指定目录下
-f 强制复制-i 覆盖文件之前询问用户-r/R 递归处理 8）man 查看帮助
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9530ee4cd36a6c140b089fe5bcc3bc99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f538bc8b43ea0e955f02a73208b451/" rel="bookmark">
			面试题总结（工作经验1年，应聘前端开发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过漫长的找工作之旅，终于定下来了。怎么说呢，过程很艰苦，结局是美好的。
下个月入职，享受最后休闲的时光，总结一下所遇到的前端面试题。
。。。下面的我会慢慢补充并且把罗列的问题对应的答案一点一点整理起来
基础：（我基础太差，恶补了一段时间，还是不行。。。。所以，就算上班了，还是要看看基础，不能专顾手头的工作）
html：
关于html，会问一下html5新增了哪些特性，又淘汰了哪些特性。
增加：查阅 http://www.w3school.com.cn/html5/html5_reference.asp
1、音频（之前做微信H5动画比较多，音频算是比较常用的）
2、视频（同上，关于微信H5，它提供了很多参数，查阅 https://www.jianshu.com/p/ad2c0057d0ff ）
3、canvas（将图片转成Base64编码格式，长按保存、画图。。。）
4、SVG（准备学习的一块）
5、地理定位（我之前写过一篇百度地图，有提及https://blog.csdn.net/belove_lucy/article/details/88575363）
6、Web存储（面试题：localStorage、sessionStorage、session、cookie 区别 ）
7、input 类型、元素、属性增加
8、。。。其他，还有些我不太熟就没罗列出来，在上面W3school都有提及
淘汰：主要淘汰了些标签…文档中有标注，我比较经常用的,其他都没怎么接触过
css：
css问的不多，最主要的是对盒子模型的理解，我觉得关键是普通浏览器的盒子模型和IE特殊的盒子模型、box-sizing属性以及如何使特殊的ie模型兼容。
* { box-sizing: content-box; margin: 0; padding: 0; } 其他就类似实现居中的方法：不同position下的居中、不定长宽的居中
js：
ES6的新特性：查阅http://www.runoob.com/w3cnote/es6-tutorial.html
1、promise（原理、作用、单任务、多任务的实现方法。。。又可能还会问到栈的概念，毕竟多任务是存储在栈内的）
2、let、const（let、const、var 区别）
3、解构（参数解构）
4、字符串增加新方法
5、数组增加新方法
6、箭头函数（主要是this指向）
7、。。。其他
其他：
1、call、apply、bind相同点和不同点
2、函数类型
概念问题：
1、优雅降级、渐进增强（渐进增强相当于向上兼容,而优雅降级相当于向下兼容）
2、函数提升、变量提升
3、css 优先级
4、元素塌陷
如果有些地方描述的不对，请大家提出，好改正，谢谢 ^ ^
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b54d0e048ab93f3fd8ad7f4a81e273/" rel="bookmark">
			DELL服务器安装完系统后出现OEMDRV盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DELL服务器安装完系统后出现OEMDRV盘。 解决方法：重启进F10--EXIT退出（什么操作都不用做。），重启即可。 或者不理它，它迟早会消失的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87d9998de61c007b65c0cc0130ab53df/" rel="bookmark">
			Xshell家庭/学校免费版下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		填写姓名和邮箱，去邮箱链接下载免费版
地址：https://www.netsarang.com/zh/free-for-home-school/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfc1136a02f97108c8331264ac925442/" rel="bookmark">
			Win10下安装elasticsearch6.5.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装ES 1.安装JDK 2.下载elasticsearch6.5.0 下载速度似乎好慢，我是直接到官网拷贝下载地址在阿里服务器上下载后再拷贝到本地的~
3.解压下载文件，修改配置文件config/elasticsearch.yml cluster.name: my-application http.port: 9200 http.cors.enabled: true http.cors.allow-origin: "*" node.master: true node.data: true 4.运行bin/elasticsearch.bat 即可启动 启动 启动成功 安装Elasticsearch-head 下载Head源码 github下载地址
安装node.js node环境安装我这就不详细介绍了，到网上下载个新版的node安装文件安装一下(我装的是node-v10.7.0-x64.msi)。然后解压刚刚下载的head源码到文件夹(直接clone的就不用解压了)
安装依赖 1.在head文件夹目录打开cmd(用前段工具打开也行，开心就好)
2.安装依赖(建议内有配置国内镜像的先配置一下)
npm config set registry https://registry.npm.taobao.org // 配置后可通过下面方式来验证是否成功 npm config get registry // 安装相关依赖 npm install 3.安装grunt
npm install -g grunt-cli 4.修改head配置（如果安装在同一台机就不用了）
我这里是在一台机上安装使用的，其实也是可以在不同主机上安装elasticsearch和head，不过如果在不同主机安装的话就要修改一下head配置，服务器的话还要注意对外端口的访问限制，以及开放外网访问权限
Gruntfile.js
_site/app.js
启动head npm run start 查看 注：
1.这里只要出现集群健康值:yelloe就对了，因为我创建了一个索引，所以会有上面的“5 of 10”.
2.分词插件这里没有写，其实只要下载好解压到plugins目录下analysis-ik文件夹(新建一个)就可以
参考原创博客：
win10下安装elasticsearch6.5.0
Elasticsearch初步使用(安装、Head配置、分词器配置)
Elasticsearch权威指南（中文版）
—&gt;现在开始自己也可以开始创建索引、查询、更新、删除~~~~一步一步学习，有不足请多多指点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce2cf498fe4290c64d944ed10cdd9cb5/" rel="bookmark">
			unity对于window下的资源管理器的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中，在做项目插件的时候涉及到了对资源管理器的一些基本操作，这里主要讲下在window下对资源管理器的选择，打开，保存的三个基本操作。
一、对指定文件的路径选择
/* * 选择某个文件夹 */ [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)] public class SelectFile { public IntPtr hwndOwner = IntPtr.Zero; public IntPtr pidlRoot = IntPtr.Zero; public String pszDisplayName = null; public String lpszTitle = null; public UInt32 ulFlags = 0; public IntPtr lpfn = IntPtr.Zero; public IntPtr lParam = IntPtr.Zero; public int iImage = 0; } public class SelectFileLog { [DllImport("shell32.dll", SetLastError = true, ThrowOnUnmappableChar = true, CharSet = CharSet.Auto)] public static extern IntPtr SHBrowseForFolder([In, Out] SelectFile ofn); [DllImport("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce2cf498fe4290c64d944ed10cdd9cb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2281b13e60ff281befb4341c1d6fea16/" rel="bookmark">
			vue.js 动态文字向上滚动广播中奖信息代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌳🌳🌳个人博客：Harvey的个人博客 🌲🌲🌲
效果如图
&lt;template&gt; &lt;div class="roll-msg"&gt; &lt;div class="popup"&gt; &lt;div class="box"&gt; &lt;ul class="lb" :class="{marquee_top:animate}"&gt; &lt;li v-for="(item, index) in list" &gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props:['list'], data() { return { animate: false, list: ["恭喜***asdasdas获得10积分", "恭喜***获得20积分", "恭喜***获得40积分"] }; }, methods: { }, mounted() { let that = this; const timer = setInterval(() =&gt; { this.animate = true; setTimeout(() =&gt; { that.list.push(this.list[0]); that.list.shift(); that.animate = false; console.log(Math.random()); }, 500); }, 3000); // 通过$once来监听定时器，在beforeDestroy钩子可以被清除。 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2281b13e60ff281befb4341c1d6fea16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f9977b2d4675f202c7bb341d83796e1/" rel="bookmark">
			Netty客户端发送消息并同步获取结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户端发送消息并同步获取结果，其实是违背Netty的设计原则的，但是有时候不得不这么做的话，那么建议进行如下的设计：
比如我们的具体用法如下：
NettyRequest request = new NettyRequest(); request.setRequestId(UUID.randomUUID().toString()); request.setClassName(method.getDeclaringClass().getName()); request.setMethodName(method.getName()); request.setParameterTypes(method.getParameterTypes()); request.setParameterValues(args); NettyMessage nettyMessage = new NettyMessage(); nettyMessage.setType(MessageType.SERVICE_REQ.value()); nettyMessage.setBody(request); if (serviceDiscovery != null) { serverAddress = serviceDiscovery.discover(); } String[] array = serverAddress.split(":"); String host = array[0]; int port = Integer.parseInt(array[1]); NettyClient client = new NettyClient(host, port); NettyMessage nettyResponse = client.send(nettyMessage); if (nettyResponse != null) { return JSON.toJSONString(nettyResponse.getBody()); } else { return null; } 先来看看NettyClient的写法 和 send方法的写法：
public class NettyClient { /** * 日志记录 */ private static final Logger logger = LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f9977b2d4675f202c7bb341d83796e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f6650269b86e391433bb2fd9e667b8/" rel="bookmark">
			关于python传参引发的一些思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人总有不会的，遇到一些问题深究下去必定有所收获
这个问题是在我写python爬虫项目的时候的疑问，可能是我太菜了(以前没学透彻)，也可能是上学期学Java的时候按值传递的特点给搞混了，因为当时在用多线程的生产者消费者问题处理资源队列，参考别人代码的时候突然蒙了一下，但后来查了查资料发现原来是下面的原因，值得记录一下坑点，顺便当复习，对语言有个更深入的理解也挺好的
前置的一些知识 在python里面一切皆为对象，而这个对象分成两种类型，第一种是可变的，另外一种是不可变的。
按值传递：会在堆中建立一个新的副本，以后操作只对副本操作，对原来主函数里面的值不影响。
按引用传递：会在堆中建立一个地址的引用，也就是参数的地址，一旦改变这个值就会把主函数里面的变量也会改变。
做一些验证 这里我以参考的代码里面的一部分进行验证，这里用类去类比一下函数，一样的效果，通过id参数打印一下地址
class Consumer(object): def __init__(self,page_queue,*args,**kwargs): super(Consumer, self).__init__(*args,**kwargs) self.page_queue = page_queue print(id(self.page_queue)) def main(): page_queue = 1 print(id(page_queue)) c = Consumer(page_queue) if __name__ == '__main__': main() 输出结果是这样的
140722209422880 140722209422880 可以发现两处的地址是一样的，可以脑补一下图应该是这样的，好像是引用传值，到底是不是这样的呢？
再来一段代码验证
class Consumer(object): def __init__(self,page_queue,*args,**kwargs): super(Consumer, self).__init__(*args,**kwargs) self.page_queue = page_queue print(id(self.page_queue)) self.page_queue += 1 print(id(self.page_queue)) print(id(page_queue),page_queue) def main(): page_queue = 1 print(id(page_queue)) c = Consumer(page_queue) if __name__ == '__main__': main() 结果是这个样子的
140722209422880 140722209422880 140722209422912 140722209422880 1 可以发现，以本来引用的常规思路去看的话，这样的操作应该会对同一个地址的东西修改了才对，你会发现，他重新开辟了一个新的空间去容纳新的值，原来传进去的参数没有存在任何影响，脑补一下这个图，现在变成了这样，跟平常的引用是不是有点不一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1f6650269b86e391433bb2fd9e667b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349644353c0f9af30fc40cea901cfe58/" rel="bookmark">
			电脑版微信每天自动发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.电脑24小时不关机，微信一直在线，将发送对象激活成单独窗口，并将任务栏图标置于第一格的位置，如下：
横坐标约190左右。
2.编写程序代码。（附后）
3.将代码打包成exe.
4.设定计划任务。
搞定。
附代码：
# coding = utf-8
import win32api,win32gui,win32con
import win32clipboard as clipboard
import time
from PIL import Image
from io import BytesIO #python3,新增字节流
import requests
###############################
# 微信发送（文本及图片）
###############################
#定义指定图片文件复制到剪贴板函数##########
def pic_ctrl_c(pathfile):
img = Image.open(pathfile)
output = BytesIO()#如是StringIO分引起TypeError: string argument expected, got 'bytes'
img.convert("RGB").save(output, "BMP")# 以BMP格式保存流
data = output.getvalue()[14:]#bmp文件头14个字节丢弃
output.close()
clipboard.OpenClipboard() #打开剪贴板
clipboard.EmptyClipboard() #先清空剪贴板
clipboard.SetClipboardData(win32con.CF_DIB, data) #将图片放入剪贴板
clipboard.CloseClipboard()
return
def send_m():
# 以下为“CTRL+V”组合键,回车发送，（方法一）
win32api.keybd_event(17, 0, 0, 0) # 有效，按下CTRL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/349644353c0f9af30fc40cea901cfe58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f713dbbd96e1a23b3ef28e38071fa2f/" rel="bookmark">
			MATLAB使用窍门——常用快捷键和调试程序的快捷键使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客 https://blog.csdn.net/u010493489
邮箱 lilin001@tyust.edu.cn
欢迎交流
MATLAB使用窍门 一、常用调试快捷键。 (1) 设置或清除断点：F12。
(2) 执行：F5。
(3) 单步执行：F10。
(4) step in：F11。单步执行，且碰到function跳入函数内执行，F10则不会跳入。
(5) step out：Shift+F11。跳入function之后，通过该指令推出function
(6) 退出调试模式：F5。执行相邻两次断点见的所有指令，如：断点在for循环中，则F5一次，循环执行一次
(7) 观察变量或表达式的值：将鼠标放在要观察的变量上停留片刻
（8）局部执行。（快捷键：F9）
如果希望对某一部分代码，进行调试，则完全没有必要每次都从头运行，这时局部执行较方便。
仍是这段代码，如果希望仅仅执行高亮部分，则箭头选中并按F9，此时程序仅仅运行高亮部分，可利用这个方法调试局部代码。
（9）打印变量
去掉所要打印变量的分号即可。
（10) 配合绘图 （快捷键：Crtl + D，可以选中某个变量，快速打开在窗口）
用图形比较容易观察，选中所选变量，在绘图区 可以任意选择所需图像，来进行观察
二、 matlab 快捷键使用 （1) Tab 键 输入一个命令前几个字符，Tab之后，会看到所有命令，回车，自动补全。
Tab (Ctrl + 】) 增加缩进
Ctrl +[ 减少缩进
（2) Ctrl + C 将运行得程序停止
（3) Ctrl + R 注释 可多行
（4) Ctrl + T 去掉注释
（5) Ctrl + I 自动对齐程序，自动排版
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f713dbbd96e1a23b3ef28e38071fa2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/755635fe9d448037aa473c62756a5286/" rel="bookmark">
			每次打开终端都需要source ~/.bashrc问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux配置文件执行顺序为：
/etc/profile→ (~/.bash_profile | ~/.bash_login | ~/.profile)→ ~/.bashrc →/etc/bashrc → ~/.bash_logout
假如在~/.bash_profile文件中没有下面的代码：
if [ -f ~/.bashrc ] ; then source .bashrc fi 那么linux就不会自动执行~/.bashrc文件，所以你每次登陆的时候都要手动输入source ~/.bashrc。
所以需要vi ~/.bash_profile 添加代码块中的内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5316271be8bf0b1b64d2c576fecf394f/" rel="bookmark">
			nginx安装及部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 官方网站：https://nginx.org/en/download.html
Windows下安装 安装 下载后解压（切记不能含有中文路径！！），文件结构如图（我解压的路径就有中文，记得拷贝放置于英文目录下即可！）：
启动 两种方法：
1） 直接双击该目录下的"nginx.exe"，即可启动nginx服务器；
2） 命令行进入该文件夹，执行start nginx命令，也会直接启动nginx服务器。
验证 开浏览器，输入地址：http://localhost，访问页面，出现如下页面表示访问成功。
Nginx Windows基本操作指 启动服务：start nginx 退出服务：nginx -s quit 强制关闭服务：nginx -s stop 重载服务：nginx -s reload　（重载服务配置文件，类似于重启，服务不会中止） 验证配置文件：nginx -t 使用配置文件：nginx -c "配置文件路径" 使用帮助：nginx -h Linux下安装 Nginx依赖包 模块依赖性Nginx需要依赖下面3个包
ssl功能需要 openssl 库 ( 点击下载 )gzip模块需要 zlib 库 ( 点击下载 )rewrite模块需要 pcre 库 ( 点击下载 ) 依赖包安装顺序依次为：openssl、zlib、pcre, 最后安装Nginx包。
安装教程（源码安装） step 1：下载所需包 openssl-fips-2.0.2.tar.gz zlib-1.2.7.tar.gz pcre-8.21.tar.gz nginx-1.12.2.tar.gz step 2：安装OpenSSL [root@localhost wcw]# tar -zxvf openssl-fips-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5316271be8bf0b1b64d2c576fecf394f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af3dc7a9f7d6b2e7cf8f747c42dfdc46/" rel="bookmark">
			Vue 中 import from @ 是什么意思？怎么配置？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**🌳个人博客🌲：[Harvey的个人博客](http://xhliu.top)**
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa51841e2b374257ab9f0a4699d58b1b/" rel="bookmark">
			UE4读写JSON数据介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON 语法是 JavaScript 对象表示法语法的子集。
数据在名称/值对中：名称是字符串，使用双引号表示。值可以是：数字（整数或浮点数），字符串（在双引号中）,数组（在方括号中）,对象（在花括号中），true/false/null。数据由逗号分隔：花括号保存对象：对象可以包含各种数据，包括数组。方括号保存数组：数字可以包含对象。 使用中，json有以下三种结构：
对象：{"Name":"ChenHong","Age":24}数组：比如：[{"Name":"ChenHong","Age":24},{"Name":"LiuHong","Age":25}]值：{"Name":"ChenHong", "Birthday":{"Month":8,"Day":26}}，类似于对象嵌套对象. 很多人疑惑{}和[]形式的区别。看到一段很经典的总结：大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。
JsonTests.cpp介绍许多 Json读写例子：
// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved. #include "CoreMinimal.h" #include "Misc/AutomationTest.h" #include "Policies/CondensedJsonPrintPolicy.h" #include "Serialization/JsonTypes.h" #include "Serialization/JsonReader.h" #include "Policies/PrettyJsonPrintPolicy.h" #include "Serialization/JsonSerializer.h" #if WITH_DEV_AUTOMATION_TESTS /** * FJsonAutomationTest * Simple unit test that runs Json's in-built test cases */ IMPLEMENT_SIMPLE_AUTOMATION_TEST(FJsonAutomationTest, "System.Engine.FileSystem.JSON", EAutomationTestFlags::ApplicationContextMask | EAutomationTestFlags::SmokeFilter ) typedef TJsonWriterFactory&lt; TCHAR, TCondensedJsonPrintPolicy&lt;TCHAR&gt; &gt; FCondensedJsonStringWriterFactory; typedef TJsonWriter&lt; TCHAR, TCondensedJsonPrintPolicy&lt;TCHAR&gt; &gt; FCondensedJsonStringWriter; typedef TJsonWriterFactory&lt; TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt; &gt; FPrettyJsonStringWriterFactory; typedef TJsonWriter&lt; TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt; &gt; FPrettyJsonStringWriter; /** * Execute the Json test cases * * @return	true if the test was successful, false otherwise */ bool FJsonAutomationTest::RunTest(const FString&amp; Parameters) { // Null Case { const FString InputString = TEXT("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa51841e2b374257ab9f0a4699d58b1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92d977e0a38ddf64d861902ff3127c9/" rel="bookmark">
			C/C&#43;&#43;语言中的int a; int* a; int** a; int (*a)[]; int (*a)(int)，重点介绍指针数组与数组指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一部分往往很少被总结，但是却经常用到，在使用的时候要注意区分。
先来一个基本的来入门吧！
参考自：
https://blog.csdn.net/qq_36744540/article/details/79832728
数组指针 首先，我们先介绍一下二维数组和二维数组的指针，二维数组相当于一个特殊的一维数组里面每个元素又是一个一维数组，例如：int a [ 3 ] [3]，可以看成一个3行的一个列数组，每一列的元素又是一个长度为3的数组，数组名的一个特殊一维数组的首地址，如下：
a（第0行的首地址，也是可以是＆a [0]）指向a [0]，对0行首地址元素的引用就有 a = a [0];
a + 1（第一行的首地址）指向a [1]，有（a + 1）= a [1];
a + 2（第二行的首地址）指向a [2]，有*（a + 2）= a [2];
a + i（第i行的首地址）指向一个[i]中，有*（a + 1）= a [i]中。
而a[0],a[1],a[2]又是里面一维数组的数组名，因此a[i]可表示i行的首地址：
a[0]（第0行第0个元素的地址）指向一个[0] [ 0 ]，有*（a [ 0 ] +0）= a [0] [ 0 ];
a [0]+1（第0行第1个元素的地址）指向a [0] [1]，有*（a [0] +1）= a [0] [1];
a [0] +2（第0行第2个元素的地址）指向a [0] [2]，有*（a [0] +2）= a [0] [2]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b92d977e0a38ddf64d861902ff3127c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc2d1ac1597c3ea496a749463709252/" rel="bookmark">
			！！！！！！！！测试基础知识 ！！！！！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找实习工作的过程中总结了下测试基础知识，编程能力重要，测试基础同样重要，希望对大家有帮助
软件测试方法：静态测试和动态测试
白盒测试和黑盒测试
传统测试与面向对象测试
软件测试过程：单元测试，集成测试，系统测试，验收测试
按测试类型：功能、性能、界面、易用性测试、兼容性测试、安全性测试、安装测试
（单元测试：在编码过程中，对每个小程序单元测试）
（集成测试：将单元集成在一起后，可称为组件）
回归测试、冒烟测试、随机测试
（冒烟测试：是指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。专门针对某一项功能的测试---主干功能）
测试流程：编写测试计划，编写测试用例，搭建测试环境，，实施测试，测试评估，测试总结。
测试计划：就是在测试实施之前确定测试对象，并对测试对象进行资源，时间，风险，测试范围，预算等方面的综合分析。
测试计划的内容：简介，项目说明，范围，测试手段和策略，项目通过和失败的标准，暂停/重启测试的标准，测试任务分配，职责等等
测试用例三要素：测试步骤，输入数据，期望结果
测试用例内容：项目名称，测试环境，预置条件，用例编号，测试步骤，输入数据，预期结果。
测试数据是写好测试用例的关键？
测试用例内容，写好测试用例的关键
功能测试，性能测试
黑盒测试（也称为功能测试或数据驱动测试） 黑盒测试分为：等价类划分法，边界值分析法，因果图法，决策表法，正交实验法，场景法，错误推测法，常用控件测试（文本框，按钮，单选按钮，复选框）（要知道各种方法的实际应用场景）
黑盒测试在程序接口进行测试，只检查程序功能是否按规格说明书的规定正常用，也被称为用户测试。
集成测试/系统测试/验收测试：黑盒测试
黑盒测试与软件的实现过程无关，在软件实现过程发生变化时，测试用例仍可使用
黑盒测试用例的设计可以和软件实现同时进行，这样能够压缩总的开发时间
等价类划分法：有效等价类，无效等价类（计算1-100之间的和，登录注册对密码位数的要求）
设计一个新用例，使它能够覆盖尽量多尚未覆盖的有效等价类，重复该步骤，直到所有有效等价类均被用例覆盖
设计一个新用例，使它仅覆盖一个尚未覆盖的无效等价类，重复该步骤，直到所有无效等价类均被用例覆盖
三角形测试用例
题目：输入三个数a、b、c分别作为三边的边长构成三角形。通过程序判定所构成的三角形是一般三角形、等腰三角形还是等边三角形时。用等价类划分方法为该程序设计测试用例。
在三角形计算中，要求三角形的三个边长：A B C。
1、 当三边不可能构成三角形时提示错误，可构成三角形时计算三角形周长。
2、若是等腰三角形打印“等腰三角形”， 若两个等腰的平方和等于第三边平方和，则打印“等腰直角三角形”。
3、若是等边三角形，则打印：“等边三角形”。
4、画出程序流程图并设计一个测试用例。
（三角形问题复杂之处在于输入与输出之间的关系比较复杂）
一、等价类划分法：大多数从输入域划分等价类，此处可从输出域划分等价类，且为最简单的方法。有五种可能的输出情况，一般三角形，等腰三角形，等腰直角三角形，等边三角形，非三角形
R1={&lt;a,b,c&gt;:边为a,b,c的等边三角形}
R2={&lt;a,b,c&gt;:边为a,b,c的等腰三角形}
R3={&lt;a,b,c&gt;:边为a,b,c的等腰直角三角形}
R4={&lt;a,b,c&gt;:边为a,b,c的一般三角形}
R5={&lt;a,b,b&gt;:a,b,c构不成三角形}
用例编号
a
b
c
预期结果
01
3
3
3
等边三角形（R1）
02
2
2
3
等腰三角形（R2）
03
3
4
5
等腰直角三角形（R3）
04
5
6
8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc2d1ac1597c3ea496a749463709252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98228862937eb6277a3b0f6633140638/" rel="bookmark">
			Oracle与OpenJDK之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在本文中，我们将探讨Oracle Java Development Kit和OpenJDK之间的差异并进行比较。
Oracle JDK Oracle JDK由Oracle公司开发，该公司是Sun许可证，基于Java标准版规范实现。它以二进制产品的形式发布。它支持多种操作系统，如Windows，Linux，Solaris，MacOS等。它支持不同的平台，如Intel 32位和64位架构，ARM架构和SPARC。它完全基于Java编程语言。之后，该许可证宣布将根据GPL（通用公共许可证）许可证发布。Oracle JDK包含许多组件作为库形式的编程工具集合。
我们来看看Java SE的历史：
JDK Beta - 1995JDK 1.0 - 1996年1月JDK 1.1 - 1997年2月J2SE 1.2 - 1998年12月J2SE 1.3 - 2000年5月J2SE 1.4 - 2002年2月J2SE 5.0 - 2004年9月Java SE 6 - 2006年12月Java SE 7 - 2011年7月Java SE 8（LTS） - 2014年3月Java SE 9 - 2017年9月Java SE 10（18.3） - 2018年3月Java SE 11（18.9 LTS） - 2018年9月Java SE 12（19.3） - 2019年3月 注意：不再支持斜体版本。
我们可以看到Java SE的主要版本大约每两年发布一次，直到Java SE 7.从Java SE 6开始花了五年时间，之后又花了三年时间到达Java SE 8。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98228862937eb6277a3b0f6633140638/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/185/">«</a>
	<span class="pagination__item pagination__item--current">186/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/187/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>