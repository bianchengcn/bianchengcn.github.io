<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b275fae0dba5da0dd8d4914d746e78db/" rel="bookmark">
			「自动搬运&#43;CDN」FFmpeg &#43; x264 t_mod &#43; x265 yuuki
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用笔者编写的ReleaseDelivr，基于 Jsdelivr + GitHub Actions 自动搬运且提供API，详情见 https://github.com/One-Studio
FFmpeg Win64位：最新版
Mac64位： 最新版 稳定版
Linux64位：最新版 稳定版
x264 tmod (t_mod) Win64位：最新版
x265 yuuki Win64位：最新版
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ebad66546d5c990f078d5b253215a90/" rel="bookmark">
			怎么彻底重装清空电脑_怎么在清空硬盘后来重装系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑系统中的硬盘但是有分盘符的，我们一般是需要按照类型的不同来决定放置的位置，出现一直乱放的情况就会导致硬盘文件乱七八糟的，就像将很多不必要的文件放置在c盘就会导致电脑卡顿。出现这样的问题要重装系统时我们需要先清空硬盘再来操作重装系统，下文小编会分享操作步骤。
如果你的电脑出现中毒的情况也可以先清盘之后在重装电脑。
一、安装准备
1、备份重要的数据，可拷贝到云盘中或移动硬盘中
2、win7系统下载：www.xitongzu.net
3、4G 左右U盘
二、清空全盘硬盘再装系统教程：
1、在电脑上插入制作好的U盘启动盘，启动后不停按F12或F11或Esc等快捷键选择从U盘启动，不同电脑按键不一样；
2、从U盘启动进入到这个菜单，通过方向键选择【02】选项回车，启动pe系统，无法进入则选择【04】旧机子版，适合老旧机子；
3、进入到pe系统，双击打开【分区工具】，右键点击硬盘，选择【快速分区】；
4、重新设置分区数目和分区的大小，C盘建议50G以上，如果是固态硬盘，勾选“对齐分区”，默认2048扇区即可4k对齐，不是固态不需要勾选，点击确定，执行硬盘格式化以及重新分区过程，完成分区之后；
5、打开【最快装机】，映像路径选择系统iso镜像，此时会自动提取gho文件，点击下拉框，选择gho文件，然后点击“还原分区”，选择系统安装位置，一般是C盘，pe下盘符可能显示错乱，如果不是显示C盘，可以根据“卷标”、磁盘大小选择，点击确定；
6、转到这个界面，执行系统安装到C盘的操作，这个过程需要5分钟左右；
7、操作完成后电脑会自动重启，此时拔出U盘，重新启动进入这个界面，继续进行安装系统组件、驱动和配置过程；
8、在启动进入全新系统桌面后，C盘格式化U盘装系统过程结束。
此时进入系统你就能发现所有硬盘里的文件都被清空了，就算是中了病毒也会被一起还原掉，之后就可以重新进行规划自己的硬盘如何分类。
看完上述的内容小伙伴们应该都已经了解清楚了吧，有需要的小伙伴之后就可以自行操作了，更多资讯请继续关注系统族。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25809410ce3238033431b4834df0738a/" rel="bookmark">
			vue调用打印机（vue-print-nb）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过npm 安装插件
1，安装 npm install vue-print-nb --save
2，引入 安装好以后在main.js文件中引入
import Print from 'vue-print-nb' Vue.use(Print); //注册
3，现在就可以使用了
&lt;div id="printTest" &gt; &lt;p&gt;锄禾日当午&lt;/p&gt; &lt;p&gt;汗滴禾下土 &lt;/p&gt; &lt;p&gt;谁知盘中餐&lt;/p&gt; &lt;p&gt;粒粒皆辛苦&lt;/p&gt; &lt;/div&gt; &lt;button v-print="'#printTest'"&gt;打印&lt;/button&gt; 如果内容打印不全，在打印操作时点击更多设置，然后设置缩放
常见问题
横向打印明明一页就能打印完，但是却会打印两页， 请检查打印区域顶部或者底部是不是有溢出的magin。打印区域的样式错乱了， 请检查css，尽可能的将选择器写完整一点，如：#printTest .xxx 。打印出来的结果紧贴在A4纸边缘，这个只需要给打印区域一个padding内边距即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec7e927c92a26f7c1bc40968b488382/" rel="bookmark">
			Tplmap的安装与用法（内包含解决缺少库报错的处理教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tplmap简介 Tplmap是一个python工具，可以通过使用沙箱转义技术找到代码注入和服务器端模板注入（SSTI）漏洞。该工具能够在许多模板引擎中利用SSTI来访问目标文件或操作系统。一些受支持的模板引擎包括PHP（代码评估），Ruby（代码评估），JaveScript（代码评估），Python（代码评估），ERB，Jinja2和Tornado。该工具可以执行对这些模板引擎的盲注入，并具有执行远程命令的能力。
Tplmap的安装步骤 在kali打开终端，输入
git clone https://github.com/epinna/tplmap
关于git，如没有该命令，则需要安装：（该命令需要在root权限下运行）
apt-get install git
有了git，以后github上下载项目都可以用git clone url这种形式来获取了
目录内容如下图
关于缺少库报错的处理 关于缺少库，在Tplmap目录下有一个名为requirements.txt的文本文件，内容如下：
PyYAML==5.1.2 certifi==2018.10.15 chardet==3.0.4 idna==2.8 requests==2.22.0 urllib3==1.24.1 wsgiref==0.1.2 这些就是tplmap所需要的库，在该文本明确的标出了库名与版本号，我们可以用pip命令指定该文本进行安装。
进入该目录，用以下指令进行安装：
pip install -r requirements.txt
用法 Usage: python tplmap.py [options] 选项: -h, --help 显示帮助并退出 目标: -u URL, --url=URL 目标 URL -X REQUEST, --re.. 强制使用给定的HTTP方法 (e.g. PUT) 请求: -d DATA, --data=.. 通过POST发送的数据字符串 它必须作为查询字符串: param1=value1&amp;param2=value2 -H HEADERS, --he.. 附加标头 (e.g. 'Header1: Value1') 多次使用以添加新的标头 -c COOKIES, --co.. Cookies (e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ec7e927c92a26f7c1bc40968b488382/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3650e0e159718bc53e8e14425367a96/" rel="bookmark">
			第一章-介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 一般建议什么是游戏引擎？什么是Godot?下载Godot其他安装方法Godot UI概述Project Manager选择文件名编辑器窗口关于节点和场景Godot中的脚本关于GDScript总结 无论你是想要从事的职业还是休闲爱好，游戏开发都是一项有趣而有意义的工作。现在是开始游戏开发的最佳时机。现代化的编程语言和工具使构建高质量的游戏并将其发布到全世界变得比以往任何时候都容易。如果你正在阅读本书，那么你已经踏上了制作梦想中的游戏的道路。
本书是对Godot游戏引擎及其2018年初发布的新3.0版本的介绍。Godot 3.0拥有大量新特性和功能，使其成为昂贵的商业游戏引擎的有力替代品。对于初学者来说，它提供了一种学习基本游戏开发技术的友好方式。对于更有经验的开发人员来说，Godot是一个强大的，可定制的，开放的工具，可以将您的愿景变为现实。
这本书采用了基于项目的方法，将向你介绍引擎的基本原理。它由5款游戏组成，旨在帮助你更好地理解游戏开发概念以及如何将其应用于Godot。在此过程中，您将了解Godot如何工作，并吸收可以应用到您的项目中的重要技术。
一般建议 本节包含了作者作为教师和讲师的经验，给读者的一些一般性建议。在你学习本书时，请记住这些建议，特别是当你对编程非常陌生的时候。
尽量按照书中的项目顺序进行。后面的章节可能会建立在前面章节介绍的主题上，在那里会有更详细的解释。当你遇到不记得的东西时，回过头来复习一下前面章节中的那个主题。没有人在安排你的时间，而且快速完成本书没有任何奖赏。
这里有很多材料需要吸收。如果你一开始不懂，也不要感到气馁。我们的目标不是要在一夜之间成为游戏开发专家–那是不可能的。重复是学习复杂主题的关键；你越是使用Godot的功能，它们就会开始显得越熟悉和容易。当您完成第7章 "附加主题 "时，试着回顾一下第2章 “硬币冲刺”。你会惊讶于与第一次阅读相比，你会明白更多的东西。
如果你使用的是本书的PDF版本，请抵制复制和粘贴代码的诱惑。自己输入代码会让你的大脑更多的参与进来。这类似于在讲座中做笔记比单纯听讲能帮助你更好地学习，即使你从来没有读过笔记。如果你是个打字慢的人，它也会帮助你锻炼打字速度。简而言之：你是一个程序员，所以要习惯打代码!
新游戏开发者所犯的最大错误之一就是承担了一个比他们能够处理的更大的项目。在刚开始的时候，将项目的范围尽可能的缩小是非常重要的。 如果您完成两个或三个小型游戏，那么与完成一个大型，不完整的项目已经超出了您的管理能力相比，您将获得更大的成功（并学到更多）。
你会注意到，本书中的五种游戏都非常严格地遵循了这一策略。它们的范围都很小，这既是出于实用的原因–可以合理地融入到书本大小的课程中–也是为了继续专注于教你基础知识。当你构建它们时，你可能会发现自己马上就会想到额外的功能和游戏元素。如果飞船有升级功能会怎样？如果角色可以进行墙壁跳跃呢？
想法很棒，但是如果您还没有完成基本项目，请将其写下来并保存以备后用。不要让自己被一个又一个酷炫的点子分散了注意力。开发者把这称为功能蠕变，这是一个陷阱，导致了许多未完成的游戏。不要成为它的受害者。
在每个新概念之后，尤其是在每个章节之后，请您花一些时间来吸收新信息，然后再学习下一个。 您会发现您不仅保留了更多信息，而且可能会更喜欢该过程。
什么是游戏引擎？ 游戏开发是复杂的，涉及到各种各样的知识和技能。为了构建一个现代游戏，你需要大量的底层技术，然后才能做出实际的游戏本身。想象一下，在你开始编程之前，你必须先建立自己的电脑，编写自己的操作系统。如果你真的要从头开始，构建你所需要的一切，那么游戏开发也会是如此。
此外，每个游戏都有一些共同的需求。例如，不管是什么游戏，都需要在屏幕上画东西。如果已经写好了这样做的代码，那么重用它比为每个游戏重新创建代码更有意义。这就是游戏框架和引擎的作用。
游戏框架是一套带有辅助代码的库，协助构建游戏的基础部分。它不一定提供所有的部分，你可能仍然需要写大量的代码来将所有的东西联系在一起。正因为如此，用游戏框架构建一款游戏可能会比用完整的游戏引擎构建的游戏花费更多的时间。
游戏引擎是一个工具和技术的集合，旨在通过消除为每个新的游戏项目重新发明轮子的需要来简化游戏制作过程。它提供了一个普遍需要的功能框架，而这些功能往往需要投入大量的时间来开发。
这里列出了游戏引擎将提供的一些主要功能:
渲染（2D和3D):渲染是将游戏显示在玩家屏幕上的过程。一个好的渲染管道必须考虑到现代GPU支持，高分辨率显示，以及光照、透视和视口等效果，同时保持非常高的帧率。
物理:构建一个强大而准确的物理引擎是一项艰巨的任务。大多数游戏都需要某种碰撞检测和响应系统，许多游戏都需要物理模拟，但很少有开发者愿意承担编写一个物理系统的任务，特别是如果他们曾经尝试过这样做。
平台支持:在今天的市场上，大多数开发者都希望能够在多个平台上发布他们的游戏，如游戏机、手机、PC和/或网络。游戏引擎提供了一个统一的导出流程，可以在多个平台上发布，而不需要重写游戏代码或支持多个版本。
通用的开发环境:通过使用相同的统一界面来制作多个游戏，你不必在每次开始一个新项目时重新学习一个新的工作流程。
此外，还会有一些工具来协助实现一些功能，如联网、简化处理图像和声音的过程、动画、调试、关卡创建等。通常情况下，游戏引擎会包括从其他工具导入内容的能力，例如用于创建动画或3D模型的工具。
使用游戏引擎可以让开发者专注于构建他们的游戏，而不是创建使游戏运行所需的所有底层框架。对于小型或独立开发者来说，这可能意味着在开发一年而不是三年后发布游戏，甚至根本就没有发布游戏的区别。
目前市场上流行的游戏引擎有几十个，如Unity、Unreal Engine和GameMaker Studio等。需要注意的一个重要事实是，大多数流行的游戏引擎都是商业产品。它们可能需要或不需要任何财务投资来启动，但如果你的游戏赚钱，它们将需要某种授权和/或版税支付。无论你选择什么样的引擎，你都需要仔细阅读用户协议，确保你明白你可以和不可以使用该引擎，以及如果有的话，你可能需要负责哪些隐藏的费用。
另一方面，有一些引擎是非商业性的、开源的，比如Godot游戏引擎，这就是本书的内容。
什么是Godot? Godot是一个功能齐全的现代游戏引擎，提供了前文所述的所有功能以及更多。它也是完全免费和开放源码的，在非常宽松的MIT许可证下发布。这意味着没有任何费用，没有隐藏成本，也不需要为您的游戏收入支付版税。你用Godot制作的所有东西100%属于你，这是许多商业游戏引擎所不具备的，它们需要持续的合同关系。对于很多开发者来说，这一点是非常有吸引力的。
如果你不熟悉开源、社区驱动开发的概念，你可能会觉得很奇怪。然而，就像Linux内核、Firefox浏览器和许多其他非常知名的软件一样，Godot并不是由一家公司作为商业产品开发的。取而代之的是，一个由充满激情的开发者组成的专门社区，他们捐出自己的时间和专业知识来构建引擎，测试和修复错误，制作文档等等。
作为一个游戏开发者，使用Godot的好处是巨大的。因为它不受商业授权的限制，你可以完全控制你的游戏到底是如何发行的，在哪里发行的。许多商业游戏引擎限制了您可以制作的项目类型，或者需要更昂贵的许可证来制作某些类别的游戏，例如赌博。
Godot的开源性质也意味着有商业游戏引擎所不存在的透明度。例如，如果你发现某个引擎功能不能满足你的需求，你可以自由修改引擎本身，并添加你所需要的新功能，不需要任何许可。这在调试大型项目时也是非常有帮助的，因为你可以完全访问引擎的内部运作。
这也意味着您可以直接为Godot的未来做出贡献。有关如何参与Godot开发的更多信息，请参见第7章 “附加主题”。
下载Godot 您可以访问https://godotengine.org/，点击下载最新版本的Godot。本书是为3.0版本编写的。如果你下载的版本在最后有另一个数字（如3.0.3），那也没关系，这只是意味着它包含了3.0版本的更新，修复了错误或其他问题。
当前正在开发3.1版，在您阅读本书时可能已经发布了。 此版本可能包含或可能不包含与本书中的代码不兼容的更改。 请查看GitHub存储库以获取有关本书的信息和勘误表：https：//github.com/PacktPublishing/Godot-Game-Engine-Projects
在下载页面，有几个选项值得解释。首先，32位与64位：这个选项取决于你的操作系统和电脑的处理器。如果你不确定，你应该选择64位版本。你还会看到一个Mono版。这是一个专门为C#编程语言打造的版本。不要下载这个版本，除非你打算使用C#与Godot。在写这篇文章的时候，C#的支持还是实验性的，不建议初学者使用。
双击下载的文件将其解压缩，您将拥有Godot应用程序。 （可选）您可以将其拖到“程序”或“应用程序”文件夹中。
双击该应用程序以启动它，您将看到Godot的Project Manager窗口。
其他安装方法 除了从Godot网站上下载外，还有其他一些方法可以让Godot在电脑上安装。需要注意的是，这种方式安装时，功能上没有区别。以下只是下载应用程序的替代方法:
Steam:如果你在Steam上有账号，你可以通过Steam桌面应用安装Godot。在Steam商店中搜索Godot，然后按照说明进行安装。你可以从Steam应用中启动Godot，它甚至会追踪你的游戏时间。
软件包管理器:如果您使用的是以下操作系统的软件包管理器，您可以通过其正常的安装过程安装Godot。请参阅您的软件包管理器的文档了解详情。Godot可在这些软件包管理器中使用:
Homebrew (macOS)Scoop (Windows)Snap (Linux) Godot UI概述 像大多数游戏引擎一样，Godot有一个统一的开发环境。这意味着您可以使用相同的界面来处理游戏的所有方面–代码、视觉效果、音频等等。本节是对界面及其部分的介绍。请注意这里使用的术语；当你在编辑器窗口中进行操作时，将在本书中使用这些术语。
Project Manager 项目管理器是打开Godot时看到的第一个窗口：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3650e0e159718bc53e8e14425367a96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/055eac41674a6fa532a13828c0bba930/" rel="bookmark">
			eplan连接定义点不显示_EPLAN电气图实例--控制柜（控制面板）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EPLAN电气图实例--控制柜(控制面板)
上期回顾(上期主要画了硬件的布局图)：
这期主要画一个控制面板控制柜布局
1.0 上期主要做了一个长方形的结构板，里面插入了一个结构盒，然后放置一个HMI的宏(这里是KTP1000，在官网随便找下就行了)，然后打开项目数据--设备/部件--2D安装板部件导航器，找到前面配置的HMI屏，拖出部件放置框，重合，命名1
2.0 再插入一个电源指示灯的宏，把属性--显示设置里，只保留图例位置显示，右键移动文本，把图例序号移到正中
2.1 再给这个指示灯，挂上标牌，这样一个部件就好了
3.0 如上操作完成总负荷开关的配置，以及启动，复位，急停
4.0 控制面板的按钮HMI，开关都画好了，下面就要箱体清单报表了，工具--报表--生成，嵌入式报表，新建如下设置，注意输出形式改成手动放置
4.1 注意部件当时归类的是筛选器还是附件，这里筛选器选择电气工程，表格可以选择自定义的，要也可以不选，那就是默认的
4.2 然后拖动到21页的界面，这样控制面板的箱柜设备清单就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8abd700e83ca084aedd3c8eb6583a921/" rel="bookmark">
			centos7 下离线安装 opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装cmake步骤 //删除原有的低版本cmake,若版本够高则不需要重新安装cmake，也可以直接下好cmake.*.tar.gz
yum remove cmake -y &amp;&amp; rm -f /usr/bin/cmake
wget https://cmake.org/files/v3.6/cmake-3.6.2.tar.gz tar xvf cmake-3.6.2.tar.gz &amp;&amp; cd cmake-3.6.2/
./bootstrap
gmake
gmake install
ln -s /usr/local/bin/cmake /usr/bin/
安装opencv 如果g++不存在先安装g++
yum install gcc gcc-c++
先下载号离线opencv压缩包
.解压opencv4.1.2.zip
cd opencv4.1.2
mkdir build
cd build
cmake3 -D BUILD_SHARED_LIBS=ON -D BUILD_TESTS=OFF -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local/opencv/ ..
make
make install
配置opencv环境
cd /usr/local/opencv
cp -r include /usr/local/
cd /usr/local/opencv/lib64
cp libopencv* /usr/local/lib64 vim /etc/ld.so.conf (增加: /usr/local/lib64 /usr/local/lib ) source /etc/profile 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fed48794e38cc6a8651291fc4d39f87/" rel="bookmark">
			vue 项目中生成条形码（jsbarcode）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条形码插件介绍和使用
安装：
cnpm install jsbarcode --save 引入：在要生成条形码的页面引入即可
import JsBarcode from 'jsbarcode' 3.二维码容器：支持三种形式，img/svg/canvas，根据自己的需要三选一即可
&lt;svg id="barcode"&gt;&lt;/svg&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;img id="barcode"/&gt; 调用构造函数，生成条形码。构造函数的使用也有两种形式，这里只介绍简单的使用，更详细的使用请参考：npm jsbarcode
JsBarcode("#barcode", "1234", { format: "pharmacode", //条形码的格式 lineColor: "#0aa", //线条颜色 width:4, //线宽 height:40, //条码高度 displayValue: false //是否显示文字信息 }) 效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e8afc179196367ca00e6b15f6179a12/" rel="bookmark">
			斐波那契1.斐波那契数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		斐波那契数列 有很多类似的问题，比如说跳台阶，矩形覆盖，变态跳台阶，只要记住公式就可以算出
用递归非常简单，但一般更建议使用循环
循环就是自下而上进行计算
public class Solution { public int Fibonacci(int n) { if(n==0){ return 0; } if(n==1){ return 1; } int res=0; int z1=0,z2=1; for(int i=2;i&lt;=n;i++){ res=z1+z2; z1=z2; z2=res; } return res; } } 这种算法是O（n）的复杂度
还有一种复杂度更低的算法O（logn）
也就是利用数学公式将求f（n）转换为求矩阵的n次乘方来算
而矩阵的n次方又可以转换为求a的n/2次方再平方，n为奇数时为n/2的平方再乘一个a，可以利用递归的思路实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72b07bd1b295e55672734ba54530eeb5/" rel="bookmark">
			动态链表之尾插法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态链表的实现
动态链表尾插法
#include
#include&lt;malloc.h&gt;
#include&lt;time.h&gt;
using namespace std;
static int length=0;
typedef struct List{
int data;
List* next;
}List;
void listInit(List *l)
{
l-&gt;data=0;
l-&gt;next=NULL;
}
void insertByTail(List **l,int data)
{
List temp=(List)malloc(sizeof(List));
temp-&gt;data = data; temp-&gt;next=NULL; (*l)-&gt;next = temp;	(*l)=(*l)-&gt;next; }
void printList(List *l)
{
while(l) { cout&lt;&lt;l-&gt;data&lt;&lt;endl; l=l-&gt;next; } //不能直接用l来进行遍历，否则会在l=l-&gt;next这个地方每一次产生一个尾部根本不存在的指向，导致程序崩溃 /*for(int i=0;i&lt;len;i++) { cout&lt;&lt;l-&gt;data&lt;&lt;endl; l=l-&gt;next; }*/ }
int main(int argc , char* argv[])
{
//对于要操作的链表，要首先通过申请开辟堆空间来获得链表的首地址
//刚开始我把List list=(List)malloc(sizeof(List));这一句放到void listInit(List *l)中，企图通过初始化函数来开辟，结果会运行时报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72b07bd1b295e55672734ba54530eeb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358ef86153b96fda0f8317c4c4c12ab2/" rel="bookmark">
			vivo/android8.1.0、oppo/android7.1.1手机webview中请求接口没响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webview控制台提示：Request header field language is not allowed by Access-Control-Allow-Headers in preflight response.
请求头设置了自定义请求头参数，需要服务器支持，并做出正确响应，参考Request header field Content-Type is not allowed by Access-Control-Allow-Headers
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571bec7857498aab00557c7f31afba86/" rel="bookmark">
			jquery中的$(document).ready(function(){})和$(window).load()比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.执行时间 window.onload()即jquery写法中的$(window).load(function(){})必须等到页面内包括图片的所有元素加载完毕后才能执行。 $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。 2.编写个数不同 window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个(最后一个)
$(document).ready()可以同时编写多个，并且都可以得到执行 3.简化写法 window.onload没有简化写法 $(document).ready(function(){})可以简写成$(function(){}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a99fb8311dc99931858d3abda6e8d078/" rel="bookmark">
			Linux下CUDA版本切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cp@ubuntu:/usr/local$ ls bin cuda cuda-10.0 cuda-10.1 etc games include lib man sbin share src cp@ubuntu:/usr/local$ sudo rm -rf cuda [sudo] cp 的密码： cp@ubuntu:/usr/local$ ls bin cuda-10.0 cuda-10.1 etc games include lib man sbin share src cp@ubuntu:/usr/local$ sudo ln -s /usr/local/cuda-10.0 /usr/local/cuda cp@ubuntu:/usr/local$ ls bin cuda cuda-10.0 cuda-10.1 etc games include lib man sbin share src 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f709edea11f54256b79685057e924545/" rel="bookmark">
			python字符串截取split-python实现字符串完美拆分split()的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数:split()
例子
我们想要将以下字符串rule进行拆分。字符串表示的是一个规则，由“…”得到“…”。我们需要将规则中的条件属性与取值分别提取出来，存放在条件属性列表cf_list与值列表cv_list中，规则的结论的属性与取值也提取出来，分别存放结果属性列表rf_list与值列表rc_list。
rule = "{age=Middle-aged,sex=Male,education=Bachelors}=&gt;{native-country=United-States}"
代码
rule = "{age=Middle-aged,sex=Male,education=Bachelors}=&gt;{native-country=United-States}"
c_s, r_s = s.split("=&gt;")
c_list = c_s.split("{")[1].split("}")[0].split(",")
r = r_s.split("{")[1].split("}")[0]
cf_list = []
cv_list = []
for c in c_list:
cf, cv = c.split("=")
cf_list.append(cf)
cv_list.append(cv)
rf, rv = r.split("=")
print(cf_list, cv_list, rf, rv)
输出结果：
(["age", "sex", "education"], ["Middle-aged", "Male", "Bachelors"], "native-country", "United-States")
部分代码说明：
1、
c_s, r_s = s.split("=&gt;")
"=&gt;"为分隔符，将字符串rule分成两部分：{age=Middle-aged,sex=Male,education=Bachelors}与{native-country=United-States}
2、
c_list = c_s.split("{")[1].split("}")[0].split(",")
该行代码将字符串{age=Middle-aged,sex=Male,education=Bachelors}中的{与}滤掉后，将每个条件分开并存储在列表中。具体地，c_s.split("{")以{将字符串{age=Middle-aged,sex=Male,education=Bachelors}拆分成包含两个元素的列表["", "age=Middle-aged,sex=Male,education=Bachelors}"]，第一个元素为空字符串，不包含任何信息，故只取拆分结果的第二个元素c_s.split("{")[1]。同理，c_s.split("{")[1].split("}")[0]是在之前拆分的基础上以}对字符串拆分，并滤掉空字符串。
以上这篇python实现字符串完美拆分split()的方法就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持脚本之家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfcb6a7c40777222c7880540935b3396/" rel="bookmark">
			torch.load()模型时报错no module named ‘xxx‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 报错代码：报错信息：原因：解决办法： 报错代码： self.activity_model = torch.load(traj_mining_config.activity_model) 报错信息： 原因： python环境变量的问题
解决办法： 方案一：
在加载模型的这个python文件中，增加两行，把报错的module的上层文件夹放到环境变量里。搞定
“报错的module的上层文件夹：比如说 我的报错是segment_crf找不到，segement_crf的上层目录是nn,那我就把nn放在环境变量里。
方案二
在pycharm的setting里，把这个module的上级目录mark as source：先点击目录，然后点击"source",该目录就会在右侧显示出来，就表示已经mark好了。然后就不会报错了。
两种方案二选一即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d37a005ab5699a774467445e1d8d87/" rel="bookmark">
			怎么彻底重装清空电脑_电脑系统怎么重装？教你一个最简单的重装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑系统怎么重装呢？现在电脑已成为我们工作学习的重要工具，但是很多朋友也只是停留在电脑的使用方面，对于重装系统是一窍不通。今天，我给这些朋友带来了最简单的重装系统方法，赶紧来学习一下吧。
1、打开下载一键重装系统软件，出现温馨提示窗口，关闭杀毒软件。(在重装系统时会对修改系统的一些启动项，避免因拦截造成重装失败)
2、然后小白软件会自动检测电脑安装环境是否适合重装系统。如果想要获取人工客服技术支持，可以点击关于帮助。
3、检测完成后来到选择系统界面，可以选择自己需要的系统版本注意一下自己需要安装的系统位数哦。选择完成后点击安装此系统。
4、选择需要安装的软件，点击下一步之后就等待系统、软件，驱动的下载，安装，部署，后面的操作步骤就无需我们动手安装啦，我们了解一下就好。
以上就是重装电脑系统的方法了，非常适合我们小白朋友的使用，就算没有计算机基础也能完成系统的安装，学会了就赶紧动手试试吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be1425cb795976e54556826bdaddc2b/" rel="bookmark">
			怎么彻底重装清空电脑_小白一键重装系统怎么用？电脑详细的重装系统教程看这里...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到给电脑重装系统，估计很多小伙伴都会觉得，这是一件非常令人头疼地事情，因为重装系统的步骤不仅麻烦，耗时时间也长，费时又费力。如果有此需求的话，自己一定会去求别人的帮忙，自己真的是搞定不了。
但其实只要你选对重装系统的工具，然后在稍微知道一些技巧，那么你完全是可以自己完成电脑系统重装工作的。觉得费事的这项工作，其实你也可以轻松搞定，不用去麻烦别人了。
而小白一键重装系统工具，就是一款让电脑系统重装变得非常简单的软件，不仅支持所有电脑品牌的系统重装工作，还支持一键装机原版系统的功能，有了这款工具，我们就可以轻松的一键安装Win7、Win10甚至是Win10系统了。那么小白一键重装系统软件怎么用呢？下面小编就来为大家详细的介绍使用小白一键重装系统工具来给电脑重装系统的方法吧，希望能够对大家有所帮助。
第一步，首先我们需要在电脑上下载并安装小白一键重装系统工具，然后在对电脑系统进行重装前，我们需要将电脑C盘当中的资料进行备份，然后关闭电脑当中的杀毒软件。
第二步，打开电脑上安装好的小白一键重装系统工具，接着对电脑本地的环境进行检测。
第三步，等待电脑本地环境检测完成后，软件界面当中出现选择系统的界面时，我们选择需要安装的系统，然后点击【安装此系统】按钮。
第四步，接着软件界面就会出现选择安装的软件列表了，在此界面当中，我们根据自己的需求来勾选需要进行安装的软件，如果不需要进行软件安装的话，那么就点两次【全选】，然后点击【下一步】按钮。
第五步，然后软件界面就进行到系统、系统软件以及驱动的下载界面当中了，在下载期间，建议不要对电脑进行操作，以及对电脑进行休眠和断电等操作。
第六步，所有的东西都下载完成后，此时软件界面就进入到了安装前的系统部署以及校对了，当电脑部署完成后，就可以对电脑进行重启了。一般10秒后电脑就会自动重启，之后的流程都是自动化的，我们只需要耐心地等待就可以了。
第七步，电脑重启后就进入到了开机选项界面当中，接着10秒后电脑就自动进入到PE系统的安装界面当中了，或者是我们手动点击进入也可以。
第八步，进入到PE系统时需要加载时间，此时我们耐心等待加载完成，待加载完成后，小白系统装机工具就会开始自动安装。
第九步，在电脑系统安装的过程当中，也建议大家不要去操作电脑，以免发生安装失败的问题。
第十步，待电脑系统安装完成后，系统会提示安装成功，然后10秒后电脑会自动重启，当然了我们也可以手动点击进行重启。
第十一步，电脑重启后，就开始了系统的设置，而在此期间，电脑会多次进行自动重启，此时我们无需担心。
第十二步，最后等待系统安装完成后，电脑就会自动进入到系统当中来了，全新的系统我们也可以放心地进行使用了。
以上呢就是小编为大家总结的关于小白一键重装系统怎么用的详细教程介绍了，如果你的电脑此前在进行重装系统的时候，一直都是求别人帮忙的话，那么不妨赶快跟着本文自己也将电脑重装系统的方法学到手吧，这样一来，你就不会觉得给电脑重装系统是一件麻烦的事情了，反而很容易的就能够搞定呢，再也不用去麻烦别人了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd1985b81ff5c0358c092a0893d53c72/" rel="bookmark">
			win10控制面板快捷键_Win10开启最强隐藏模式，电脑性能直线飙升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑的处理器、显卡等重要配置不停的在辞旧迎新(更新换代)，很多人为了追求更好的性能，也愿意花高价钱买高配置的电脑！
要提升电脑性能，硬件设备必然是主导地位，但不是人人都这么富裕买得起的。
按小高个人的理解不管设备多先进或多陈旧，能满足我们的需求够用就行，性能过剩完全就是白花钱！
另外，不管多好的硬件它也是依托于电脑系统运行的，所以除了换硬件改善性能，还要优化系统、让性能发挥到极致。
这期小高分享几种Win10的“隐藏模式”，开启后电脑性能直线上升！
1：游戏模式 这个模式是Win10自带的，在控制面板中找到游戏板块-开启该模式即可！
具体作用我们可以看看官方的描述：
简单来说就是任何影响游戏体验的干扰因素，系统都会尽可能帮你拦截，保证网速和帧速率。
2：卓越模式 这是Win10隐藏的一种电源模式，默认情况我们最多能看到高性能和平衡或节能模式！
但其实Win10还隐藏了一种“卓越”模式，瞬间让你的电脑打满鸡血！
按下快捷键Win+R打开电脑命令窗口-并输入命令“powershell”-调用出电源命令窗口：
接着输入(粘贴)代码至输入框中-按下回车键-即可开启模式，再次进入电源管理就会看到新增的“卓越”模式。
卓越模式代码：
powercfg –duplicatescheme e9a42b02–d5df–448d–aa00–03f14749eb61 这种状态下各方面功耗肯定会提升，但电脑会进入一个最佳性能状态。
比如玩游戏或剪辑时，可开启此模式，平时看电影、处理文档之类的就用默认模式即可。
3：上帝模式 同样是一项被隐藏的命令模式，从字面意思就能大致摸清楚，在这种模式下你就是电脑最强的执行力！
在任意窗口创建文件夹，将名称改为下方代码：
GodMode.{ED7BA470–8E54–465E-825C–99712043E01C} 然后会自动变成一个图标，贼熟悉的控制面板。
双击进入后，就能看到很多在控制面板中看不到的选项
4：最后 这些被隐藏的模式，虽然不能给电脑产生质的提升，但却能让你的设备发挥出它最大的能力。
或许这些提升刚刚符合你的玩机需求，这样不就省下一笔硬件费用嘛，或者让旧电脑再多战几年。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19de33c9c87ae8eed41e540d217219da/" rel="bookmark">
			Java二进制和位运算，这一万字准能喂饱你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“BAT的乌托邦”，选择“设为星标”
后台回复“专栏”，开启专栏模式学习
✍前言 你好，我是YourBatman。
本号正在连载Jackson深度解析系列，虽然目前还只讲到了其「流式API」层面，但已接触到其多个Feature特征。更为重要的是我在文章里赞其设计精妙，处理优雅，因此就有小伙伴私信给我问这样的话：题外话：Jackson这个话题本就非常小众，看着阅读量我自己都快没信心写下去。但自己说过的话就是「欠下的债」，熬夜也得把承诺的付费内容给公开完了，毕竟还有那么几个人在白嫖不是????。
❝ 话外音：以后闷头做事，少吹牛逼┭┮﹏┭┮
❞ 虽然小众，竟然还有想深入了解一波的小伙伴，确实让我为之振奋了那么三秒。既然如此那就干吧，本文就先行来认识认识「Java中的位运算」。位运算在Java中很少被使用，那么为何Jackson里爱不释手呢？一切就为两字：「性能」/「高效」。用计算机能直接看懂的语言跟它打交道，你说快不快，不用多想嘛。
✍正文 提及位运算，对绝大多数Java程序员来说，是一种「既熟悉又陌生」的感觉。熟悉是因为你在学JavaSE时肯定学过，并且在看一些开源框架（特别是JDK源码）时都能看到它的身影；陌生是因为大概率我们不会去使用它。当然，不能“流行”起来是有原因的：不好理解，不符合人类的思维，阅读性差…...
❝ 小贴士：一般来说，程序让人看懂远比被机器看懂来得更重要些
❞ 位运算它在low-level的语言里使用得比较多，但是对于Java这种高级语言它就很少被提及了。虽然我们使用得很少但Java也是支持的，毕竟很多时候使用位运算才是「最佳实践」。
位运算在日常开发中使用得较少，但是巧妙的使用位运算可以大量减少运行开销，优化算法。「一条语句可能对代码没什么影响，但是在高重复，大数据量的情况下将会节省很多开销。」
二进制 在了解什么是位运算之前，十分有必要先科普下二进制的概念。
二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是「逢二进一」，借位规则是「借一当二」。因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。
❝ 小贴士：半导体开代表1，关代表0，这也就是CPU计算的最底层原理????
❞ 先看一个例子：
求 1011（二进制）+ 11（二进制） 的和？ 结果为：1110（二进制） 二进制理解起来非常非常的简单，比10进制简单多了。你可能还会思考二进制怎么和十进制互转呢？毕竟1110这个也看不到啊。有或者往深了继续思考：如何转为八进制、十六进制、三十二进制......进制转换并非本文所想讲述的内容，请有兴趣者自行度娘。
二进制与编码 这个虽然和本文内容关联系并不是很大，但顺带捞一捞，毕竟编码问题在开发中还是比较常见的。
计算机能识别的只有1和0，也就是二进制，1和0可以表达出全世界的「所有」文字和语言符号。那如何表达文字和符号呢？这就涉及到「字符编码」了。字符编码强行将每一个字符对应一个十进制数字（请注意字符和数字的区别，比如0字符对应的十进制数字是48），再将十进制数字转换成计算机理解的二进制，而计算机读到这些1和0之后就会显示出对应的文字或符号。
一般对「英文字符」而言，一个字节表示一个字符，但是对汉字而言，由于低位的编码已经被使用(早期计算机并不支持中文，因此为了扩展支持，唯一的办法就是采用更多的字节数)只好向高位扩展
字符集编码的范围utf-8&gt;gbk&gt;iso-8859-1(latin1)&gt;ascll。ascll编码是美国标准信息交换码的英文缩写，包含了常用的字符，如阿拉伯数字，英文字母和一些打印符号共255个（一般说成共128个字符问题也不大）
❝ UTF-8：一套以 8 位为一个编码单位的「可变长」编码，会将一个码位（Unicode）编码为1到4个字节（英文1字节，大部分汉字3字节）。
❞ Java中的二进制 在Java7版本以前，Java是不支持直接书写除十进制以外的其它进制字面量。但这在Java7以及以后版本就允许了：
二进制：前置0b/0B
八进制：前置0
十进制：默认的，无需前置
十六进制：前置0x/0X
@Test public void test1() { //二进制 int i = 0B101; System.out.println(i); //5 System.out.println(Integer.toBinaryString(i)); //八进制 i = 0101; System.out.println(i); //65 System.out.println(Integer.toBinaryString(i)); //十进制 i = 101; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19de33c9c87ae8eed41e540d217219da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06bcb029c431093193b138a6f2652d2c/" rel="bookmark">
			Spring Boot 微服务框架 Part1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 微框架Part1 1.springboot的引言 SpringBoot是由 Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，springboot致力于在蓬勃发展的快速应用开发领域(rapid application devolopment)成为领导者。
springboot(微框架) = spring(项目管理) + springmvc(控制器)
2.SpringBoot的特点 构建一个独立的spring应用；springboot开发的应用内嵌tomcat容器，无需部署war文件；简化maven的配置；自动配置spring应用和springmvc应用，没有xml配置文件。 3.SpringBoot的环境搭建 环境要求:
MAVEN 3.x+Spring FrameWork 4.x+JDK7.x +
. Spring Boot 1.5.x+ 3.1 项目中引入依赖 &lt;!-- 继承springboot的父项目 --&gt; &lt;parent&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;version&gt;1.5.7.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- 引入web的支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 3.2 引入springboot配置文件 项目中src/main/resources/application.yml 3.3 编写入口类 package com.baizhi; //入口类必须放在项目的基包下，SpringBoot只有一个入口类，所以这个注解只能出现一次 @SpringBootApplication public class Application { //main函数 public static void main(String[] args) { //启动 springboot应用 //参数1：入口类类对象 参数2：main函数参数 SpringApplication.run(Application.class,args); } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06bcb029c431093193b138a6f2652d2c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/159/">«</a>
	<span class="pagination__item pagination__item--current">160/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/161/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>