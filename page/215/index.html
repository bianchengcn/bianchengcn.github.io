<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc61a3a9c3fa0482295d9c0abc7e2e6b/" rel="bookmark">
			判断周围是否有敌人的三种模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//1、只攻击正前方的单位，向前发射一条射线，攻击碰到的单位 RaycastHit hit; //range 射线的长度，即攻击范围，maskTarget敌方单位的mask，只攻击敌方单位 if(Physics.Raycast(unit.thisT.position, unit.thisT.forward, out hit, range, maskTarget)){ Unit targetTemp=hit.collider.gameObject.GetComponent(); if(targetTemp!=null &amp;&amp; targetTemp.HPAttribute.HP&gt;0){ target=targetTemp; if(attackMode==_AttackMode.StopNAttack){ if(attackMethod!=_AttackMethod.Melee) unit.StopAnimation(); unit.StopMoving(); } } } //2、以己方单位为圆心的某一半径长度内 //返回相交球的所有碰撞体 Collider[] cols=Physics.OverlapSphere(unit.thisT.position, range, maskTarget); //if(cols!=null &amp;&amp; cols.Length&gt;0) Debug.Log(cols[0]); if(cols.Length&gt;0){ Collider currentCollider=cols[Random.Range(0, cols.Length)]; Unit targetTemp=currentCollider.gameObject.GetComponent(); if(targetTemp!=null &amp;&amp; targetTemp.HPAttribute.HP&gt;0){ target=targetTemp; if(attackMode==_AttackMode.StopNAttack){ if(attackMethod!=_AttackMethod.Melee) unit.StopAnimation(); unit.StopMoving(); } } } //3、以己方单位为圆心的扇形范围内 Collider[] cols=Physics.OverlapSphere(unit.thisT.position, range, maskTarget); //if(cols!=null &amp;&amp; cols.Length&gt;0) Debug.Log(cols[0]); if(cols.Length&gt;0){ Collider currentCollider=cols[0]; foreach(Collider col in cols){ Quaternion targetRot=Quaternion.LookRotation(col.transform.position-unit.thisT.position); if(Quaternion.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc61a3a9c3fa0482295d9c0abc7e2e6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c294a2fefcf08cfdf0450346726bca/" rel="bookmark">
			c&#43;&#43; ActiveX基础1：使用VS2010创建MFC ActiveX工程项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ActiveX的基本概念
ActiveX控件可以看作是一个极小的服务器应用程序，它不能独立运行，必须嵌入到某个容器程序中，与该容器一起运行。这个容器包括WEB网页，应用程序窗体等。。。
ActiveX控件的后缀名是OCX或者DLL。一般是以OCX和动态库共存的形式打包成cab或者exe的文件放在服务器上，客户端下载后运行安装cab或exe解压成OCX和动态库共存的文件，然后注册ocx文件。
ActiveX控件是基于com标准，使得软件部件在网络环境中进行交互的技术集。它与具体的编程语言无关。作为针对Internet应用开发的技术，ActiveX被广泛应用于WEB服务器以及客户端的各个方面。同时，ActiveX技术也被用于方便地创建普通的桌面应用程序，此外ActiveX一般具有界面。
2.三个概念：ActiveX、OLE和COM
从时间的角度讲，OLE是最早出现的，然后是COM和 ActiveX；从体系结构角度讲，OLE和ActiveX是建立在COM之上的，所以COM是基础；单从名称角度讲，OLE、ActiveX是两个商标名称，而COM则是一个纯技术名词，这也是大家更多的听说ActiveX和OLE的原因。COM是应OLE的需求而诞生的，所以虽然COM是OLE的基础，但OLE的产生却在COM之前。COM的基本出发点是，让某个软件通过一个通用的机构为另一个软件提供服务。ActiveX最核心的技术还是COM。ActiveX和OLE的最大不同在于，OLE针对的是桌面上应用软件和文件之间的集成，而 ActiveX则以提供进一步的网络应用与用户交互为主。COM对象可以用C++、Java和VB等任意一种语言编写，并可以用DLL或作为不同过程工作的执行文件的形式来实现。使用COM对象的浏览器，无需关心对象是用什么语言写的，也无须关心它是以DLL还是以另外的过程来执行的。从浏览器端看，无任何区别。这样一个通用的处理技巧非常有用。
3.ActiveX控件工程的创建
使用VS2010有两种方式可以创建ActiveX工程，
第一种：创建“MFC ActiveX 控件”工程；
第二种：创建“ATL 项目”。由于使用ATL开发ActiveX控件需要了解com技术，对程序员的要求也较高，开发时间也较长，所以如果ActiveX只在windows操作系统下运行，那么就使用“MFC ActiveX 控件”工程来快速建立ActiveX控件。但是这里要注意了：使用“MFC ActiveX 控件”工程来快速建立ActiveX控件，他不仅要建立在windows操作系统下，还必须在windows操作系统下安装c++依赖库安装包，因为MFC是建立在微软的c++动态库的基础上的。所以这两种方式各有优缺点，根据项目需求来选择适合的方式。
4.使用VS2010创建MFC ActiveX工程项目步骤
由于使用ATL进行ActiveX工程的创建难度比较大，所以这里先使用“MFC ActiveX 控件”工程来创建一个简单的ActiveX控件。
第一：新建项目-》选择“MFC ActiveX 控件”工程，给项目命名TestMfcAtlDebug，点击确定，弹出“控件向导”对话框
第二：在概述，应用程序设置，控件名称和控件设置都可以选择默认，然后点击“完成”，这样“MFC ActiveX 控件”工程创建完成
5.分析“MFC ActiveX 控件”工程的三个重要的类以及对外接口定义文件idl
使用向导创建完工程可以看到自动生成了三个类，TestMfcAtlDebug，TestMfcAtlDebugCtrl和TestMfcAtlDebugPropPage
可以打开上面三个类的头文件及cpp文件，发现它们都是派生类。
TestMfcAtlDebug：cpp文件中定义了DllRegisterServer和DllUnregisterServer，可以发现ActiveX的注册和反组册都与该类有关。
TestMfcAtlDebugCtrl：可以发现该头文件中声明了消息映射（让ActiveX控件程序可以接受系统发送的事件通知，如窗体创建和关闭事件），调度映射（让外部调用程序（包含ActiveX的容器）可以方便地访问ActiveX控件的属性和方法），事件映射（让ActiveX控件可以向外部调用程序（包含ActiveX的容器）发送事件通知）。也就是说对ActiveX控件的窗口操作都将在这个类中完成，包括ActiveX控件的创建，重绘，以及在此类中创建可视MFC窗体。
TestMfcAtlDebugPropPage：显示ActiveX控件的属性页的
让我们来看看最重要的部分：对外接口定义文件TestMfcAtlDebug.idl，代码如下：
#include &lt;olectl.h&gt;#include &lt;idispids.h&gt;[ uuid(69EE37F4-8B36-495F-9F60-5E3AAF2FB494), version(1.0),control ]library TestMfcAtlDebugLib{importlib(STDOLE_TLB);// CTestMfcAtlDebugCtrl 的主调度接口[ uuid(6B60346D-5CCD-4907-83F4-51938558A9B7)	]dispinterface _DTestMfcAtlDebug{properties:methods:[id(DISPID_ABOUTBOX)] void AboutBox();};// CTestMfcAtlDebugCtrl 的事件调度接口[ uuid(E26ECC46-9BA2-4C25-A4DD-A690560A5113)	]dispinterface _DTestMfcAtlDebugEvents{properties:// 事件接口没有任何属性methods:};// CTestMfcAtlDebugCtrl 的类信息[uuid(DD0CF7EF-A181-428C-B5FC-C44A1C13CA43)]coclass TestMfcAtlDebug{[default] dispinterface _DTestMfcAtlDebug;[default, source] dispinterface _DTestMfcAtlDebugEvents;};}; 这个就是对外接口定义文件，如果外部程序想要调用ActiveX的方法，属性以及在注册表注册的classid（WEB网页调用需要使用），就必须了解这个文件，这个文件可以分为四个部分来看：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40c294a2fefcf08cfdf0450346726bca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62156227d934e26e8c1587eb421118d3/" rel="bookmark">
			htaccess不起作用的解决方法,AllowOverride All打开后出现403错误时解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在php程序的目录下有一个htaccess文件,这个文件起着对url重写的作用,但是不巧的,在我的应用程序里不起作用,baidu了一下,发现是
AllowOverride All, 这个选项没有打开,
这个选项,只能写在
&lt;Directory /&gt; &lt;/Directory&gt;中,我在http.conf中打开了这个选项,结果网站出现了403禁止访问的错误,经查看,结果发现是
&lt;Directory /&gt; Options Indexes AllowOverride None #AllowOverride All Order allow,deny Allow from all &lt;/Directory&gt; 不应在/这个目录下,写这个选项,应在应用程序的目录下打开这个选项,
&lt;Directory "http://www.cnblogs.com/WebRoot/Default"&gt; 这里的相对目录是对于配置文件中的ServerRoot而言. # # Possible values for the Options directive are "None", "All", # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that "MultiViews" must be named *explicitly* --- "Options All" # doesn't give it to you. # # The Options directive is both complicated and important.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62156227d934e26e8c1587eb421118d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/816b01a2a9f651240f82bbfb952b3b73/" rel="bookmark">
			libcurl教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一段时间无事，等待入职。以前把libcurl的easy Interface 的那些函数用法手册翻译了，这次也把 libcurl-tutorial翻译一下，多有不足，请多指教。
原文是网址是 ：http://curl.haxx.se/libcurl/c/libcurl-tutorial.html
之前也有人翻译过，我参考了很多，在这里表示感谢，链接是：
http://blog.csdn.net/jgood/article/details/4787670
我有些是逐句翻译的，有些是省略了，只翻译出自己认为重要的地方。还有些地方我也有困惑，不知道如何翻译是好。有些我认为用的不多的主题，比如代理，简略了。也许翻译久了有些枯燥了，渐渐后面的多的不如刚开始的好。有上面诸多缺点，希望我翻译的不要误导到大家。能够大家一个参考，我就感到足矣。
名称
libcurl 的编程教程
目标
本文档介绍使用libcurl编程的一般原则和一些基本方法。本文主要是介绍 c 语言的调用接口，同时也可能很好的适用于其他类 c 语言的接口。
跨平台的可移植代码
libcurl库背后的开发人员投入了相当大的努力确保libcurl可以在很多不同的系统和环境里工作。
全局的准备
程序必须初始化一些libcurl的全局函数。这意味着不管你准备使用libcurl多少次，你都应该，且只初始化一次。当你的程序开始的时候，使用
curl_global_init()
这个函数需要一个参数来告诉它如何来初始化。使用CURL_GLOBAL_ALL ,它将用通常是比较好的默认参数来初始化所有已知的内部子模块。还有两个可选值：
CURL_GLOBAL_WIN32
这个参数只被用在windows 操作系统上。它让libcurl初始化win32套接字的的东西。没有正确的初始化，你的程序将不能正确的使用套接字。你应该只为每个程序做一次这样的操作，如果你的程序的其他库这样了，你就不要再让libcurl这样做。
CURL_GLOBAL_SSL
这个参数会使libcurl具有SSL的能力。你应该只为每个程序做一次这样的操作，如果你的程序的其他库这样了，你就不要再让libcurl这样做。
libcurl有个默认的保护机制，检测如果curl_global_init没有在curl_easy_perform之前被调用，那么libcurl会猜测该使用的初始化模式来执行程序。请注意，依靠默认的保护机制来这么做一点都不好。
当程序不再使用libcurl，请调用curl_global_cleanup函数来对应初始化函数所做的工作，它会做逆向的工作来清理curl_global_init所初始化的资源。
请避免重复的调用curl_global_init和 curl_global_cleanup。他们每个仅被调用一次。
libcurl所支持的功能
确定libcurl所提供功能的最佳办法是在运行的时候而不是在编译的时候。通过调用curl_version_info函数，然后查看返回信息的结构体，你知道当前的libcurl版本所支持的功能了。
使用libcurl的简单接口
首先介绍libcurl的简单接口(easy interface)，这些接口都有curl_easy的前缀。 libcurl的最近版本还提供了复杂接口(multi interface)。更多关系该接口的信息将另作讨论，为了更好的理解复杂接口，你仍然需要先了解简单接口。
为了使用简单接口，你先需要创建一个简单接口的句柄。每一个简单接口的数据通信都需要这个句柄。一般来说，你需要为每个准备传输数据的线程使用一个句柄。但你绝不能在多线程里共享相同的句柄。
获取简单句柄
easyhandle = curl_easy_init();
这个函数返回一个简单接口句柄。接下来的操作力，可以在这个`easyhandle设置各种选项。在随后的一个或者多次数据传输中，句柄只是一个逻辑实体。 通过curl_easy_setopt设置句柄的属性和选项，它们控制随后的数据传输。这些属性和选项的设置一个保存在句柄里直到它再次被设置为其他值。多次网络请求使用相同的句柄，它们的句柄选择和属性也是相同的。
很多用于设置libcurl属性都是字符串，一个指向一段以0结尾数据。当你用字符串设置 curl_easy_setopt(），libcurl会复制这个字符串的一个副本，所以你在设置后不用再保存那个字符串的内存。
在句柄上最经常设置的属性是URL。你可以这样设置它
curl_easy_setopt(handle, CURLOPT_URL, "http://domain.com/");
假如你希望得到指定URL上的远程主机的数据资源到本地。如果你想自己处理得到的数据而不是直接显示在标准输出里，你可以写一个符合下面原型的函数
size_t write_data(void *buffer, size_t size, size_t nmemb, void *userp);
你可以用类似下面这样的代码来控制libcurl将得到的数据传递到你写的函数里
curl_easy_setopt(easyhandle, CURLOPT_WRITEFUNCTION, write_data);
你还可以控制你的回调函数第四个参数得到的数据，用这样的函数原型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/816b01a2a9f651240f82bbfb952b3b73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2dc8a762c6728ab1b7a9b1a5aa813c/" rel="bookmark">
			使用ibatis时让控制台打印sql文的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在log4j.properties文件中追加以下内容。
log4j.logger.com.ibatis=debug&lt;br /&gt;
log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=debug&lt;br /&gt;
log4j.logger.com.ibatis.common.jdbc.ScriptRunner=debug&lt;br /&gt;
log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=debug&lt;br /&gt;
log4j.logger.java.sql.Connection=debug&lt;br /&gt;
log4j.logger.java.sql.Statement=debug&lt;br /&gt;
log4j.logger.java.sql.PreparedStatement=debug,base
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc59ecb17afbabbe6a5efc272f49a25a/" rel="bookmark">
			$(window).load(function() {})和$(document).ready(function(){})的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我以前的开发中，一般用到javascript，我都是采用jquery的模式，也就是大多数时候，第一行写的是：
$(document).ready(function(){...});这个时候，不一定要等所有的js和图片加载完毕，就可以执行一些方法，不过有些时候，必须要等所有的
元素都加载完毕，才可以执行一些方法的时候，比如说，部分图片或者什么其他方面还没有加载好，这个时候，点击某些按钮，会导致出现意外的情况，这个时候，就
需要用到:
$(window).load(function() {$("#btn-upload").click(function(){ //比如说：
uploadPhotos();
});
});
下面是转载的内容， 首先它们都是在页面所有元素(包括html标签以及引用到得所有图片,Flash等媒体)加载完毕后执行的,这是它们的共同点.
不用body.Onload()理由1：
如果我们想同时加载多个函数,我们必须这样写
&lt;body οnlοad="fn1(),fn2()"&gt;&lt;/body&gt;看起来极其丑陋,如果用$(window).load()我们可以这样加载多个函数
$(window).load(function() {
alert("hello,我是jQuery!");
});
$(window).load(function() {
alert("hello,我也是jQuery");
});
这样写它会从上往下执行这两个函数,并且看起来漂亮多了.
不用body.Onload()理由2：
用body.Onload()不能够做到js和html完全分离,这是一个很严重的问题.
另外用$(window).load(function(){...})和body.onload()都存在同样一个问题,因为开始也说到了,它们都需要等到页面的所有内容
加载完毕才执行,但是如果当网速比较慢的时候,加载一个页面往往需要较长的时间(几秒到十几秒不等,甚至更长...),所以我们经常
会遇到页面还没有完全加载完毕而用户已经在操作页面了这种情况,这样页面表现出来的效果就跟我们预期的效果不一样了,
所以在这里我推荐使用$(document).ready(function(){}),或简写为$(function(){})，因为他会在页面的dom元素加载完毕后就执行,
而无需等到图片或其他媒体下载完毕.
但是有时候确实我们有需要等到页面的所有东西都加载完后再执行我们想执行的函数,所以是该使用$(window).load(function(){...})还是
该使用$(function(){})往往需要结合具体需要而作不同的选择.
最后附上一段在所有DOM元素加载之前执行的jQuery代码
&lt;script type="text/javascript"&gt;
(function() {
alert("DOM还没加载哦!");
})(jQuery)
&lt;/script&gt;
=======================================================
用$(window).load(function(){...})而不用body.onload()的几个理由 =============================================================
jQuery内ready与load事件的区别 jQuery内ready与load事件的区别 我之所以转载这篇文章,是因为我前两天在写http://hi.baidu.com/see7di/blog/item/c2ba78601de67c5deaf8f8e9.html这个的时候曾经碰到过ready与load的问题.所以转载过来看一下.
在前面小节中曾经介绍过jQuery定义的ready事件和JavaScript默认的load事件。下面我们来比较这两个事件的区别。为了理解这两个事件的异同，读者应该先了解HTML文档加载的顺序。
DOM文档加载是按顺序执行的，这与浏览器的渲染方式有关系。一般浏览器渲染操作的顺序大致按如下几个步骤来完成。
(1) 解析HTML结构。
(2) 加载外部脚本和样式表文件。
(3) 解析并执行脚本代码。
(4) 构造HTML DOM模型。
(5) 加载图片等外部文件。
(6) 页面加载完毕。
具体说明如下。
1. 执行时机
load事件必须等到网页中所有内容全部加载完毕之后才被执行。如果一个页面中包含了大容量的多媒体文件，则就会出现这种情况：网页文档已经呈现出来，但由于网页数据还没有完全加载完毕，导致load事件不能够即时被触发。
开发人员习惯把页面初始化设置的脚本都放在load事件处理函数中，由于页面数据没有完全加载进来，导致网页文档呈现和脚本初始化配置不能够保持同步，从而影响了页面的可用性。
而jQuery的ready事件是在DOM结构绘制完毕之后就执行，也就是说它在外部文件加载之前就被执行了，这样就能够确保网页文档的呈现和脚本初始化设置保持同步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc59ecb17afbabbe6a5efc272f49a25a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0795659fd214d18cc3073eeb1a28dfa/" rel="bookmark">
			python时间处理之datetime
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行环境:Python3.4 # -*- coding: utf-8 -*- #datetime类 #datetime是date与time的结合体，包括date与time的所有信息。 #它的构造函数如下： #datetime. datetime (year, month, day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] ) #各参数的含义与date、time的构造函数中的一样，要注意参数值的范围。 # 1. datetime类定义的类属性与方法： #datetime.min、datetime.max：datetime所能表示的最小值与最大值； #print: datetime.max: 9999-12-31 23:59:59.999999 #print: datetime.min: 0001-01-01 00:00:00 from datetime import * import time print ('datetime.max:' +str(datetime.max )) print ('datetime.min:' +str(datetime.min)) #datetime.resolution：datetime最小单位； #print: datetime.resolution: 0:00:00.000001 print ('datetime.resolution:' + str(datetime.resolution )) #datetime.today()：返回一个表示当前本地时间的datetime对象； #print: today(): 2012-09-12 19:37:50.721000 print ('today():' +str(datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0795659fd214d18cc3073eeb1a28dfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c560f99600ce9a05f6cf815a0f3a0d65/" rel="bookmark">
			向下取整floor函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 floor函数 floor(x),有时候也写做Floor(x)，其功能是“下取整”，或者说“向下舍入”，即取不大于x的最大整数(与“ 四舍五入”不同，下取整是直接去掉小数部分)，例如： x=3.14，floor(x)=3 y=9.99999，floor(y)=9 在C语言的库函数中，floor函数的语法如下： #include &lt;math.h&gt; double floor( double arg ); 功能： 函数返回参数不大于 arg的最大整数。例如, x = 6.04; y = floor( x ); y的值为6.0. 与floor函数对应的是ceil函数，即上取整函数。 有趣的是，floor在英文中是地板的意思，而ceil是天花板的意思，很形象地描述了下取整和上取整的数学运算。 说明：如果任一参数为非数值参数，则 FLOOR 将返回错误值 #VALUE!。 如果 number 和 significance 符号相反，则函数 FLOOR 将返回错误值 #NUM!。 不论 number 的正负号如何，舍入时参数的 绝对值都将减小。如果 number 恰好是 significance 的倍数，则无需进行任何舍入处理。 FLOOR 用途：将参数Number沿绝对值减小的方向去尾舍入，使其等于最接近的significance的倍数。 语法：FLOOR(number，significance) 参数：Number为要舍入的某一数值，Significance为该数值的倍数。 实例：如果A1=22.5，则公式“=FLOOR(A1，1)”返回22;=FLOOR(-2.5，-2)返回-2。 “使其等于最接近的significance的倍数”,比如： 如果A1=22.5，则公式“=FLOOR(A1，1)“ 结果就是22，22最接近1的倍数 如果A1=22.5，则公式“=FLOOR(A1，3)“ 结果就是21，21最接近3的倍数 如果A1=25.8，则公式“=FLOOR(A1，3)“ 结果就是24，24最接近3的倍数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1b337b3f91e14b21fbe45a31c30110/" rel="bookmark">
			Nuke基本合成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#! D:/Program Files/Nuke6.3v4/Nuke6.3.exe -nx
version 6.3 v4
define_window_layout_xml {&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;layout version="1.0"&gt;
&lt;window x="310" y="153" w="1157" h="895" screen="0"&gt;
&lt;splitter orientation="1"&gt;
&lt;split size="725"/&gt;
&lt;splitter orientation="1"&gt;
&lt;split size="40"/&gt;
&lt;dock id="" hideTitles="1" activePageId="Toolbar.1"&gt;
&lt;page id="Toolbar.1"/&gt;
&lt;/dock&gt;
&lt;split size="681"/&gt;
&lt;splitter orientation="2"&gt;
&lt;split size="0"/&gt;
&lt;dock id=""/&gt;
&lt;split size="841"/&gt;
&lt;dock id="" activePageId="DAG.1"&gt;
&lt;page id="DAG.1"/&gt;
&lt;page id="Curve Editor.1"/&gt;
&lt;page id="DopeSheet.1"/&gt;
&lt;/dock&gt;
&lt;/splitter&gt;
&lt;/splitter&gt;
&lt;split size="420"/&gt;
&lt;dock id="" activePageId="Properties.1"&gt;
&lt;page id="Properties.1"/&gt;
&lt;/dock&gt;
&lt;/splitter&gt;
&lt;/window&gt;
&lt;window x="2025" y="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1b337b3f91e14b21fbe45a31c30110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ccbc16677431efdc5a3540015cd89b/" rel="bookmark">
			COCOS2D中对精灵的操作、对图片的各种操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于精灵的各种操作，总结一下以便以后复习查找。 内容简要：
1、初始化 2、创建无图的精灵 3、设置精灵贴图大小 4、添加入层中
5、对精灵进行缩放 6、对精灵款或高进行缩放 7、旋转精灵
8、设置精灵透明度 9、精灵的镜像反转 10、设置精灵的颜色
11、得到图的宽高 12、按照像素设定图片大小 13、在原有的基础上加xy的坐标
14、设置图片锚点 15、从新排列z轴顺序 16、更换精灵贴图
17、设置可视区域 18、贴图无锯齿
//初始化
CCSprite* sprite =[CCSprite spriteWithFile:@"Icon.png"];
//创建无图的精灵
CCSprite*sprite2 =[CCSprite node];
//设置精灵贴图大小
sprite2.textureRect=CGRectMake(0, 0, 20, 20);//设置其为宽20，高20.
//添加入层中
[self addChild:sprite z:2]; //将精灵加入层中设置其z轴为2
//对精灵进行缩放
sprite.scale=2;//放大2倍
//对精灵款或高进行缩放
sprite.scaleX = 2;//宽放大2倍 sprite.scaleY = 2;//高放大2倍
//旋转精灵
sprite.rotation=90;//旋转90度
//设置精灵透明度
sprite.opacity=255;//设置透明度为完全不透明（范围0～255）
//定义精灵位置
sprite.position=ccp(100,100);//设置精灵中心点坐标是x=100，y=100
//精灵的镜像反转
[sprite setFlipX:YES];//X轴镜像反转
[sprite setFlipY:YES];//Y轴镜像反转
//设置精灵的颜色
[sprite setColor:ccc3(255, 0, 0)];//设置颜色为红色
//得到图的宽高
float contentSize = sprite .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53ccbc16677431efdc5a3540015cd89b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21531062a2c8bf7c1286d26a366b395c/" rel="bookmark">
			正则表达式以“，”为分隔符分割CSV文件的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import java.util.regex.Pattern;import java.util.regex.Matcher;public class Test {public static void main(String[] args) {String str = "dw,\"kk,ll\",\",yioi\",iu,\",\",r3,\"\"\"fte\",l,\"kk\"\"ll\",mm'oo,\"n\"\"dw,erw\"\",e\",, ";String regex = "\\G(?:^|,)(?:\"([^\"]*+(?:\"\"[^\"]*+)*+)\"|([^\",]*+))";Matcher main = Pattern.compile(regex).matcher(str);Matcher mquote = Pattern.compile("\"\"").matcher("");while (main.find()) {String field;if (main.start(2) &gt;= 0) {field = main.group(2);} else {field = mquote.reset(main.group(1)).replaceAll("\"");}System.out.println("Field [" + field + "]");}System.out.println("dw kk,ll ,yioi iu , r3 \"fte l kk\"ll mm'oo n\"dw,erw\",e");}} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/856055000a8b6b4d75e56d14544269d5/" rel="bookmark">
			RHEL各版本的XManager4远程配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Red Hat 7,Red Hat 8,Red Hat 9,Red Hat 3.0 AS 下配置 XDMCP 连接 1. XDM Configuration 1.将系统的运行级别设置为5，具体如下： 打开/etc/inittab。修改参数 id：5：initdefault; 2. 激活 XDMCP 为 GDM: 打开/etc/X11/gdm/gdm.conf,然后在打开的编辑中为[xdmcp]设置一个参数如下： [xdmcp] Enable=1 For KDM: #RHEL默认是GDM，没有安装KDM的下面的路径是找不到的，所以不用去配置这个，这里只是给个概念。以下也是一样。
打开/etc/X11/xdm/xdm-config并做以下修改： DisplayManager.requestPort: 0 ==&gt; !DisplayManager.requestPort: 0 打开/etc/X11/xdm/Xaccess，并做以下修改： #* #any host can get a login window ==&gt; * #any host can get a login window 在[xdmcp]下添加Enable=true。格式如下：[xdmcp] Enable=true 2. 防火墙配置 如果我们的Linux机器配置有防火墙，为防止防火墙将通过177端口（即xdmcp服务）的数据过虑。 #iptables -A INPUT -p udp -s 0/0 -d 0/0 --dport 177 -j ACCEPT。 若没有防火墙则可跳过这一项 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/856055000a8b6b4d75e56d14544269d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f594fb41b300ea0dc05ed91700504a/" rel="bookmark">
			Boot（启动设备设置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Boot（启动设备设置） 本选单是更改系统系统启动装置和相关设置的，再Bios中较为重要。
一. Boot Device Priority（启动装置顺序） 本项目是设置开机时系统启动存储器的顺序，比如大家在安装操作系统时要从光驱启动，就必须把1st Device Priority设置成为你的光驱，图上设置的是硬盘，所以当系统开机时第一个启动的是硬盘，建议大家如果不是要从光驱启动，就把第一启动设置成为硬盘，其他的启动项目设置成为Disable，这样系统启动就会相对快一点，因为系统不用去搜索其他多余的硬件装置！
二. Boot Settings Configuration（启动选项设置） 这里是设置系统启动时的一些项目的！它可以更好的方便用户的习惯或者提升系统性能。
1. QuickBoot（快速启动）设置
本项目可以设置计算机是否在启动时进行自检功能，从而来加速系统启动速度，如果设置成“Disable”系统将会在每次开机时执行所有自检，但是这样会减慢启动速度！一般设置为“Enabled”
2. Full Screen Logo（全屏开机画面显示设置）
这里是设置是否开启开机Logo的设置的，如果你不想要开机Logo就可以设置为“Disable”
3. Add On ROM Display Mode（附件软件显示模式）
本项目是让你设定的附件装置软件显示的模式，一般设置成“Force BIOS”就可以了。
4. Bootup Nun－Lock（小键盘锁定开关）
就是设置开机时是否自动打开小键盘上的Num－Lock。一般设置为On
5. PS/2 Mouse Support
此项目时设置是否支持PS/2鼠标功能。设定为AUTO就可以。
6. Typematic Rate（键盘反映频率设置）
这个就是让你选择键盘反映快慢频率的选项，一般设置为“fast”
7. Boot To OS/2（OS/2系统设置）
本项目让你选择是否启动OS/2作业系统兼容模式，一般设置为“No”
8. Wait For ‘F1’ If Error （错误信息提示）
本项目是设置是否在系统启动时出现错误时显示按下“F1”键确认才继续进行开机，一般设置为“Enabled”
9. Hit ‘DEL’Messgae Display （按DEL键提示）
这个选项选择是否在开机时显示按下Del键进入Bios设定的提示，如果选择“Disable”将不会看到本文章开头的那句“Press DEL to Run Steup,Presss TAB to display BIOS Post Message”的提示，一般设置为“Enabled”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57f594fb41b300ea0dc05ed91700504a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48dfd9f7a7777db56b90243b5ab8a3cc/" rel="bookmark">
			Cocos2d 如何暂停一个动作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这也是群里问的一个问题。。。。
第一反应 [node stopActionByTag: ];
后来发现 不对吖。。。。这样是 stop 而不是 暂停吖。。
然后想暂停和继续是什么东西呢？ 是 pause 和 resume
然后去看ccnode的头文件，你会发现 只有 pauseAllScheduleAndActions 这个选项 可没有 by tag了。。
这不就神奇了么。。。。这么简单的问题 居然没有接口来实现它。。。。
那么就去看了下CCAction 的头文件
里面有：
+(id) action;
-(id) init;
-(id) copyWithZone: (NSZone*) zone;
-(BOOL) isDone;
-(void) startWithTarget:(id)target;
-(void) stop;
-(void) step: (ccTime) dt;
-(void) update: (ccTime) time;
也没有 pause。。那么 有没有可能 stop 后 在通过 update 或者 step 重新运行呢。。。
试了半天 无果
然后就又去试了一下 stop 之后的 isDone。。
结果发现返回的仍然是NO
也就是说 如果我的动作没有完全运行到底的话 他是不会认为已经结束了。。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48dfd9f7a7777db56b90243b5ab8a3cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ec7282d2799fd29acd40f176517059d/" rel="bookmark">
			用fileupload组件上传文件出现乱码解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用fileupload组件上传文件出现乱码解决方法www.yjyunda.com/art 2006-5-20 星语文章我们用apache的fileupload组件上传文件,如果不做任何出理,通常会出现文件名乱码或普通text文本框值的乱码,那么,我们该如何处理呢?其实,fileupload组件提供了一个设置编码的接口,在没有指定编码时使用系统缺省的encoding,如果需要使用gbk,可以使用该接口进行设置,如://FileUploadBase fb = new FileUpload(new DefaultFileItemFactory());//fb.setHeaderEncoding("GBK");DiskFileUpload fu = new DiskFileUpload();fu.setHeaderEncoding("GBK");这样,获取的文件名就不会乱码了,但普通文本框的值却还是乱码,我们还要对文本值进行处理,中文的text字段可以通过title = new String((fileItem.getString("iso8859-1")).getBytes("iso8859-1"),"GBK"); 来获取UTF-8的也是同理,祝在家好运.http://www.yjyunda.com/art/list.asp?id=729
common-fileupload是jakarta项目组开发的一个功能很强大的上传文件组件
下面先介绍上传文件到服务器（多文件上传）：
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;
import java.util.regex.*;
import org.apache.commons.fileupload.*;
public class upload extends HttpServlet {
private static final String CONTENT_TYPE = "text/html; charset=GB2312";
//Process the HTTP Post request
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
response.setContentType(CONTENT_TYPE);
PrintWriter out=response.getWriter();
try {
DiskFileUpload fu = new DiskFileUpload();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ec7282d2799fd29acd40f176517059d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d62e984efdb3dd7c183ec90fbdd41bfc/" rel="bookmark">
			Source Insight宏 -  头文件与源文件切换（不限目录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面发布的帖子：Source Insight 宏 - 头文件与源文件切换用到的切换宏有一定的限制（要求在同一目录下），如源码结构为src、include、test时，include下头文件与src下源文件之间就不能实现切换，在使用过程中不免会产生一点影响，今天将其进行了修改，经测试可以达到不同目录下的文件切换，对目录再没有要求，但是同时如果源码中存在多个相同文件名（不同目录下）时，需要用户自己选择相应的文件。
宏代码如下，也可以从我的资源中直接下载em文件。
/** cpp和hpp文件互换(不限目录) 作者: 王丰亮 时间: 2012.2.18 */ macro SwitchCppAndHpp() { hwnd = GetCurrentWnd() hCurOpenBuf = GetCurrentBuf() if (hCurOpenBuf == 0)// empty buffer stop // 文件类型临时缓冲区 strFileExt = NewBuf("strFileExtBuf") ClearBuf(strFileExt) // 头文件 index_hpp_begin = 0 // 头文件开始索引 AppendBufLine(strFileExt, ".h") AppendBufLine(strFileExt, ".hpp") AppendBufLine(strFileExt, ".hxx") index_hpp_end = GetBufLineCount(strFileExt) // 头文件结束索引 // 源文件 index_cpp_begin = index_hpp_end // 源文件开始索引 AppendBufLine(strFileExt, ".c") AppendBufLine(strFileExt, ".cpp") AppendBufLine(strFileExt, ".cc") AppendBufLine(strFileExt, ".cx") AppendBufLine(strFileExt, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d62e984efdb3dd7c183ec90fbdd41bfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32d492a1f6d6a7ad525763a405fd682/" rel="bookmark">
			Asp 结合JQuery EasyUI 框架完成的一个增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Asp 结合JQuery EasyUI 框架完成的一个增删改查 $(document).ready(function(){ $("#addPayOrder").linkbutton({text:"添加"}); $("#editPayOrder").linkbutton({text:"修改"}); $("#delPayOrder").linkbutton({text:"删除"}); //绑定右键菜单 $("#TRData").bind("contextmenu",function(e){ $("#menu").menu("show",{ left: e.pageX, top: e.pageY }); return false; }); //添加订单 $("#addPayOrder").click(function(){ //$("#w").find("input[type='text']").val(""); //清空所有的文本框值和文本域的值 $(":input").each(function(){ if($(this).attr("type")=="text"||$(this).attr("type")=="textarea"){ $(this).val(""); } }) var user=$("#HUserID").val(); if(user!=""){ $("#txtUserID").val(user); } //$("#txtUserID").removeAttr("disabled"); document.getElementById("hiddenAction").value="Add"; openWin("添加用户订单"); $('#w').window("open"); GetProdSubNameById($("#selProdID").val());//获取选择产品的产品子类 }); //修改订单 $("#editPayOrder").click(function(){ //$("#w").find("input[type='text']").val(""); //清空所有的文本框值 $(":input").each(function(){ if($(this).attr("type")=="text"||$(this).attr("type")=="textarea"){ $(this).val(""); } }); document.getElementById("hiddenAction").value="Edit"; var selectTR=$("#hiddenValue").val(); //单击或双击一行时给hiddenValue 赋值 if(selectTR==""){ msgBox("系统提示","请先选择一行在进行修改操作！","error"); }else{ openWin("修改订单"); $('#w').window("open"); GetPayOrderInfoById(selectTR); GetTotalMoney();//计算总费用 GetProdSubNameById($("#hiddenProdID").val());//获取选择产品的产品子类 } }); //删除订单 $("#delPayOrder").click(function(){ var selectTR=$("#hiddenValue").val(); if(selectTR==""){ msgBox("系统提示","请先选择一行在进行修改操作！","error"); }else{ $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f32d492a1f6d6a7ad525763a405fd682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c16e40f92d407b7c416411bd0e61945e/" rel="bookmark">
			在CMD下使用sc命令，报openservice failed 1060错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CMD下使用sc命令，删除tomcat服务，报openservice failed 1060错误
原因：服务里的tomcat服务的状态是禁止状态，如果改为自动状态就可以用sc delete tomcat
注意：虽然服务名为Apache tomcat 但删除tomcat 服务时不用加Apache
总结：
删除windows服务两个办法：
办法一： 用sc.exe这个Windows命令
开始——运行——cmd.exe，然后输入sc就可以看到了。使用办法很简单：
sc delete "服务名" (如果服务名中间有空格，就需要前后加引号）
如针对上面的： sc delete Service 方法二：直接进行注册表编辑（不推荐）
打开注册表编辑器，找到下面的键值：
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services 一般服务会以相同的名字在这里显示一个主健，直接删除相关的键值便可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d2b35084049d26484febe6903fb873/" rel="bookmark">
			VB.Net类型转换——全角半角间转换（StrConv）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用StrConv，指定转换类型，可以方便的进行字符串的转换。比如，需要将一串繁体中文转换为简体中文，如下：
Dim strTraditionalCn As String = "將字串轉換成簡體中文字元"
Dim strSimplifiedCnn As String = String.Empty
strSimplifiedCnn = StrConv(strTraditionalCn ,VbStrConv.SimplifiedChinese)
Console.Writeline(strSimplifiedCnn ) 输出：将字符串转换成简体中文字元
又如，如果需要将全角数字转换成半角数字，则可以使用：
StrConv("２２２２２",VbStrConv.Narrow)
详细的转换类型如下：
成员名称说明None 不执行转换。 Uppercase 将字符串转换为大写字符。 该成员等效于 Visual Basic 常数 vbUpperCase。 Lowercase 将字符串转换为小写字符。 该成员等效于 Visual Basic 常数 vbLowerCase。 ProperCase 将字符串中每个单词的首字母转换为大写。 该成员等效于 Visual Basic 常数 vbProperCase。 Wide 将字符串中的窄（单字节）字符转换为宽（双字节）字符。 应用于亚洲区域设置。 该成员等效于 Visual Basic 常数 vbWide。 Narrow 将字符串中的宽（双字节）字符转换为窄（单字节）字符。 应用于亚洲区域设置。 该成员等效于 Visual Basic 常数 vbNarrow。 Katakana 将字符串中的平假名字符转换为片假名字符。 仅应用于日文区域设置。 该成员等效于 Visual Basic 常数 vbKatakana。 Hiragana 将字符串中的片假名字符转换为平假名字符。 仅应用于日文区域设置。 该成员等效于 Visual Basic 常数 vbHiragana。 SimplifiedChinese 将字符串转换为简体中文字符。 该成员等效于 Visual Basic 常数 vbSimplifiedChinese。 TraditionalChinese 将字符串转换为繁体中文字符。 该成员等效于 Visual Basic 常数 vbTraditionalChinese。 LinguisticCasing 将字符串从大小写文件系统规则转换为语义规则。 该成员等效于 Visual Basic 常数 vbLinguisticCasing。 MSDN参考资料：http://msdn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71d2b35084049d26484febe6903fb873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae862de08210c4f42a6f71474bfda8e1/" rel="bookmark">
			VB6.0对全角半角字符串进行混合截位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 '--------------------------------------------------------------------- ' 文字列の先頭から指定した桁数を取り出す ' 引数：　sData　処理前文字列 ' iLen 取り出す桁数 ' iMode 処理モード ' 戻り値：LeftString 処理後文字列 '---------------------------------------------------------------------- Function LeftString(ByVal sData As String, ByVal iLen As Integer, Optional ByVal iMode As Integer = 0) As String ' バイトデータを格納用 Dim bBuffer() As Byte ' 全角文字があるかどうか判定用 Dim bChinesePrev As Boolean Dim iLoop As Integer ' 文字列をユニコードに転換する bBuffer = StrConv(sData, vbFromUnicode) bChinesePrev = False iLoop = 0 ' 全角文字があるかどうかを判定する If iLen &lt; UBound(bBuffer) + 1 Then For iLoop = 0 To iLen - 1 If bBuffer(iLoop) &gt;= 160 Then bChinesePrev = Not bChinesePrev End If Next iLoop End If ' 文字列の先頭から指定した桁数を取り出す If bChinesePrev Then Select Case iMode Case 0 LeftString = StrConv(LeftB(bBuffer, iLen), vbUnicode) Case 1 LeftString = StrConv(LeftB(bBuffer, iLen - 1), vbUnicode) Case 2 LeftString = StrConv(LeftB(bBuffer, iLen + 1), vbUnicode) End Select Else LeftString = StrConv(LeftB(bBuffer, iLen), vbUnicode) End If End Function 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/214/">«</a>
	<span class="pagination__item pagination__item--current">215/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/216/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>