<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ea93dd8db3dfccaf50dc8955785b13a/" rel="bookmark">
			Java GUI 实现登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体效果图： 详细代码： package java_gui; import java.awt.Color; import java.awt.Container; import java.awt.Cursor; import java.awt.Font; import java.awt.Image; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.ImageIcon; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JComboBox; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JPasswordField; import javax.swing.JRootPane; import javax.swing.JTextField; public class Login extends JFrame { private static final long serialVersionUID = -6788045638380819221L; //用户名 private JTextField ulName; //密码 private JPasswordField ulPasswd; //小容器 private JLabel j1; private JLabel j2; private JLabel j3; private JLabel j4; //小按钮 private JButton b1; private JButton b2; private JButton b3; //复选框 private JCheckBox c1; private JCheckBox c2; //列表框 private JComboBox&lt;String&gt; cb1; /** * 初始化QQ登录页面 * */ public Login() { //设置登录窗口标题 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ea93dd8db3dfccaf50dc8955785b13a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c55fde0110f8cccd6d94702f53707e/" rel="bookmark">
			【剑指Offer系列12】矩阵中的路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目代码PythonC++ 题目 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
[[“a”,“b”,“c”,“e”],
[“s”,“f”,“c”,“s”],
[“a”,“d”,“e”,“e”]]
但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
示例 1：
输入：board = [[“A”,“B”,“C”,“E”],[“S”,“F”,“C”,“S”],[“A”,“D”,“E”,“E”]], word = “ABCCED”
输出：true
示例 2：
输入：board = [[“a”,“b”],[“c”,“d”]], word = “abcd”
输出：false
提示：
1 &lt;= board.length &lt;= 200
1 &lt;= board[i].length &lt;= 200
代码 Python # 思路： # 二维矩阵路径搜索问题，采用回溯法 # 复杂度： # O(3^L*M*N), L是字符串长度，M行N列 class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: def dfs(i,j,k): # 超出索引或不匹配，返回False if not 0&lt;=i&lt;len(board) or not 0&lt;=j&lt;len(board[0]) or board[i][j]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c55fde0110f8cccd6d94702f53707e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76725a57f9ae5b3df83994a55819e903/" rel="bookmark">
			【剑指Offer系列11】旋转数组的最小数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 题目代码PythonC++ 题目 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。
示例 1：
输入：[3,4,5,1,2]
输出：1
示例 2：
输入：[2,2,2,0,1]
输出：0
代码 Python # 思路： # 二分查找法 # 复杂度： # O(logN) class Solution: def minArray(self, numbers: List[int]) -&gt; int: i, j = 0, len(numbers)-1 # 左右指针 while i&lt;j: m=(i+j)//2 if numbers[m]&lt;numbers[j]: j=m elif numbers[m]&gt;numbers[j]: i=m+1 else: j-=1 return numbers[i] C++ class Solution { public: int minArray(vector&lt;int&gt;&amp; numbers) { int i=0, j=numbers.size()-1; while (i&lt;j) { int m = (i+j)/2; if (numbers[m]&lt;numbers[j]) j=m; else if (numbers[m]&gt;numbers[j]) i=m+1; else j--; } return numbers[i]; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9066440241d286139912d38e2433f03/" rel="bookmark">
			程序员趣味儿逻辑题！5分钟出正确答案算你达标！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逻辑测试题 老师在三张贴纸上各写了一个正整数，
三个学生只能看到另外两人的数字，但看不到自己的。
老师告诉他们，其中两个数字的和等于第三个。
老师问他们是否能猜出自己的数字，
A：“我猜不出来”
B：“我猜不出来”
C：“我猜不出来”
于是，老师再问一次“能猜出自己的数字吗？”。
A：“猜不出”
B：“猜不出”
C：“我知道了，我的数字是144.”
C的数字的确是144，请问。另外两个数字是多少？
答案在下面，不要偷看哦，计时5分钟，开始！！ ~~~~~~~~~~~~~~~~~~~~~我是分割线~~~~~~~~~~~~~~~~~我是分割线~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
答案 另两个数字分别是：96跟48。
对于三个正整数，自己的数字只能是另两个数字的和或者差（大减小）。如果能确定是和或差，就能算出自己的数字。
三人都说猜不出来，说明：三个数字两两不相等，因为如果看到两个数相等就知道自己的数字一定是他们的和。
C突然猜出来了，则只可能是C把“差”排除了，即另两个数的差等于被减数了，导致两数相等，与前面的推导矛盾。所以，C的数字就是另两数的和。
即：
a+b=144
a-b=b
所以，b=48，a=96。
AB看到的另两个数字并无此特点，故猜测不出来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9589741c8a19c6647934e2aae8e4943b/" rel="bookmark">
			【剑指Offer系列10-2】青蛙跳台阶问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 题目代码PythonC++ 题目 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2
输出：2
示例 2：
输入：n = 7
输出：21
提示：
0 &lt;= n &lt;= 100
代码 Python # 思路： # 避免重复计算，弃用递归，采用动态规划；实质就是裴波那契数列 # 复杂度： # O(N) class Solution: def numWays(self, n: int) -&gt; int: if n&lt;0: return -1 elif n==0: return 1 elif n==1: return 1 else: dp = {} dp[0] = 1 dp[1] = 1 for i in range(2, n+1): dp[i] = (dp[i-1]+dp[i-2])%1000000007 return dp[n] C++ class Solution { public: int numWays(int n) { if (n&lt;0) return -1; if (n==0) return 1; if (n==1) return 1; else { int dp[n+1]; dp[0]=1;dp[1]=1; for (int i=2; i&lt;n+1; i++) { dp[i] = (dp[i-1]+dp[i-2])%1000000007; } return dp[n]; } } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4027b2d45b6c8bc45605f92cf8f7bf4/" rel="bookmark">
			【剑指Offer系列10-1】斐波那契数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 题目代码PythonC++ 题目 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2
输出：1
示例 2：
输入：n = 5
输出：5
提示：
0 &lt;= n &lt;= 100
代码 Python # 思路： # 避免重复计算，弃用递归，采用动态规划 # 复杂度： # O(N) class Solution: def fib(self, n: int) -&gt; int: if n&lt;0: return -1 elif n==0: return 0 elif n==1: return 1 else: dp={} # 不用列表，防止栈溢出 dp[0]=0 dp[1]=1 for i in range(2,n+1): dp[i] = (dp[i-1]+dp[i-2]) % 1000000007 return dp[n] C++ class Solution { public: int fib(int n) { if (n&lt;0) return -1; if (n==0) return 0; if (n==1) return 1; else { int dp[n+1]; dp[0]=0; dp[1]=1; for (int i=2; i&lt;n+1; i++) { dp[i]=(dp[i-1]+dp[i-2]) % 1000000007; } return dp[n]; } } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b537362424d48688e681fa8f2211a3e/" rel="bookmark">
			【剑指Offer系列06】从尾到头打印链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目代码PythonC++ 题目 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
示例 1：
输入：head = [1,3,2]
输出：[2,3,1]
限制：
0 &lt;= 链表长度 &lt;= 10000
代码 Python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None # 思路： # 打印且不改变链表结构，采用辅助栈或递归 # 复杂度： # O(N) class Solution: def reversePrint(self, head: ListNode) -&gt; List[int]: stack = [] while head: stack.append(head.val) head = head.next return stack[::-1] C++ /** * Definition for singly-linked list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b537362424d48688e681fa8f2211a3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e494923e0724ea8c4403ad7761424c/" rel="bookmark">
			用python 读取excel 指定列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 df = pd.read_excel(“文件id”, usecols=[0, 5]) # 指定读取第1列和第6列 df = pd.read_excel(“文件id””, usecols=[0]) # 指定读取第1列 df = pd.read_excel(“文件id””, usecols=[0, 1，2]) # 指定读取第1列、第2列第三 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85fad5cdbb42a25aa6451bb5347e91d0/" rel="bookmark">
			Initialization failed for ‘https://start.spring.io‘ Please check URL, network and proxy settings.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用ctrl+alt+s快捷键打开设置界面。
2.选择Appearance &amp; Beahavior -&gt; System Settings-&gt; HTTP Proxy
3.选择第二个:Auto-detet proxy settings
4.点击Check onnetion，在弹出的提示框中输入 https://start.spring.io 后ok即可
5.连接成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d138784176dc9cb7e94e002bb80c31c8/" rel="bookmark">
			css学习笔记一（flex与一些选择器)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @CSS学习笔记一（flex布局与一些选择器的作用)
css选择器及作用
兄弟选择器：选择并设置所有 样式和所有 元素的样式：
h1,p
{
background-color:yellow;
}
后代选择器：选择并设置位于
元素内部的每个 元素的样式:
div p { background-color:yellow; } flex布局：
Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。
任何一个容器都可以指定为Flex布局。
行内元素也可以使用Flex布局。
注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。
属性：
flex-direction：flex-direction属性决定主轴的方向（即项目的排列方向）。
row（默认值）：主轴为水平方向，起点在左端。
row-reverse：主轴为水平方向，起点在右端。
column：主轴为垂直方向，起点在上沿。
column-reverse：主轴为垂直方向，起点在下沿。
flex-wrap：默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 flex-flow：flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; } justify-content：justify-content属性定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items：align-items属性定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a7b82252b8fa05a1600f24e42864d2/" rel="bookmark">
			springboot&#43;shiro实现自定义密码加密及验证(Bcrypt)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot+shiro实现自定义密码加密及验证 前言正文1.创建一个类，继承 `SimpleCredentialsMatcher` 类2.修改 身份认证Realm3.修改你继承 `AuthorizingRealm` 类中的 `doGetAuthenticationInfo` 方法4. 工具类中 `BCrypt` 类获得方式5.`BcryptUtil`工具类 前言 本篇文章不展示如何集成springboot和shiro，仅展示自定义密码加密方式的相关部门，如何集成请查看其它相关文章
正文 因shiro没有集成Bcrypt加密方式，需要自己去继承实现相关方法。
1.创建一个类，继承 SimpleCredentialsMatcher 类 此类用于重写验证密码方法，验证完成后返回true false来告诉shiro密码是否正确。 public class CustomCredentialsMatcher extends SimpleCredentialsMatcher { @Override public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) { //获得前台传过来的密码 String originalPassword=(String)token.getCredentials(); //这是数据库里查出来的密码 String sqlOriginalPassword=(String)info.getCredentials(); //进行比对，BcryptUtil工具类会在文章末尾放出 return BcryptUtil.match(originalPassword,sqlOriginalPassword); } } 2.修改 身份认证Realm 将上面重写的类注入到Realm中
3.修改你继承 AuthorizingRealm 类中的 doGetAuthenticationInfo 方法 因shiro自带加密中salt都需要单独放一个字段，Bcrypt的salt是包含在password里面的，所以
返回的信息中不需要带salt（你要愿意也可以放进去，反正用不到）。
4. 工具类中 BCrypt 类获得方式 **注意：**工具类中 BCrypt 类 可以通过引入两种依赖获得。
1.直接引入
&lt;dependency&gt; &lt;groupId&gt;de.svenkubiak&lt;/groupId&gt; &lt;artifactId&gt;jBCrypt&lt;/artifactId&gt; &lt;version&gt;0.4.1&lt;/version&gt; &lt;/dependency&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4a7b82252b8fa05a1600f24e42864d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e721d20810e29dce99640dbbd746ede8/" rel="bookmark">
			ubuntu 宿主机无法访问docker内的服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因：docker网卡地址冲突
解决：
前提: brctl命令需要安装
sudo apt-get install -y bridge-utils 设置网卡信息
sudo service docker stop sudo ip link set dev docker0 down sudo brctl delbr docker0 sudo iptables -t nat -F POSTROUTING sudo brctl addbr docker0 sudo ip addr add 172.16.10.1/24 dev docker0 sudo ip link set dev docker0 up 修改daemon.json文件。centos上安装后有此文件，但是ubuntu上需要自己创建文件。
vim vi /etc/docker/daemon.json 示例:
{ "registry-mirrors": ["https://cqiunwxe.mirror.aliyuncs.com"],// 加速器 "bip": "172.16.10.1/24"// 添加该句内容 } 重启docker
systemctl restart docker 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/569429e6e9c7325e499038558223dc51/" rel="bookmark">
			webstorm常用插件集合(2020)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN 中文章可能更新不及时，请前往我的博客查看最新版 2016 年整理了一下自己常用的 webstorm 插件：webstorm常用插件集合
不过毕竟现在已经 2020 年了，常用的插件已经发生了一些变化，重新整理一下。
一、必装 这一部分是建议一定要装的插件，对开发体验或工作效率有较大提升的插件。
Material Theme UI 如果没有这个插件，webstorm 怕是会被很多人丑拒，用上之后配色还是很不错的，默认内置了多种配色，Preferences/Settings -&gt; Appearance -&gt; Material Theme 中可以进行切换。
.ignore 直接在文件列表中右键，可以快速根据模板生成一系列的 .ignore 文件，比如 .dockerignore、.gitignore 等等。
CodeGlance sublime 和 vscode 都默认会在编辑器右侧显示代码缩略图，webstorm 需要自己装插件实现，这个插件就是用来干这个的。
代码缩略图的边缘还可以对宽度进行调整，很不错。
GitToolBox 官方描述是：
Extends Git Integration with additional features
Status display, auto fetch, inline blame annotation, commit dialog completion, behind notifications and more…
其实就是给 ide 扩展了一下 git 相关的功能，比如会自动帮你 fetch 最新的代码（我之前都是两下 shift，然后输入 fetch 查找到对应的命令然后回车，麻烦），单行代码后面显示提交信息等等。
二、选装 这一部分是选装的插件，针对特定的技术选型或者业务场景需要使用到的插件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/569429e6e9c7325e499038558223dc51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9155600e5c3398fd5c5058c2ebb546f/" rel="bookmark">
			【剑指Offer系列05】替换空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目代码PythonC++ 题目 请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
示例 1：
输入：s = "We are happy." 输出："We%20are%20happy." 限制：
0 &lt;= s 的长度 &lt;= 10000
代码 Python # 思路： # 字符串不可变，故新建list存储新字符串 # 复杂度： # O(N) class Solution: def replaceSpace(self, s: str) -&gt; str: res = [] for c in s: if c==" ": res.append("%20") else: res.append(c) return "".join(res) C++ class Solution { public: string replaceSpace(string s) { string res; for (auto c:s) { if (c==' ') res += "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9155600e5c3398fd5c5058c2ebb546f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4532d5b2156c58bfbb3d9923862eda/" rel="bookmark">
			Unity--Animation Transitions（动画过渡）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 动画过渡:是指一个动画状态过渡到另外一个时发生的行为事件。
各个参数的含义：
Has Exit Time：在Exit Time时刻发生过渡动作。如果勾选此项，并且设置了过渡条件，则需要到达Exit Time 并且满足过渡条件才能发生过渡的动作。两者有一个不满足都不会发生过渡动作。 如果希望满足了过渡条件就立即发生过渡动作，建议取消勾选此项。
Transition Duration:从一个动画过渡到另一个动画需要的时间。如果勾选了Fixed Duration,时间的单位为秒。
Transition Offset:意思为一个动画过渡到另一个动画，另一个动画从哪里开始（如果你的Transition Offset为0.5，动画会在50%处开始播放，并不会从0%开始播放）。
Interruption Source:打断优先级。如果 一个动画正在播放，突然某个动画达到了播放条件，则会打断正在播放地动画，播放达到条件的动画。
Conditions：决定动画过渡在何时被触发。一个Condition包括：①一个事件的参数。 ②一个可选的断言。③一个可选的参数值
Animation Parameters（动画参数）
*Animation Parameters：是一系列在动画系统中定义的变量，可以通过脚本来进行访问和赋值。
在Animator中的Parameters中可以设置动画参数，点击右上角的加号。
参数的四种类型：
Float：浮点型
Int：整型
Bool：布尔型
Trigger：触发一个布尔值
在设置好参数后，点击两个动画中间的连线，在Conditions设置过渡条件。
设置后，就可以在脚本中使用Animator类函数来赋值，包括SetTrigger,SetFloat,SetInterger和SetBool.
using UnityEngine; using System.Collections; public calss Simpleplayer:MonoBehaviour { Animator animator; bool isWalk; void Start() { animator=GetComponent&lt;Animator&gt;(); } void Update() { float h=Input.GetAxis("Horizontal"); float v=Input.GetAxis("Vertical"); isWalk=h!=0||v!=0; animator.SetBool("isWalk",isWalk); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e881304cf8dec9e95489f9515a8f7ee/" rel="bookmark">
			C#封装带有圆角弧度的Label控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
public partial class RoundLabel : Label
{
Color _borderColor = Color.Blue;
int _radian;
#region 自定义属性
[DefaultValue(typeof(Color), "240, 240, 240"), Description("边框颜色")]
public Color BorderColor
{
get { return _borderColor; }
set
{
_borderColor = value;
base.Invalidate();
}
}
[DefaultValue(typeof(int), "10"), Description("圆角弧度大小")]
public int Radian
{
get { return _radian; }
set
{
_radian = value;
base.Invalidate();
}
}
#endregion
public RoundLabel()
{
InitializeComponent();
this.SetStyle(ControlStyles.UserPaint
| ControlStyles.DoubleBuffer
| ControlStyles.ResizeRedraw
| ControlStyles.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e881304cf8dec9e95489f9515a8f7ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203760eb5905e231886efcc4bc11431c/" rel="bookmark">
			分布式锁之Redis实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、分布式锁 分布式锁，是一种思想，它的实现方式有很多。比如，我们将沙滩当做分布式锁的组件，那么它看起来应该是这样的：
加锁 在沙滩上踩一脚，留下自己的脚印，就对应了加锁操作。其他进程或者线程，看到沙滩上已经有脚印，证明锁已被别人持有，则等待。
解锁 把脚印从沙滩上抹去，就是解锁的过程。
锁超时 为了避免死锁，我们可以设置一阵风，在单位时间后刮起，将脚印自动抹去。
分布式锁的实现有很多，比如基于数据库、memcached、Redis、系统文件、zookeeper等。它们的核心的理念跟上面的过程大致相同。
二、redis 我们先来看如何通过单节点Redis实现一个简单的分布式锁。
1、加锁
加锁实际上就是在redis中，给Key键设置一个值，为避免死锁，并给定一个过期时间。
SET lock_key random_value NX PX 5000 值得注意的是：
random_value 是客户端生成的唯一的字符串。
NX 代表只在键不存在时，才对键进行设置操作。
PX 5000 设置键的过期时间为5000毫秒。
这样，如果上面的命令执行成功，则证明客户端获取到了锁。
2、解锁
解锁的过程就是将Key键删除。但也不能乱删，不能说客户端1的请求将客户端2的锁给删除掉。这时候random_value的作用就体现出来。
为了保证解锁操作的原子性，我们用LUA脚本完成这一操作。先判断当前锁的字符串是否与传入的值相等，是的话就删除Key，解锁成功。
if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end 3、实现
首先，我们在pom文件中，引入Jedis。在这里，笔者用的是最新版本，注意由于版本的不同，API可能有所差异。
&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; 加锁的过程很简单，就是通过SET指令来设置值，成功则返回；否则就循环等待，在timeout时间内仍未获取到锁，则获取失败。
@Service public class RedisLock { Logger logger = LoggerFactory.getLogger(this.getClass()); private String lock_key = "redis_lock"; //锁键 protected long internalLockLeaseTime = 30000;//锁过期时间 private long timeout = 999999; //获取锁的超时时间 //SET命令的参数 SetParams params = SetParams.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/203760eb5905e231886efcc4bc11431c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7f7d4f2641f442b1c2ad0910e6e952a/" rel="bookmark">
			【剑指Offer系列04】二维数组中的查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目代码PythonC++ 题目 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例:
现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。
给定 target = 20，返回 false。
限制：
0 &lt;= n &lt;= 1000
代码 Python # 思路： # 注意二维数组的内在规律（每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序），寻找标志数：左下角与右上角数 # 复杂度： # O(N+M) class Solution: def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -&gt; bool: i, j = len(matrix)-1, 0 while i&gt;=0 and j&lt;len(matrix[0]): if matrix[i][j] &gt; target: i-=1 # 跳转上一行 elif matrix[i][j] &lt; target: j+=1 # 跳转下一列 else: return True return False C++ class Solution { public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int i=matrix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7f7d4f2641f442b1c2ad0910e6e952a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e933f56c6a614e8a58133cda874cbde4/" rel="bookmark">
			如何关闭WIN7自动配置 IPV4 地址 169.254. x. x
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何关闭WIN7自动配置 IPV4 地址 169.254. x. x 先把本地连接禁用，再启用，完事
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bffab9a16c33531b8aa0b5e74eaac0c9/" rel="bookmark">
			Java将给出的链表中的节点每k个一组翻转，返回翻转后的链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 将给出的链表中的节点每k个一组翻转，返回翻转后的链表
如果链表中的节点数不是k的倍数，将最后剩下的节点保持原样
你不能更改节点中的值，只能更改节点本身。
只允许使用常数级的空间
例如：
给定的链表是1-&gt;2-&gt;3-&gt;4-&gt;5
对于 k = 2, 你应该返回 2-&gt;1-&gt;4-&gt;3-&gt;5
对于 k = 3, y你应该返回 3-&gt;2-&gt;1-&gt;4-&gt;5
public ListNode reverseKGroup (ListNode head, int k) { if(head == null || k == 1){ return head; } int len = 0; ListNode curNode = head; while(curNode!=null){ len++; curNode = curNode.next; } //自定义一个头指针节点 ListNode node = new ListNode(-1); ListNode pre = node; pre.next = head; ListNode curNode2 = head; ListNode tempNode = null; for(int i=0;i&lt;len/k;i++){ //头插法 反转每一段节点 相当于单链表反转 for(int j=1;j&lt;k;j++){ tempNode = curNode2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bffab9a16c33531b8aa0b5e74eaac0c9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/166/">«</a>
	<span class="pagination__item pagination__item--current">167/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/168/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>