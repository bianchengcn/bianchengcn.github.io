<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7fbfeb95805365eb5d1bd6a1763cfe5/" rel="bookmark">
			centos 安装 RabbitMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先去安装erlang
方法一 yum -y install rabbitmq-server rabbitmq-server -detached rabbitmq-plugins enable rabbitmq_management rabbitmqctl stop rabbitmqctl status 方法二 1.下载RabbitMQ官网
https://www.rabbitmq.com/download.html 2.由于是tar.xz格式的所以需要用到xz，没有的话就先安装
yum install -y xz 3.第一次解压
/bin/xz -d rabbitmq-server-generic-unix-3.7.15.tar.xz 4.第二次解压
tar -xvf rabbitmq-server-generic-unix-3.7.15.tar 5.移走
mv rabbitmq_server-3.7.15/ /usr/local/ 6.改名
mv /usr/local/rabbitmq_server-3.7.15 rabbitmq 7.配置环境变量
echo 'export PATH=$PATH:/usr/local/rabbitmq/sbin' &gt;&gt; /etc/profile 8.创建配置目录（使用单独的配置文件，本步骤纯属多余）
mkdir /etc/rabbitmq 9.启动/停止/状态
rabbitmq-server -detached rabbitmqctl stop rabbitmqctl status 10.启用插件
rabbitmq-plugins enable rabbitmq_management 11.开启端口(–permanent永久生效，没有此参数重启后失效)
firewall-cmd --zone=public --add-port=5672/tcp --permanent firewall-cmd --zone=public --add-port=15672/tcp --permanent 重新载入 firewall-cmd --reload 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7fbfeb95805365eb5d1bd6a1763cfe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2af88d9f234549231a885cb326826f0/" rel="bookmark">
			MySQL数据库备份与还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL数据库备份与还原 一、通过Navicat设置计划1 : 备份文件存储位置2 : 新建计划3 : 测试计划 二、通过Navicat设置自动任务1 : 设置计划任务时间 三、通过Windows设置自动任务1 : 打开任务计划程序2 : 创建基本任务 四、mysql还原五、说明 一、通过Navicat设置计划 1 : 备份文件存储位置 查看 连接属性
选择 高级， 起始位置即为文件存储位置，可手动修改，也可使用默认位置。
2 : 新建计划 点击 计划，新建批处理作业
双击选择可用任务 Backup databaseName，点击保存
说明： 可备份链接下的所有数据库，以图示例，此时可用任务为 Backup Server localhost_3306。其中localhost_3306为数据库连接。 一般情况下选择备份单个数据库，以图示例，此时可用任务为 Backup rbac。其中rbac为数据库名。 一个计划也可同时备份多个数据库，侧边栏选择库名，双击添加到已选择任务即可。 输入文件名即可，实例：testBackUp
3 : 测试计划 找到对应文件存放位置
双击计划，点击开始
到对应文件位置，文件夹同库名，查看文件。
也可打开数据库，在备份中查看文件。
二、通过Navicat设置自动任务 1 : 设置计划任务时间 说明：计划任务时间，可手动设定修改。
三、通过Windows设置自动任务 1 : 打开任务计划程序 2 : 创建基本任务 /schedule “testBackUp”
可右键运行测试，是否成功，查看数据库，或文件夹数据是否生成。
四、mysql还原 选择一个备份文件，点击还原备份即可。
如果不想全库还原，仅仅想还原某个表或某几个表，可用SQL提取的方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2af88d9f234549231a885cb326826f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2abb6265b5c30b07402b2c30792bb8ba/" rel="bookmark">
			威胁建模主流框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		威胁建模主流框架 目录
威胁建模主流框架
一、简要介绍
二、威胁建模流程和步骤
三、威胁建模技术
1、 在线银行应用的数据流程图示例
2、过程流程图
3、攻击树
四、威胁建模框架和方法
1、STRIDE威胁建模
2、DREAD威胁建模
3、PASTA威胁建模
4、VAST威胁建模
5、Trike威胁建模
6、OCTAVE威胁建模
7、NIST威胁建模
五、威胁建模最佳实践
六、威胁建模工具
一、简要介绍 了解威胁建模框架、方法和工具可以帮助更好地识别、量化和排序面临的威胁。威胁建模是一个结构化的过程，IT专业人员可以通过该过程识别潜在的安全威胁和漏洞，量化每个威胁的严重性，并确定技术的优先级以缓解攻击并保护IT资产。威胁模型的重要之处在于它是系统的和结构化的。威胁建模人员将执行一系列具体步骤，以全面了解他们试图保护的IT环境，识别漏洞和潜在攻击者。 二、威胁建模流程和步骤 每种的威胁建模方法都包含一系列步骤，不同的建模方法的每个步骤存在着细微差别。首先，看一下所有这些方法共有的基本逻辑流程。对威胁建模过程最简洁明了的概述指出，威胁模型的目的是回答四个问题：
我们面对的是什么？可能会有哪些问题（威胁）？ 我们该怎么做？ 我们做得好吗？ 反过来，威胁建模过程应包括四个主要步骤，每个步骤都会为这些问题之一提供答案。
分解应用程序或基础架构 确定威胁 确定对策和缓解措施 排序威胁 为了准确了解这些步骤中的每个步骤，我们需要讨论构成威胁建模基础的特定技术。
三、威胁建模技术 上面列出的步骤中，最陌生的术语可能是分解（Decompose）。分解应用程序或基础架构意味着什么？
广义上讲，分解应用程序包括”了解应用程序及其与外部实体的交互方式。这涉及创建用例，以了解应用程序的使用方式，确定入口点以查看潜在的攻击者可以在哪里与应用程序进行交互，确定资产（即攻击者可能会感兴趣的项目/区域），并标识表示应用程序将授予外部实体的访问权限的信任级别。” （这里专门谈论应用程序安全性，但是显然，从广义上讲，这也适用于对基础结构的看法。）
分解应用程序的一种技术是构建数据流程图。这是1970年代开发的一种方法，以可视方式展示数据如何在应用程序或系统中移动，以及各个组件在何处更改或存储数据。其中信任边界是在2000年代初期添加进来的概念，特指数据流中的卡点，在该点上需要对数据进行验证，然后数据才能被接收该数据的实体使用。信任边界是用数据流程图进行威胁建模的关键。
1、 在线银行应用的数据流程图示例 下图是在线银行应用程序的数据流程图；虚线表示信任边界，数据可能会在信任边界被更改，因此需要采取安全措施。
网上银行应用程序的数据流程图（作者为Wei Zhang和Marco Morana，以OWASP许可分发
更深入的数据流程图威胁建模方法可以参考微软的这个文档²。
2、过程流程图 由于数据流程图是由系统工程师而不是安全专家开发的，因此它们包含了许多威胁建模不需要的开销。数据流程图的一种替代方法是过程流程图。两者在总体概念上相似，但后者更加精简，并且侧重于用户和执行代码在系统中的移动方式，更紧密地反映了攻击者的思维方式（例如下图）。
3、攻击树 绘制攻击树也是一种威胁建模技术，当您确定要对应用程序或基础结构潜在威胁的阶段时，它就变得非常重要。攻击树由90年代后期的信息安全传奇人物布鲁斯·施耐尔（Bruce Schneier）开创。它们由代表不同事件的一系列父节点和子节点组成，子节点是必须满足的条件才能使父节点为真。根节点（图中的最高父节点）是攻击的总体目标。借助攻击树，威胁建模者可以看到必须组合哪些情况才能使威胁成功。下图显示了一个简单的银行应用攻击树，说明了病毒可能成功感染文件的不同方式。
下图是Hackinthebox从攻击者的角度构建的攻击树示例，可以帮助了解自己所面临的威胁。
四、威胁建模框架和方法 威胁建模的各种结构化方法通常称为框架或方法论（本文中这两个术语基本上可以互换使用）。目前的威胁建模框架和方法有很多，我们挑几个最流行的介绍如下：
7种顶级威胁建模方法
STRIDEDREADPASTAVASTTrikeOCTAVENIST 1、STRIDE威胁建模 如上所述，STRIDE是威胁建模的祖父，最早于90年代末在Microsoft开发。STRIDE代表六种威胁，每种都对CIA三要素构成威胁，具体如下：
1)Spoofing欺骗或冒充他人或计算机，影响真实性
2)Tampering篡改数据，这会破坏完整性
3)Repudiation抵赖，或无法将执行的操作关联到操作者，违反了不可抵赖性
4)Information Disclosure信息泄露，违反机密性
5)Denial of Service拒绝服务，这违反了可用性
6)Elevation of Privilege特权提升，违反授权
2、DREAD威胁建模 DREAD被认为是STRIDE模型的一个附加组件，该模型使建模人员可以在确定威胁后对其进行排名。对于每个潜在威胁，DREAD代表六个问题,这些问题中的每一个都得到1-3分的评分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2abb6265b5c30b07402b2c30792bb8ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4108f0360cce5d75bc2317790e0b8e90/" rel="bookmark">
			k8s pod 一直重启 code 137 排查记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 k8s pod一直在重启，调度不起来
排查 1. 首先看状态 这个比较简单，我直接在页面上的(rancher查看api、查看/编辑yaml等都能看)
如图，找到containerStatuses，里面有个exitCode：137
网上搜了下错误码的意思：
退出代码 0：一般为容器正常退出退出代码 1：由于容器中 pid 为 1 的进程错误而失败退出代码 137：由于容器收到 SIGKILL 信号而失败（手动执行或“oom-killer” [OUT-OF-MEMORY]）
= 退出代码 139：由于容器收到 SIGSEGV 信号而失败退出代码 143：由于容器收到 SIGTERM 信号而失败 网上对137的解释：一般为pod容器内存达到资源限制（resources.limits）或者宿主机本身内存不够了。
我们知道，oom被kill是可以在系统日志里看到的：
ubuntu 的系统日志在 /var/log/syslog，centos 的系统日志在 /var/log/messages
2. 登录机器排查 大致判断可能是OOM导致之后，需要进机器看下真实情况
首先看下pod所在的node [superuser@server2558 ~]$ sudo kubectl get pod -n mynamespace -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES elasticsearch-568889b5f-h482t 0/1 CrashLoopBackOff 8 23m 10.x.x.x a2617 &lt;none&gt; &lt;none&gt; &lt;none&gt; &lt;none&gt; 如图，这个异常的pod被调度到了a2617节点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4108f0360cce5d75bc2317790e0b8e90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/079c90a36d5602f13fc5c35422fde08d/" rel="bookmark">
			Markdown常用样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 可表示1-6级标题 斜体 : *斜体*
粗体 : **粗体**
粗体加斜体 : ***粗体加斜体***
🐫 😊 😄 : :smil\e:(去掉斜线)
分割线(下面这条) : ---
上角标 : ^上角标^
下角标 : ~下角标~
删除线 : ~~删除线~~
下划线 : &lt;u&gt;下划线&lt;/u&gt;
无序列表 : - 无序列表 有序列表 : 1. 有序列表 代办列表 : - [ ]代办列表 已完成 : - [x]已完成 区块 : &gt; 区块
可以嵌套 : &gt;&gt; 可以嵌套
代码 : `代码`
代码段 : ```代码段 ``` 链接 : [链接](网址)
图片 : ![描述](网址), 注意某些网址不适用, 比如csdn
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/079c90a36d5602f13fc5c35422fde08d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b978661d83b9e51bc0c6e14ad0e445cd/" rel="bookmark">
			实现基于Netty的“请求-响应”同步通信机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现基于Netty的“请求-响应”同步通信机制
设计思路
Netty提供了异步IO和同步IO的统一实现，但是我们的需求其实和IO的同步异步并无关系。我们的关键是要实现请求-响应这种典型的一问一答交互方式。要实现这个需求，需要解决两个问题：
请求和响应的正确匹配
客户端发送数据后，服务端返回响应结果的时候，怎么和客户端的请求正确匹配起来呢，（即一个请求对应一个自己的响应）？
解决思路：通过客户端唯一的RequestId，服务端返回的响应中需要包含该RequestId，这样客户端就可以通过RequestId来正确匹配请求响应。
请求线程和响应线程的通信。
请求线程会在发出请求后，同步等待服务端的返回。因此，就需要解决，Netty客户端在接受到响应之后，怎么通知请求线程结果。
解决思路：客户端线程在发送请求后，进入等待，服务器返回响应后，根据RequestId来唤醒客户端的请求线程，并把结果返回给请求线程
解决方案
利用Java中的CountDownLatch类来实现同步Future。
具体过程是：客户端发送请求后将&lt;请求ID，Future&gt;的键值对保存到一个缓存中，这时候用Future等待结果，挂住请求线程；当Netty客户端收到服务端的响应后，响应线程根据请求ID从缓存中取出Future，然后设置响应结果到Future中。这个时候利用CountDownLatch的通知机制，通知请求线程。请求线程从Future中拿到响应结果，然后做业务处理。
缓存使用google的guava
&lt;!-- guava --&gt;
&lt;dependency&gt;
&lt;groupId&gt;com.google.guava&lt;/groupId&gt;
&lt;artifactId&gt;guava&lt;/artifactId&gt;
&lt;version&gt;28.0-jre&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- Netty --&gt;
&lt;dependency&gt;
&lt;groupId&gt;io.netty&lt;/groupId&gt;
&lt;artifactId&gt;netty-all&lt;/artifactId&gt;
&lt;version&gt;4.1.39.Final&lt;/version&gt;
&lt;/dependency&gt;
package com.topinfo.ci.netty.client;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
public class SyncFuture&lt;T&gt; implements Future&lt;T&gt; {
// 因为请求和响应是一一对应的，因此初始化CountDownLatch值为1。
private CountDownLatch latch = new CountDownLatch(1);
// 需要响应线程设置的响应结果
private T response;
// Futrue的请求时间，用于计算Future是否超时
private long beginTime = System.currentTimeMillis();
public SyncFuture() {
}
@Override
public boolean cancel(boolean mayInterruptIfRunning) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b978661d83b9e51bc0c6e14ad0e445cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/404ff101dcdc837601e26b59a9be161c/" rel="bookmark">
			【windows软件】terminal软件添加git bash 命令行功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在terminal软件添加新的控制台程序一般需要更改软件的json配置文件。
json文件内容大致如下：
之前曾经借鉴了一篇文章，在list中添加如下代码：
{ "commandline": "C:\\Program Files\\Git\\git\\bash.exe", "guid": "{b453ae62-4e3d-5e58-b989-0a998ec441b7}", "hidden": false, "name": "git bash" } 效果如下，我们可以看出git bash可以显示了，但是git命令行会单独弹出独立的窗口，而不是向我们希望的那样嵌在terminal主窗口
为此，我们更改了了json代码
{ "hidden": false, "name": "Git Bash", "commandline" : "%ProgramFiles%/Git/bin/bash.exe -li", "icon" : "%ProgramFiles%/Git/mingw64/share/git/git-for-windows.ico", "startingDirectory" : "%USERPROFILE%" } 更新后结果如下：
是我们想要的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca6b8020212d3ce0bdc136590f5a8a2/" rel="bookmark">
			基于libssh2的ssh远程执行/sftp传输C&#43;&#43;库pssh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时维护一大堆linux服务器，如何无需交互带密码远程执行命令?其实之前也调研过几种方案，比如直接调用plink获取其结果--后来发现这玩意非线程安全，无法多线程使用且bug很多。又比如QT自带的QSSH代码，我搞下来试了一下，一是也是非线程安全，二是这货是非阻塞式调用，门槛比较高，难受的很，所以放弃了，最终选定了libssh2。
不用脚本纯代码的话，libssh2无疑是一个好的选择。但这个库对新手不是很友好，网络上的例子也都是把官方给的几个例子抄来抄去毫无新意，不但繁琐而且有很多缺点，总结几个如下：
纯C库，用起来不是那么方便非线程安全，无法线程执行连接/执行没有断线重连功能sftp传输没有上传/下载文件夹的功能sftp传输没有短点续传的功能windows与linux之间sftp传输不支持路径以及文件名含有中文以及空格问题远程执行返回You have mail/You have new mail的问题ssh命令过长偶尔导致\b \b \b..乱码的问题 等一系列问题，实在无法满足我想简单粗暴阻塞式执行命令以及传输文件、目录的需求，于是自己花了几个月封装了一个跨平台pssh库，致力于解决这些问题，主要功能以及更新记录如下:
增加了带空格的目录以及文件名支持 增加了中文支持 对断点续传上传和下载文件增加速度提示功能 增加了下载文件/上传文件/下载目录/上传目录的断点续传功能 已改造windows上传文件,下载文件,上传目录,下载目录,支持回调函数,目录支持进度 传输相关要从windows下psshsingle考,从linux考来的不对,因为有中文问题 已改造为单线程断线重连，不要卡住，目前实现思路是，send失败后，只重连一次，失败再返回，因为xsh一般都不是只执行一次，多次执行，上一次失败的话，重连一次，这次失败，下一次就会成功本版本是多个channel版本，以后多线程用这个作为模板，原来的套一个pssh太臃肿，每次要写两遍函数 修改了recv处理，兼容centos系和ubuntu系列,ubuntu系列没有[,可连接127.0.0.1 单线程重连版,主要是为了防止线程过多,线程重连如果pssh多的话2倍线程,而且稳定一些 xsh是send失败直接阻塞重连，recv因为有参数返回，所以还是返回值，在xsh里面阻塞重连 xshlastinng是成功尝试多个channel，在循环lastting的时候用statuschannel判断阻塞重连 已经改造了close，xsh和xshlasting都可以closetrue 已经改造了xshlasting，可以做到closetrue后再open依然可以 已经改造了xsh，可以做到closetrue后再open依然可以 解决了深度openssl线程安全问题 增加了获取是否生成core文件功能,增加在/etc/profile增加配置等功能 增加切换目录,获取当前目录,查看远程进程,获取根目录使用比例是否在等常用功能 增加获取远程core文件"Core文件"&lt;&lt;"服务器地址"&lt;&lt;"所属进程"&lt;&lt;"生成时间"的list信息 增加了远程ini模式配置文件的增删改查功能 增加了给/etc/profile添加配置功能,内置判断是否已有配置 增加了close(true)功能,true情况下关闭自动重连,彻底关闭(两种模式); 修复了在高延迟情况下判断远程文件是否存在时间过长的bug(不再用sftp模式获取,使用ssh模式直接ll获取) 增加xshlasting模式自动重连功能,使用另一个xsh一直发送pwd探测,如果断开,则线程自动重连,重连成功后继续返回正确结果 增加了自动重连的功能,如果连接断开,则当时xsh返回错误,线程自动重连,如果下次已经连接上则下次获取正确结果 增加了与服务器连接断开时返回错误的功能,不会一直卡住 阻塞调用,xsh等结果获取完成才返回 增加了上传文件/下载文件/上传目录/下载目录功能 修复了xsh有时会返回You have mail/You have new mail的问题,过滤 修复了xsh有时命令过长会出现结果返回\b\b\b..乱码的问题,过滤 修改了xsh功能,任务错误都字符串返回#fail,包括连接断开 修改了connect,增加了连接超时功能,默认超时时间1秒,原来是20秒太长 增加了同一个ssh close再open功能 测试了多线程功能C++11线程,线程安全 增加了探测连接的功能.另起一个chanel一直探测,用于判断连接状态,该功能是xshlasting的基础,因为xshlasting不能判断断了,用这个bconnected判断 增加了支持域名功能(为了支持端口映射) 增加两种模式,一种正常获取xsh结果,一种持续获取xshlasting,xshlasting可用于tail -f收集日志到统一服务器增加了xsh获取结果超时10秒返回错误功能对于xsh获取结果失败(原因不限于连接断开,超时等),均返回#fail开头的字符串 主要代码如下：
/* * 作者:李海龙2021-02-26 */ class pssh { public: pstring strhost; int iport; pstring strpwd; pstring struser; pstring strerr;//最后一次错误描述 pssh(); pssh(pstring host,int port=22,pstring pwd="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca6b8020212d3ce0bdc136590f5a8a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a22a292edba2cd21a47d7ee8ac68201/" rel="bookmark">
			本地虚拟机搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载和安装workstation
2.workstation 创建新的虚拟机。
3.挂载ios操作系统文件开机重启按提示安装。
4.配置网络模式
VMware虚拟机有3种网络模式，桥接网络模式，NAT网络地址转换模式，Host-only主机模式，通常选择前2种设置方式。
桥接网络模式配置简单，ip与本地网络在同一网段，DNS,网关与本地一致即可。
NAT配置步骤如下：
点编辑--虚拟网络编辑器
步骤1：添加网络
步骤2：选中NAT模式，单击NAT设置，配置网关，通常默认设置即可。
步骤3：单击DHCP设置，设置起止IP网段。确定退出。
4.虚拟机网络配置
重启网络服务，关闭防火墙即可正常使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e210b9dcadbb750bb30e447cae5b3f2/" rel="bookmark">
			linux 命令行操作串口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux 命令行操作串口 1. 获取串口号2. 配置串口属性（stty命令）3. 串口数据读写操作4. 解析数据5. 后台运行6. 绘制数据Linux stty命令一、参数：二：用法 Linux下minicom操作Linux minicom 软件退出方法 1. 获取串口号 在Linux系统中一切皆为文件，所以串口端口号也不例外，都是以设备文件的形式出现。也就是说我们可以用访问文本文件的命令来访问它们。
a. 一般串口都是以/dev/ttyS#的格式显示，所以第一个连接的串口就是/dev/ttyS0,第二个连接的串口就是/dev/ttyS1…以此类推。
b. USB转串口适配，没有额外驱动，它们会显示为/dev/ttyUSB#,如/dev/ttyUSB0
2. 配置串口属性（stty命令） 我们可以使用stty命令来更改配置串口属性(详情查看”man stty”)，比如我们设置串口/dev/ttyS0波特率为57600和odd parity，命令如下stty -F /dev/ttyS0 57600 parodd
3. 串口数据读写操作 使用echo向串口发送数据，如echo “command” &gt; /dev/ttyUSB0
可以使用cat来读取串口中的数据，如cat /dev/ttyUSB0
读取数据并保存到txt文本文件中，如cat /dev/ttyUSB0 &gt; file.txt
4. 解析数据 说到解析数据，我们可以使用一个强大的文本分析工具awk，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。
awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。
下面使用gawk举个栗子，在终端以H:M:S格式输出当前时间和来自串口的每一行前3个字符，命令如下：cat /dev/ttyUSB0 | gawk ’{print strftime("%T"), substr($1 ,1,3)}’
5. 后台运行 可以讲串口数据读写操作设置为后台进行，通过一个简单命令或者shell 脚本就可以实现。命令可以用nohup。即使关闭终端或者注销账户，进程还是在进行着，比如nohup cat /dev/ttyS0 | gawk ’{substr($1 ,1,3)}’ &gt; result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e210b9dcadbb750bb30e447cae5b3f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ae958532917030c7049a2f94a13d3a/" rel="bookmark">
			Spring中IOC详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IOC的原型 IOC ----控制反转
比如我们有一个功能是获取用户数据，我们使用Dao层实现这个功能，再在Service层调用这个功能。但是我们每增加一个接口，比如获取mysql中的数据，就要修改原来的代码，如果再增加一个新的接口，又需要去service实现类中修改对应的实现。
解决方法
用户实际调用的是业务层，dao层他们不需要接触 UserServiceImpl userService = new UserServiceImpl(); userService.setUserDao(new UserDaoImpl()); userService.getUser(); 利用set，我们可以通过传入参数，指定实现的是哪个接口。已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口。
这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !
二、 IOC本质 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法
没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系
完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，所谓控制反转就是：获得依赖对象的方式反转了。
IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。
Spring容器在初始化时先读取配置文件，根据配置文件或元数据，创建并组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。
控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）
三、实现一个简单的HelloSpring 理解IOC 导入spring依赖的jar包 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写一个Hello实体类 package com.lding.pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1ae958532917030c7049a2f94a13d3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a85217f0fe28c98d8fb7c464c51815/" rel="bookmark">
			一次ios转安卓记录（ios15 --＞ 魅族18s）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因为被iphone的通话记录与短信机制所局限，
于是打算换安卓。
在京东淘宝逛了很久，终于在京东下单了魅族18s。
主要记录一下迁移通话记录/联系人/短信的历程。
推荐使用官方软件，最省心，地址 Wondershare Official Website: Creativity, Productivity, Utility​​​​​​
当然，我没用这个，这个太贵了，我就用一次，200多太贵了，遂走上了po jie 版的道路。
在网上百度到了这个的2020的可用的版本。
不过这个版本有个问题，就是只有那一个模块可以用，其他的要不闪退，要不下载不了，所以就用这个可用的模块导出短信信息为csv格式（别问为什么导这个，因为没得选）
大概长这样
然后找了半天找这个用csv格式恢复，无果。
最终找到一个vivo x9的旧手机，用上面的互传备份了一下到电脑上，发现备份文件是xml格式的，于是稍微研究了一下这个格式，然后将csv文件转换成这个xml的格式，用vivo手机导入
转换完成的的局部是这样
这些字段很好对应起来，
代码很简单我就不发了。
通话记录跟联系人我是用的另外一个软件导入的， 链接：https://pan.baidu.com/s/10jK0QEPLbYS8i9SQyRNqMg 提取码：lqu2 时间间隔有点长了，我不记得具体是哪个包了，链接里自己一个个试试吧。
步骤的话，得先使用win10的itunes备份一下手机，然后用这个导出记录。
事实证明，mei国的公司，还是不够懂国内人的心，通话短信做的跟个啥一样。
另外 我通话记录只恢复了200条，（我的iphone 12只看的到100条，听说ios都是只看得到100条）
如果大家有更好的迁移方案，欢迎留下链接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f136caf7fd29958bf133a7997f81ca19/" rel="bookmark">
			VGGNet网络详解与模型搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 模型介绍2 模型结构3 模型特性4 Pytorch模型搭建代码 1 模型介绍 ​ VGGNet是由牛津大学视觉几何小组（Visual Geometry Group, VGG）提出的一种深层卷积网络结构，他们以7.32%的错误率赢得了2014年ILSVRC分类任务的亚军（冠军由GoogLeNet以6.65%的错误率夺得）和25.32%的错误率夺得定位任务（Localization）的第一名（GoogLeNet错误率为26.44%）,网络名称VGGNet取自该小组名缩写。VGG网络原论文《Very Deep Convolutional Networks For Large-Scale Image Recognition》发表于ICLR-2015，VGGNet所提出的 3 × 3 3\times3 3×3卷积核的思想为后来许多模型所沿用。
2 模型结构 ​ 在原论文中，作者尝试了不同深度的配置（11层，13层，16层，19层），是否使用LRN（Local Response Normalization）以及卷积核1x1与卷积核3x3的差异，VGGNet尝试使用了6种不同的模型结构，分别对应VGG11、VGG11-LRN、VGG13、VGG16-1、VGG16-3和VGG19，不同的后缀数值表示不同的网络层数（VGG11-LRN表示在第一层中采用了LRN的VGG11，VGG16-1表示后三组卷积块中最后一层卷积采用卷积核尺寸为 1 × 1 1\times1 1×1，相应的VGG16-3表示卷积核尺寸为 3 × 3 3\times3 3×3）。下表是从原论文中截取的几种VGG模型的配置表，VGGNet网络模型结构非常工整，其卷积层全部都采用了大小为3x3，步距为1，padding为1的卷积操作（即same卷积，经过卷积后不会改变特征矩阵的高和宽）；最大池化下采样层全部都是池化核大小为2，步距为2的池化操作，每次通过最大池化下采样后特征矩阵的高和宽都会缩减为原来的一半。
​ 我们通常使用的VGG模型是表格中的VGG16(D)配置，根据表格中的配置信息以及上文所讲的卷积层和池化层的详细参数，可以搭建如下图所示的feature map大小的变化图。在VGG模型中，卷积操作不会改变feature map的大小，池化操作会使feature map大小减小为原来的一半。
3 模型特性 （1）通过堆叠多个3x3的卷积核来替代大尺度卷积核
​ 论文中提到，可以通过堆叠两层 3 × 3 3\times 3 3×3的卷积核替代一层 5 × 5 5\times 5 5×5的卷积核，堆叠三层 3 × 3 3\times3 3×3的卷积核替代一层 7 × 7 7\times7 7×7的卷积核。这样的连接方式使得网络参数量更小（见下例），而且多层的激活函数令网络对特征的学习能力更强。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f136caf7fd29958bf133a7997f81ca19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783aec7f184c957d5f51da14800270ff/" rel="bookmark">
			Linux学习之路--基础命令（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Linux命令行基础 Linux命令是用来实现某一类功能的指令或程序，在Linux中执行大多数命令时，都要找到命令所对应的程序 [root@server1 ~]# hostname #查询主机名 localhost [root@server1 ~]#which hostname #查询命令对应的程序 /usr/bin/hostnamet 命令的执行依赖于解释器（默认解释器/bin/bash） 用户—&gt;解释器—&gt;内核—&gt;硬件 命令行完整格式： 命令字 (选项)… (参数1) ( 参数2)… [root@server1 ~]# cat --help #查看命令帮助信息 ... [root@server1 ~]# cat -n /etc/shells 1 /bin/sh 2 /bin/bash 3 /usr/bin/sh 4 /usr/bin/bash [root@server1 ~]# ls -l /etc/passwd #长格式显示 -rw-r--r--. 1 root root 2319 Nov 29 2020 /etc/passwd #默认显示目录内容的详细属性 计算机容量单位：
一般用B，KB，MB，GB，TB，PB，EB，ZB，YB，BB来表示，它们之间的关系是：
1KB (Kilobyte 千字节)=1024B;1MB (Megabyte 兆字节 简称“兆”)=1024KB;1GB (Gigabyte 吉字节 又称“千兆”)=1024MB;1TB (Terabyte 万亿字节 太字节)=1024GB;1PB (Petabyte 千万亿字节 拍字节)=1024TB;1EB (Exabyte 百亿亿字节 艾字节)=1024PB;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/783aec7f184c957d5f51da14800270ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/636859778a4a926fd0c224d2f5ad78aa/" rel="bookmark">
			C&#43;&#43;基础——结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 结构体基本概念
2 结构体定义和使用
3 结构体数组
4 结构体指针
5 结构体嵌套结构体
6 结构体做函数参数
7 结构体中 const使用场景
8 结构体案例
1 结构体基本概念 结构体属于用户自定义的数据类型，允许用户存储不同的数据类型
2 结构体定义和使用 语法：struct 结构体名 { 结构体成员列表 };
通过结构体创建变量的方式有三种：
○struct 结构体名 变量名
○struct 结构体名 变量名 = { 成员1值, 成员2值...}
○定义结构体时顺便创建变量
#include &lt;iostream&gt; using namespace std; #include&lt;string&gt; //1、创建学生数据类型：学生包括（姓名，年龄，分数） //自定义数据类型，一些类型集合组成的一个类型 //语法 struct 类型名称 { 成员列表 } struct Student { //成员列表 //姓名 string name; //年龄 int age; //分数 int score; }s3; //2、通过学生类型创建具体学生 int main(){ //2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/636859778a4a926fd0c224d2f5ad78aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9620baffa4872b0b691a04edca2e3ff/" rel="bookmark">
			JavaScript也可以制作颜色拾取工具了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		必备工具？ 作为一名前端开发，颜色拾取工具是不是你们必备的工具，像之前都是用的软件的吸管工具来进行吸取颜色，完成自己的页面设计，但现在使用简单的JavaScript也能实现颜色拾取功能，你们知道吗？Chrome 95 推出的EyeDropper API 能够帮助我们轻松地在 Web 应用中创建吸管工具。使用EyeDropper API你可以使用取色器提取当前页面上的颜色。当取色器被激活的时候，它就像一个“放大镜”，使得你可以进行像素精度的颜色选择。在取色器下方显示的是当前像素点的颜色值，颜色值显示格式与你在设置中选择的一致。
制作自己的工具 当然，EyeDropper不仅仅可以用在特殊的需求场景上，我们也可以将其封装成一个工具，集成自己平时办公学习的插件，如上图所示，我们可以将其做成一个Chrome浏览器的插件，这样在平时的设计工作时，需要提取颜色的时候，可以随时调出该页面对颜色进行拾取，更加快捷地完成自己的工作。
如何制作 弹窗组件 使用JavaScript封装一个弹窗组件，可以使用快捷键来控制弹窗的显示，实现代码如下：
/* * @Author: zheng yong tao * @Date: 2021-12-30 00:51:37 * @LastEditors: zheng yong tao * @LastEditTime: 2021-12-30 02:21:36 * @Description: "弹窗组件类封装" */ class Dialog { /** * * @param {String} innerHTML 内嵌页面html * @param {Object} config 弹窗属性配置 * @param {Function} callBack 回调函数 * @param {Number} mode 内嵌模式 -&gt; 1:页面初始化时就创建dom元素并插入页面 2：窗口打开是创建dom元素，关闭时销毁 */ constructor(innerHTML,config = {},callBack,mode = 1){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9620baffa4872b0b691a04edca2e3ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c7106946f4434a6d5f4ae1cbc8875f/" rel="bookmark">
			cesium 实现雷达波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构建雷达扫描
// TODO 未集成 export class RadarRadiationWave { viewer:any; init(map: any){ this.viewer = map; this.initRadarRiationWave1(); this.initRadarRiationWave2(); } initRadarRiationWave1 () { var e = this.viewer.scene, i = Cesium.Cartesian3.fromDegrees(112.39, 39.9), a = Cesium.Cartesian3.fromDegrees(112.39, 39.9, 2e5), t = Cesium.Cartesian3.fromDegrees(112.39, 39.9, 4e5), r = Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(i), new Cesium.Cartesian3(0, 0, 2e5), new Cesium.Matrix4); this.viewer.camera.flyToBoundingSphere(new Cesium.BoundingSphere(a, 4e5)); e.primitives.add(new Cesium.BillboardCollection).add({ image: "./images/svg/wave.svg", position: t, horizontalOrigin: Cesium.HorizontalOrigin.LEFT, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, pixelOffset: new Cesium.Cartesian2(-10, 10), scale: .3 }); var n = new Cesium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84c7106946f4434a6d5f4ae1cbc8875f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4919b411f2c5f195a7ad10d4f1a811d/" rel="bookmark">
			c语言常见的字符串函数及模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.模拟strlen()实现原理 我们知道定义字符数组时,可以有以下两种形式：
char a[]="abcd"; char a[]={'a','b','c','d'}; 两者的区别是第一种末尾会带一个'\0'，而第二种不会带，所以可以扫描字符数组每一个字符，如果扫描到'\0',扫描结束
具体模拟strlen函数如下： int my_strlen(char* base) { int length = 0; while ((*base++)!='\0') { length++; } return length; } 当传的是 char a[]="abcd" 这种形式时，会得出正确的结果
当传的是 char a[]={'a','b','c','d'} 这种形式时，会返回一个不确定的值，原因是这种定义下没有'\0'
在对以上进行优化
有可以知道：
while(a) 表示当a!=0时执行循环，其等价于while(a!=0)。
//模拟strlen()函数 int my_strlen(char* base) { int length = 0; while (*base++) { length++; } return length; } char a[]={'a','b','c','d'} 这种形式时,返回一个随机值 int my_strlen(char* base) { int length = 0; while (*base++) { length++; } return length; } int main() { char ch[] = {'a','b','s','f','2'}; //char ch[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4919b411f2c5f195a7ad10d4f1a811d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d6e279f3f3fdf170e72768f14c0402/" rel="bookmark">
			java socket 解析自定义包头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java socket 打包和解包自定义包头格式的数据包。 1、背景：用java接收 C++服务推过来的数据，采用TCP协议，数据格式是自定义二进制的包头+pb数据构成的数据包。
2、包头格式，二进制格式12字节长度：
{ uint32 packetlength;//包体长度 uint32 packetno;//包序号 uint16 type;//包类型 uint16 version;//版本号当前固定为100 } 3、代码实现接收和发送数据：
public class NetWork { private Socket socket = null; private String strHost; private int iPort; private DataInputStream dis = null; //用于接收数据 private DataOutputStream dos = null;//用于发送数据 public void Connect(String strHost, int iPort) { this.strHost = strHost; this.iPort = iPort; try { //创建一个Socket，跟服务器的端口链接 this.socket = new Socket(); this.socket.connect(new InetSocketAddress(this.strHost, this.iPort), 3000); // 初始化输入输出流 dis = new DataInputStream(socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47d6e279f3f3fdf170e72768f14c0402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc01b50e14a35b9f28eb8c7c5bf0c4d6/" rel="bookmark">
			/ ./ ../路径含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“/ ” 代表根目录
“./” 代表当前所在的目录
". ./ " 代表上一层目录
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/119/">«</a>
	<span class="pagination__item pagination__item--current">120/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/121/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>