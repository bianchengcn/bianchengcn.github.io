<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>std::atomic - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="std::atomic" />
<meta property="og:description" content="一、概述 std::atomic 是C&#43;&#43;11引入的一个模板类，用于提供原子操作的类型。在多线程编程中，当多个线程同时访问同一块数据时，可能会导致数据竞争和不确定的行为。std::atomic 可以用来创建原子类型的变量，保证对该变量的操作是原子的，不会被中断，从而避免了数据竞争。
std::atomic 适用于以下场景：
在多线程环境下对共享数据进行原子操作；需要保证特定操作的原子性，如递增、递减、交换等操作；需要避免使用锁的情况下进行线程同步。 举个具体的例子：
#include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;mutex&gt; int counter = 0; void incrementCounter() { for (int i = 0; i &lt; 100000; &#43;&#43;i) { counter&#43;&#43;; } } int main(int argc, char *argv[]) { std::thread t1(incrementCounter); std::thread t2(incrementCounter); t1.join(); t2.join(); qDebug() &lt;&lt; counter; return 0; } 这段代码存在一个线程安全的问题。多个线程同时访问和修改同一个全局变量 counter ，而没有进行同步操作会导致竞态条件。
竞态条件指的是多个线程并发执行时，由于执行顺序不确定导致程序出现意料之外的结果的情况。
就上面的代码来说，在 incrementCounter() 函数中，多个线程同时对 counter 进行递增操作，而递增操作不是一个原子操作，它包括读取 counter 的当前值、对该值加一、然后写回到 counter。由于线程间的执行顺序是不确定的，就可能出现以下情况：
线程 A 读取 counter 的值为 0，然后执行加一操作得到 1；此时线程 B 也读取 counter 的值为 0，执行加一操作得到 1；然后线程 A 和线程 B 都把值 1 写回到 counter，导致实际的递增次数少于预期。 因此，竞态条件可能会导致 counter 的最终结果少于预期的值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/24c7e94c556e02f56a440f4639e31d16/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-20T20:41:16+08:00" />
<meta property="article:modified_time" content="2024-01-20T20:41:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">std::atomic</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、概述</h2> 
<p>std::atomic 是C++11引入的一个模板类，用于提供原子操作的类型。在多线程编程中，当多个线程同时访问同一块数据时，可能会导致数据竞争和不确定的行为。std::atomic 可以用来创建原子类型的变量，保证对该变量的操作是原子的，不会被中断，从而避免了数据竞争。</p> 
<p>std::atomic 适用于以下场景：</p> 
<ol><li>在多线程环境下对共享数据进行原子操作；</li><li>需要保证特定操作的原子性，如递增、递减、交换等操作；</li><li>需要避免使用锁的情况下进行线程同步。</li></ol> 
<p>举个具体的例子：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

int counter = 0;

void incrementCounter()
{
    for (int i = 0; i &lt; 100000; ++i)
    {
        counter++;
    }
}

int main(int argc, char *argv[])
{
    std::thread t1(incrementCounter);
    std::thread t2(incrementCounter);

    t1.join();
    t2.join();

    qDebug() &lt;&lt; counter;

    return 0;
}</code></pre> 
<p><img alt="" height="398" src="https://images2.imgbox.com/0f/29/aIByKW40_o.png" width="849"></p> 
<p>这段代码存在一个线程安全的问题。多个线程同时访问和修改同一个全局变量 <code>counter</code> ，而没有进行同步操作会导致<span style="color:#fe2c24;"><strong>竞态条件</strong></span>。</p> 
<p>竞态条件指的是多个线程并发执行时，由于执行顺序不确定导致程序出现意料之外的结果的情况。</p> 
<p>就上面的代码来说，在 <code>incrementCounter()</code> 函数中，多个线程同时对 <code>counter</code> 进行递增操作，而递增操作不是一个原子操作，它包括读取 <code>counter</code> 的当前值、对该值加一、然后写回到 <code>counter</code>。由于线程间的执行顺序是不确定的，就可能出现以下情况：</p> 
<ol><li>线程 A 读取 <code>counter</code> 的值为 0，然后执行加一操作得到 1；</li><li>此时线程 B 也读取 <code>counter</code> 的值为 0，执行加一操作得到 1；</li><li>然后线程 A 和线程 B 都把值 1 写回到 <code>counter</code>，导致实际的递增次数少于预期。</li></ol> 
<p>因此，竞态条件可能会导致 <code>counter</code> 的最终结果少于预期的值。</p> 
<p>为了解决这个问题，可以使用互斥锁来保护对 <code>counter</code> 的访问，确保同时只有一个线程能够访问和修改 <code>counter</code>，从而避免了竞态条件的问题：</p> 
<pre><code class="language-cpp">int counter = 0;
std::mutex mutex;

void incrementCounter()
{
    for (int i = 0; i &lt; 100000; ++i)
    {
        std::lock_guard&lt;std::mutex&gt; lock(mutex);
        counter++;
    }
}

int main(int argc, char *argv[])
{
    std::thread t1(incrementCounter);
    std::thread t2(incrementCounter);

    t1.join();
    t2.join();

    qDebug() &lt;&lt; counter;

    return 0;
}</code></pre> 
<p>使用std::atomic是另一种做法：</p> 
<pre><code class="language-cpp">#include &lt;atomic&gt;

std::atomic&lt;int&gt; counter(0);

void incrementCounter()
{
    for (int i = 0; i &lt; 100000; ++i)
    {
        counter++;
    }
}

int main(int argc, char *argv[])
{
    std::thread t1(incrementCounter);
    std::thread t2(incrementCounter);

    t1.join();
    t2.join();

    qDebug() &lt;&lt; counter;

    return 0;
}</code></pre> 
<p>使用std::atomic&lt;int&gt; 类型的计数器 counter，并在两个线程中并发地对其进行递增操作。由于 counter 是 std::atomic 类型，它会保证递增操作的原子性，避免了多线程竞争导致的问题。最终输出的 counter 值会是预期的 200000。</p> 
<h2>二、成员函数</h2> 
<h3>1、<code>compare_exchange_weak()</code>、<code>compare_exchange_strong()</code></h3> 
<blockquote> 
 <p>比较和交换函数。这两个函数的作用都是：当原子对象的值等于期望值时，用新值替换原子对象的值。</p> 
</blockquote> 
<p><code>compare_exchange_weak</code> 函数</p> 
<ul><li>比较和交换不成功时，<span style="color:#fe2c24;"><strong>允许</strong></span>原子变量的值被其他线程更改，并返回 <code>false</code>，表示失败。</li><li>比较和交换成功时，将原子变量的值设置为新值，并返回 <code>true</code>，表示成功。</li></ul> 
<pre><code class="language-cpp">std::atomic&lt;int&gt; atomic_var(10);

void increment(std::atomic&lt;int&gt;&amp; var)
{
    int expected = 10;
    int new_value = 20;

    bool success = var.compare_exchange_weak(expected, new_value);

    if (success) {
        std::cout &lt;&lt; "线程 " &lt;&lt; std::this_thread::get_id()&lt;&lt; std::endl
                  &lt;&lt; " 比较和交换成功，原子变量的值已修改为: " &lt;&lt; var &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "线程 " &lt;&lt; std::this_thread::get_id()&lt;&lt; std::endl
                  &lt;&lt; " 比较和交换失败，原子变量的值未修改" &lt;&lt; std::endl;
    }
}

int main(int argc, char *argv[])
{
    std::thread t1(increment, std::ref(atomic_var));
    std::thread t2(increment, std::ref(atomic_var));
    t1.join();
    t2.join();
    return 0;
}</code></pre> 
<p><img alt="" height="232" src="https://images2.imgbox.com/3f/cc/32cCk8gv_o.png" width="750"></p> 
<p></p> 
<p>如果某个线程在比较和交换时发现 <code>atomic_var</code> 的值已经被其他线程更改，那么它会允许原子变量的值被其他线程更改，并返回 <code>false</code>，表示失败。因此，上面代码输出结果可能会是以下两种情况之一：</p> 
<p>结果1</p> 
<blockquote> 
 <p>线程 1 比较和交换成功，原子变量的值已修改为: 20</p> 
 <p>线程 2 比较和交换失败，原子变量的值未修改</p> 
</blockquote> 
<p>结果2</p> 
<blockquote> 
 <p>线程 2 比较和交换失败，原子变量的值未修改</p> 
 <p>线程 1 比较和交换成功，原子变量的值已修改为: 20</p> 
</blockquote> 
<p><code>compare_exchange_strong</code> 函数</p> 
<ul><li>比较和交换不成功时，<span style="color:#fe2c24;"><strong>拒绝</strong></span>其他线程对原子变量的更改，并返回 <code>false</code>，表示失败。</li><li>比较和交换成功时，将原子变量的值设置为新值，并返回 <code>true</code>，表示成功。</li></ul> 
<pre><code class="language-cpp">std::atomic&lt;int&gt; atomic_var(10);

void increment(std::atomic&lt;int&gt;&amp; var)
{
    int expected = 10;
    int new_value = 20;

    bool success = var.compare_exchange_strong(expected, new_value);

    if (success) {
        std::cout &lt;&lt; "线程 " &lt;&lt; std::this_thread::get_id()&lt;&lt; std::endl
                  &lt;&lt; " 比较和交换成功，原子变量的值已修改为: " &lt;&lt; var &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "线程 " &lt;&lt; std::this_thread::get_id()&lt;&lt; std::endl
                  &lt;&lt; " 比较和交换失败，原子变量的值未修改" &lt;&lt; std::endl;
    }
}

int main(int argc, char *argv[])
{
    std::thread t1(increment, std::ref(atomic_var));
    std::thread t2(increment, std::ref(atomic_var));
    t1.join();
    t2.join();
    return 0;
}</code></pre> 
<p><img alt="" height="184" src="https://images2.imgbox.com/3a/fa/5ZCEcsyc_o.png" width="578"></p> 
<p>如果某个线程在比较和交换时发现 atomic_var 的值已经被其他线程更改，那么它会拒绝其他线程对原子变量的更改，并返回 false，表示失败。因此，无论哪个线程先执行，只会有一个线程能够成功修改原子变量的值。上述代码输出结果可能会是以下两种情况之一：</p> 
<p>结果1</p> 
<blockquote> 
 <p>线程 1 比较和交换成功，原子变量的值已修改为: 20</p> 
 <p>线程 2 比较和交换失败，原子变量的值未修改</p> 
</blockquote> 
<p>结果2</p> 
<blockquote> 
 <p>线程 2 比较和交换成功，原子变量的值已修改为: 20</p> 
 <p>线程 1 比较和交换失败，原子变量的值未修改</p> 
</blockquote> 
<h3>2、exchange()</h3> 
<blockquote> 
 <p>原子地交换原子变量的值，并返回原来的值。</p> 
</blockquote> 
<pre><code class="language-cpp">    std::atomic&lt;int&gt; atomic_var(10);

    // 将 atomic_var 的值交换为 42
    int old_value = atomic_var.exchange(42);

    std::cout &lt;&lt; "旧值: " &lt;&lt; old_value &lt;&lt; std::endl;
    std::cout &lt;&lt; "新值: " &lt;&lt; atomic_var &lt;&lt; std::endl;</code></pre> 
<h3>3、fetch_add()、fetch_sub()</h3> 
<blockquote> 
 <p>原子地将原子变量的值增加 / 减少指定的增量，并返回增加前的旧值。</p> 
</blockquote> 
<pre><code class="language-cpp">    std::atomic&lt;int&gt; atomic_var(10);

    // 将 atomic_var 的值原子地增加 5
    int old_value = atomic_var.fetch_add(5);

    std::cout &lt;&lt; "增加前的值: " &lt;&lt; old_value &lt;&lt; std::endl;
    std::cout &lt;&lt; "增加后的值: " &lt;&lt; atomic_var &lt;&lt; std::endl;</code></pre> 
<h3>4、fetch_and()、fetch_or()、fetch_xor()</h3> 
<blockquote> 
 <p>原子地将原子变量的值与指定的值进行按位 与 / 或 / 异或 操作，并返回按位与前的旧值。</p> 
</blockquote> 
<h3>5、load()、operator T()</h3> 
<blockquote> 
 <p>获取对象中存储的值，同时确保在多线程环境下进行<strong>安全的原子操作</strong>（也就是可以安全地在多线程环境下进行，而无需额外的同步控制）。</p> 
</blockquote> 
<pre><code class="language-cpp">std::atomic&lt;int&gt; atomicInt(42);
int value = atomicInt.load();//value = 42;</code></pre> 
<h3>6、store()</h3> 
<blockquote> 
 <p>用于将给定的值存储到<code>std::atomic</code>对象中，并确保在多线程环境下进行<strong>安全的原子操作</strong>。该函数没有返回值，它仅负责将值存储到<code>std::atomic</code>对象中。它确保在存储新值之前，不会发生其他线程访问该<code>std::atomic</code>对象的竞争条件。</p> 
</blockquote> 
<h2>三、一个自定义类型的示例</h2> 
<p><code>std::atomic</code> 不仅支持数值类型，还支持其他可赋值类型。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;
#include &lt;string&gt;

struct Person {
    std::string name;
    int age;
};

std::atomic&lt;Person&gt; atomicPerson;

void updatePerson() {
    Person p{"Alice", 25};
    atomicPerson.store(p);
}

void printPerson() {
    Person p = atomicPerson.load();
    std::cout &lt;&lt; "Name: " &lt;&lt; p.name &lt;&lt; ", Age: " &lt;&lt; p.age &lt;&lt; std::endl;
}

int main() {
    std::thread t1(updatePerson);
    std::thread t2(printPerson);

    t1.join();
    t2.join();

    return 0;
}</code></pre> 
<h2>四、std::atomic_ref</h2> 
<p>此模板类可以对各种类型的非原子变量进行原子操作，比如整型、指针、自定义结构等。它允许在需要时<span style="color:#fe2c24;"><strong>对非原子变量进行原子操作</strong></span>。</p> 
<p>在多线程环境中使用 <code>std::atomic_ref</code> 可以避免对<span style="color:#fe2c24;"><strong>非原子变量</strong></span>进行竞争条件的操作，从而提高线程安全性。</p> 
<p>此类也有如上述的成员函数。</p> 
<p>例1：</p> 
<pre><code class="language-cpp">    int value = 42;
    std::atomic_ref&lt;int&gt; atomicValue(value);

    atomicValue.store(10, std::memory_order_relaxed);
    std::cout &lt;&lt; "Value is: " &lt;&lt; value &lt;&lt; std::endl; // 输出 10</code></pre> 
<p>这里首先创建了一个普通的整型变量 <code>value</code>，然后使用 <code>std::atomic_ref</code> 类型的 <code>atomicValue</code> 对其进行原子操作。通过 <code>store</code> 函数，将新的值 10 存储到 <code>atomicValue</code> 中，这也直接影响到了原始的变量 <code>value</code>。</p> 
<p>例2：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;string&gt;

struct UserData 
{
    std::string name;
    int age;
};

int main(int argc, char *argv[])
{
    UserData user {"Alice", 30};

    std::atomic_ref&lt;int&gt; atomicAge(user.age);

    // 在多线程环境中，使用原子操作更新用户的年龄
    auto updateAge = [&amp;atomicAge](int newAge)
    {
        atomicAge.store(newAge, std::memory_order_relaxed);
    };

    std::thread t1(updateAge, 35);
    std::thread t2(updateAge, 40);

    t1.join();
    t2.join();

    std::cout &lt;&lt; "Updated user1's age: " &lt;&lt; user.age &lt;&lt; std::endl; // 输出更新后的年龄

    return 0;
}</code></pre> 
<p>这里使用 <code>std::atomic_ref</code> 类型的 <code>atomicAge</code> 对 <code>user</code> 结构体中的 <code>age</code> 成员变量进行原子操作。在 <code>updateAge</code> 函数中，将新的 age 值存储到 <code>atomicAge</code> 中，并利用 <code>std::thread</code> 创建了两个线程来更新 <code>user</code> 的 age 。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c6e584464ad0635d7ddcc7b780b70ea7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RabbitMQ系列之入门级</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ee9923229d67e9dc46aaadff00dd05c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ABC337(A-C)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>