<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java代码实现—冒泡排序 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java代码实现—冒泡排序" />
<meta property="og:description" content="目录
1、前言
2、冒泡排序
2.1 算法思路
2.2 代码实现过程：
3、代码优化
3.1 趟数优化
3.2 循环次数优化
3.3 排序完成优化
4、结语
1、前言 我们书接上回，接着数组中的遗留问题来讲解这节的冒泡排序，干货满满，里面还涉及到代码的优化，希望大家有所收获
2、冒泡排序 冒泡排序思想：给定一个数组，让数组升序 (降序) 排序。 2.1 算法思路 假设排升序： 将数组中相邻元素从前往后依次进行比较，如果前一个元素比后一个元素大，则交换，一趟下来后最大元素就在数组的末尾。依次从上上述过程，直到数组中所有的元素都排列好。依据这个思想，我们很容易写出如下代码： public static void main7(String[] args) { int[] array = {10,5,3,7,6}; myBubblesort(array); System.out.println(Arrays.toString(array)); } public static void myBubblesort(int[] array){ for (int i = 0; i &lt; array.length; i&#43;&#43;) { for (int j = 0; j &lt; array.length-1; j&#43;&#43;) { if(array[j] &gt; array[j&#43;1]){ int tmp = 0; tmp = array[j]; array[j] = array[j&#43;1]; array[j&#43;1] = tmp; } } } } 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/4fb128ddb1339c0cf97c74febe5be32e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-09T16:31:11+08:00" />
<meta property="article:modified_time" content="2022-05-09T16:31:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java代码实现—冒泡排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E5%89%8D%E8%A8%80" rel="nofollow">1、前言</a></p> 
<p id="2%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" rel="nofollow">2、冒泡排序</a></p> 
<p id="2.1%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#2.1%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF" rel="nofollow">2.1 算法思路</a></p> 
<p id="2.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%9A" rel="nofollow">2.2 代码实现过程：</a></p> 
<p id="3%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96" rel="nofollow">3、代码优化</a></p> 
<p id="3.1%C2%A0%E8%B6%9F%E6%95%B0%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#3.1%C2%A0%E8%B6%9F%E6%95%B0%E4%BC%98%E5%8C%96" rel="nofollow">3.1 趟数优化</a></p> 
<p id="3.2%20%E5%BE%AA%E7%8E%AF%E6%AC%A1%E6%95%B0%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#3.2%20%E5%BE%AA%E7%8E%AF%E6%AC%A1%E6%95%B0%E4%BC%98%E5%8C%96" rel="nofollow">3.2 循环次数优化</a></p> 
<p id="3.3%20%E6%8E%92%E5%BA%8F%E5%AE%8C%E6%88%90%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#3.3%20%E6%8E%92%E5%BA%8F%E5%AE%8C%E6%88%90%E4%BC%98%E5%8C%96" rel="nofollow">3.3 排序完成优化</a></p> 
<p id="4%E3%80%81%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E7%BB%93%E8%AF%AD" rel="nofollow">4、结语</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81%E5%89%8D%E8%A8%80">1、前言</h2> 
<p>我们书接上回，接着数组中的遗留问题来讲解这节的冒泡排序，干货满满，里面还涉及到代码的优化，希望大家有所收获</p> 
<h2 id="2%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">2、冒泡排序</h2> 
<ul><li>冒泡排序思想：给定一个数组，让数组升序 (降序) 排序。</li></ul> 
<h3 id="2.1%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF">2.1 算法思路</h3> 
<ul><li>假设排升序：</li></ul> 
<ol><li>将数组中相邻元素从前往后依次进行比较，<strong>如果前一个元素比后一个元素大，则交换</strong>，一趟下来后最大元素就在数组的末尾。</li><li>依次从上上述过程，直到数组中所有的元素都排列好。</li><li>依据这个思想，我们很容易写出如下代码：</li></ol> 
<pre><code class="language-java">
    public static void main7(String[] args) {
        int[] array = {10,5,3,7,6};
        myBubblesort(array);
        System.out.println(Arrays.toString(array));
    }
    public static void myBubblesort(int[] array){
        for (int i = 0; i &lt; array.length; i++) {
            for (int j = 0; j &lt; array.length-1; j++) {
                if(array[j] &gt; array[j+1]){
                    int tmp = 0;
                    tmp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = tmp;
                }
            }
        }
    }

</code></pre> 
<h3 id="2.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%9A">2.2 代码实现过程：</h3> 
<ul><li> 上述代码在我们思路清晰的情况下很容易写出，但是代码是如何实现的呢？</li><li>在这里我们主要关注两个点：<strong><span style="color:#fe2c24;">趟数i和每次循环的次数j</span></strong>。</li></ul> 
<hr> 
<ul><li>第1趟：i = 0时</li></ul> 
<p><span style="color:#0d0016;">        当j = 0时，此时array[0] = 10; array[1] = 5；10 &gt; 5，<strong>所以执行array[j] = array[j+1]的交换代码（这里交换代码简写，下同）</strong>，数组变为：{5,10,3,7,6};</span></p> 
<p><span style="color:#0d0016;">        当j = 1时，此时array[1] = 10; array[2] = 3；10 &gt; 3，所以执行array[j] = array[j+1]的交换代码，数组变为{5,3,10,7,6}; </span></p> 
<p><span style="color:#0d0016;">        当j = 2时，此时array[2] = 10; array[3] = 7；10&gt;7，所以执行array[j] = array[j+1]的交换代码，数组变为{5,3,7,10,6}； </span></p> 
<p><span style="color:#0d0016;">        当j = 3时，此时array[3] = 10; array[4] = 6；10&gt;6，所以执行array[j] = array[j+1]的交换代码，数组变为{5,3,7,6,10}；</span></p> 
<p></p> 
<p>      <span style="color:#0d0016;">  至此第1趟的内部循环结束，</span><span style="color:#fe2c24;">我们将10这个数字排列到数组的末尾</span><span style="color:#0d0016;">，此时j循环了4次，<strong>j = 3时停止</strong>。 </span></p> 
<p><span style="color:#0d0016;">        我们发现，数组中一共有5个元素，j循环了4次，那么第一个循环条件就是<strong>j &lt;array.length - 1</strong>；如果不-1的话，j = 4的时候，<strong>那么array[j+1]就会越界</strong>，因为数组的下标就到4。 所以array.length - 1，<strong>是否就有一个条件呢？</strong>，答案是否定的（</span><span style="color:#fe2c24;">可以做代码优化</span><span style="color:#0d0016;">），我们继续向下执行第2趟。</span></p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/8e/a9/9gfdupVE_o.png" width="428"></p> 
<ul><li> 第2趟：i = 1时</li></ul> 
<p>        当j = 0时，此时数组是上一趟结束的数组{5,3,7,6,10}，此时array[0] = 5; array[1] = 3；5 &gt; 3，所以执行array[j] = array[j+1]的交换代码，数组变为：{3,5,7,6,10};</p> 
<p>        当j = 1时，此时array[1] = 5; array[2] = 7；5 &lt; 7，所以不执行array[j] = array[j+1]的交换代码，数组还是{3,5,7,6,10};</p> 
<p>        当j = 2时，此时array[2] = 7; array[3] = 6；7 &gt; 6，所以执行array[j] = array[j+1]的交换代码，数组变为{3,5,6,7,10};</p> 
<p>        至此第2趟代码就执行完交换了，因为当j = 3的时候，我们比较的是7和10的大小，在第一趟的时候，<strong>我们就已经操作完10到数组的末尾了，所以没必要再比较一次</strong>。</p> 
<p>         在第2趟中我们将7操作到倒数第二位的指定位置，我们发现内部循环j执行了3次，<span style="color:#fe2c24;">到j = 2时候停止</span>。 其实到第2趟的时候我们已经排序完成了，<strong>但是代码不知道这个事情（这点记下来，可以做代码优化）</strong>，我们接着执行第3趟</p> 
<p class="img-center"><img alt="" height="292" src="https://images2.imgbox.com/06/5c/tPkYsczd_o.png" width="456"></p> 
<ul><li> 第3趟：i = 2时</li></ul> 
<p><span style="color:#0d0016;">        当j = 0时，此时数组是上一趟结束的数组{3,5,6,7,10}，此时array[0] = 3; array[1] = 5；3 &lt; 5，所以不执行array[j] = array[j+1]的交换代码，数组还是{3,5,6,7,10}。</span></p> 
<p><span style="color:#0d0016;">         当j = 1时，此时array[1] = 5; array[2] = 6；5 &lt; 6，所以不执行array[j] = array[j+1]的交换代码，数组还是{3,5,6,7,10}。</span></p> 
<p><span style="color:#0d0016;">         至此第3趟的内部循环就结束了，因为如果再往下执行，就要操作7了，<strong>但是7我们在第2趟的时候已经操作过了。</strong></span></p> 
<p><span style="color:#0d0016;">         在第3趟的内部循环中，<strong>是操作了6在倒数第3位的位置</strong>，我们发现内部循环j执行了2次，</span><span style="color:#fe2c24;">到j = 1时候停止</span><span style="color:#0d0016;">。 数据早就排序好了，但是代码不知道，所以继续第4趟。</span></p> 
<p style="text-align:center;"><img alt="" height="212" src="https://images2.imgbox.com/28/d0/7eIPd6O9_o.png" width="454"></p> 
<ul><li>第4趟，i = 3时</li></ul> 
<p>        当j = 0时，此时数组是上一趟结束的数组{3,5,6,7,10}，此时array[0] = 3; array[1] = 5；3 &lt; 5，所以不执行array[j] = array[j+1]的交换代码，数组还是{3,5,6,7,10}。</p> 
<p>        至此第4趟结束了，因为我们要<strong>操作的是5这个数字，和3比较完之后，就已经在原来正确的位置了，所以循环结束</strong>。</p> 
<p>        在第4趟的内部循环中，是操作了<strong>5在倒数第4位的位置</strong>，我们发现内部循环j执行了1次，到<span style="color:#fe2c24;">j = 0</span>时候停止。</p> 
<p>       <span style="color:#fe2c24;">  注意</span>：我们要不要执行第5趟呢，这个问题放在代码优化中讲解。</p> 
<p class="img-center"><img alt="" height="238" src="https://images2.imgbox.com/77/25/JATtooJ2_o.png" width="212"></p> 
<h2 id="3%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96">3、代码优化</h2> 
<h3 id="3.1%C2%A0%E8%B6%9F%E6%95%B0%E4%BC%98%E5%8C%96">3.1 趟数优化</h3> 
<ul><li>书接上一节，当我们执行完第四趟的时候，现在只有3一个数字，没有必要再执行一趟，因为其他的数字如果排序完成之后，3自动排序好了，所<span style="color:#fe2c24;">以趟数可以优化为：i &lt; array.length - 1趟，也就是最后1趟没有必要执行</span>，代码优化如下：</li></ul> 
<pre><code class="language-java">
    public static void main7(String[] args) {
        int[] array = {10,5,3,7,6};
        myBubblesort(array);
        System.out.println(Arrays.toString(array));
    }
    public static void myBubblesort(int[] array){
        for (int i = 0; i &lt; array.length-1; i++) {
            for (int j = 0; j &lt; array.length-1; j++) {
                if(array[j] &gt; array[j+1]){
                    int tmp = 0;
                    tmp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = tmp;
                }
            }
        }
    }</code></pre> 
<h3 id="3.2%20%E5%BE%AA%E7%8E%AF%E6%AC%A1%E6%95%B0%E4%BC%98%E5%8C%96">3.2 循环次数优化</h3> 
<ul><li>我们发现，第1趟时候，j = 3结束循环；第2趟的时候，j = 2的时候结束循环；第3趟的时候，j = 1结束循环；第4趟的时候，j = 0结束循环。 <span style="color:#fe2c24;">所以内部循环j可以优化成j &lt; array.length- 1 - i；循环次数减少，代码的运行效率就提高了</span>。代码优化如下：</li></ul> 
<pre><code class="language-java">
    public static void main7(String[] args) {
        int[] array = {10,5,3,7,6};
        myBubblesort(array);
        System.out.println(Arrays.toString(array));
    }
    public static void myBubblesort(int[] array){
        for (int i = 0; i &lt; array.length-1; i++) {
            for (int j = 0; j &lt; array.length-i-1; j++) {
                if(array[j] &gt; array[j+1]){
                    int tmp = 0;
                    tmp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = tmp;
                }
            }
        }
    }</code></pre> 
<h3 id="3.3%20%E6%8E%92%E5%BA%8F%E5%AE%8C%E6%88%90%E4%BC%98%E5%8C%96">3.3 排序完成优化</h3> 
<ul><li>在上述代码中，我们<strong>肉眼可见的第2趟的时候就已经排序完成</strong>，<span style="color:#fe2c24;">但是代码并不知道排序完成</span>，还是会继续执行，那么我们有没有办法让代码知道什么时候已经排序完成呢？</li><li>我们设置一个<span style="color:#fe2c24;">标志位flg = false</span>；如果<span style="color:#fe2c24;">执行交换代码，就把flg = true</span>；如果没有交换代码，就证明排序已经完成。 我们在每一趟，执行或不执行交换代码的后面判断这个标志位，<strong>如果flg = true，证明本趟交换了数据，那就执行下一趟；如果flg = false；证明没有执行交换代码，那么本趟就已经排序完成了，就return结束函数即可</strong>。 代码优化如下：</li></ul> 
<pre><code class="language-java">   public static void main7(String[] args) {
        int[] array = 10,5,3,7,6};
        myBubblesort(array);
        System.out.println(Arrays.toString(array));
    }
    public static void myBubblesort(int[] array){
        for (int i = 0; i &lt; array.length-1; i++) {
            boolean flg = false;
            for (int j = 0; j &lt; array.length-1-i; j++) {
                if(array[j] &gt; array[j+1]){
                    int tmp = 0;
                    tmp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = tmp;
                    flg = true;
                }
            }
            if(flg == false){
                return;
            }
        }
    }
</code></pre> 
<ul><li><span style="color:#fe2c24;">注意</span>：flg标志位要放在趟数循环内部，因为每次循环都要把flg = false；<strong>否则如果放在循环外部，只要执行过一次交换，flg就为true了</strong>，那么就检测不到这趟是否完成了排序。 </li></ul> 
<h2 id="4%E3%80%81%E7%BB%93%E8%AF%AD">4、结语</h2> 
<ul><li>其实，冒泡排序我们本身是不难实现的，但是你能否做到三次代码优化呢？相信看完这次blog你也可以实现。</li><li>接下来，博主会更新<strong>类与对象</strong>的相关内容，期待大家的持续关注！</li></ul> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01e561c72317f646bfe5f085664a81e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux学习之必备命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ca1bf200c6c282837038a623f5fc19b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Markdown教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>