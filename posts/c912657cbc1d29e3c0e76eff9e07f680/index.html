<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue面试题总汇 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue面试题总汇" />
<meta property="og:description" content="vue的底层原理? vue组件之间的通信？ JS中判断数据类型的方法有几种? 最常见的判断方法：typeof
判断已知对象类型的方法： instanceof
根据对象的constructor判断： constructor
无敌万能的方法：jquery.type()
vue与angular的区别? 1.vue仅仅是mvvm中的view层，只是一个如jquery般的工具库，而不是框架，而angular而是mvvm框架。
2.vue的双向邦定是基于ES5 中的 3.getter/setter来实现的，而angular而是由自己实现一套模版编译规则，需要进行所谓的“脏”检查，vue则不需要。因此，vue在性能上更高效，但是代价是对于ie9以下的浏览器无法支持。
4.vue需要提供一个el对象进行实例化，后续的所有作用范围也是在el对象之下，而angular而是整个html页面。一个页面，可以有多个vue实例，而angular好像不是这么玩的。
5.vue真的很容易上手，学习成本相对低，不过可以参考的资料不是很丰富，官方文档比较简单，缺少全面的使用案例。高级的用法，需要自己去研究源码，至少目前是这样。
说说你对angular脏检查理解？ 在angular中你无法判断你的数据是否做了更改，所以它设置了一些条件，当你触发这些条件之后,它就执行一个检测来遍历所有的数据，对比你更改的地方，然后执行变化。
这个检查很不科学。而且效率不高，有很多多余的地方，所以官方称为 脏检查。
active-class是哪个组件的属性？ vue-router模块的router-link组件。
嵌套路由怎么定义？ 在实际项目中我们会碰到多层嵌套的组件组合而成，但是我们如何实现嵌套路由呢？因此我们需要在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。
index.html，只有一个路由出口
&lt;div id=&#34;app&#34;&gt; &lt;!-- router-view 路由出口, 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;复制代码 main.js，路由的重定向，就会在页面一加载的时候，就会将home组件显示出来，因为重定向指向了home组件，redirect的指向与path的必须一致。children里面是子路由，当然子路由里面还可以继续嵌套子路由。
import Vue from &#39;vue&#39; import VueRouter from &#39;vue-router&#39; Vue.use(VueRouter) //引入两个组件 import home from &#34;./home.vue&#34; import game from &#34;./game.vue&#34; //定义路由 const routes = [ { path: &#34;/&#34;, redirect: &#34;/home&#34; },//重定向,指向了home组件 { path: &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c912657cbc1d29e3c0e76eff9e07f680/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-06T02:52:29+08:00" />
<meta property="article:modified_time" content="2017-11-06T02:52:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue面试题总汇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <h5 class="heading">vue的底层原理?</h5> 
 <h5 class="heading">vue组件之间的通信？</h5> 
 <h5 class="heading">JS中判断数据类型的方法有几种?</h5> 
 <p><font color="#0000FF">最常见的判断方法：</font><font color="#FF0000">typeof</font></p> 
 <p><font color="#0000FF">判断已知对象类型的方法：</font> <font color="#FF0000">instanceof</font></p> 
 <p><font color="#0000FF">根据对象的constructor判断：</font><font color="#FF0000"> constructor</font></p> 
 <p><font color="#0000FF">无敌万能的方法：</font><font color="#FF0000">jquery.type()</font></p> 
 <h5 class="heading">vue与angular的区别?</h5> 
 <p>1.vue仅仅是mvvm中的view层，只是一个如jquery般的工具库，而不是框架，而angular而是mvvm框架。<br>2.vue的双向邦定是基于ES5 中的 3.getter/setter来实现的，而angular而是由自己实现一套模版编译规则，需要进行所谓的“脏”检查，vue则不需要。因此，vue在性能上更高效，但是代价是对于ie9以下的浏览器无法支持。<br>4.vue需要提供一个el对象进行实例化，后续的所有作用范围也是在el对象之下，而angular而是整个html页面。一个页面，可以有多个vue实例，而angular好像不是这么玩的。<br>5.vue真的很容易上手，学习成本相对低，不过可以参考的资料不是很丰富，官方文档比较简单，缺少全面的使用案例。高级的用法，需要自己去研究源码，至少目前是这样。</p> 
 <h5 class="heading">说说你对angular脏检查理解？</h5> 
 <p>在angular中你无法判断你的数据是否做了更改，所以它设置了一些条件，当你触发这些条件之后,它就执行一个检测来遍历所有的数据，对比你更改的地方，然后执行变化。<br>这个检查很不科学。而且效率不高，有很多多余的地方，所以官方称为 脏检查。</p> 
 <h5 class="heading">active-class是哪个组件的属性？</h5> 
 <p>vue-router模块的router-link组件。</p> 
 <h5 class="heading">嵌套路由怎么定义？</h5> 
 <p>在实际项目中我们会碰到多层嵌套的组件组合而成，但是我们如何实现嵌套路由呢？因此我们需要在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。<br>index.html，只有一个路由出口</p> 
 <pre><code class="hljs bash copyable">&lt;div id=<span class="hljs-string">"app"</span>&gt;  
    &lt;!-- router-view 路由出口, 路由匹配到的组件将渲染在这里 --&gt;  
    &lt;router-view&gt;&lt;/router-view&gt;  
&lt;/div&gt;<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>main.js，路由的重定向，就会在页面一加载的时候，就会将home组件显示出来，因为重定向指向了home组件，redirect的指向与path的必须一致。children里面是子路由，当然子路由里面还可以继续嵌套子路由。</p> 
 <pre><code class="hljs bash copyable">import Vue from <span class="hljs-string">'vue'</span>  
import VueRouter from <span class="hljs-string">'vue-router'</span>  
Vue.use(VueRouter)  

//引入两个组件 

import home from <span class="hljs-string">"./home.vue"</span>  
import game from <span class="hljs-string">"./game.vue"</span>  
//定义路由  
const routes = [  
    { path: <span class="hljs-string">"/"</span>, redirect: <span class="hljs-string">"/home"</span> },//重定向,指向了home组件  
    {  
        path: <span class="hljs-string">"/home"</span>, component: home,  
        children: [  
            { path: <span class="hljs-string">"/home/game"</span>, component: game }  
        ]  
    }  
]  
//创建路由实例  
const router = new VueRouter({routes})  

new Vue({  
    el: <span class="hljs-string">'#app'</span>,  
    data: {  
    },  
    methods: {  
    },  
    router  
})<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>home.vue，点击显示就会将子路由显示在出来，子路由的出口必须在父路由里面，否则子路由无法显示。</p> 
 <pre><code class="hljs bash copyable">&lt;template&gt;  
    &lt;div&gt;  
        &lt;h3&gt;首页&lt;/h3&gt;  
        &lt;router-link to=<span class="hljs-string">"/home/game"</span>&gt;  
            &lt;button&gt;显示&lt;tton&gt;  
        &lt;/router-link&gt;  
        &lt;router-view&gt;&lt;/router-view&gt;  
    &lt;/div&gt;  
&lt;/template&gt;<span class="copy-code-btn">复制代码</span></code></pre> 
 <p> game.vue</p> 
 <pre><code class="hljs bash copyable"> &lt;template&gt;  
    &lt;h3&gt;游戏&lt;/h3&gt;  
&lt;/template&gt;<span class="copy-code-btn">复制代码</span></code></pre> 
 <h5 class="heading">怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h5> 
 <blockquote> 
  <p>在router目录下的index.js文件中，对path属性加上/:id。<br>使用router对象的params.id。</p> 
 </blockquote> 
 <h5 class="heading">vue-router有哪几种导航钩子？</h5> 
 <p>三种，<br>第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。<br>第二种：组件内的钩子<br>第三种：单独路由独享组件</p> 
 <h5 class="heading">scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</h5> 
 <p>css的预编译。</p> 
 <blockquote> 
  <p>使用步骤：</p> 
 </blockquote> 
 <p>第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）</p> 
 <p>第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss</p> 
 <p>第三步：还是在同一个文件，配置一个module属性</p> 
 <p>第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”</p> 
 <blockquote> 
  <p>有哪几大特性:</p> 
 </blockquote> 
 <p>1、可以用变量，例如（$变量名称=值）；<br>2、可以用混合器，例如（）<br>3、可以嵌套</p> 
 <h5 class="heading">mint-ui是什么？怎么使用？说出至少三个组件使用方法？</h5> 
 <p>基于vue的前端组件库。npm安装，然后import样式和js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。<br>组件一：Toast(‘登录成功’)；<br>组件二：mint-header；<br>组件三：mint-swiper</p> 
 <h5 class="heading">v-model是什么？怎么使用？ vue中标签怎么绑定事件？</h5> 
 <p>可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性。绑定事件：<code>&lt;input @click=doLog()/&gt;</code></p> 
 <h5 class="heading">iframe的优缺点？</h5> 
 <p>iframe也称作嵌入式框架，嵌入式框架和框架网页类似，它可以把一个网页的框架和内容嵌入在现有的网页中。</p> 
 <blockquote> 
  <p>优点：</p> 
 </blockquote> 
 <ol><li>解决加载缓慢的第三方内容如图标和广告等的加载问题</li><li>Security sandbox</li><li>并行加载脚本</li><li>方便制作导航栏</li></ol> 
 <blockquote> 
  <p>缺点：</p> 
 </blockquote> 
 <ol><li>iframe会阻塞主页面的Onload事件</li><li>即时内容为空，加载也需要时间</li><li>没有语意</li></ol> 
 <h5 class="heading">简述一下Sass、Less，且说明区别？</h5> 
 <p>他们是动态的样式语言，是CSS预处理器,CSS上的一种抽象层。他们是一种特殊的语法/语言而编译成CSS。<br>变量符不一样，less是@，而Sass是$;<br>Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持;<br>Sass是基于Ruby的，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出Css到浏览器</p> 
 <h5 class="heading">axios是什么？怎么使用？描述使用它实现登录功能的流程？</h5> 
 <p>请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p> 
 <h5 class="heading">axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？</h5> 
 <p>跨域，添加用户操作，更新操作。</p> 
 <h5 class="heading">vuex是什么？怎么使用？哪种功能场景使用它？</h5> 
 <p>vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p> 
 <h5 class="heading">mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？</h5> 
 <p>一个model+view+viewModel框架，数据模型model，viewModel连接两个</p> 
 <p>区别：vue数据驱动，通过数据来显示视图层而不是节点操作。</p> 
 <p>场景：数据操作比较多的场景，更加便捷</p> 
 <h5 class="heading">自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？</h5> 
 <p>全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives</p> 
 <p>钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）</p> 
 <p>钩子函数参数：el、binding</p> 
 <h5 class="heading">说出至少4种vue当中的指令和它的用法？</h5> 
 <p>v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定</p> 
 <h5 class="heading">vue-router是什么？它有哪些组件？</h5> 
 <p>vue用来写路由一个插件。router-link、router-view</p> 
 <h5 class="heading">导航钩子有哪些？它们有哪些参数？</h5> 
 <blockquote> 
  <p>导航钩子有：</p> 
 </blockquote> 
 <p>a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave</p> 
 <blockquote> 
  <p>参数：</p> 
 </blockquote> 
 <p>有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种</p> 
 <h5 class="heading">Vue的双向数据绑定原理是什么？</h5> 
 <p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p> 
 <blockquote> 
  <p>具体步骤：</p> 
 </blockquote> 
 <p><strong>第一步：</strong>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter<br>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p> 
 <p><strong>第二步：</strong>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p> 
 <p><strong>第三步：</strong>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p> 
 <p><strong>第四步：</strong>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p> 
 <h5 class="heading">请详细说下你对vue生命周期的理解？</h5> 
 <p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p> 
 <pre><code class="hljs bash copyable">创建前/后： 在beforeCreated阶段，vue实例的挂载元素<span class="hljs-variable">$el</span>和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，<span class="hljs-variable">$el</span>还没有。

载入前/后：在beforeMount阶段，vue实例的<span class="hljs-variable">$el</span>和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。

更新前/后：当data变化时，会触发beforeUpdate和updated方法。

销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在<span class="copy-code-btn">复制代码</span></code></pre> 
 <h5 class="heading">请说下封装 vue 组件的过程？</h5> 
 <p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</p> 
 <p>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p> 
 <h5 class="heading">你是怎么认识vuex的？</h5> 
 <p>vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。<br>通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。</p> 
 <p>应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。</p> 
 <h5 class="heading">vue-loader是什么？使用它的用途有哪些？</h5> 
 <p>解析.vue文件的一个加载器，跟template/js/style转换成js模块。</p> 
 <p>用途：js可以写es6、style样式可以scss或less、template可以加jade等</p> 
 <h5 class="heading">请说出vue.cli项目中src目录每个文件夹和文件的用法？</h5> 
 <p>assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件</p> 
 <h5 class="heading">vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？</h5> 
 <p>第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default {<!-- --></p> 
 <p>第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’</p> 
 <p>第三步：注入到vue的子组件的components属性上面,components:{smithButton}</p> 
 <p>第四步：在template视图view中使用，<code>&lt;smith-button&gt; &lt;/smith-button&gt;</code><br>问题有：smithButton命名，使用的时候则smith-button。</p> 
 <h5 class="heading">聊聊你对Vue.js的template编译的理解？</h5> 
 <p>简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）</p> 
 <blockquote> 
  <p>详情步骤：</p> 
 </blockquote> 
 <p>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。</p> 
 <p>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p> 
 <h5 class="heading">vue的历史记录</h5> 
 <p>history 记录中向前或者后退多少步</p> 
 <h5 class="heading">vuejs与angularjs以及react的区别？</h5> 
 <h6 class="heading">1.与AngularJS的区别</h6> 
 <blockquote> 
  <p>相同点：</p> 
 </blockquote> 
 <p>都支持指令：内置指令和自定义指令。</p> 
 <p>都支持过滤器：内置过滤器和自定义过滤器。</p> 
 <p>都支持双向数据绑定。</p> 
 <p>都不支持低端浏览器。</p> 
 <blockquote> 
  <p>不同点：</p> 
 </blockquote> 
 <p>1.AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观。</p> 
 <p>2.在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢。</p> 
 <p>Vue.js使用基于依赖追踪的观察并且使用异步队列更新。所有的数据都是独立触发的。</p> 
 <p>对于庞大的应用来说，这个优化差异还是比较明显的。</p> 
 <h6 class="heading">2.与React的区别</h6> 
 <blockquote> 
  <p>相同点：</p> 
 </blockquote> 
 <p>React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用。</p> 
 <p>中心思想相同：一切都是组件，组件实例之间可以嵌套。</p> 
 <p>都提供合理的钩子函数，可以让开发者定制化地去处理需求。</p> 
 <p>都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载。</p> 
 <p>在组件开发中都支持mixins的特性。</p> 
 <blockquote> 
  <p>不同点：</p> 
 </blockquote> 
 <p>React依赖Virtual DOM,而Vue.js使用的是DOM模板。React采用的Virtual DOM会对渲染出来的结果做脏检查。</p> 
 <p>Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作DOM。</p> 
 <h2 class="heading">vue生命周期面试题</h2> 
 <h5 class="heading">什么是vue生命周期？</h5> 
 <p> Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p> 
 <h5 class="heading">vue生命周期的作用是什么？</h5> 
 <p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p> 
 <h5 class="heading">vue生命周期总共有几个阶段？</h5> 
 <p>它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p> 
 <h5 class="heading">第一次页面加载会触发哪几个钩子？</h5> 
 <p>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p> 
 <h5 class="heading">DOM 渲染在 哪个周期中就已经完成？</h5> 
 <p>DOM 渲染在 mounted 中就已经完成了</p> 
 <h5 class="heading">简单描述每个周期具体适合哪些场景？</h5> 
 <p>生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom</p> 
 <p>arguments是一个伪数组，没有遍历接口，不能遍历</p> 
 <h5 class="heading">cancas和SVG的是什么以及区别</h5> 
 <blockquote> 
  <p>SVG</p> 
 </blockquote> 
 <p>SVG 是一种使用 XML 描述 2D 图形的语言。<br>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。<br>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p> 
 <blockquote> 
  <p>Canvas</p> 
 </blockquote> 
 <p>Canvas 通过 JavaScript 来绘制 2D 图形。<br>Canvas 是逐像素进行渲染的。<br>在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p> 
 <p><strong>Canvas 与 SVG 的比较</strong></p> 
 <blockquote> 
  <p>Canvas</p> 
  <pre><code class="hljs bash copyable">依赖分辨率
不支持事件处理器
弱的文本渲染能力
能够以 .png 或 .jpg 格式保存结果图像
最适合图像密集型的游戏，其中的许多对象会被频繁重绘<span class="copy-code-btn">复制代码</span></code></pre> 
  <p>SVG</p> 
  <pre><code class="hljs bash copyable">不依赖分辨率
支持事件处理器
最适合带有大型渲染区域的应用程序（比如谷歌地图）
复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
不适合游戏应用<span class="copy-code-btn">复制代码</span></code></pre> 
 </blockquote> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32f337ce4fa02f502b05830373dd8e5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows安装tortoiseGIT图文详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a5d5d3c0babbca9c79358ac8d0f3cdbc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">EasyTouch物体的旋转缩放</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>