<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>测试RT-Thread 动态模块 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="测试RT-Thread 动态模块" />
<meta property="og:description" content="听说国人开发的RT-Thread OS 已经有一段时间了，一直没有尝试。毕竟学习一个新的平台花费的时间和精力非常多。这次来测试RT-Thread 的主要目的是希望使用它的动态库功能。现在Cortex-M 系列的Arm 处理器已经非常强大了。但是由于Cortex-M没有内存管理器。程序缺乏重定位的功能。所以难以实现类似linux OS 的共享库（lib.so )。而共享库对于系统的功能扩展非常重要。比如在控制器中，需要动态地导入功能块。如果没有共享库功能。那么新增加的程序库必须要和内核，OS 一起重新编译下载。实现远程添加，更新功能块就更加麻烦。所以，共享库对于控制设备的嵌入式软件而言是非常重要的。
初识RT-Thread RT-Thread Studio 开发环境非常方便
RT-Thread 已经提供了一个一体化的开发环境RT-Thread Studio。使用起来十分方便。为了减少一开始设置的麻烦，购买了一个Art PI 开发板。开发一个闪灯程序非常快捷和顺利。
RT-Thread的 依赖项
RT-Thread 使用ST link 作为程序下载工具，需要下载和安装STlink，同时也是有Python 需要安装Python 2.7
RT-Thread 的msh
与其他嵌入式OS 不同，RT-Thread 提供了一个类似Linux shell 的命令工具， 前叫做msh。通过开发板上的USB 与PC 链接。你可以使用一个串口软件使用。以前好像叫做Finsh 。不知道为什么不直接叫做shell ？
摆脱不了 RT-Thread 的ENV 工具
以前RT-Thread 是使用ENV 工具开发的。目前开发动态模块，好像依然脱不了ENV 工具。它是是在windows cmd 下使用的。在相关的目录下 击右键，选择 conEMU Here 进入。
吐槽一下
也许是一些历史的包袱，RT-Thread 的某些概念，命名和使用方式有点古怪，与linux ，或者其他的开发环境不同。初学起来有点摸不着头脑。正如我所指出的。开发一个软件，要十分小心地起名字和术语。尽量符合社会化语义（也就是人们的习惯）。
RT-Thread 的另一个问题是国人开发的软件普遍存在一个问题，不是软件本身的技术不好，而是社区不好。遇到问题在网络上很难找到答案。网络上的除了原厂的文档以外，回答问题，相互讨论和分享经验比较少。大多数是文章是相互转发的，或者是自己的学习笔记，或者是培训老师的文案。说的话都一个样。一个地方出错，许多地方都是错。这是使用国内软件的最大困惑。
使用动态模块 主要参考【STM32H750】玩转ART-Pi（八）——添加动态模块 这篇博文。视乎没有遇到太大的问题。
主要的scons 命令
set RTT_ROOT=C:\RT-ThreadStudio\workspace\art_pi_module\rt-thread set BSP_ROOT=C:\RT-ThreadStudio\workspace\art_pi_module scons --target=ua -s $ scons --lib=lib scons: Reading SConscript files ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/a95b425baacac1de306c68413a09eeef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-08T12:53:31+08:00" />
<meta property="article:modified_time" content="2021-09-08T12:53:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">测试RT-Thread 动态模块</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>      听说国人开发的RT-Thread OS 已经有一段时间了，一直没有尝试。毕竟学习一个新的平台花费的时间和精力非常多。这次来测试RT-Thread 的主要目的是希望使用它的动态库功能。现在Cortex-M 系列的Arm 处理器已经非常强大了。但是由于Cortex-M没有内存管理器。程序缺乏重定位的功能。所以难以实现类似linux OS 的共享库（lib.so )。而共享库对于系统的功能扩展非常重要。比如在控制器中，需要动态地导入功能块。如果没有共享库功能。那么新增加的程序库必须要和内核，OS 一起重新编译下载。实现远程添加，更新功能块就更加麻烦。所以，共享库对于控制设备的嵌入式软件而言是非常重要的。</p> 
<h3><span style="color:#4da8ee;">初识RT-Thread</span></h3> 
<p><strong><span style="color:#0d0016;">RT-Thread Studio 开发环境非常方便</span></strong></p> 
<p>     RT-Thread 已经提供了一个一体化的开发环境<span style="color:#0d0016;">RT-Thread Studio。使用起来十分方便。为了减少一开始设置的麻烦，购买了一个Art PI 开发板。开发一个闪灯程序非常快捷和顺利。</span></p> 
<p><strong><span style="color:#0d0016;">RT-Thread的 依赖项</span></strong></p> 
<p><span style="color:#0d0016;">  RT-Thread 使用ST link 作为程序下载工具，需要下载和安装STlink，同时也是有Python 需要安装Python 2.7</span></p> 
<p><strong><span style="color:#0d0016;">RT-Thread 的msh</span></strong></p> 
<p><span style="color:#0d0016;">     与其他嵌入式OS 不同，RT-Thread 提供了一个类似Linux shell 的命令工具， 前叫做msh。通过开发板上的USB 与PC 链接。你可以使用一个串口软件使用。以前好像叫做</span>Finsh 。不知道为什么不直接叫做shell ？</p> 
<p><strong>摆脱不了 RT-Thread 的ENV 工具</strong></p> 
<p>    以前RT-Thread 是使用ENV 工具开发的。目前开发动态模块，好像依然脱不了ENV 工具。它是是在windows cmd 下使用的。在相关的目录下 击右键，选择 conEMU Here 进入。</p> 
<p><strong>吐槽一下</strong></p> 
<p>     也许是一些历史的包袱，RT-Thread 的某些概念，命名和使用方式有点古怪，与linux ，或者其他的开发环境不同。初学起来有点摸不着头脑。正如我所指出的。开发一个软件，要十分小心地起名字和术语。尽量符合社会化语义（也就是人们的习惯）。</p> 
<p>   RT-Thread 的另一个问题是国人开发的软件普遍存在一个问题，不是软件本身的技术不好，而是社区不好。遇到问题在网络上很难找到答案。网络上的除了原厂的文档以外，回答问题，相互讨论和分享经验比较少。大多数是文章是相互转发的，或者是自己的学习笔记，或者是培训老师的文案。说的话都一个样。一个地方出错，许多地方都是错。这是使用国内软件的最大困惑。</p> 
<h3><span style="color:#4da8ee;">使用动态模块</span></h3> 
<p>主要参考<a href="https://blog.csdn.net/sinat_31039061/article/details/109763932" title="【STM32H750】玩转ART-Pi（八）——添加动态模块">【STM32H750】玩转ART-Pi（八）——添加动态模块</a> 这篇博文。视乎没有遇到太大的问题。</p> 
<p>主要的scons 命令</p> 
<pre><code class="language-bash">set RTT_ROOT=C:\RT-ThreadStudio\workspace\art_pi_module\rt-thread
 set BSP_ROOT=C:\RT-ThreadStudio\workspace\art_pi_module
scons --target=ua -s
$ scons --lib=lib
scons: Reading SConscript files ...

scons: warning: No version of Visual Studio compiler found - C/C++ compilers most likely not set correctly
File "C:\RT-ThreadStudio\workspace\rtthread-apps\tools\ua.py", line 275, in BuildLibrary
scons: done reading SConscript files.
scons: Building targets ...
CXX lib\FB_Interface.o
cc1plus.exe: warning: command line option '-std=c99' is valid for C/ObjC but not for C++
LINK lib\lib.so
arm-none-eabi-strip -R .hash lib\lib.so
arm-none-eabi-size lib\lib.so
   text    data     bss     dec     hex filename
   8621     416      16    9053    235d lib\lib.so
scons: done building targets.</code></pre> 
<p>后来在scons --lib=lib 时出现了 问题arm-none-eabi-gcc 命令找不到的问题：</p> 
<pre><code class="language-bash">scons: Building targets ...
CC lib\lib.o
Error in calling command:arm-none-eabi-gcc
Exception: No such file or directory</code></pre> 
<p>添加设置路径后好了。 </p> 
<pre><code class="language-cpp">set RTT_EXEC_PATH=C:\RT-ThreadStudio\repo\Extract\ToolChain_Support_Packages\ARM\GNU_Tools_for_ARM_Embedded_Processors\5.4.1\bin</code></pre> 
<p>  源码来自于 <a href="https://github.com/RT-Thread/rtthread-apps" title="rtthread-apps">rtthread-apps</a> 里面包括了两个程序，一个是库lib，一个是主程序hello</p> 
<p>lib.c</p> 
<pre><code class="language-objectivec">#include &lt;stdio.h&gt;

int lib_func(void)
{
    printf("hello world from RTT::dynamic library!\n");

    return 0;
}

int add_func(int a, int b)
{
    return (a + b);
}</code></pre> 
<p>在hello目录中的main.c</p> 
<pre><code class="language-objectivec">#include &lt;stdio.h&gt;
 #include &lt;dlfcn.h&gt;
 #include &lt;rtthread.h&gt; 
 
 #define APP_PATH "/sdcard/lib.so"
 
 typedef int (*add_func_t)(int, int); 
 typedef void (*lib_func_t)(void);
  int dlmodule_sample(void) 
  { 
      void* handle; 
      lib_func_t lib_function; 
      add_func_t add_function; 
      
       handle = dlopen(APP_PATH,RTLD_LAZY);
        if(!handle) {
             printf("dlopen %s failed!\n",APP_PATH); return -1;
              } 
         
         
              lib_function = 
              (lib_func_t)dlsym(handle,"lib_func");
               if(!lib_function) { 
                   printf("dlsym %p failed!\n",handle); return -1; } 
                  
                   lib_function(); 
               
               
                    add_function = (add_func_t)dlsym(handle,"add_func");
                     if(!add_function) { printf("dlsym %p failed!\n",handle); return -1; }                         
                     printf("add_function result is:%d\n",add_function(3,4));
 dlclose(handle); return 0; }
   MSH_CMD_EXPORT(dlmodule_sample, dlmodule sample);
   int main(void) { 
       printf("rt-thread dynamic module Test!\n");
        return 0; 
}</code></pre> 
<p>仔细对比一下的话，我们可做了一点改动。</p> 
<p>原来的 #define APP_PATH "/lib.so" 改成</p> 
<p> #define APP_PATH "/sdcard/lib.so"，也许某个地方设置一下使用/lib.so 也是可以的。</p> 
<p>另外，不知道为什么</p> 
<p>MSH_CMD_EXPORT(dlmodule_sample, dlmodule sample);   不起作用，按说这个语句可以将dlmount_sample 程序转变成为一条msh 命令。在msh 下运行这个程序。我后来直接在main 中调用dlmount_sample这个程序了。</p> 
<p>编译的命令</p> 
<pre><code class="language-bash"> set RTT_ROOT=C:\RT-ThreadStudio\workspace\art_pi_module\rt-thread
 set BSP_ROOT=C:\RT-ThreadStudio\workspace\art_pi_module
 scons --target=ua -s
 scons --lib=lib
 scons --app=hello
</code></pre> 
<h3><span style="color:#38d8f0;">进一步的测试</span></h3> 
<p><a href="https://blog.csdn.net/sinat_31039061/article/details/109763932" title="【STM32H750】玩转ART-Pi（八）——添加动态模块">【STM32H750】玩转ART-Pi（八）——添加动态模块</a> 的文章中到此结束了，但是真正要使用动态模块，好像还有一些事情要做</p> 
<p><span style="color:#38d8f0;"><strong>在studio 的项目文件中调用lib.so 库</strong></span></p> 
<p>这个好像比较简单，将dlmount_sample 拷贝到了项目的main中。</p> 
<pre><code class="language-objectivec">/*
 * Copyright (c) 2006-2020, RT-Thread Development Team
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Change Logs:
 * Date           Author       Notes
 * 2020-09-02     RT-Thread    first version
 */

#include &lt;rtthread.h&gt;
#include &lt;rtdevice.h&gt;
#include "drv_common.h"
#include &lt;stdio.h&gt;
 #include &lt;dlfcn.h&gt;
#define LED_PIN GET_PIN(I, 8)
#define APP_PATH "/sdcard/lib.so"

 typedef int (*add_func_t)(int, int);
 typedef void (*lib_func_t)(void);


  int dlmodule_sample(void)
  {
      void* handle;
      lib_func_t lib_function;
      add_func_t add_function;
       handle = dlopen(APP_PATH,RTLD_LAZY);
        if(!handle) {
             printf("dlopen %s failed!\n",APP_PATH); return -1;
              }


              lib_function =
              (lib_func_t)dlsym(handle,"lib_func");
               if(!lib_function) {
                   printf("dlsym %p failed!\n",handle); return -1; }

                   lib_function();

                 //add function
                    add_function = (add_func_t)dlsym(handle,"add_func");
                     if(!add_function) { printf("dlsym %p failed!\n",handle); return -1; }
                     printf("add_function result is:%d\n",add_function(3,4));
           
 dlclose(handle);
 return 0;
  }
int main(void)
{
    rt_uint32_t count = 1;
    printf("rt-thread dynamic module Test!\n");
    rt_thread_mdelay(500);
    dlmodule_sample();
    rt_pin_mode(LED_PIN, PIN_MODE_OUTPUT);

    while(count++)
    {
        rt_thread_mdelay(500);
        rt_pin_write(LED_PIN, PIN_HIGH);
        rt_thread_mdelay(500);
        rt_pin_write(LED_PIN, PIN_LOW);
    }
    return RT_EOK;
}

#include "stm32h7xx.h"
static int vtor_config(void)
{
    /* Vector Table Relocation in Internal QSPI_FLASH */
    SCB-&gt;VTOR = QSPI_BASE;
    return 0;
}
INIT_BOARD_EXPORT(vtor_config);

</code></pre> 
<p>     在这里唯一的一个问题是运行时，先运行main 线程，在mount sdcard 所以一开始就open lib.so 文件时，找不到 sdcard 。所以我在调用 dlmount_sample 之前添加了一个</p> 
<p> rt_thread_mdelay(500);</p> 
<p>确保 sdcard 已经mount 成功了。</p> 
<p><span style="color:#38d8f0;"><strong>lib 调用外部函数 </strong></span></p> 
<p>      如何在lib程序中回调main 的函数。这里我们使用了C语言 callback 的方法。经测试是可行的。</p> 
<p>lib.c</p> 
<pre><code>#include &lt;stdio.h&gt;

int lib_func(void)
{
    printf("hello world from RTT::dynamic library!\n");

    return 0;
}

int add_func(int a, int b)
{
    return (a + b);
}
int handle(int y, int (*Callback)(int)){
    printf("Entering Handle Function. \n");
        Callback(y);
        printf("Leaving Handle Function. \n");
        return 0;
}
</code></pre> 
<p>dlmodule_sample 子程序</p> 
<pre><code>#include &lt;rtdevice.h&gt;
#include "drv_common.h"
#include &lt;stdio.h&gt;
 #include &lt;dlfcn.h&gt;
#define LED_PIN GET_PIN(I, 8)
#define APP_PATH "/sdcard/lib.so"

 typedef int (*add_func_t)(int, int);
 typedef void (*lib_func_t)(void);
 typedef void (*handle_func_t)(int,int (*Callback)(int));
 int Callback(int x) // Callback Function 1
 {
     printf("Hello, this is Callback_1: x = %d ", x);
     return 0;
 }

  int dlmodule_sample(void)
  {
      void* handle;
      lib_func_t lib_function;
      add_func_t add_function;
      handle_func_t handle_function;
       handle = dlopen(APP_PATH,RTLD_LAZY);
        if(!handle) {
             printf("dlopen %s failed!\n",APP_PATH); return -1;
              }


              lib_function =
              (lib_func_t)dlsym(handle,"lib_func");
               if(!lib_function) {
                   printf("dlsym %p failed!\n",handle); return -1; }

                   lib_function();

                 //add function
                    add_function = (add_func_t)dlsym(handle,"add_func");
                     if(!add_function) { printf("dlsym %p failed!\n",handle); return -1; }
                     printf("add_function result is:%d\n",add_function(3,4));
                 // callback
                     handle_function = (handle_func_t)dlsym(handle,"handle");
                                         if(!handle_function) { printf("dlsym %p failed!\n",handle); return -1; }
                  handle_function(100,&amp;Callback);
 dlclose(handle);
 return 0;
  }</code></pre> 
<h3><span style="color:#4da8ee;">C++ 的动态库</span></h3> 
<p>     经过几天的测试表明，RT-Thread 的动态模块不支持C++ 类的动态库（在Linux 下是支持的，我测试过），一个简单的类，编译出来的so 有744K ，而且dlopen fail 。看来RT-Thread 目前不支持C++类的动态库。但是，在C++ 程序中调用c 语言的动态库。 </p> 
<h3><span style="color:#4da8ee;">RTM_EXPORT</span><br>  </h3> 
<p>        我的动态库中使用atoi 函数，编译的时候没有问题，运行时出现了 can't find atoi in kernel symbol table。看来stdlib 是基础库，并不能链接到动态库代码中。这就要用到RTM_EXPORT 。在主程序的第一行加上</p> 
<p> RTM_EXPORT(atoi);</p> 
<p>        就好了。作用是导出函数名，让动态模块使用，据说是缺什么，RTM_EXPORT 什么。</p> 
<h3><span style="color:#38d8f0;">结束语</span></h3> 
<p>       完成了RT-Thread OS 外部模块调用的初步测试。外部模块调用对应嵌入式程序而言是很有用的，也许是因为RT-Thread 的外部模块功能使我爱上了RT-Thread。</p> 
<p>        尽管不支持C++ 类的动态库，但是可以在C语言中使用static 变量，部分实现了类的功能</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d806b661d51b49a4ea5155110a972775/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">https协议详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d9f61b55e08e33a85d4a7673fb470461/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Echarts 柱状图渐变色设置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>