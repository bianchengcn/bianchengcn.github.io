<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>sprintf_s与_snprintf与_snprintf_s - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="sprintf_s与_snprintf与_snprintf_s" />
<meta property="og:description" content="int snprintf(char *str, size_t size, const char *format, ...); 将可变个参数(...)按照format格式化成字符串，然后将其复制到str中 (1) 如果格式化后的字符串长度 &lt; size，则将此字符串全部复制到str中，并给其后添加一个字符串结束符(&#39;\0&#39;)； (2) 如果格式化后的字符串长度 &gt;= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符(&#39;\0&#39;) 函数返回值:若成功则返回欲写入的字符串长度，若出错则返回负值。 -------------------------------------------- #include &lt;stdio.h&gt; //snprintf() #include &lt;string.h&gt; //strlen() int main() { char toname[30]; char *name = &#34;yangtaiping&#34;; printf(&#34;strlen(name) = %d\n&#34;, strlen(name)); snprintf(toname, strlen(name)&#43;strlen(&#34;姓名：&#34;)&#43;1, &#34;姓名：%s&#34;, name); printf(&#34;toname = %s\n&#34;, toname); printf(&#34;strlen(name) = %d\n&#34;, strlen(name)); } strcpy() sprintf() strcat() 存在安全隐患， 其对应的安全版为：strncpy() snprintf() strncat() 。　snprintf(s, 100, &#34;%.*S&#34;, 3, &#34;abcd&#34;);s的值为abc %.*s 表示有两项， 第一项指定了长度，第二项则是%s的内容，所以取前三位 词条图册更多图册 类似的函数还有： #include &lt;stdio." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/89544487d97216267d053e789f7c4791/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-02T22:54:57+08:00" />
<meta property="article:modified_time" content="2019-07-02T22:54:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">sprintf_s与_snprintf与_snprintf_s</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p> </p> 
 <p>int snprintf(char *str, <a href="http://baike.baidu.com/view/3236587.htm" rel="nofollow">size_t</a> size, const char *format, ...); </p> 
 <div class="spctrl"></div> 
 <p>　　将可变个<a href="http://baike.baidu.com/view/327406.htm" rel="nofollow">参数</a>(...)按照format格式化成字符串，然后将其复制到str中 </p> 
 <div class="spctrl"></div> 
 <p>　　(1) 如果格式化后的字符串长度 &lt; size，则将此字符串全部复制到str中，并给其后添加一个字符串结束符('\0')； </p> 
 <div class="spctrl"></div> 
 <p>　　(2) 如果格式化后的字符串长度 &gt;= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符('\0') </p> 
 <div class="spctrl"></div> 
 <p>　　函数返回值:若成功则返回欲写入的字符串长度，若出错则返回负值。 -------------------------------------------- </p> 
 <div class="spctrl"></div> 
 <p>　　#include &lt;stdio.h&gt; //snprintf() </p> 
 <div class="spctrl"></div> 
 <p>　　#include &lt;<a href="http://baike.baidu.com/view/1728868.htm" rel="nofollow">string.h</a>&gt; //strlen() </p> 
 <div class="spctrl"></div> 
 <p>　　int main() </p> 
 <div class="spctrl"></div> 
 <p>　　{ </p> 
 <div class="spctrl"></div> 
 <p>　　char toname[30]; </p> 
 <div class="spctrl"></div> 
 <p>　　char *name = "yangtaiping"; </p> 
 <div class="spctrl"></div> 
 <p>　　printf("strlen(name) = %d\n", strlen(name)); </p> 
 <div class="spctrl"></div> 
 <p>　　snprintf(toname, strlen(name)+strlen("姓名：")+1, "姓名：%s", name); </p> 
 <div class="spctrl"></div> 
 <p>　　printf("toname = %s\n", toname); </p> 
 <div class="spctrl"></div> 
 <p>　　printf("strlen(name) = %d\n", strlen(name)); </p> 
 <div class="spctrl"></div> 
 <p>　　} </p> 
 <div class="spctrl"></div> 
 <p>　　strcpy() sprintf() strcat() 存在安全隐患， 其对应的安全版为：strncpy() snprintf() strncat() 。　 </p> 
 <div class="spctrl"></div> 
 <p>　　snprintf(s, 100, "%.*S", 3, "abcd");s的值为abc %.*s 表示有两项， 第一项指定了长度，第二项则是%s的内容，所以取前三位 词条图册更多图册 </p> 
 <div class="spctrl"></div> 
 <p>　　类似的函数还有： </p> 
 <div class="spctrl"></div> 
 <p>　　#include &lt;stdio.h&gt; </p> 
 <div class="spctrl"></div> 
 <p>　　int printf(const char *format, ...); //格式化输出到标准输出设备 </p> 
 <div class="spctrl"></div> 
 <p>　　int fprintf(FILE *stream,const char *format, ...); //格式化输出到文件流 </p> 
 <div class="spctrl"></div> 
 <p>　　int sprintf(char *str,const char *format, ...); //格式化的输出字符串输出到str指向的地址空间</p> 
 <p> </p> 
 <p> </p> 
 <table style="table-layout:fixed;"><tbody><tr><td> 
     <div class="cnt" id="blog_text"> 
      <p>int snprintf(char *str, size_t size, <a class="ed_inner_link" href="http://baike.soso.com/v7610856.htm?ch=ch.bk.innerlink" rel="nofollow">const</a> char *format, ...);<br>　　将可变个参数(...)按照format格式化成字符串，然后将其复制到str中<br>　　(1) 如果格式化后的字符串长度 &lt; size，则将此字符串全部复制到str中，并给其后添加一个字符串结束符('\0')；<br>　　(2) 如果格式化后的字符串长度 =&gt; size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符('\0')<br>　　函数<a class="ed_inner_link" href="http://baike.soso.com/v581547.htm?ch=ch.bk.innerlink" rel="nofollow">返回值</a>:若成功则返回欲写入的字符串长度，若出错则返回负值。<br>　　--------------------------------------------<br>　　#include &lt;stdio.h&gt; //snprintf()<br>　　#include &lt;string.h&gt; //strlen()<br>　　int main()<br>　　{<!-- --><br>　　char array[30];<br>　　char *name = "yangtaiping";<br>　　printf("strlen(array) = %d\n", strlen(array));<br>　　snprintf(array, strlen(array), "姓名：%s", name);<br>　　printf("array = %s\n", array);<br>　　printf("strlen(array) = %d\n", strlen(array));<br>　　}<br>　　<a class="ed_inner_link" href="http://baike.soso.com/v646771.htm?ch=ch.bk.innerlink" rel="nofollow">strcpy</a>() sprintf() <a class="ed_inner_link" href="http://baike.soso.com/v1986961.htm?ch=ch.bk.innerlink" rel="nofollow">strcat</a>() 存在安全隐患， 其对应的安全版为：<br>　　strncpy() snprintf() strncat()<br>　　snprintf(s, 100, "%.*S", 3, "abcd");<br>　　s的值为abc<br>　　%.*s 表示有两项， 第一项指定了长度，第二项则是%s的内容，所以取前三位<br></p> 
      <p> </p> 
      <p>------------------------------------------------------------------------------------------------</p> 
      <p>MSDN页面分别如下：</p> 
      <p>spirntf_s:</p> 
      <p><a href="http://msdn.microsoft.com/zh-cn/library/ce3zzk1k%28VS.80%29.aspx" rel="nofollow"><font color="#000000">http://msdn.microsoft.com/zh-cn/library/ce3zzk1k%28VS.80%29.aspx</font></a></p> 
      <p>_snprintf:</p> 
      <p><a href="http://msdn.microsoft.com/zh-cn/library/2ts7cx93%28v=VS.90%29.aspx" rel="nofollow"><font color="#000000">http://msdn.microsoft.com/zh-cn/library/2ts7cx93%28v=VS.90%29.aspx</font></a></p> 
      <p>_snprintf_s:</p> 
      <p><a href="http://msdn.microsoft.com/zh-cn/library/f30dzcf6.aspx" rel="nofollow"><font color="#000000">http://msdn.microsoft.com/zh-cn/library/f30dzcf6.aspx</font></a></p> 
      <p>三个页面都有自己的例子。。其中后2个的例子比较多内容一些。</p> 
      <p> </p> 
      <p>为免将来页面失效：</p> 
      <pre>int sprintf_s(<br>   char *buffer,<br>   size_t sizeOfBuffer,<br>   const char *format [,<br>      argument] ... <br></pre> 
      <p>);</p> 
      <pre>template &lt;size_t size&gt;<br>int sprintf_s(<br>   char (&amp;buffer)[size],<br>   const char *format [,<br>      argument] ... <br></pre> 
      <p>); // C++ only</p> 
      <pre>int _snprintf(<br>   char *buffer,<br>   size_t count,<br>   const char *format [,<br>      argument] ... <br></pre> 
      <p>);</p> 
      <pre>int _snprintf(<br>   char (&amp;buffer)[size],<br>   size_t count,<br>   const char *format [,<br>      argument] ... <br></pre> 
      <p>); // C++ only</p> 
      <pre>int _snprintf_s(<br>   char *buffer,<br>   size_t sizeOfBuffer,<br>   size_t count,<br>   const char *format [,<br>   argument] ... <br></pre> 
      <p>);</p> 
      <pre>int _snprintf_s(<br>   char (&amp;buffer)[size],<br>   size_t count,<br>   const char *format [,<br>   argument] ... <br></pre> 
      <p>); // C++ only</p> 
      <p> </p> 
      <p>呼呼。。内容还挺多。</p> 
      <p> </p> 
      <p> </p> 
      <pre><br></pre> 
      <p>这里比较引人注目的是，_snprintf_s为什么在sizeOfBuffer的基础上，还要多加一个count？</p> 
      <p>count似乎是用来控制理想的宽度的。</p> 
      <p>如果得到的字符串超过了count，于是会被截断到count的长度后面再加一个null-teminate</p> 
      <p>当然，更高优先级的应该是sizeOfBuffer，必须不超过这个大小。这个就说到点子上了。</p> 
      <p> </p> 
      <p>如果应该输出的字符串的大小已经达到了sizeOfBuffer，那么就溢出了。溢出的情况下，sprintf_s函数把这当做一个错误，会把buffer缓冲区置为一个空字符串""。</p> 
      <p>而_snprintf_s的好处就是，有了count参数，输出的字符串就算超过缓冲区长度，仍然会有输出，输出字符串被截断到count大小，在这个大小的字符串后面加null-teminate。</p> 
      <pre><br></pre> 
      <p>当然，如果count被设置成和sizeOfBuffer同样大，或者不合理的更大，那么这个count参数就失去了意义。</p> 
      <p>这时候，如果输出字符串将要达到或者超过sizeOfBuffer，一样导致一个错误，输出缓冲区被置为空字符串。</p> 
      <p>因此，如果希望缓冲区被尽量利用，可以把count参数置为_TRUNCATE，这样的情况下，实际上效果相当于是将count设置为sizeOfBuffer - 1。</p> 
      <p> </p> 
      <p> </p> 
      <p>至于C语言环境下，sprintf_s与_snprintf的对比：</p> 
      <p>注意到，_snprintf的参数用的是count，而sprintf_s的参数用的是sizeOfBuffer。这很能说明问题。</p> 
      <p>看下对_snprintf的说明：</p> 
      <p>Let len be the length of the formatted data string (not including the terminating null). len and count are in bytes for _snprintf, wide characters for _snwprintf.</p> 
      <p>If len &lt; count, then len characters are stored in buffer, a null-terminator is appended, and len is returned.</p> 
      <p>If len = count, then len characters are stored in buffer, no null-terminator is appended, and len is returned.</p> 
      <p>If len &gt; count, then count characters are stored in buffer, no null-terminator is appended, and a negative value is returned.</p> 
      <p> </p> 
      <p>也就是说，_snprintf的count参数明明白白的就是一个count。</p> 
      <p>如果输出字符串刚好达到count，由于期待的最大长度就是count，那么输出字符串肯定要完整，不能截断。</p> 
      <p>但是假如字符串缓冲区的大小其实就是count，这怎么办？MS VCRT的设计者认为，在这种情况下应该把输出字符串的长度告知调用者，让调用者来决定是否自己添加null-teminate。</p> 
      <p>换句话说，调用_snprintf时要注意了，必须检查_snprintf的返回值，如果返回值不是正数，那么还得注意你的字符串缓冲区并不是null-teminate结尾的。</p> 
      <p> </p> 
      <p>总结来说，sprintf_s在缓冲区不够大时会失败，失败时缓冲区中是一个空字符串。</p> 
      <p>_snprintf不会失败，但是必须注意如果缓冲区不够大，缓冲区的内容将不是null-teminate的，必须自己注意字符串的结束。</p> 
      <p>_snprintf_s结合了2者的优点，只要count参数设置合理，函数就不会因缓冲区不够而失败。</p> 
      <p> </p> 
      <p>但是观察_snprintf_s的说明，有一个很有趣的内容。</p> 
      <p>这3族函数中，有失败情况的2个函数sprintf_s和_snprintf_s中，（再次强调，我这里的失败的意思是，调用后缓冲区里是一个空字符串），_set_invalid_parameter_handler设置的错误处理器，在失败的情况下会被调用。</p> 
      <p> </p> 
      <p>而截断的情况下，错误处理器并不会被调用。</p> 
      <p> </p> 
      <p>VC的库开发者总是提供一些怪怪的东西。无论如何，让代码更加安全总是符合大家的总体期望的。</p> 
      <p>另外补充一下，查阅这些字符串安全函数的资料的时候要注意，</p> 
      <p>对微软来说，凡是限制字符串复制长度的函数，这些设计者仍然认为是不安全的，因为逻辑上来说，</p> 
      <p>这些长度参数只是限制了源字符串被复制的长度，而不是目标缓冲区的长度。</p> 
      <p>也就是说，微软的这些设计者认为，安全的方式其实是依赖C++的机制，辨认出目标缓冲区的真正大小，以此实现安全的复制。</p> 
     </div></td></tr></tbody></table> 
 <br> 
</div> 
<p>转载于:https://www.cnblogs.com/kungfupanda/archive/2012/04/09/2438657.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/acc2d99b8f55a429503f9666ca188932/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">三大运营商移动电话用户总数达15.9亿户 同比增长6.2%</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3c694e87902ac5c32bb0728e5b8ffc6f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Dependency introduction</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>