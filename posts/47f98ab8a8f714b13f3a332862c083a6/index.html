<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OpenAI、斯坦福大学提出Meta-Prompting，有效提升语言模型的性能 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OpenAI、斯坦福大学提出Meta-Prompting，有效提升语言模型的性能" />
<meta property="og:description" content="为了研究如何提高语言模型的性能，使其更充分有效地输出对于提问的回答，来自斯坦福和 OpenAI 的学者强强联手，通过提出一种名为元提示（meta-prompting）的方法来深入探索。元提示通过让单个语言模型（如 GPT-4）充当中央控制器和多种专家角色，以实现对各种任务的准确和可靠回复。该方法结合了多个独立专家模型的优势和多样性，以便更好地解决复杂的任务和问题。
元提示的显著特点之一是其将复杂任务巧妙地分解为各个组件，然后汲取不同专业知识为每个组件提供支持，最终将各个专业领域的输出巧妙地整合在一起。让我们一起来看看究竟什么是元提示，而该方法又有着怎样的表现~
论文题目:
Meta-Prompting: Enhancing Language Models with Task-Agnostic Scaffolding
论文链接:
https://arxiv.org/abs/2401.12954
元提示（meta-prompting）的核心思想在于使用一个模型来协调和执行多个独立的提问，然后综合它们的回复以生成最终的答案。
从本质上讲，这种机制支持借助独立专业模型的能力和多样性，共同解决复杂任务或问题的集成方法。结合多个领域专业模型（即专家）的观点和结论，可能会产生更全面、强大和准确的解决方案。
▲图1 通过元提示增强 GPT-4 的有效性
举例来说，如果想通过应用元提示使 GPT-4 解决一个数学难题的话，通常可以采用三阶段的策略：
Meta Model 的输入指令：首先请教专业的“高级数学家”将难题分解为简单步骤；
Meta Model 输出：其次，将各步骤分配给专业领域的专家（比如让“程序员”来写代码）；
专家输出：最后，协调专家之间的交流并综合他们的输出。
因此，通过一个高层次的提示，GPT-4 可以同时充当两种角色：
Meta：管控过程的指挥者，扮演着任务的中枢，引导整个问题解决过程，提供指导和整体协调。
Expert：解决子任务的专家小组，通过多角度思考，为任务的提供各个专业领域的贡献。
在作者的设置下，专家只能由元模型调用。尽管在与新专家互动时，元模型可以选择综合各个专家的见解或共享一些文本给他们，但他们不能直接交互或沟通。这种限制是为了简化专家之间的交流，并将元模型置于操作的中心。
图 2 是元提示对话的可视化示例。元提示的独特之处在于，它将决定使用哪些提示和执行哪些代码片段交由 LLM 自身判断。
▲图2 元提示历史的示例
元提示 元提示（Meta-Prompting）是一种提高语言模型性能的方法，通过使用模型来协调和执行多个独立提问，待合成回复后生成最终的答案。这种方法原则上采用了集成方法，借鉴了多个专门模型（称为专家）的优势和多样性，以协同解决和处理具有多面性的任务或问题。
元提示的主要特点有：
使用模型协调和执行多个独立提问，然后合成它们的回复以生成最终答案。
元模型在整个过程中保持对整个历史和协调的全局视图。
动态选择上下文为专家提供新颖视角，同时元模型保留对整个过程的鸟瞰。
元提示可以启用单个黑盒模型充当中央控制器和各种专家小组，以生成更准确、可靠和连贯的回复。
▲算法1 元提示
如算法 1 所示，元提示主要包括以下步骤：
转换输入：使用转换函数 将原始提问放在合适的模板中，然后在 Meta Model 的初始指令中添加。
循环迭代：a) 提示 Meta Model：当前消息列表 指导 Meta Model 的下一个操作，要么直接回复提问，要么咨询特定领域的专家。b) 与领域专家模型互动：如果 Meta Model 没有返回结果，它可以调用任何专家并给予相应的指令，这些指令通过 从其输出中提取。此过程是隔离的，即每个专家只看到 Meta Model 选择与他们共享的内容，并根据这些内容作出回复。例如，如果问题涉及数学和历史，Meta Model 可能会咨询数学专家进行计算，并咨询历史专家提供历史背景。使用 模板提取专家的输出并附加上额外的指令。c) 返回最终回复：如果 Meta Model 的回复包含最终答案（通过特殊 token 突出显示），则使用 提取解决方案并返回。d) 错误处理：如果模型的回复 没有包含最终答案或没调用专家模型，则在消息列表 中附加错误消息。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/47f98ab8a8f714b13f3a332862c083a6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-28T23:58:27+08:00" />
<meta property="article:modified_time" content="2024-01-28T23:58:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OpenAI、斯坦福大学提出Meta-Prompting，有效提升语言模型的性能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>为了研究如何提高语言模型的性能，使其更充分有效地输出对于提问的回答，来自斯坦福和 OpenAI 的学者强强联手，通过提出一种名为元提示（meta-prompting）的方法来深入探索。元提示通过<strong>让单个语言模型（如 GPT-4）充当中央控制器和多种专家角色</strong>，以实现对各种任务的准确和可靠回复。该方法结合了多个独立专家模型的优势和多样性，以便更好地解决复杂的任务和问题。</p> 
<p>元提示的显著特点之一是其<strong>将复杂任务巧妙地分解为各个组件</strong>，然后<strong>汲取不同专业知识为每个组件提供支持</strong>，最终<strong>将各个专业领域的输出巧妙地整合在一起</strong>。让我们一起来看看究竟什么是元提示，而该方法又有着怎样的表现~</p> 
<p><strong>论文题目</strong>:<br><em><strong>Meta-Prompting: Enhancing Language Models with Task-Agnostic Scaffolding</strong></em></p> 
<p><strong>论文链接</strong>:<br><em>https://arxiv.org/abs/2401.12954</em></p> 
<hr> 
<p>元提示（meta-prompting）的核心思想在于<strong>使用一个模型来协调和执行多个独立的提问</strong>，然后综合它们的回复以生成最终的答案。</p> 
<p>从本质上讲，这种机制支持借助独立专业模型的能力和多样性，共同解决复杂任务或问题的集成方法。结合多个领域专业模型（即专家）的观点和结论，可能会产生更全面、强大和准确的解决方案。</p> 
<p></p> 
<p class="img-center"><img alt="" height="296" src="https://images2.imgbox.com/f6/d0/o8SReYbv_o.png" width="1080"></p> 
<p>▲图1 通过元提示增强 GPT-4 的有效性</p> 
<p>举例来说，如果想通过应用元提示使 GPT-4 解决一个数学难题的话，通常可以采用三阶段的策略：</p> 
<ol><li> <p><strong>Meta Model 的输入指令</strong>：首先请教专业的“高级数学家”将难题分解为简单步骤；</p> </li><li> <p><strong>Meta Model 输出</strong>：其次，将各步骤分配给专业领域的专家（比如让“程序员”来写代码）；</p> </li><li> <p><strong>专家输出</strong>：最后，协调专家之间的交流并综合他们的输出。</p> </li></ol> 
<p>因此，通过一个高层次的提示，GPT-4 可以同时<strong>充当两种角色</strong>：</p> 
<ul><li> <p><strong>Meta</strong>：管控过程的指挥者，扮演着任务的中枢，引导整个问题解决过程，提供指导和整体协调。</p> </li><li> <p><strong>Expert</strong>：解决子任务的专家小组，通过多角度思考，为任务的提供各个专业领域的贡献。</p> </li></ul> 
<p>在作者的设置下，<strong>专家只能由元模型调用</strong>。尽管在与新专家互动时，元模型可以选择<strong>综合</strong>各个专家的见解或<strong>共享</strong>一些文本给他们，但他们<strong>不能直接交互或沟通</strong>。这种限制是为了<strong>简化专家之间的交流</strong>，并<strong>将元模型置于操作的中心</strong>。</p> 
<p>图 2 是元提示对话的可视化示例。元提示的独特之处在于，它将<strong>决定使用哪些提示和执行哪些代码片段交由 LLM 自身判断</strong>。</p> 
<p></p> 
<p class="img-center"><img alt="" height="696" src="https://images2.imgbox.com/7e/5e/pIZ12D6z_o.png" width="1080"></p> 
<p>▲图2 元提示历史的示例</p> 
<h3><strong>元提示</strong></h3> 
<p>元提示（Meta-Prompting）是一种提高语言模型性能的方法，<strong>通过使用模型来协调和执行多个独立提问，待合成回复后生成最终的答案</strong>。这种方法原则上采用了集成方法，借鉴了多个专门模型（称为专家）的优势和多样性，以协同解决和处理具有多面性的任务或问题。</p> 
<p>元提示的主要特点有：</p> 
<ol><li> <p>使用模型协调和执行多个独立提问，然后合成它们的回复以生成最终答案。</p> </li><li> <p>元模型在整个过程中保持对整个历史和协调的全局视图。</p> </li><li> <p>动态选择上下文为专家提供新颖视角，同时元模型保留对整个过程的鸟瞰。</p> </li><li> <p>元提示可以启用单个黑盒模型充当中央控制器和各种专家小组，以生成更准确、可靠和连贯的回复。</p> </li></ol> 
<p></p> 
<p class="img-center"><img alt="" height="430" src="https://images2.imgbox.com/b8/7b/qWqdCRTW_o.png" width="1080"></p> 
<p>▲算法1 元提示</p> 
<p>如算法 1 所示，元提示主要包括以下步骤：</p> 
<ol><li> <p><strong>转换输入</strong>：使用转换函数  将原始提问放在合适的模板中，然后在 Meta Model 的初始指令中添加。</p> </li><li> <p><strong>循环迭代</strong>：a) <strong>提示 Meta Model</strong>：当前消息列表  指导 Meta Model 的下一个操作，<strong>要么直接回复提问，要么咨询特定领域的专家</strong>。b) <strong>与领域专家模型互动</strong>：如果 Meta Model 没有返回结果，它可以调用任何专家并给予相应的指令，这些指令通过  从其输出中提取。此过程是隔离的，即<strong>每个专家只看到 Meta Model 选择与他们共享的内容，并根据这些内容作出回复</strong>。例如，如果问题涉及数学和历史，Meta Model 可能会咨询数学专家进行计算，并咨询历史专家提供历史背景。使用  模板提取专家的输出并附加上额外的指令。c) <strong>返回最终回复</strong>：如果 Meta Model 的<strong>回复包含最终答案</strong>（通过特殊 token 突出显示），则使用  提取解决方案并返回。d) <strong>错误处理</strong>：如果模型的回复  <strong>没有包含最终答案或没调用专家模型</strong>，则在消息列表  中附加错误消息。</p> </li><li> <p><strong>实时代码执行</strong>：将 Python 专家引入到 meta-prompting 框架中，可以显著提高在算法挑战方面的表现。这使得立即验证和优化解决方案成为可能，大大提高了问题解决的效率和精确度。</p> </li></ol> 
<p>通过这种方法，<strong>单一的黑盒语言模型可以充当中央控制器和多领域的不同专家角色</strong>，从而产生更准确、可靠和连贯的回复。</p> 
<h3><strong>实验结果</strong></h3> 
<p>本文实验要评估下述零样本提示任务的有效性：</p> 
<ul><li> <p>24 点游戏；</p> </li><li> <p>Three BIG-Bench Hard（BBH），即几何形状、多步算术和单词排序，以及一步将军的推理任务</p> </li><li> <p>Python 编程难题；</p> </li><li> <p>多语言小学数学（MGSM），即 GSM8K 数据集的多语言版本</p> </li><li> <p>莎士比亚十四行诗创作，这是作者创建的一个新任务。</p> </li></ul> 
<p>有如下度量标准来衡量准确性：</p> 
<ul><li> <p>精确匹配（EM）：严格。要求答案与真实标签完全相同。</p> </li><li> <p>软匹配（SM）：相对宽松。只要答案中存在真实标签即可，而不考虑其他文本内容。</p> </li><li> <p>功能正确（FC）：确定答案是否在功能上正确，即是否符合任务特定的约束。</p> </li></ul> 
<p>在不同任务中应用不同的度量标准。例如，使用 EM 的任务包括几何形状、多步算术和一步将军；SM 度量标准用于解 MGSM 和单词排序；而 FC 则被用于 24 点游戏、Python 编程难题和莎士比亚十四行诗创作。</p> 
<h4><strong>元提示的整体表现</strong></h4> 
<p>实验结果如表 1 所示，元提示方法在各项任务中相相较于零样本提示方法取得卓越效果，元提示可以以任务无关的方式利用 Python 解释器，搭配使用时显著提高了准确性。在标准提示方面的表现提升了 17.1%，在专家（动态）提示方面提升了 17.3%，在多人物提示方面提升了 15.2%。</p> 
<p></p> 
<p class="img-center"><img alt="" height="385" src="https://images2.imgbox.com/29/97/mxkLy1na_o.png" width="1080"></p> 
<p>▲表1 不同任务中的综合比较</p> 
<ul><li> <p>在 24 点游戏挑战中，元提示方法相较于基本标准提示方法，<strong>准确性提高了超过 60%<strong>；在Python 编程难题中获得了约 15% 的增益；在创作十四行诗的任务中，准确性提升近 18%。这些任务</strong>对于启发式或迭代试错问题解决策略具有挑战性</strong>，而<strong>传统的单次提示方法无法胜任</strong>。元提示通过<strong>充分利用各种专家角色的集体智慧，迭代地推进解决方案发展</strong>，展现了更具动态和有效的问题解决能力。</p> </li><li> <p>在创意写作任务中，尤其是在莎士比亚十四行诗创作中，元提示同样表现出色。</p> </li><li> <p><strong>在 MGSM 和几何形状等任务中，元提示相对于其他提示方法的优势较小</strong>，尤其是在几何形状任务中，性能仅略有增益。然而，在一步将军任务中，元提示甚至在没有用 Python 解释器的情况下也取得了 20.8% 的提升。</p> </li></ul> 
<h4><strong>让多位专家合作</strong></h4> 
<p>元提示框架成功在其策略性运用专业知识、自我协作和隐式验证循环。这一方法，尤其是多人物提示，鼓励多轮互动，促使不同专家角色共同参与问题解决。</p> 
<p>本文的结构化方法体现了<strong>集体的多样化批判性思想家意见往往超过个别专家的见解</strong>。<strong>通过在 Meta Model 的指导下利用一系列专业专家模型，每个模型从不同的专业角度贡献</strong>，从而实现了更准确和可靠的问题解决方案。</p> 
<h4><strong>引入新颖视角</strong></h4> 
<p>引入新颖视角<strong>对于缓解语言模型的重复错误和过于自信的表现具有关键作用</strong>。元提示与多人物提示存在着区别，它是通过重新评估问题引入新的专业视角。相较于元提示，<strong>新颖视角提供了发现新颖见解和之前未注意到的错误解决方案的机会</strong>。</p> 
<p>其中，专家的提示不包含整个历史记录，因此每一步都引入了新的视角，有效地找到解决方案的同时识别和纠正错误。</p> 
<h4><strong>实时执行代码</strong></h4> 
<p>对比实验结果，在引入 Python 专家进行代码生成和执行的元提示框架中，解决算法挑战的能力得到显著提高。这一提升主要归功于 <strong>Meta Model 能够使用 Python 专家基于自然语言指令生成和执行代码</strong>。实时执行代码使得可以即时验证和优化解决方案，极大地提高了解决问题的效率和准确度。</p> 
<p></p> 
<p class="img-center"><img alt="" height="414" src="https://images2.imgbox.com/81/07/MxCS33IU_o.png" width="1080"></p> 
<p>▲图4 Meta Model 在涉及 Python 解释器的实验中调用专家的分布</p> 
<p></p> 
<p class="img-center"><img alt="" height="411" src="https://images2.imgbox.com/51/47/9fXeWRwN_o.png" width="1080"></p> 
<p>▲图5 Meta Model 在没有使用 Python 解释器的实验中调用专家的分布</p> 
<p>然而，这种增强不只适用于 Python 编程难题这一任务，总体而言，与没有 Python 解释器的元提示相比，集成 Python 解释器平均使不同任务的性能额外提高了 11.5%。这凸显了代码生成和执行在提高元提示框架效果方面的关键作用，并展示了其<strong>在不同计算任务中的变革性影响</strong>。</p> 
<h3><strong>元提示框架的局限性</strong></h3> 
<ol><li> <p><strong>成本效益问题</strong>：其显著限制便是<strong>模型多次调用 GPT-4 API</strong>，导致产生了相当高的费用。</p> </li><li> <p><strong>大规模上下文窗口的要求</strong>：元提示框架<strong>对大规模和相当大的上下文窗口有要求</strong>。它需要一个能够处理和保留大量文本信息的语言模型。</p> </li><li> <p><strong>操作效率挑战</strong>：由于<strong>逐步处理的步骤，依赖于前面调用的结果</strong>，这个线性（顺序）性质带来<strong>操作效率上的挑战</strong>。限制了并行处理的可能性，从而影响系统的速度和效率。</p> </li><li> <p><strong>封闭领域系统的限制</strong>：当前只在封闭领域系统中研究，<strong>未在更广泛的实际应用中测试</strong>。该框架的潜力在于整合外部资源，如 API、专门调优的模型、搜索引擎或计算工具，但这一方面带来的提升仍需进一步研究。</p> </li><li> <p><strong>回复模式和信息管理问题</strong>：元模型在面对性能较差的任务时，其<strong>回复的措辞可能总在表达歉意</strong>，其根源可以追溯到元模型在训练中接受的指令数据。而且偶尔会<strong>忽略向专家传达必要信息</strong>。这凸显了改进信息管理的需要，以确保元模型与专家之间的沟通更加准确和完整</p> </li><li> <p><strong>亟待开发的潜力</strong>：例如在同时调用多个专家或利用具有不同温度参数的单个专家，以更有效地综合他们的输出。希望在后续版本中，元模型能够在推进过程之前从其历史中受益，通过精简或总结信息来提高整个过程的相关性和效率。</p> </li></ol> 
<h3><strong>总结</strong></h3> 
<p>本文介绍了元提示这一技简单而强大的框架，可以以任务无关的方式增强语言模型的性能。这一方法的独特之处在于，它<strong>巧妙地利用语言模型兼具中央控制器和专家的双重角色</strong>，赋予传统模型动态和多功能能力。</p> 
<p>实验结果表明，元提示方法在多种任务和数据集上的表现优于其他零样本提示技术。特别是与 Python 解释器相结合时，元提示框架显著提高了 GPT-4 在各种任务中的整体准确性和稳定性。</p> 
<p>本文提出的元提示框架作为语言模型不断发展的一部分，有望博采众家之长，<strong>其独特的任务分解、多专业知识引入和输出整合方法</strong>，使其在解决各种问题时表现出灵活性和效果。然而，作者也明确指出了一些限制和挑战，如成本效益、可扩展性和操作效率等问题，这需要在未来的研究中进一步探讨和解决。</p> 
<p></p> 
<p class="img-center"><img alt="" height="1080" src="https://images2.imgbox.com/e5/79/mmmXLCxt_o.jpg" width="1080"></p> 
<p></p> 
<p class="img-center"><img alt="" height="74" src="https://images2.imgbox.com/48/6b/kG8rPTT3_o.png" width="726"></p> 
<p></p> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/2e/f7/P27BBv3m_o.jpg" width="1080"></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fe4c7e59352f7757b792c20064f046b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">更新PerformanceDataCenter</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f0da8524f02f21cb1f28dd677d54f1ab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Fluid Engine Development PIC/FLIP 代码分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>