<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LibCurl使用小结 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LibCurl使用小结" />
<meta property="og:description" content="一、LibCurl基本编程框架 libcurl是一个跨平台的网络协议库，支持http, https, ftp, gopher, telnet, dict, file, 和ldap 协议。libcurl同样支持HTTPS证书授权，HTTP POST, HTTP PUT, FTP 上传, HTTP基本表单上传，代理，cookies,和用户认证。想要知道更多关于libcurl的介绍，可以到官网 http://curl.haxx.se/上去了解，在这里不再详述。 win32版的libcurl下载地址:http://curl.freeby.pctools.cl/download/libcurl-7.18.0-win32-msvc.zip 在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。下面是利用libcurl完成传输任务的流程： 1. 调用curl_global_init()初始化libcurl 2. 调用curl_easy_init()函数得到 easy interface型指针 3. 调用curl_easy_setopt()设置传输选项 4. 根据curl_easy_setopt()设置的传输选项，实现回调函数以完成用户特定任务 5. 调用curl_easy_perform()函数完成传输任务 6. 调用curl_easy_cleanup()释放内存 在整过过程中设置curl_easy_setopt()参数是最关键的，几乎所有的libcurl程序都要使用它。
二、基本的函数 1.CURLcode curl_global_init(long flags); 描述： 这个函数只能用一次。(其实在调用curl_global_cleanup 函数后仍然可再用) 如果这个函数在curl_easy_init函数调用时还没调用，它讲由libcurl库自动调用，所以多线程下最好主动调用该函数以防止在线程中curl_easy_init时多次调用。 注意：虽然libcurl是线程安全的，但curl_global_init是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。 参数：flags CURL_GLOBAL_ALL //初始化所有的可能的调用。 CURL_GLOBAL_SSL //初始化支持 安全套接字层。 CURL_GLOBAL_WIN32 //初始化win32套接字库。 CURL_GLOBAL_NOTHING //没有额外的初始化。
2 void curl_global_cleanup(void); 描述：在结束libcurl使用的时候，用来对curl_global_init做的工作清理。类似于close的函数。 注意：虽然libcurl是线程安全的，但curl_global_cleanup是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。
3 char *curl_version( ); 描述: 打印当前libcurl库的版本。
4 CURL *curl_easy_init( ); 描述: curl_easy_init用来初始化一个CURL的指针(有些像返回FILE类型的指针一样)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5cf902a417548a6318fb226ea7deeb6c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-01-03T20:23:01+08:00" />
<meta property="article:modified_time" content="2017-01-03T20:23:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LibCurl使用小结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="一libcurl基本编程框架">一、LibCurl基本编程框架</h3> 
<p>libcurl是一个跨平台的网络协议库，支持http, https, ftp, gopher, telnet, dict, file, 和ldap 协议。libcurl同样支持HTTPS证书授权，HTTP POST, HTTP PUT, FTP 上传, HTTP基本表单上传，代理，cookies,和用户认证。想要知道更多关于libcurl的介绍，可以到官网 <a href="http://curl.haxx.se/" rel="nofollow">http://curl.haxx.se/</a>上去了解，在这里不再详述。 <br> win32版的libcurl下载地址:<a href="http://curl.freeby.pctools.cl/download/libcurl-7.18.0-win32-msvc.zip" rel="nofollow">http://curl.freeby.pctools.cl/download/libcurl-7.18.0-win32-msvc.zip</a> <br> 在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。下面是利用libcurl完成传输任务的流程： <br> 1. 调用curl_global_init()初始化libcurl <br> 2. 调用curl_easy_init()函数得到 easy interface型指针 <br> 3. 调用curl_easy_setopt()设置传输选项 <br> 4. 根据curl_easy_setopt()设置的传输选项，实现回调函数以完成用户特定任务 <br> 5. 调用curl_easy_perform()函数完成传输任务 <br> 6. 调用curl_easy_cleanup()释放内存 <br> 在整过过程中设置curl_easy_setopt()参数是最关键的，几乎所有的libcurl程序都要使用它。</p> 
<h3 id="二基本的函数">二、基本的函数</h3> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-number">1.</span>CURLcode curl_global_init(<span class="hljs-keyword">long</span> flags);</code></pre> 
<p>描述： <br> 这个函数只能用一次。(其实在调用curl_global_cleanup 函数后仍然可再用) <br> 如果这个函数在curl_easy_init函数调用时还没调用，它讲由libcurl库自动调用，所以多线程下最好主动调用该函数以防止在线程中curl_easy_init时多次调用。 <br> 注意：虽然libcurl是线程安全的，但curl_global_init是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。 <br> 参数：flags <br> CURL_GLOBAL_ALL //初始化所有的可能的调用。 <br> CURL_GLOBAL_SSL //初始化支持 安全套接字层。 <br> CURL_GLOBAL_WIN32 //初始化win32套接字库。 <br> CURL_GLOBAL_NOTHING //没有额外的初始化。</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-number">2</span> <span class="hljs-keyword">void</span> curl_global_cleanup(<span class="hljs-keyword">void</span>);</code></pre> 
<p>描述：在结束libcurl使用的时候，用来对curl_global_init做的工作清理。类似于close的函数。 <br> 注意：虽然libcurl是线程安全的，但curl_global_cleanup是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。</p> 
<pre class="prettyprint"><code class=" hljs scss">3 <span class="hljs-value">char</span> *<span class="hljs-function">curl_version( )</span>;</code></pre> 
<p>描述: 打印当前libcurl库的版本。</p> 
<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-number">4</span> CURL <span class="hljs-variable">*curl_easy_init</span>( );</code></pre> 
<p>描述: <br> curl_easy_init用来初始化一个CURL的指针(有些像返回FILE类型的指针一样). 相应的在调用结束时要用curl_easy_cleanup函数清理. <br> 一般curl_easy_init意味着一个会话的开始. 它会返回一个easy_handle(CURL*对象), 一般都用在easy系列的函数中.</p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-number">5</span> <span class="hljs-literal">void</span> curl_easy_cleanup(CURL <span class="hljs-subst">*</span><span class="hljs-keyword">handle</span>);</code></pre> 
<p>描述: <br> 这个调用用来结束一个会话.与curl_easy_init配合着用. <br> 参数: <br> CURL类型的指针.</p> 
<pre class="prettyprint"><code class=" hljs rsl"><span class="hljs-number">6</span> CURLcode curl_easy_setopt(CURL *handle, CURLoption <span class="hljs-built_in">option</span>, parameter);</code></pre> 
<p>描述: 这个函数最重要了.几乎所有的curl 程序都要频繁的使用它.它告诉curl库.程序将有如何的行为. 比如要查看一个网页的html代码等.(这个函数有些像ioctl函数)参数: <br> 1 CURL类型的指针 <br> 2 各种CURLoption类型的选项.(都在curl.h库里有定义,man 也可以查看到) <br> 3 parameter 这个参数 既可以是个函数的指针,也可以是某个对象的指针,也可以是个long型的变量.它用什么这取决于第二个参数. <br> CURLoption 这个参数的取值很多.具体的可以查看man手册.</p> 
<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-number">7</span> CURLcode curl_easy_perform(CURL <span class="hljs-variable">*handle</span>);</code></pre> 
<p>描述:这个函数在初始化CURL类型的指针 以及curl_easy_setopt完成后调用. 就像字面的意思所说perform就像是个舞台.让我们设置的 <br> option 运作起来.参数: <br> CURL类型的指针.</p> 
<h3 id="三-curleasysetopt函数部分选项介绍">三、 curl_easy_setopt函数部分选项介绍</h3> 
<p>本节主要介绍curl_easy_setopt中跟http相关的参数。该函数是curl中非常重要的函数，curl所有设置都是在该函数中完成的，该函数的设置选项众多，注意本节的阐述的只是部分常见选项。 <br> 1. CURLOPT_URL <br> 设置访问URL <br> 2. CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA <br> 回调函数原型为：size_t function( void *ptr, size_t size, size_t nmemb, void *stream); 函数将在libcurl接收到数据后被调用，因此函数多做数据保存的功能，如处理下载文件。CURLOPT_WRITEDATA 用于表明CURLOPT_WRITEFUNCTION函数中的stream指针的来源。 <br> 如果你没有通过CURLOPT_WRITEFUNCTION属性给easy handle设置回调函数，libcurl会提供一个默认的回调函数，它只是简单的将接收到的数据打印到标准输出。你也可以通过 CURLOPT_WRITEDATA属性给默认回调函数传递一个已经打开的文件指针，用于将数据输出到文件里。</p> 
<ol><li><p>CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA <br> 回调函数原型为 size_t function( void *ptr, size_t size,size_t nmemb, void *stream); libcurl一旦接收到http 头部数据后将调用该函数。CURLOPT_WRITEDATA 传递指针给libcurl，该指针表明CURLOPT_HEADERFUNCTION 函数的stream指针的来源。</p></li><li><p>CURLOPT_READFUNCTION CURLOPT_READDATA <br> libCurl需要读取数据传递给远程主机时将调用CURLOPT_READFUNCTION指定的函数，函数原型是：size_t function(void *ptr, size_t size, size_t nmemb,void *stream). CURLOPT_READDATA 表明CURLOPT_READFUNCTION函数原型中的stream指针来源。</p></li><li><p>CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA <br> 跟数据传输进度相关的参数。CURLOPT_PROGRESSFUNCTION 指定的函数正常情况下每秒被libcurl调用一次，为了使CURLOPT_PROGRESSFUNCTION被调用，CURLOPT_NOPROGRESS必须被设置为false，CURLOPT_PROGRESSDATA指定的参数将作为CURLOPT_PROGRESSFUNCTION指定函数的第一个参数</p></li><li><p>CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT: <br> CURLOPT_TIMEOUT 由于设置传输时间，CURLOPT_CONNECTIONTIMEOUT 设置连接等待时间</p></li><li><p>CURLOPT_FOLLOWLOCATION <br> 设置重定位URL</p></li><li><p>CURLOPT_RANGE: CURLOPT_RESUME_FROM: <br> 断点续传相关设置。CURLOPT_RANGE 指定char *参数传递给libcurl，用于指明http域的RANGE头域，例如： <br> 表示头500个字节：bytes=0-499 <br> 表示第二个500字节：bytes=500-999 <br> 表示最后500个字节：bytes=-500 <br> 表示500字节以后的范围：bytes=500- <br> 第一个和最后一个字节：bytes=0-0,-1 <br> 同时指定几个范围：bytes=500-600,601-999 <br> CURLOPT_RESUME_FROM 传递一个long参数给libcurl，指定你希望开始传递的 偏移量。</p></li></ol> 
<h3 id="四-curleasyperform-函数说明error-状态码">四、 curl_easy_perform 函数说明（error 状态码）</h3> 
<p>该函数是完成curl_easy_setopt指定的所有选项，本节重点介绍curl_easy_perform的返回值。返回0意味一切ok，非0代表错误发生。主要错误码说明： <br> 1. CURLE_OK <br> 任务完成一切都好 <br> 2 CURLE_UNSUPPORTED_PROTOCOL <br> 不支持的协议，由URL的头部指定 <br> 3 CURLE_COULDNT_CONNECT <br> 不能连接到remote 主机或者代理 <br> 4 CURLE_REMOTE_ACCESS_DENIED <br> 访问被拒绝 <br> 5 CURLE_HTTP_RETURNED_ERROR <br> Http返回错误 <br> 6 CURLE_READ_ERROR <br> 读本地文件错误 <br> 要获取详细的错误描述字符串，可以通过const char *curl_easy_strerror(CURLcode errornum ) 这个函数取得.</p> 
<h3 id="五libcurl使用的http消息头">五、libcurl使用的HTTP消息头</h3> 
<pre><code>当使用libcurl发送http请求时，它会自动添加一些http头。我们可以通过CURLOPT_HTTPHEADER属性手动替换、添加或删除相应 的HTTP消息头。
Host
http1.1（大部分http1.0)版本都要求客户端请求提供这个信息头。
Pragma
"no-cache"。表示不要缓冲数据。
Accept
"*/*"。表示允许接收任何类型的数据。
Expect
以POST的方式向HTTP服务器提交请求时，libcurl会设置该消息头为"100-continue"，它要求服务器在正式处理该请求之前，返回一 个"OK"消息。如果POST的数据很小，libcurl可能不会设置该消息头。
</code></pre> 
<p>自定义选项 <br> 当前越来越多的协议都构建在HTTP协议之上（如：soap），这主要归功于HTTP的可靠性，以及被广泛使用的代理支持（可以穿透大部分防火墙）。 这些协议的使用方式与传统HTTP可能有很大的不同。对此，libcurl作了很好的支持。 <br> 自定义请求方式(CustomRequest) <br> HTTP支持GET, HEAD或者POST提交请求。可以设置CURLOPT_CUSTOMREQUEST来设置自定义的请求方式，libcurl默认以GET方式提交请求： <br> curl_easy_setopt(easy_handle, CURLOPT_CUSTOMREQUEST, “MYOWNREQUEST”); </p> 
<p>修改消息头 <br> HTTP协议提供了消息头，请求消息头用于告诉服务器如何处理请求；响应消息头则告诉浏览器如何处理接收到的数据。在libcurl中，你可以自由的添加 这些消息头：</p> 
<p>复制代码 <br> struct curl_slist <em>headers=NULL; /</em> init to NULL is important */ <br> headers = curl_slist_append(headers, “Hey-server-hey: how are you?”); <br> headers = curl_slist_append(headers, “X-silly-content: yes”); <br> /* pass our list of custom made headers */ <br> curl_easy_setopt(easyhandle, CURLOPT_HTTPHEADER, headers); <br> curl_easy_perform(easyhandle); /* transfer http */ <br> curl_slist_free_all(headers); /* free the header list */ <br> 复制代码 <br> 对于已经存在的消息头，可以重新设置它的值：</p> 
<p>headers = curl_slist_append(headers, “Accept: Agent-007”); <br> headers = curl_slist_append(headers, “Host: munged.host.line”); <br> 删除消息头 <br> 对于一个已经存在的消息头，设置它的内容为空，libcurl在发送请求时就不会同时提交该消息头：</p> 
<p>headers = curl_slist_append(headers, “Accept:”);</p> 
<h3 id="六获取http应答头信息">六、获取http应答头信息</h3> 
<pre><code>发出http请求后，服务器会返回应答头信息和应答数据，如果仅仅是打印应答头的所有内容，则直接可以通过curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, 打印函数)的方式来完成，这里需要获取的是应答头中特定的信息，比如应答码、cookies列表等，则需要通过下面这个函数：
CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ... ); 
info参数就是我们需要获取的内容，下面是一些参数值:
1.CURLINFO_RESPONSE_CODE
获取应答码
2.CURLINFO_HEADER_SIZE
头大小
3.CURLINFO_COOKIELIST
cookies列表

除了获取应答信息外，这个函数还能获取curl的一些内部信息，如请求时间、连接时间等等。

更多的参数可以参考API文档。
</code></pre> 
<h3 id="七多线程问题">七、多线程问题</h3> 
<pre><code>首先一个基本原则就是：绝对不应该在线程之间共享同一个libcurl handle(CURL *对象)，不管是easy handle还是multi handle（本文只介绍easy_handle）。一个线程每次只能使用一个handle。
libcurl是线程安全的，但有两点例外：信号(signals)和SSL/TLS handler。 信号用于超时失效名字解析(timing out name resolves)。libcurl依赖其他的库来支持SSL/STL，所以用多线程的方式访问HTTPS或FTPS的URL时，应该满足这些库对多线程 操作的一些要求。详细可以参考：
OpenSSL: http://www.openssl.org/docs/crypto/threads.html#DESCRIPTION

GnuTLS: http://www.gnu.org/software/gnutls/manual/html_node/Multi_002dthreaded-applications.html

NSS: 宣称是多线程安全的。
</code></pre> 
<h3 id="八什么时候libcurl无法正常工作">八、什么时候libcurl无法正常工作</h3> 
<pre><code>传输失败总是有原因的。你可能错误的设置了一些libcurl的属性或者没有正确的理解某些属性的含义，或者是远程主机返回一些无法被正确解析的内容。
这里有一个黄金法则来处理这些问题：将CURLOPT_VERBOSE属性设置为1，libcurl会输出通信过程中的一些细节。如果使用的是http协 议，请求头/响应头也会被输出。将CURLOPT_HEADER设为1，这些头信息将出现在消息的内容中。
当然不可否认的是，libcurl还存在bug。
如果你对相关的协议了解越多，在使用libcurl时，就越不容易犯错。
</code></pre> 
<h3 id="九关于密码">九、关于密码</h3> 
<pre><code>客户端向服务器发送请求时，许多协议都要求提供用户名与密码。libcurl提供了多种方式来设置它们。
一些协议支持在URL中直接指定用户名和密码，类似于： protocol://user:password@example.com/path/。libcurl能正确的识别这种URL中的用户名与密码并执行 相应的操作。如果你提供的用户名和密码中有特殊字符，首先应该对其进行URL编码。
也可以通过CURLOPT_USERPWD属性来设置用户名与密码。参数是格式如 “user:password ”的字符串：
curl_easy_setopt(easy_handle, CURLOPT_USERPWD, "user_name:password"); 
有时候在访问代理服务器的时候，可能时时要求提供用户名和密码进行用户身份验证。这种情况下，libcurl提供了另 一个属性CURLOPT_PROXYUSERPWD：
curl_easy_setopt(easy_handle, CURLOPT_PROXYUSERPWD, "user_name:password"); 
在UNIX平台下，访问FTP的用户名和密码可能会被保存在$HOME/.netrc文件中。libcurl支持直接从这个文件中获取用户名与密码：
curl_easy_setopt(easy_handle, CURLOPT_NETRC, 1L); 
在使用SSL时，可能需要提供一个私钥用于数据安全传输，通过CURLOPT_KEYPASSWD来设置私钥：
curl_easy_setopt(easy_handle, CURLOPT_KEYPASSWD, "keypassword");
</code></pre> 
<h3 id="十http验证">十、HTTP验证</h3> 
<pre><code>在使用HTTP协议时，客户端有很多种方式向服务器提供验证信息。默认的 HTTP验证方法是"Basic”，它将用户名与密码以明文的方式、经Base64编码后保存在HTTP请求头中，发往服务器。当然这不太安全。
当前版本的libcurl支持的验证方法有：basic, Digest, NTLM, Negotiate, GSS-Negotiate and SPNEGO。（译者感叹：搞Web这么多年，尽然不知道这些Http的验证方式，实在惭愧。）可以通过CURLOPT_HTTPAUTH属性来设置具体 的验证方式：
curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);
向代理服务器发送验证信息时，可以通过CURLOPT_PROXYAUTH设置验证方式：
curl_easy_setopt(easy_handle, CURLOPT_PROXYAUTH, CURLAUTH_NTLM);
也可以同时设置多种验证方式（通过按位与）， 使用‘CURLAUTH_ANY‘将允许libcurl可以选择任何它所支持的验证方式。通过CURLOPT_HTTPAUTH或 CURLOPT_PROXYAUTH属性设置的多种验证方式，libcurl会在运行时选择一种它认为是最好的方式与服务器通信：
curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST|CURLAUTH_BASIC); 
// curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);
</code></pre> 
<p>下面记录一下实现代码 <br> 1.基本的http GET/POST操作</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;curl/curl.h&gt;</span>
<span class="hljs-keyword">bool</span> getUrl(<span class="hljs-keyword">char</span> *filename)
{
    CURL *curl;
    CURLcode res;
    FILE *fp;
    <span class="hljs-keyword">if</span> ((fp = fopen(filename, <span class="hljs-string">"w"</span>)) == <span class="hljs-literal">NULL</span>)  <span class="hljs-comment">// 返回结果用文件存储</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">struct</span> curl_slist *headers = <span class="hljs-literal">NULL</span>;
    headers = curl_slist_append(headers, <span class="hljs-string">"Accept: Agent-007"</span>);
    curl = curl_easy_init();    <span class="hljs-comment">// 初始化</span>
    <span class="hljs-keyword">if</span> (curl)
    {
        <span class="hljs-comment">//curl_easy_setopt(curl, CURLOPT_PROXY, "10.99.60.201:8080");// 代理</span>
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);<span class="hljs-comment">// 改协议头</span>
        curl_easy_setopt(curl, CURLOPT_URL,<span class="hljs-string">"http://www.baidu.com"</span>);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp); <span class="hljs-comment">//将返回的http头输出到fp指向的文件</span>
        curl_easy_setopt(curl, CURLOPT_HEADERDATA, fp); <span class="hljs-comment">//将返回的html主体数据输出到fp指向的文件</span>
        res = curl_easy_perform(curl);   <span class="hljs-comment">// 执行</span>
        <span class="hljs-keyword">if</span> (res != <span class="hljs-number">0</span>) {

            curl_slist_free_all(headers);
            curl_easy_cleanup(curl);
        }
        fclose(fp);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
<span class="hljs-keyword">bool</span> postUrl(<span class="hljs-keyword">char</span> *filename)
{
    CURL *curl;
    CURLcode res;
    FILE *fp;
    <span class="hljs-keyword">if</span> ((fp = fopen(filename, <span class="hljs-string">"w"</span>)) == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    curl = curl_easy_init();
    <span class="hljs-keyword">if</span> (curl)
    {
        curl_easy_setopt(curl, CURLOPT_COOKIEFILE, <span class="hljs-string">"/tmp/cookie.txt"</span>); <span class="hljs-comment">// 指定cookie文件</span>
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, <span class="hljs-string">"&amp;logintype=uid&amp;u=xieyan&amp;psw=xxx86"</span>);    <span class="hljs-comment">// 指定post内容</span>
        <span class="hljs-comment">//curl_easy_setopt(curl, CURLOPT_PROXY, "10.99.60.201:8080");</span>
        curl_easy_setopt(curl, CURLOPT_URL, <span class="hljs-string">" http://mail.sina.com.cn/cgi-bin/login.cgi "</span>);   <span class="hljs-comment">// 指定url</span>
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
        res = curl_easy_perform(curl);
        curl_easy_cleanup(curl);
    }
    fclose(fp);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">void</span>)
{
    getUrl(<span class="hljs-string">"/tmp/get.html"</span>);
    postUrl(<span class="hljs-string">"/tmp/post.html"</span>);
}</code></pre> 
<p>2 获取html网页</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;curl/curl.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])
{
    CURL *curl;             <span class="hljs-comment">//定义CURL类型的指针</span>
CURLcode res;           <span class="hljs-comment">//定义CURLcode类型的变量，保存返回状态码</span>
    <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">2</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage : file &lt;url&gt;;\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    curl = curl_easy_init();        <span class="hljs-comment">//初始化一个CURL类型的指针</span>
    <span class="hljs-keyword">if</span>(curl!=NULL)
    {
        <span class="hljs-comment">//设置curl选项. 其中CURLOPT_URL是让用户指 定url. argv[1]中存放的命令行传进来的网址</span>
        curl_easy_setopt(curl, CURLOPT_URL, argv[<span class="hljs-number">1</span>]);        
        <span class="hljs-comment">//调用curl_easy_perform 执行我们的设置.并进行相关的操作. 在这 里只在屏幕上显示出来.</span>
        res = curl_easy_perform(curl);
        <span class="hljs-comment">//清除curl操作.</span>
        curl_easy_cleanup(curl);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>3 网页下载保存实例</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">// 采用CURLOPT_WRITEFUNCTION 实现网页下载保存功能</span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt;;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;;</span>
<span class="hljs-preprocessor">#include &lt;unistd.h&gt;;</span>

<span class="hljs-preprocessor">#include &lt;curl/curl.h&gt;;</span>
<span class="hljs-preprocessor">#include &lt;curl/types.h&gt;;</span>
<span class="hljs-preprocessor">#include &lt;curl/easy.h&gt;;</span>

FILE *fp;  <span class="hljs-comment">//定义FILE类型指针</span>
<span class="hljs-comment">//这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的</span>
<span class="hljs-comment">//完成数据保存功能</span>
size_t write_data(<span class="hljs-keyword">void</span> *ptr, size_t size, size_t nmemb, <span class="hljs-keyword">void</span> *stream)  
{
    <span class="hljs-keyword">int</span> written = fwrite(ptr, size, nmemb, (FILE *)fp);
    <span class="hljs-keyword">return</span> written;
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])
{
    CURL *curl;

    curl_global_init(CURL_GLOBAL_ALL);  
    curl=curl_easy_init();
    curl_easy_setopt(curl, CURLOPT_URL, argv[<span class="hljs-number">1</span>]);  

    <span class="hljs-keyword">if</span>((fp=fopen(argv[<span class="hljs-number">2</span>],<span class="hljs-string">"w"</span>))==NULL)
    {
        curl_easy_cleanup(curl);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }
<span class="hljs-comment">CURLOPT_WRITEFUNCTION 将后继的动作交给write_data函数处理</span>
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);  
    curl_easy_perform(curl);
    curl_easy_cleanup(curl);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
}</code></pre> 
<p>4 进度条实例显示文件下载进度</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">// 采用CURLOPT_NOPROGRESS， CURLOPT_PROGRESSFUNCTION    CURLOPT_PROGRESSDATA 实现文件传输进度提示功能</span>
<span class="hljs-comment">//函数采用了gtk库，故编译时需指定gtk库</span>
<span class="hljs-comment">//函数启动专门的线程用于显示gtk 进度条bar</span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;gtk/gtk.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;curl/curl.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;curl/types.h&gt; /* new for v7 */</span>
<span class="hljs-preprocessor">#include &lt;curl/easy.h&gt; /* new for v7 */</span>

GtkWidget *Bar;
<span class="hljs-comment">这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的</span>
<span class="hljs-comment">//完成数据保存功能</span>
size_t my_write_func(<span class="hljs-keyword">void</span> *ptr, size_t size, size_t nmemb, FILE *stream)
{
  <span class="hljs-keyword">return</span> fwrite(ptr, size, nmemb, stream);
}
<span class="hljs-comment">//这个函数是为了符合CURLOPT_READFUNCTION而构造的</span>
<span class="hljs-comment">//数据上传时使用</span>
size_t my_read_func(<span class="hljs-keyword">void</span> *ptr, size_t size, size_t nmemb, FILE *stream)
{
  <span class="hljs-keyword">return</span> fread(ptr, size, nmemb, stream);
}
<span class="hljs-comment">//这个函数是为了符合CURLOPT_PROGRESSFUNCTION而构造的</span>
<span class="hljs-comment">//显示文件传输进度，t代表文件大小，d代表传 输已经完成部分</span>
<span class="hljs-keyword">int</span> my_progress_func(GtkWidget *bar,
                     <span class="hljs-keyword">double</span> t, <span class="hljs-comment">/* dltotal */</span>
                     <span class="hljs-keyword">double</span> d, <span class="hljs-comment">/* dlnow */</span>
                     <span class="hljs-keyword">double</span> ultotal,
                     <span class="hljs-keyword">double</span> ulnow)
{
<span class="hljs-comment">/*  printf("%d / %d (%g %%)\n", d, t, d*100.0/t);*/</span>
  gdk_threads_enter();
  gtk_progress_set_value(GTK_PROGRESS(bar), d*<span class="hljs-number">100.0</span>/t);
  gdk_threads_leave();
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">void</span> *my_thread(<span class="hljs-keyword">void</span> *ptr)
{
  CURL *curl;
  CURLcode res;
  FILE *outfile;
  gchar *url = ptr;

  curl = curl_easy_init();
  <span class="hljs-keyword">if</span>(curl)
  {
    outfile = fopen(<span class="hljs-string">"test.curl"</span>, <span class="hljs-string">"w"</span>);

    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, outfile);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_write_func);
    curl_easy_setopt(curl, CURLOPT_READFUNCTION, my_read_func);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, <span class="hljs-number">0</span>L);
    curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, my_progress_func);
    curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, Bar);

    res = curl_easy_perform(curl);

    fclose(outfile);
    <span class="hljs-comment">/* always cleanup */</span>
    curl_easy_cleanup(curl);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)
{
  GtkWidget *Window, *Frame, *Frame2;
  GtkAdjustment *adj;

  <span class="hljs-comment">/* Must initialize libcurl before any threads are started */</span>
  curl_global_init(CURL_GLOBAL_ALL);

  <span class="hljs-comment">/* Init thread */</span>
  g_thread_init(<span class="hljs-literal">NULL</span>);

  gtk_init(&amp;argc, &amp;argv);
  Window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  Frame = gtk_frame_new(<span class="hljs-literal">NULL</span>);
  gtk_frame_set_shadow_type(GTK_FRAME(Frame), GTK_SHADOW_OUT);
  gtk_container_add(GTK_CONTAINER(Window), Frame);
  Frame2 = gtk_frame_new(<span class="hljs-literal">NULL</span>);
  gtk_frame_set_shadow_type(GTK_FRAME(Frame2), GTK_SHADOW_IN);
  gtk_container_add(GTK_CONTAINER(Frame), Frame2);
  gtk_container_set_border_width(GTK_CONTAINER(Frame2), <span class="hljs-number">5</span>);
  adj = (GtkAdjustment*)gtk_adjustment_new(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  Bar = gtk_progress_bar_new_with_adjustment(adj);
  gtk_container_add(GTK_CONTAINER(Frame2), Bar);
  gtk_widget_show_all(Window);

  <span class="hljs-keyword">if</span> (!g_thread_create(&amp;my_thread, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">FALSE</span>, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>)
    g_warning(<span class="hljs-string">"can't create the thread"</span>);


  gdk_threads_enter();
  gtk_main();
  gdk_threads_leave();
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>5 断点续传实例</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//采用CURLOPT_RESUME_FROM_LARGE 实现文件断点续传功能</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/stat.h&gt;</span>

<span class="hljs-preprocessor">#include &lt;curl/curl.h&gt;</span>
<span class="hljs-comment">//这个函数为CURLOPT_HEADERFUNCTION参数构造</span>
<span class="hljs-comment">/* 从http头部获取文件size*/</span>
size_t getcontentlengthfunc(<span class="hljs-keyword">void</span> *ptr, size_t size, size_t nmemb, <span class="hljs-keyword">void</span> *stream) {
       <span class="hljs-keyword">int</span> r;
       <span class="hljs-keyword">long</span> len = <span class="hljs-number">0</span>;

       <span class="hljs-comment">/* _snscanf() is Win32 specific */</span>
       <span class="hljs-comment">// r = _snscanf(ptr, size * nmemb, "Content-Length: %ld\n", &amp;len);</span>
 r = <span class="hljs-built_in">sscanf</span>(ptr, <span class="hljs-string">"Content-Length: %ld\n"</span>, &amp;len);
       <span class="hljs-keyword">if</span> (r) <span class="hljs-comment">/* Microsoft: we don't read the specs */</span>
              *((<span class="hljs-keyword">long</span> *) stream) = len;

       <span class="hljs-keyword">return</span> size * nmemb;
}

<span class="hljs-comment">/* 保存下载文件 */</span>
size_t wirtefunc(<span class="hljs-keyword">void</span> *ptr, size_t size, size_t nmemb, <span class="hljs-keyword">void</span> *stream)
{
        <span class="hljs-keyword">return</span> fwrite(ptr, size, nmemb, stream);
}

<span class="hljs-comment">/*读取上传文件 */</span>
size_t readfunc(<span class="hljs-keyword">void</span> *ptr, size_t size, size_t nmemb, <span class="hljs-keyword">void</span> *stream)
{
       FILE *f = stream;
       size_t n;

       <span class="hljs-keyword">if</span> (ferror(f))
              <span class="hljs-keyword">return</span> CURL_READFUNC_ABORT;

       n = fread(ptr, size, nmemb, f) * size;

       <span class="hljs-keyword">return</span> n;
}

<span class="hljs-comment">// 下载 或者上传文件函数</span>
<span class="hljs-keyword">int</span> download(CURL *curlhandle, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * remotepath, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * localpath,
           <span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">long</span> tries)
{
       FILE *f;
       curl_off_t local_file_len = -<span class="hljs-number">1</span> ;
       <span class="hljs-keyword">long</span> filesize =<span class="hljs-number">0</span> ;

       CURLcode r = CURLE_GOT_NOTHING;
       <span class="hljs-keyword">int</span> c;
  <span class="hljs-keyword">struct</span> stat file_info;
  <span class="hljs-keyword">int</span> use_resume = <span class="hljs-number">0</span>;
  <span class="hljs-comment">/* 得到本地文件大小 */</span>
  <span class="hljs-comment">//if(access(localpath,F_OK) ==0)</span>

    <span class="hljs-keyword">if</span>(stat(localpath, &amp;file_info) == <span class="hljs-number">0</span>) 
     {
        local_file_len =  file_info.st_size;
        use_resume  = <span class="hljs-number">1</span>;
      }
  <span class="hljs-comment">//采用追加方式打开文件，便于实现文件断点续传工作</span>
       f = fopen(localpath, <span class="hljs-string">"ab+"</span>); 
       <span class="hljs-keyword">if</span> (f == NULL) {
              perror(NULL);
              <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
       }

       <span class="hljs-comment">//curl_easy_setopt(curlhandle, CURLOPT_UPLOAD, 1L);</span>

       curl_easy_setopt(curlhandle, CURLOPT_URL, remotepath);

              curl_easy_setopt(curlhandle, CURLOPT_CONNECTTIMEOUT, timeout);  <span class="hljs-comment">// 设置连接超时，单位秒</span>
       <span class="hljs-comment">//设置http 头部处理函数</span>
       curl_easy_setopt(curlhandle, CURLOPT_HEADERFUNCTION, getcontentlengthfunc);
       curl_easy_setopt(curlhandle, CURLOPT_HEADERDATA, &amp;filesize);
 <span class="hljs-comment">// 设置文件续传的位置给libcurl</span>
       curl_easy_setopt(curlhandle, CURLOPT_RESUME_FROM_LARGE, use_resume?local_file_len:<span class="hljs-number">0</span>);

       curl_easy_setopt(curlhandle, CURLOPT_WRITEDATA, f);
       curl_easy_setopt(curlhandle, CURLOPT_WRITEFUNCTION, wirtefunc);

       <span class="hljs-comment">//curl_easy_setopt(curlhandle, CURLOPT_READFUNCTION, readfunc);</span>
       <span class="hljs-comment">//curl_easy_setopt(curlhandle, CURLOPT_READDATA, f);</span>
       curl_easy_setopt(curlhandle, CURLOPT_NOPROGRESS, <span class="hljs-number">1L</span>);
       curl_easy_setopt(curlhandle, CURLOPT_VERBOSE, <span class="hljs-number">1L</span>);


  r = curl_easy_perform(curlhandle);


       fclose(f);

       <span class="hljs-keyword">if</span> (r == CURLE_OK)
              <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
       <span class="hljs-keyword">else</span> {
              <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"%s\n"</span>, curl_easy_strerror(r));
              <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
       }
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">char</span> **argv) {
       CURL *curlhandle = NULL;

       curl_global_init(CURL_GLOBAL_ALL);
       curlhandle = curl_easy_init();

       <span class="hljs-comment">//download(curlhandle, "ftp://user:pass@host/path/file", "C:\\file", 0, 3);</span>
  download(curlhandle , <span class="hljs-string">"http://software.sky-union.cn/index.asp"</span>,<span class="hljs-string">"/work/index.asp"</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);
       curl_easy_cleanup(curlhandle);
       curl_global_cleanup();

       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h3 id="十一multi接口的使用">十一、multi接口的使用</h3> 
<p>easy接口的使用非常的简单，curl_easy_init用来初始化一个easy curl对象，curl_easy_setopt对easy curl对象进行相关设置，最后curl_easy_perform执行curl请求，返回相应结果。easy接口是阻塞的，也就是说必须等到上一个curl请求执行完后，下一个curl请求才能继续执行，在一般的应用场合，这种阻塞的访问方式是没有问题的，但是当程序需要进行多次curl并发请求的时候，easy接口就无能为力了，这个时候curl提供的multi接口就派上用场了，网上关于libcurl的multi接口的使用资料比较少（百度出来的大部分都是PHP multi curl的资料），curl官网上貌似也只有相关函数的说明，有实际demo才能让我们更快速的上手使用，所以下面结合实际例子来讲讲multi curl接口的使用方法。</p> 
<pre><code>相比而言，multi接口的使用会比easy 接口稍微复杂点，毕竟multi接口是依赖easy接口的，首先粗略的讲下其使用流程：curl_multi _init初始化一个multi curl对象，为了同时进行多个curl的并发访问，我们需要初始化多个easy curl对象，使用curl_easy_setopt进行相关设置，然后调用curl_multi _add_handle把easy curl对象添加到multi curl对象中，添加完毕后执行curl_multi_perform方法进行并发的访问，访问结束后curl_multi_remove_handle移除相关easy curl对象，curl_easy_cleanup清除easy curl对象，最后curl_multi_cleanup清除multi curl对象。

上面的介绍只是给大家一个大概的印象，实际使用中还有很多细节需要注意，好了，代码才能说明一切，下面的例子使用multi curl方式进行多次http并发访问，并输出访问结果。
</code></pre> 
<pre class="prettyprint"><code class=" hljs java">#include &lt;string&gt;   
#include &lt;iostream&gt;   

#include &lt;curl/curl.h&gt;   
#include &lt;sys/time.h&gt;   
#include &lt;unistd.h&gt;   

using namespace std;  

size_t curl_writer(<span class="hljs-keyword">void</span> *buffer, size_t size, size_t count, <span class="hljs-keyword">void</span> * stream)  
{  
    std::string * pStream = static_cast&lt;std::string *&gt;(stream);  
    (*pStream).append((<span class="hljs-keyword">char</span> *)buffer, size * count);  

    <span class="hljs-keyword">return</span> size * count;  
};  

<span class="hljs-javadoc">/** 
 * 生成一个easy curl对象，进行一些简单的设置操作 
 */</span>  
CURL * curl_easy_handler(<span class="hljs-keyword">const</span> std::string &amp; sUrl,  
                         <span class="hljs-keyword">const</span> std::string &amp; sProxy,  
                         std::string &amp; sRsp,  
                         unsigned <span class="hljs-keyword">int</span> uiTimeout)  
{  
    CURL * curl = curl_easy_init();  

    curl_easy_setopt(curl, CURLOPT_URL, sUrl.c_str());  
    curl_easy_setopt(curl, CURLOPT_NOSIGNAL, <span class="hljs-number">1</span>);  

    <span class="hljs-keyword">if</span> (uiTimeout &gt; <span class="hljs-number">0</span>)  
    {  
        curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, uiTimeout);  
    }  
    <span class="hljs-keyword">if</span> (!sProxy.empty())  
    {  
        curl_easy_setopt(curl, CURLOPT_PROXY, sProxy.c_str());  
    }  

    <span class="hljs-comment">// write function //   </span>
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_writer);  
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;sRsp);  

    <span class="hljs-keyword">return</span> curl;  
}  

<span class="hljs-javadoc">/** 
 * 使用select函数监听multi curl文件描述符的状态 
 * 监听成功返回0，监听失败返回-1 
 */</span>  
<span class="hljs-keyword">int</span> curl_multi_select(CURLM * curl_m)  
{  
    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;  

    struct timeval timeout_tv;  
    fd_set  fd_read;  
    fd_set  fd_write;  
    fd_set  fd_except;  
    <span class="hljs-keyword">int</span>     max_fd = -<span class="hljs-number">1</span>;  

    <span class="hljs-comment">// 注意这里一定要清空fdset,curl_multi_fdset不会执行fdset的清空操作  //   </span>
    FD_ZERO(&amp;fd_read);  
    FD_ZERO(&amp;fd_write);  
    FD_ZERO(&amp;fd_except);  

    <span class="hljs-comment">// 设置select超时时间  //   </span>
    timeout_tv.tv_sec = <span class="hljs-number">1</span>;  
    timeout_tv.tv_usec = <span class="hljs-number">0</span>;  

    <span class="hljs-comment">// 获取multi curl需要监听的文件描述符集合 fd_set //   </span>
    curl_multi_fdset(curl_m, &amp;fd_read, &amp;fd_write, &amp;fd_except, &amp;max_fd);  

    <span class="hljs-javadoc">/** 
     * When max_fd returns with -1, 
     * you need to wait a while and then proceed and call curl_multi_perform anyway. 
     * How long to wait? I would suggest 100 milliseconds at least, 
     * but you may want to test it out in your own particular conditions to find a suitable value. 
     */</span>  
    <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == max_fd)  
    {  
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  
    }  

    <span class="hljs-javadoc">/** 
     * 执行监听，当文件描述符状态发生改变的时候返回 
     * 返回0，程序调用curl_multi_perform通知curl执行相应操作 
     * 返回-1，表示select错误 
     * 注意：即使select超时也需要返回0，具体可以去官网看文档说明 
     */</span>  
    <span class="hljs-keyword">int</span> ret_code = ::select(max_fd + <span class="hljs-number">1</span>, &amp;fd_read, &amp;fd_write, &amp;fd_except, &amp;timeout_tv);  
    <span class="hljs-keyword">switch</span>(ret_code)  
    {  
    <span class="hljs-keyword">case</span> -<span class="hljs-number">1</span>:  
        <span class="hljs-comment">/* select error */</span>  
        ret = -<span class="hljs-number">1</span>;  
        <span class="hljs-keyword">break</span>;  
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  
        <span class="hljs-comment">/* select timeout */</span>  
    <span class="hljs-keyword">default</span>:  
        <span class="hljs-comment">/* one or more of curl's file descriptors say there's data to read or write*/</span>  
        ret = <span class="hljs-number">0</span>;  
        <span class="hljs-keyword">break</span>;  
    }  

    <span class="hljs-keyword">return</span> ret;  
}  

#define MULTI_CURL_NUM <span class="hljs-number">3</span>   

<span class="hljs-comment">// 这里设置你需要访问的url //   </span>
std::string     URL     = <span class="hljs-string">"http://website.com"</span>;  
<span class="hljs-comment">// 这里设置代理ip和端口  //   </span>
std::string     PROXY   = <span class="hljs-string">"ip:port"</span>;  
<span class="hljs-comment">// 这里设置超时时间  //   </span>
unsigned <span class="hljs-keyword">int</span>    TIMEOUT = <span class="hljs-number">2000</span>; <span class="hljs-comment">/* ms */</span>  

<span class="hljs-javadoc">/** 
 * multi curl使用demo 
 */</span>  
<span class="hljs-keyword">int</span> curl_multi_demo(<span class="hljs-keyword">int</span> num)  
{  
    <span class="hljs-comment">// 初始化一个multi curl 对象 //   </span>
    CURLM * curl_m = curl_multi_init();  

    std::string     RspArray[num];  
    CURL *          CurlArray[num];  

    <span class="hljs-comment">// 设置easy curl对象并添加到multi curl对象中  //   </span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; idx &lt; num; ++idx)  
    {  
        CurlArray[idx] = NULL;  
        CurlArray[idx] = curl_easy_handler(URL, PROXY, RspArray[idx], TIMEOUT);  
        <span class="hljs-keyword">if</span> (CurlArray[idx] == NULL)  
        {  
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  
        }  
        curl_multi_add_handle(curl_m, CurlArray[idx]);  
    }  

    <span class="hljs-comment">/* 
     * 调用curl_multi_perform函数执行curl请求 
     * url_multi_perform返回CURLM_CALL_MULTI_PERFORM时，表示需要继续调用该函数直到返回值不是CURLM_CALL_MULTI_PERFORM为止 
     * running_handles变量返回正在处理的easy curl数量，running_handles为0表示当前没有正在执行的curl请求 
     */</span>  
    <span class="hljs-keyword">int</span> running_handles;  
    <span class="hljs-keyword">while</span> (CURLM_CALL_MULTI_PERFORM == curl_multi_perform(curl_m, &amp;running_handles))  
    {  
        cout &lt;&lt; running_handles &lt;&lt; endl;  
    }  

    <span class="hljs-javadoc">/** 
     * 为了避免循环调用curl_multi_perform产生的cpu持续占用的问题，采用select来监听文件描述符 
     */</span>  
    <span class="hljs-keyword">while</span> (running_handles)  
    {  
        <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == curl_multi_select(curl_m))  
        {  
            cerr &lt;&lt; <span class="hljs-string">"select error"</span> &lt;&lt; endl;  
            <span class="hljs-keyword">break</span>;  
        } <span class="hljs-keyword">else</span> {  
            <span class="hljs-comment">// select监听到事件，调用curl_multi_perform通知curl执行相应的操作 //   </span>
            <span class="hljs-keyword">while</span> (CURLM_CALL_MULTI_PERFORM == curl_multi_perform(curl_m, &amp;running_handles))  
            {  
                cout &lt;&lt; <span class="hljs-string">"select: "</span> &lt;&lt; running_handles &lt;&lt; endl;  
            }  
        }  
        cout &lt;&lt; <span class="hljs-string">"select: "</span> &lt;&lt; running_handles &lt;&lt; endl;  
    }  

    <span class="hljs-comment">// 输出执行结果 //   </span>
    <span class="hljs-keyword">int</span>         msgs_left;  
    CURLMsg *   msg;  
    <span class="hljs-keyword">while</span>((msg = curl_multi_info_read(curl_m, &amp;msgs_left)))  
    {  
        <span class="hljs-keyword">if</span> (CURLMSG_DONE == msg-&gt;msg)  
        {  
            <span class="hljs-keyword">int</span> idx;  
            <span class="hljs-keyword">for</span> (idx = <span class="hljs-number">0</span>; idx &lt; num; ++idx)  
            {  
                <span class="hljs-keyword">if</span> (msg-&gt;easy_handle == CurlArray[idx]) <span class="hljs-keyword">break</span>;  
            }  

            <span class="hljs-keyword">if</span> (idx == num)  
            {  
                cerr &lt;&lt; <span class="hljs-string">"curl not found"</span> &lt;&lt; endl;  
            } <span class="hljs-keyword">else</span>  
            {  
                cout &lt;&lt; <span class="hljs-string">"curl ["</span> &lt;&lt; idx &lt;&lt; <span class="hljs-string">"] completed with status: "</span>  
                        &lt;&lt; msg-&gt;data.result &lt;&lt; endl;  
                cout &lt;&lt; <span class="hljs-string">"rsp: "</span> &lt;&lt; RspArray[idx] &lt;&lt; endl;  
            }  
        }  
    }  

    <span class="hljs-comment">// 这里要注意cleanup的顺序 //   </span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; idx &lt; num; ++idx)  
    {  
        curl_multi_remove_handle(curl_m, CurlArray[idx]);  
    }  

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; idx &lt; num; ++idx)  
    {  
        curl_easy_cleanup(CurlArray[idx]);  
    }  

    curl_multi_cleanup(curl_m);  

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}  

<span class="hljs-javadoc">/** 
 * easy curl使用demo 
 */</span>  
<span class="hljs-keyword">int</span> curl_easy_demo(<span class="hljs-keyword">int</span> num)  
{  
    std::string     RspArray[num];  

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; idx &lt; num; ++idx)  
    {  
        CURL * curl = curl_easy_handler(URL, PROXY, RspArray[idx], TIMEOUT);  
        CURLcode code = curl_easy_perform(curl);  
        cout &lt;&lt; <span class="hljs-string">"curl ["</span> &lt;&lt; idx &lt;&lt; <span class="hljs-string">"] completed with status: "</span>  
                &lt;&lt; code &lt;&lt; endl;  
        cout &lt;&lt; <span class="hljs-string">"rsp: "</span> &lt;&lt; RspArray[idx] &lt;&lt; endl;  

        <span class="hljs-comment">// clear handle //   </span>
        curl_easy_cleanup(curl);  
    }  

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}  

#define USE_MULTI_CURL   

struct timeval begin_tv, end_tv;  

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * argv[])  
{  
    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)  
    {  
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  
    }  
    <span class="hljs-keyword">int</span> num = atoi(argv[<span class="hljs-number">1</span>]);  

    <span class="hljs-comment">// 获取开始时间 //   </span>
    gettimeofday(&amp;begin_tv, NULL);  
#ifdef USE_MULTI_CURL   
    <span class="hljs-comment">// 使用multi接口进行访问 //   </span>
    curl_multi_demo(num);  
#<span class="hljs-keyword">else</span>   
    <span class="hljs-comment">// 使用easy接口进行访问 //   </span>
    curl_easy_demo(num);  
#endif   
    <span class="hljs-comment">// 获取结束时间  //   </span>
    struct timeval end_tv;  
    gettimeofday(&amp;end_tv, NULL);  

    <span class="hljs-comment">// 计算执行延时并输出，用于比较  //   </span>
    <span class="hljs-keyword">int</span> eclapsed = (end_tv.tv_sec - begin_tv.tv_sec) * <span class="hljs-number">1000</span> +  
                   (end_tv.tv_usec - begin_tv.tv_usec) / <span class="hljs-number">1000</span>;  

    cout &lt;&lt; <span class="hljs-string">"eclapsed time:"</span> &lt;&lt; eclapsed &lt;&lt; <span class="hljs-string">"ms"</span> &lt;&lt; endl;  

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e04920a6cb3cb2428cd46cef08898e76/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DB2如何查看表空间是否为‘自动存储管理’（Automatic Storage）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ffbb7547a824d3af246b3e988d8e692c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQl语句之   BETWEEN 用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>