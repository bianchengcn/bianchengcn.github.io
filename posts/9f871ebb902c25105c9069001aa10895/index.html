<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>libssh2编译lib/dll与使用的步骤 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="libssh2编译lib/dll与使用的步骤" />
<meta property="og:description" content="1:下载源码：libssh2https://www.libssh2.org/
2.OpenSSL安装
编译libssh2需要安装OpenSSL，这里自己编译库比较复杂，直接安装带库的包比较方便：
直接从 Win32/Win64 OpenSSL Installer for Windows - Shining Light Productions 下载
注意，不要下载 light 版本，因为 light 版本不带库文件。
这里仅仅是使用安装目录的库文件。
3.在根目录创建编译目录
mkdir build cd build cmake .. 如果环境正确：
-- Configuring done -- Generating done -- Build files have been written to: E:/libssh2-libssh2-1.10.0/build 执行：
cmake --build . 将会在E:\libssh2-libssh2-1.10.0\build\example\Debug中编译出各个例子的exe文件。
同样在E:\libssh2-libssh2-1.10.0\build\src\Debug中会生成libssh2.lib文件。
4.编译dll
双击E:\libssh2-libssh2-1.10.0\build\example的ALL_Build.vcxproj（任何一个都行）
打开VS：
这里我将Debug模式改为了release,重新生成libssh2目录：
在E:\libssh2-libssh2-1.10.0\build\src\Release便生成新的release的lib.
修改libssh2文件夹下的CmakeLists.txt文件：
将
add_library(libssh2 ${SOURCES}) 改为：
add_library(libssh2 SHARED ${SOURCES}) 重新编译： 目录: E:\libssh2-libssh2-1.10.0\build\src\Release Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2021/9/26 10:29 226304 libssh2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/9f871ebb902c25105c9069001aa10895/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-26T15:01:39+08:00" />
<meta property="article:modified_time" content="2021-09-26T15:01:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">libssh2编译lib/dll与使用的步骤</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;">1:下载源码：<a class="has-card" href="https://www.libssh2.org/" rel="nofollow" title="libssh2"><span class="link-card-box"><span class="link-title">libssh2</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/62/43/XJswj2f8_o.png">https://www.libssh2.org/</span></span></a></p> 
<p> <img alt="" height="256" src="https://images2.imgbox.com/58/83/JPEfGH1F_o.png" width="434"></p> 
<p></p> 
<p> 2.OpenSSL安装</p> 
<p style="margin-left:.0001pt;text-align:justify;">编译libssh2需要安装OpenSSL，这里自己编译库比较复杂，直接安装带库的包比较方便：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">直接从 </span></span><a href="http://slproweb.com/products/Win32OpenSSL.html" rel="nofollow" title="Win32/Win64 OpenSSL Installer for Windows - Shining Light Productions">Win32/Win64 OpenSSL Installer for Windows - Shining Light Productions</a><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"> 下载</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">注意，不要下载 light 版本，因为 light 版本不带</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">库文件。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">这里仅仅是使用安装目录的库文件。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">3.在根目录创建编译目录</span></span></p> 
<pre><code>mkdir build
cd build
cmake ..</code></pre> 
<p>如果环境正确：</p> 
<pre><code>-- Configuring done
-- Generating done
-- Build files have been written to: E:/libssh2-libssh2-1.10.0/build</code></pre> 
<p>执行：</p> 
<pre><code>cmake --build .</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">将会在E:\libssh2-libssh2-1.10.0\build\example\Debug中编译出各个例子的exe文件。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">同样在E:\libssh2-libssh2-1.10.0\build\src\Debug中会生成libssh2.lib文件。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">4.<span style="background-color:#ffffff;"><span style="color:#4d4d4d;">编译dll</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">双击E:\libssh2-libssh2-1.10.0\build\example的ALL_Build.vcxproj（任何一个都行）</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">打开VS：</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="214" src="https://images2.imgbox.com/a3/83/pnB1D7aW_o.png" width="429"></p> 
<p style="margin-left:.0001pt;text-align:justify;">这里我将Debug模式改为了release,重新生成libssh2目录：</p> 
<p style="margin-left:.0001pt;text-align:justify;">在E:\libssh2-libssh2-1.10.0\build\src\Release便生成新的release的lib.</p> 
<p style="margin-left:.0001pt;text-align:justify;">修改libssh2文件夹下的CmakeLists.txt文件：</p> 
<p style="margin-left:.0001pt;text-align:justify;">将</p> 
<pre><code>add_library(libssh2 ${SOURCES})</code></pre> 
<p> 改为：</p> 
<pre><code>add_library(libssh2 SHARED ${SOURCES})</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">重新编译： </span></p> 
<pre><code>   目录: E:\libssh2-libssh2-1.10.0\build\src\Release

Mode                 LastWriteTime         Length Name

----                 -------------         ------ ----

-a----         2021/9/26     10:29         226304 libssh2.dll

-a----         2021/9/26     10:29          19538 libssh2.exp

-a----         2021/9/26     10:29          32788 libssh2.lib</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">这样就可以正常使用dll.</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">但是如果想要二次封装为自己的dll的话，就需要还原原来的add_library(libssh2 ${SOURCES})，来使用libssh2.lib进行使用。</p> 
<h3 style="margin-left:.0001pt;text-align:justify;">二次封装</h3> 
<p style="margin-left:.0001pt;text-align:justify;">这里想要将libssh2的功能二次封装为dll，提供简洁的调用。</p> 
<p style="margin-left:.0001pt;text-align:justify;">为了减少工作量：</p> 
<p style="margin-left:.0001pt;text-align:justify;">随便选取一个例子，如example-ssh2_exec,将包含的CMakeLists.txt的：</p> 
<pre><code>add_executable(example-${example} ${example}.c)</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#008000;">改为：</span></p> 
<pre><code>add_library(example-${example} SHARED ${example}.c)</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">然后修改其中的Source File文件ssh2_exec.c:</span></p> 
<pre><code class="language-cpp">#include "libssh2_config.h"
#include "libssh2.h"
#include "libssh2_sftp.h"

#ifdef HAVE_WINSOCK2_H
# include &lt;winsock2.h&gt;
#endif
#ifdef HAVE_SYS_SOCKET_H
# include &lt;sys/socket.h&gt;
#endif
#ifdef HAVE_NETINET_IN_H
# include &lt;netinet/in.h&gt;
#endif
# ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#endif
#ifdef HAVE_ARPA_INET_H
# include &lt;arpa/inet.h&gt;
#endif
#ifdef HAVE_SYS_TIME_H
# include &lt;sys/time.h&gt;
#endif

#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

const char* username = "username";
const char* password = "password";
unsigned long hostaddr = 0;//inet_addr("192.168.3.1"); init in anyfunction

unsigned long getIP() {
    if (!hostaddr)
    {
        return inet_addr("192.168.3.1");
    }
    return hostaddr;
}

int sftp_download(char* loclfile, char* sftppath)
{
    unsigned long hostaddr = getIP();
    int sock, i, auth_pw = 1;
    struct sockaddr_in sin;
    const char* fingerprint;
    LIBSSH2_SESSION* session;
    int rc;
    FILE* local;
    LIBSSH2_SFTP* sftp_session;
    LIBSSH2_SFTP_HANDLE* sftp_handle;
    LIBSSH2_SFTP_ATTRIBUTES attrs;
    char mem[1024 * 100];
    size_t nread;
    char* ptr;

#ifdef WIN32
    WSADATA wsadata;
    int err;

    err = WSAStartup(MAKEWORD(2, 0), &amp;wsadata);
    if (err) {
        fprintf(stderr, "WSAStartup failed with error: %d\n", err);
        return -1;
    }
#endif

    rc = libssh2_init(0);
    if (rc) {
        fprintf(stderr, "libssh2 initialization failed (%d)\n", rc);
        return -1;
    }

    local = fopen(loclfile, "rb");
    if (!local) {
        fprintf(stderr, "Can't open local file %s\n", loclfile);
        return -1;
    }

    /*
     * The application code is responsible for creating the socket
     * and establishing the connection
     */
    sock = socket(AF_INET, SOCK_STREAM, 0);

    sin.sin_family = AF_INET;
    sin.sin_port = htons(22);
    sin.sin_addr.s_addr = hostaddr;
    if (connect(sock, (struct sockaddr*)(&amp;sin),
        sizeof(struct sockaddr_in)) != 0) {
        fprintf(stderr, "failed to connect!\n");
        return -1;
    }

    /* Create a session instance
     */
    session = libssh2_session_init();
    if (!session)
        return -1;

    /* Since we have set non-blocking, tell libssh2 we are blocking */
    libssh2_session_set_blocking(session, 1);

    /* ... start it up. This will trade welcome banners, exchange keys,
     * and setup crypto, compression, and MAC layers
     */
    rc = libssh2_session_handshake(session, sock);
    if (rc) {
        fprintf(stderr, "Failure establishing SSH session: %d\n", rc);
        return -1;
    }

    if (auth_pw) {
        /* We could authenticate via password */
        if (libssh2_userauth_password(session, username, password)) {
            fprintf(stderr, "Authentication by password failed.\n");
            goto shutdown;
        }
    }

    sftp_session = libssh2_sftp_init(session);

    if (!sftp_session) {
        fprintf(stderr, "Unable to init SFTP session\n");
        goto shutdown;
    }

    /* Request a file via SFTP */

    sftp_handle =
        libssh2_sftp_open(sftp_session, sftppath,
            LIBSSH2_FXF_CREAT | LIBSSH2_FXF_WRITE | LIBSSH2_FXF_READ,
            LIBSSH2_SFTP_S_IRUSR | LIBSSH2_SFTP_S_IWUSR |
            LIBSSH2_SFTP_S_IRGRP | LIBSSH2_SFTP_S_IROTH);
    if (!sftp_handle) {
        fprintf(stderr, "Unable to open file with SFTP\n");
        goto shutdown;
    }

    if (libssh2_sftp_fstat_ex(sftp_handle, &amp;attrs, 0) &lt; 0) {
        fprintf(stderr, "libssh2_sftp_fstat_ex failed\n");
        goto shutdown;
    }
    else
        libssh2_sftp_seek64(sftp_handle, attrs.filesize);

    if (!sftp_handle) {
        fprintf(stderr, "Unable to open file with SFTP\n");
        goto shutdown;
    }
    //fprintf(stderr, "libssh2_sftp_open() is done, now send data!\n");
    do {
        nread = fread(mem, 1, sizeof(mem), local);
        if (nread &lt;= 0) {
            /* end of file */
            break;
        }
        ptr = mem;

        do {
            /* write data in a loop until we block */
            rc = libssh2_sftp_write(sftp_handle, ptr, nread);
            if (rc &lt; 0)
                break;
            ptr += rc;
            nread -= rc;
        } while (nread);

    } while (rc &gt; 0);

    libssh2_sftp_close(sftp_handle);
    libssh2_sftp_shutdown(sftp_session);

shutdown:
    libssh2_session_disconnect(session,
        "Normal Shutdown, Thank you for playing");
    libssh2_session_free(session);

#ifdef WIN32
    closesocket(sock);
#else
    close(sock);
#endif
    if (local)
        fclose(local);
    libssh2_exit();

    return 0;
}

static int waitsocket(int socket_fd, LIBSSH2_SESSION* session)
{
    struct timeval timeout;
    int rc;
    fd_set fd;
    fd_set* writefd = NULL;
    fd_set* readfd = NULL;
    int dir;

    timeout.tv_sec = 10;
    timeout.tv_usec = 0;

    FD_ZERO(&amp;fd);

    FD_SET(socket_fd, &amp;fd);

    /* now make sure we wait in the correct direction */
    dir = libssh2_session_block_directions(session);

    if (dir &amp; LIBSSH2_SESSION_BLOCK_INBOUND)
        readfd = &amp;fd;

    if (dir &amp; LIBSSH2_SESSION_BLOCK_OUTBOUND)
        writefd = &amp;fd;

    rc = select(socket_fd + 1, readfd, writefd, NULL, &amp;timeout);

    return rc;
}

int ssh_exec(char* commandline)
{
    unsigned long hostaddr = getIP();
    int sock;
    struct sockaddr_in sin;
    const char* fingerprint;
    LIBSSH2_SESSION* session;
    LIBSSH2_CHANNEL* channel;
    int rc;
    int exitcode;
    char* exitsignal = (char*)"none";
    int bytecount = 0;
    size_t len;
    LIBSSH2_KNOWNHOSTS* nh;
    int type;

#ifdef WIN32
    WSADATA wsadata;
    int err;

    err = WSAStartup(MAKEWORD(2, 0), &amp;wsadata);
    if (err != 0) {
        fprintf(stderr, "WSAStartup failed with error: %d\n", err);
        return -1;
    }
#endif

    rc = libssh2_init(0);
    if (rc != 0) {
        fprintf(stderr, "libssh2 initialization failed (%d)\n", rc);
        return -1;
    }

    /* Ultra basic "connect to port 22 on localhost"
     * Your code is responsible for creating the socket establishing the
     * connection
     */
    sock = socket(AF_INET, SOCK_STREAM, 0);

    sin.sin_family = AF_INET;
    sin.sin_port = htons(22);
    sin.sin_addr.s_addr = hostaddr;
    if (connect(sock, (struct sockaddr*)(&amp;sin),
        sizeof(struct sockaddr_in)) != 0) {
        fprintf(stderr, "failed to connect!\n");
        return -1;
    }

    /* Create a session instance */
    session = libssh2_session_init();
    if (!session)
        return -1;

    /* tell libssh2 we want it all done non-blocking */
    libssh2_session_set_blocking(session, 0);

    /* ... start it up. This will trade welcome banners, exchange keys,
     * and setup crypto, compression, and MAC layers
     */
    while ((rc = libssh2_session_handshake(session, sock)) ==
        LIBSSH2_ERROR_EAGAIN);
    if (rc) {
        fprintf(stderr, "Failure establishing SSH session: %d\n", rc);
        return -1;
    }

    nh = libssh2_knownhost_init(session);
    if (!nh) {
        /* eeek, do cleanup here */
        return -2;
    }

    /* read all hosts from here */
    libssh2_knownhost_readfile(nh, "known_hosts",
        LIBSSH2_KNOWNHOST_FILE_OPENSSH);

    /* store all known hosts to here */
    libssh2_knownhost_writefile(nh, "dumpfile",
        LIBSSH2_KNOWNHOST_FILE_OPENSSH);

    libssh2_knownhost_free(nh);

    if (1) {
        /* We could authenticate via password */
        while ((rc = libssh2_userauth_password(session, username, password)) ==
            LIBSSH2_ERROR_EAGAIN);
        if (rc) {
            fprintf(stderr, "Authentication by password failed.\n");
            goto shutdown;
        }
    }

#if 0
    libssh2_trace(session, ~0);
#endif

    /* Exec non-blocking on the remove host */
    while ((channel = libssh2_channel_open_session(session)) == NULL &amp;&amp;
        libssh2_session_last_error(session, NULL, NULL, 0) ==
        LIBSSH2_ERROR_EAGAIN) {
        waitsocket(sock, session);
    }
    if (channel == NULL) {
        fprintf(stderr, "Error\n");
        exit(1);
    }
    while ((rc = libssh2_channel_exec(channel, commandline)) ==
        LIBSSH2_ERROR_EAGAIN) {
        waitsocket(sock, session);
    }
    if (rc != 0) {
        fprintf(stderr, "Error\n");
        exit(1);
    }
    for (;;) {
        /* loop until we block */
        int rc;
        do {
            char buffer[0x4000];
            rc = libssh2_channel_read(channel, buffer, sizeof(buffer));
            if (rc &gt; 0) {
                int i;
                bytecount += rc;
                fprintf(stderr, "We read:\n");
                for (i = 0; i &lt; rc; ++i)
                    fputc(buffer[i], stderr);
                fprintf(stderr, "\n");
            }
            else {
                if (rc != LIBSSH2_ERROR_EAGAIN)
                    /* no need to output this for the EAGAIN case */
                    fprintf(stderr, "returned %d\n", rc);
            }
        } while (rc &gt; 0);

        /* this is due to blocking that would occur otherwise so we loop on
           this condition */
        if (rc == LIBSSH2_ERROR_EAGAIN) {
            waitsocket(sock, session);
        }
        else
            break;
    }
    exitcode = 127;
    while ((rc = libssh2_channel_close(channel)) == LIBSSH2_ERROR_EAGAIN)
        waitsocket(sock, session);

    if (rc == 0) {
        exitcode = libssh2_channel_get_exit_status(channel);
        libssh2_channel_get_exit_signal(channel, &amp;exitsignal,
            NULL, NULL, NULL, NULL, NULL);
    }

    if (exitsignal)
        fprintf(stderr, "\nGot signal: %s\n", exitsignal);
    else
        fprintf(stderr, "\nEXIT: %d bytecount: %d\n", exitcode, bytecount);

    libssh2_channel_free(channel);
    channel = NULL;

shutdown:

    libssh2_session_disconnect(session,
        "Normal Shutdown, Thank you for playing");
    libssh2_session_free(session);

#ifdef WIN32
    closesocket(sock);
#else
    close(sock);
#endif

    libssh2_exit();

    return 0;
}


__declspec(dllexport) download_file(char* loclfile)
{
    char sftppath[512] = "/home/XXX/";
    strcat(sftppath, loclfile);
    return sftp_download(loclfile, sftppath);
}

__declspec(dllexport) int setip(char* IP)
{
    hostaddr = inet_addr(IP);
    return 0;
}

__declspec(dllexport) int my_exec(char *cmd)
{
    ssh_exec(cmd);
    return 0;
}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">编译命令：</span></p> 
<pre><code>Clang main.c -lexample-ssh2_exec</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">注意在其他电脑中不仅需要拷贝本次编译的dll，在安装OpenSSL时的安装目录下的bin文件中包含其他的可能需要的dll，需要拷贝过来，如libcrypto-3-x64.dll。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">改进1：</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Dll無法直接改名！</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">將文件名改为需要的如XXX.c,然后替换Cmakelists.txt：</span></p> 
<pre><code>include(CheckIncludeFiles)
include(CheckSymbolExists)
include(CopyRuntimeDependencies)
include(SocketLibraries)

append_needed_socket_libraries(LIBRARIES)


add_library(XXX SHARED XXX.c)
list(APPEND EXAMPLE_TARGETS XXX)
# to find generated header
target_include_directories(XXX PRIVATE ${CMAKE_CURRENT_BINARY_DIR})
target_link_libraries(XXX libssh2 ${LIBRARIES})

add_target_to_copy_dependencies(
  TARGET copy_example_dependencies
  DEPENDENCIES ${RUNTIME_DEPENDENCIES}
  BEFORE_TARGETS ${EXAMPLE_TARGETS})</code></pre> 
<p>将其中的XXX 改为自己的文件名即可，就会在libssh2-libssh2-1.10.0\build\example\Release生成对应的dll</p> 
<p></p> 
<p>改进2：</p> 
<p>提供用户包含<span style="color:#000000;">libcrypto-3-x64.dll文件，显得不专业。</span></p> 
<p>在VS添加指定的lib进行重新编译： </p> 
<p><img alt="" height="512" src="https://images2.imgbox.com/38/0a/E4VispYn_o.png" width="775"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fc5d9f5fb0f0d71336d1199a7ac275f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenCV基础（4）使用OpenCV裁剪图像</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99e802e933e376f8a9edd1698970cd93/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UGUI检测不规则图片点击</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>