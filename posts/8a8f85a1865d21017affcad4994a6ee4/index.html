<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot &#43; Redis 实现接口限流 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot &#43; Redis 实现接口限流" />
<meta property="og:description" content="一、思路 使用接口限流的主要目的在于提高系统的稳定性，防止接口被恶意打击（短时间内大量请求）。
比如要求某接口在1分钟内请求次数不超过1000次，那么应该如何设计代码呢？
下面讲两种思路，如果想看代码可直接翻到后面的代码部分。
1.1 固定时间段（旧思路） 1.1.1 思路描述 该方案的思路是：使用Redis记录固定时间段内某用户IP访问某接口的次数，其中：
Redis的key：用户IP &#43; 接口方法名
Redis的value：当前接口访问次数。
当用户在近期内第一次访问该接口时，向Redis中设置一个包含了用户IP和接口方法名的key，value的值初始化为1（表示第一次访问当前接口）。同时，设置该key的过期时间（比如为60秒）。
之后，只要这个key还未过期，用户每次访问该接口都会导致value自增1次。
用户每次访问接口前，先从Redis中拿到当前接口访问次数，如果发现访问次数大于规定的次数（如超过1000次），则向用户返回接口访问失败的标识。
1.1.2 思路缺陷 该方案的缺点在于，限流时间段是固定的。
比如要求某接口在1分钟内请求次数不超过1000次，观察以下流程：
可以发现，00:59和01:01之间仅仅间隔了2秒，但接口却被访问了1000&#43;999=1999次，是限流次数（1000次）的2倍！
所以在该方案中，限流次数的设置可能不起作用，仍然可能在短时间内造成大量访问。
1.2 滑动窗口（新思路） 1.2.1 思路描述 为了避免出现方案1中由于键过期导致的短期访问量增大的情况，我们可以改变一下思路，也就是把固定的时间段改成动态的：
假设某个接口在10秒内只允许访问5次。用户每次访问接口时，记录当前用户访问的时间点（时间戳），并计算前10秒内用户访问该接口的总次数。如果总次数大于限流次数，则不允许用户访问该接口。这样就能保证在任意时刻用户的访问次数不会超过1000次。
如下图，假设用户在0:19时间点访问接口，经检查其前10秒内访问次数为5次，则允许本次访问。
假设用户0:20时间点访问接口，经检查其前10秒内访问次数为6次（超出限流次数5次），则不允许本次访问。
1.2.2 Redis部分的实现 1）选用何种 Redis 数据结构
首先是需要确定使用哪个Redis数据结构。用户每次访问时，需要用一个key记录用户访问的时间点，而且还需要利用这些时间点进行范围检查。
2）为何选择 zSet 数据结构
为了能够实现范围检查，可以考虑使用Redis中的zSet有序集合。
添加一个zSet元素的命令如下：
ZADD [key] [score] [member] 它有一个关键的属性score，通过它可以记录当前member的优先级。
于是我们可以把score设置成用户访问接口的时间戳，以便于通过score进行范围检查。key则记录用户IP和接口方法名，至于member设置成什么没有影响，一个member记录了用户访问接口的时间点。因此member也可以设置成时间戳。
3）zSet 如何进行范围检查（检查前几秒的访问次数）
思路是，把特定时间间隔之前的member都删掉，留下的member就是时间间隔之内的总访问次数。然后统计当前key中的member有多少个即可。
① 把特定时间间隔之前的member都删掉。
zSet有如下命令，用于删除score范围在[min~max]之间的member：
Zremrangebyscore [key] [min] [max] 假设限流时间设置为5秒，当前用户访问接口时，获取当前系统时间戳为currentTimeMill，那么删除的score范围可以设置为：
min = 0 max = currentTimeMill - 5 * 1000 相当于把5秒之前的所有member都删除了，只留下前5秒内的key。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8a8f85a1865d21017affcad4994a6ee4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-07T15:01:25+08:00" />
<meta property="article:modified_time" content="2023-08-07T15:01:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot &#43; Redis 实现接口限流</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<h3>一、思路</h3> 
<p>使用接口限流的主要目的在于提高系统的稳定性，防止接口被恶意打击（短时间内大量请求）。</p> 
<p>比如要求某接口在1分钟内请求次数不超过1000次，那么应该如何设计代码呢？</p> 
<p>下面讲两种思路，如果想看代码可直接翻到后面的代码部分。</p> 
<h4>1.1 固定时间段（旧思路）</h4> 
<h6>1.1.1 思路描述</h6> 
<p>该方案的思路是：使用Redis记录固定时间段内某用户IP访问某接口的次数，其中：</p> 
<ul><li> <p><strong>Redis的key</strong>：用户IP + 接口方法名</p> </li><li> <p><strong>Redis的value</strong>：当前接口访问次数。</p> </li></ul> 
<p>当用户在近期内第一次访问该接口时，向Redis中设置一个包含了用户IP和接口方法名的key，value的值初始化为1（表示第一次访问当前接口）。同时，设置该key的过期时间（比如为60秒）。</p> 
<p>之后，只要这个key还未过期，用户每次访问该接口都会导致value自增1次。</p> 
<p>用户每次访问接口前，先从Redis中拿到当前接口访问次数，如果发现访问次数大于规定的次数（如超过1000次），则向用户返回接口访问失败的标识。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="326" src="https://images2.imgbox.com/73/fd/deRBbCMs_o.png" width="907"></p> 
<h6>1.1.2 思路缺陷</h6> 
<p>该方案的缺点在于，限流时间段是固定的。</p> 
<p>比如要求某接口在1分钟内请求次数不超过1000次，观察以下流程：</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="299" src="https://images2.imgbox.com/00/8e/Ex9PdeBt_o.png" width="904"></p> 
<p></p> 
<p class="img-center"><img alt="图片" height="247" src="https://images2.imgbox.com/97/4e/mBxAgVJA_o.png" width="963"></p> 
<p>可以发现，00:59和01:01之间仅仅间隔了2秒，但接口却被访问了1000+999=1999次，是限流次数（1000次）的2倍！</p> 
<p>所以在该方案中，限流次数的设置可能不起作用，仍然可能在短时间内造成大量访问。</p> 
<p></p> 
<h4>1.2 滑动窗口（新思路）</h4> 
<h6>1.2.1 思路描述</h6> 
<p>为了避免出现方案1中由于键过期导致的短期访问量增大的情况，我们可以改变一下思路，也就是把固定的时间段改成动态的：</p> 
<p>假设某个接口在10秒内只允许访问5次。用户每次访问接口时，记录当前用户访问的时间点（时间戳），并计算前10秒内用户访问该接口的总次数。如果总次数大于限流次数，则不允许用户访问该接口。这样就能保证在任意时刻用户的访问次数不会超过1000次。</p> 
<p>如下图，假设用户在0:19时间点访问接口，经检查其前10秒内访问次数为5次，则允许本次访问。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="279" src="https://images2.imgbox.com/65/d6/5gqKxDab_o.png" width="903"></p> 
<p>假设用户0:20时间点访问接口，经检查其前10秒内访问次数为6次（超出限流次数5次），则不允许本次访问。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="223" src="https://images2.imgbox.com/1f/6f/qoG8PY1Q_o.png" width="904"></p> 
<h6>1.2.2 Redis部分的实现</h6> 
<p><strong>1）选用何种 Redis 数据结构</strong></p> 
<p>首先是需要确定使用哪个Redis数据结构。用户每次访问时，需要用一个key记录用户访问的时间点，而且还需要利用这些时间点进行范围检查。</p> 
<p><strong>2）为何选择 zSet 数据结构</strong></p> 
<p>为了能够实现范围检查，可以考虑使用Redis中的zSet有序集合。</p> 
<p>添加一个zSet元素的命令如下：</p> 
<pre><code>ZADD [key] [score] [member]
</code></pre> 
<p>它有一个关键的属性score，通过它可以记录当前member的优先级。</p> 
<p>于是我们可以把score设置成用户访问接口的时间戳，以便于通过score进行范围检查。key则记录用户IP和接口方法名，至于member设置成什么没有影响，一个member记录了用户访问接口的时间点。因此member也可以设置成时间戳。</p> 
<p><strong>3）zSet 如何进行范围检查（检查前几秒的访问次数）</strong></p> 
<p>思路是，把特定时间间隔之前的member都删掉，留下的member就是时间间隔之内的总访问次数。然后统计当前key中的member有多少个即可。</p> 
<p>① 把特定时间间隔之前的member都删掉。</p> 
<p>zSet有如下命令，用于删除score范围在<code>[min~max]</code>之间的member：</p> 
<pre><code>Zremrangebyscore [key] [min] [max]
</code></pre> 
<p>假设限流时间设置为5秒，当前用户访问接口时，获取当前系统时间戳为<code>currentTimeMill</code>，那么删除的score范围可以设置为：</p> 
<pre><code>min = 0
max = currentTimeMill - 5 * 1000
</code></pre> 
<p>相当于把5秒之前的所有member都删除了，只留下前5秒内的key。</p> 
<p>② 统计特定key中已存在的member有多少个。</p> 
<p>zSet有如下命令，用于统计某个key的member总数：</p> 
<pre><code> ZCARD [key]
</code></pre> 
<p>统计的key的member总数，就是当前接口已经访问的次数。如果该数目大于限流次数，则说明当前的访问应被限流。</p> 
<h3>二、代码实现</h3> 
<p>主要是使用注解 + AOP的形式实现。</p> 
<h4>2.1 固定时间段思路</h4> 
<p>使用了lua脚本。</p> 
<blockquote> 
 <ul><li> <p>参考：https://blog.csdn.net/qq_43641418/article/details/127764462</p> </li></ul> 
</blockquote> 
<h6>2.1.1 限流注解</h6> 
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface RateLimiter {

    /**
     * 限流时间，单位秒
     */
    int time() default 5;

    /**
     * 限流次数
     */
    int count() default 10;
}
</code></pre> 
<h6>2.1.2 定义lua脚本</h6> 
<p>在<code>resources/lua</code>下新建<code>limit.lua</code>：</p> 
<pre><code>-- 获取redis键
local key = KEYS[1]
-- 获取第一个参数（次数）
local count = tonumber(ARGV[1])
-- 获取第二个参数（时间）
local time = tonumber(ARGV[2])
-- 获取当前流量
local current = redis.call('get', key);
-- 如果current值存在，且值大于规定的次数，则拒绝放行（直接返回当前流量）
if current and tonumber(current) &gt; count then
    return tonumber(current)
end
-- 如果值小于规定次数，或值不存在，则允许放行，当前流量数+1  (值不存在情况下，可以自增变为1)
current = redis.call('incr', key);
-- 如果是第一次进来，那么开始设置键的过期时间。
if tonumber(current) == 1 then 
    redis.call('expire', key, time);
end
-- 返回当前流量
return tonumber(current)
</code></pre> 
<h6>2.1.3 注入Lua执行脚本</h6> 
<p>关键代码是<code>limitScript()</code>方法</p> 
<pre><code>@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        redisTemplate.setConnectionFactory(connectionFactory);
        // 使用Jackson2JsonRedisSerialize 替换默认序列化(默认采用的是JDK序列化)
        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        redisTemplate.setKeySerializer(jackson2JsonRedisSerializer);
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.setHashKeySerializer(jackson2JsonRedisSerializer);
        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);
        return redisTemplate;
    }


    /**
     * 解析lua脚本的bean
     */
    @Bean("limitScript")
    public DefaultRedisScript&lt;Long&gt; limitScript() {
        DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();
        redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource("lua/limit.lua")));
        redisScript.setResultType(Long.class);
        return redisScript;
    }
}
</code></pre> 
<h6>2.1.3 定义Aop切面类</h6> 
<pre><code>@Slf4j
@Aspect
@Component
public class RateLimiterAspect {
 @Autowired
    private RedisTemplate redisTemplate;
    @Autowired
    private RedisScript&lt;Long&gt; limitScript;

 @Before("@annotation(rateLimiter)")
    public void doBefore(JoinPoint point, RateLimiter rateLimiter) throws Throwable {
        int time = rateLimiter.time();
        int count = rateLimiter.count();

        String combineKey = getCombineKey(rateLimiter.type(), point);
        List&lt;String&gt; keys = Collections.singletonList(combineKey);
        try {
            Long number = (Long) redisTemplate.execute(limitScript, keys, count, time);
            // 当前流量number已超过限制，则抛出异常
            if (number == null || number.intValue() &gt; count) {
             throw new RuntimeException("访问过于频繁，请稍后再试");
            }
            log.info("[limit] 限制请求数'{}',当前请求数'{}',缓存key'{}'", count, number.intValue(), combineKey);
        } catch (Exception ex) {
            ex.printStackTrace();
            throw new RuntimeException("服务器限流异常，请稍候再试");
        }
    }
    
    /**
     * 把用户IP和接口方法名拼接成 redis 的 key
     * @param point 切入点
     * @return 组合key
     */
    private String getCombineKey(JoinPoint point) {
        StringBuilder sb = new StringBuilder("rate_limit:");
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        sb.append( Utils.getIpAddress(request) );
        
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        Class&lt;?&gt; targetClass = method.getDeclaringClass();
        // keyPrefix + "-" + class + "-" + method
        return sb.append("-").append( targetClass.getName() )
                .append("-").append(method.getName()).toString();
    }
}
</code></pre> 
<h4>2.2 滑动窗口思路</h4> 
<h6>2.2.1 限流注解</h6> 
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface RateLimiter {

    /**
     * 限流时间，单位秒
     */
    int time() default 5;

    /**
     * 限流次数
     */
    int count() default 10;
}
</code></pre> 
<h6>2.2.2 定义Aop切面类</h6> 
<pre><code>@Slf4j
@Aspect
@Component
public class RateLimiterAspect {

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 实现限流（新思路）
     * @param point
     * @param rateLimiter
     * @throws Throwable
     */
    @SuppressWarnings("unchecked")
    @Before("@annotation(rateLimiter)")
    public void doBefore(JoinPoint point, RateLimiter rateLimiter) throws Throwable {
        // 在 {time} 秒内仅允许访问 {count} 次。
        int time = rateLimiter.time();
        int count = rateLimiter.count();
        // 根据用户IP（可选）和接口方法，构造key
        String combineKey = getCombineKey(rateLimiter.type(), point);
        
        // 限流逻辑实现
        ZSetOperations zSetOperations = redisTemplate.opsForZSet();
        // 记录本次访问的时间结点
        long currentMs = System.currentTimeMillis();
        zSetOperations.add(combineKey, currentMs, currentMs);
        // 这一步是为了防止member一直存在于内存中
        redisTemplate.expire(combineKey, time, TimeUnit.SECONDS);
        // 移除{time}秒之前的访问记录（滑动窗口思想）
        zSetOperations.removeRangeByScore(combineKey, 0, currentMs - time * 1000);
        
        // 获得当前窗口内的访问记录数
        Long currCount = zSetOperations.zCard(combineKey);
        // 限流判断
        if (currCount &gt; count) {
            log.error("[limit] 限制请求数'{}',当前请求数'{}',缓存key'{}'", count, currCount, combineKey);
            throw new RuntimeException("访问过于频繁，请稍后再试!");
        }
    }

    /**
     * 把用户IP和接口方法名拼接成 redis 的 key
     * @param point 切入点
     * @return 组合key
     */
    private String getCombineKey(JoinPoint point) {
        StringBuilder sb = new StringBuilder("rate_limit:");
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        sb.append( Utils.getIpAddress(request) );
        
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        Class&lt;?&gt; targetClass = method.getDeclaringClass();
        // keyPrefix + "-" + class + "-" + method
        return sb.append("-").append( targetClass.getName() )
                .append("-").append(method.getName()).toString();
    }
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c7e5fa7707cc673b6f0229dbd1733b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">当我用Python采集全国加盟品牌详情信息，并进行可视化分析后发现了这些</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cc82c8b27a65978a5ebf2d5481ea9bf2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">manifest merger failed with multiple errors see logs（已解决）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>