<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>跟cherno手搓游戏引擎【1】：配置与入口点 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="跟cherno手搓游戏引擎【1】：配置与入口点" />
<meta property="og:description" content="环境配置： 编译环境：VS2019
创建两个项目：
设置Sandbox为启动项：
设置sandbox的配置属性-常规-输出目录\中间目录为如下：
预处理定义：为了配置一些只有windows才能用的函数。
设置YOTOEngin（我自己起的名字）配置属性-常规-输出目录\中间目录为如下：配置类型改为dll。
预处理定义：为了配置一些只有windows才能用的函数，并且在core.h中区分在此包中，是dll导出还是导入。
附加包含目录：用来包含#include&lt;YOTO.h&gt;
按下列格式创建文件：bin和bin-int为自动生成的文件：
架构理解：（个人理解） Sandbox和YOTOEngine是分离的，即引擎的功能单独写在YOTOEngine里，Sandbox只是功能的启动、配置器（客户端）。目前还不太懂为什么这么设计，只是个猜测，作者太菜啦。
代码部分： YOTOEngine: core.h:用于dll配置
核心：因为__declspec(dllexport) 只在window支持，且在不同包下dll导入导出不一样。为什么下面没有用import呢，这个我查了下，可以不用import，除了静态类。
（关于__declspec(dllimport)的理解-CSDN博客）
#pragma once //用于dll的宏 #ifdef YT_PLATFORM_WINDOWS #ifdef YT_BUILD_DLL #define YOTO_API __declspec(dllexport) #else #define YOTO_API __declspec(dllimport) #endif // DEBUG #else #error YOTO_ONLY_SUPPORT_WINDOWS #endif // YOTO_PLATFORM_WINDOWS Application.h:定义了一个Run函数，即启动程序，需要一个入口，继承此类
#pragma once #include&#34;Core.h&#34; namespace YOTO { class YOTO_API Application { public: Application(); virtual ~Application(); void Run(); }; //在客户端定义 Application* CreateApplication(); } Application.cpp
#include &#34;Application.h&#34; namespace YOTO { Application::Application() { } Application::~Application() { } void Application::Run() { while (true) { } } } EntryPoint." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/297299fbf2821dafc13b507642b85084/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-30T17:34:35+08:00" />
<meta property="article:modified_time" content="2023-12-30T17:34:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">跟cherno手搓游戏引擎【1】：配置与入口点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>环境配置：</h2> 
<hr> 
<p>编译环境：VS2019</p> 
<p>创建两个项目：</p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/4d/94/bHLsYQxR_o.png" width="405"></p> 
<p>设置Sandbox为启动项：</p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/a3/08/KvaCKqk8_o.png" width="618"></p> 
<p>设置sandbox的配置属性-常规-输出目录\中间目录为如下：</p> 
<p><img alt="" height="416" src="https://images2.imgbox.com/32/3b/4Dfwkien_o.png" width="1200"></p> 
<p> 预处理定义：为了配置一些只有windows才能用的函数。</p> 
<p><img alt="" height="394" src="https://images2.imgbox.com/f4/df/sKbbNrPB_o.png" width="1200"></p> 
<p>设置YOTOEngin（我自己起的名字）配置属性-常规-输出目录\中间目录为如下：配置类型改为dll。</p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/5f/3c/furRFdET_o.png" width="1200"><br>  </p> 
<p>预处理定义：为了配置一些只有windows才能用的函数，并且在core.h中区分在此包中，是dll导出还是导入。</p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/d2/7c/dLy0otAp_o.png" width="1200"></p> 
<p>附加包含目录：用来包含#include&lt;YOTO.h&gt;</p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/32/73/TraX0FaS_o.png" width="1200"></p> 
<p>按下列格式创建文件：bin和bin-int为自动生成的文件：</p> 
<p><img alt="" height="467" src="https://images2.imgbox.com/5b/e8/7Bic1GVT_o.png" width="403"></p> 
<h2>架构理解：（个人理解）</h2> 
<p>Sandbox和YOTOEngine是分离的，即引擎的功能单独写在YOTOEngine里，Sandbox只是功能的启动、配置器（客户端）。目前还不太懂为什么这么设计，只是个猜测，作者太菜啦。</p> 
<h2>代码部分：</h2> 
<hr> 
<h3>YOTOEngine:</h3> 
<p><strong>core.h:用于dll配置</strong></p> 
<p>核心：因为__declspec(dllexport) 只在window支持，且在不同包下dll导入导出不一样。为什么下面没有用import呢，这个我查了下，可以不用import，除了静态类。</p> 
<p>（<a href="https://blog.csdn.net/sinat_22991367/article/details/73695039" title="关于__declspec(dllimport)的理解-CSDN博客">关于__declspec(dllimport)的理解-CSDN博客</a>）</p> 
<pre><code class="language-cpp">#pragma once
//用于dll的宏
#ifdef YT_PLATFORM_WINDOWS
#ifdef YT_BUILD_DLL
#define YOTO_API __declspec(dllexport) 
#else
#define YOTO_API __declspec(dllimport) 

#endif // DEBUG
#else
#error YOTO_ONLY_SUPPORT_WINDOWS
#endif // YOTO_PLATFORM_WINDOWS
</code></pre> 
<p><strong>Application.h:定义了一个Run函数，即启动程序，需要一个入口，继承此类</strong></p> 
<pre><code class="language-cpp">#pragma once
#include"Core.h"
namespace YOTO {
	class YOTO_API Application
	{
	public:
		Application();
		virtual ~Application();
		void Run();
	};
	//在客户端定义
	Application* CreateApplication();
}


</code></pre> 
<p><strong>Application.cpp</strong></p> 
<pre><code class="language-cpp">#include "Application.h"
namespace YOTO {
	Application::Application() {

	}
	Application::~Application() {

	}
	void Application::Run() {
		while (true)
		{

		}
	}
}</code></pre> 
<p><strong>EntryPoint.h：入口点，主函数，这个作用就是把客户端和引擎分离开</strong></p> 
<pre><code class="language-cpp">#pragma once

#ifdef YT_PLATFORM_WINDOWS
#include "Application.h"
extern YOTO::Application* YOTO::CreateApplication();
void main(int argc,char** argv) {
	auto app = YOTO::CreateApplication();
	app-&gt;Run();
	delete app;
}
#endif</code></pre> 
<p><strong>YOTO.h</strong></p> 
<pre><code class="language-cpp">#pragma once

#include "YOTO/Application.h"
//入口点
#include"YOTO/EntryPoint.h"</code></pre> 
<h3>Sandbox:</h3> 
<p><strong>SandboxApp.cpp:客户端类，只需要继承和完成CreateApplication方法</strong></p> 
<pre><code class="language-cpp">#include&lt;YOTO.h&gt;
class Sandbox:public YOTO::Application
{
public:
	Sandbox() {

	}
	~Sandbox() {

	}

private:

};

YOTO::Application*YOTO::CreateApplication() {

	return new Sandbox();
}</code></pre> 
<p>在运行之前，请先生成YOTOEngine，之后将bin\Debug-x64\YOTOEngine\YOTOEngine.dll拖入bin\Debug-x64\SandBox文件夹中</p> 
<h2>测试：</h2> 
<p>在new前加入一个printf("helloworld");</p> 
<p>运行结果：</p> 
<p><img alt="" height="606" src="https://images2.imgbox.com/bf/55/BWXtS9hz_o.png" width="1200"></p> 
<p>不定期更新</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e19901cb02acf9c0c552782524c4ef07/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">路径中“./”、“../”、“/”代表的含义 路径相关知识点总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2dbfb923e9c49a3fc9a01aeeb35e508c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Proteus仿真】【Arduino单片机】汽车尾灯控制设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>