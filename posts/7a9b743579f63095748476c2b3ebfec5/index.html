<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【操作系统】什么是用户态和内核态？用户态和内核态是如何切换的？ - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【操作系统】什么是用户态和内核态？用户态和内核态是如何切换的？" />
<meta property="og:description" content="【操作系统】什么是用户态和内核态？用户态和内核态是如何切换的？ 参考资料：
用户态到内核态切换
什么是用户态和内核态？
「操作系统」什么是用户态和内核态？为什么要区分
一、什么是用户态和内核态？ 1.1、概述 用户态和内核态是操作系统的两种运行状态。
内核态：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。
用户态：处于用户态的 CPU 只能访问受限资源，不能直接访问内存等硬件设备，不能直接访问内存等硬件设备，必须通过「系统调用」陷入到内核中，才能访问这些特权资源。
1.2、为什么要区分用户态和内核态？ 在 CPU 的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃，比如：清空内存，修改时钟等。如果所有的程序代码都能够直接使用这些指令，那么很有可能我们的系统一天将会死 n 次。
所以，CPU将指令分为 特权指令 和 非特权指令 ，对于较为危险的指令，只允许操作系统本身及其相关模块进行调用，普通的、用户自行编写的应用程序只能使用那些不会造成危险的指令。
基于安全的考虑，CPU 提供了特权分级机制，把区域分成了四个 Ring，越往里权限越高，越往外权限越低。
操作系统根据 CPU 的特权分级机制，把进程的运行空间分为「内核空间」和「用户空间」，分别对应着上图中， CPU 特权等级的 Ring 0 和 Ring 3。
二、什么时候会从用户态陷入内核态？ 有三种方式程序会从用户态陷入内核态：
系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程「主动」发起的，异常和外围设备中断则是「被动」的。
三、什么是系统调用？过程是怎么样的？ 当程序需要访问硬件资源的时候，比如内存、硬盘等，就需要通过「系统调用」陷入到内核中，才能访问这些特权资源。系统调用可以理解为内核实现的函数，比如应用程序要通过网卡接收数据，会调用 Socket 的 read 函数。
程序在执行系统调用的过程中会从用户态切换到内核态，再从内核态切换到用户态，过程如下：
系统调用的过程：
从用户态到内核态：当应用程序使用系统调用时，先将系统调用名称转换为系统调用号，接着将「系统调用号」和「请求参数」放到寄存器里，然后执行中断指令（int $0x80 指令），产生一个中断，CPU 陷入到内核态。执行内核态逻辑：CPU 跳转到中断处理程序，先将当前用户态的寄存器（用户态的代码段、数据段、保存参数的寄存器）保存到内核数据结构，接着将系统调用号从寄存器里面取出来，最后根据系统调用号，在「系统调用表」中找到相应的系统调用函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。从内核态到用户态：执行完系统调用后，执行中断返回指令（iret 指令），将原来用户态保存的现场恢复回来，包含代码段、指令指针寄存器等。这时候 CPU 恢复到用户态，用户态进程恢复执行。 一次系统调用过程中的，会发生两次「 CPU 上下文切换」（所谓的 CPU 上下文就是 CPU 寄存器和程序计数器）：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/7a9b743579f63095748476c2b3ebfec5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-06T07:00:00+08:00" />
<meta property="article:modified_time" content="2023-06-06T07:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【操作系统】什么是用户态和内核态？用户态和内核态是如何切换的？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>【操作系统】什么是用户态和内核态？用户态和内核态是如何切换的？</h2> 
<p>参考资料：</p> 
<blockquote> 
 <p><a href="https://abcdxyzk.github.io/blog/2015/06/02/kernel-sched-user-to-kernel/" rel="nofollow">用户态到内核态切换</a></p> 
 <p><a href="https://blog.csdn.net/qq_36894974/article/details/115654242?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168581678016800180687839%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=168581678016800180687839&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-115654242-null-null.268%5Ev1%5Ekoosearch&amp;utm_term=%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81&amp;spm=1018.2226.3001.4450">什么是用户态和内核态？</a></p> 
 <p><a href="https://blog.csdn.net/u014571143/article/details/129660010">「操作系统」什么是用户态和内核态？为什么要区分</a></p> 
</blockquote> 
<h3><a id="_11"></a>一、什么是用户态和内核态？</h3> 
<h4><a id="11_13"></a>1.1、概述</h4> 
<p>用户态和内核态是操作系统的两种运行状态。</p> 
<ul><li> <p><strong>内核态</strong>：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</p> </li><li> <p><strong>用户态</strong>：处于用户态的 CPU 只能访问受限资源，不能直接访问内存等硬件设备，不能直接访问内存等硬件设备，必须通过「系统调用」陷入到内核中，才能访问这些特权资源。</p> </li></ul> 
<h4><a id="12_21"></a>1.2、为什么要区分用户态和内核态？</h4> 
<p>在 CPU 的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃，比如：清空内存，修改时钟等。如果所有的程序代码都能够直接使用这些指令，那么很有可能我们的系统一天将会死 n 次。</p> 
<p>所以，CPU将指令分为 <strong>特权指令</strong> 和 <strong>非特权指令</strong> ，对于较为危险的指令，只允许操作系统本身及其相关模块进行调用，普通的、用户自行编写的应用程序只能使用那些不会造成危险的指令。</p> 
<p>基于安全的考虑，CPU 提供了特权分级机制，把区域分成了四个 Ring，越往里权限越高，越往外权限越低。</p> 
<p><img src="https://images2.imgbox.com/23/7a/wFbOxLSi_o.png" alt="image-20230605002339747"></p> 
<p>操作系统根据 CPU 的特权分级机制，把进程的运行空间分为「内核空间」和「用户空间」，分别对应着上图中， CPU 特权等级的 Ring 0 和 Ring 3。</p> 
<h3><a id="_33"></a>二、什么时候会从用户态陷入内核态？</h3> 
<p>有三种方式程序会从用户态陷入内核态：</p> 
<ul><li><strong>系统调用</strong>：这是用户态进程<strong>主动</strong>要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。</li><li><strong>异常</strong>：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li><li><strong>外围设备的中断</strong>：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li></ul> 
<p>这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中<strong>系统调用可以认为是用户进程「主动」发起的，异常和外围设备中断则是「被动」的</strong>。</p> 
<h3><a id="_43"></a>三、什么是系统调用？过程是怎么样的？</h3> 
<p>当程序需要访问硬件资源的时候，比如内存、硬盘等，就需要通过「系统调用」陷入到内核中，才能访问这些特权资源。系统调用可以理解为内核实现的函数，比如应用程序要通过网卡接收数据，会调用 Socket 的 read 函数。</p> 
<p><img src="https://images2.imgbox.com/f1/a9/O9rM0Q4w_o.png" alt="image-20230605004440189"></p> 
<p>程序在执行系统调用的过程中会从用户态切换到内核态，再从内核态切换到用户态，过程如下：</p> 
<p><img src="https://images2.imgbox.com/70/44/dGlfuXff_o.png" alt="image-20230605004501963"></p> 
<p><strong>系统调用的过程</strong>：</p> 
<ul><li><strong>从用户态到内核态</strong>：当应用程序使用系统调用时，先将系统调用名称转换为系统调用号，接着将「系统调用号」和「请求参数」放到寄存器里，然后执行中断指令（int $0x80 指令），产生一个<strong>中断</strong>，CPU 陷入到内核态。</li><li><strong>执行内核态逻辑</strong>：CPU 跳转到中断处理程序，先将当前用户态的寄存器（用户态的代码段、数据段、保存参数的寄存器）保存到内核数据结构，接着将系统调用号从寄存器里面取出来，最后根据系统调用号，在「系统调用表」中找到相应的系统调用函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。</li><li><strong>从内核态到用户态</strong>：执行完系统调用后，执行中断返回指令（iret 指令），将原来用户态保存的现场恢复回来，包含代码段、指令指针寄存器等。这时候 CPU 恢复到用户态，用户态进程恢复执行。</li></ul> 
<p><strong>一次系统调用过程中的，会发生两次「</strong> <strong>CPU</strong> <strong>上下文切换」（<strong>所谓的 CPU 上下文就是 CPU 寄存器和程序计数器</strong>）：</strong></p> 
<ul><li><strong>第一次</strong> CPU 上下文切换是从用户态切换到内核态：CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。</li><li><strong>第二次</strong> CPU 上下文切换是从内核态切换到用户态： CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。</li></ul> 
<p><img src="https://images2.imgbox.com/0b/39/FPMs5HlP_o.png" alt="image-20230605004817167"></p> 
<h3><a id="_66"></a>四、用户态和内核态是如何切换的？</h3> 
<p>Linux 系统中每个进程都有两个栈，分别是<strong>用户栈和内核栈</strong>，当应用程序运行在用户态的时候，就会使用用户栈，当应用程序运行在内核态的时候，就会使用内核栈。</p> 
<p>内核态与用户态的相互切换，其中最重要的一个步骤就是<strong>用户栈和内核栈的切换</strong>。</p> 
<p><strong>1、用户栈到内核栈：</strong></p> 
<ul><li>执行中断指令（int $0x80 指令），中断发生时，CPU 去一个特定的结构（比如 TSS）中，<strong>获取该进程的内核栈的地址信息</strong>，也就是内核栈的段选择子和栈顶指针（这两个东西是描述内核栈在内存的哪个地址空间），<strong>并分别送入 ss 寄存器和 rsp 寄存器，这时候 CPU 就指向了该进程的内核栈的栈顶位置了，这就完成了用户态到内核态的一次栈的切换</strong>。（*PS：如果不明白 ss 和 rsp 寄存器是干嘛的，可以看这篇文章：<a href="http://liupzmin.com/2021/06/27/theory/stack-insight-01-md/" rel="nofollow">一个学渣对于stack的顿悟（1）：从CPU的视角说起</a>）</li><li>然后，IP 寄存器（指令指针寄存器）跳入中断服务程序开始执行，中断服务程序会<strong>把用户态的所有寄存器压入到内核栈中</strong>，如下图，CPU 自动地将用户态栈的段选择子 ss3，和栈顶指针 rsp3 都放到内核态栈里了。<strong>这里的数字 3 代表了 CPU 特权级，内核态是 0，用户态是 3。</strong></li></ul> 
<p><img src="https://images2.imgbox.com/3c/1a/tl6HXrOx_o.png" alt="image-20230605004937675"></p> 
<p><strong>2、内核栈到用户栈</strong></p> 
<ul><li>当中断结束时，中断服务程序会从内核栈里将 CPU 寄存器的值全部恢复，最后再执行<code>iret</code>指令。</li><li><strong>将 ss3/rsp3 都弹出栈，并且将这个值分别送到 ss 和 rsp 寄存器中，这时候</strong> <strong>CPU</strong> <strong>就指向了该进程的用户栈的栈顶位置了</strong>，这样就完成了从内核栈到用户栈的一次切换。</li><li>内核栈的 ss0 和 rsp0 也会被保存到前面所说的 CPU 的一个特定的结构（比如 TSS）中，以供下次切换时使用。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/851c1153a21842dc81fa9f9de45d8290/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mybatis之Collectin标签多层嵌套使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7a6ddb6d9c667140a035451439e3dc51/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">分享5种常用计算机编程算法及示例代码提升效率的关键</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>