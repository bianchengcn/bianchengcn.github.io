<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql分页3种方式_分页实现的三种方式 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql分页3种方式_分页实现的三种方式" />
<meta property="og:description" content="三种分页的实现方式
(1)每次取查询结果的所有数据，然后根据页面显示指定的记录
(2)根据页面只取一页的数据，然后显示这一页，这里要构造sql语句
(3)取一定页数的数据，就是前两种的折中
实现分页的步骤：
1.创建一个用于封装分页相关属性及操作的类
2.从页面增加分页导航条的功能
3.实现分页查询功能，从页面请求-&gt;Servlet-&gt;DAO的实现
这里还要注意的是这些数据是放在request还是session中，这里一一讨论
1.一般不会放在session中，因为会占用大量内存，所以要放在request里面。
优点：实现比较简单，查询速度比较快。
缺点：占用内存多一些，网络传输数据多。
对于数据量比较少的查询这种方法比较合适。这里有人把数据放在session中，这样换页的时候就不用重新查询，但是这样是极其不好的，强烈建议不要这样使用。
2.肯定不会放在session中，因为放在session中没有意义。
优点：占用内存少。
缺点：比较麻烦，必须先获得查询结果的总数，因为要知道有多少纪录才知道有多少页。另外要构造分页查询语句，对于不同的数据库是不一样的。
一.借助数组进行分页
原理：进行数据库查询操作时，获取到数据库中所有满足条件的记录，保存在应用的临时数组中，再通过List的subList方法，获取到满足条件的所有记录。
实现：
首先在dao层，创建StudentMapper接口，用于对数据库的操作。在接口中定义通过数组分页的查询方法，如下所示：
List
创建StudentMapper.xml文件，编写查询的sql语句：
可以看出再编写sql语句的时候，我们并没有作任何分页的相关操作。这里是查询到所有的学生信息。
接下来在service层获取数据并且进行分页实现：
定义IStuService接口，并且定义分页方法：
通过接收currPage参数表示显示第几页的数据，pageSize表示每页显示的数据条数。
创建IStuService接口实现类StuServiceIml对方法进行实现，对获取到的数组通过currPage和pageSize进行分页：
通过subList方法，获取到两个索引间的所有数据。
最后在controller中创建测试方法：
通过用户传入的currPage和pageSize获取指定数据。
二.借助Sql语句进行分页
在了解到通过数组分页的缺陷后，我们发现不能每次都对数据库中的所有数据都检索。然后在程序中对获取到的大量数据进行二次操作，这样对空间和性能都是极大的损耗。所以我们希望能直接在数据库语言中只检索符合条件的记录，不需要在通过程序对其作处理。这时，Sql语句分页技术横空出世。
实现：通过sql语句实现分页也是非常简单的，只是需要改变我们查询的语句就能实现了，即在sql语句后面添加limit分页语句。
首先还是在StudentMapper接口中添加sql语句查询的方法，如下：
List
接下来还是在IStuService接口中定义方法，并且在StuServiceIml中对sql分页实现。
ql分页语句如下：select * from table limit index, pageSize;
所以在service中计算出currIndex：要开始查询的第一条记录的索引。
三.拦截器分页
上面提到的数组分页和sql语句分页都不是我们今天讲解的重点，今天需要实现的是利用拦截器达到分页的效果。自定义拦截器实现了拦截所有以ByPage结尾的查询语句，并且利用获取到的分页相关参数统一在sql语句后面加上limit分页的相关语句，一劳永逸。不再需要在每个语句中单独去配置分页相关的参数了。。
首先我们看一下拦截器的具体实现，在这里我们需要拦截所有以ByPage结尾的所有查询语句，因此要使用该拦截器实现分页功能，那么再定义名称的时候需要满足它拦截的规则(以ByPage结尾)，
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.executor.parameter.ParameterHandler;
import org.apache.ibatis.executor.resultset.ResultSetHandler;
import org.apache.ibatis.executor.statement.StatementHandler;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.plugin.*;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.reflection.SystemMetaObject;
import java.sql.Connection;
import java.util.Map;
import java.util.Properties;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/58e86cbfc7909757bf6a4a1f64bd3465/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-28T09:48:37+08:00" />
<meta property="article:modified_time" content="2021-01-28T09:48:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql分页3种方式_分页实现的三种方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>三种分页的实现方式</p> 
 <p>(1)每次取查询结果的所有数据，然后根据页面显示指定的记录</p> 
 <p>(2)根据页面只取一页的数据，然后显示这一页，这里要构造sql语句</p> 
 <p>(3)取一定页数的数据，就是前两种的折中</p> 
 <p>实现分页的步骤：</p> 
 <p>1.创建一个用于封装分页相关属性及操作的类</p> 
 <p>2.从页面增加分页导航条的功能</p> 
 <p>3.实现分页查询功能，从页面请求-&gt;Servlet-&gt;DAO的实现</p> 
 <p>这里还要注意的是这些数据是放在request还是session中，这里一一讨论</p> 
 <p>1.一般不会放在session中，因为会占用大量内存，所以要放在request里面。</p> 
 <p>优点：实现比较简单，查询速度比较快。</p> 
 <p>缺点：占用内存多一些，网络传输数据多。</p> 
 <p>对于数据量比较少的查询这种方法比较合适。这里有人把数据放在session中，这样换页的时候就不用重新查询，但是这样是极其不好的，强烈建议不要这样使用。</p> 
 <p>2.肯定不会放在session中，因为放在session中没有意义。</p> 
 <p>优点：占用内存少。</p> 
 <p>缺点：比较麻烦，必须先获得查询结果的总数，因为要知道有多少纪录才知道有多少页。另外要构造分页查询语句，对于不同的数据库是不一样的。</p> 
 <p align="center"><img src="https://images2.imgbox.com/55/68/sFtzmQI0_o.png" alt="3367b4182c96bbb06b2377df331f909d.png"></p> 
 <p>一.借助数组进行分页</p> 
 <p>原理：进行数据库查询操作时，获取到数据库中所有满足条件的记录，保存在应用的临时数组中，再通过List的subList方法，获取到满足条件的所有记录。</p> 
 <p>实现：</p> 
 <p>首先在dao层，创建StudentMapper接口，用于对数据库的操作。在接口中定义通过数组分页的查询方法，如下所示：</p> 
 <p>List</p> 
 <p>创建StudentMapper.xml文件，编写查询的sql语句：</p> 
 <p align="center"><img src="https://images2.imgbox.com/47/c6/PI0wyKGS_o.png" alt="530b4ca5b7b6e422aa74a0d47a382b9d.png"></p> 
 <p>可以看出再编写sql语句的时候，我们并没有作任何分页的相关操作。这里是查询到所有的学生信息。</p> 
 <p>接下来在service层获取数据并且进行分页实现：</p> 
 <p>定义IStuService接口，并且定义分页方法：</p> 
 <p align="center"><img src="https://images2.imgbox.com/44/16/gbNIl6jv_o.png" alt="1e05432379d3c71506798e8ee0759d2a.png"></p> 
 <p>通过接收currPage参数表示显示第几页的数据，pageSize表示每页显示的数据条数。</p> 
 <p>创建IStuService接口实现类StuServiceIml对方法进行实现，对获取到的数组通过currPage和pageSize进行分页：</p> 
 <p align="center"><img src="https://images2.imgbox.com/de/ef/qEFmj9kI_o.png" alt="12de71f495a35c4c4d9bc4e1c9c5bdfc.png"></p> 
 <p>通过subList方法，获取到两个索引间的所有数据。</p> 
 <p>最后在controller中创建测试方法：</p> 
 <p align="center"><img src="https://images2.imgbox.com/4d/58/6qnWiVpV_o.png" alt="6e2ec46a375117d6384807999a663a51.png"></p> 
 <p>通过用户传入的currPage和pageSize获取指定数据。</p> 
 <p>二.借助Sql语句进行分页</p> 
 <p>在了解到通过数组分页的缺陷后，我们发现不能每次都对数据库中的所有数据都检索。然后在程序中对获取到的大量数据进行二次操作，这样对空间和性能都是极大的损耗。所以我们希望能直接在数据库语言中只检索符合条件的记录，不需要在通过程序对其作处理。这时，Sql语句分页技术横空出世。</p> 
 <p>实现：通过sql语句实现分页也是非常简单的，只是需要改变我们查询的语句就能实现了，即在sql语句后面添加limit分页语句。</p> 
 <p>首先还是在StudentMapper接口中添加sql语句查询的方法，如下：</p> 
 <p>List</p> 
 <p align="center"><img src="https://images2.imgbox.com/46/fb/wtmTmS2z_o.png" alt="226622f87aa614ef4041cf7ce58fca70.png"></p> 
 <p>接下来还是在IStuService接口中定义方法，并且在StuServiceIml中对sql分页实现。</p> 
 <p align="center"><img src="https://images2.imgbox.com/b8/19/WoNga1RO_o.png" alt="18d611f24f15d0926abd8a0fb02d2e69.png"></p> 
 <p>ql分页语句如下：select * from table limit index, pageSize;</p> 
 <p>所以在service中计算出currIndex：要开始查询的第一条记录的索引。</p> 
 <p>三.拦截器分页</p> 
 <p>上面提到的数组分页和sql语句分页都不是我们今天讲解的重点，今天需要实现的是利用拦截器达到分页的效果。自定义拦截器实现了拦截所有以ByPage结尾的查询语句，并且利用获取到的分页相关参数统一在sql语句后面加上limit分页的相关语句，一劳永逸。不再需要在每个语句中单独去配置分页相关的参数了。。</p> 
 <p>首先我们看一下拦截器的具体实现，在这里我们需要拦截所有以ByPage结尾的所有查询语句，因此要使用该拦截器实现分页功能，那么再定义名称的时候需要满足它拦截的规则(以ByPage结尾)，</p> 
 <p align="center"><img src="https://images2.imgbox.com/e8/ff/3HR9VO5O_o.png" alt="a9f6bc88bb1a5e6002502e863c54f806.png"></p> 
 <p>import org.apache.ibatis.executor.Executor;</p> 
 <p>import org.apache.ibatis.executor.parameter.ParameterHandler;</p> 
 <p>import org.apache.ibatis.executor.resultset.ResultSetHandler;</p> 
 <p>import org.apache.ibatis.executor.statement.StatementHandler;</p> 
 <p>import org.apache.ibatis.mapping.MappedStatement;</p> 
 <p>import org.apache.ibatis.plugin.*;</p> 
 <p>import org.apache.ibatis.reflection.MetaObject;</p> 
 <p>import org.apache.ibatis.reflection.SystemMetaObject;</p> 
 <p>import java.sql.Connection;</p> 
 <p>import java.util.Map;</p> 
 <p>import java.util.Properties;</p> 
 <p>/**</p> 
 <p>Created by chenboge on 2017/5/7.</p> 
 <p>description:</p> 
 <p>*/</p> 
 <p>/**</p> 
 <p>@Intercepts 说明是一个拦截器</p> 
 <p>@Signature 拦截器的签名</p> 
 <p>type 拦截的类型 四大对象之一( Executor,ResultSetHandler,ParameterHandler,StatementHandler)</p> 
 <p>method 拦截的方法</p> 
 <p>args 参数</p> 
 <p>*/</p> 
 <p>@Intercepts({@Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class, Integer.class})})</p> 
 <p>public class MyPageInterceptor implements Interceptor {<!-- --></p> 
 <p>//每页显示的条目数</p> 
 <p>private int pageSize;</p> 
 <p>//当前现实的页数</p> 
 <p>private int currPage;</p> 
 <p align="center"><img src="https://images2.imgbox.com/8f/1e/HORvIJqr_o.png" alt="197a5dab6c5907189add427d440b3e97.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/99/7a/IDbWwjbR_o.png" alt="89048bf50db082f58818003edc433e5c.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/09/5a/0AJXx0P8_o.png" alt="e3458970fd60e9e92872fab4c65d3fe1.png"></p> 
 <p>//如果项目中分页的pageSize是统一的，也可以在这里统一配置和获取，这样就不用每次请求都传递pageSize参数了。参数是在配置拦截器时配置的。</p> 
 <p>String limit1 = properties.getProperty("limit", "10");</p> 
 <p>this.pageSize = Integer.valueOf(limit1);</p> 
 <p>this.dbType = properties.getProperty("dbType", "mysql");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>上面即是拦截器功能的实现，在intercept方法中获取到select标签和sql语句的相关信息，拦截所有以ByPage结尾的select查询，并且统一在查询语句后面添加limit分页的相关语句，统一实现分页功能。</p> 
 <p>重点详解：</p> 
 <p>StatementHandler是一个接口，而我们在代码中通过StatementHandler statementHandler = (StatementHandler) invocation.getTarget();获取到的是StatementHandler默认的实现类RoutingStatementHandler。而RoutingStatementHandler只是一个中间代理，他不会提供具体的方法。那你可能会纳闷了，拦截器中基本上是依赖statementHandler获取各种对象和属性的，没有具体属性和方法怎么行？？接着看下面代码：</p> 
 <p>private final StatementHandler delegate;</p> 
 <p align="center"><img src="https://images2.imgbox.com/20/0b/1ENXCsVc_o.png" alt="994a05dd26dc33062e74f0ddc9381d6d.png"></p> 
 <p>原来它是通过不同的MappedStatement创建不同的StatementHandler实现类对象处理不同的情况。这里的到的StatementHandler实现类才是真正服务的。看到这里，你可能就会明白MappedStatement mappedStatement = (MappedStatement) MetaObjectHandler.getValue("delegate.mappedStatement");中delegate的来源了吧。至于为什么要这么去获取，后面我们会说道。</p> 
 <p>拿到statementHandler后，我们会通过MetaObject MetaObjectHandler = SystemMetaObject.forObject(statementHandler);去获取它的包装对象，通过包装对象去获取各种服务。</p> 
 <p>接下来说说：MappedStatement mappedStatement = (MappedStatement) MetaObjectHandler.getValue("delegate.mappedStatement");</p> 
 <p>上面提到为什么要这么去获取MappedStatement对象？？在RoutingStatementHandler中delegate是私有的(private final StatementHandler delegate;)，有没有共有的方法去获取。所以这里只有通过反射来获取啦。</p> 
 <p>MappedStatement是保存了xxMapper.xml中一个sql语句节点的所有信息的包装类，可以通过它获取到节点中的所有信息。在示例中我们拿到了id值，也就是方法的名称，通过名称区拦截所有需要分页的请求。</p> 
 <p>通过StatementHandler的包装类，不光能拿到MappedStatement，还可以拿到下面的数据：</p> 
 <p align="center"><img src="https://images2.imgbox.com/a4/35/t8oG3f1U_o.png" alt="91308504977d7a28530f93e40e567b10.png"></p> 
 <p>上面的所有数据都可以通过反射拿到。</p> 
 <p>几个重要的参数：</p> 
 <p>Configuration：所有配置的相关信息。</p> 
 <p>ResultSetHandler：用于拦截执行结果的组装。</p> 
 <p>ParameterHandler：拦截执行Sql的参数的组装。</p> 
 <p>Executor：执行Sql的全过程，包括组装参数、组装结果和执行Sql的过程。</p> 
 <p>BoundSql：执行的Sql的相关信息。</p> 
 <p>接下来我们通过如下代码拿到请求时的map对象(反射)。</p> 
 <p align="center"><img src="https://images2.imgbox.com/c1/52/7DbzMYgn_o.png" alt="bb5422f00c0817f118d448eed29f05ab.png"></p> 
 <p>如上所示，还能在里面配置一些属性，在拦截器的setProperties方法中可以获取配置好的属性值。如项目分页的pageSize参数的值固定，我们就可以配置在这里了，以后就不需要每次传入pageSize了，读取方式如下：</p> 
 <p align="center"><img src="https://images2.imgbox.com/61/20/iQvlR4YX_o.png" alt="c130ba2fac13437108431aafdf19ad87.png"></p> 
 <p>到这里，有关拦截器的相关知识就讲解的差不多了，接下来就需要测试，是否我们这样写真的有效？？</p> 
 <p>首先还是添加dao层的方法和xml文件的sql语句配置，注意项目中拦截的是以ByPage结尾的请求，所以在这里，我们的方法名称也以此结尾：</p> 
 <p>方法</p> 
 <p align="center"><img src="https://images2.imgbox.com/e7/eb/tb8ND431_o.png" alt="8ecbe0afedc116253e72b0801f5d026a.png"></p> 
 <p>实现：</p> 
 <p align="center"><img src="https://images2.imgbox.com/f2/1b/1QtkdmLu_o.png" alt="ecbb5ac70c9f76c88646725eab595246.png"></p> 
 <p>这里我们虽然传入了currPage和pageSize两个参数，但是在sql的xml文件中并没有使用，直接在拦截器中获取到统一使用。</p> 
 <p>最后编写controller的测试代码：</p> 
 <p align="center"><img src="https://images2.imgbox.com/e5/d7/a7yRjGMB_o.png" alt="f405dfaf81317cf4684e84959f2af11a.png"></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f11ab9a8578b5b4fab1a187c4fdf928f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Unity】Opencv使用问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0659cb6167d6ded8a1f9396561842b06/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">漏洞定级标准参考</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>