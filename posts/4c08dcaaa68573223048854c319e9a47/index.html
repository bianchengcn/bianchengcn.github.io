<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机考研复试问题汇总（408&#43;计算机前言知识） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机考研复试问题汇总（408&#43;计算机前言知识）" />
<meta property="og:description" content="一、数据库 https://www.cnblogs.com/wenxiaofei/p/9853682.html
Q：数据库中的事务了解吗？事务的四大特性？
数据库事务是数据库运行中的逻辑工作单位，单个逻辑工作单元所执行的一系列操作，要么都执行，要么都不执行。例如银行取款事务分为2个步骤(1)存折减款(2)提取现金，2个步骤必须同时完成或者都不完成。
数据库事务的四大特性（ACID)：
(1) 原子性(Atomicity)：
事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。
(2)一致性(Consistency) ：
事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。
(3)分离性(Isolation)：
分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。
(4)持久性(Durability)：
持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。
Q：如何理解数据库的范式？
第一范式（1NF）：确保每一列的原子性；如果每一列都是不可再分的最小数据单元，则满足第一范式。
第二范式:非键字段必须依赖于键字段；如果一个关系满足1NF，并且除了主键以外的其它列，都依赖与该主键，则满足二范式(2NF)，第二范式要求每个表只描述一件事。
第三范式：在2NF的基础上，不存在传递依赖
Q：什么叫视图？游标是什么？
视图：是一种虚拟的表，具有和物理表相同的功能，它可以对试图进行增删改查操作，试图通常是一个表或者多个表的行或者列的子集，对视图的修改会不影响基本表。它使得我们获取数据更容易，相比多表查询。
游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。
Q：视图的优缺点
优点：
①简化了操作，把经常使用的数据定义为视图。
②安全性，视图随着基表的变化而更新，但不会通过视图修改基本表的数据，保证了数据的安全性
③可以合并分离的数据，创建分区视图，更好的实现数据的对比
缺点：
①性能：SQL Server必须把视图的查询转化成对基本表的查询，如果这7a64e78988e69d8331333236373831个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，SQL Server也把它变成一个复杂的结合体，需要花费一定的时间。
②修改限制：当用户试图修改视图的某些行时，SQL Server必须把它转化为对基本表的某些行的修改。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的。
Q：数据库为什么需要锁机制？有哪些锁机制？
https://www.cnblogs.com/xiaofengwang/p/11291944.html
保证数据库事务的一致性；防止出现（数据库的隔离级别：脏读，不可重复读，幻读等并发事件https://www.jianshu.com/p/d9389f27ca1a）
锁分为行级锁、表级锁、悲观锁、乐观锁
Q：drop、truncate、 delete区别
drop直接删掉表。truncate删除表中数据，再插入时自增长id又从1开始。delete删除表中数据，可以加where字句。 Q：理解数据库的触发器
Q：重要的SQL语句举例
二、离散数学 Q：
三、计算机网络 Q：谈谈对TCP/IP协议的理解
Q：TCP的三次握手和四次挥手
Q：TCP和UDP的区别
1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP对系统资源要求较多，UDP对系统资源要求较少。
Q：拥塞控制和流量控制都是什么，两者的区别？
流量控制是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。 拥塞控制是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。
Q：访问一个网页的过程
https://blog.csdn.net/huangwei18351/article/details/81456228
1、解析baidu.com域名对应的ip地址
1.1使用ARP（Address Resolution Protocol）地址解析协议获得默认网关的MAC地址；
1.2组织数据发送给默认网关（ip还是DNS服务器的ip，但是MAC地址变成了默认网关的MAC地址）；
1.3默认网关具有转发数据的能力，他把数据转发给路由器；
1.4路由器根据自己的路由协议，选择一个合适的较快的路径转发数据给目的网关（DNS服务器所在的网关）；
1.5目的网关把数据转发给 DNS服务器；
1.6DNS服务器查询解析出baidu.com对应的IP地址，并将此IP地址俺原路返回给请求这个域名IP的客户端。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/4c08dcaaa68573223048854c319e9a47/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-12T01:52:28+08:00" />
<meta property="article:modified_time" content="2020-04-12T01:52:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机考研复试问题汇总（408&#43;计算机前言知识）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、数据库</h3> 
<p><a href="https://www.cnblogs.com/wenxiaofei/p/9853682.html" rel="nofollow">https://www.cnblogs.com/wenxiaofei/p/9853682.html</a></p> 
<p><span style="color:#f33b45;"><strong>Q：数据库中的事务了解吗？事务的四大特性？</strong></span></p> 
<p>数据库事务是数据库运行中的逻辑工作单位，单个逻辑工作单元所执行的一系列操作，要么都执行，要么都不执行。例如银行取款事务分为2个步骤(1)存折减款(2)提取现金，2个步骤必须同时完成或者都不完成。</p> 
<p>数据库事务的四大特性（ACID)：</p> 
<p>(1) 原子性(Atomicity)：<br>      事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。<br> (2)一致性(Consistency) ：<br>     事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。<br> (3)分离性(Isolation)：<br>    分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。<br> (4)持久性(Durability)：<br>    持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。</p> 
<p><span style="color:#f33b45;"><strong>Q：如何理解数据库的范式？</strong></span></p> 
<p>第一范式（1NF）：确保每一列的原子性；如果每一列都是不可再分的最小数据单元，则满足第一范式。</p> 
<p>第二范式:非键字段必须依赖于键字段；如果一个关系满足1NF，并且除了主键以外的其它列，都依赖与该主键，则满足二范式(2NF)，第二范式要求每个表只描述一件事。</p> 
<p>第三范式：在2NF的基础上，不存在传递依赖</p> 
<p><strong>Q：<span style="color:#f33b45;">什么叫视图？</span>游标是什么？</strong></p> 
<p>视图：是一种虚拟的表，具有和物理表相同的功能，它可以对试图进行增删改查操作，试图通常是一个表或者多个表的行或者列的子集，对视图的修改会不影响基本表。它使得我们获取数据更容易，相比多表查询。</p> 
<p>游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p> 
<p><span style="color:#f33b45;"><strong>Q：视图的优缺点</strong></span></p> 
<p><strong>优点：</strong></p> 
<p>①简化了操作，把经常使用的数据定义为视图。</p> 
<p>②安全性，视图随着基表的变化而更新，但不会通过视图修改基本表的数据，保证了数据的安全性</p> 
<p>③可以合并分离的数据，创建分区视图，更好的实现数据的对比</p> 
<p><strong>缺点：</strong></p> 
<p>①性能：SQL Server必须把视图的查询转化成对基本表的查询，如果这7a64e78988e69d8331333236373831个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，SQL Server也把它变成一个复杂的结合体，需要花费一定的时间。<br><br> ②修改限制：当用户试图修改视图的某些行时，SQL Server必须把它转化为对基本表的某些行的修改。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的。</p> 
<p><strong>Q：数据库为什么需要锁机制？有哪些锁机制？</strong></p> 
<p><a href="https://www.cnblogs.com/xiaofengwang/p/11291944.html" rel="nofollow">https://www.cnblogs.com/xiaofengwang/p/11291944.html</a></p> 
<p>保证数据库事务的一致性；防止出现（数据库的隔离级别：脏读，不可重复读，幻读等并发事件<a href="https://www.jianshu.com/p/d9389f27ca1a" rel="nofollow">https://www.jianshu.com/p/d9389f27ca1a</a>）</p> 
<p>锁分为行级锁、表级锁、悲观锁、乐观锁</p> 
<p><strong>Q：drop、truncate、 delete区别</strong></p> 
<ul><li>drop直接删掉表。</li><li>truncate删除表中数据，再插入时自增长id又从1开始。</li><li>delete删除表中数据，可以加where字句。</li></ul> 
<p><strong>Q：理解数据库的触发器</strong></p> 
<p><strong>Q：重要的SQL语句举例</strong></p> 
<h3><strong>二、离散数学</strong></h3> 
<p><strong>Q：</strong></p> 
<p> </p> 
<p> </p> 
<h3><strong>三、计算机网络</strong></h3> 
<p><span style="color:#f33b45;"><strong>Q：谈谈对TCP/IP协议的理解</strong></span></p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/56/2d/lbA7Bwvu_o.png" width="473"></p> 
<p><strong>Q：TCP的三次握手和四次挥手</strong></p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/51/24/Sxh7JSDK_o.png" width="451"></p> 
<p><span style="color:#f33b45;"><strong>Q：TCP和UDP的区别</strong></span></p> 
<p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p> 
<p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p> 
<p>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p> 
<p>3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p> 
<p>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p> 
<p>5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p> 
<p><strong>Q：拥塞控制和流量控制都是什么，两者的区别？</strong></p> 
<p>流量控制是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。 <br> 拥塞控制是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。</p> 
<p><span style="color:#f33b45;"><strong>Q：访问一个网页的过程</strong></span></p> 
<p><a href="https://blog.csdn.net/huangwei18351/article/details/81456228">https://blog.csdn.net/huangwei18351/article/details/81456228</a></p> 
<p><a href="https://blog.csdn.net/huangwei18351/article/details/81456228">1、解析baidu.com域名对应的ip地址<br>       1.1使用ARP（Address Resolution Protocol）地址解析协议获得默认网关的MAC地址；<br>       1.2组织数据发送给默认网关（ip还是DNS服务器的ip，但是MAC地址变成了默认网关的MAC地址）；<br>       1.3默认网关具有转发数据的能力，他把数据转发给路由器；<br>       1.4路由器根据自己的路由协议，选择一个合适的较快的路径转发数据给目的网关（DNS服务器所在的网关）；<br>       1.5目的网关把数据转发给    DNS服务器；<br>       1.6DNS服务器查询解析出baidu.com对应的IP地址，并将此IP地址俺原路返回给请求这个域名IP的客户端。<br> 2、得到baidu.com对应的IP后，客户端会发送TCP的三次握手，进行连接；<br> 3、连接成功后，使用HTTP协议发送请求数据包给WEB服务器；<br> 4、web服务器受到数据请求后，通过查询自己的服务器的到对应的结果，并将结果原路返回给浏览器；<br> 5、浏览器收到数据后，通过浏览器的渲染结果来显示网页；<br> 6、浏览器关闭TCP，即四次挥手离别。</a><br>  </p> 
<h3><strong>四、操作系统</strong></h3> 
<p><a href="https://zhuanlan.zhihu.com/p/124284469" rel="nofollow">https://zhuanlan.zhihu.com/p/124284469</a></p> 
<p><span style="color:#f33b45;"><strong>Q：操作系统的特点？</strong></span></p> 
<ol><li>– 共享：资源可被多个并发执行的进程使用</li><li>– 并发：可以在同一时间间隔处理多个进程，需要硬件支持</li><li>– 虚拟：将物理实体映射成为多个虚拟设备</li><li>– 异步：进程执行走走停停，每次进程执行速度可能不同，但OS需保证进程每次执行结果相同</li></ol> 
<p><span style="color:#f33b45;"><strong>Q：操作系统的主要功能是什么？</strong></span></p> 
<ol><li>处理机管理（包括进程控制、进程同步、进程通信、调度）</li><li>存储器管理（内存分配（静态/动态/连续/非连续分配）、内存包含、地址映射（逻辑地址--&gt;物理地址）、内存扩充（虚拟存储技术））</li><li>设备管理（缓冲管理、设备分配、设备处理（启动设备、中断设备））</li><li>文件管理（文件存储空间管理、目录管理、文件读/写保护）</li></ol> 
<p><span style="color:#f33b45;"><strong>Q：操作系统发展过程？</strong></span></p> 
<ol><li>　无操作系统（人工操作方式）：用户独占、CPU等待人工</li><li>　单道批处理：内存只保存一道作业</li><li>　多道批处理：运行多个程序同时存在主存中</li><li>　分时：及时接收、及时处理，交互性</li><li>　实时：实时控制、实时信息处理</li></ol> 
<p><span style="color:#f33b45;"><strong>Q：进程和线程的区别？</strong></span><br> 线程被称作轻量级进程，在进程中包含线程。进程有独立的内存空间，不同进程间不能直接共享其他进程资源，同一个进程内的线程共享进程内存空间；相比进程，线程切换对系统开销更小一些；进程是资源分配的最小单位，线程是程序执行的最小单位。</p> 
<p><img alt="图示" height="291" src="https://images2.imgbox.com/e3/12/yG3Wd4RH_o.png" width="485"></p> 
<p><strong>Q：进程的三个组成部分？</strong><br> 程序段、数据段、PCB(Process Control Block)</p> 
<p><strong>Q：进程切换的过程？</strong><br> 保持处理机上下文 -&gt; 更新PCB -&gt; 把PCB移入相应队列(就绪、阻塞) -&gt; 选择另一个进程并更新其PCB -&gt; 更新内存管理的数据结构 -&gt; 恢复处理机上下文</p> 
<p><span style="color:#f33b45;"><strong>Q：进程通信的方式</strong></span><br> 1、低级通信方式<br> PV操作（信号量机制）。<br> – P：wait(S)原语，申请S资源<br> – V：signal(S)原语，释放S资源<br> 2、高级通信方式：以较高效率传输大量数据的通信方式<br> – 共享存储（使用同步互斥工具操作共享空间）<br> – 消息传递（进程间以格式化的消息进行数据交换，有中间实体，分为直接和间接两种，底层通过发送消息和接收消息两个原语实现）<br> – 管道通信（两个进程中间存在一个特殊的管道文件，进程的输入输出都通过管道，半双工通信）</p> 
<p><strong>Q：管程是什么？</strong><br> 由一组数据及对这组数据操作的定义组成的模块。同一时间只能有一个进程使用管程，即管程是互斥使用的，进程释放管程后需唤醒申请管程资源的等待队列上的进程。进程只有通过进入管程并使用管程内部的操作才能访问其中数据</p> 
<p><span style="color:#f33b45;"><strong>Q：进程的五种状态是什么？</strong></span></p> 
<p>　　创建、就绪、阻塞、执行、终止</p> 
<p><img alt="preview" height="77" src="https://images2.imgbox.com/42/4d/JAKCtKUq_o.png" width="457"></p> 
<p> </p> 
<p><strong>Q：线程间的同步与通信类型有哪些？</strong></p> 
<p>　　1.互斥锁mutex</p> 
<p>　　2.条件变量</p> 
<p>　　3.信号量机制</p> 
<p><strong>Q：线程的实现方式有哪几种？</strong></p> 
<p>　　1.内核支持线程（核内切换快，开销小，模式间切换慢）</p> 
<p>　　2.用户级线程（节省模式间切换的开销）</p> 
<p>　　3.混合</p> 
<p><span style="color:#f33b45;"><strong>Q：产生死锁的原因有哪些？</strong></span></p> 
<ol><li>　　对互斥资源分配不当</li><li>　　进程推进顺序不当</li></ol> 
<p><strong>Q：处理产生死锁的办法有哪些？</strong></p> 
<ol><li>　预防死锁（破坏产生死锁的必要条件</li><li>    避免死锁；3.检测死锁；4.解除死锁</li></ol> 
<p><strong>Q：死锁的产生和避免?</strong></p> 
<p>死锁的四个必要条件：<br> (1)互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。<br> (2)请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。<br> (3)非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。<br> (4)循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。</p> 
<p>　死锁避免（deadlock avoidence）是在系统运行过程中注意避免死锁的发生。这就要求每当申请一个资源时，系统都应根据一定的算法判断是否认可这次申请，使得在今后一段时间内系统不会出现死锁。这面方最著名的算法首推Dijkstra[1965]提出的银行家（banker）算法。</p> 
<p><strong>Q：死锁与饥饿的区别？</strong><br> – 都是资源分配问题<br> – 死锁是等待永远不会释放的资源，而饥饿申请的资源会被释放，只是永远不会分配给自己<br> – 一旦产生死锁，则死锁进程必然是多个，而饥饿进程可以只有一个<br> – 饥饿的进程可能处于就绪状态，而死锁进程一定是阻塞进程</p> 
<p><strong>Q：FCB包含什么？</strong><br> 文件指针：上次读写位置。<br> 文件打开数：多少个进程打开了此文件。<br> 文件磁盘位置。<br> 文件的访问权限：创建、只读、读写等。</p> 
<p><strong>Q：页面置换算法？</strong><br> 最佳置换算法OPT<br> 先进先出置换算法FIFO<br> 最近最久未使用算法LRU<br> 时钟算法LOCK<br> 改进型时钟算法</p> 
<p><span style="color:#f33b45;"><strong>Q：批处理作业调度算法？</strong><br> 先来先服务FCFS<br> 最短作业优先SJF<br> 最高响应比优先HRN<br> 多级队列调度算法</span></p> 
<p><span style="color:#f33b45;"><strong>Q：进程调度算法？</strong><br> 先进先出FIFO<br> 时间片轮转算法RR<br> 最高优先级算法HPF<br> 多级队列反馈算法</span></p> 
<p><strong>Q：磁盘调度算法？</strong><br> 先来先服务FCFS<br> 最短寻道时间优先SSTF<br> 扫描算法SCAN<br> 循环扫描算法C-SCAN</p> 
<p><strong>Q：FAT（File Allocation Table）？</strong><br> 分配给文件的所有盘块号都放在FAT中，记录了文件的物理位置。</p> 
<p><strong>Q：什么是中断？</strong></p> 
<p>1.中断的引入——为了支持CPU和设备之间的并行操作<br> 中断也称外中断，指来自CPU执行指令以外的事件的发生，如设备发出的I/O结束中断、时钟中断等。这一类中断通常是与当前执行的指令无关的事件。<br> 2.异常的引入——表示CPU执行指令本身时出现的问题<br> 异常也称内中断、例外或陷入，指源自CPU执行指令内部的事件，如程序的非法操作码、地址越界、算术溢出、缺页异常等。对异常的处理一般要依赖与当前程序的运行现场，不能被屏蔽。<br><br><strong>3.中断和异常的联系与区别</strong></p> 
<p><img alt="" height="116" src="https://images2.imgbox.com/69/04/Wy7CwU7b_o.png" width="319"></p> 
<p><span style="color:#f33b45;"><strong>Q：中断和系统调用区别？</strong></span><br> 中断：解决处理器速度和硬件速度不匹配，是多道程序设计的必要条件。每个中断都有自己的数字标识，当中断发生时，指令计数器PC和处理机状态字PSW中的内容自动压入处理器堆栈，同时新的PC和PSW的中断向量也装入各自的寄存器中。这时，PC中包含的是该中断的中断处理程序的入口地址，它控制程序转向相应的处理，当中断处理程序执行完毕，该程序的最后一条iret（中断返回），它控制着恢复调用程序的环境。 中断和系统调用的区别: 中断是由外设产生, 无意的, 被动的 系统调用是由应用程序请求操作系统提供服务产生, 有意的, 主动的。要从用户态通过中断进入内核态。（联系） 中断过程：中断请求 中断响应 断点保护 执行中断服务程序 断点恢复 中断返回 系统调用过程：应用程序在用户态执行时请求系统调用，中断，从用户态进入内核态，在内核态执行相应的内核代码。</p> 
<p><span style="color:#f33b45;"><strong>Q：处理机调度有哪几层？</strong></span></p> 
<ol><li>　高级调度（后备作业--&gt;内存）</li><li>　中级调度（进程--&gt;外存）</li><li>　低级调度（进程/线程调度）</li></ol> 
<p><strong>Q：页面置换算法有哪些？</strong></p> 
<p>　　最佳页面置换算法、最近最久未使用算法、时钟置换算法</p> 
<p><span style="color:#f33b45;"><strong>Q：I/O控制方式有哪些？</strong></span></p> 
<ol><li>　程序控制I/O方式（CPU与I/O设备只能串行工作）</li><li>　中断驱动方式</li><li>　DMA（仅在开始和结束才需要CPU干预）</li></ol> 
<p><strong>Q：存储器的层次结构有哪些？</strong></p> 
<p>　　外存、主存、快速缓存、寄存器</p> 
<p><strong>Q：存储管理方案有哪些？</strong></p> 
<p>　　分区存储管理、分页存储管理、分段存储管理、段页式存储管理、虚拟存储管理</p> 
<p><strong>Q：设备管理采用的相关缓冲技术有哪些？</strong></p> 
<ol><li>　通道技术（使数据传输独立于CPU）（增加设备到主机之间的通路，使主存和设备之间有两条以上的通路）</li><li>　DMA技术（数据在主存与I/O设备间直接成块传送）</li><li>　缓冲技术（硬件缓冲、软件缓冲）</li><li>　Spooling技术（使独占设备虚拟为多台设备）</li></ol> 
<h3><strong>五、计算机组成原理</strong></h3> 
<p><strong>Q：</strong><strong>什么是冯诺伊曼结构？</strong></p> 
<p>输入输出，计算单元，控制单元，存储单元。</p> 
<p><strong>Q：高速缓存的作用</strong></p> 
<p>连接CPU和内存。</p> 
<p><strong>Q：cache和寄存器区别？</strong></p> 
<p>寄存器是暂时存储的CPU组成部分，cache用来做高度CPU和低速的主存之间加速带。</p> 
<p><strong>Q：指令系统</strong></p> 
<p>CISC复杂指令集，RISC是精简指令集。</p> 
<p><strong>Q：流水线</strong></p> 
<p>将重复性的过程分为若干个子过程来完成。</p> 
<p><strong>Q：总线和I/O</strong></p> 
<p>总线是指数据通信的连接线，有地址，数据，控制指令。</p> 
<p>I/O的方式有程序性，中断性，通道,DMA。<br>  </p> 
<p> </p> 
<h3><strong>六、数据结构</strong></h3> 
<p><strong>Q：迅速编写出算法（快排，冒泡，最短路）</strong></p> 
<p><strong>Q：什么是二叉树，红黑树，AVL树</strong></p> 
<p> </p> 
<h3><strong>七、面向对象程序设计</strong></h3> 
<p><strong>Q：C和C++还有java的区别</strong></p> 
<p><strong>Q：指针和引用的区别？</strong><br> 1.指针是一个存储地址的变量，该地址为内存的一个存储单元；引用是原变量的一个别名；<br> 2.指针可以为空，而引用不能为空；<br> 3.指针可以有多级，而引用只能有一级；<br> 4指针可以重新赋值，而引用只能初始化一次<br> 5.sizeof引用得到的是变量大小，而sizeof指针得到的是指针本身大小<br><strong>将引用作为函数返回值的好处是？</strong><br> 在内存中不会产生被返回值的副本，同时不能返回局部变量的引用，因为随着调用结束局部变量会被销毁。</p> 
<p><strong>Q：三种传参方式？</strong></p> 
<p>值传递：传递的是实参的一个拷贝，修改形参不会改变实参值。<br> 地址传递：传递的是实参地址的一个拷贝，修改形参不会改变实参值。<br> 引用传递：传递的是实参的一个别名，修改形参会导致改变实参。<br> 被调用函数的形参只有在被调用时才会临时分配存储单元，一旦调用结束则释放内存。<br><strong>Q：const作用？</strong><br> 被const修饰符修饰的变量不能被修改。const *x表明x数据是常量，不能修改；*const x表明指针本身是常量，x的指针不能指向其他内存地址，x本身可被修改；*const *x表明x本身数据和地址都不能被修改。</p> 
<p><strong>Q：static作用？</strong><br> 被static修饰符修饰的变量在整个文件中都是可见的，而在文件外是不可见的。该变量在全局数据区分配内存。C++中由程序运行new出的动态数据存放在堆区，而函数内部局部变量存放在栈区。<br> 静态局部变量：在函数内部定义static变量，第一次运行到这里初始化，存储到全局数据区，下一次执行到这里不会再重新初始化。<br> static变量如果没有显式初始化，默认初始值为0。 静态函数不能被其他函数所调用。</p> 
<p><span style="color:#f33b45;"><strong>Q：面向对象的三个要素(基本特征)？</strong></span><br> 1、封装：将客观事物封装成类，隐藏实现细节，模块化代码。<br> 2、多态：实现多态的两种方式——覆盖(重写)和重载。<br> 覆盖是子类重新定义父类的虚函数，与多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。<br> 重载是存在多个同名函数，但是函数的参数个数不同。这些函数实际上成为了不同的函数，对它们的调用在编译期间就已经确定，属于早绑定，与多态无关。<br> 3、继承：子类继承父类功能，对父类功能进行扩展。</p> 
<p><strong>Q：结构体和联合有什么区别？</strong><br> (1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。<br> (2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。</p> 
<p><strong>Q：C++是不是类型安全的语言？</strong><br> 不是。不同类型间指针可以强制互转。</p> 
<p><strong>Q：const与#define区别？</strong></p> 
<p>（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。<br> （2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 <br> （3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。<br> （4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。</p> 
<p><strong>Q：基类的析构函数为什么是虚函数？</strong><br> 为了防止派生类析构函数未执行，造成资源泄露。</p> 
<p><strong>Q：#include尖括号和双引号区别？</strong><br> &lt;&gt;是标准头文件，“”是非系统头文件</p> 
<p><strong>Q：为什么有了指针，还要使用引用？</strong><br> 为了支持运算符的重载。更加方便。</p> 
<p><strong>Q：如何避免野指针？</strong><br> 声明指针记得初始化，暂时不用就指向NULL；使用malloc分配内存，必须经过显式释放(free)，避免内存泄漏。</p> 
<h3>八 软件开发</h3> 
<p><strong>Q：类之间的关系有哪些？</strong><br> 继承：类继承另一个类的功能<br> 实现：类实现接口的功能<br> 依赖：A类的某个方法使用到了B类<br> 关联：强依赖关系，B类作为一个属性出现在了A类<br> 聚合：一种特别的关联，公司与个人的关系<br> 组合：强聚合关系，整体与部分的联系更紧密，如汽车与轮胎</p> 
<p><strong>Q：软件工程标准步骤？</strong></p> 
<p>问题定义<br> 可行性研究<br> 需求分析<br> 总体设计<br> 详细设计<br> 编码和单元测试<br> 综合测试<br> 软件维护<br><strong>Q：有哪些软件测试分类？</strong><br> 黑盒测试：不考虑软件内部原理，以用户角度测试软件输入输出<br> 白盒测试：知道软件内部工作过程，确定每个分支都能按照预定正常工作<br> 灰盒测试：集合白盒黑盒<br> 冒烟测试：测试软件基本功能，快速<br> 系统测试：验证系统是否满足需求规格的黑盒类测试<br> 性能测试：负载测试和压力测试<br> 安全测试：假扮黑客侵入系统<br> 兼容性测试：不同平台不同环境下的测试</p> 
<p><strong>Q：自顶向下和自底向上测试方法的区别？</strong><br> 自顶向下：从程序入口主控模块开始，按照系统程序结构，沿着控制层次从上而下测试各模块。方便把握整体结构，早期可发现顶层错误。<br> 自底向上：从最底层模块，即叶子结点开始，按照调用从下而上的测试各模块。最后一个模块提交后才能完整系统测试，某些模块可以提前测试。</p> 
<p><strong>Q：软件工程的三要素？</strong><br> 方法、工具、过程。</p> 
<p><strong>Q：软件工程的主要模型？</strong><br> 1、瀑布模型：前一阶段工作结束才可以进行下一阶段工作。基于文档，易于维护，但加大了工作量。</p> 
<p>2、快速原型：快速建立可以运行的程序，完成的功能是最终软件的一个子集。不带反馈环，满足用户真实需求，但会导致系统设计差，难以维护。</p> 
<p>3、增量模型：每个阶段不交付完整产品，软件由一系列增量构件组成。降低开发风险，易于维护，但不容易控制整体过程</p> 
<p>4、螺旋模型：结合快速原型和瀑布模型，有利于软件重用，减少风险，风险人员需要一定经验。</p> 
<p>5、喷泉模型：迭代，无缝，节省开发时间。</p> 
<p>6、敏捷</p> 
<p><br><strong>Q：什么是死代码？</strong><br> 永远不会被执行到的代码。</p> 
<p><strong>Q：内聚和耦合</strong><br> 内聚：指一个好的内聚模块内应当尽量只做一件事，描述的是模块内的功能联系。<br> 耦合：各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度。<br> （1）内聚类型低→高：功能内聚、信息内聚、通信内聚、过程内聚、时间内聚、逻辑内聚、偶然内聚<br> （2）耦合类型高→低：内容耦合、公共耦合、外部耦合、控制耦合、标记耦合、数据耦合、非直接耦合</p> 
<h3><strong>八、杂七杂八计算机前沿知识</strong></h3> 
<p><strong>Q：什么是神经网络？</strong></p> 
<p><span style="color:#f33b45;"><strong>Q：什么是人工智能，谈谈你对她的理解？</strong></span></p> 
<p><strong>Q：用过哪些搜索引擎，他们的区别是什么</strong></p> 
<p><strong>Q：你认为的计算机发展前景，那些方面比较热门</strong></p> 
<p><span style="color:#f33b45;"><strong>Q：什么是数据挖掘</strong></span></p> 
<p><strong>Q：什么是嵌入式系统</strong></p> 
<p><strong>Q：什么是机器学习？讲讲具体的算法。你认为你本科学的数学有哪些会用到机器学习中？</strong></p> 
<p><strong>Q：什么是大数据？你接触到的最大的数据有多大？</strong></p> 
<p><strong>Q：大数据和机器学习之前有什么联系？</strong></p> 
<p><strong>Q：什么是云计算？</strong></p> 
<p><strong>Q：什么是深度学习？</strong></p> 
<p> </p> 
<p><span style="color:#f33b45;"><strong>云计算？</strong></span><br> 云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池，这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。</p> 
<p><span style="color:#f33b45;"><strong>大数据的特点？</strong></span><br> 1.Volume:数据量巨大<br> 体量大是大数据区分于传统数据最显著的特征。一般关系型数据库处理的数据量在TB级，大数据所处理的数据量通常在PB级以上。<br> 2.Variety:数据类型多<br> 大数据所处理的计算机数据类型早已不是单一的文本形式或者结构化数据库中的表，它包括订单、日志、BLOG、微博、音频、视频等各种复杂结构的数据。<br> 3.Velocity:数据流动快<br> 速度是大数据区分于传统数据的重要特征。在海量数据面前，需要实时分析获取需要的信息，处理数据的效率就是组织的生命。<br> 4.Value:数据潜在价值大<br> 在研究和技术开发领域，上述三个特征已经足够表征大数据的特点。但在商业应用领域，第四个特征就显得非常关键！投入如此巨大的研究和技术开发的努力，就是因为大家<br> 都洞察到了大数据的潜在巨大价值。如何通过强大的机器学习和高级分析更迅速地完成数据的价值“提纯”，挖掘出大数据的潜在价值，这是目前大数据应用背景下苛待解决的难题。</p> 
<p><strong>大数据发展的瓶颈？</strong><br> 没有成熟的方法采集和处理大数据。<br> 数据涉及到隐私，法律法规还没有完善。<br> 大量不同类别的数据不知道怎么存储。<br> 数据的独占性：有价值的数据别人不一定会分享。<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/46c29cf364ef46704eefa3b7fcdbaf4b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/00af626b4a86713a3af0fc932c349965/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【python】opencv教程CV2模块——图片处理，裁剪缩放加边框</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>