<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java  菜单列表转菜单树 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java  菜单列表转菜单树" />
<meta property="og:description" content="需求中经常遇到菜单列表转菜单树的情况，如果知道顶级菜单的话，有工具类可以使用，还是很方便的，hutool有一个TreeUtil类可以帮我们实现此功能，代码如下：
1.menu对象
@Data @EqualsAndHashCode(callSuper = false) @Accessors(chain = true) @ApiModel(value = &#34;Menu对象&#34;, description = &#34;菜单表&#34;) public class Menu implements Serializable { private static final long serialVersionUID = 1L; @TableId(value = &#34;id&#34;, type = IdType.ASSIGN_ID) private String id; @ApiModelProperty(value = &#34;上级id&#34;) private String parentId; @ApiModelProperty(value = &#34;名称&#34;) private String name; @ApiModelProperty(value = &#34;路径&#34;) private String url; @ApiModelProperty(value = &#34;类型&#34;) private Integer type; @ApiModelProperty(value = &#34;排序&#34;) private Integer sort; @ApiModelProperty(value = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f0092e63c7a00d75d4bd5226ac52e3ea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-26T16:42:23+08:00" />
<meta property="article:modified_time" content="2021-03-26T16:42:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java  菜单列表转菜单树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>需求中经常遇到菜单列表转菜单树的情况，如果知道顶级菜单的话，有工具类可以使用，还是很方便的，hutool有一个TreeUtil类可以帮我们实现此功能，代码如下：</p> 
<p>1.menu对象</p> 
<pre><code class="language-html hljs">@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@ApiModel(value = "Menu对象", description = "菜单表")
public class Menu implements Serializable {

  private static final long serialVersionUID = 1L;

  @TableId(value = "id", type = IdType.ASSIGN_ID)
  private String id;

  @ApiModelProperty(value = "上级id")
  private String parentId;

  @ApiModelProperty(value = "名称")
  private String name;

  @ApiModelProperty(value = "路径")
  private String url;

  @ApiModelProperty(value = "类型")
  private Integer type;

  @ApiModelProperty(value = "排序")
  private Integer sort;

  @ApiModelProperty(value = "是否删除")
  @TableField("is_deleted")
  @TableLogic
  private Boolean deleted;

  @ApiModelProperty(value = "创建时间")
  @TableField(fill = FieldFill.INSERT)
  private LocalDateTime createTime;

  @ApiModelProperty(value = "更新时间")
  @TableField(fill = FieldFill.INSERT_UPDATE)
  private LocalDateTime updateTime;
}</code></pre> 
<p>2.接口需要返回的菜单节点</p> 
<pre><code class="language-html hljs">@ApiModelProperty("菜单")
private List&lt;Tree&lt;String&gt;&gt; menus;</code></pre> 
<p>3.调用方法</p> 
<pre><code class="language-html hljs">vo.setMenus(
    TreeUtil.build(
        menus, // 菜单列表
        "", // 顶级菜单的id
        (menu, treeMenu) -&gt;{
          treeMenu.setId(menu.getId()).setParentId(menu.getParentId()).setName(menu.getName());
          treeMenu.putExtra("url", menu.getUrl());
          treeMenu.putExtra("type", menu.getType());
        }));</code></pre> 
<p>如果只有菜单列表，不知道顶级菜单，那要怎么转成菜单树呢？这是本文的重点了。但是很少用到是真的。上代码：</p> 
<p>1.首先定义菜单树</p> 
<pre><code class="language-html hljs">@Data
@ApiModel("菜单树DTO")
public class MenuTreeDTO implements Serializable {
  private static final long serialVersionUID = 1L;

  @ApiModelProperty(value = "编码")
  private String id;
  @ApiModelProperty(value = "名称")
  private String name;
  @ApiModelProperty(value = "父级编码")
  private String parentId;
  @ApiModelProperty(value = "路由")
  private String url;
  @ApiModelProperty(value = "类型")
  private String type;
  @ApiModelProperty(value = "子集")
  private List&lt;MenuTreeDTO&gt; children;
}</code></pre> 
<p>2.转换方法</p> 
<pre><code class="language-html hljs">/**
 * 菜单转菜单树
 * @param menus
 * @return
 */
private static List&lt;MenuTreeDTO&gt; convertMenuTree(List&lt;Menu&gt; menus) {
  // 菜单map
  Map&lt;String, MenuTreeDTO&gt; menuMap = menus.stream().map(menu -&gt; {
      MenuTreeDTO menuTree = BeanUtil.copyProperties(menu, MenuTreeDTO.class);
     return menuTree;
  }).collect(Collectors.toMap(MenuTreeDTO::getId, Function.identity()));
  // 菜单子集map
  HashMap&lt;String, List&lt;MenuTreeDTO&gt;&gt; menuChildMap = new HashMap&lt;&gt;(2);
  menus.forEach(menu -&gt; {
    MenuTreeDTO menuTree = BeanUtil.copyProperties(menu, MenuTreeDTO.class);
    // 找到父级节点，若子级已经在父节点了，跳过，否则加入父节点
    MenuTreeDTO parentMenu = menuMap.get(menu.getParentId());
    if (null != parentMenu) {
      if (CollUtil.isNotEmpty(parentMenu.getChildren())) {
        if (!getHasExist(parentMenu.getChildren(), menuTree.getId())) {
          parentMenu.getChildren().add(menuTree);
        }
      } else {
        parentMenu.setChildren(new ArrayList&lt;MenuTreeDTO&gt;() {<!-- -->{ add(menuTree); }});
      }
      // 如果父节点是别人的子节点，别人的子节点需要重新设置，这也是上方为什么需要判断子节点是否已经存在
      MenuTreeDTO grandMenu = menuMap.get(parentMenu.getParentId());
      if (null != grandMenu) {
        if (CollUtil.isNotEmpty(grandMenu.getChildren())) {
          if (getHasExist(grandMenu.getChildren(), parentMenu.getId())) {
            MenuTreeDTO menuTreeDTO = getMenuTree(grandMenu.getChildren(), parentMenu.getId());
            menuTreeDTO.setChildren(parentMenu.getChildren());
          } else {
            grandMenu.getChildren().add(parentMenu);
          }
        } else {
          grandMenu.setChildren(new ArrayList&lt;MenuTreeDTO&gt;() {<!-- -->{ add(parentMenu); }});
        }
      }
    }
    List&lt;MenuTreeDTO&gt; menuTrees = menuChildMap.get(menu.getParentId());
    if (CollUtil.isNotEmpty(menuTrees)) {
      menuTrees.add(menuTree);
    } else {
      menuChildMap.put(menu.getParentId(), new ArrayList&lt;MenuTreeDTO&gt;() {<!-- -->{ add(menuTree); }});
    }
  });
  // 经过以上处理，有子级的被当成了‘树干’，有的可能是别人的子级，需要从‘树干’上移除掉
  Set&lt;Entry&lt;String, List&lt;MenuTreeDTO&gt;&gt;&gt; entrySet = menuChildMap.entrySet();
  Iterator&lt;Entry&lt;String, List&lt;MenuTreeDTO&gt;&gt;&gt; iterator = entrySet.iterator();
  while (iterator.hasNext()) {
    Entry&lt;String, List&lt;MenuTreeDTO&gt;&gt; entry = iterator.next();
    MenuTreeDTO menuTree = menuMap.get(entry.getKey());
    if (null != menuTree &amp;&amp; null != menuMap.get(menuTree.getParentId())) {
      iterator.remove();
    }
  }
  // 修剪掉树叶后，循环输出树【特别注意：如果菜单链断裂，比如应该是A-&gt;B-&gt;C,但是菜单列表只有A、C，A、C会被当成不相关的元素输出】
  List&lt;MenuTreeDTO&gt; menuTrees = new ArrayList&lt;&gt;();
  menuChildMap.forEach((parendMenuId, menuTreeList) -&gt; {
    MenuTreeDTO menuTree = menuMap.get(parendMenuId);
    if (null != menuTree) {
      menuTrees.add(menuTree);
    }
  });
  return menuTrees;
}

/**
 * 获取菜单
 * @param menuTrees
 * @param menuId
 * @return
 */
private static MenuTreeDTO getMenuTree(List&lt;MenuTreeDTO&gt; menuTrees, String menuId) {
  MenuTreeDTO result = null;
  for(MenuTreeDTO menuTree : menuTrees) {
    if (menuId.equals(menuTree.getId())) {
      result = menuTree;
      break;
    }
  }
  return result;
}

/**
 * 判断是否已存在
 * @param menuTrees
 * @param menuId
 * @return
 */
private static boolean getHasExist(List&lt;MenuTreeDTO&gt; menuTrees, String menuId) {
  List&lt;String&gt; menuIds = menuTrees.stream().map(MenuTreeDTO::getId).collect(Collectors.toList());
  return menuIds.contains(menuId);
}</code></pre> 
<p>3.调用转换方法</p> 
<p>①.接口出参类型需要修改：</p> 
<pre><code class="language-html hljs">@ApiModelProperty("菜单")
private List&lt;MenuTreeDTO&gt; menus;</code></pre> 
<p>②.调用转换方法</p> 
<p>vo.setMenus(convertMenuTree(menus));</p> 
<p>上面的代码是自己设计，手敲，调试的，肯定有不完善，甚至是错误的地方，欢迎指正。</p> 
<p> </p> 
<p><span style="color:#f33b45;">正式测试的时候，脑袋突然灵光一闪，没必要费那么大劲写这个树转化方法啊，循环菜单列表，递归找菜单的父级，直到顶级，然后调用人家提供好的工具类。我了个法克。</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/02e23c489ab06d44efbd4e44b3faa4b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">centos7.2安装mysql</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67c401367f248fe12bde6b7425eb02f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">8种MySQL分页方法总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>