<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL的varchar字段最大长度真的是65535吗？ - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL的varchar字段最大长度真的是65535吗？" />
<meta property="og:description" content="在mysql建表sql里，我们经常会有定义字符串类型的需求。
CREATE TABLE `user` ( `name` varchar(100) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;名字&#39; ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ; 比方说user表里的名字，就是个字符串。mysql里有两个类型比较适合这个场景。
char和varchar。
声明它们都需要在字段边上加个数组，比如char(100)和varchar(100)，这个100是指当前字段能放的最大字符数。
char和varchar的区别在于，varchar虽然声明了最大能放100个字符，但一开始不需要分配100个字符的空间，可以根据需要慢慢增加空间。而char一开始声明是多少，就固定预留多少空间。
所以，varchar比起char更省空间，一般没啥大事，大家都爱用varchar。
那问题来了，声明varchar字段时，它的最大长度是多少呢？
相信大家应该听说过varchar字段的最大长度是65535吧。
没听过也没关系，你现在听到了。
但实际上是这样吗？
我们来做个实验。
varchar最大值是多少 我们直接拿65535来试一下。
长度为65535的varchar报错 很明显报错了。
报错内容也说了, 由于列长度过大导致报错，最长是16383。
把上面的65535改成 16383，确实是成功了。
哦？所以说varchar最大值是16383？
当然不是。
这其实还有好几个因素影响这这个最大值。
不同字符集的影响 varchar里放的是字符串，而字符串看起来可以是英文字母，也可以是数字或中文。但不管怎么样，都可以把这样的中英文数字转成二进制的01串。
按照一定规则把符号和二进制码对应起来，这就是编码。而把n多这种已经编码的字符聚在一起，就是我们常说的字符集。
建表语句里有个CHARSET，这里填的是字符集。
不同的字符集要求使用的字节个数也不同，我们可以通过 show charset; 看到mysql支持哪些字符集，以及这些字符集里存储一个字符所需的最大字节数（Maxlen）。
查看mysql支持哪些charset 我们尝试下把建表sql语句里的CHARSET改一改，比如改成utf8mb3。
我们再执行下，会发现，最大值又不一样了。
utf8mb3下的报错 并且，上面虽然提示max=21845，但要是真执行起来会发现还是报错。在改为21844之后才成功。
不讲武德。
再把字符集改为 latin1。会发现，最大值会是 65533。
varchar为65533时创建成功 这里渐渐可以发现规律。
utf8mb4的maxlen=4，对应varchar最大长度=16383。4*16383 = 65532。
utf8mb3的maxlen=3，对应varchar最大长度=21844。3*21844 = 65532。
latin1的maxlen=1，对应varchar最大长度=65533。 1 * 65533 = 65533。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/e06120e8786f3485d9732ce3626a8770/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-18T08:45:34+08:00" />
<meta property="article:modified_time" content="2023-04-18T08:45:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL的varchar字段最大长度真的是65535吗？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>在mysql建表sql里，我们经常会有定义<strong>字符串</strong>类型的需求。</p> 
 <pre class="has"><code class="language-go">CREATE TABLE `user` (
  `name` varchar(100) NOT NULL DEFAULT '' COMMENT '名字'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ;</code></pre> 
 <p>比方说user表里的名字，就是个字符串。mysql里有两个<strong>类型</strong>比较适合这个场景。</p> 
 <p><strong>char和varchar。</strong></p> 
 <p>声明它们都需要在字段边上加个数组，比如<strong>char(100)</strong>和<strong>varchar(100)</strong>，这个100是指当前字段能放的<strong>最大字符数</strong>。</p> 
 <p><strong>char和varchar的区别</strong>在于，varchar虽然声明了最大能放100个字符，但一开始不需要分配100个字符的空间，可以根据需要慢慢增加空间。而char一开始声明是多少，就固定预留多少空间。</p> 
 <p>所以，varchar比起char更省空间，一般没啥大事，大家都爱用<strong>varchar</strong>。</p> 
 <p>那问题来了，声明<strong>varchar</strong>字段时，它的最大长度是多少呢？</p> 
 <p><strong>相信大家应该听说过varchar字段的最大长度是65535吧。</strong></p> 
 <p>没听过也没关系，你现在听到了。</p> 
 <p>但实际上是这样吗？</p> 
 <p>我们来做个实验。</p> 
 <h4>varchar最大值是多少</h4> 
 <p>我们直接拿65535来试一下。</p> 
 <img title="长度为65535的varchar报错" src="https://images2.imgbox.com/77/25/qQzlGQsp_o.png" alt="33b09134f3880eff905410fe5a9659ff.png"> 
 <figcaption>
   长度为65535的varchar报错 
 </figcaption> 
 <p>很明显报错了。</p> 
 <p>报错内容也说了, <strong>由于列长度过大导致报错，最长是16383</strong>。</p> 
 <p>把上面的65535<strong>改成 16383，确实是成功了。</strong></p> 
 <p>哦？所以说varchar最大值是16383？</p> 
 <p>当然不是。</p> 
 <p>这其实还有好几个因素影响这这个最大值。</p> 
 <h4>不同字符集的影响</h4> 
 <p>varchar里放的是字符串，而字符串看起来可以是英文字母，也可以是数字或中文。但不管怎么样，都可以把这样的中英文数字转成二进制的01串。</p> 
 <p>按照一定规则把符号和二进制码对应起来，这就是<strong>编码</strong>。而把n多这种已经编码的字符聚在一起，就是我们常说的<strong>字符集</strong>。</p> 
 <p>建表语句里有个<strong>CHARSET</strong>，这里填的是<strong>字符集。</strong></p> 
 <p>不同的字符集要求使用的字节个数也不同，我们可以通过 <code>show charset;</code> 看到mysql支持哪些字符集，以及这些字符集里<strong>存储一个字符所需的最大字节数（Maxlen）。</strong></p> 
 <img title="查看mysql支持哪些charset" src="https://images2.imgbox.com/f1/6e/B7V7DrT8_o.png" alt="e7480ce23efa46ca33d7b77ced1eeed1.png"> 
 <figcaption>
   查看mysql支持哪些charset 
 </figcaption> 
 <p>我们尝试下把建表sql语句里的CHARSET改一改，比如改成<strong>utf8mb3</strong>。</p> 
 <p>我们再执行下，会发现，最大值又不一样了。</p> 
 <img title="utf8mb3下的报错" src="https://images2.imgbox.com/a3/e1/9uAC0iMy_o.png" alt="08cd0fb57f1fcf80b581b5f124b48cb8.png"> 
 <figcaption>
   utf8mb3下的报错 
 </figcaption> 
 <p>并且，上面虽然提示max=21845，但要是真执行起来会发现还是报错。<strong>在改为21844之后才成功。</strong></p> 
 <p>不讲武德。</p> 
 <p>再把<strong>字符集改为 latin1</strong>。会发现，<strong>最大值会是 65533</strong>。</p> 
 <img title="varchar为65533时创建成功" src="https://images2.imgbox.com/f4/b2/gCgleAoI_o.png" alt="25701cf3a3b5f8c7c8ef841b92b0e458.png"> 
 <figcaption>
   varchar为65533时创建成功 
 </figcaption> 
 <p>这里渐渐可以发现规律。</p> 
 <ul><li><p>utf8mb4的maxlen=4，对应varchar最大长度=16383。4*16383 = 65532。</p></li><li><p>utf8mb3的maxlen=3，对应varchar最大长度=21844。3*21844 = 65532。</p></li><li><p>latin1的maxlen=1，对应varchar最大长度=65533。   1 * 65533 = 65533。</p></li></ul> 
 <p>也就是说varchar边上的长度代表的是这一列能放的最大<strong>字符数</strong>，而maxlen代表单个字符占用的最大<strong>字节数</strong>。相乘的结果很接近65535。说明<strong>65535是指的字节数</strong>，而<strong>不是字符数</strong>。</p> 
 <p>也就是说varchar的最大长度，根据选择的字符集的不同，会有区别。</p> 
 <p>总的来说接近于 65535 除以 字符集的maxlen。</p> 
 <p><strong>但其实这样还不够严谨</strong>。还有其他影响因素。</p> 
 <h4>是否可以为NULL的影响</h4> 
 <p>上面的建表语句里声明了test字段都是<code>NOT NULL</code>，也就是非空，如果我们将这个改成可以为NULL，再用 <strong>CHARSET=latin1</strong>去试试。这时候就会发现，前面NOT NULL的时候最大能使用65533去建表，现在报错了。</p> 
 <p>改成65532，就能成功了，也就是最长长度<strong>少了1个字节</strong>。</p> 
 <img title="是否为NULL的影响" src="https://images2.imgbox.com/a8/c1/Gc5pHoX3_o.png" alt="a8ee245ee1870c5d9d2e2e3b498611eb.png"> 
 <figcaption>
   是否为NULL的影响 
 </figcaption> 
 <p>这是因为一个字段是否为NULL这件事情，是需要<strong>一个字节</strong>去记录下来的。</p> 
 <p>而当字段为<strong>NOT NULL</strong>的时候，则可以省下这个字节。</p> 
 <h4>列数的影响</h4> 
 <p>上面提到的情况都是在表里只有一列时的结果，当我们表里<strong>有更多的列</strong>时，我们会发现varchar的最大值还会有变化。比如同样还是latin1字符集，我们再增加一列varchar类型，并且用的还是前面允许的最大值65533。</p> 
 <p>结果发现这次会失败。</p> 
 <img title="两个varchar列的情况" src="https://images2.imgbox.com/19/74/w4r7AghW_o.png" alt="612217ad478c0d0e24b076b60cdc7d05.png"> 
 <figcaption>
   两个varchar列的情况 
 </figcaption> 
 <p>查了一下资料发现，原来65535是mysql单行的最大长度（不包含blob和text等类型的情况下）</p> 
 <p>mysql表里单行中的<strong>所有列加起来</strong>（不考虑其他隐藏列和记录头信息） ，占用的最大长度是65535个字节。</p> 
 <p><strong>注意上面加粗的部分，加起来不超过65535。</strong></p> 
 <p>比如如果还有int的列，那它占用4个字节，bigint占用8个字节，字段越多，留给单个varchar列的空间就越少。</p> 
 <p>因此，<strong>前面提到的 varchar 的最大长度，接近于 65535 除以 字符集的maxlen，但前提是只有一列not null 的varchar类型的字段。</strong></p> 
 <h4>为什么不是65535而是65533？</h4> 
 <p>不过问题又来了，上面建表sql里，不管是那种字符集，最后得到的字符数都约等于65533。</p> 
 <p>但数据库单行最大值应该是65535。<strong>65535 - 65533 = 2 。这里面还差了个2</strong>，为什么呢？</p> 
 <p>这就要聊一下mysql单行里数据到底是怎么存储的。</p> 
 <h5>数据表行存储的格式</h5> 
 <p>我们可以通过 <code>show table status</code> 命令，查看到当前表格使用的行格式。</p> 
 <img title="查看到当前表格使用的行格式" src="https://images2.imgbox.com/9d/50/4APFHUhB_o.png" alt="63061b9666f19838a7e4d21f88b38f31.png"> 
 <figcaption>
   查看到当前表格使用的行格式 
 </figcaption> 
 <p>通过上面的 <code>Row_format</code> 字段可以看到这个表用的是 <code>Dynamic</code> 行格式。</p> 
 <p>事实上，现在的mysql数据表一般都是采用Dynamic行记录格式。</p> 
 <p>我们来看下<code>Dynamic</code>行格式长什么样子。</p> 
 <img title="Dynamic行记录格式" src="https://images2.imgbox.com/ba/69/3vJHhk0S_o.png" alt="b4f86cc0410f72c544dc890107f53861.png"> 
 <figcaption>
   Dynamic行记录格式 
 </figcaption> 
 <p>Dynamic格式将行记录分为两部分，分为是<strong>行记录的额外信息</strong>和<strong>行记录的真实数据</strong>。</p> 
 <p><strong>行记录的额外信息：</strong></p> 
 <ul><li><p><strong>变长字段长度列表</strong>：指的是varchar，text，blob这种类型，它们属于变长字段，这里表示的就是这些字段的长度。</p></li><li><p><strong>NULL值列表</strong>：用来记录当前行里哪些列是为null的。如果全部列都是not null的话，那就不需要有这个字段。</p></li><li><p><strong>记录头信息</strong>：这是固定5个字节，用来记录一些特殊的信息，比如这一行是否被删了，这一行在这个16k的数据页内是不是最小的，以及指向下一条记录的指针之类的一些信息，不需要太关注。</p></li></ul> 
 <p><strong>行记录的真实数据：</strong></p> 
 <p>里面放的就是一行里，每一列的真正内容。除了我们建表时里涉及到的列以外，还有一些隐藏列。</p> 
 <p>比如Row_ID，这个是在建表是没有声明主键时，数据表自动会生成的隐藏主键。另外还有<code>trx_id</code>字段，用于记录当前这一行数据行是被<strong>哪个事务</strong>修改的，和一个<code>roll_pointer</code>字段，这个字段是用来指向当前这个数据行的上一个版本，通过这个字段，可以为这行数据形成一条版本链，从而实现<strong>多版本并发控制（MVCC）</strong>。有没有很眼熟，这个在之前写的<a href="" rel="nofollow">文章</a>里出现过。</p> 
 <img title="隐藏列有哪些" src="https://images2.imgbox.com/16/9f/kgk7EV4p_o.png" alt="3a3c360cd6dd1117943f6553b7c0fa72.png"> 
 <figcaption>
   隐藏列有哪些 
 </figcaption> 
 <p>所以我们回过头来看我们建的表，当只有一列not null的 varchar字段时，行记录长下面这样。</p> 
 <img title="单条varchar数据的Dynamic行记录格式.drawio" src="https://images2.imgbox.com/b4/f8/q3qgrBt3_o.png" alt="f62b75c3cbb785bcc3200112a048a855.png"> 
 <figcaption>
   单条varchar数据的Dynamic行记录格式.drawio 
 </figcaption> 
 <p>前面提到，行最大值65535字节是不包含隐藏列和记录头信息的，所以其实是指上图中红色的部分。</p> 
 <p>而最左边的<strong>变长字段长度列表</strong>中，为了表示varchar列的长度，占用了<strong>两个字节</strong>，也就是16位，2的16次方，最大可以表示65535的长度，正好足够用来表示varchar列当前的长度是65533。</p> 
 <p>所以<strong>65535 - 65533 = 2 。这里面差的2</strong>，是用来存<strong>varchar字段长度</strong>去了。</p> 
 <h4>一个页才16k，怎么保存65533（64k）数据？</h4> 
 <p>之前的文章里其实多次提到了mysql底层是以页的形式去存储数据的，而一个页固定16k，而一个varchar字段最大能放65533字节数据，换算一下大概是64k，整整4个16k的页。</p> 
 <img title="页结构" src="https://images2.imgbox.com/c2/13/8JZXaiSL_o.png" alt="44e421ac722f837fac8f7c59aa70e7fe.png"> 
 <figcaption>
   页结构 
 </figcaption> 
 <p>这里面是怎么实现的？</p> 
 <p>对于这种情况，其实行数据里针对这个超大的varchar字段只保存个20字节的指针（实际上是个偏移量），这个指针会指向新的页（off page），这些页里保存的是实际的varchar字段里的65533字节数据。这种由于字段过长导致需要额外的页来保存数据的现象叫<strong>行溢出</strong>。</p> 
 <img title="行溢出" src="https://images2.imgbox.com/17/f4/Sn0eyJCo_o.png" alt="08c8b3e61bdbdd1b3ef41b011ab90b78.png"> 
 <figcaption>
   行溢出 
 </figcaption> 
 <h4>大于64k的字符串该怎么处理？</h4> 
 <p>如果离谱点，数据量更大，比64k还大，这时候就不能继续用varchar了，需要改用text和blob类型字段。</p> 
 <p>而text和blob类型本身也是分TINY、MEDIUM，LONG三个档位的，对应着不同的数据长度，最大到4G左右。</p> 
 <p>像下面这样就可以将数据类型定义为LONGTEXT。</p> 
 <pre class="has"><code class="language-go">CREATE TABLE `test_max_length` (
  `test` LONGTEXT NOT NULL COMMENT '测试长度字段'
) ENGINE=InnoDB DEFAULT CHARSET=latin1 ;</code></pre> 
 <p>而他们的存储方式也跟varchar的情况类似，只保存20个字节的指针，实际数据保存在其他溢出页里。</p> 
 <p>以前我们查某一行数据，他们都在一个16k的数据页里，查询时只要一次磁盘IO就能将这个数据页读取出来。</p> 
 <p>当一个数据库里某行数据里有个特别大的字符串时，我们如果还想把整行数据给读出来，那我们还得把<strong>off page</strong>的数据给全部读出来，这意味着<strong>更多的磁盘IO，性能就更差了</strong>。</p> 
 <p>为了规避这个问题，我们写<strong>select sql</strong>的时候，如果发现某列字段，是个特别长的字符串时，能不读它就尽量不加到select里，这也是为什么大家不建议使用<code>select * from table</code>的原因。</p> 
 <h5>blob和text的区别</h5> 
 <p>一般来说，blob和text都可以用来放超长字符串。但它们会有一点点区别。</p> 
 <p>我们知道字符集（charset）下还有个<strong>校对规则</strong>（collation）的概念，比如同样是a，大写A和小写a能不能算作是一个字符，这会影响比较和排序，collation就是定义这个规则用的。</p> 
 <p><strong>blob没有字符集的概念，而text有</strong>。这意味如果用blob来存文本的话，就没法用字符集的校对规则来排序和做比较。</p> 
 <p>还有一个区别，blob还能保存二进制数据，比如压缩过的文本数据，图片或者视频，别笑，虽然不合适，但我确实见过有人拿它来保存视频。。。</p> 
 <h4>总结</h4> 
 <ul><li><p>现在的mysql数据表一般采用Dynamic行记录格式。它由行记录的额外信息和行记录的真实数据组成。</p></li><li><p>mysql表里单行中的<strong>所有列加起来</strong>（不考虑其他隐藏列和记录头信息） ，占用的最大长度是65535个字节。</p></li><li><p>如果数据表里只有<strong>一列 not null</strong> 的varchar字段，它的最大长度，接近于 <strong>65535 除以 字符集的maxlen</strong>。</p></li><li><p>如果要存放大于64k的字段数据，可以考虑使用longtext和longblob等类型。</p></li><li><p>mysql的数据页大小是16k，为了保存varchar或者text，blob这种长度可能大于16k的字段，在Dynamic行格式中，会只保留<strong>20个字节</strong>的指针，实际数据则放在其他溢出页中。为了将它们读取出来，会需要更多的磁盘IO。</p></li><li><p>blob和text很像，但blob没有字符集的概念，并且还能存放二进制的数据，比如图片或视频，但实际上图片和视频更推荐放在对象存储（<strong>O</strong>bject <strong>S</strong>torage <strong>S</strong>ervice，简称<strong>oss</strong>）中。</p></li></ul> 
 <h4>参考资料</h4> 
 <p>《mysql技术内幕》</p> 
 <p>《从根儿理解mysql》</p> 
 <h4>最后</h4> 
 <p>别说了，一起在知识的海洋里呛水吧<br></p> 
 <p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br></p> 
 <p style="text-align:left;">- END -</p> 
 <p style="text-align:center;">扫码关注公众号「网管叨bi叨」</p> 
 <p style="text-align:center;">给网管个星标，第一时间吸我的知识 👆</p> 
 <p style="text-align:left;">网管整理了一本《Go 开发参考书》收集了70多条开发实践。去公众号回复【gocookbook】领取！还有一本《k8s 入门实践》讲解了常用软件在K8s上的部署过程，公众号回复【k8s】即可领取！</p> 
 <p style="text-align:right;">觉得有用就点个在看  👇👇👇</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65695b1c058c71919978791eb52fd218/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">实验一：Shamir 秘密共享</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/34a13e3eb8b6a13ad52193a718d8ad89/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows添加自定义右键菜单</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>