<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>非科班进大厂必备算法，没压中找我拿红包 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="非科班进大厂必备算法，没压中找我拿红包" />
<meta property="og:description" content="基础数据结构的融合是成为庞大系统的基石。比如Redis中的跳跃表，数据库索引B&#43;树等，只有对基础的数据结构足够的熟悉才能更容易去理解稍微复杂的结构，就仿佛我们闯关打怪一样，一步一步解锁直到结局。今天想和大家一起分享的是常见数据结构以及面试中的高频手撕算法题，一定要去手动写这些代码，可说百分之七八十都是这些题，一定要好好掌握。
1 数据结构 链表属于数据结构中的线性结构的一种，我们先看看什么是数据结构
数据结构是：结构的定义&#43;结构的操作 想必大伙儿应该玩儿过拼图，拼图之前我们先看看说明书，看看包含几个部分，然后对这些部分进行拼装，随后拼好候进行组合直到完成。
那么数据结构中的结构定义是这个数据结构长什么样子，有些什么性质？结构的操作意思是这个结构可以支持什么操作，但是不管你怎么的操作，不能破坏了它的结构
2 链表定义 一个链表是由1个或者多个节点组成，每个节点包含两个信息，一个是数据信息，用来存储数据，一个是地址信息，用来存储下个节点的地址。
链表结构由一个个节点组成，我们不需要对结构做任何改变，只需要按照需求修改链表结构中的数据域即可。从上图我们知道此事数据域类型为整型763，指针域为0x56432，这个地址正好是第二个节点的地址，所以这两个节点在逻辑上是有个指向关系，也是通过这种方式将两个节点进行了关联。
第二个节点中的指针域为0x0，这是一个特殊的地址，叫做空地址，指向空地址意味着它是这个链表结构的最后一个节点。
那在代码中是什么样子呢
struct Node { int data; struct Node *next; }; 这个结构很清晰，数据域根据我们的需求而定，想存整型就改成整型，想存字符串就写字符串。而指针域用来维护整个链表结构，一般来说直接用即可，如果需要内存中的链表结构，一定要修改节点内部next指针域中存储的地址值
3 链表操作 说到链表结构，我们习惯性的和数组联系在一起。只是数组结构在内存中是连续的，而链表结构因为指针域的存在，每个节点在内存中存储的位置未必连续。下面我们按照数组的方式给链表也编个号。
下面我们定义一个向链表插入节点的函数
struct Node *insert(struct Node *head, int ind, struct Node *a); 第一个参数为待操作的链表的头结点地址，也就是第一个节点的地址第二个参数为插入位置第三个参数为指针变量，指向要插入的新节点 简单的说就是向 head 指向的链表的 ind 位置插入一个由 a 指向的节点，返回值为插入新节点后的表头地址。为什么要返回它呢？因为我们插入的节点很可能在头部，此时就会改变链表的结构且改变头结点地址，所以需要返回。
那么我们插入一个元素，显然会改变链表的节点，操作方法为修改链表节点的 next 指针域即可，那么为了插入成功，我们需要修改哪些节点呢？
首先是让 ind - 1 位置的节点指向 a 节点，然后是 a 节点指向原 ind 位置的节点，也就是说，涉及到两个节点的 next 指针域的值的修改，一个是 ind - 1 位置的节点，一个是 a 节点自身。我们就可以先找到 ind - 1 位置的节点，然后再进行相关操作即可。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/d5f2d9df2bf4bb427e43af56d99fc796/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-14T21:35:48+08:00" />
<meta property="article:modified_time" content="2020-09-14T21:35:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">非科班进大厂必备算法，没压中找我拿红包</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>基础数据结构的融合是成为庞大系统的基石。比如Redis中的跳跃表，数据库索引B+树等，只有对基础的数据结构足够的熟悉才能更容易去理解稍微复杂的结构，就仿佛我们闯关打怪一样，一步一步解锁直到结局。今天想和大家一起分享的是常见数据结构以及面试中的高频手撕算法题，一定要去手动写这些代码，可说百分之七八十都是这些题，一定要好好掌握。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/59/b9/9CCxg7Fq_o.png" alt="高频手撕算法合集"></p> 
<h3><a id="1__6"></a>1 数据结构</h3> 
<blockquote> 
 <p>链表属于数据结构中的<strong>线性结构</strong>的一种，我们先看看什么是数据结构</p> 
</blockquote> 
<ul><li>数据结构是：结构的定义+结构的操作</li></ul> 
<blockquote> 
 <p>想必大伙儿应该玩儿过拼图，拼图之前我们先看看说明书，看看包含几个部分，然后对这些部分进行拼装，随后拼好候进行组合直到完成。</p> 
</blockquote> 
<p>那么数据结构中的结构定义是这个数据结构长什么样子，有些什么性质？结构的操作意思是这个结构可以支持什么操作，但是不管你怎么的操作，不能<strong>破坏</strong>了它的结构</p> 
<h3><a id="2__16"></a>2 链表定义</h3> 
<blockquote> 
 <p>一个链表是由1个或者多个节点组成，每个节点包含两个信息，一个是<strong>数据信息</strong>，用来<strong>存储数据</strong>，一个是<strong>地址信息</strong>，用来存储下个节点的<strong>地址</strong>。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/dc/55/10je4KPM_o.png" alt="链表节点"><br> 链表结构由一个个节点组成，我们不需要对结构做任何改变，只需要按照需求修改链表结构中的<strong>数据域</strong>即可。从上图我们知道此事数据域类型为整型763，指针域为0x56432，这个地址正好是第二个节点的地址，所以这两个节点在逻辑上是有个<strong>指向关系</strong>，也是通过这种方式将两个节点进行了关联。</p> 
<p>第二个节点中的指针域为<strong>0x0</strong>，这是一个特殊的地址，叫做<strong>空地址</strong>，指向空地址意味着它是这个链表结构的最后一个节点。</p> 
<blockquote> 
 <p>那在代码中是什么样子呢</p> 
</blockquote> 
<pre><code>struct Node {
	int data;
	struct Node *next;
};
</code></pre> 
<p>这个结构很清晰，数据域根据我们的需求而定，想存整型就改成整型，想存字符串就写字符串。而指针域用来维护整个链表结构，一般来说直接用即可，如果需要内存中的链表结构，一定要修改节点内部next指针域中存储的地址值</p> 
<h3><a id="3__36"></a>3 链表操作</h3> 
<blockquote> 
 <p>说到链表结构，我们习惯性的和数组联系在一起。只是数组结构在<strong>内存中是连续</strong>的，而链表结构因为指针域的存在，每个节点在内存中存储的位置未必连续。下面我们按照数组的方式给链表也编个号。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/10/f2/fPxEzFx1_o.png" alt="单链表"></p> 
<p>下面我们定义一个向链表插入节点的函数</p> 
<pre><code class="prism language-c++">struct Node *insert(struct Node *head, int ind, struct Node *a);
</code></pre> 
<ul><li>第一个参数为待操作的链表的头结点地址，也就是第一个节点的地址</li><li>第二个参数为插入位置</li><li>第三个参数为指针变量，指向要插入的新节点</li></ul> 
<p>简单的说就是向 head 指向的链表的 ind 位置插入一个由 a 指向的节点，返回值为插入新节点后的<strong>表头地址</strong>。为什么要返回它呢？因为我们插入的节点很可能在头部，此时就会改变链表的结构且改变头结点地址，所以需要返回。</p> 
<p>那么我们插入一个元素，显然会改变链表的节点，操作方法为修改链表节点的 next 指针域即可，那么为了插入成功，我们需要修改哪些节点呢？</p> 
<p>首先是让 ind - 1 位置的节点指向 a 节点，然后是 a 节点指向原 ind 位置的节点，也就是说，涉及到两个节点的 next 指针域的值的修改，一个是 ind - 1 位置的节点，一个是 a 节点自身。我们就可以先找到 ind - 1 位置的节点，然后再进行相关操作即可。</p> 
<pre><code class="prism language-c++">struct Node *insert(struct Node *head, int ind, struct Node *a) {
	struct Node ret, *p = &amp;ret;
	ret.next = head;
	// 从虚拟头节点开始向后走 ind 步
	while (ind--) p = p-&gt;next;
	// 完成节点的插入操作
	a-&gt;next = p-&gt;next;
	p-&gt;next = a;
	// 返回真正的链表头节点地址
	return ret.next;
}
</code></pre> 
<p>这里非常关心且非常重要的是<strong>虚拟节点</strong>。我们为什么引入虚拟节点？是为了让我们的插入操作<strong>统一化</strong>？什么是统一化？举个例子，假设我们现在是在第5个位置插入元素，我们自然需要从头遍历到第四个节点，确定了第四个节点后，修改相关的next指针域，也就是如果我们想插入到 nid 位，就需要从头节点向后移动 ind-1 步，那么如果插入的位置为0呢？我们总不能走-1步吧，所以这个时候我们只好对ind=0的情况进行单独的判断了，这样明显是不完美了，所以我们为了统一ind在等于0和不等于0时的情况，引入虚拟节点。</p> 
<p>ok，我们看看是不是方便了。增加了虚拟节点，如果插入第5个位置，我们只需要向后移动5位，如果插入到0号位置，向后移动0步即可，即p指针指向虚拟节点不懂，直接将新的节点插入到虚拟头结点后面完事儿。</p> 
<p><img src="https://images2.imgbox.com/b4/a9/hVKQ9g6N_o.png" alt="虚拟节点"></p> 
<p>好勒，这里出现了第一个重要的技巧。在我们插入链表节点的时候，加上虚拟节点是个实用技巧。</p> 
<p>那么我们看看插入和删除的操作动态以及实现方式</p> 
<h3><a id="3__86"></a>3 案例</h3> 
<p><strong>案例1</strong></p> 
<blockquote> 
 <p>我们看个题吧，定义一个快乐数，什么是快乐数，所谓快乐数即通过有限次变换后等于1 的数字。怎么变换呢，给出一个非1的数字，然后出去位数，求各个位数的平方和，得到数字A，假设A不死1，那就继续对元素A的每一位进行平方和，得到数字B。。。。知道最后能够=1</p> 
</blockquote> 
<p>例如，一开始的数字是 19，经过变换规则 ，得到数字 82；因为不是 1 ，所以接着做变换，就是 ，再做一次变换 ，最后一次做变换，得到了 1 以后，停止</p> 
<p>这个题的难点不是判断数是不是快乐数，而是如何判断一个数<strong>不是</strong>快乐数，如果不是快乐数，说明没有办法通过有限的次数到达数字1，那么到底是 经过多少次呢？1k次，10w次？很难确定上限。在说这个问题之前我们先看几个<strong>高频链表</strong>练习题</p> 
<p><strong>例题1 用数组判断链表中是否有环</strong></p> 
<blockquote> 
 <p>在上面我们介绍了最后一个节点指向空，可是你有没有想过如果链表的最后一个节点不是空地址而是指向链表中的一个节点，这不就是环了？</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ea/dc/hMM1R6eh_o.png" alt="链表环"></p> 
<p>如上图所示，节点8指向了3，这样形成了3,4,5,6,7,8的环状结构，此时使用指针遍历链表将永无止境。那通过什么办法判断是否有环呢？</p> 
<ul><li> <p>使用数组标记的方法。记录<strong>出现过</strong>的节点信息，每次遍历新节点就去数组查看记录，这样的时间复杂度不给力。经过第一个节点，需要在数组查找0次，第2个节点，数组查找1次，第i个节点，在数组查找i-1次，直到遍历第n+1个节点，查找的总次数为(n + 1) * n / 2，这样时间复杂度为O(n^2)。太慢了，给我优化</p> </li><li> <p><strong>快慢指针法</strong></p> </li></ul> 
<blockquote> 
 <p>AB两位同学跑步，A同学速度快，B同学速度慢，他们并不知道跑道是环形的，如果是环形，跑得快的，在足够的时间终究会从速度慢的B同学经过，形成相遇的情况。如果不是环形，速度快的先到重点，不会相遇—快慢指针法。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/97/7c/qeyGxXy9_o.png" alt="快慢指针"></p> 
<p>在这里，我们将链表当做跑道，跑道上两个指针，指针A每次走两步，指针B每次走两步，如果快的指针先跑到终点注定没有环，如果两指针相遇则有环。</p> 
<pre><code class="prism language-c++">int hasCycle(struct Node *head) {
	if (head == NULL) return 0;
    // p 是慢指针，q 是快指针
    struct Node *p = head, *q = head;
	// 每次循环，p 走1步，q 走2步
	do {
            p = p-&gt;next;
            q = q-&gt;next;
            if (q == NULL) return 0;
			q = q-&gt;next;
		} while (p != q &amp;&amp; q);
	return p == q;
}
</code></pre> 
<h3><a id="3__132"></a>3 二分查找初探</h3> 
<blockquote> 
 <p>说到二分查找，这里就有个笑话了。</p> 
</blockquote> 
<p>小孙同学去图书馆借书，一次性了借了40本书，出图书馆的时候报警了，不知道哪一本书没有<strong>消磁</strong>，然后把书放在地上，准备一本本尝试。</p> 
<p>女生的操作被旁边的阿姨看见了，阿姨说你这样操作多慢啊，我来教你。于是将树分为两摞，拿出第一luo过一下安检，安检机器想了，于是阿姨将这摞书分成两部分，拿出一部分继续尝试，就这样，阿姨每次减少一半，没几次就找到了没有消磁的书。阿姨嘚瑟的来一句：小姑凉，这就是书中的二分查找算法，你这还得好好学习哇，第二天，图书馆发现丢了39本书。哈哈哈哈</p> 
<h3><a id="4__140"></a>4 二分查找基础</h3> 
<blockquote> 
 <p>最简单的二分算法即在一个有序数组中，查找一个数字X是否存在。注意有序性。那么如何在数组中查找一个数</p> 
</blockquote> 
<ul><li>从头到尾一个一个查找，找到即有数字x</li><li>二分算法即通过确定一个区间，然后查找区间的一半和x比较，如果比x大则在x前半段查找。如果比x小则在后半段查找，只需要log2n的比较即可确定结果。</li></ul> 
<p><img src="https://images2.imgbox.com/ba/a4/Xocd9ksE_o.png" alt="二分初探"></p> 
<p>图中呢，我们以查找 17 这个数字为例，L 和 R 所圈定的，就是当前的<strong>查找区间</strong>，一开始 L= 0，R = 6，mid 所指向的就是数组的中间位置，根据 L 和 R 计算得到 mid 的值是 3。查看数组第 3 位的值是 12，比待查找值 17 要小，说明如果 17 在这个有序数组中，那它一定在 mid 所指向位置的后面，而 mid 本身所指向的数字已经确定不是 17 了，所以下一次我们可以将查找区间，定位到 mid + 1 到 R，也就是将 L 调整到 mid + 1 （即数组第 4<br> 位）的位置。</p> 
<p><strong>1 第一种小白写法</strong></p> 
<pre><code class="prism language-c++">int BinarySerach(vector&lt;int&gt;&amp; nums,int n, int target) {
    int left = 0, right = n-1;
    while (left &lt;= right) {
        int mid = (left+right)/2;
        if (nums[mid] == target) return mid;
        else if (nums[mid] &lt; target) left = mid + 1;
        else right = mid-1;
    }
    return -1;
}
</code></pre> 
<p>面试官发话了</p> 
<p><img src="https://images2.imgbox.com/ea/a1/3rFGVB1N_o.png" alt="img"></p> 
<p><strong>方法二优化版</strong></p> 
<blockquote> 
 <p>如果right和left比较的时候，两者之和可能溢出。那么改进的方法是mid=left+(right-left)/2.还可以<strong>继续优化</strong>，我们将除以2这种操作转换为位运算mid=left+((right-left)&gt;&gt;1).</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8e/5e/CbMoAh5b_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>哪有这么简单的事儿，大多数的笔试面试中可能会出现下面的几种情况。</p> 
</blockquote> 
<h2><a id="_181"></a>二分的各种变种</h2> 
<p>这里主要是看看原始数组有重复数的情况。</p> 
<p><img src="https://images2.imgbox.com/7e/5c/0ZUOFv8q_o.png" alt="二分"></p> 
<p><strong>1 查找第一个值等于给定值的情况(查找元素7)</strong><br> 思路</p> 
<blockquote> 
 <p>首先7与中间值a[4]比较，发现小于7，于是在5到9中继续查找，中间a[7]=7,但是这个数7不是第一次出现的。那么我们检查这个值的前面是不是等于7，如果等于7，说明目前这个值不是第一次出现的7，此时更新rihgt=mid-1。ok我们看看代码</p> 
</blockquote> 
<pre><code class="prism language-c++">int BinarySerach(vector&lt;int&gt;&amp; nums, int n,int target) {
    int left = 0, right = n-1;
    while (left &lt;= right) {
        int mid = left+((right-left)&gt;&gt;1);
        if (nums[mid]&gt;value)
        {
            right=mid-1;
        } else if(nums[mid]&lt;value)
        {
            left=mid+1;
        }else
        {
            if((mid==0)||(nums[mid-1]!=value))
            {
                return mid;
            }else
            {
                left=mid-1;
            }
        }
    return -1;
}
</code></pre> 
<p><strong>2 查找最后一个值等于给定值的情况</strong></p> 
<blockquote> 
 <p>假设nums[mid]这个值已经是最后一个元素了，那么它肯定是要找到最后一个值。如果nums[mid]的下一个不等于value，那说明nums[mid]就是我们需要找到最后一个等于给定值的值。</p> 
</blockquote> 
<pre><code class="prism language-c++">int BinarySerach(vector&lt;int&gt;&amp; nums, int n,int target) {
    int left = 0, right = n-1;
    while (left &lt;= right) {
        int mid = left+((right-left)&gt;&gt;1);
        if (nums[mid]&gt;value)
        {
            right=mid-1;
        } else if(nums[mid]&lt;value)
        {
            left=mid+1;
        }else
        {
            if((mid==n-1)||(nums[mid+1]!=value))
            {
                return mid;
            }else
            {
                left=mid+1;
            }
        }
    return -1;
}
</code></pre> 
<p><strong>3 查找第一个大于等于给定值的情况</strong></p> 
<ul><li>如果nums[mid]小于要查找的值，那么我们需要查找在[mid+1,right]之间，所以此时更新为left=mid+1</li><li>如果nums[mid]大于给定值value,这个时候需要查看nums[mid]是不是我们需要找的第一个值大于等于给定值元素，如果nums[mid]前面没有元素或者前面一个元素小于查找的值，那么nums[mid]就是我们需要查找的值。相反</li><li>如果nums[mid-1]也是大于等于查找的值，那么说明查找的元素在[left,mid-1]之间，所以我们需要将right更新为mid-1</li></ul> 
<pre><code class="prism language-c++">int BinarySerach(vector&lt;int&gt;&amp; nums, int n,int target) {
    int left = 0, right = n-1;
    while (left &lt;= right) {
        int mid = left+((right-left)&gt;&gt;1);
        if (nums[mid]&gt;value)
        {
            right=mid-1;
        } else if(nums[mid]&lt;value)
        {
            left=mid+1;
        }else
        {
            if((mid==n-1)||(nums[mid+1]!=value))
            {
                return mid;
            }else
            {
                left=mid+1;
            }
        }
    return -1;
}

</code></pre> 
<p><strong>4 查找第一个大于等于给定值的情况</strong></p> 
<ul><li>如果nums[mid]小于要查找的值，那么我们需要查找在[mid+1,right]之间，所以此时更新为left=mid+1</li><li>如果nums[mid]大于给定值value,这个时候需要查看nums[mid]是不是我们需要找的第一个值大于等于给定值元素，如果nums[mid]前面没有元素或者前面一个元素小于查找的值，那么nums[mid]就是我们需要查找的值。相反</li><li>如果nums[mid-1]也是大于等于查找的值，那么说明查找的元素在[left,mid-1]之间，所以我们需要将right更新为mid-1</li></ul> 
<pre><code class="prism language-c++">int BinarySerach(vector&lt;int&gt;&amp; nums, int n,int target) {
    int left = 0, right = n-1;
    while (left &lt;= right) {
        int mid = left+((right-left)&gt;&gt;1);
        if (nums[mid]&gt;=value)
        {
            if(mid==0||nums[mid-1]&lt;value)
            {
                return mid;
            }else
            {
                right=mid-1;
            }
        }else
        {
            left=mid+1;
        }
    return -1;
}



</code></pre> 
<p><strong>5 查找最后一个小于等于给定值的情况</strong></p> 
<ul><li>如果nums[mid]小于查找的值，那么需要查找的值肯定在[mid+1,right]之间，所以我们需要更新left=mid+1</li><li>如果nums[mid]大于等于给定的value，检查nums[mid]是不是我们的第一个值大于等于给定值的元素</li></ul> 
<pre><code class="prism language-c++">int BinarySerach(vector&lt;int&gt;&amp; nums, int n,int target) {
    int left = 0, right = n-1;
    while (left &lt;= right) {
        int mid = left+((right-left)&gt;&gt;1);
        if (nums[mid]&gt;value)
        {
            right=mid-1;
        }else
        {
            if(mid==n-1||(nums[mid+1]&gt;value))
            {
                return mid;
            }else
            {
                left=mid+1;
            }
        }
    return -1;
}

</code></pre> 
<h3><a id="4__337"></a>4 队列</h3> 
<blockquote> 
 <p>例子：滑动窗口最大值</p> 
</blockquote> 
<p><strong>队列回忆：</strong></p> 
<blockquote> 
 <p>火车站买票应该都经历过，窗口小姐姐每次服务排在最前面的那个人，买完票则从头部离开，后面人往前一步接替离开的人继续购票，这就是典型的队列结构。</p> 
</blockquote> 
<p>计算机中的队列和其类似，先到先得，先入先出，每个元素从尾部入队，从头部处理完出队</p> 
<p><img src="https://images2.imgbox.com/95/ea/9mpTCBis_o.png" alt="队列定义"></p> 
<p><strong>单调队列</strong></p> 
<blockquote> 
 <p>假设将学生从高年级到低年级排列，随着时间的推移，高年级同学从队列头部毕业，低年级从尾部进入。大部分学校都有校队，假设小林高三，我高二，小七高一，小林毕业接班的是我，我毕业，很可能就是小七接班，而当我进队的那一刻，小七即使进的早但是战斗力没我高，所以小七是永远没计划被选中啦。所以，纵观全队，不仅有着队列的性质，也有着单调的性质，所以就是单调队列。</p> 
</blockquote> 
<p><strong>为什么需要单调队列</strong></p> 
<blockquote> 
 <p>比较明显的作用是，用来维护队列处理顺序中的区间最大值。</p> 
</blockquote> 
<p><strong>高频面试题----滑动窗口最大值</strong></p> 
<blockquote> 
 <p>滑动窗口没向后滑动一位，就有一个元素从队首出队，同时也会有个元素从队尾入队。这个题需要求区间的最大值：意味着需要维护在队列处理顺序中的区间最大值，直接上代码附上注释</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MAX_N 1000</span>
<span class="token keyword">int</span> q<span class="token punctuation">[</span>MAX_N <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> head<span class="token punctuation">,</span> tail<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">interval_max_number</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// a[i] 入队，将违反单调性的从队列 q 中踢出</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">&lt;</span> tail <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tail <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tail<span class="token operator">--</span><span class="token punctuation">;</span>
        q<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// i 入队</span>
        <span class="token comment">// 判断队列头部元素是否出了窗口范围</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> m <span class="token operator">==</span> q<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">)</span> head<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出区间内最大值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"interval(%d, %d)"</span><span class="token punctuation">,</span> i <span class="token operator">-</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>	
	<span class="token keyword">return</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="5__383"></a>5 栈与单调栈</h3> 
<blockquote> 
 <p>栈结构对应于队列，可以将栈想象为一个只有单出口的羽毛球筒，羽毛球只能从单一的入口放入和取出。假设我们将1，2,3三个球放进球桶，如果取出来此时就是3,2,1。性质就很明显了，先进后出的结构</p> 
</blockquote> 
<p>栈结构本身维护的是一种完全包含的关系。这种包含关系在函数之间的运行体现的玲离尽致，也就是一种包含关系，如果主函数调用函数B，那么函数B一定会在主函数结束之前结束。</p> 
<p><strong>单调栈</strong></p> 
<p>此时应该了解了栈和队列，那么我问你，你觉得栈和队列最大的区别是啥？</p> 
<p>你可能毫不犹豫的可以回答栈是<strong>先进后出</strong>，队列是<strong>先进先出</strong>。ok，那我再问你，堵住了出口的单调队列和栈有什么区别？这是不是就没什么区别了，单调队列为了维护其<strong>单调性</strong>，在入队的时候会将违反单调性的元素弹出去，这就相当于栈的同一段进出，是的，堵住出口的单调队列就是我们现在要说的单调栈，目前以单调递减栈为例</p> 
<p><img src="https://images2.imgbox.com/dd/9a/LMaDYl66_o.png" alt="单调栈"></p> 
<p>当序列中的12号元素入栈以后，此时单调栈有4个元素，从栈底到栈顶分别为23,18,15,9，按照原始序列为2 5 9 12。此时我们关注12号元素和9号元素的关系。如果12号元素入栈，为了保证栈的单调递减性，最终放在9号上面，此时我们虽然不是第十个元素和十一号元素值多少，但是这两个元素的值一定是比9号元素小，这就是单调栈的性质。所以，单调队列是用来维护区最值的高效结构，单调栈呢是维护最近大于或小于的高效结构。下面看个例子</p> 
<p><strong>题目：判断括号序列是否合法</strong></p> 
<p>示例 合法</p> 
<blockquote> 
 <p>({})<br> <a href="%5B%5D" rel="nofollow"></a>{()}</p> 
</blockquote> 
<p>示例 非合法</p> 
<blockquote> 
 <p>([)]<br> (((){}</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Stack<span class="token generics function"><span class="token punctuation">&lt;</span>Character<span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Map<span class="token generics function"><span class="token punctuation">&lt;</span>Character<span class="token punctuation">,</span>Character<span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">,</span><span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">,</span><span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">,</span><span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">//为左括号时直接入栈</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            	<span class="token comment">//为右括号时，如果栈为空或者栈顶与该括号类型不匹配返回false</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//字符串遍历完毕后，如果栈为空返回true，反之返回false</span>
        <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre> 
<h3><a id="6__437"></a>6 递推套路</h3> 
<blockquote> 
 <p>在分享递推之前，先和大家分享与之紧密的数学原理：容斥原理</p> 
</blockquote> 
<p>在计数问题中，为了保证计数的准确程度，通常会保证两个问题，<strong>第一个问题</strong>是没有重复，<strong>第二个问题</strong>是没有遗漏。这两个问题相对来说，第二点比较容易做到。比如对某地区进行爆炸式轰炸，为了保证炸的覆盖面，足够多的炸弹即可，但是如果保障一块土地只能炸一次就比较难搞了。那么容斥原理就是解决这个问题</p> 
<blockquote> 
 <p>容斥原理是什么？</p> 
</blockquote> 
<p>先不考虑重叠的情况，先将所有对象数目计算出来，然后将重复计算的排斥出去，是的，计算的结果不仅不遗漏也不重复。简单的说就是在计算的过程中，如果加多了就减去多的部分，如果减多了就加回来一部分，直到不多不少。</p> 
<p>我们看一个兔子繁殖问题</p> 
<blockquote> 
 <p>假设有一片草原上，莫名其妙来了一只外星兔子，这种外星兔子呢，第一个月的时候是幼体，第二个月成长为成体，从第三个月开始，成体兔子每个月都会产生出一只克隆体的幼体兔子，而且这种兔子不会衰老，一旦成体以后，就会一直生下去。按照这种情况，请你计算出第 n 个月，草原上有多<br> 少只兔子？</p> 
</blockquote> 
<p>此时给出前面6个月的情况<br> <img src="https://images2.imgbox.com/be/d3/cjf4QCFp_o.png" alt="六个月兔子情况"></p> 
<p>从上图我们可以发现，从第一个月到第六个月，草原上的兔子数量分别为1,1,2,3,5,8</p> 
<p>第六个月共有8只兔子，其中包含5只成兔，3只幼兔，为什么是5只成兔，因为第六个月的兔子数量等于第五个月的兔子总数，六个月的3只幼兔是等于第四个月的兔子数量</p> 
<p><img src="https://images2.imgbox.com/0a/79/7CW762Dq_o.png" alt="后三个月情况"></p> 
<p>结论就比较清晰了：从第三个月开始，第n个月的兔子数量等于该月的成兔数量与幼兔数量之和，也就是等于第n-1个月的兔子数量与第n-2兔子数量之和。这种根据前面的数量来推后面的数量的情况叫做递推，那么递推算法套路通常是怎么样呢</p> 
<ul><li>确定递推的状态，多画图前面几步</li><li>推导递推公式</li><li>程序的编写</li></ul> 
<blockquote> 
 <p>我们根据三步走的方式来阐释解决兔子的这个问题</p> 
</blockquote> 
<ul><li>f(n)表示n个月兔子的数量</li><li>递推公式(第一个月合第二个月兔子的数量为1，到了第三个月即等于前面两个月之和)<br> <img src="https://images2.imgbox.com/51/c1/7jBahWhb_o.png" alt="递推公式"></li></ul> 
<p><strong>案例2 凑钱币问题</strong></p> 
<blockquote> 
 <p>用 1 元、2 元、5 元、10 元、20 元、50 元和 100<br> 元凑成 1000 元钱，总共有多少种方案</p> 
</blockquote> 
<ul><li>确定递推状态，需要分析自变量与因变量，自变量两个分别为币种种类和拼凑的钱币数量，因变量1个为方案总数，因此我们的状态定义为f(i,j)，i种钱币，拼凑j元钱的方案总数。比如f [3][10]即使用三种钱币，凑出10元的方案总数</li><li>假设我们不使用第三种钱币，那么此时等价于使用前两种钱币拼凑10元钱的方案总数，即f[2][10]。如果使用至少1张5块钱，那么我们在这些方案中去掉一张5元钱，剩下的方案数为f[3][5]，所以此时的递推公式为f[3][10] = f[2][10] + f[3][5]。这只是一般情况，假设我们没有使用第i种钱币，拼凑j元的方案为f(i-1,j)，代表使用前i-1种钱币的方案总数。剩下的使用了第i中钱币，由于都存在第i钱币1张，假设第i种钱币的面额为val[i]，那么此时我们的前i种钱币，凑j-val[i]的钱数，此时方案总数为f(i,j-val[i])；所以公式为f(i,j)=f(i-1,j)+f(i,j-val[i])<br> <img src="https://images2.imgbox.com/c3/59/1gUtRGNo_o.png" alt="推理"></li></ul> 
<blockquote> 
 <p><strong>欢迎关注[我是程序员小贱]，专注面试各种痛点</strong></p> 
</blockquote> 
<h3><a id="7__485"></a>7 动态规划</h3> 
<blockquote> 
 <p>动态规划通常简称DP(dynamic programming)，如果按照问题类型来划分，将分为线性DP、区间DP，数位DP等等，每当说到动态规划就会想最优子结构，重叠子问题等等，这些词汇苦涩难懂，不要慌，再难的问题也是建立在基础问题上，逐步拆分，这也是动态规划的思想，相信通过下面动态规划四步走的方式，加上习题的练习，一定会让你对动态规划有个新的理解。</p> 
</blockquote> 
<p>四个步骤分为：状态定义，状态转移方程，正确性的证明和实现</p> 
<ul><li><strong>状态定义</strong></li></ul> 
<blockquote> 
 <p>其实上面说递推的时候就已经有所涉及状态定义，通常在推导的过程中，如果感觉推不下去了，很有可能就是我们的状态定义出现了问题。</p> 
</blockquote> 
<p>第一个状态：dp[i][j]代表从起始点到(I,j)路径的最大值</p> 
<p>第二个状态：dp[i][j]代表从底边的某个点出发，到达(i,j)路径的最大值</p> 
<ul><li><strong>状态转移方程</strong></li></ul> 
<blockquote> 
 <p>上面的两种状态定义对应这里两个转移方向。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ae/83/t94VZ1hh_o.png" alt="状态转移过程"></p> 
<p>如上图所示，我们想要求得dp[i][j]，需要知道dp|[i-1]|[j-1]和dp[i-1][j]的值。因为只有(i - 1, j - 1) 和 (i - 1, j) 这两个点，才能能走到 (i, j)此时的状态转移方程为</p> 
<p>第一种状态转移方程dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + val[i][j]</p> 
<p>第二册中状态转移方程dp[i][j] = max(dp[i + 1][j], dp[i + 1][j + 1]) + val[i][j]</p> 
<p>从这里可以知道我们的状态定义不一样，我们的转移方程就很不一样吧</p> 
<ul><li>正确性证明</li></ul> 
<blockquote> 
 <p>数学归纳法通常采用三步走的方式，常用的正确性证明方法为数学归纳法。</p> 
</blockquote> 
<p>第一步，第一个阶段所有dp值可以轻松获得，也就是初始化dp[1][1]，等于val[1][1]</p> 
<p>第二步，假设如果第i-1阶段的所有状态值都正确得到，那么根据状态方程dp[i][j]=max(dp[i - 1][j], dp[i - 1][j + 1]) + val[i][j] 来说，此时就可以计算得到第i阶段中的素有状态值</p> 
<p>第三步：得出结论，所有的状态值计算正确</p> 
<p>我们继续分析动态规划问题中的0/1背包问题，通常分为三类，0/1背包问题，完全背包问题和多重背包问题。</p> 
<p>0/1背包问题是另外两种背包问题的基础，简单描述一下，假设有个背包，载重上限为W，此时有n个物品，第i个物品的重量是wi，价值为vi，那么在不超过背包重量上限的前提下，能获得的最大物品价值总和？同样我们采用四步走的方式</p> 
<ul><li>状态定义</li></ul> 
<p>首先分析背包问题中的自变量和因变量，其中因变量比较好确定，就是所求最大价值总和，自变量呢，在此自变量为物品种类和背包承重上限，因为这两者会影响价值总和的最大值，所以我们设置一个二维状态。dp[i][j]代表使用前i个物品，背包最大载重为j的情况下最大价值总和。</p> 
<ul><li>状态方程</li></ul> 
<p>说白了就是找映射函数，dp[i][j]的表达式。我们将dp[i][j]分为两大类，第一类是不选择第i个物品最大价值和，第二类为选择了第i个物品的最大价值和。然后在两者中选择最大值就是价值更大的方案。</p> 
<p>如果选择第i个物品，此时的最大价值为dp[i-1][j-wi]+vi，既然选择了第i个商品，那么就需要留出一个位置，那么此时对于剩余的i-1个商品的载重空间就只剩下j-wi了，此时i-1个物品选择的最大价值和为dp[i-1][j-wi]，然后加上vi就是当前获得最大价值和。所以转移方程为</p> 
<p>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])</p> 
<ul><li>正确性证明</li></ul> 
<p>首先dp[0][j]=0，意味着没有物品的时候，无论背包限重多少，能够得到的最大价值和都是0，所以k0争取</p> 
<p>其次，假设我们已经获取i-1个物品的价值最大值，所有dp[i-1]的值，那么根据状态方程，我们能知道所有dp[i]的值</p> 
<p>最后两步联合，整个求解对于任意dp[i][j]成立</p> 
<ul><li>实现</li></ul> 
<pre><code class="prism language-c++">#define MAX_V 10000
#define MAX_N 100
int v[MAX_N + 5], w[MAX_N + 5];
int dp[MAX_N + 5][MAX_V + 5];
int get_dp(int n, int W) {
    // 初始化 dp[0] 阶段
    for (int i = 0; i &lt;= W; i++) dp[0][i] = 0;
    // 假设 dp[i - 1] 成立，计算得到 dp[i]
    // 状态转移过程，i 代表物品，j 代表背包限重
    for (int i = 1; i &lt;= n; i++) {
   	 	for (int j = 0; j &lt;= W; j++) {
        // 不选择第 i 种物品时的最大值
        dp[i][j] = dp[i - 1][j];
        // 与选择第 i 种物品的最大值作比较，并更新
        if (j &gt;= w[i] &amp;&amp; dp[i][j] &lt; dp[i - 1][j - w[i]] + v[i]) {
        	dp[i][j] = dp[i - 1][j - w[i]] + v[i];
   		 }
   	 }
	}
	return dp[n][W];
}
</code></pre> 
<h3><a id="8__575"></a>8 贪心</h3> 
<blockquote> 
 <p>其实我们大学学习的好几种应用都是采用了贪心的算法啊，比如Huffman Coding，Prim最小生成树等</p> 
</blockquote> 
<p>先来看一道之前美团的一道笔试题–跳一跳</p> 
<blockquote> 
 <p>有n个盒子排成一行，每个盒子上面有一个数字a[i]，表示最多能向右跳a[i]个盒子；小林站在左边第一个盒子，请问能否到达最右边的盒子？比如说：[1, 2, 3, 0, 4] 可以到达第5个盒子；[3, 2, 1, 0, 4] 无法到达第5个盒子；</p> 
</blockquote> 
<p>思路：自然而然的想法，尽可能的往右边跳，看最后能够到达，从第一个盒子开始从右遍历，对于每个经过的盒子，不断地更新maxRight值。那么贪心算法的思考过程通常是怎么样的？</p> 
<p>类似于动态规划，<strong>大事化小，小事化了</strong>。所谓大事化小，将大的问题，找到和子问题的重复部分，将复杂问题拆分为小的问题。小事化了，通过对小事的打磨找到较为核心的策略。上例子</p> 
<p>分糖果问题</p> 
<blockquote> 
 <p>我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n），所以糖果只能分配给一部分孩子。 每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。<br> 我的问题是，如何分配糖果，能尽可能满足最多数量的孩子？</p> 
</blockquote> 
<ul><li>对于一个孩子来说，如果小的糖果可以满足，那么就没必要用更大的糖果</li><li>对糖果的大小需求的孩子更容易被满足，所以我们可以从需求小得孩子开始分配糖果</li><li>因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的</li><li>我们每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案</li></ul> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;


/*
解题思路：
遍历两边，首先每个人得一块糖，第一遍从左到右，若当前点比前一个点高就比前者多一块。
这样保证了在一个方向上满足了要求。第二遍从右往左，若左右两点，左侧高于右侧，但
左侧的糖果数不多于右侧，则左侧糖果数等于右侧糖果数+1，这就保证了另一个方向上满足要求。

最后将各个位置的糖果数累加起来就可以了。
*/


int candyCount(vector&lt;int&gt;&amp;rating) {

    int res = 0;
    //孩子总数
    int n = rating.size();

    //糖果集合
    vector&lt;int&gt; candy(n, 1);
    //从左往右遍历
    for (int i = 0;i &lt; n - 1;i++) {
        if (rating[i + 1] &gt; rating[i])candy[i + 1] = candy[i] + 1;
    }
    //从右往左
    for (int i = n - 1;i &gt; 0;i--) {
        if (rating[i - 1] &gt; rating[i] &amp;&amp; candy[i - 1] &lt;= candy[i])
        	candy[i - 1] = candy[i] + 1;
    }

    //累加结果
    for (auto a : candy) {
        res += a;
    }

    return res;
}
//测试函数
int main() {

    vector&lt;int&gt; rating{1,3,2,1,4,5,2};
    cout &lt;&lt; candyCount(rating) &lt;&lt; endl;
    return 0;
}

</code></pre> 
<h3><a id="_649"></a>唠嗑</h3> 
<blockquote> 
 <p>也许当我们工作了以后，才知道如果有一小段时间可以安心的思考一道算法题目是多么美好的事儿。算法的技巧文章太多太多，可谓眼花缭乱，以致于自己都不知道看什么资料。看太多的书真不如"刀枪实战"，直接去Leetcode或者其他算法平台练习，不过练习真的需要章法，毕竟咋们时间也有限，在我看来分类刷比较好，最好可以从树来刷题，咋们不能靠数量取胜，需要读题思考，写代码，看看是否有其他方法来优化，以致于让自己更深入的了解这代码逻辑以及优化原理。好了，今天就到这了，如果需要算法学习资料，可以私信我啦。求个<strong>点赞</strong>，明天更美好。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/52658f970432875fa9ab5f6aad1b4789/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">字节跳动半夜给员工发钱，全员沸腾了</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/208e508d4b820387efb89f090b5f3ec8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入理解 Vue 模板渲染：Vue 模板反编译</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>