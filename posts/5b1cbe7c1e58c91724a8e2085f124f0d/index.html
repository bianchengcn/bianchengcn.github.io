<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python学习笔记-基础语法 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python学习笔记-基础语法" />
<meta property="og:description" content="Python filename.py,在执行.py文件之前，需要把当前目录切换文件所在目录使用python命令切换到交互模式使用./filename.py直接执行py文件需要在.py文件的首行加上#！/usr/bin/env python 3 # -*- coding：utf-8 -*-print()函数用于输出，print(‘hello’);默认是换行输出的，想要实现不换行输出需要在变量末尾加上’,’ python3要求带括号input()函数用于输入,函数中可以添加提示,个人测试使用raw_input();更合适。注释符号# 相邻的两句的缩进需要统一使用tab或统一使用空格，不能混用。在python中strings tuples numbers是不可更改的对象，而list dict则是可以修改的对象同一行多条语句的时候使用；隔开多行内容使用\n换行符或者使用（··· ···）反引号除法分/和//地板除两种，地板除得到的是整数字符编码：utf-8 汉子三个字节\u开头的字符串是unicode编码，转换为中文汉字使用str.decode(‘unicode_escap’)ord(char)获取自负对应的整数，chr(int)获取整数对应的字符将字符串保存到磁盘上时需要将类型转换成字节流类型bytes，bytes类型数据使用’b’做前缀x=b’abc’使用的是str.encode(),bytes.decode()。包含不能被解码的字节，decode就会报错。len（str）函数查看字符串包含多少字符格式化占位符%d整数 %f浮点数 %s字符串 %x十六进制整数 %来转义%号条件循环等语句都是以关键字开始以：结束该行之后的一行或多行构成代码组,不支持switch允许同时为多个变量赋值a=b=c=1del用来删除单个或多个对象的引用&#43;字符串连接，*重复操作，操作*n重复n次数据类型：数字、字符串、列表、元组、字典列表用[]标识，列表切割也用[头下标：尾下标]，包含头下标对应的值不包含尾下标对应的值，使用list.append[‘’]为列表项追加元素，使用del()删除列表元素del list[index],删除指定位置元素 cmp(l1,l2)比较两个列表的元素len(list)列表元素个数Max（list）列表元素最大值min()list(元组)将元组转换为列表Lname.append(obj) lname.count(obj) lname.extend(seq) lname.index(obj) lname.pop() lname.remove()移除列表中某个值的第一个匹配项lname.reverse() lname.sort() lname.insert(index,obj) 元组用()标识，元组不能二次赋值，相当于只读列表 注意元组中只包含一个元素时，需要在元素后面添加逗号元组中的元素是不能修改的，但是我们可以对元组进行组合元组的元素值是不允许删除的，但是我们可以使用del语句删除整个元组元组中的方法cmp(元组1，元组2)，len（元组）计算元组个数，max（元组）min（元组），tuple（列表）将列表转换为元组字典用{}标识，类似js中的对象 Dict(a=‘’,b=‘’),通过方法创建字典访问字典 dict[‘索引值’]删除字典元素 del dict[‘索引值’]清空字典所有条目 del dict；注意不允许一个键出现两次，键值必须不可变，所以可以用数字，，字符串或元组充当，但是不能使用列表cmp() len() type(var)返回输入变量的类型str(字典名) 输出字典可打印的字符串表示Dict.clear() 清空字典Dict.copy()浅拷贝，复制，注意直接赋值和copy的区别，直接赋值是引用对象（修改原对象，赋值的对像值也会相应地改变），使用函数是深拷贝父对象（修改原对象，不会改变父对象的值），子对象还是引用(与直接赋值效果一样)，深拷贝是完全复制，原对象和复制的对象相互独立，浅拷贝是引用。Dict.deepcopy()深度拷贝Dict.fromkeys(swq[,val]),创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值Dict.get(key,default=None)返回指定键的值，如果值不存在（访问的key不存在）则返回default的值Dict.has_key(key)判断字典中是否含有某个键，有返回true，没有返回falseDict.items()以列表返回可遍历的（键，值）元组数组[(),()]dict.keys()以列表返回一个字典的所有的键[‘’,’’]Dict.setdefault(key,default=None)如果字典中包含有给定键，则返回该键对应的值，否则返回为该键设置的值Dict.update(dict2),把dict2的键值对添加到dict中Dict.values(),以列表返回字典中的所有值Dict.pop(key[,default])删除字典给定键所对应的值，返回值为被删除的值，key值必须给出，否则返回default的值Dict.popitem()随机返回并删除字典中的一对键和值返回形式元组（’key’，’value’） 算术运算符，基本一致，注意a**b是指a的b次方。//是地板除 注意python不支持&#43;&#43;和—运算比较运算符&lt;&gt;和！=都表示不等于’赋值运算符**=和//=位运算符&amp; | ^ ！～ &gt;&gt; &lt;&lt;逻辑运算符用关键字 and or not成员运算符 in 类似php中的as（foreach），not inis 和is not判断两个标识符是不是引用自一个对象id（）函数用来获取对象的内存地址无限循环while var==1: while else在while条件为false时执行elsepass语句时空语句，用作占位语句数字：整型，长整型、浮点数、复数数学运算的函数都在math模块和 cmath模块使用时需要引入 import math随机数函数需要引入随机模块import random random.choice(seq)从序列元素中随机挑一个元素random.randrange([start,]stop[,step])从指定范围获取一个随机数，比较有意思的是python竟然在参数取值上不遵循最右原则Random.random()随机生成一个0到1之间的实数random.seed([x])Random.shuffle(lst)将序列的所有元素随机排序Random.uniform(x,y)随机生成一个实数在【x，y】之间三角函数需要引入数学函数import math数学常量 pi表示pai e表示自然常数三引号类似php中的定界符Python 日期和时间 提供了很多处理时间和日期的函数，在使用之前需要引入模块import time时间元组 九组数字组成 分别表示年 月 日 时 分 秒 一周的第几日 一年的第几日 夏令时 获取当前的时间戳使用time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5b1cbe7c1e58c91724a8e2085f124f0d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-07T09:24:35+08:00" />
<meta property="article:modified_time" content="2018-05-07T09:24:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python学习笔记-基础语法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul class="ul1"><li class="li1"><span class="s1"></span><span class="s2">Python filename.py,</span><span class="s3">在执行</span><span class="s2">.py</span><span class="s3">文件之前，需要把当前目录切换文件所在目录</span></li><li class="li1"><span class="s4"></span><span class="s3">使用</span><span class="s2">python</span><span class="s3">命令切换到交互模式</span></li><li class="li2"><span class="s4"></span><span class="s5">使用</span><span class="s3">./filename.py</span><span class="s5">直接执行</span><span class="s3">py</span><span class="s5">文件需要在</span><span class="s3">.py</span><span class="s5">文件的首行加上</span><span class="s3">#</span><span class="s5">！</span><span class="s3">/usr/bin/env python 3   # -*-  coding</span><span class="s5">：</span><span class="s3">utf-8 -*-</span></li><li class="li1"><span class="s4"></span><span class="s2">print()</span><span class="s3">函数用于输出，</span><span class="s2">print(‘hello’);</span><span class="s3">默认是换行输出的，想要实现不换行输出需要在变量末尾加上</span><span class="s2">’,’ python3</span><span class="s3">要求带括号</span></li><li class="li1"><span class="s4"></span><span class="s2">input()</span><span class="s3">函数用于输入</span><span class="s2">,</span><span class="s3">函数中可以添加提示</span><span class="s2">,</span><span class="s3">个人测试使用</span><span class="s2">raw_input();</span><span class="s3">更合适。</span></li><li class="li1"><span class="s4"></span><span class="s3">注释符号</span><span class="s2">#</span> 
  <ul class="ul1"><li class="li1"><span class="s4"></span><span class="s3">相邻的两句的缩进需要统一使用</span><span class="s2">tab</span><span class="s3">或统一使用空格，不能混用。</span></li><li class="li2"><span class="s4"></span><span class="s5">在</span><span class="s3">python</span><span class="s5">中</span><span class="s3">strings tuples numbers</span><span class="s5">是不可更改的对象，而</span><span class="s3">list dict</span><span class="s5">则是可以修改的对象</span></li></ul></li><li class="li1"><span class="s4"></span><span class="s3">同一行多条语句的时候使用；隔开</span></li><li class="li1"><span class="s4"></span><span class="s3">多行内容使用</span><span class="s2">\n</span><span class="s3">换行符或者使用（</span><span class="s2">··· ···</span><span class="s3">）反引号</span></li><li class="li1"><span class="s4"></span><span class="s3">除法分</span><span class="s2">/</span><span class="s3">和</span><span class="s2">//</span><span class="s3">地板除两种，地板除得到的是整数</span></li><li class="li1"><span class="s4"></span><span class="s3">字符编码：</span><span class="s2">utf-8 </span><span class="s3">汉子三个字节</span></li><li class="li2"><span class="s4"></span><span class="s3">\u</span><span class="s5">开头的字符串是</span><span class="s3">unicode</span><span class="s5">编码，转换为中文汉字使用</span><span class="s3">str.decode(‘unicode_escap’)</span></li><li class="li1"><span class="s4"></span><span class="s2">ord(char)</span><span class="s3">获取自负对应的整数，</span><span class="s2">chr(int)</span><span class="s3">获取整数对应的字符</span></li><li class="li1"><span class="s4"></span><span class="s3">将字符串保存到磁盘上时需要将类型转换成字节流类型</span><span class="s2">bytes</span><span class="s3">，</span><span class="s2">bytes</span><span class="s3">类型数据使用</span><span class="s2">’b’</span><span class="s3">做前缀</span><span class="s2">x=b’abc’</span><span class="s3">使用的是</span><span class="s2">str.encode(),bytes.decode()</span><span class="s3">。包含不能被解码的字节，</span><span class="s2">decode</span><span class="s3">就会报错。</span></li><li class="li1"><span class="s4"></span><span class="s2">len</span><span class="s3">（</span><span class="s2">str</span><span class="s3">）函数查看字符串包含多少字符</span></li><li class="li1"><span class="s4"></span><span class="s3">格式化占位符</span><span class="s2">%d</span><span class="s3">整数</span><span class="s2"> %f</span><span class="s3">浮点数</span><span class="s2"> %s</span><span class="s3">字符串</span><span class="s2"> %x</span><span class="s3">十六进制整数</span><span class="s2"> %</span><span class="s3">来转义</span><span class="s2">%</span><span class="s3">号</span></li><li class="li1"><span class="s4"></span><span class="s3">条件循环等语句都是以关键字开始以：结束该行之后的一行或多行构成代码组</span><span class="s2">,</span><span class="s3">不支持</span><span class="s2">switch</span></li><li class="li1"><span class="s4"></span><span class="s3">允许同时为多个变量赋值</span><span class="s2">a=b=c=1</span></li><li class="li1"><span class="s4"></span><span class="s2">del</span><span class="s3">用来删除单个或多个对象的引用</span></li><li class="li1"><span class="s4"></span><span class="s2">+</span><span class="s3">字符串连接，</span><span class="s2">*</span><span class="s3">重复操作，操作</span><span class="s2">*n</span><span class="s3">重复</span><span class="s2">n</span><span class="s3">次</span></li><li class="li1"><span class="s4"></span><span class="s3">数据类型：数字、字符串、列表、元组、字典</span></li><li class="li1"><span class="s4"></span><span class="s3">列表用</span><span class="s2">[]</span><span class="s3">标识，列表切割也用</span><span class="s2">[</span><span class="s3">头下标：尾下标</span><span class="s2">]</span><span class="s3">，包含头下标对应的值不包含尾下标对应的值，使用</span><span class="s2">list.append[‘’]</span><span class="s3">为列表项追加元素，使用</span><span class="s2">del()</span><span class="s3">删除列表元素</span><span class="s2">del list[index],</span><span class="s3">删除指定位置元素</span> 
  <ul class="ul1"><li class="li2"><span class="s4"></span><span class="s3">cmp(l1,l2)</span><span class="s5">比较两个列表的元素</span></li><li class="li2"><span class="s4"></span><span class="s3">len(list)</span><span class="s5">列表元素个数</span></li><li class="li1"><span class="s4"></span><span class="s2">Max</span><span class="s3">（</span><span class="s2">list</span><span class="s3">）列表元素最大值</span></li><li class="li2"><span class="s4"></span><span class="s3">min()</span></li><li class="li1"><span class="s4"></span><span class="s2">list(</span><span class="s3">元组</span><span class="s2">)</span><span class="s3">将元组转换为列表</span></li><li class="li2"><span class="s4"></span><span class="s3">Lname.append(obj) lname.count(obj) lname.extend(seq) lname.index(obj) lname.pop() </span></li><li class="li1"><span class="s4"></span><span class="s2">lname.remove()</span><span class="s3">移除列表中某个值的第一个匹配项</span></li><li class="li2"><span class="s4"></span><span class="s3">lname.reverse() lname.sort() lname.insert(index,obj)</span></li></ul></li></ul> 
<p class="p3"><span class="s3"></span><br></p> 
<ul class="ul1"><li class="li1"><span class="s4"></span><span class="s3">元组用</span><span class="s2">()</span><span class="s3">标识，元组不能二次赋值，相当于只读列表</span> 
  <ul class="ul1"><li class="li1"><span class="s4"></span><span class="s3">注意元组中只包含一个元素时，需要在元素后面添加逗号</span></li><li class="li1"><span class="s4"></span><span class="s3">元组中的元素是不能修改的，但是我们可以对元组进行组合</span></li><li class="li1"><span class="s4"></span><span class="s3">元组的元素值是不允许删除的，但是我们可以使用</span><span class="s2">del</span><span class="s3">语句删除整个元组</span></li><li class="li1"><span class="s4"></span><span class="s3">元组中的方法</span><span class="s2">cmp(</span><span class="s3">元组</span><span class="s2">1</span><span class="s3">，元组</span><span class="s2">2)</span><span class="s3">，</span><span class="s2">len</span><span class="s3">（元组）计算元组个数，</span><span class="s2">max</span><span class="s3">（元组）</span><span class="s2">min</span><span class="s3">（元组），</span><span class="s2">tuple</span><span class="s3">（列表）将列表转换为元组</span></li></ul></li><li class="li1"><span class="s4"></span><span class="s3">字典用</span><span class="s2">{}</span><span class="s3">标识，类似</span><span class="s2">js</span><span class="s3">中的对象</span> 
  <ul class="ul1"><li class="li2"><span class="s4"></span><span class="s3">Dict(a=‘’,b=‘’),</span><span class="s5">通过方法创建字典</span></li><li class="li2"><span class="s4"></span><span class="s5">访问字典</span><span class="s3"> dict[‘</span><span class="s5">索引值</span><span class="s3">’]</span></li><li class="li2"><span class="s4"></span><span class="s5">删除字典元素</span><span class="s3"> del dict[‘</span><span class="s5">索引值</span><span class="s3">’]</span></li><li class="li2"><span class="s4"></span><span class="s5">清空字典所有条目</span><span class="s3"> del dict</span><span class="s5">；</span></li><li class="li1"><span class="s4"></span><span class="s3">注意不允许一个键出现两次，键值必须不可变，所以可以用数字，，字符串或元组充当，但是不能使用列表</span></li><li class="li2"><span class="s4"></span><span class="s3">cmp() len() </span></li><li class="li2"><span class="s4"></span><span class="s3">type(var)</span><span class="s5">返回输入变量的类型</span></li><li class="li1"><span class="s4"></span><span class="s2">str(</span><span class="s3">字典名</span><span class="s2">) </span><span class="s3">输出字典可打印的字符串表示</span></li><li class="li2"><span class="s4"></span><span class="s3">Dict.clear() </span><span class="s5">清空字典</span></li><li class="li1"><span class="s4"></span><span class="s2">Dict.copy()</span><span class="s3">浅拷贝，复制，注意直接赋值和</span><span class="s2">copy</span><span class="s3">的区别，直接赋值是引用对象（修改原对象，赋值的对像值也会相应地改变），使用函数是深拷贝父对象（修改原对象，不会改变父对象的值），子对象还是引用</span><span class="s2">(</span><span class="s3">与直接赋值效果一样</span><span class="s2">)</span><span class="s3">，深拷贝是完全复制，原对象和复制的对象相互独立，浅拷贝是引用。</span></li><li class="li2"><span class="s4"></span><span class="s3">Dict.deepcopy()</span><span class="s5">深度拷贝</span></li><li class="li1"><span class="s4"></span><span class="s2">Dict.fromkeys(swq[,val]),</span><span class="s3">创建一个新字典，以序列</span><span class="s2">seq</span><span class="s3">中元素做字典的键，</span><span class="s2">val</span><span class="s3">为字典所有键对应的初始值</span></li><li class="li2"><span class="s4"></span><span class="s3">Dict.get(key,default=None)</span><span class="s5">返回指定键的值，如果值不存在（访问的</span><span class="s3">key</span><span class="s5">不存在）则返回</span><span class="s3">default</span><span class="s5">的值</span></li><li class="li2"><span class="s4"></span><span class="s3">Dict.has_key(key)</span><span class="s5">判断字典中是否含有某个键，有返回</span><span class="s3">true</span><span class="s5">，没有返回</span><span class="s3">false</span></li><li class="li2"><span class="s4"></span><span class="s3">Dict.items()</span><span class="s5">以列表返回可遍历的（键，值）元组数组</span><span class="s3">[(),()]</span></li><li class="li2"><span class="s4"></span><span class="s3">dict.keys()</span><span class="s5">以列表返回一个字典的所有的键</span><span class="s3">[‘’,’’]</span></li><li class="li2"><span class="s4"></span><span class="s3">Dict.setdefault(key,default=None)</span><span class="s5">如果字典中包含有给定键，则返回该键对应的值，否则返回为该键设置的值</span></li><li class="li2"><span class="s4"></span><span class="s3">Dict.update(dict2),</span><span class="s5">把</span><span class="s3">dict2</span><span class="s5">的键值对添加到</span><span class="s3">dict</span><span class="s5">中</span></li><li class="li2"><span class="s4"></span><span class="s3">Dict.values(),</span><span class="s5">以列表返回字典中的所有值</span></li><li class="li1"><span class="s4"></span><span class="s2">Dict.pop(key[,default])</span><span class="s3">删除字典给定键所对应的值，返回值为被删除的值，</span><span class="s2">key</span><span class="s3">值必须给出，否则返回</span><span class="s2">default</span><span class="s3">的值</span></li><li class="li2"><span class="s4"></span><span class="s3">Dict.popitem()</span><span class="s5">随机返回并删除字典中的一对键和值返回形式元组（</span><span class="s3">’key’</span><span class="s5">，</span><span class="s3">’value’</span><span class="s5">）</span></li></ul></li></ul> 
<p class="p3"><span class="s3"></span><br></p> 
<ul class="ul1"><li class="li1"><span class="s4"></span><span class="s3">算术运算符，基本一致，注意</span><span class="s2">a**b</span><span class="s3">是指</span><span class="s2">a</span><span class="s3">的</span><span class="s2">b</span><span class="s3">次方。</span><span class="s2">//</span><span class="s3">是地板除</span> 
  <ul class="ul1"><li class="li2"><span class="s4"></span><span class="s5">注意</span><span class="s3">python</span><span class="s5">不支持</span><span class="s3">++</span><span class="s5">和</span><span class="s3">—</span><span class="s5">运算</span></li></ul></li><li class="li1"><span class="s4"></span><span class="s3">比较运算符</span><span class="s2">&lt;&gt;</span><span class="s3">和！</span><span class="s2">=</span><span class="s3">都表示不等于</span><span class="s2">’</span></li><li class="li2"><span class="s4"></span><span class="s5">赋值运算符</span><span class="s3">**=</span><span class="s5">和</span><span class="s3">//=</span></li><li class="li2"><span class="s4"></span><span class="s5">位运算符</span><span class="s3">&amp; | ^ </span><span class="s5">！～</span><span class="s3"> &gt;&gt;  &lt;&lt;</span></li><li class="li2"><span class="s4"></span><span class="s5">逻辑运算符用关键字</span><span class="s3"> and or not</span></li><li class="li2"><span class="s4"></span><span class="s5">成员运算符</span><span class="s3"> in </span><span class="s5">类似</span><span class="s3">php</span><span class="s5">中的</span><span class="s3">as</span><span class="s5">（</span><span class="s3">foreach</span><span class="s5">），</span><span class="s3">not in</span></li><li class="li1"><span class="s4"></span><span class="s2">is </span><span class="s3">和</span><span class="s2">is not</span><span class="s3">判断两个标识符是不是引用自一个对象</span></li><li class="li1"><span class="s4"></span><span class="s2">id</span><span class="s3">（）函数用来获取对象的内存地址</span></li><li class="li2"><span class="s4"></span><span class="s5">无限循环</span><span class="s3">while var==1:   while else</span><span class="s5">在</span><span class="s3">while</span><span class="s5">条件为</span><span class="s3">false</span><span class="s5">时执行</span><span class="s3">else</span></li><li class="li1"><span class="s4"></span><span class="s2">pass</span><span class="s3">语句时空语句，用作占位语句</span></li><li class="li1"><span class="s4"></span><span class="s3">数字：整型，长整型、浮点数、复数</span></li><li class="li2"><span class="s4"></span><span class="s5">数学运算的函数都在</span><span class="s3">math</span><span class="s5">模块和</span><span class="s3"> cmath</span><span class="s5">模块使用时需要引入</span><span class="s3"> import math</span></li><li class="li2"><span class="s4"></span><span class="s5">随机数函数需要引入随机模块</span><span class="s3">import random </span> 
  <ul class="ul1"><li class="li2"><span class="s4"></span><span class="s3">random.choice(seq)</span><span class="s5">从序列元素中随机挑一个元素</span></li><li class="li2"><span class="s4"></span><span class="s3">random.randrange([start,]stop[,step])</span><span class="s5">从指定范围获取一个随机数，比较有意思的是</span><span class="s3">python</span><span class="s5">竟然在参数取值上不遵循最右原则</span></li><li class="li2"><span class="s4"></span><span class="s3">Random.random()</span><span class="s5">随机生成一个</span><span class="s3">0</span><span class="s5">到</span><span class="s3">1</span><span class="s5">之间的实数</span></li><li class="li2"><span class="s4"></span><span class="s3">random.seed([x])</span></li><li class="li2"><span class="s4"></span><span class="s3">Random.shuffle(lst)</span><span class="s5">将序列的所有元素随机排序</span></li><li class="li2"><span class="s4"></span><span class="s3">Random.uniform(x,y)</span><span class="s5">随机生成一个实数在【</span><span class="s3">x</span><span class="s5">，</span><span class="s3">y</span><span class="s5">】之间</span></li></ul></li><li class="li1"><span class="s4"></span><span class="s3">三角函数需要引入数学函数</span><span class="s2">import math</span></li><li class="li1"><span class="s4"></span><span class="s3">数学常量</span><span class="s2"> pi</span><span class="s3">表示</span><span class="s2">pai e</span><span class="s3">表示自然常数</span></li><li class="li4"><span class="s4"></span><span class="s3">三引号类似</span><span class="s2">php</span><span class="s3">中的定界符</span></li><li class="li5"><span class="s6"><strong></strong></span><span class="s3"><strong>Python </strong></span><span class="s7"><strong>日期和时间</strong></span></li></ul> 
<p class="p6"><span class="s3"></span><br></p> 
<ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">提供了很多处理时间和日期的函数，在使用之前需要引入模块</span><span class="s9">import time</span></li><li class="li7"><span class="s8"></span><span class="s3">时间元组</span><span class="s9"> </span><span class="s3">九组数字组成</span><span class="s9"> </span><span class="s3">分别表示年</span><span class="s9"> </span><span class="s3">月</span><span class="s9"> </span><span class="s3">日</span><span class="s9"> </span><span class="s3">时</span><span class="s9"> </span><span class="s3">分</span><span class="s9"> </span><span class="s3">秒</span><span class="s9"> </span><span class="s3">一周的第几日</span><span class="s9"> </span><span class="s3">一年的第几日</span><span class="s9"> </span><span class="s3">夏令时</span><span class="s9"> </span></li><li class="li8"><img src="https://images2.imgbox.com/9c/b5/YkgGDRJI_o.png" alt=""></li></ul> 
<p class="p6"><span class="s3"></span><br></p> 
<ul class="ul1"><li class="li9"><span class="s8"></span><span class="s10">获取当前的时间戳使用</span><span class="s3">time.time()</span></li><li class="li9"><span class="s8"></span><span class="s10">获取当前时间</span><span class="s3">time.localtime()</span><span class="s10">返回的是时间元组</span></li><li class="li9"><span class="s8"></span><span class="s10">格式化时间</span><span class="s3"> time.asctime(time.localtime()) Thu Apr 7 10:05:21 2016 </span><span class="s10">格式</span></li><li class="li9"><span class="s8"></span><span class="s3"> </span><span class="s10">格式化日期</span><span class="s3"> time.strftime(‘%Y-%m-%d %H:%M:%S’,time.localtime)</span></li><li class="li9"><span class="s8"></span><span class="s10">将格式化字符串转换为时间戳</span><span class="s3">time.mktime(time.strptime(str,”format</span><span class="s10">字符串对应的时间戳个格式</span><span class="s3">”))</span></li><li class="li9"><span class="s8"></span><span class="s3">time.ctime([secs])</span><span class="s10">作用相当于</span><span class="s3">asctime(localtime([secs]))</span></li><li class="li7"><span class="s8"></span><span class="s9">Time.gmtime([secs])</span><span class="s3">接收时间戳（</span><span class="s9">1970</span><span class="s3">纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组</span><span class="s9">t</span><span class="s3">。注：</span><span class="s9">t.tm_isdst</span><span class="s3">始终为</span><span class="s9">0</span></li><li class="li7"><span class="s8"></span><span class="s9">Time.mktime(</span><span class="s3">时间元组</span><span class="s9">)</span><span class="s3">，接受时间元组并返回时间戳</span></li><li class="li9"><span class="s8"></span><span class="s3">time.sleep(secs)</span><span class="s10">推迟调用线程的运行，</span><span class="s3">secs</span><span class="s10">指秒数</span></li><li class="li9"><span class="s8"></span><span class="s3">Time.strftime(fmt[,</span><span class="s10">时间元组</span><span class="s3">])</span></li><li class="li9"><span class="s8"></span><span class="s3">time.timezong</span><span class="s10">属性，返回当地时区</span></li><li class="li9"><span class="s8"></span><span class="s3">time.tzname</span><span class="s10">属性</span></li><li class="li5"><span class="s6"><strong></strong></span><span class="s3"><strong>Calendar</strong></span><span class="s7"><strong>模块</strong></span></li><li class="li7"><span class="s8"></span><span class="s3">用来处理年历和月历</span></li><li class="li9"><span class="s8"></span><span class="s3">import calendar</span><span class="s10">使用前引入</span></li><li class="li9"><span class="s8"></span><span class="s3">Calendar.month(2018</span><span class="s10">，</span><span class="s3">5)</span><span class="s10">返回</span><span class="s3">2018</span><span class="s10">年五月的日历</span></li><li class="li7"><span class="s8"></span><span class="s9">calendar.firstweekday( ),</span><span class="s3">返回每周起始日期的设置，默认情况下首次在如模块返回</span><span class="s9">0</span><span class="s3">，即周一</span></li><li class="li9"><span class="s8"></span><span class="s3">Calendar.isleap(year)</span><span class="s10">瑞年返回</span><span class="s3">true</span><span class="s10">，否则返回</span><span class="s3">false</span></li><li class="li9"><span class="s8"></span><span class="s3">Calendar.leapdays(y1,y2)</span><span class="s10">返回在</span><span class="s3">y1 y2</span><span class="s10">之间的瑞年总数</span></li><li class="li9"><span class="s8"></span><span class="s3">Calendar.month(year,month,w=2,l=1)</span><span class="s10">返回</span><span class="s3">year</span><span class="s10">年</span><span class="s3">month</span><span class="s10">月的日历</span></li><li class="li7"><span class="s8"></span><span class="s9">Calendar.monthcalendar(year,month)</span><span class="s3">返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。</span><span class="s9">Year</span><span class="s3">年</span><span class="s9">month</span><span class="s3">月外的日期都设为</span><span class="s9">0;</span><span class="s3">范围内的日子都由该月第几日表示，从</span><span class="s9">1</span><span class="s3">开始</span></li><li class="li7"><span class="s8"></span><span class="s9">Calendar.monthrange(year,month)</span><span class="s3">返回两个整数，第一个是该月的日期码就是一号星期几，第二个整数代表这个月有多少天</span></li><li class="li9"><span class="s8"></span><span class="s3">Calendar.prcal(year,w=2,l=1,c=6)</span><span class="s10">相当于</span><span class="s3">print calendar.calendar(year,w,l,c)</span><span class="s10">输出整年的日历</span></li><li class="li9"><span class="s8"></span><span class="s3">Calendar.promonth(year,month,w=2,l=1)</span><span class="s10">相当于</span><span class="s3">print calendar.month(year,month,w,l)</span></li><li class="li9"><span class="s8"></span><span class="s3">Calendar.setfirstweekdayu(weekday)</span><span class="s10">设置每周的起始日期码</span></li><li class="li7"><span class="s8"></span><span class="s9">calendar.timegm(</span><span class="s3">时间元组</span><span class="s9">)</span><span class="s3">接受一个时间元组返回一个时间戳</span></li><li class="li9"><span class="s8"></span><span class="s3">Calendar.weekday(year,month,day)</span><span class="s10">返回给定日期的日期码，周几对应的码（编号</span><span class="s3">0-6</span><span class="s10">）</span></li><li class="li8"></ul> 
<p class="p10"><span class="s7"><strong>函数</strong></span></p> 
<ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">函数代码块以</span><span class="s9">def</span><span class="s3">关键字开头，后接函数标识符名称和圆括号（）。</span></li><li class="li7"><span class="s8"></span><span class="s3">任何传入参数和自身变量必须放在圆括号中间。圆括号之间可以用于定义参数</span></li><li class="li7"><span class="s8"></span><span class="s3">函数的第一行语句可以选择性地使用文档字符串用于存放函数说明</span></li><li class="li7"><span class="s8"></span><span class="s3">函数内容以冒号起始，并且缩进</span></li><li class="li7"><span class="s8"></span><span class="s9">return [</span><span class="s3">表达式</span><span class="s9">]</span><span class="s3">结束函数，选择性地返回一个值给调用方。不带表达式的</span><span class="s9">return</span><span class="s3">相当于</span><span class="s9">None</span><span class="s3">。</span></li><li class="li7"><span class="s8"></span><span class="s9">python</span><span class="s3">函数的参数传递</span> 
  <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">不可变类型</span><span class="s9"> </span><span class="s3">作为参数传递过去时</span><span class="s9"> </span><span class="s3">传递的只是值，不会影响</span><span class="s9">a</span><span class="s3">对象本身</span></li><li class="li7"><span class="s8"></span><span class="s3">可变类型</span><span class="s9"> </span><span class="s3">字典，列表</span><span class="s9"> </span><span class="s3">则是真正传过去，修改后</span><span class="s9">fun</span><span class="s3">外部也会受影响</span></li><li class="li7"><span class="s8"></span><span class="s9">python</span><span class="s3">中一切皆对象，参数分为不可变对象和可变对象</span></li><li class="li7"><span class="s8"></span><span class="s3">关键字参数，在调用函数时使用了定义函数时使用的参数作为关键字，此时传入参数的顺序不重要</span><span class="s9"> </span></li></ul></li></ul> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><img src="https://images2.imgbox.com/73/3b/azk39GDB_o.png" alt=""><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p3"><span class="s3"></span><br></p> 
<ul class="ul1"><li> 
  <ul class="ul1"><li class="li1"><span class="s4"></span><span class="s2"> </span><span class="s3">缺省参数是指在定义函数时设置了默认值例如</span> 
    <ul class="ul1"><li class="li2"><span class="s4"></span><span class="s3">def printinfo(name,age=35):</span> 
      <ul class="ul1"><li class="li12"><span class="s2">…</span></li><li class="li12"><span class="s2">…</span></li></ul></li></ul></li><li class="li2"><span class="s4"></span><span class="s5">不定长参数</span><span class="s3">def functionname([flags,] *var_args_tuple):</span> 
    <ul class="ul1"><li class="li1"><span class="s4"></span><span class="s2">*</span><span class="s3">变量名会存放所有未命名的变量参数</span></li></ul></li></ul></li></ul> 
<ul class="ul1"><li class="li1"><span class="s4"></span><span class="s3">匿名函数</span> 
  <ul class="ul1"><li class="li2"><span class="s4"></span><span class="s3">python</span><span class="s5">使用</span><span class="s3">lambda</span><span class="s5">来创建匿名函数</span></li><li class="li1"><span class="s4"></span><span class="s2">lambda</span><span class="s3">的主体只是一个表达式，而不是一个代码块。仅仅能在</span><span class="s2">lambda</span><span class="s3">表达式中封装有限的逻辑</span></li><li class="li1"><span class="s4"></span><span class="s2">lambda</span><span class="s3">函数拥有自己的命名空间，且不能访问自由参数之外或全局命名空间里的参数</span></li><li class="li2"><span class="s4"></span><span class="s5">语法</span><span class="s3"> lambda [arg1[,arg2…]]:expression </span></li></ul></li></ul> 
<p class="p3"><span class="s3"></span><br></p> 
<p class="p3"><span class="s3"></span><img src="https://images2.imgbox.com/e6/cd/1Y4kP0Nu_o.png" alt=""><br></p> 
<p class="p3"><span class="s3"></span><br></p> 
<p class="p3"><span class="s3"></span><br></p> 
<p class="p3"><span class="s3"></span><br></p> 
<p class="p3"><span class="s3"></span><br></p> 
<p class="p13"><span class="s3"></span><br></p> 
<p class="p10"><span class="s7"><strong>模块</strong></span></p> 
<ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">模块就是一个</span><span class="s9">python</span><span class="s3">文件</span></li><li class="li9"><span class="s8"></span><span class="s10">引入模块</span><span class="s3">import </span><span class="s10">文件名</span> 
  <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">注意在引入模块时，不需要加后缀</span><span class="s9">.py</span></li><li class="li7"><span class="s8"></span><span class="s3">可以同时引入多个，中间用逗号隔开</span></li><li class="li7"><span class="s8"></span><span class="s3">在使用引入模块的函数时，需要加上模块名使用</span><span class="s9"> </span><span class="s3">例如</span><span class="s9">importname.func()</span></li><li class="li7"><span class="s8"></span><span class="s3">一个模块只会被导入一次，不管执行多少次</span><span class="s9">import</span><span class="s3">。类似</span><span class="s9">php</span><span class="s3">中</span><span class="s9">include_once</span></li></ul></li><li class="li9"><span class="s8"></span><span class="s3">from…import</span><span class="s10">语句</span> 
  <ul class="ul1"><li class="li9"><span class="s8"></span><span class="s10">语法</span><span class="s3">from modname import name1,name2…</span></li><li class="li9"><span class="s8"></span><span class="s3">From modname import  *</span></li><li class="li7"><span class="s8"></span><span class="s3">注意与直接</span><span class="s9">import modname</span><span class="s3">的区别，这种方法引入时不需要加模块名称</span> 
    <ul class="ul1"><li class="li9"><span class="s8"></span><span class="s3">Modname.func() </span><span class="s10">与</span><span class="s3">func()</span><span class="s10">的区别</span></li></ul></li><li class="li7"><span class="s8"></span><span class="s3">理解为从一个模块中导入一个或几个函数</span></li><li class="li7"><span class="s8"></span><span class="s3">搜索路径</span> 
    <ul class="ul1"><li class="li9"><span class="s8"></span><span class="s10">当前目录</span><span class="s3">-</span><span class="s10">》</span><span class="s3">shell</span><span class="s10">变量下</span><span class="s3">PATHONPATH</span><span class="s10">下的每个目录</span><span class="s3">-</span><span class="s10">》默认路径一般为</span><span class="s3">/usr/local/lib/python/</span></li></ul></li></ul></li></ul> 
<ul class="ul1"><li> 
  <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">命名空间</span> 
    <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">全局变量，局部变量</span></li><li class="li7"><span class="s8"></span><span class="s3">在函数内使用全局变量的时候需要用关键字</span><span class="s9">global</span><span class="s3">进行声明</span></li></ul></li></ul></li></ul> 
<ul class="ul1"><li class="li7"><span class="s8"></span><span class="s9">Dir()</span><span class="s3">函数用来查看查询对象的属性和方法</span></li><li class="li9"><span class="s8"></span><span class="s3">globals()</span><span class="s10">函数和</span><span class="s3">locals()</span><span class="s10">函数</span> 
  <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">根据使用的地方不同，</span><span class="s9">globals() locals()</span><span class="s3">返回全局或局部命名空间里的名字</span></li><li class="li7"><span class="s8"></span><span class="s3">如果在函数内部调用</span><span class="s9">locals</span><span class="s3">（）返回的是所有能在该函数里访问的命名</span></li><li class="li7"><span class="s8"></span><span class="s3">如果在函数内部调用</span><span class="s9">globals</span><span class="s3">（）返回的是所有能在该函数里能访问的全局名字</span></li><li class="li7"><span class="s8"></span><span class="s3">两个函数返回的都是字典，所以能用</span><span class="s9">keys</span><span class="s3">（）函数摘取</span></li></ul></li><li class="li9"><span class="s8"></span><span class="s3">reload()</span><span class="s10">函数</span> 
  <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">当一个模块被导入到一个脚本，模块顶层代码只会被执行一次想要重新执行顶层代码使用本函数</span></li><li class="li9"><span class="s8"></span><span class="s10">语法：</span><span class="s3">reload(module_name)</span></li><li class="li14"><strong></strong><span class="s7"><strong>包</strong></span></li></ul></li><li class="li7"><span class="s8"></span><span class="s3">包就是一个文件夹但是该文件夹下必须有</span><span class="s9">__init__.py </span><span class="s3">文件，可以为空，用来标识这是一个包</span></li><li class="li5"><span class="s6"><strong></strong></span><span class="s7"><strong>文件</strong></span><span class="s3"><strong>I/O</strong></span></li><li class="li9"><span class="s8"></span><span class="s3">Print() </span><span class="s10">打印字符</span></li><li class="li9"><span class="s8"></span><span class="s3">raw_input() </span><span class="s10">从标准输入读取一个字符串</span></li><li class="li9"><span class="s8"></span><span class="s3">Input() </span><span class="s10">与</span><span class="s3">raw_input()</span><span class="s10">函数基本一致，但是</span><span class="s3">input</span><span class="s10">函数能够接受表达式</span></li><li class="li7"><span class="s8"></span><span class="s3">打开和关闭文件</span> 
  <ul class="ul1"><li class="li9"><span class="s8"></span><span class="s3">open()</span><span class="s10">函数</span><span class="s3"> file object=open(file_name[,access_mode][,buffering]),</span><span class="s10">第二个参数决定打开方式</span></li><li class="li7"><span class="s8"></span><span class="s9">file</span><span class="s3">对象的属性</span> 
    <ul class="ul1"><li class="li9"><span class="s8"></span><span class="s3">file_object.closed  </span><span class="s10">返回</span><span class="s3">true</span><span class="s10">文件被关闭，否则返回</span><span class="s3">false</span></li><li class="li9"><span class="s8"></span><span class="s3">file_object.mode </span><span class="s10">返回被打开文件的访问模式</span></li><li class="li9"><span class="s8"></span><span class="s3">File_object.name </span><span class="s10">返回文件的名称</span></li><li class="li9"><span class="s8"></span><span class="s3">file_object.softspace </span><span class="s10">如果用</span><span class="s3">print</span><span class="s10">输出后，必须跟一个空格符，则返回</span><span class="s3">false</span><span class="s10">。否则返回</span><span class="s3">true</span></li></ul></li></ul></li></ul> 
<ul class="ul1"><li> 
  <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s9">file</span><span class="s3">对象的方法</span> 
    <ul class="ul1"><li class="li9"><span class="s8"></span><span class="s3">close()</span><span class="s10">方法</span><span class="s3"> </span><span class="s10">关闭文件</span><span class="s3"> </span><span class="s10">语法</span><span class="s3"> file_object.close()        php fclose($handle)</span></li><li class="li9"><span class="s8"></span><span class="s3">file.flush()</span><span class="s10">刷新文件内部缓冲</span></li><li class="li9"><span class="s8"></span><span class="s3">file.fileno()</span><span class="s10">返回一个文件描述符</span></li><li class="li9"><span class="s8"></span><span class="s3">file.isatty()</span><span class="s10">如果文件链接到一个设备终端返回</span><span class="s3">true</span><span class="s10">，否则返回</span><span class="s3">false</span></li><li class="li9"><span class="s8"></span><span class="s3">file.next()</span><span class="s10">返回文件的下一行</span></li><li class="li7"><span class="s8"></span><span class="s9">file.read([size]) </span><span class="s3">从文件读取制定的字节数，未指定或为负则读取所有</span></li><li class="li9"><span class="s8"></span><span class="s3">file.readline([size])</span><span class="s10">未指定读取整行</span><span class="s3">,</span><span class="s10">指定读取</span><span class="s3">size</span><span class="s10">字节</span><span class="s3"> </span><span class="s10">包含</span><span class="s3">“\n”,</span></li><li class="li7"><span class="s8"></span><span class="s9">file.readlines([sizehint])</span><span class="s3">读取所有行并返回列表，若给定</span><span class="s9">sizeint&gt;0,</span><span class="s3">则是设置一次读取多少字节，这是为了减轻读取压力</span></li><li class="li9"><span class="s8"></span><span class="s3">file.truncate([size])</span><span class="s10">截取文件，截取的字节通过</span><span class="s3">size</span><span class="s10">指定。默认为当前文件位置</span></li><li class="li7"><span class="s8"></span><span class="s9">file.writelines(sequence)</span><span class="s3">向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符</span></li><li class="li9"><span class="s8"></span><span class="s3">file_object.write(str),</span><span class="s10">该方法可以将任何字符串写入一个打开的文件</span> 
      <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">注意该方法不会在字符串结尾添加换行符</span><span class="s9">“\n”</span></li></ul></li></ul></li></ul></li></ul> 
<p class="p6"><span class="s3"></span><br></p> 
<ul class="ul1"><li> 
  <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s9">Read([count])</span><span class="s3">方法</span><span class="s9"> </span><span class="s3">从一个打开的文件中读取一个字符串</span> 
    <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s9">file_object.read()</span><span class="s3">从打开的文件中读取一个字符串，参数</span><span class="s9">count</span><span class="s3">是读取的字节数，不指定则尽可能的读取更多内容，很可能是读到文件结尾</span></li></ul></li></ul></li></ul> 
<ul class="ul1"><li class="li9"><span class="s8"></span><span class="s10">文件定位</span><span class="s3"> tell() seek(offset[,from])</span> 
  <ul class="ul1"><li class="li9"><span class="s8"></span><span class="s3">file_object.tell() </span><span class="s10">返回当前位置</span></li><li class="li7"><span class="s8"></span><span class="s9">file_object.seek(offset[,from]),</span><span class="s3">改变当前位置，</span><span class="s9">offset</span><span class="s3">表示要移动的字节数，</span><span class="s9">from</span><span class="s3">表示开始移动的参考位置，</span><span class="s9">0</span><span class="s3">表示开头作为参考位置，</span><span class="s9">1</span><span class="s3">表示当前位置作为参考值，</span><span class="s9">2</span><span class="s3">表示文件末尾作为参考值</span> 
    <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">注意：在</span><span class="s9">write</span><span class="s3">内容后直接</span><span class="s9">read</span><span class="s3">文件输出为空，是因为指针已经在文</span><span class="s9"> </span><span class="s3">件末尾</span> 
      <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">解决方法：关闭文件，重新打开。使用</span><span class="s9">seek</span><span class="s3">函数将指针移到起始位置</span></li></ul></li></ul></li></ul></li><li class="li9"><span class="s8"></span><span class="s3">with </span><span class="s10">语句的引入</span> 
  <ul class="ul1"><li class="li7"><span class="s8"></span><span class="s3">为保证能正确关闭文件且语言更加简洁</span> 
    <ul class="ul1"><li class="li9"><span class="s8"></span><span class="s3">with open(‘file_name’,’r’) as f</span> 
      <ul class="ul1"><li> 
        <ul class="ul1"><li class="li9"><span class="s8"></span><span class="s3">Print f.read();</span></li></ul></li></ul></li></ul></li></ul></li><li class="li10"><span class="s6"><strong></strong></span><span class="s7"><strong>异常处理</strong></span></li></ul> 
<p class="p9"><span class="s3"> </span><span class="s10">语法：</span><span class="s3">Try</span><span class="s10">：</span></p> 
<p class="p7"><span class="s9"> except </span><span class="s3">【错误类别】【，错误类别</span><span class="s9">2</span><span class="s3">】</span><span class="s9">…</span><span class="s3">：</span></p> 
<p class="p9"><span class="s3"> else</span><span class="s10">：</span></p> 
<p class="p7"><span class="s3">在</span><span class="s9">try</span><span class="s3">中出错，</span><span class="s9">except</span><span class="s3">捕捉到错误。没有错误执行</span><span class="s9">else</span></p> 
<p class="p9"><span class="s3">try-finlly</span><span class="s10">是无论是否出现异常都会执行</span><span class="s3">finlly</span><span class="s10">内容</span></p> 
<p class="p9"><span class="s10">使用</span><span class="s3">raise </span><span class="s10">触发异常</span></p> 
<p class="p9"><span class="s3"> raise Exception</span><span class="s10">（</span><span class="s3">“some info”</span><span class="s10">）；</span></p> 
<p class="p5"><span class="s3"><strong>os</strong></span><span class="s7"><strong>模块</strong></span></p> 
<ul class="ul1"><li class="li9"><span class="s8"></span><span class="s3">import os</span><span class="s10">引入模块</span></li><li class="li9"><span class="s8"></span><span class="s3">Os.rename(current_file_name,new_file_name)</span><span class="s10">文件重命名</span></li><li class="li9"><span class="s8"></span><span class="s3">Os.remove(‘filename’)</span><span class="s10">删除文件</span></li><li class="li9"><span class="s8"></span><span class="s3">Os.mkdir(“newdir”)</span><span class="s10">在当前目录下创建新目录</span></li><li class="li9"><span class="s8"></span><span class="s3">Os.chdir(‘newdir’) </span><span class="s10">改变当前目录</span></li><li class="li9"><span class="s8"></span><span class="s3">Os.getcwd()</span><span class="s10">显示当前的工作目录</span></li><li class="li9"><span class="s8"></span><span class="s3">Os.rmdir(‘dirname’) </span><span class="s10">删除目录</span></li><li class="li8"></ul> 
<p class="p6"><span class="s3"></span><br></p> 
<ul class="ul1"><li class="li14"><strong></strong></li></ul> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<p class="p6"><span class="s3"></span><br></p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a1513756ada4581ae32a3c65b6adece4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Windows】win10升级后多出一个盘怎么办？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7ff9d22b419f1ecd679c3cc6f49b85b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jquery事件三 -- load(), ready(), resize()以及bind()事件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>