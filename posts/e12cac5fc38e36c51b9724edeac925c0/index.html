<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity渲染管线基础知识学习与总结（一） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity渲染管线基础知识学习与总结（一）" />
<meta property="og:description" content=" Unity渲染管线基础知识学习与总结 引言渲染流程概述GPU渲染管线（GPU流水线） 引言 鄙人只是对游戏开发感兴趣，所以在不断学习游戏相关知识，越往深入去学习游戏开发与制作，越感觉自己会的东西很少。鄙人想深入了解特效的开发制作，对渲染管线流程深入学习。做一个上架游戏或者demo需要很多计算机、物理、数学、动画以及美术等多学科基础，做一个demo为例包括以下几个部分：
游戏剧情及内容策划：做一个游戏首先要确定你的游戏主题及风格，自己做个demo主要看你想做什么风格的游戏。游戏模型及场景制作：这是游戏的根本元素，游戏对象模型制作的是否精美、是否入目直接影响整个游戏的玩赏性，这个需要一定的美术功底，可以学习3dmax、maya、blender、zbrush等软件来进行人物及场景建模。游戏动画制作：主角的行走、奔跑以及攻击等动画，可以通过Unity、3dmax、maya等制作，2D像素游戏可以由PS制作。游戏编程：Unity通过C#、JS编写，UE4由C&#43;&#43;编写；主要编写游戏运动逻辑、UI界面、状态机管理等，需要了解数据结构、多线程甚至GPU计算等知识。特效渲染制作：通过编写Shader实现游戏中炫酷的特效，这里需要知道GPU渲染流程及原理，会shader编程应该是做游戏开发中比较高级的技术。 渲染流程概述 渲染流程可以由上图概述：
该过程表示将CPU内存(RAM)中存储的模型顶点、法线、三角面以及UV等渲染所需要的信息加载到显存当中(VRAM),这是因为GPU对于显存的访问速度更快，而且大多数GPU不能直接访问RAM。该过程包含两个内容，一个是读取显存中模型的顶点等渲染数据，另一个是接收来自CPU的Draw Call指令，该指令告诉GPU按照CPU设置的方式渲染。将经过GPU渲染管线后的颜色缓冲区的颜色输出到屏幕上，上述所有的操作需要我们编程操作的便是GPU渲染管线阶段，也是我们编写shader的核心。 GPU渲染管线（GPU流水线） 该图来自书籍《Unity Shader入门精要》，讲的比较详细，国内Shader方面的书比较少，推荐这本入门。
顶点着色器：是完全可以编程的，它的是流水线的第一个阶段，用于顶点坐标变换以及顶点颜色计算等，在这里改变顶点的位置可以模拟水面和布料等的运动。其中，顶点着色器将顶点坐标从模型空间转换到齐次裁剪空间，接着进行裁剪剔除不渲染的点后，最终得到归一化的设备坐标（NDC），Unity设备坐标范围同OpenGL一样在[-1,1]之间。曲面细分着色器、几何着色器：都是可选的着色器，不必过于了解。裁剪：由于我们的场景会很大，摄像机视野外的画面不需要进行渲染计算，所以裁剪的作用便是剔除视野外的图元。如下图一条线段A点在视野内，B点在视野外，将会剔除B点，取线段与视野交点处C点。注意裁剪这一步我们不可以编辑，这是硬件上的固定操作。 屏幕映射：将图元的x和y坐标转换到屏幕坐标系，这与屏幕的分辨率有关，而图元的z坐标表示各物体与摄像机的远近，用于判断各图元的遮挡关系，这一阶段输出屏幕坐标系下的顶点坐标，Z深度信息，法线方向等。光栅化：我的理解是将屏幕坐标系坐标转换为图像像素的过程。光栅化处理包含以下几个部分：
1）三角形设置：计算三角形网格的边界像素坐标。
2）三角形遍历：该阶段将会检查每个像素是否被三角网格覆盖，对应覆盖像素会生成一个片元，而片元的状态由三角网格三个顶点插值得到，注意片元不是像素。这些片元包含屏幕坐标、深度、法线、UV等。
3）片元着色器：可以编程，对纹理进行采样，输出该片元的颜色信息。逐片元操作：这一阶段决定片元的可见性，通过模板测试、深度测试后，将片元的颜色和已经存储在颜色缓冲区的颜色进行混合存入颜色缓冲区。为了避免看到正在栅格化的图元，GPU使用双重缓冲，场景渲染是在幕后的后置缓冲区进行的，一旦场景渲染完成后会将后置缓冲区内容与前置缓冲区交换，保证图像的连续性。
这一小节主要了解渲染基本流程，后面会进行实例编程讲解，这个过程有些枯燥，但这是必经之路，加油老铁们！ " />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/e12cac5fc38e36c51b9724edeac925c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-26T19:55:41+08:00" />
<meta property="article:modified_time" content="2019-11-26T19:55:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity渲染管线基础知识学习与总结（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Unity渲染管线基础知识学习与总结</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">引言</a></li><li><a href="#_10" rel="nofollow">渲染流程概述</a></li><li><a href="#GPUGPU_18" rel="nofollow">GPU渲染管线（GPU流水线）</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>引言</h3> 
<p>鄙人只是对游戏开发感兴趣，所以在不断学习游戏相关知识，越往深入去学习游戏开发与制作，越感觉自己会的东西很少。鄙人想深入了解特效的开发制作，对渲染管线流程深入学习。做一个上架游戏或者demo需要很多计算机、物理、数学、动画以及美术等多学科基础，做一个demo为例包括以下几个部分：</p> 
<ul><li>游戏剧情及内容策划：做一个游戏首先要确定你的游戏主题及风格，自己做个demo主要看你想做什么风格的游戏。</li><li>游戏模型及场景制作：这是游戏的根本元素，游戏对象模型制作的是否精美、是否入目直接影响整个游戏的玩赏性，这个需要一定的美术功底，可以学习3dmax、maya、blender、zbrush等软件来进行人物及场景建模。</li><li>游戏动画制作：主角的行走、奔跑以及攻击等动画，可以通过Unity、3dmax、maya等制作，2D像素游戏可以由PS制作。</li><li>游戏编程：Unity通过C#、JS编写，UE4由C++编写；主要编写游戏运动逻辑、UI界面、状态机管理等，需要了解数据结构、多线程甚至GPU计算等知识。</li><li>特效渲染制作：通过编写Shader实现游戏中炫酷的特效，这里需要知道GPU渲染流程及原理，会shader编程应该是做游戏开发中比较高级的技术。</li></ul> 
<h3><a id="_10"></a>渲染流程概述</h3> 
<p><img src="https://images2.imgbox.com/05/59/6ETsoHGK_o.png" alt="在这里插入图片描述"><br> 渲染流程可以由上图概述：</p> 
<ol><li>该过程表示将CPU内存(RAM)中存储的模型顶点、法线、三角面以及UV等渲染所需要的信息加载到显存当中(VRAM),这是因为GPU对于显存的访问速度更快，而且大多数GPU不能直接访问RAM。</li><li>该过程包含两个内容，一个是读取显存中模型的顶点等渲染数据，另一个是接收来自CPU的Draw Call指令，该指令告诉GPU按照CPU设置的方式渲染。</li><li>将经过GPU渲染管线后的颜色缓冲区的颜色输出到屏幕上，上述所有的操作需要我们编程操作的便是GPU渲染管线阶段，也是我们编写shader的核心。</li></ol> 
<h3><a id="GPUGPU_18"></a>GPU渲染管线（GPU流水线）</h3> 
<p>该图来自书籍《Unity Shader入门精要》，讲的比较详细，国内Shader方面的书比较少，推荐这本入门。<br> <img src="https://images2.imgbox.com/dd/7f/xmRG2122_o.png" alt="在这里插入图片描述"></p> 
<ul><li><mark>顶点着色器</mark>：是完全可以编程的，它的是流水线的第一个阶段，用于顶点坐标变换以及顶点颜色计算等，在这里改变顶点的位置可以模拟水面和布料等的运动。其中，顶点着色器将顶点坐标从模型空间转换到齐次裁剪空间，接着进行裁剪剔除不渲染的点后，最终得到归一化的设备坐标（NDC），Unity设备坐标范围同OpenGL一样在[-1,1]之间。</li><li>曲面细分着色器、几何着色器：都是可选的着色器，不必过于了解。</li><li><mark>裁剪</mark>：由于我们的场景会很大，摄像机视野外的画面不需要进行渲染计算，所以裁剪的作用便是剔除视野外的图元。如下图一条线段A点在视野内，B点在视野外，将会剔除B点，取线段与视野交点处C点。注意裁剪这一步我们不可以编辑，这是硬件上的固定操作。</li></ul> 
<div align="center"> 
 <img src="https://images2.imgbox.com/f2/5d/RuWxP01M_o.png" width="45%"> 
</div> 
<ul><li><mark>屏幕映射</mark>：将图元的x和y坐标转换到屏幕坐标系，这与屏幕的分辨率有关，而图元的z坐标表示各物体与摄像机的远近，用于判断各图元的遮挡关系，这一阶段输出屏幕坐标系下的顶点坐标，Z深度信息，法线方向等。</li><li><mark>光栅化</mark>：我的理解是将屏幕坐标系坐标转换为图像像素的过程。光栅化处理包含以下几个部分：<br> 1）三角形设置：计算三角形网格的边界像素坐标。<br> 2）三角形遍历：该阶段将会检查每个像素是否被三角网格覆盖，对应覆盖像素会生成一个片元，而片元的状态由三角网格三个顶点插值得到，注意片元不是像素。这些片元包含屏幕坐标、深度、法线、UV等。<br> 3）<mark>片元着色器</mark>：可以编程，对纹理进行采样，输出该片元的颜色信息。</li><li>逐片元操作：这一阶段决定片元的可见性，通过模板测试、深度测试后，将片元的颜色和已经存储在颜色缓冲区的颜色进行混合存入颜色缓冲区。为了避免看到正在栅格化的图元，GPU使用<strong>双重缓冲</strong>，场景渲染是在幕后的<strong>后置缓冲区</strong>进行的，一旦场景渲染完成后会将<strong>后置缓冲区</strong>内容与<strong>前置缓冲区</strong>交换，保证图像的连续性。<br> <s>这一小节主要了解渲染基本流程，后面会进行实例编程讲解，这个过程有些枯燥，但这是必经之路，加油老铁们！</s></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/99942246f147494f993f357a5bf0d6fd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NX二次开发    获取图纸页上的全部注释</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6370e4b3a47b7708a18db98e6e006f68/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JAVA中集合List练习之获取10个1-20之间的随机数，要求不能重复</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>