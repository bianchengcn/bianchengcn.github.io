<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端面试题型汇总（适合应届/社招1年水平） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端面试题型汇总（适合应届/社招1年水平）" />
<meta property="og:description" content="【本文内容是我应届找实习的时候整理的（2020年），如果有部分内容落后或不正确的欢迎指正~同时也更新了社招篇面经，欢迎光临👉 前端面试题型汇总（适合社招两-三年水平）】
目录
HTML
HTML语义化
的作用
SEO中的TDK
HTML5中新增标签
块级元素和内联元素
img中的alt和title的区别
title与h1的区别、b与strong的区别、i与em的区别
元标签
label标签的作用
iframe的缺点
HTML和XHTML的区别
repaint和reflow
为什么div&#43;css的格式替代了table
CSS
css样式初始化
块级元素和内联元素样式区别
css的盒模型
伪类和伪元素
position各属性区别
display各属性区别
float浮动对元素的影响
display：none和visibility：hidden的区别
display，float，position的相互影响
样式中属性的继承
BFC块级格式化上下文
css hack
css选择器及其权重优先级
清除浮动的几种方法
动画（animation）
transition和animation的区别
媒体查询，@media
水平、垂直居中的几种方式
省略文本的样式
box-sizing属性
双栏布局和三栏布局
css预处理，less和sass
css sprite
z-index属性 scale和zoom区别
flex弹性布局
px，em，rem，vh的区别
单行文字居中，多行文字左对齐 CSS面试题
JavaScript
基本数据类型
undefined和null的区别
判断数据类型的方式（比较typeof与instanceof）
参数的按值传递的理解
执行环境和作用域链
模仿块级作用域
js原型和原型链
作用域链和原型链的区别
js创建对象的方式
js实现继承的方式
对闭包的理解
this指向问题 模拟new实现创建对象
防抖函数
节流函数 DOM操作
DOM0级和DOM2级的事件处理程序
事件冒泡和事件捕获
不同浏览器如何阻止事件冒泡" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/98c0c17e9ec9d473f7b37ec0e24c0082/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-28T17:18:07+08:00" />
<meta property="article:modified_time" content="2022-11-28T17:18:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端面试题型汇总（适合应届/社招1年水平）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>【本文内容是我应届找实习的时候整理的（2020年），如果有部分内容落后或不正确的欢迎指正~同时也更新了社招篇面经，欢迎光临👉 <a class="link-info" href="https://blog.csdn.net/CWH0908/article/details/126448361" title="前端面试题型汇总（适合社招两-三年水平）">前端面试题型汇总（适合社招两-三年水平）</a>】</p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="HTML-toc" style="margin-left:40px;"><a href="#HTML" rel="nofollow">HTML</a></p> 
<p id="HTML%E8%AF%AD%E4%B9%89%E5%8C%96-toc" style="margin-left:80px;"><a href="#HTML%E8%AF%AD%E4%B9%89%E5%8C%96" rel="nofollow">HTML语义化</a></p> 
<p id="%3C!DOCTYPE%3E%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#%3C!DOCTYPE%3E%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">的作用</a></p> 
<p id="SEO%E4%B8%AD%E7%9A%84TDK-toc" style="margin-left:80px;"><a href="#SEO%E4%B8%AD%E7%9A%84TDK" rel="nofollow">SEO中的TDK</a></p> 
<p id="HTML5%E4%B8%AD%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE-toc" style="margin-left:80px;"><a href="#HTML5%E4%B8%AD%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE" rel="nofollow">HTML5中新增标签</a></p> 
<p id="%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0" rel="nofollow">块级元素和内联元素</a></p> 
<p id="img%E4%B8%AD%E7%9A%84alt%E5%92%8Ctitle%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#img%E4%B8%AD%E7%9A%84alt%E5%92%8Ctitle%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">img中的alt和title的区别</a></p> 
<p id="title%E4%B8%8Eh1%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81b%E4%B8%8Estrong%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81i%E4%B8%8Eem%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#title%E4%B8%8Eh1%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81b%E4%B8%8Estrong%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81i%E4%B8%8Eem%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">title与h1的区别、b与strong的区别、i与em的区别</a></p> 
<p id="%3Cmeta%3E%E5%85%83%E6%A0%87%E7%AD%BE-toc" style="margin-left:80px;"><a href="#%3Cmeta%3E%E5%85%83%E6%A0%87%E7%AD%BE" rel="nofollow">元标签</a></p> 
<p id="label%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#label%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">label标签的作用</a></p> 
<p id="iframe%E7%9A%84%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><a href="#iframe%E7%9A%84%E7%BC%BA%E7%82%B9" rel="nofollow">iframe的缺点</a></p> 
<p id="HTML%E5%92%8CXHTML%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#HTML%E5%92%8CXHTML%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">HTML和XHTML的区别</a></p> 
<p id="repaint%E5%92%8Creflow-toc" style="margin-left:80px;"><a href="#repaint%E5%92%8Creflow" rel="nofollow">repaint和reflow</a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88div%2Bcss%E7%9A%84%E6%A0%BC%E5%BC%8F%E6%9B%BF%E4%BB%A3%E4%BA%86table-toc" style="margin-left:80px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88div%2Bcss%E7%9A%84%E6%A0%BC%E5%BC%8F%E6%9B%BF%E4%BB%A3%E4%BA%86table" rel="nofollow">为什么div+css的格式替代了table</a></p> 
<p id="CSS-toc" style="margin-left:40px;"><a href="#CSS" rel="nofollow">CSS</a></p> 
<p id="css%E6%A0%B7%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#css%E6%A0%B7%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">css样式初始化</a></p> 
<p id="%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F%E5%8C%BA%E5%88%AB" rel="nofollow">块级元素和内联元素样式区别</a></p> 
<p id="css%E7%9A%84%E7%9B%92%E6%A8%A1%E5%9E%8B-toc" style="margin-left:80px;"><a href="#css%E7%9A%84%E7%9B%92%E6%A8%A1%E5%9E%8B" rel="nofollow">css的盒模型</a></p> 
<p id="%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0" rel="nofollow">伪类和伪元素</a></p> 
<p id="position%E5%90%84%E5%B1%9E%E6%80%A7%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#position%E5%90%84%E5%B1%9E%E6%80%A7%E5%8C%BA%E5%88%AB" rel="nofollow">position各属性区别</a></p> 
<p id="display%E5%90%84%E5%B1%9E%E6%80%A7%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#display%E5%90%84%E5%B1%9E%E6%80%A7%E5%8C%BA%E5%88%AB" rel="nofollow">display各属性区别</a></p> 
<p id="float%E6%B5%AE%E5%8A%A8%E5%AF%B9%E5%85%83%E7%B4%A0%E7%9A%84%E5%BD%B1%E5%93%8D-toc" style="margin-left:80px;"><a href="#float%E6%B5%AE%E5%8A%A8%E5%AF%B9%E5%85%83%E7%B4%A0%E7%9A%84%E5%BD%B1%E5%93%8D" rel="nofollow">float浮动对元素的影响</a></p> 
<p id="display%EF%BC%9Anone%E5%92%8Cvisibility%EF%BC%9Ahidden%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#display%EF%BC%9Anone%E5%92%8Cvisibility%EF%BC%9Ahidden%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">display：none和visibility：hidden的区别</a></p> 
<p id="display%EF%BC%8Cfloat%EF%BC%8Cposition%E7%9A%84%E7%9B%B8%E4%BA%92%E5%BD%B1%E5%93%8D-toc" style="margin-left:80px;"><a href="#display%EF%BC%8Cfloat%EF%BC%8Cposition%E7%9A%84%E7%9B%B8%E4%BA%92%E5%BD%B1%E5%93%8D" rel="nofollow">display，float，position的相互影响</a></p> 
<p id="%E6%A0%B7%E5%BC%8F%E4%B8%AD%E5%B1%9E%E6%80%A7%E7%9A%84%E7%BB%A7%E6%89%BF-toc" style="margin-left:80px;"><a href="#%E6%A0%B7%E5%BC%8F%E4%B8%AD%E5%B1%9E%E6%80%A7%E7%9A%84%E7%BB%A7%E6%89%BF" rel="nofollow">样式中属性的继承</a></p> 
<p id="BFC%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87-toc" style="margin-left:80px;"><a href="#BFC%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87" rel="nofollow">BFC块级格式化上下文</a></p> 
<p id="css%20hack-toc" style="margin-left:80px;"><a href="#css%20hack" rel="nofollow">css hack</a></p> 
<p id="css%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E5%85%B6%E6%9D%83%E9%87%8D%E4%BC%98%E5%85%88%E7%BA%A7-toc" style="margin-left:80px;"><a href="#css%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E5%85%B6%E6%9D%83%E9%87%8D%E4%BC%98%E5%85%88%E7%BA%A7" rel="nofollow">css选择器及其权重优先级</a></p> 
<p id="%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95" rel="nofollow">清除浮动的几种方法</a></p> 
<p id="css3%E8%BF%87%E6%B8%A1%EF%BC%88transition%EF%BC%89%E3%80%81%E5%8F%98%E5%8C%96%EF%BC%88transform%EF%BC%89%E3%80%81%E5%8A%A8%E7%94%BB%EF%BC%88animation%EF%BC%89-toc" style="margin-left:80px;"><a href="#css3%E8%BF%87%E6%B8%A1%EF%BC%88transition%EF%BC%89%E3%80%81%E5%8F%98%E5%8C%96%EF%BC%88transform%EF%BC%89%E3%80%81%E5%8A%A8%E7%94%BB%EF%BC%88animation%EF%BC%89" rel="nofollow">动画（animation）</a></p> 
<p id="%C2%A0transition%E5%92%8Canimation%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%C2%A0transition%E5%92%8Canimation%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow"> transition和animation的区别</a></p> 
<p id="%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%EF%BC%8C%40media-toc" style="margin-left:80px;"><a href="#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%EF%BC%8C%40media" rel="nofollow">媒体查询，@media</a></p> 
<p id="%E6%B0%B4%E5%B9%B3%E3%80%81%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E6%B0%B4%E5%B9%B3%E3%80%81%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">水平、垂直居中的几种方式</a></p> 
<p id="%E7%9C%81%E7%95%A5%E6%96%87%E6%9C%AC%E7%9A%84%E6%A0%B7%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E7%9C%81%E7%95%A5%E6%96%87%E6%9C%AC%E7%9A%84%E6%A0%B7%E5%BC%8F" rel="nofollow">省略文本的样式</a></p> 
<p id="bix-sizing%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#bix-sizing%E5%B1%9E%E6%80%A7" rel="nofollow">box-sizing属性</a></p> 
<p id="%E5%8F%8C%E6%A0%8F%E5%B8%83%E5%B1%80%E5%92%8C%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80-toc" style="margin-left:80px;"><a href="#%E5%8F%8C%E6%A0%8F%E5%B8%83%E5%B1%80%E5%92%8C%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80" rel="nofollow">双栏布局和三栏布局</a></p> 
<p id="css%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%8Cless%E5%92%8Csass-toc" style="margin-left:80px;"><a href="#css%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%8Cless%E5%92%8Csass" rel="nofollow">css预处理，less和sass</a></p> 
<p id="css%20sprite-toc" style="margin-left:80px;"><a href="#css%20sprite" rel="nofollow">css sprite</a></p> 
<p id="z-index%E5%B1%9E%E6%80%A7%C2%A0-toc" style="margin-left:80px;"><a href="#z-index%E5%B1%9E%E6%80%A7%C2%A0" rel="nofollow">z-index属性 </a></p> 
<p id="scale%E5%92%8Czoom%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#scale%E5%92%8Czoom%E5%8C%BA%E5%88%AB" rel="nofollow">scale和zoom区别</a></p> 
<p id="flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80-toc" style="margin-left:80px;"><a href="#flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80" rel="nofollow">flex弹性布局</a></p> 
<p id="px%EF%BC%8Cem%EF%BC%8Crem%EF%BC%8Cvh%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#px%EF%BC%8Cem%EF%BC%8Crem%EF%BC%8Cvh%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">px，em，rem，vh的区别</a></p> 
<p id="%E5%8D%95%E8%A1%8C%E6%96%87%E5%AD%97%E5%B1%85%E4%B8%AD%EF%BC%8C%E5%A4%9A%E8%A1%8C%E6%96%87%E5%AD%97%E5%B7%A6%E5%AF%B9%E9%BD%90%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%8D%95%E8%A1%8C%E6%96%87%E5%AD%97%E5%B1%85%E4%B8%AD%EF%BC%8C%E5%A4%9A%E8%A1%8C%E6%96%87%E5%AD%97%E5%B7%A6%E5%AF%B9%E9%BD%90%C2%A0" rel="nofollow">单行文字居中，多行文字左对齐 </a></p> 
<p id="CSS%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:80px;"><a href="#CSS%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">CSS面试题</a></p> 
<p id="JavaScript-toc" style="margin-left:40px;"><a href="#JavaScript" rel="nofollow">JavaScript</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">基本数据类型</a></p> 
<p id="undefined%E5%92%8Cnull%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#undefined%E5%92%8Cnull%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">undefined和null的区别</a></p> 
<p id="%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E6%AF%94%E8%BE%83typeof%E4%B8%8Einstanceof%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E6%AF%94%E8%BE%83typeof%E4%B8%8Einstanceof%EF%BC%89" rel="nofollow">判断数据类型的方式（比较typeof与instanceof）</a></p> 
<p id="%E5%8F%82%E6%95%B0%E7%9A%84%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:80px;"><a href="#%E5%8F%82%E6%95%B0%E7%9A%84%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">参数的按值传递的理解</a></p> 
<p id="%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F-toc" style="margin-left:80px;"><a href="#%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F" rel="nofollow">执行环境和作用域链</a></p> 
<p id="%E6%A8%A1%E4%BB%BF%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-toc" style="margin-left:80px;"><a href="#%E6%A8%A1%E4%BB%BF%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F" rel="nofollow">模仿块级作用域</a></p> 
<p id="js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-toc" style="margin-left:80px;"><a href="#js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="nofollow">js原型和原型链</a></p> 
<p id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">作用域链和原型链的区别</a></p> 
<p id="js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F" rel="nofollow">js创建对象的方式</a></p> 
<p id="js%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#js%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F" rel="nofollow">js实现继承的方式</a></p> 
<p id="%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:80px;"><a href="#%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">对闭包的理解</a></p> 
<p id="this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%C2%A0-toc" style="margin-left:80px;"><a href="#this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%C2%A0" rel="nofollow">this指向问题 </a></p> 
<p id="%E6%A8%A1%E6%8B%9Fnew%E5%AE%9E%E7%8E%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#%E6%A8%A1%E6%8B%9Fnew%E5%AE%9E%E7%8E%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1" rel="nofollow">模拟new实现创建对象</a></p> 
<p id="%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0" rel="nofollow">防抖函数</a></p> 
<p id="%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:80px;"><a href="#%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">节流函数 </a></p> 
<p id="DOM%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#DOM%E6%93%8D%E4%BD%9C" rel="nofollow">DOM操作</a></p> 
<p id="DOM0%E7%BA%A7%E5%92%8CDOM2%E7%BA%A7%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F-toc" style="margin-left:80px;"><a href="#DOM0%E7%BA%A7%E5%92%8CDOM2%E7%BA%A7%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F" rel="nofollow">DOM0级和DOM2级的事件处理程序</a></p> 
<p id="%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7-toc" style="margin-left:80px;"><a href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7" rel="nofollow">事件冒泡和事件捕获</a></p> 
<p id="%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1-toc" style="margin-left:80px;"><a href="#%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1" rel="nofollow">不同浏览器如何阻止事件冒泡</a></p> 
<p id="%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1EventUtil-toc" style="margin-left:80px;"><a href="#%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1EventUtil" rel="nofollow">跨浏览器的事件对象EventUtil</a></p> 
<p id="%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E5%8F%8A%E5%85%B6%E5%A5%BD%E5%A4%84-toc" style="margin-left:80px;"><a href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E5%8F%8A%E5%85%B6%E5%A5%BD%E5%A4%84" rel="nofollow">事件委托及其好处</a></p> 
<p id="JSON%E5%92%8CXML%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#JSON%E5%92%8CXML%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow">JSON和XML的对比</a></p> 
<p id="Ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#Ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">Ajax请求的实现</a></p> 
<p id="Axios%E5%92%8CAjax%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#Axios%E5%92%8CAjax%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">Axios和Ajax的区别</a></p> 
<p id="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5" rel="nofollow">浏览器的同源策略</a></p> 
<p id="%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88-toc" style="margin-left:80px;"><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88" rel="nofollow">常用的跨域方案</a></p> 
<p id="cookie%E3%80%81localStorage%E3%80%81sessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#cookie%E3%80%81localStorage%E3%80%81sessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">cookie、localStorage、sessionStorage的区别</a></p> 
<p id="%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E9%87%8C%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%2C%E5%88%B0%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%B8%AD%E9%97%B4%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E9%87%8C%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%2C%E5%88%B0%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%B8%AD%E9%97%B4%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？</a></p> 
<p id="call%E3%80%81bind%E3%80%81apply%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#call%E3%80%81bind%E3%80%81apply%E5%8C%BA%E5%88%AB" rel="nofollow">call、bind、apply区别</a></p> 
<p id="get%E3%80%81post%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#get%E3%80%81post%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">get、post的区别</a></p> 
<p id="%E2%80%9C%20%3D%3D%3D%E2%80%9D%E3%80%81%E2%80%9C%20%3D%3D%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%E2%80%9C%20%3D%3D%3D%E2%80%9D%E3%80%81%E2%80%9C%20%3D%3D%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">“ ===”、“ ==”的区别</a></p> 
<p id="%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">同步和异步的区别</a></p> 
<p id="JS%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%A5%BD%E5%A4%84-toc" style="margin-left:80px;"><a href="#JS%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%A5%BD%E5%A4%84" rel="nofollow">JS模块化的好处</a></p> 
<p id="%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87-toc" style="margin-left:80px;"><a href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" rel="nofollow">执行上下文</a></p> 
<p id="%E6%B7%B1%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D" rel="nofollow">深拷贝</a></p> 
<p id="%E7%AE%80%E6%98%93%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#%E7%AE%80%E6%98%93%E5%A4%84%E7%90%86" rel="nofollow">简易处理</a></p> 
<p id="%E5%A4%8D%E6%9D%82%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#%E5%A4%8D%E6%9D%82%E5%A4%84%E7%90%86" rel="nofollow">复杂处理</a></p> 
<p id="js%E4%B8%ADimport%E5%92%8Crequire%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#js%E4%B8%ADimport%E5%92%8Crequire%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">js中import和require的区别</a></p> 
<p id="js%E6%8B%BC%E6%8E%A5%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#js%E6%8B%BC%E6%8E%A5%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E5%BC%8F" rel="nofollow">js拼接两个数组的方式</a></p> 
<p id="String%E3%80%81Number%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%C2%A0-toc" style="margin-left:80px;"><a href="#String%E3%80%81Number%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%C2%A0" rel="nofollow">String、Number类型运算 </a></p> 
<p id="%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">数组去重的几种方式</a></p> 
<p id="JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:80px;"><a href="#JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">JS正则表达式</a></p> 
<p id="defer%20%E3%80%81async%20%E5%92%8Csync-toc" style="margin-left:80px;"><a href="#defer%20%E3%80%81async%20%E5%92%8Csync" rel="nofollow">defer 、async 和sync</a></p> 
<p id="JS%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:40px;"><a href="#JS%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">JS面试题</a></p> 
<p id="Vue%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:40px;"><a href="#Vue%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">Vue面试题</a></p> 
<p id="vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:80px;"><a href="#vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" rel="nofollow">vue的生命周期</a></p> 
<p id="v-for%E4%B8%AD%3Akey%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#v-for%E4%B8%AD%3Akey%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">v-for中:key的作用</a></p> 
<p id="%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AA%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AA%E5%87%BD%E6%95%B0" rel="nofollow">组件中的data为什么是个函数</a></p> 
<p id="%C2%A0%E8%99%9A%E6%8B%9FDOM%E8%8A%82%E7%82%B9%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%E8%99%9A%E6%8B%9FDOM%E8%8A%82%E7%82%B9%C2%A0" rel="nofollow"> 虚拟DOM节点 </a></p> 
<p id="vue-cli%20%E8%84%9A%E6%89%8B%E6%9E%B6%20%E7%9B%AE%E5%BD%95%20%E8%A7%A3%E6%9E%90-toc" style="margin-left:80px;"><a href="#vue-cli%20%E8%84%9A%E6%89%8B%E6%9E%B6%20%E7%9B%AE%E5%BD%95%20%E8%A7%A3%E6%9E%90" rel="nofollow">vue-cli 脚手架 目录 解析</a></p> 
<p id="Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86" rel="nofollow">Vue双向数据绑定原理</a></p> 
<p id="MVVM%E6%98%AF%E4%BB%80%E4%B9%88%3F%C2%A0-toc" style="margin-left:80px;"><a href="#MVVM%E6%98%AF%E4%BB%80%E4%B9%88%3F%C2%A0" rel="nofollow">MVVM是什么? </a></p> 
<p id="%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8BMVVM%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8BMVVM%E6%A8%A1%E5%BC%8F" rel="nofollow">简述一下MVVM模式</a></p> 
<p id="MVVM%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%3F%C2%A0-toc" style="margin-left:80px;"><a href="#MVVM%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%3F%C2%A0" rel="nofollow">MVVM的优缺点? </a></p> 
<p id="Vue%E4%B8%ADMVVM%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#Vue%E4%B8%ADMVVM%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" rel="nofollow">Vue中MVVM实现的基本原理</a></p> 
<p id="Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-toc" style="margin-left:80px;"><a href="#Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1" rel="nofollow">Vue组件通信</a></p> 
<p id="computed%E5%92%8Cwatch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F-toc" style="margin-left:80px;"><a href="#computed%E5%92%8Cwatch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F" rel="nofollow">computed和watch有什么区别?</a></p> 
<p id="Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD-toc" style="margin-left:80px;"><a href="#Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD" rel="nofollow">Vue组件的按需加载</a></p> 
<p id="vue-router%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#vue-router%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86" rel="nofollow">vue-router的核心原理</a></p> 
<p id="vue%20mixins%E5%92%8Cextends%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#vue%20mixins%E5%92%8Cextends%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">vue mixins和extends的区别</a></p> 
<p id="Vue%E7%9A%84SEO%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#Vue%E7%9A%84SEO%E4%BC%98%E5%8C%96" rel="nofollow">Vue的SEO优化</a></p> 
<p id="Vue%20%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E6%95%B0%E7%BB%84%E9%A1%B9%E8%B5%8B%E5%80%BC%E5%8F%98%E5%8C%96%E5%90%97-toc" style="margin-left:80px;"><a href="#Vue%20%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E6%95%B0%E7%BB%84%E9%A1%B9%E8%B5%8B%E5%80%BC%E5%8F%98%E5%8C%96%E5%90%97" rel="nofollow">Vue 能检测到数组项赋值变化吗</a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%20vue%20%E4%B8%8D%E9%9C%80%E8%A6%81%E5%85%B3%E5%BF%83%20shouldcomponetupdate%EF%BC%88react%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%20vue%20%E4%B8%8D%E9%9C%80%E8%A6%81%E5%85%B3%E5%BF%83%20shouldcomponetupdate%EF%BC%88react%EF%BC%89" rel="nofollow">为什么 vue 不需要关心 shouldcomponetupdate（react）</a></p> 
<p id="React%20%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:40px;"><a href="#React%20%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">React 面试题</a></p> 
<p id="React%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:80px;"><a href="#React%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" rel="nofollow">React 生命周期</a></p> 
<p id="%E4%B8%BA%E4%BD%95%E8%A6%81%E5%9C%A8componentDidMount%E9%87%8C%E9%9D%A2%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%9F%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%B8%BA%E4%BD%95%E8%A6%81%E5%9C%A8componentDidMount%E9%87%8C%E9%9D%A2%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%9F%C2%A0" rel="nofollow">为何要在componentDidMount里面发送请求？ </a></p> 
<p id="React%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81-toc" style="margin-left:80px;"><a href="#React%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81" rel="nofollow">React单向数据流</a></p> 
<p id="%3CSwitch%3E%20%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#%3CSwitch%3E%20%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">标签的作用</a></p> 
<p id="react%E4%B8%ADkey%E5%80%BC%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#react%E4%B8%ADkey%E5%80%BC%E4%BD%9C%E7%94%A8" rel="nofollow">react中key值作用</a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%20setState%20%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84-toc" style="margin-left:80px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%20setState%20%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84" rel="nofollow">为什么 setState 是异步的</a></p> 
<p id="item-5-toc" style="margin-left:80px;"><a href="#item-5" rel="nofollow">react 性能优化是哪个周期函数？</a></p> 
<p id="item-6-toc" style="margin-left:80px;"><a href="#item-6" rel="nofollow">为什么虚拟 dom 会提高性能?(必考)</a></p> 
<p id="react%20diff%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%87%E7%A8%8B-toc" style="margin-left:80px;"><a href="#react%20diff%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%87%E7%A8%8B" rel="nofollow">react diff算法的比较过程</a></p> 
<p id="%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%88%E7%B1%BB%E7%BB%84%E4%BB%B6%EF%BC%89%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%88%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%88%E7%B1%BB%E7%BB%84%E4%BB%B6%EF%BC%89%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%88%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">状态组件（类组件）和无状态组件（函数组件）的区别</a></p> 
<p id="item-12-toc" style="margin-left:80px;"><a href="#item-12" rel="nofollow">状态(state)和属性(props)之间有何不同</a></p> 
<p id="item-25-toc" style="margin-left:80px;"><a href="#item-25" rel="nofollow">讲一下redux</a></p> 
<p id="render%E5%87%BD%E6%95%B0%E4%B8%ADreturn%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8()%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#render%E5%87%BD%E6%95%B0%E4%B8%ADreturn%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%28%29%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98" rel="nofollow">render函数中return如果没有使用()会有什么问题</a></p> 
<p id="super()%E5%92%8Csuper(props)%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%C2%A0-toc" style="margin-left:80px;"><a href="#super%28%29%E5%92%8Csuper%28props%29%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%C2%A0" rel="nofollow">super()和super(props)有什么区别？ </a></p> 
<p id="react%E4%BD%BF%E7%94%A8async%2Fawait-toc" style="margin-left:80px;"><a href="#react%E4%BD%BF%E7%94%A8async%2Fawait" rel="nofollow">react使用async/await</a></p> 
<p id="%E8%AE%B2%E4%B8%80%E4%B8%8Breact%20%E7%9A%84%20jsx-toc" style="margin-left:80px;"><a href="#%E8%AE%B2%E4%B8%80%E4%B8%8Breact%20%E7%9A%84%20jsx" rel="nofollow">讲一下react 的 jsx</a></p> 
<p id="componentWillUpdate%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9state%E7%9A%84%E5%80%BC%E5%90%97%EF%BC%9F-toc" style="margin-left:80px;"><a href="#componentWillUpdate%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9state%E7%9A%84%E5%80%BC%E5%90%97%EF%BC%9F" rel="nofollow">componentWillUpdate可以直接修改state的值吗？</a></p> 
<p id="super()%E5%92%8Csuper(props)%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%86%99super%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#super%28%29%E5%92%8Csuper%28props%29%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%86%99super%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">super()和super(props)以及不写super的区别</a></p> 
<p id="Context%20%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#Context%20%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">Context 的作用</a></p> 
<p id="React%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E6%99%AE%E9%80%9A%E7%9A%84HTML%E4%BA%8B%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F-toc" style="margin-left:80px;"><a href="#React%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E6%99%AE%E9%80%9A%E7%9A%84HTML%E4%BA%8B%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F" rel="nofollow">React的事件和普通的HTML事件有什么不同？</a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E6%B2%A1%E6%9C%89%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E6%B2%A1%E6%9C%89%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F" rel="nofollow">为什么函数式组件没有生命周期？</a></p> 
<p id="%E5%9C%A8React%E4%B8%AD%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84render%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E5%9C%A8React%E4%B8%AD%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84render%EF%BC%9F" rel="nofollow">在React中如何避免不必要的render？</a></p> 
<p id="React%20%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%82%B9%E5%87%BB%E5%85%83%E7%B4%A0%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6-toc" style="margin-left:80px;"><a href="#React%20%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%82%B9%E5%87%BB%E5%85%83%E7%B4%A0%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6" rel="nofollow">React 如何判断点击元素属于哪一个组件</a></p> 
<p id="this.refs.XXX%20%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#this.refs.XXX%20%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">this.refs.XXX 的作用</a></p> 
<p id="vue%E5%92%8Creact%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px;"><a href="#vue%E5%92%8Creact%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">vue和react路由的区别是什么？</a></p> 
<p id="react%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#react%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">react绑定函数的四种方式</a></p> 
<p id="react%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-toc" style="margin-left:80px;"><a href="#react%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6" rel="nofollow">react高阶组件</a></p> 
<p id="%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AD%90%E7%BB%84%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AD%90%E7%BB%84%E4%BB%B6" rel="nofollow">函数作为子组件</a></p> 
<p id="React%20%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F%C2%A0-toc" style="margin-left:80px;"><a href="#React%20%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F%C2%A0" rel="nofollow">React 父组件如何调用子组件中的方法？ </a></p> 
<p id="React%20%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD%E7%9A%84%E6%89%8B%E6%AE%B5%3F-toc" style="margin-left:80px;"><a href="#React%20%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD%E7%9A%84%E6%89%8B%E6%AE%B5%3F" rel="nofollow">React 有哪些优化性能的手段?</a></p> 
<p id="%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5-toc" style="margin-left:80px;"><a href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5" rel="nofollow">类组件中的优化手段</a></p> 
<p id="%E6%96%B9%E6%B3%95%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5" rel="nofollow">方法组件中的优化手段</a></p> 
<p id="%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F" rel="nofollow">其他方式</a></p> 
<p id="react%20hook-toc" style="margin-left:80px;"><a href="#react%20hook" rel="nofollow">react hook</a></p> 
<p id="mixin%E3%80%81hoc%E3%80%81render%20props%E3%80%81react-hooks%E7%9A%84%E4%BC%98%E5%8A%A3%E5%A6%82%E4%BD%95%EF%BC%9F-toc" style="margin-left:80px;"><a href="#mixin%E3%80%81hoc%E3%80%81render%20props%E3%80%81react-hooks%E7%9A%84%E4%BC%98%E5%8A%A3%E5%A6%82%E4%BD%95%EF%BC%9F" rel="nofollow">mixin、hoc、render props、react-hooks的优劣如何？</a></p> 
<p id="react%20%E6%96%87%E7%AB%A0-toc" style="margin-left:80px;"><a href="#react%20%E6%96%87%E7%AB%A0" rel="nofollow">react 文章</a></p> 
<p id="Webpack%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:40px;"><a href="#Webpack%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">Webpack面试题</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AFWebpack-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AFWebpack" rel="nofollow">什么是Webpack</a></p> 
<p id="webpack%E4%B8%8Egrunt%E3%80%81gulp%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F-toc" style="margin-left:80px;"><a href="#webpack%E4%B8%8Egrunt%E3%80%81gulp%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F" rel="nofollow">webpack与grunt、gulp的不同？</a></p> 
<p id="NPM%E5%92%8Cwebpack%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:80px;"><a href="#NPM%E5%92%8Cwebpack%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow">NPM和webpack的关系</a></p> 
<p id="%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8Dbundle%EF%BC%8Cchunk%EF%BC%8Cmodule%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:80px;"><a href="#%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8Dbundle%EF%BC%8Cchunk%EF%BC%8Cmodule%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">分别介绍bundle，chunk，module是什么</a></p> 
<p id="%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D%E4%BB%80%E4%B9%88%E6%98%AFloader%3F%E4%BB%80%E4%B9%88%E6%98%AFplugin%3F-toc" style="margin-left:80px;"><a href="#%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D%E4%BB%80%E4%B9%88%E6%98%AFloader%3F%E4%BB%80%E4%B9%88%E6%98%AFplugin%3F" rel="nofollow">分别介绍什么是loader?什么是plugin?</a></p> 
<p id="%E4%BB%80%E4%B9%88%20%E6%98%AF%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%20%E6%98%AF%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%9F" rel="nofollow">什么 是模块热更新？</a></p> 
<p id="%C2%A0%E5%A6%82%E4%BD%95%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90webpack%E9%85%8D%E7%BD%AE%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%A6%82%E4%BD%95%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90webpack%E9%85%8D%E7%BD%AE%EF%BC%9F" rel="nofollow"> 如何可以自动生成webpack配置？</a></p> 
<p id="webpack-dev-server%E5%92%8Chttp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82nginx%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F-toc" style="margin-left:80px;"><a href="#webpack-dev-server%E5%92%8Chttp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82nginx%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F" rel="nofollow">webpack-dev-server和http服务器如nginx有什么区别?</a></p> 
<p id="webpack%E5%92%8Cgulp%E5%8C%BA%E5%88%AB%EF%BC%88%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89-toc" style="margin-left:80px;"><a href="#webpack%E5%92%8Cgulp%E5%8C%BA%E5%88%AB%EF%BC%88%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89" rel="nofollow">webpack和gulp区别（模块化与流的区别）</a></p> 
<p id="Git%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:40px;"><a href="#Git%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">Git面试题</a></p> 
<p id="问题3git和svn的优缺点-toc" style="margin-left:80px;"><a href="#%E9%97%AE%E9%A2%983git%E5%92%8Csvn%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">git和svn的优缺点。</a></p> 
<p id="Git%20%E9%87%8C%E9%9D%A2%E7%9A%84%20origin-toc" style="margin-left:80px;"><a href="#Git%20%E9%87%8C%E9%9D%A2%E7%9A%84%20origin" rel="nofollow">Git 里面的 origin</a></p> 
<p id="fetch%E5%92%8Cmerge%E5%92%8Cpull%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#fetch%E5%92%8Cmerge%E5%92%8Cpull%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">fetch和merge和pull的区别</a></p> 
<p id="%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" rel="nofollow">常用命令</a></p> 
<p id="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-toc" style="margin-left:40px;"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE" rel="nofollow">浏览器和网络协议</a></p> 
<p id="http%20%E5%92%8C%20https%20%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#http%20%E5%92%8C%20https%20%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB" rel="nofollow">http 和 https 有何区别</a></p> 
<p id="TCP%E4%BC%A0%E8%BE%93%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%C2%A0-toc" style="margin-left:80px;"><a href="#TCP%E4%BC%A0%E8%BE%93%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%C2%A0" rel="nofollow">TCP传输的三次握手 </a></p> 
<p id="%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%88%90%E5%8A%9F%E6%98%BE%E7%A4%BA%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%88%90%E5%8A%9F%E6%98%BE%E7%A4%BA%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%C2%A0" rel="nofollow">从输入URL到页面加载成功显示经历了什么 </a></p> 
<p id="%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81" rel="nofollow">常见的HTTP状态码</a></p> 
<p id="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:80px;"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">浏览器的内核分别是什么</a></p> 
<p id="%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%92%8C%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA-toc" style="margin-left:80px;"><a href="#%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%92%8C%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA" rel="nofollow">优雅降级和渐进增强</a></p> 
<p id="%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2-toc" style="margin-left:80px;"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2" rel="nofollow">浏览器是如何渲染页面</a></p> 
<p id="%E5%85%B3%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%85%B3%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%C2%A0" rel="nofollow">关于事件循环 </a></p> 
<p id="%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%96%B9%E5%BC%8F" rel="nofollow">垃圾回收机制方式</a></p> 
<p id="Web%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF-toc" style="margin-left:80px;"><a href="#Web%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF" rel="nofollow">Web攻击技术</a></p> 
<p id="转载-理解cookie和session机制-toc" style="margin-left:80px;"><a href="#%E8%BD%AC%E8%BD%BD-%E7%90%86%E8%A7%A3cookie%E5%92%8Csession%E6%9C%BA%E5%88%B6" rel="nofollow">理解Cookie和session机制</a></p> 
<p id="Cookie%E5%92%8Csession%E3%80%81storage%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB-toc" style="margin-left:80px;"><a href="#Cookie%E5%92%8Csession%E3%80%81storage%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB" rel="nofollow">Cookie和session、storage的区别和联系</a></p> 
<p id="%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84Http%E8%AF%B7%E6%B1%82%E5%A4%B4-toc" style="margin-left:80px;"><a href="#%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84Http%E8%AF%B7%E6%B1%82%E5%A4%B4" rel="nofollow">缓存相关的Http请求头</a></p> 
<p id="%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">观察者模式和发布-订阅模式的区别</a></p> 
<p id="%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" rel="nofollow">性能优化</a></p> 
<p id="%E5%85%B6%E4%BB%96-toc" style="margin-left:40px;"><a href="#%E5%85%B6%E4%BB%96" rel="nofollow">其他</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="HTML">HTML</h3> 
<ul><li> <h4 id="HTML%E8%AF%AD%E4%B9%89%E5%8C%96" style="margin-left:0cm;">HTML语义化</h4> </li></ul> 
<blockquote> 
 <ul><li>用正确的标签做正确的事情。</li><li>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</li><li>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</li><li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li></ul> 
</blockquote> 
<ul><li> <h4 id="%3C!DOCTYPE%3E%E7%9A%84%E4%BD%9C%E7%94%A8" style="margin-left:0cm;">&lt;!DOCTYPE&gt;的作用</h4> </li></ul> 
<blockquote> 
 <ul><li>不是一个HTML标签，是一个用于告诉浏览器当前HTML版本的指令</li><li>告知浏览器按照何种规范解析页面</li><li> 添加了，就等同于开启了标准模式</li></ul> 
</blockquote> 
<ul><li> <h4 id="SEO%E4%B8%AD%E7%9A%84TDK" style="margin-left:0cm;">SEO中的TDK</h4> </li></ul> 
<blockquote> 
 <ul><li> <p>在SEO中，所谓的TDK其实就是title、description、keywords这三个标签，这三个标签在网站的优化过程中，title标题标签，description描述标签，keywords关键词标签。</p> </li><li> <p><a href="https://blog.csdn.net/CWH0908/article/details/88030838" title="SEO中TDK详细介绍">SEO中TDK详细介绍</a></p> </li></ul> 
</blockquote> 
<ul><li> <h4 id="HTML5%E4%B8%AD%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE" style="margin-left:0cm;">HTML5中新增标签</h4> </li></ul> 
<blockquote> 
 <p style="margin-left:0cm;"><a href="https://www.cnblogs.com/fliu/articles/5244866.html" rel="nofollow" title="新增语义化标签">新增语义化标签</a></p> 
</blockquote> 
<ul><li> <h4 id="%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0" style="margin-left:0cm;">块级元素和内联元素</h4> </li></ul> 
<blockquote> 
 <p>常用的块级元素：</p> 
 <p> 　　address , center , div , dl ,, form , h1 , h2 , h3 , h4 , h5 , h6 , menu , ol , p , table , ul , li</p> 
 <p>常用内联的元素：</p> 
 <p>　　a , b , br , em , font , img , input , label , select , small , span , textarea  </p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/89407061" title="内联元素和块级元素的float属性区别">内联元素和块级元素的float属性区别</a></p> 
</blockquote> 
<ul><li> <h4 id="img%E4%B8%AD%E7%9A%84alt%E5%92%8Ctitle%E7%9A%84%E5%8C%BA%E5%88%AB" style="margin-left:0cm;">img中的alt和title的区别</h4> </li></ul> 
<blockquote> 
 <ul><li> <p>alt是给搜索引擎识别，在图像无法显示时的替代文本；</p> </li><li> <p>title是关于元素的注释信息，主要是给用户解读。当鼠标放到文字或是图片上时有title文字显示。</p> </li><li> <p>（因为IE不标准）在IE浏览器中alt起到了title的作用，变成文字提示。在定义img对象时，将alt和title属性写全，可以保证在各种浏览器中都能正常使用。</p> </li></ul> 
</blockquote> 
<ul><li> <h4 id="title%E4%B8%8Eh1%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81b%E4%B8%8Estrong%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81i%E4%B8%8Eem%E7%9A%84%E5%8C%BA%E5%88%AB" style="margin-left:0cm;">title与h1的区别、b与strong的区别、i与em的区别</h4> </li></ul> 
<blockquote> 
 <ul><li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；</li><li>strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<strong>是展示强调内容。</strong></strong></li><li>i内容展示为斜体，em表示强调的文本；</li></ul> 
</blockquote> 
<ul><li> <h4 id="%3Cmeta%3E%E5%85%83%E6%A0%87%E7%AD%BE" style="margin-left:0cm;">元标签</h4> </li></ul> 
<blockquote> 
 <p style="margin-left:0cm;">提供有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键词。</p> 
</blockquote> 
<ul><li> <h4 id="label%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8" style="margin-left:0cm;">label标签的作用</h4> </li></ul> 
<blockquote> 
 <p>label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p> 
 <pre class="has"><code class="language-html">&lt;label for="Name"&gt;Number:&lt;/label&gt;

&lt;input type="text" id="Name"/&gt;

</code></pre> 
 <p></p> 
</blockquote> 
<ul><li> <h4 id="iframe%E7%9A%84%E7%BC%BA%E7%82%B9" style="margin-left:0cm;">iframe的缺点</h4> </li></ul> 
<blockquote> 
 <ul><li>会阻塞主页面的Onload事件；</li><li>搜索引擎的检索程序无法解读这种页面，不利于SEO;</li><li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li></ul> 
 <p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript。动态给iframe添加src属性值，这样可以绕开以上两个问题。</p> 
</blockquote> 
<ul><li> <h4 id="HTML%E5%92%8CXHTML%E7%9A%84%E5%8C%BA%E5%88%AB" style="margin-left:0cm;">HTML和XHTML的区别</h4> </li></ul> 
<blockquote> 
 <ul><li>XHTML 元素必须被正确地嵌套。</li></ul> 
 <p>错误：</p> 
 <p>this is example.</p> 
 <p>正确：</p> 
 <p>this is example.</p> 
 <ul><li>XHTML 元素必须被关闭。</li></ul> 
 <p>错误：</p> 
 <p>this is example.</p> 
 <p>正确：</p> 
 <p>this is example.</p> 
 <ul><li>标签名必须用小写字母。</li></ul> 
 <p>错误：</p> 
 <p>this is example.</p> 
 <p></p> 
 <p>正确：</p> 
 <p>this is example.</p> 
 <ul><li>空标签也必须被关闭</li></ul> 
 <p>错误：</p> 
 <p>正确：</p> 
 <ul><li>XHTML 文档必须拥有根元素。</li></ul> 
 <p>所有的 XHTML 元素必须被嵌套于 根元素中。</p> 
</blockquote> 
<ul><li> <h4 id="repaint%E5%92%8Creflow" style="margin-left:0cm;">repaint和reflow</h4> </li></ul> 
<blockquote> 
 <ul><li> <p>repaint就是重绘，reflow就是回流</p> </li><li> <p>在性能优先的前提下，reflow的性能消耗要比repaint的大。</p> </li><li> <p> repaint是某个dom元素进行重绘，reflow是整个页面进行重排，也就是对页面所有的dom元素渲染。</p> </li></ul> 
</blockquote> 
<blockquote> 
 <ul><li> repaint的触发：</li></ul> 
 <p>  1）不涉及任何dom元素的排版问题的变动为repaint，例如元素的color、text-align等改变。</p> 
 <p>  2）color的修改，text-align的修改，a：hover也会造成重绘，伪类引起的颜色等变化不会导致页面的回流，仅仅会触发重绘。</p> 
 <ul><li>  reflow的触发：</li></ul> 
 <p> 1）width、height、border、margin、padding的修改</p> 
 <p> 2）通过hover造成元素表现的改动，如display:none会导致回流</p> 
 <p> 3）appendChild等dom元素操作。</p> 
 <p> 4）font类style 的修改。</p> 
 <p> 5)   background的修改，现在经过浏览器厂家的优化，部分background的修改只会触发repaint。<br>  </p> 
</blockquote> 
<blockquote> 
 <ul><li>如何尽量避免回流reflow：</li></ul> 
 <p>a、尽可能在dom末稍通过修改class来修改元素的style属性，尽可能减少受影响的dom元素。</p> 
 <p>b、避免设置多项内联样式，使用常用的class方式进行设置样式，以避免设置样式时访问dom的低效率。</p> 
 <p>c、设置动画元素position属性为fixed或absolute：由于当前元素从dom流中独立出来，因此受影响的只有当前元素。</p> 
 <p>d、牺牲平滑度满足性能：动画精度太强，会造成更多的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。</p> 
 <p>f、避免使用table进行布局，table每个元素的大小以及内容的改变，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以针对性的repaint和避免不必要的reflow。</p> 
 <p>g、避免在css中使用运算式<br>  </p> 
</blockquote> 
<ul><li> <h4 id="%E4%B8%BA%E4%BB%80%E4%B9%88div%2Bcss%E7%9A%84%E6%A0%BC%E5%BC%8F%E6%9B%BF%E4%BB%A3%E4%BA%86table">为什么div+css的格式替代了table</h4> </li></ul> 
<blockquote> 
 <ul><li>div+css编写出来的文件比用table边写出来的文件小。</li><li>table必须在页面完全加载后才显示，div则是逐行显示。</li><li>table的嵌套性太多，没有div简洁</li></ul> 
</blockquote> 
<h3 id="CSS">CSS</h3> 
<ul><li> <h4 id="css%E6%A0%B7%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96">css样式初始化</h4> </li></ul> 
<blockquote> 
 <ul><li>原因</li></ul> 
 <p>因为浏览器的兼容的问题，不同浏览器有些标签的默认值是不同的，如果没有CSS初始化往往会出现浏览器之间的页面显示差异。</p> 
 <ul><li>弊端</li></ul> 
 <p>初始化样式会对SEO有一定的影响</p> 
 <ul><li>淘宝初始化样式</li></ul> 
 <pre class="has"><code class="language-css">body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }
body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }
h1, h2, h3, h4, h5, h6{ font-size:100%; }
address, cite, dfn, em, var { font-style:normal; }
code, kbd, pre, samp { font-family:couriernew, courier, monospace; }
small{ font-size:12px; }
ul, ol { list-style:none; }
a { text-decoration:none; }
a:hover { text-decoration:underline; }
sup { vertical-align:text-top; }
sub{ vertical-align:text-bottom; }
legend { color:#000; }
fieldset, img { border:0; }
button, input, select, textarea { font-size:100%; }</code></pre> 
 <p></p> 
</blockquote> 
<ul><li> <h4 id="%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F%E5%8C%BA%E5%88%AB">块级元素和内联元素样式区别</h4> </li></ul> 
<blockquote> 
 <ul><li>内联元素：</li></ul> 
 <ol><li> <p>内联元素(inline)不会独占一行，相邻的内联元素会排在同一行。其宽度随内容的变化而变化。 </p> </li><li> <p>内联元素不可以设置宽高 </p> </li><li> <p>内联元素可以设置margin，padding，但只在水平方向有效。</p> </li></ol> 
 <p></p> 
 <ul><li>块状元素：</li></ul> 
 <ol><li>块级元素会独占一行，默认情况下宽度自动填满其父元素宽度 </li><li>块级元素可以设置宽高 </li><li>块级元素可以设置margin，padding</li></ol> 
 <p></p> 
 <ul><li>内联块状元素 inline-block：</li></ul> 
 <p>表现为同行显示并可修改宽高内外边距等属性。简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现（可以设置宽高和margin值）。之后的内联对象会被排列在同一内联。比如我们可以给一个span标签设置inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。</p> 
</blockquote> 
<ul><li> <h4 id="css%E7%9A%84%E7%9B%92%E6%A8%A1%E5%9E%8B">css的盒模型</h4> </li></ul> 
<blockquote> 
 <p> IE 盒子模型、W3C 盒子模型；</p> 
 <ul><li>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</li><li>区  别： IE的content部分把 border 和 padding计算了进去;</li></ul> 
</blockquote> 
<ul><li> <h4 id="%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0">伪类和伪元素</h4> </li></ul> 
<blockquote> 
 <ul><li><strong>伪类</strong></li></ul> 
 <p>伪类选择元素基于的是当前元素处于的状态，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。</p> 
 <p>:link</p> 
 <p>伪类将应用于未被访问过的链接，与:visited互斥。</p> 
 <p>:hover</p> 
 <p>伪类将应用于有鼠标指针悬停于其上的元素。</p> 
 <p>:active</p> 
 <p>伪类将应用于被激活的元素，如被点击的链接、被按下的按钮等。</p> 
 <p><strong>:</strong>visited</p> 
 <p>伪类将应用于已经被访问过的链接，与:link互斥。</p> 
 <ul><li><strong>伪元素</strong></li></ul> 
 <p>与伪类针对特殊状态的元素不同的是，伪元素是对元素中的特定内容进行操作，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。</p> 
 <p>:first-letter</p> 
 <p>伪元素的样式将应用于元素文本的第一个字（母）。</p> 
 <p>:first-line</p> 
 <p>伪元素的样式将应用于元素文本的第一行。</p> 
 <p>:before</p> 
 <p>在元素内容的最前面添加新内容。</p> 
 <p>:after</p> 
 <p>在元素内容的最后面添加新内容。</p> 
</blockquote> 
<ul><li> <h4 id="position%E5%90%84%E5%B1%9E%E6%80%A7%E5%8C%BA%E5%88%AB">position各属性区别</h4> </li></ul> 
<blockquote> 
 <ul><li> <p><strong>relative  相对定位</strong></p> </li></ul> 
 <p>不影响元素本身特性（无论区块元素还是内联元素会保留其原本特性）</p> 
 <p> 不会使元素脱离文档流（元素原本位置会被保留，即改变位置也不会占用新位置）</p> 
 <p>没有定位偏移量时对元素无影响（相对于自身原本位置进行偏移）</p> 
 <p>用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值越大越在上面（z-index只能在position属性值为relative或absolute或fixed的元素上有效。） （两个都为定位元素，后面的会覆盖前面的定位）</p> 
 <ul><li><strong>absolute  绝对定位</strong></li></ul> 
 <p>使元素完全脱离文档流（在文档流中不再占位）</p> 
 <p><span style="color:#f33b45;">使内联元素在设置宽高的时候支持宽高（改变内联元素的特性）</span></p> 
 <p>使区块元素在未设置宽度时由内容撑开宽度（改变区块元素的特性）</p> 
 <p>相对于最近一个有定位的父元素（定位属性除static之外）偏移（若其父元素没有定位则逐层上找，直到document）</p> 
 <p>相对定位一般配合绝对定位使用（将父元素设置相对定位，使其相对于父元素偏移）</p> 
 <p>可使用z-index改变显示层级</p> 
 <ul><li><strong>fixed  固定定位</strong></li></ul> 
 <p> fixed生成固定定位的元素，相对于浏览器窗口进行定位。</p> 
 <ul><li><strong>static</strong>  <strong>默认值</strong></li></ul> 
 <p>默认布局。元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</p> 
 <ul><li><strong>sticky  粘性定位</strong></li></ul> 
 <p>粘性定位，该定位基于用户滚动的位置。</p> 
 <p>它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。</p> 
</blockquote> 
<ul><li> <h4 id="display%E5%90%84%E5%B1%9E%E6%80%A7%E5%8C%BA%E5%88%AB">display各属性区别</h4> </li></ul> 
<blockquote> 
 <ul><li><strong>block</strong></li></ul> 
 <p>单独占一行，可以设置width,height，maigin四个方向，padding四个方向；</p> 
 <p>元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度；</p> 
 <ul><li><strong>inline</strong></li></ul> 
 <p>多个内联元素占同一行，直到放不下才换行。设置width,height,margin-top,margin-bottom,padding-top,padding-bottom无效；（通过添加背景颜色可以看出有设置上述属性，但是不会影响其他元素的布局）</p> 
 <ul><li><strong>inline-block</strong></li></ul> 
 <p>像inline一样放置(比如和它相邻的元素处在同一行)，像block一样表现。比如：input,select,img等。</p> 
 <p>float属性、position:absolute绝对定位 和上述替换元素表现为inline-block</p> 
 <ul><li><strong>none</strong></li></ul> 
 <p></p> 
 <p>inline和inline-block出现的问题</p> 
 <p>水平呈现的元素间，换行显示或空格分隔的情况下会有间距</p> 
 <p>解决方法</p> 
 <ul><li>相邻inline-block元素不分行写，写在同一行并且中间无空格</li><li>select父元素使用font-size:0</li></ul> 
</blockquote> 
<ul><li> <h4 id="float%E6%B5%AE%E5%8A%A8%E5%AF%B9%E5%85%83%E7%B4%A0%E7%9A%84%E5%BD%B1%E5%93%8D">float浮动对元素的影响</h4> </li></ul> 
<blockquote> 
 <p><a href="https://www.jianshu.com/p/091b4ffb10b0" rel="nofollow" title="float(对块级、行内、内联块元素的影响)">float(对块级、行内、内联块元素的影响)</a></p> 
</blockquote> 
<ul><li> <h4 id="display%EF%BC%9Anone%E5%92%8Cvisibility%EF%BC%9Ahidden%E7%9A%84%E5%8C%BA%E5%88%AB">display：none和visibility：hidden的区别</h4> </li></ul> 
<blockquote> 
 <ul><li>display:none是彻底消失，不在文档流中占位，浏览器也不会解析该元素；</li><li>visibility:hidden是视觉上消失了，可以理解为透明度为0的效果，在文档流中占位，浏览器会解析该元素；</li><li>使用visibility:hidden比display:none性能上要好，display:none切换显示时，页面产生回流（当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等，页面重新构建，此时就是回流。所有页面第一次加载时需要产生一次回流），而visibility切换是否显示时则不会引起回流。</li></ul> 
</blockquote> 
<ul><li> <h4 id="display%EF%BC%8Cfloat%EF%BC%8Cposition%E7%9A%84%E7%9B%B8%E4%BA%92%E5%BD%B1%E5%93%8D">display，float，position的相互影响</h4> </li></ul> 
<blockquote> 
 <p><img alt="" class="has" src="https://images2.imgbox.com/45/60/h0QVErK3_o.png"></p> 
 <p></p> 
 <p><strong> position跟display、overflow、float这些特性相互叠加后会怎么样？</strong></p> 
 <p>display属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。<br> 类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。</p> 
 <p></p> 
</blockquote> 
<ul><li> <h4 id="%E6%A0%B7%E5%BC%8F%E4%B8%AD%E5%B1%9E%E6%80%A7%E7%9A%84%E7%BB%A7%E6%89%BF">样式中属性的继承</h4> </li></ul> 
<blockquote> 
 <p>继承的属性</p> 
 <ul><li>颜色 (color)</li><li>字体系列 (font-family)</li><li>字体大小 (font-size)</li><li>字体样式 (font-style)</li><li>字体重量 (font-weight)</li><li>文本对齐 (text-align)</li></ul> 
 <p>非继承属性</p> 
 <ul><li>背景 (background)</li><li>边界 (border)</li><li>余量 (margin)</li><li>填充 (padding)</li><li>显示 (display)</li><li>浮动 (float)</li><li>宽度 (width)</li><li>高度 (height)</li></ul> 
</blockquote> 
<ul><li> <h4 id="BFC%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87">BFC块级格式化上下文</h4> </li></ul> 
<blockquote> 
 <p>满足下列css声明之一的元素便会生成BFC</p> 
 <ul><li>根元素</li><li>float的值不为none</li><li>overflow的值不为visible（常用 overflow:hidden创建BFC区域）</li><li>display的值为inline-block、table-cell、table-caption</li><li>position的值不为static或relative</li></ul> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/89202638" title="BFC（块级格式上下文）">BFC（块级格式上下文）</a></p> 
</blockquote> 
<ul><li> <h4 id="css%20hack">css hack</h4> </li></ul> 
<blockquote> 
 <p>由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack</p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/89445903" title="CSS hack">CSS hack</a></p> 
</blockquote> 
<ul><li> <h4 id="css%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E5%85%B6%E6%9D%83%E9%87%8D%E4%BC%98%E5%85%88%E7%BA%A7">css选择器及其权重优先级</h4> </li></ul> 
<blockquote> 
 <p>1.id选择器（ # myid）</p> 
 <p>2.类选择器（.myclassname）</p> 
 <p>3.标签选择器（div, h1, p）</p> 
 <p>4.相邻选择器（h1 + p）</p> 
 <p>5.子选择器（ul &gt; li）</p> 
 <p>6.后代选择器（li a）</p> 
 <p>7.通配符选择器（ * ）</p> 
 <p>8.属性选择器（a[rel = "external"]）</p> 
 <p>9.伪类选择器（a:hover, li:nth-child）</p> 
 <p></p> 
 <p>优先级：</p> 
 <ol><li> <p>important的权值为最高 1,0,0,0</p> </li><li> <p>ID的权值为 0,1,0,0</p> </li><li> <p>类的权值为 0,0,1,0</p> </li><li> <p>标签的权值为 0,0,0,1</p> </li><li> <p>伪类选择的权值为 0,0,1,0</p> </li><li> <p>通配选择符的权值 0,0,0,0</p> </li></ol> 
 <p></p> 
 <p><strong>比较同一级别的个数，数量多的优先级高，<span style="color:#f33b45;">如果相同</span>即比较下一级别的个数：</strong></p> 
 <p><strong>important &gt; 内联 &gt; ID &gt; 类| 伪类| 属性选择 &gt; 标签 | 伪元素 &gt; 通配符 &gt; 继承</strong></p> 
 <p>这也就解释了为什么11个标签的定义会比不上1个类的定义，1个类加11个标签会比不上2个类的权重高。</p> 
 <p></p> 
 <p><a href="https://www.cnblogs.com/aaronjs/p/3156809.html" rel="nofollow" title="CSS选择器、优先级与匹配原理">CSS选择器、优先级与匹配原理</a></p> 
</blockquote> 
<ul><li> <h4 id="%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95">清除浮动的几种方法</h4> </li></ul> 
<blockquote> 
 <p style="margin-left:0cm;"><strong>什么时候需要清除浮动</strong></p> 
 <p>浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。<br> 浮动带来的问题：</p> 
 <ol><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素（内联元素）会跟随其后</li><li>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</li></ol> 
 <p></p> 
 <p style="margin-left:0cm;"><strong>清除浮动的方法：</strong></p> 
 <p style="margin-left:0cm;">1.父级div定义 height</p> 
 <p>原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。</p> 
 <p>优点：简单、代码少、容易掌握</p> 
 <p>缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题</p> 
 <p style="margin-left:0cm;"></p> 
 <p style="margin-left:0cm;">2，结尾处加空div标签 clear:both</p> 
 <p>原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度</p> 
 <p>优点：简单、代码少、浏览器支持好、不容易出现怪问题</p> 
 <p>缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好</p> 
 <p style="margin-left:0cm;"></p> 
 <p style="margin-left:0cm;">3，父级div定义 伪类:after 和 zoom</p> 
 <p>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题</p> 
 <p>优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）</p> 
 <p>缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持</p> 
 <pre class="has"><code class="language-css">.clearfix:after{
  display:table;
  clear:both;
  content:"";
  height:0px;
}
.clearfix {*zoom:1;} /*照顾IE6，IE7就可以了*/
</code></pre> 
 <p style="margin-left:0cm;"></p> 
 <p style="margin-left:0cm;">4，父级div定义 overflow:hidden（<span style="color:#f33b45;">利用BFC检测区域的浮动的盒子高度</span>）</p> 
 <p>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden生成BFC时，浏览器会自动检查浮动区域的高度</p> 
 <p>优点：简单、代码少、浏览器支持好</p> 
 <p>缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。</p> 
</blockquote> 
<ul><li> <h4 id="css3%E8%BF%87%E6%B8%A1%EF%BC%88transition%EF%BC%89%E3%80%81%E5%8F%98%E5%8C%96%EF%BC%88transform%EF%BC%89%E3%80%81%E5%8A%A8%E7%94%BB%EF%BC%88animation%EF%BC%89">动画（animation）</h4> </li></ul> 
<blockquote> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/88803958" title="animation动画的基本使用方式">animation动画的基本使用方式</a></p> 
</blockquote> 
<ul><li> <h4 id="%C2%A0transition%E5%92%8Canimation%E7%9A%84%E5%8C%BA%E5%88%AB"> transition和animation的区别</h4> </li></ul> 
<blockquote> 
 <ul><li>css3过渡（transition）、变化（transform）、动画（animation）</li><li>transition是过渡，animation是动画。transition只能从一种状态过渡到另外一种状态，animation可以定制复杂动画，可以定义动画的区间等。</li><li>transition必须通过一些行为才能触发（js或者伪类来触发），animation的话直接就可以触发。</li></ul> 
</blockquote> 
<ul><li> <h4 id="%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%EF%BC%8C%40media">媒体查询，@media</h4> </li></ul> 
<blockquote> 
 <p><a href="https://www.runoob.com/cssref/css3-pr-mediaquery.html" rel="nofollow" title="菜鸟教程——@media">菜鸟教程——@media</a></p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/91435214" title="利用CSS中的@media实现响应式布局">利用CSS中的@media实现响应式布局</a></p> 
</blockquote> 
<ul><li>link和@import 导入css文件的区别</li></ul> 
<blockquote> 
 <ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；</li><li>@import属于CSS范畴，只能加载CSS。</li></ul> 
 <p></p> 
 <ul><li>link引用CSS时，在页面载入时同时加载；</li><li>@import需要页面网页完全载入以后加载。</li></ul> 
 <p></p> 
 <ul><li>link是XHTML标签，无兼容问题；</li><li>@import是在CSS2.1提出的，低版本的浏览器不支持。</li></ul> 
 <p></p> 
 <ul><li>link支持使用Javascript控制DOM去改变样式；</li><li>@import不支持使用Javascript控制DOM去改变样式。</li></ul> 
</blockquote> 
<ul><li> <h4 id="%E6%B0%B4%E5%B9%B3%E3%80%81%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">水平、垂直居中的几种方式</h4> </li></ul> 
<blockquote> 
 <p><a href="http://www.ihref.com/read-17539.html" rel="nofollow" title="html中div如何水平和垂直居中的几种css方法代码">html中div如何水平和垂直居中的几种css方法代码</a></p> 
 <p><a href="https://juejin.im/post/5aa252ac518825558001d5de" rel="nofollow" title="干货!各种常见布局实现">干货!各种常见布局实现</a></p> 
</blockquote> 
<ul><li> <h4 id="%E7%9C%81%E7%95%A5%E6%96%87%E6%9C%AC%E7%9A%84%E6%A0%B7%E5%BC%8F">省略文本的样式</h4> </li></ul> 
<blockquote> 
 <pre class="has"><code class="language-css">/*省略文本*/
white-space:nowrap; 
overflow: hidden;
text-overflow: ellipsis;</code></pre> 
 <pre><code class="language-css">/* 多行省略 */
width:100px;
overflow : hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 2;
-webkit-box-orient: vertical;</code></pre> 
 <p></p> 
</blockquote> 
<ul><li> <h4 id="bix-sizing%E5%B1%9E%E6%80%A7">box-sizing属性</h4> </li></ul> 
<blockquote> 
 <p>box-sizing属性可以指定盒子模型种类</p> 
 <p>content-box指定盒子模型为W3C的标准盒子模型</p> 
 <p><img alt="è¿éåå¾çæè¿°" class="has" height="363" src="https://images2.imgbox.com/b7/21/H2xvbNQq_o.jpg" width="595"></p> 
 <p></p> 
 <p>border-box指定盒子模型为IE盒子模型（width包含border和padding）</p> 
 <p><img alt="" class="has" height="344" src="https://images2.imgbox.com/ad/fd/W0uWEMVt_o.jpg" width="589"></p> 
</blockquote> 
<ul><li> <h4 id="%E5%8F%8C%E6%A0%8F%E5%B8%83%E5%B1%80%E5%92%8C%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80">双栏布局和三栏布局</h4> </li></ul> 
<blockquote> 
 <p><a href="https://juejin.im/post/5aa252ac518825558001d5de" rel="nofollow" title="干货!各种常见布局实现">干货!各种常见布局实现</a></p> 
</blockquote> 
<ul><li> <h4 id="css%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%8Cless%E5%92%8Csass">css预处理，less和sass</h4> </li></ul> 
<blockquote> 
 <p>CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。</p> 
 <p><a href="https://blog.csdn.net/ly2983068126/article/details/77737292" title="详说css与预处理器">详说css与预处理器</a></p> 
</blockquote> 
<ul><li> <h4 id="css%20sprite">css sprite</h4> </li></ul> 
<blockquote> 
 <p id="原理">原理：</p> 
 <p>将许多的小图片整合到一张大图片中，利用css中的background-image属性，background-position属性定位某个图片位置，来达到在大图片中引用某个部位的小图片的效果。</p> 
 <p id="优点">优点：</p> 
 <ul><li>减少网页的http请求，提升网页加载速度。</li><li>合并多张小图片成大图，能减少字节总数（大图大小&lt;=多张小图大小）.</li></ul> 
 <p id="缺点">缺点：</p> 
 <ul><li>前期需要处理图片将小图合并，多些许工程量。</li><li>对于需要经常改变的图片维护起来麻烦。</li></ul> 
</blockquote> 
<ul><li> <h4 id="z-index%E5%B1%9E%E6%80%A7%C2%A0">z-index属性 </h4> </li></ul> 
<blockquote> 
 <p><a href="https://cloud.tencent.com/developer/article/1148371" rel="nofollow" title="z-index失效的原因">z-index失效的原因</a></p> 
 <p><strong>注意点:</strong></p> 
 <p>         (1):z-index属性只作用在被定位了的元素上。所以如果你在一个没被定位的元素上使用z-index的话，是不会有效果的.</p> 
 <p>          (2)同一个父元素下的元素的层叠效果会受父元素的z-index影响,如果父元素的z-index值很小,那么子元素的z-index值很大也不起作用</p> 
 <p><strong>失效的情况:</strong></p> 
 <p>1、父标签 position属性为relative；</p> 
 <p>2、问题标签无position属性（不包括static）；</p> 
 <p>3、问题标签含有浮动(float)属性。</p> 
 <p>4、问题标签的祖先标签的z-index值比较小</p> 
 <p></p> 
 <p>解决方法:</p> 
 <p>第一种:  position:relative改为position:absolute；</p> 
 <p>第二种:浮动元素添加position属性（如relative，absolute等）；</p> 
 <p>第三种:去除浮动。</p> 
 <p>第四种:提高父标签的z-index值</p> 
</blockquote> 
<ul><li> <h4 id="scale%E5%92%8Czoom%E5%8C%BA%E5%88%AB">scale和zoom区别</h4> </li></ul> 
<blockquote> 
 <ul><li>zoom左上角缩放，scale默认中心缩放；scale可通过transform-origin来改变缩放焦点</li><li>zoom缩放只可以是整数，scale可以是负数</li><li>zoom缩放之后不占文档流，下方的元素会自动上移；scale缩放之后会仍然占据文档流(类似position：relative)</li><li>room缩放之后，用js获取元素的宽高仍然是缩放之前的宽高；scale缩放之后，用js获取是缩放之后的宽高。</li><li>由于对文档流的影响，zoom会引起整个页面的重绘；而scale只改变的缩放的元素</li><li>zoom在火狐上是不支持的（2019-06-15），请谨慎使用 </li></ul> 
</blockquote> 
<ul><li> <p><strong>src和href引入地址的区别</strong></p> </li></ul> 
<blockquote> 
 <ul><li>href表示超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系。</li><li>src表示引用资源，表示替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。</li><li><li>src是source的缩写，是指向外部资源的位置，指向的内部会迁入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中，例如js脚本，img图片和frame等元素。当浏览器解析到这一句的时候会暂停其他资源的下载和处理，直至将该资源加载，编译，执行完毕，图片和框架等元素也是如此，类似于该元素所指向的资源嵌套如当前标签内，这也是为什么要把js饭再底部而不是头部。</li><li>当浏览器解析到这一句的时候会识别该文档为css文件，会下载并且不会停止对当前文档的处理，这也是为什么建议使用link方式来加载css而不是使用@import。</li></ul> 
</blockquote> 
<ul><li> <h4 id="flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80">flex弹性布局</h4> </li></ul> 
<blockquote> 
 <p><a href="https://www.runoob.com/w3cnote/flex-grammar.html" rel="nofollow" title="Flex 布局语法教程">Flex 布局语法教程</a></p> 
</blockquote> 
<ul><li> <h4 id="px%EF%BC%8Cem%EF%BC%8Crem%EF%BC%8Cvh%E7%9A%84%E5%8C%BA%E5%88%AB">px，em，rem，vh的区别</h4> </li></ul> 
<blockquote> 
 <p></p> 
 <ul><li style="margin-left:15pt;">px是最常用的css长度单位，缺点是其不能适应浏览器缩放时产生的变化，因此一般不用于响应式网站。</li><li style="margin-left:15pt;">em和rem属于相对类型的长度单位值，不过它们所参照的标准不同，em字体大小参照的是其父元素的字体大小值，其余如宽度单位是参照其本身字体大小，过多使用em容易造成耦合依赖，不易于修改维护；而rem的大小参照的是根节点的字体大小值，容易设置，常用于响应式布局。</li><li style="margin-left:15pt;">vh属于视口的绝对高度，常用100vw表示视口的总宽度，100vh表示视口的总高度。</li></ul> 
 <p style="margin-left:15pt;">参考文章：<a href="https://segmentfault.com/a/1190000005936910" rel="nofollow" title="CSS：区别 px、em、rem">CSS：区别 px、em、rem</a></p> 
 <p style="margin-left:15pt;">                  <a href="https://segmentfault.com/a/1190000016788019" rel="nofollow" title="CSS单位em是相对于父元素还是当前元素的字体大小？">CSS单位em是相对于父元素还是当前元素的字体大小？</a></p> 
</blockquote> 
<ul><li> <h4 id="%E5%8D%95%E8%A1%8C%E6%96%87%E5%AD%97%E5%B1%85%E4%B8%AD%EF%BC%8C%E5%A4%9A%E8%A1%8C%E6%96%87%E5%AD%97%E5%B7%A6%E5%AF%B9%E9%BD%90%C2%A0">单行文字居中，多行文字左对齐 </h4> </li></ul> 
<blockquote> 
 <p><img alt="" height="362" src="https://images2.imgbox.com/bb/70/kdf7Jp12_o.png" width="1188"></p> 
 <p>p标签是定义为内联块元素，始终是左对齐，因为内联块元素是最小宽度，当文字少的时候，然后外面的div把p标签设为居中。表现得效果就是把文字居中了，多行文字时，居中的p标签占据了整个div的宽度，表现了其自身的左对齐效果。</p> 
</blockquote> 
<ul><li> <h4 id="CSS%E9%9D%A2%E8%AF%95%E9%A2%98">CSS面试题</h4> </li></ul> 
<blockquote> 
 <p> 例：</p> 
 <ol><li>请写出以下盒子(a、b、c)分别占据的高度：</li></ol> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;文档标题&lt;/title&gt;
&lt;/head&gt;
&lt;style&gt;
.a{
  border :1px solid red
}
.b{
   margin: 10px; 
   padding: 20px; 
   height: 100px;
	border: 2px solid black; 
   outline: 1px double blue;
	box-shadow: 1px 2px 3px 4px white;

}
.c{
  margin: 20px; 
  padding: 10px; 
  height: 50px;
  border: 1px solid black; 
  box-sizing: border-box;
}
&lt;/style&gt;
&lt;body&gt;
&lt;div class="a"&gt;
	&lt;div class="b"&gt;&lt;/div&gt;
	&lt;div class="c"&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;


</code></pre> 
 <p><img alt="" height="429" src="https://images2.imgbox.com/f4/fd/uhBuXTjr_o.png" width="1200"></p> 
 <p> <img alt="" height="507" src="https://images2.imgbox.com/8b/af/pk3gRDbU_o.png" width="1200"></p> 
 <p><img alt="" height="511" src="https://images2.imgbox.com/04/2e/rzRbtkau_o.png" width="1200"></p> 
 <p></p> 
 <p>例：计算盒子c的padding值与margin值等于多少px</p> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;文档标题&lt;/title&gt;
&lt;/head&gt;
&lt;style&gt;
  .a{
	position: relative;
	width: 2000px; height: 1000px;
	background:red;
}
.b{
	box-sizing: border-box;
	width: 1000px; height: 500px;
  	background:yellow;
}
.c{
	width: 100px; height: 50px; margin: 20%;
	padding: 20%;
  	background:blue;
}
&lt;/style&gt;
&lt;body&gt;
  &lt;div class="a"&gt;
      &lt;div class="b"&gt;
          &lt;div class="c"&gt;
          &lt;/div&gt;
      &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
 <p>padding为200px，margin为200px，c的盒子的百分比内外边距值是根据父级（b）的width进行计算的 ，其中子级百分比width和height根据规定，也是由父级的width进行计算的。</p> 
 <p></p> 
</blockquote> 
<p></p> 
<h3 id="JavaScript">JavaScript</h3> 
<ul><li> <h4 id="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基本数据类型</h4> </li></ul> 
<blockquote> 
 <ul><li>undefined </li><li>null </li><li>string </li><li>boolean </li><li>number </li><li>symbol(ES6)</li></ul> 
 <p>一种引用类型 </p> 
 <ul><li>Object</li></ul> 
</blockquote> 
<ul><li> <h4 id="undefined%E5%92%8Cnull%E7%9A%84%E5%8C%BA%E5%88%AB">undefined和null的区别</h4> </li></ul> 
<blockquote> 
 <ul><li>null： 代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以可以认为它是一个特殊的对象值。</li><li>undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。</li></ul> 
 <p>null是javascript的关键字，可以认为是对象类型，它是一个空对象指针，和其它语言一样都是代表“空值”，</p> 
 <p>不过 undefined 却是javascript才有的。</p> 
 <p>undefined是在ECMAScript第三版引入的，为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。</p> 
 <p>没有返回值的函数返回为undefined，没有实参的形参也是undefined。</p> 
</blockquote> 
<ul><li> <h4 id="%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E6%AF%94%E8%BE%83typeof%E4%B8%8Einstanceof%EF%BC%89">判断数据类型的方式（比较typeof与instanceof）</h4> </li></ul> 
<blockquote> 
 <p>相同点：</p> 
 <ul><li>JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。</li></ul> 
 <p>typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。</p> 
 <p>Instanceof定义和用法：instanceof 用于判断一个变量是否属于某个对象的实例，返回布尔值</p> 
 <p></p> 
 <ul><li>typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。</li><li>typeof 来获取一个变量是否存在，如 if(typeof a!="undefined")，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错。</li><li>对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。</li></ul> 
 <p></p> 
 <p>常见面试题：<a href="https://blog.csdn.net/CWH0908/article/details/91339877" title="判断JS数据类型的四种方法">判断JS数据类型的四种方法</a></p> 
</blockquote> 
<ul><li> <h4 id="%E5%8F%82%E6%95%B0%E7%9A%84%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E7%90%86%E8%A7%A3">参数的按值传递的理解</h4> </li></ul> 
<blockquote> 
 <p>ECMAScript中所有函数的参数都是按值传递的。</p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/91047402" title="javascript 参数按值传递的理解">javascript 参数按值传递的理解</a></p> 
</blockquote> 
<ul><li> <h4 id="%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F">执行环境和作用域链</h4> </li></ul> 
<blockquote> 
 <p><strong>执行环境：</strong></p> 
 <p>当JavaScript解释器初始化执行代码时,它首先默认进入全局执行环境;从此刻开始,函数的每次调用都会创建一个新的执行环境;每个函数都有自己的执行环境,当执行流进入一个函数时,函数的环境就会被推入一个环境栈中，在函数执行完后栈将其环境弹出,保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出也随之销毁,例如关闭网页或退出浏览器）</p> 
 <p><img alt="" class="has" src="https://images2.imgbox.com/9a/aa/rewQuZYo_o.png"></p> 
 <p><strong>作用域链：</strong></p> 
 <p>当代码在一个环境中执行时,会创建变量对象的一个作用域链，作用域链中的下一个变量对象包含（外部）环境，一直延续到全局执行环境，全局执行环境的变量对象始终是作用域链中的最后一个对象。</p> 
 <p><strong>简述一下作用域链</strong></p> 
 <p>       访问一个变量属性时先在当前内部作用域中查找，未找到时就会到外部作用域进行往上查找，直到全局作用域为止，由此形成作用域链。</p> 
</blockquote> 
<ul><li> <h4 id="%E6%A8%A1%E4%BB%BF%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">模仿块级作用域</h4> </li></ul> 
<blockquote> 
 <ul><li>使用立即执行函数</li><li><s>function函数作用域</s></li><li>es6中的let、const命令创建</li></ul> 
</blockquote> 
<ul><li> <h4 id="js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE">js原型和原型链</h4> </li></ul> 
<blockquote> 
 <p><strong>简述一下原型链：</strong></p> 
 <p>       所有函数都有一个prototype属性，所有引用类型（对象）都有__proto__属性，当对象调用当前实例不存在的属性和函数的时候就会沿着__proto__属性向上查找prototype原型对象中的属性和函数，直到Object原型对象为止，由此形成原型链。</p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/91045526" title="javascript深入学习原型到原型链">javascript深入学习原型到原型链</a></p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/88076659" title="prototype和__proto__的区别">prototype和__proto__的区别</a></p> 
</blockquote> 
<ul><li> <h4 id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%8C%BA%E5%88%AB">作用域链和原型链的区别</h4> </li></ul> 
<blockquote> 
 <ul><li>作用域是针对变量的</li><li>原型链是针对构造函数的</li></ul> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/90339764" title="javascript中作用域链和原型链的区别">javascript中作用域链和原型链的区别</a></p> 
</blockquote> 
<ul><li> <h4 id="js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F">js创建对象的方式</h4> </li></ul> 
<blockquote> 
 <ul><li>工厂模式</li><li>构造函数模式</li><li>原型模式</li><li>组合模式</li><li>寄生构造函数模式</li><li>稳妥构造函数模式</li></ul> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/90348402" title="javascript创建对象的方式">javascript创建对象的方式</a></p> 
</blockquote> 
<ul><li> <h4 id="js%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F">js实现继承的方式</h4> </li></ul> 
<blockquote> 
 <ul><li>原型链继承</li><li>借用构造函数继承</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ul> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/90409308" title="javascript继承的方式">javascript继承的方式</a></p> 
</blockquote> 
<ul><li> <h4 id="%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3">对闭包的理解</h4> </li></ul> 
<blockquote> 
 <p><strong>什么是闭包：</strong></p> 
 <ul><li> <p><strong>闭包的概念</strong></p> <p>函数执行时形成的私有上下文EC(FN)，正常情况下，代码执行完会出栈后释放;但是特殊情况下，如果当前私有上下文中的某个东西被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不销毁的上下文。 函数执行函数执行过程中，会形成一个全新的私有上下文，可能会被释放，可能不会被释放，不论释放与否，他的作用是：</p> </li></ul> 
 <p>（1）保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；</p> 
 <p>（2）保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</p> 
 <p>我们把函数执行形成私有上下文，来保护和保存私有变量机制称为<code>闭包</code>。</p> 
 <blockquote> 
  <p>闭包是指有权访问另一个函数作用域中的变量的函数--《JavaScript高级程序设计》</p> 
 </blockquote> 
 <p><strong>全面的回答</strong>： 在js中变量的作用域属于函数作用域, 在函数执行完后,作用域就会被清理,内存也会随之被回收,但是由于闭包函数是建立在函数内部的子函数, 由于其可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 这时的子函数(也就是闭包),便拥有了访问上级作用域中变量的权限,即使上级函数执行完后作用域内的值也不会被销毁。</p> 
 <ul><li> <p><strong>闭包的特性</strong>：</p> 
   <ul><li> <p>1、内部函数可以访问定义他们外部函数的参数和变量。(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)设计私有的方法和变量，避免全局变量的污染。</p> <p>1.1.闭包是密闭的容器，，类似于set、map容器，存储数据的</p> <p>1.2.闭包是一个对象，存放数据的格式为 key-value 形式</p> </li><li> <p>2、函数嵌套函数</p> </li><li> <p>3、本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除</p> </li></ul></li><li> <p><strong>闭包形成的条件</strong>：</p> 
   <ol><li>函数的嵌套</li><li>内部函数引用外部函数的局部变量，延长外部函数的变量生命周期</li></ol></li><li> <p><strong>闭包的用途</strong>：</p> 
   <ol><li>模仿块级作用域</li><li>保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li>封装私有化变量</li><li>创建模块</li></ol></li><li> <p><strong>闭包应用场景</strong></p> <p>闭包的两个场景，闭包的两大作用：<code>保存/保护</code>。 在开发中, 其实我们随处可见闭包的身影, 大部分前端JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送ajax请求成功|失败的回调;setTimeout的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。</p> </li><li> <p><strong>闭包的优点</strong>：延长局部变量的生命周期</p> </li><li> <p><strong>闭包缺点</strong>：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p> </li></ul> 
 <p></p> 
 <p>练习题：</p> 
 <p><img alt="" class="has" height="502" src="https://images2.imgbox.com/8e/2d/4pBRdldo_o.png" width="830"></p> 
</blockquote> 
<ul><li> <h4 id="this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%C2%A0">this指向问题 </h4> </li></ul> 
<blockquote> 
 <p>this 永远指向最后调用它的那个对象</p> 
 <ul><li>在调用函数时使用<code>new</code>关键字，函数内的<code>this</code>是一个全新的对象。</li><li>如果<code>apply</code>、<code>call</code>或<code>bind</code>方法用于调用、创建一个函数，函数内的 this 就是作为参数传入这些方法的对象。</li><li>当函数作为对象里的方法被调用时，函数内的<code>this</code>是调用该函数的对象。比如当<code>obj.method()</code>被调用时，函数内的 this 将绑定到<code>obj</code>对象。</li><li>如果调用函数不符合上述规则，那么<code>this</code>的值指向全局对象（global object）。浏览器环境下<code>this</code>的值指向<code>window</code>对象，但是在严格模式下(<code>'use strict'</code>)，<code>this</code>的值为<code>undefined</code>。</li><li>如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定<code>this</code>的值。</li><li>ES6的箭头函数，将忽略上面的所有规则，<code>this</code>被设置为它被创建时的上下文。</li></ul> 
 <p></p> 
 <p><strong>改变 this 指向的方法：</strong></p> 
 <ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 <code>_this = this</code></li><li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li><li>new 实例化一个对象</li></ul> 
 <p></p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/91049290" title="javascript深入学习this指向问题">javascript深入学习this指向问题</a></p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/89740557" title="简述JavaScript中的this">简述JavaScript中的this</a></p> 
</blockquote> 
<ul><li> <h4 id="%E6%A8%A1%E6%8B%9Fnew%E5%AE%9E%E7%8E%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">模拟new实现创建对象</h4> </li></ul> 
<blockquote> 
 <p>通过new创建对象经历4个步骤</p> 
 <ol><li><strong>创建一个新Object对象</strong>；[var o = {};]</li><li><strong>将构造函数的作用域赋给新对象</strong>（因此this指向了这个新对象）执行构造函数中的代码(为这个新对象添加属性)；       [Person.apply(o)] [Person原来的this指向的是window]</li><li><strong>为其绑定原型对象</strong>；</li><li><strong>返回新生成的对象</strong>。<br>  </li></ol> 
</blockquote> 
<ul><li> <h4 id="%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0">防抖函数</h4> </li></ul> 
<blockquote> 
 <p>防抖：在高频发的事件调用时，每次将定义好的定时器清除掉，只有当高频发事件调用最后一次的时候，由于没有再调用该事件函数，没有清除定义的定时器，那么定时器将正常工作，即定时器等待时间内连续调用10次后显示1，连续调用20次后显示的还是1。</p> 
 <p>通俗来讲就是，你要我在30s内搬100块砖，我偷懒，我结束时才搬一块。</p> 
 <p>主要用于 防止表单重复提交。</p> 
 <p><br><a href="https://blog.csdn.net/CWH0908/article/details/89712442" title="javascript的防抖和节流">javascript的防抖和节流</a></p> 
</blockquote> 
<ul><li> <h4 id="%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%C2%A0">节流函数 </h4> </li></ul> 
<blockquote> 
 <p>节流：在高频发的事件调用时，不会清除定义好的定时器。假设你的定时器为1s，加入if判断语句，如果你高频发事件的调用间隔小于1s，那么你在这1s的定时器等待时间内调用的次数都当成一次，即连续调用10次后如果花了三秒钟则显示3，连续调用20次后如果花了三秒钟那么也显示3，就是看你的调用时间。注意，将若干函数调用合成为一次（稀释函数的执行频率），并在给定时间过去之后，调用一次(仅仅只会调用一次）。</p> 
 <p>通俗来讲就是，你要我在30s内搬100块砖，我搬，不过我每1s（定时器范围）才搬一块，多了我不干，所以我最后才搬了30块砖。</p> 
 <p>主要用于搜索框请求频率的稀释。</p> 
 <p><br><a href="https://blog.csdn.net/CWH0908/article/details/89712442" title="javascript的防抖和节流">javascript的防抖和节流</a></p> 
</blockquote> 
<ul><li> <h4 id="DOM%E6%93%8D%E4%BD%9C">DOM操作</h4> </li></ul> 
<blockquote> 
 <p id="原生JS中DOM节点相关API合集"><a href="https://blog.csdn.net/CWH0908/article/details/91128215" title="原生JS中DOM节点相关API合集">原生JS中DOM节点相关API合集</a></p> 
</blockquote> 
<ul><li> <h4 id="DOM0%E7%BA%A7%E5%92%8CDOM2%E7%BA%A7%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F">DOM0级和DOM2级的事件处理程序</h4> </li></ul> 
<blockquote> 
 <p><strong>DOM0级</strong></p> 
 <p>分为2个：一是在标签内写onclick事件</p> 
 <p>　　　　  二是在JS写οnclick=function（）{}函</p> 
 <ul><li> <pre class="has"><code class="language-html">&lt;input id="myButton" type="button" value="Press Me" onclick="alert('thanks');" &gt;</code></pre> </li><li> <pre class="has"><code class="language-javascript">document.getElementById("myButton").onclick = function () {
    alert('thanks');
}</code></pre> <p></p> </li></ul> 
 <p><strong>为什么没有1级DOM</strong></p> 
 <p>DOM级别1于1998年10月1日成为W3C推荐标准。1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。在2级DOM中除了定义了一些DOM相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的2级DOM事件模型 。</p> 
 <p></p> 
 <p><strong>DOM2级</strong></p> 
 <p>有两个用来添加和移除事件处理程序的函数：addEventListener()和removeEventListener()。</p> 
 <p>它们都有三个参数：第一个参数是事件名（如click）；</p> 
 <p>　　　　　　　　　第二个参数是事件处理程序函数；</p> 
 <p>　　　　　　　　   第三个参数如果是true则表示在捕获阶段调用，为false表示在冒泡阶段调用。</p> 
 <ul><li>addEventListener():可以为元素添加多个事件处理程序，触发时会按照添加顺序依次调用。</li><li>removeEventListener():不能移除匿名添加的函数。</li></ul> 
 <pre class="has"><code class="language-javascript">document.getElementById("myTest").attachEvent("onclick", function(){alert(1)});
//IE下使用attachEvent（），等价于
document.getElementById("myTest").addEventListener("click", function(){alert(1)}, false);</code></pre> 
 <p></p> 
 <p>dom0<strong>（属性绑定，兼容性好）</strong>和dom2<strong>（函数绑定，兼容性不好，</strong>万恶的IE<strong>）</strong>事件绑定的区别</p> 
 <ul><li>如果定义了两个dom0级事件，dom0级事件会覆盖</li><li>dom2不会覆盖，会依次执行</li><li>dom0和dom2可以共存，不互相覆盖，但是dom0之间依然会覆盖</li><li>为啥不直接都用dom0呢？？按照W3C标准所推崇的——结构，行为，样式分离。  DOM0级的耦合度是最高的，所以说是其中最“笨”的方法。所以说这里要依次判断，如果浏览器能用好方法就用好方法，不然在降低标准，不然再降，到DOM0就是极限了。</li></ul> 
 <p></p> 
 <p><a href="https://www.cnblogs.com/holyson/p/3914406.html" rel="nofollow" id="cb_post_title_url" title="DOM0级事件处理和DOM2级事件处理">DOM0级事件处理和DOM2级事件处理</a></p> 
</blockquote> 
<ul><li> <h4 id="%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7">事件冒泡和事件捕获</h4> </li></ul> 
<blockquote> 
 <p><strong>事件冒泡（常用）</strong></p> 
 <p>IE中采用的事件流是事件冒泡，先从具体的接收元素，然后逐步向上传播到不具体的元素。</p> 
 <p><img alt="" class="has" src="https://images2.imgbox.com/d6/eb/291z5aVR_o.png"></p> 
 <p><strong>事件捕获（不常用）</strong></p> 
 <p>先由不具体的元素接收事件，最具体的节点最后才接收到事件。</p> 
 <p><img alt="" class="has" src="https://images2.imgbox.com/fa/27/00CBr0Xr_o.png"></p> 
 <p><strong>DOM事件流</strong></p> 
 <p><strong><img alt="" class="has" src="https://images2.imgbox.com/f5/21/VTebo4Ga_o.png"></strong></p> 
</blockquote> 
<ul><li> <h4 id="%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1">不同浏览器如何阻止事件冒泡</h4> </li></ul> 
<blockquote> 
 <ul><li>event.stopPropagation();||event.cancelBubble=true;</li></ul> 
 <p>事实上stoppropagation和cancelBubble的作用是一样的，都是用来阻止浏览器默认的事件冒泡行为。不同之处在于stoppropagation属于W3C标准，适用于Firefox等浏览器，但是不支持IE浏览器（IE8以下）。相反cancelBubble不符合W3C标准，而且只支持IE浏览器。所以很多时候，我们都要<strong>结合起来用</strong>。不过，cancelBubble在新版本chrome,opera浏览器中已经支持。</p> 
 <ul><li>event.preventDefault()阻止标签默认事件; </li></ul> 
 <p></p> 
 <p><a href="http://caibaojian.com/javascript-stoppropagation-preventdefault.html" rel="nofollow" title="JS阻止冒泡和取消默认事件(默认行为)">JS阻止冒泡和取消默认事件(默认行为)</a></p> 
 <p></p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/88136844" title="javascript 事件冒泡及其阻止方法">javascript 事件冒泡及其阻止方法</a></p> 
</blockquote> 
<ul><li> <h4 id="%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1EventUtil">跨浏览器的事件对象EventUtil</h4> </li></ul> 
<blockquote> 
 <p>在JavaScript中，DOM0级、DOM2级与旧版本IE(8-)为对象添加事件的方法不同</p> 
 <p>为了以跨浏览器的方式处理事件，需要编写一段“通用代码”，即跨浏览器的事件处理程序</p> 
 <p>习惯上，这个方法属于一个名为EventUtil的对象</p> 
 <p>编写并使用该对象后，可保证处理事件的代码能在大多数浏览器下一致的运行</p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/85939765" title="EventUtil对象的封装及其使用">EventUtil对象的封装及其使用</a></p> 
</blockquote> 
<ul><li> <h4 id="%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E5%8F%8A%E5%85%B6%E5%A5%BD%E5%A4%84">事件委托及其好处</h4> </li></ul> 
<blockquote> 
 <p>把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。</p> 
 <p>优点：</p> 
 <ul><li>减少内存消耗</li><li>动态绑定事件（因为事件是绑定在父层的，和目标元素的增减是没有关系的）</li></ul> 
 <p>局限性：</p> 
 <ul><li>focus、blur 之类的事件本身没有事件冒泡机制，所以无法委托</li><li>mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也不适合事件委托</li></ul> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/85989853" title="JavaScript 事件委托 (事件代理) 详解">JavaScript 事件委托 (事件代理) 详解</a></p> 
</blockquote> 
<ul><li> <h4 id="JSON%E5%92%8CXML%E7%9A%84%E5%AF%B9%E6%AF%94">JSON和XML的对比</h4> </li></ul> 
<blockquote> 
 <p>JSON对象的两个很重要的方法</p> 
 <pre class="has"><code class="language-javascript">JSON.parse() //JSON字符串转换为JSON对象

JSON.stringify() //JSON对象转化为字符串</code></pre> 
 <ul><li>JSON相对于XML来讲，数据的体积小，传递的速度更快些</li><li>JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互</li><li>XML对数据描述性比较好；</li><li>JSON的速度要远远快于XML</li></ul> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/89892114" title="JSON用法">JSON用法</a></p> 
</blockquote> 
<ul><li> <h4 id="Ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0">Ajax请求的实现</h4> </li></ul> 
<blockquote> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/89762865" title="原生Ajax和jQuery版本的使用">原生Ajax和jQuery版本的使用</a></p> 
</blockquote> 
<ul><li> <h4 id="Axios%E5%92%8CAjax%E7%9A%84%E5%8C%BA%E5%88%AB">Axios和Ajax的区别</h4> </li></ul> 
<blockquote> 
 <p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征：<br> 1.从浏览器中创建 XMLHttpRequest<br> 2.支持 Promise API<br> 3.客户端支持防止CSRF<br> 4.提供了一些并发请求的接口（重要，方便了很多的操作）<br> 5.从 node.js 创建 http 请求<br> 6.拦截请求和响应<br> 7.转换请求和响应数据</p> 
 <p><img alt="" height="499" src="https://images2.imgbox.com/b8/49/e2cY6Vcn_o.png" width="582"></p> 
</blockquote> 
<ul><li> <h4 id="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">浏览器的同源策略</h4> </li></ul> 
<blockquote> 
 <p>同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。是用于隔离潜在恶意文件的重要安全机制</p> 
 <p>属于同源，必须同时满足以下三个相同</p> 
 <ul><li>域名</li><li>协议</li><li>端口</li></ul> 
</blockquote> 
<ul><li> <h4 id="%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88">常用的跨域方案</h4> </li></ul> 
<blockquote> 
 <ul><li>JSONP：</li></ul> 
 <p>Ajax不能跨域，但是script标签和img标签都可以跨域。动态创建script，即新创建script标签，将回调函数名通过后缀的方式写入url地址，服务端收到后进行处理，将包含有json数据格式的对象封装在这个回调函数的参数里里面。客户端收到这个动态script的有参数的回调函数调用，执行操作，更新数据。</p> 
 <p><strong>缺点：</strong></p> 
 <p>　　1、无法发送post请求</p> 
 <p>　　2、要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。</p> 
 <p><strong>为什么不支持post请求：</strong></p> 
 <p>浏览器的同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互,jsonp跨域本质上是通过动态script标签, 本质上也是对静态资源的访问,所以只能是get请求</p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/89739935" title="JSONP原理及详细使用（含jQuery调用）">JSONP原理及详细使用（含jQuery调用）</a></p> 
 <hr> 
 <ul><li>CORS（跨域资源共享）</li></ul> 
 <p>CORS的整个过程都由浏览器自动完成，前端无需做任何设置，跟平时发送ajax请求并无差异。实现CORS的关键在于服务器，只要服务器实现CORS接口，就可以实现跨域通信。</p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/89765421" title="CORS原理及详细使用">CORS原理及详细使用</a></p> 
 <p><a href="https://blog.csdn.net/huangpb123/article/details/78335282" title="CORS 使用详解 + 例子">CORS 使用详解 + 例子</a></p> 
 <ul><li>window.postMessage()</li></ul> 
 <p>适合在APP内嵌网页与APP webview 的通信</p> 
 <ul><li>nginx</li></ul> 
 <p>由运维/前端 配置允许访问的域名</p> 
 <ul><li>websocket协议</li></ul> 
 <p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br> 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p> 
 <ul><li>node中间间代理跨域</li></ul> 
 <p>n<span style="color:#4f4f4f;">ode中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证</span></p> 
</blockquote> 
<ul><li> <h4 id="cookie%E3%80%81localStorage%E3%80%81sessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB">cookie、localStorage、sessionStorage的区别</h4> </li></ul> 
<blockquote> 
 <p><strong>存储大小：</strong></p> 
 <p>cookie数据大小不能超过4k。</p> 
 <p>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p> 
 <p><strong>生命周期：</strong></p> 
 <p>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</p> 
 <p>sessionStorage  数据在当前浏览器窗口关闭后自动删除。</p> 
 <p><strong>注意：</strong></p> 
 <p>通过点击链接（或者用了 window.open）打开的新标签页之间是属于同一个 session 的，但新开一个标签页总是会初始化一个新的 session，即使网站是一样的，它们也不属于同一个 session。</p> 
 <p><br><a href="https://blog.csdn.net/CWH0908/article/details/88081659" title="cookies，sessionStorage 和 localStorage 的区别">cookies，sessionStorage 和 localStorage 的区别</a></p> 
</blockquote> 
<ul><li> <h4 id="%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E9%87%8C%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%2C%E5%88%B0%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%B8%AD%E9%97%B4%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F">在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？</h4> </li></ul> 
<blockquote> 
 <p><img alt="" class="has" height="460" src="https://images2.imgbox.com/95/44/I0f83Av4_o.png" width="656"></p> 
 <p><img alt="" class="has" height="450" src="https://images2.imgbox.com/34/5c/rtzQiUUQ_o.png" width="838"></p> 
 <ol><li>输入url后，首先需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器用以解析ip地址。</li><li>得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的html给浏览器。</li><li>因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部央视，内部央视，内联样式构建一个CSS对象模型树CSSOM树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸。</li><li>之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 </li></ol> 
</blockquote> 
<p></p> 
<ul><li> <h4 id="call%E3%80%81bind%E3%80%81apply%E5%8C%BA%E5%88%AB"><span style="color:#333333;">call</span><span style="color:#333333;">、</span><span style="color:#333333;">bind</span><span style="color:#333333;">、</span><span style="color:#333333;">apply</span><span style="color:#333333;">区别</span></h4> </li></ul> 
<blockquote> 
 <p>call与apply都属于Function.prototype的一个方法，所以每个function实例都有call、apply属性；</p> 
 <p></p> 
 <p><strong>作用</strong><br> call（）方法和apply（）方法的作用相同：改变this指向。</p> 
 <p></p> 
 <p><strong>区别（接收参数的方式不同）</strong></p> 
 <ul><li>call（）：第一个参数是对象，其余参数都直接传递给函数（参数必须逐个列举出来）。</li><li>apply（）：第一个参数是对象，传递给函数的是参数数组或者arguments类数组对象。</li></ul> 
 <p></p> 
 <p>传递参数并非call()和apply()真正的作用，真正强大的地方是能修改函数运行的作用域（改变this指向）</p> 
 <p><a href="https://blog.csdn.net/CWH0908/article/details/88076979" title="javascript中的call()与apply()">javascript中的call()与apply()</a></p> 
</blockquote> 
<ul><li> <h4 id="get%E3%80%81post%E7%9A%84%E5%8C%BA%E5%88%AB"><span style="color:#333333;">get</span><span style="color:#333333;">、</span><span style="color:#333333;">post</span><span style="color:#333333;">的区别</span></h4> </li></ul> 
<blockquote> 
 <ul><li>Get 请求能缓存，Post 不能</li><li>Post 相对 Get 安全，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但在抓包的情况下都是一样的。</li><li>Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术</li><li>URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</li><li>Post 支持更多的编码类型且不对数据类型限制</li></ul> 
</blockquote> 
<ul><li> <h4 id="%E2%80%9C%20%3D%3D%3D%E2%80%9D%E3%80%81%E2%80%9C%20%3D%3D%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB">“ ===”、“ ==”的区别</h4> </li></ul> 
<blockquote> 
 <ul><li>==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型</li><li>===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型</li></ul> 
</blockquote> 
<ul><li> <h4 id="%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB">同步和异步的区别</h4> </li></ul> 
<blockquote> 
 <p style="margin-left:0cm;">同步是阻塞模式，异步是非阻塞模式。</p> 
 <ul><li style="margin-left:0cm;">同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；</li><li style="margin-left:0cm;">异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</li></ul> 
</blockquote> 
<ul><li> <h4 id="JS%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%A5%BD%E5%A4%84" style="margin-left:0cm;">JS模块化的好处</h4> </li></ul> 
<blockquote> 
 <p><img alt="" class="has" height="126" src="https://images2.imgbox.com/96/2b/2obLrZq0_o.png" width="482"></p> 
</blockquote> 
<ul><li> <h4 id="%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" style="margin-left:0cm;">执行上下文</h4> </li></ul> 
<blockquote> 
 <p style="text-align:center;"><img alt="" class="has" height="403" src="https://images2.imgbox.com/51/f3/PgKqpd34_o.png" width="442"></p> 
</blockquote> 
<ul><li> <h4 id="%E6%B7%B1%E6%8B%B7%E8%B4%9D">深拷贝</h4> </li></ul> 
<blockquote> 
 <ul><li>浅拷贝是指创建一个对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，那么拷贝的就是基本类型的值，如果属性是引用类型，那么拷贝的就是内存地址，所以如果其中一个对象修改了某些属性，那么另一个对象就会受到影响。</li><li>深拷贝是指从内存中完整地拷贝一个对象出来，并在堆内存中为其分配一个新的内存区域来存放，并且修改该对象的属性不会影响到原来的对象。</li></ul> 
 <p><strong>深拷贝和浅拷贝的实现方式分别有哪些？</strong></p> 
 <ul><li>浅拷贝：(1) Object.assign的方式 (2) 通过对象扩展运算符 (3) 通过数组的slice方法 (4) 通过数组的concat方法。</li><li>深拷贝：(1) 通过JSON.stringify来序列化对象 (2) 手动实现递归的方式</li></ul> 
 <p></p> 
 <p>使用变量 a 拷贝对象 b，改变 a 中的值 b 中的值也会跟着改变，这叫做浅拷贝。要想让 a 独立于 b 就需要深拷贝。（非基本类型）</p> 
 <h4 id="%E7%AE%80%E6%98%93%E5%A4%84%E7%90%86">简易处理</h4> 
 <pre class="has"><code class="language-javascript">function deepClone() {
    return JSON.parse(JSON.stringify(obj))
}复制代码</code></pre> 
 <p>既然是简易处理就有他的不足，上面主要是用了 JSON 的序列化和反序列化。而 JSON 是不支持function和 undefined 的，因此碰到这些情况会缺失，但是已经能够满足大部分情况了。</p> 
 <h4 id="%E5%A4%8D%E6%9D%82%E5%A4%84%E7%90%86">复杂处理</h4> 
 <p><strong>Object.assign  （伪深度拷贝,只能拷贝第一层</strong><strong>）</strong></p> 
 <p>定义:将源对象（source）的所有可枚举属性，复制到目标对象（target）</p> 
 <p>用法:</p> 
 <pre class="has"><code class="language-javascript">合并多个对象
var target = { a: 1, b: 1 };
var source1 = { b: 2, c: 2 };
var source2 = { c: 3 };
Object.assign(target, source1, source2);
复制代码</code></pre> 
 <p></p> 
 <p>完全深拷贝就需要采用递归的方式了</p> 
 <pre class="has"><code class="language-javascript">function clone(obj) {

    function whichType(o) {
        if (o === null) return "Null";
        if (o === undefined) return "Undefined";
        return Object.prototype.toString.call(o).slice(8, -1); //返回数据类型
    }

    var result;

    var oType = whichType(obj);
    if (oType === "Object") {
        result = {};
    } else if (oType === "Array") {
        result = [];
    } else {
        return obj;
    }

    for (var key in obj) {
        // key值为 对象的key值， 数组的下标值
        var copy = obj[key];
        if (whichType(copy) == "Object" || whichType(copy) == "Object") {
            result[key] = clone(copy); //递归调用
        } else {
            result[key] = copy; //基本类型直接返回
        }
    }
    return result;
}</code></pre> 
 <p>递归实现深拷贝解析 （面试回答）</p> 
 <p><strong><span style="color:#f33b45;">为什么要实现深拷贝呢？</span></strong>浅拷贝的限制所在了。它只能拷贝一层对象。如果有对象的嵌套，那么浅拷贝将无能为力浅拷贝引用的是内存地址，当修改拷贝的数据时会影响原来的数据，因此复杂数据类型需要使用深拷贝来克隆数据。</p> 
 <p><strong><span style="color:#f33b45;">为什么序列化和反序列化不行呢？</span></strong> JSON 是不支持function和 undefined 的，因此碰到这些情况会缺失，只能使用递归实现深拷贝。</p> 
 <p><span style="color:#f33b45;"><strong>如何实现数据深拷贝的递归方式呢？</strong></span>深拷贝的递归实现方式，首先需要判断传入的数据的类型，对于基本数据类型或者 null</p> 
 <p> 和 undefined 则直接返回，对于复杂数据类型（Array和Object），使用 Object.prototype.toString.call (数据) 的方式获取到数据类型，然后使用 for in 循环来得到 复杂数据类型的每个属性值（for in 取出的是对象的key值，数组的下标值），对于每个属性值，如果还是复杂数据类型（嵌套对象等），则继续调用此函数递归求解到基本数据类型为止，如果是基本数据类型，则返回，最后返回克隆的数据即可实现深拷贝。</p> 
</blockquote> 
<ul><li> <h4 id="js%E4%B8%ADimport%E5%92%8Crequire%E7%9A%84%E5%8C%BA%E5%88%AB">js中import和require的区别</h4> </li></ul> 
<blockquote> 
 <p>ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块。但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口。</p> 
 <p><strong>遵循规范</strong></p> 
 <ul><li><code>require</code> 是 CommonJS/AMD规范引入方式</li><li><code>import</code>是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</li></ul> 
 <p><strong>调用时间</strong></p> 
 <ul><li>require是运行时调用，所以require理论上可以运用在代码的任何地方</li><li>import是编译时调用，所以必须放在文件开头</li></ul> 
 <p><strong>本质</strong></p> 
 <ul><li>require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量</li><li>import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</li></ul> 
 <p>参考文章：<a href="https://www.cnblogs.com/sunshq/p/7922182.html" rel="nofollow" title="import和require的区别">import和require的区别</a></p> 
</blockquote> 
<ul><li> <h4 id="js%E6%8B%BC%E6%8E%A5%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E5%BC%8F">js拼接两个数组的方式</h4> </li></ul> 
<blockquote> 
 <ul><li> <strong>方法一：使用for循环</strong></li></ul> 
 <pre class="has"><code class="language-javascript">var arr = ['tom', 'jerry'];
var arr2 = [1, 2];

for(var i=0; i&lt;arr2.length; i++){
     arr.push(arr2[i])
}
console.log(arr);
// ['tom', 'jerry', 1, 2]</code></pre> 
 <ul><li><strong>方法二：使用concat()，注意concat()方法生成了一个新的数组，并不改变原来的数组。</strong></li></ul> 
 <pre class="has"><code class="language-javascript">var arr = ['tom', 'jerry'];
var arr2 = [1, 2];

var newArr = arr.concat(arr2);
console.log(newArr);
// ["tom", "jerry", 1, 2]</code></pre> 
 <ul><li><strong>方法三： 使用apply劫持数组的push方法（推荐，apply具体使用方法参考MDN）</strong></li></ul> 
 <pre class="has"><code class="language-javascript">var arr = ['tom', 'jerry'];
var arr2 = [1, 2];

arr.push.apply(arr, arr2);
console.log(arr)
// ["tom", "jerry", 1, 2]</code></pre> 
 <ul><li> <strong>方法四：使用es6中的 ‘点语法’ 扩展运算符（推荐）</strong></li></ul> 
 <pre class="has"><code class="language-javascript">var arr = ['tom', 'jerry'];
var arr2 = [1, 2];

arr.push(...arr2);
console.log(arr)
// ["tom", "jerry", 1, 2]</code></pre> 
 <ul><li><strong>备注：扩展运算符（...）</strong></li></ul> 
 <pre class="has"><code class="language-javascript">扩展运算符（ spread ）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5
[...document.querySelectorAll('div')]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</code></pre> 
 <p></p> 
</blockquote> 
<ul><li> <h4 id="String%E3%80%81Number%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%C2%A0">String、Number类型运算 </h4> </li></ul> 
<blockquote> 
 <pre class="has"><code class="language-javascript">console.log(1 + "2" + "2");

console.log(1 + +"2" + "2");

console.log(1 + -"1" + "2");

console.log(+"1" + "1" + "2");

console.log( "A" - "B" + "2");

console.log( "A" - "B" + 2);</code></pre> 
 <p>以上代码将输出到控制台：<br>  </p> 
 <pre class="has"><code class="language-javascript">"122"

"32"

"02"

"112"

"NaN2"

NaN</code></pre> 
 <p>这里的基本问题是JavaScript（ECMAScript）是一种松散类型的语言，它对值执行自动类型转换以适应正在执行的操作。让我们来看看这是如何与上面的每个例子进行比较。</p> 
 <ul><li>示例1：1 +“2”+“2”输出：“122”说明：第一个操作在1 +“2”中执行。由于其中一个操作数（“2”）是一个字符串，所以JavaScript假定需要执行字符串连接，因此将1的类型转换为“1”，1 +“2”转换为“12”。然后，“12”+“2”产生“122”。</li><li>示例2：1 + +“2”+“2”输出：“32”说明：根据操作顺序，要执行的第一个操作是+“2”（第一个“2”之前的额外+被视为一个一元运算符）。因此，JavaScript将“2”的类型转换为数字，然后将一元+符号应用于它（即将其视为正数）。结果，下一个操作现在是1 + 2，当然这会产生3.但是，我们有一个数字和一个字符串之间的操作（即3和“2”），所以JavaScript再次转换数值赋给一个字符串并执行字符串连接，产生“32”。</li><li>示例3：1 + - “1”+“2”输出：“02”说明：这里的解释与前面的示例相同，只是一元运算符是 - 而不是+。因此，“1”变为1，然后在应用 - 时将其变为-1，然后将其加1到产生0，然后转换为字符串并与最终的“2”操作数连接，产生“02”。</li><li>示例4：+“1”+“1”+“2”输出：“112”说明：尽管第一个“1”操作数是基于其前面的一元+运算符的数值类型转换的，当它与第二个“1”操作数连接在一起时返回一个字符串，然后与最终的“2”操作数连接，产生字符串“112”。</li><li>示例5：“A” - “B”+“2”输出：“NaN2”说明：由于 - 运算符不能应用于字符串，并且既不能将“A”也不能将“B”转换为数值， “ - ”B“产生NaN，然后与字符串”2“串联产生”NaN2“。</li><li>例6：“A” - “B”+2输出：NaN说明：在前面的例子中，“A” - “B”产生NaN。但是任何运算符应用于NaN和其他数字操作数仍然会产生NaN。 </li></ul> 
</blockquote> 
<ul><li> <h4 id="%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">数组去重的几种方式</h4> </li></ul> 
<blockquote> 
 <pre class="has"><code class="language-javascript">let originalArray = [1,2,3,4,5,3,2,4,1];

// 方式1
const result = Array.from(new Set(originalArray));
console.log(result); // -&gt; [1, 2, 3, 4, 5]

// 方式2
const result = [];
const map = new Map();
for (let v of originalArray) {
    if (!map.has(v)) {
        map.set(v, true);
        result.push(v);
    }
}
console.log(result); // -&gt; [1, 2, 3, 4, 5]

// 方式3
const result = [];
for (let v of originalArray) {
    if (!result.includes(v)) {
        result.push(v);
    }
}
console.log(result); // -&gt; [1, 2, 3, 4, 5]

// 方式4
for (let i = 0; i &lt; originalArray.length; i++) {
    for (let j = i + 1; j &lt; originalArray.length; j++) {
        if (originalArray[i] === originalArray[j]) {
            originalArray.splice(j, 1);
            j--;
        }
    }
}
console.log(originalArray); // -&gt; [1, 2, 3, 4, 5]

// 方式5
const obj = {};
const result = originalArray.filter(item =&gt; obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true));
console.log(result); // -&gt; [1, 2, 3, 4, 5]
</code></pre> 
 <p></p> 
</blockquote> 
<ul><li> <h4 id="JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">JS正则表达式</h4> </li></ul> 
<blockquote> 
 <p> 示例：</p> 
 <p><img alt="" height="197" src="https://images2.imgbox.com/04/3b/hBvWnrlw_o.png" width="366"></p> 
 <p>常用操作符</p> 
 <ul><li>    \d : 0-9之间的任意一个数字  \d只占一个位置</li><li>    \w : 数字，字母 ，下划线 0-9 a-z A-Z _</li><li>    \s : 空格或者空白等</li><li>    \D : 除了\d</li><li>    \W : 除了\w</li><li>    \S : 除了\s</li><li>     . : 除了\n之外的任意一个字符</li><li>    \ : 转义字符</li><li>    | : 或者</li><li>    () : 分组</li><li>    \n : 匹配换行符</li><li>     \b : 匹配边界 字符串的开头和结尾 空格的两边都是边界 =&gt; 不占用字符串位数</li><li>    ^ : 限定开始位置 =&gt; 本身不占位置</li><li>     $ : 限定结束位置 =&gt; 本身不占位置</li><li>    [a-z] : 任意字母 []中的表示任意一个都可以</li><li>    [^a-z] : 非字母 []中^代表除了</li><li>    [abc] : abc三个字母中的任何一个 [^abc]除了这三个字母中的任何一个字符</li></ul> 
 <p></p> 
 <table><tbody><tr><th>字符</th><th>描述</th></tr><tr><td>\</td><td> <p>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。</p> </td></tr><tr><td>^</td><td> <p>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。</p> </td></tr><tr><td>$</td><td> <p>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。</p> </td></tr><tr><td>*</td><td> <p>匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。</p> </td></tr><tr><td>+</td><td> <p>匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。</p> </td></tr><tr><td>?</td><td> <p>匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。</p> </td></tr><tr><td>{n}</td><td> <p>n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。</p> </td></tr><tr><td>{n,}</td><td> <p>n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。</p> </td></tr><tr><td>{n,m}</td><td> <p>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。</p> </td></tr><tr><td>?</td><td> <p>当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。</p> </td></tr><tr><td>.</td><td> <p>匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"<strong>(.|\n)</strong>"的模式。</p> </td></tr><tr><td>(pattern)</td><td> <p>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。</p> </td></tr><tr><td>(?:pattern)</td><td> <p>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。</p> </td></tr><tr><td>(?=pattern)</td><td> <p>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p> </td></tr><tr><td>(?!pattern)</td><td> <p>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p> </td></tr><tr><td>(?&lt;=pattern)</td><td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"<code>(?&lt;=95|98|NT|2000)Windows</code>"能匹配"<code>2000Windows</code>"中的"<code>Windows</code>"，但不能匹配"<code>3.1Windows</code>"中的"<code>Windows</code>"。</td></tr><tr><td>(?</td><td>反向否定预查，与正向否定预查类似，只是方向相反。例如"<code>(?"能匹配"<code>3.1Windows</code>"中的"<code>Windows</code>"，但不能匹配"<code>2000Windows</code>"中的"<code>Windows</code>"。</code></td></tr><tr><td>x|y</td><td> <p>匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。</p> </td></tr><tr><td>[xyz]</td><td> <p>字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。</p> </td></tr><tr><td>[^xyz]</td><td> <p>负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。</p> </td></tr><tr><td>[a-z]</td><td> <p>字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。</p> </td></tr><tr><td>[^a-z]</td><td> <p>负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。</p> </td></tr><tr><td>\b</td><td> <p>匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。</p> </td></tr><tr><td>\B</td><td> <p>匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。</p> </td></tr><tr><td>\cx</td><td> <p>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。</p> </td></tr><tr><td>\d</td><td> <p>匹配一个数字字符。等价于 [0-9]。</p> </td></tr><tr><td>\D</td><td> <p>匹配一个非数字字符。等价于 [^0-9]。</p> </td></tr><tr><td>\f</td><td> <p>匹配一个换页符。等价于 \x0c 和 \cL。</p> </td></tr><tr><td>\n</td><td> <p>匹配一个换行符。等价于 \x0a 和 \cJ。</p> </td></tr><tr><td>\r</td><td> <p>匹配一个回车符。等价于 \x0d 和 \cM。</p> </td></tr><tr><td>\s</td><td> <p>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</p> </td></tr><tr><td>\S</td><td> <p>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</p> </td></tr><tr><td>\t</td><td> <p>匹配一个制表符。等价于 \x09 和 \cI。</p> </td></tr><tr><td>\v</td><td> <p>匹配一个垂直制表符。等价于 \x0b 和 \cK。</p> </td></tr><tr><td>\w</td><td> <p>匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。</p> </td></tr><tr><td>\W</td><td> <p>匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。</p> </td></tr><tr><td>\xn</td><td> <p>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' &amp; "1"。正则表达式中可以使用 ASCII 编码。</p> </td></tr><tr><td>\num</td><td> <p>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。</p> </td></tr><tr><td>\n</td><td> <p>标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</p> </td></tr><tr><td>\nm</td><td> <p>标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</p> </td></tr><tr><td>\nml</td><td> <p>如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</p> </td></tr><tr><td>\un</td><td> <p>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</p> </td></tr></tbody></table> 
</blockquote> 
<ul><li> <h4 id="defer%20%E3%80%81async%20%E5%92%8Csync">defer 、async 和sync</h4> </li></ul> 
<blockquote> 
 <p>defer：延迟      async ：异步      sync：同步</p> 
 <p>当浏览器碰到 <code>script</code> 脚本的时候：</p> 
 <ol><li> <p></p> <p>没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 <code>script</code> 标签之下的文档元素之前，也就是说不等待后续载入的文档元素读到就加载并执行。</p> </li><li> <p></p> <p>有 <code>async</code>，加载和渲染后续文档元素的过程将和 <code>script.js</code> 的加载与执行并行进行（异步）。</p> </li><li> <p></p> <p>有 <code>defer</code>，加载后续文档元素的过程将和 <code>script.js</code> 的加载并行进行（异步），但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded</code> 事件触发之前完成。</p> </li></ol> 
 <p>然后从实用角度来说呢，首先把所有脚本都丢到  之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。</p> 
 <p>接着，我们来看一张图：</p> 
 <p><img alt="请输入图片描述" height="158" src="https://images2.imgbox.com/6b/c5/zit7wO36_o.jpg" width="972"></p> 
 <p>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p> 
 <p>此图告诉我们以下几个要点：</p> 
 <ol><li><em>defer</em> 和 <em>async</em> 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</li><li>它俩的差别在于脚本下载完之后何时执行，显然 <em>defer</em> 是最接近我们对于应用脚本加载和执行的要求的</li><li>关于 <em>defer</em>，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</li><li><em>async</em> 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</li><li>仔细想想，<em>async</em> 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics</li></ol> 
</blockquote> 
<p></p> 
<h3 id="JS%E9%9D%A2%E8%AF%95%E9%A2%98">JS面试题</h3> 
<blockquote> 
 <p> 例：</p> 
 <pre class="has"><code class="language-javascript">var a={},

    b={key:'b'},

    c={key:'c'};


a[b]=123;

a[c]=456;

console.log(a[b]);</code></pre> 
 <p>此代码的输出将是456（不是123）。</p> 
 <p>原因如下：设置对象属性时，JavaScript会隐式地将参数值串联起来。在这种情况下，由于b和c都是对象，它们都将被转换为“[object Object]”。因此，a [b]和a [c]都等价于[“[object Object]”]，并且可以互换使用。因此，设置或引用[c]与设置或引用[b]完全相同。</p> 
 <p></p> 
 <p>例：</p> 
 <pre class="has"><code class="language-javascript">  var a = 10;
  var obj = {
      a: 20,
      say: () =&gt; {  // 此处改为箭头函数
          console.log(this.a);
      }
  };
  obj.say(); // -&gt; 10

</code></pre> 
 <p>例</p> 
 <p><img alt="" height="312" src="https://images2.imgbox.com/49/be/gjZtCoVc_o.png" width="556"></p> 
 <p></p> 
 <p>例</p> 
 <p><img alt="" height="250" src="https://images2.imgbox.com/c6/ff/aK7RrAkS_o.png" width="389"></p> 
 <p></p> 
 <p><a href="https://mp.weixin.qq.com/s/7arl-8kDjxHgP2yV3LS0Eg" rel="nofollow" title="37个JavaScript基础面试题">37个JavaScript基础面试题</a></p> 
</blockquote> 
<p></p> 
<h3 id="Vue%E9%9D%A2%E8%AF%95%E9%A2%98">Vue面试题</h3> 
<ul><li> <h4 id="vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">vue的生命周期</h4> </li></ul> 
<blockquote> 
 <p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p> 
 <p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。</p> 
 <ol><li>实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行<span style="color:#f33b45;"><strong>beforeCreate</strong></span>钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</li><li>挂载数据，绑定事件等等，然后执行<span style="color:#f33b45;"><strong>created</strong></span>函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li><li>接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行<span style="color:#f33b45;"><strong>beforeMount</strong></span>钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li><li>接下来开始render，渲染出真实dom，然后执行<span style="color:#f33b45;"><strong>mounted</strong></span>钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情...</li><li>当组件或实例的数据更改之后，会立即执行<span style="color:#f33b45;"><strong>beforeUpdate</strong></span>，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿</li><li>当更新完成后，执行<span style="color:#f33b45;"><strong>updated</strong></span>，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom</li><li>当经过某种途径调用$destroy方法后，立即执行<span style="color:#f33b45;"><strong>beforeDestroy</strong></span>，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等</li><li>组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行<span style="color:#f33b45;"><strong>destroyed</strong></span>，在这里做善后工作也可以</li></ol> 
</blockquote> 
<ul><li> <h4 id="v-for%E4%B8%AD%3Akey%E7%9A%84%E4%BD%9C%E7%94%A8">v-for中:key的作用</h4> </li></ul> 
<blockquote> 
 <p>需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。key的作用主要是为了高效的更新虚拟DOM</p> 
 <p><a href="https://www.cnblogs.com/zhumingzhenhao/p/7688336.html" rel="nofollow" title="Vue2.0 v-for 中 :key 到底有什么用？">Vue2.0 v-for 中 :key 到底有什么用？</a></p> 
</blockquote> 
<ul><li> <h4 id="%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AA%E5%87%BD%E6%95%B0">组件中的data为什么是个函数</h4> </li></ul> 
<blockquote> 
 <p>组件是可复用的<code>vue</code>实例，一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的<code>data</code>数据都应该是相互隔离，互不影响的，基于这一理念，组件每复用一次，<code>data</code>数据就应该被复制一次，之后，当某一处复用的地方组件内<code>data</code>数据被改变时，其他复用地方组件的<code>data</code>数据不受影响。每个组件实例可以维护一份被返回对象的独立拷贝。</p> 
</blockquote> 
<ul><li> <h4 id="%C2%A0%E8%99%9A%E6%8B%9FDOM%E8%8A%82%E7%82%B9%C2%A0"> 虚拟DOM节点 </h4> </li></ul> 
<blockquote> 
 <p><img alt="" class="has" height="153" src="https://images2.imgbox.com/c2/66/cWshGcAX_o.png" width="1069"></p> 
 <p></p> 
 <p><strong> 优点:</strong></p> 
 <ul><li>保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限</li><li>无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率</li><li>跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等</li></ul> 
 <p><strong>缺点:</strong></p> 
 <ul><li>无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化</li></ul> 
 <p><strong>虚拟DOM实现原理?</strong></p> 
 <ul><li>虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象</li><li>状态变更时，记录新树和旧树的差异</li><li>最后把差异更新到真正的dom中</li></ul> 
 <p>虚拟DOM详细实现见<a href="https://link.juejin.im/?target=https%3A%2F%2Fuser-gold-cdn.xitu.io%2F2019%2F8%2F1%2F16c49afec13e0416" rel="nofollow" title="虚拟DOM原理">虚拟DOM原理</a></p> 
</blockquote> 
<ul><li> <h4 id="vue-cli%20%E8%84%9A%E6%89%8B%E6%9E%B6%20%E7%9B%AE%E5%BD%95%20%E8%A7%A3%E6%9E%90">vue-cli 脚手架 目录 解析</h4> </li></ul> 
<blockquote> 
 <p> <img alt="" class="has" src="https://images2.imgbox.com/eb/e3/ArUDXUlR_o.png"></p> 
 <p><img alt="" class="has" height="261" src="https://images2.imgbox.com/91/d4/YpO0Ntey_o.png" width="507"></p> 
 <p><img alt="" class="has" height="123" src="https://images2.imgbox.com/90/ce/V57NDT56_o.png" width="560"></p> 
</blockquote> 
<ul><li> <h4 id="Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86">Vue双向数据绑定原理</h4> </li></ul> 
<blockquote> 
 <ul><li>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。</li><li>首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。</li><li>因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。</li><li>接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</li></ul> 
 <p><img alt="" src="https://images2.imgbox.com/1c/11/Vag8BjVq_o.png"></p> 
 <p>参考文章：<a href="https://www.cnblogs.com/chenhuichao/p/10818396.html" rel="nofollow" title="vue的双向绑定原理及实现">vue的双向绑定原理及实现</a></p> 
</blockquote> 
<ul><li> <h4 id="MVVM%E6%98%AF%E4%BB%80%E4%B9%88%3F%C2%A0">MVVM是什么? </h4> </li></ul> 
<blockquote> 
 <ul><li>Model 层: 对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model。</li><li>View 层:作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明。</li><li>ViewModel 层:把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。</li></ul> 
 <p><img alt="" class="has" src="https://images2.imgbox.com/77/fc/W8QHgsdn_o.png"></p> 
</blockquote> 
<ul><li> <h4 id="%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8BMVVM%E6%A8%A1%E5%BC%8F">简述一下MVVM模式</h4> </li></ul> 
<blockquote> 
 <p>MVVM模式，即Model-View-ViewModel，其中，</p> 
 <p>Model是数据层，里面包含页面渲染所需要的数据。</p> 
 <p>View是视图层，即所呈现出来的页面。</p> 
 <p>VM层，是Model层和View层的桥梁。</p> 
 <p>View 和 Model 没有直接的联系，而是通过VM层进行交互，View 和 Model 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。开发者只需关注业务逻辑，不需要手动操作DOM。</p> 
</blockquote> 
<ul><li> <h4 id="MVVM%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%3F%C2%A0">MVVM的优缺点? </h4> </li></ul> 
<blockquote> 
 <p><strong>优点:</strong></p> 
 <ol><li>分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性: 比如视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定不同的"View"上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑</li><li>提高可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</li><li>自动更新dom: 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动dom中解放</li></ol> 
 <p><strong>缺点:</strong></p> 
 <ol><li>Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的</li><li>一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存</li><li>对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高</li></ol> 
</blockquote> 
<ul><li> <h4 id="Vue%E4%B8%ADMVVM%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">Vue中MVVM实现的基本原理</h4> </li></ul> 
<blockquote> 
 <p><img alt="" class="has" height="516" src="https://images2.imgbox.com/25/2e/ZuoIYHCS_o.png" width="763"></p> 
 <p></p> 
 <p><img alt="" class="has" height="499" src="https://images2.imgbox.com/56/9b/XE5XLPB8_o.png" width="1059"></p> 
</blockquote> 
<ul><li> <h4 id="Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">Vue组件通信</h4> </li></ul> 
<blockquote> 
 <p><img alt="" class="has" height="263" src="https://images2.imgbox.com/51/f2/BdHuk2gK_o.png" width="660"></p> 
</blockquote> 
<ul><li> <h4 id="computed%E5%92%8Cwatch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F">computed和watch有什么区别?</h4> </li></ul> 
<blockquote> 
 <p><strong>computed:</strong></p> 
 <ol><li><code>computed</code>是计算属性,也就是计算值,它更多用于计算值的场景</li><li><code>computed</code>具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算</li><li><code>computed</code>适用于计算比较消耗性能的计算场景</li></ol> 
 <p><strong>watch:</strong></p> 
 <ol><li>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察<code>props</code> <code>$emit</code>或者本组件的值,当数据变化时来执行回调进行后续操作</li><li>无缓存性，页面重新渲染时值不变化也会执行</li></ol> 
</blockquote> 
<ul><li> <h4 id="Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD">Vue组件的按需加载</h4> </li></ul> 
<blockquote> 
 <pre class="has"><code class="language-javascript">// 工厂函数执行 resolve 回调
Vue.component('async-webpack-example', function (resolve) {
  // 这个特殊的 `require` 语法将会告诉 webpack
  // 自动将你的构建代码切割成多个包, 这些包
  // 会通过 Ajax 请求加载
  require(['./my-async-component'], resolve)
})

</code></pre> 
 <p></p> 
</blockquote> 
<ul><li> <h4 id="vue-router%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86">vue-router的核心原理</h4> </li></ul> 
<blockquote> 
 <p>vue-router通过hash与History两种方式实现前端路由，更新视图但不重新请求页面”是前端路由原理的核心之一</p> 
</blockquote> 
<ul><li> <h4 id="vue%20mixins%E5%92%8Cextends%E7%9A%84%E5%8C%BA%E5%88%AB">vue mixins和extends的区别</h4> </li></ul> 
<blockquote> 
 <p>混合mixins和继承extends</p> 
 <img alt="" class="has" src="https://images2.imgbox.com/b4/e4/hsk8OpZK_o.png"> 
 <p></p> 
 <p>看看官方文档怎么写的，其实两个都可以理解为继承，mixins接收对象数组（可理解为多继承），extends接收的是对象或函数（可理解为单继承）。</p> 
 <p><img alt="" class="has" height="604" src="https://images2.imgbox.com/d1/c4/Ujjdcs2y_o.png" width="516"></p> 
 <p><img alt="" class="has" height="536" src="https://images2.imgbox.com/c0/57/8FSH1YpF_o.png" width="343"></p> 
 <p><img alt="" class="has" height="335" src="https://images2.imgbox.com/86/8a/8NF4WUrv_o.png" width="491"></p> 
 <p>关于mixins和extend你可以理解为mvc的c(controller)，这一层。可见通用的成员变量（包括属性和方法）抽象成为一个父类，提供给子类继承，这样可以让子类拥有一些通用成员变量，然而子类也可以重写父类的成员变量。这样的整个编程思想就很面向对象，也就是继承性。</p> 
</blockquote> 
<ul><li> <h4 id="Vue%E7%9A%84SEO%E4%BC%98%E5%8C%96">Vue的SEO优化</h4> </li></ul> 
<blockquote> 
 <p><a href="https://blog.csdn.net/chjj0904/article/details/79388438" title="前后端分离之SEO优化--------以vue为例">前后端分离之SEO优化--------以vue为例</a></p> 
</blockquote> 
<ul><li> <h4 id="Vue%20%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E6%95%B0%E7%BB%84%E9%A1%B9%E8%B5%8B%E5%80%BC%E5%8F%98%E5%8C%96%E5%90%97"><strong>Vue 能检测到数组项赋值变化吗</strong></h4> </li></ul> 
<blockquote> 
 <p>vue中的数组的监听不是通过Object.defineProperty来实现的，是通过对'push', 'pop','shift','unshift','splice', 'sort','reverse'等改变数组本身的方法来通知监听的,所以直接给数组某一项赋值无法监听到变化,解决方案如下:</p> 
 <ul><li> <p>用vue的set方法改变数组或者对象</p> </li><li> <p>用改变数组本身的方法如splice, pop, shift等</p> </li><li> <p>用深拷贝,解构运算符</p> </li></ul> 
</blockquote> 
<ul><li> <h4 id="%E4%B8%BA%E4%BB%80%E4%B9%88%20vue%20%E4%B8%8D%E9%9C%80%E8%A6%81%E5%85%B3%E5%BF%83%20shouldcomponetupdate%EF%BC%88react%EF%BC%89">为什么 vue 不需要关心 shouldcomponetupdate（react）</h4> </li></ul> 
<blockquote> 
 <p>在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。</p> 
 <p>如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 PureComponent，或是手动实现 shouldComponentUpdate 方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。</p> 
 <p>然而，使用 PureComponent 和 shouldComponentUpdate 时，需要保证该组件的整个子树的渲染输出都是由该组件的 props 所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致。这使得 React 中的组件优化伴随着相当的心智负担。</p> 
 <p>在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上述的子树问题限制。</p> 
 <p>Vue 的这个特点使得开发者不再需要考虑此类优化，从而能够更好地专注于应用本身。</p> 
 <p><br> Vue 和 React 本质上都是实现这个逻辑，分歧在于 isDataChanged 如何计算。<br> React 选择把这个变量的计算过程交给开发者实现，如果开发者没有实现就默认为 true；Vue 凭借 getter/setter 特性可以自动计算出这个值，但牺牲了 IE8- 的兼容性。</p> 
</blockquote> 
<h3 id="React%20%E9%9D%A2%E8%AF%95%E9%A2%98">React 面试题</h3> 
<ul><li> <h4 id="React%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">React 生命周期</h4> </li></ul> 
<blockquote> 
 <ul><li> <p>初始化阶段：</p> 
   <ul><li>getDefaultProps:获取实例的默认属性</li><li>getInitialState:获取每个实例的初始化状态</li><li>componentWillMount：组件即将被装载、渲染到页面上</li><li>render:组件在这里生成虚拟的 DOM 节点</li><li>componentDidMount:组件真正在被装载之后</li></ul></li><li> <p>运行中状态：</p> 
   <ul><li>componentWillReceiveProps:组件将要接收到属性的时候调用</li><li>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</li><li>componentWillUpdate:组件即将更新不能修改属性和状态</li><li>render:组件重新描绘</li><li>componentDidUpdate:组件已经更新</li></ul></li><li> <p>销毁阶段：</p> 
   <ul><li>componentWillUnmount:组件即将销毁</li></ul></li></ul> 
</blockquote> 
<ul><li> <h4 id="%E4%B8%BA%E4%BD%95%E8%A6%81%E5%9C%A8componentDidMount%E9%87%8C%E9%9D%A2%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%9F%C2%A0">为何要在componentDidMount里面发送请求？ </h4> </li></ul> 
<blockquote> 
 <p>如果你要获取外部数据并加载到组件上，只能在组件"已经"挂载到真实的网页上才能作这事情，其它情况你是加载不到组件的。</p> 
 <p></p> 
 <ul><li>constructor被调用是在组件准备要挂载的最一开始，所以此时组件尚未挂载到网页上。</li><li>componentWillMount方法的调用在constructor之后，在render之前，在这方法里的代码调用setState方法不会触发重渲染，所以它一般不会用来作加载数据之用，它也很少被使用到。</li><li>一般的从后台(服务器)获取的数据，都会与组件上要用的数据加载有关，所以都在componentDidMount方法里面作。虽然与组件上的数据无关的加载，也可以在constructor里作，但constructor是作组件state初绐化工作，并不是设计来作加载数据这工作的，componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。</li></ul> 
 <p></p> 
 <p>constructor()中获取数据的话，如果时间太长，或者出错，组件就渲染不出来，你整个页面都没法渲染了。</p> 
 <p>componentDidMount()中能保证你的组件已经正确渲染。</p> 
 <p>总结下：</p> 
 <ol><li>跟服务器端渲染（同构）有关系，如果在componentWillMount里面获取数据，fetch data会执行两次，一次在服务器端一次在客户端。在componentDidMount中可以解决这个问题。</li><li>在componentWillMount中fetch数据一定在render后才能到达，如果你忘记了设置初始状态，用户体验不好。</li><li>react16.0以后，componentWillMount可能会被执行多次。</li></ol> 
</blockquote> 
<ul><li> <h4 id="React%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81">React单向数据流</h4> </li></ul> 
<blockquote> 
 <p>React遵循从上到下的数据流向，即单向数据流。</p> 
 <p>        单向数据流并非‘单向绑定’，甚至单向数据流与绑定没有‘任何关系’。对于React来说，单向数据流（从上到下）与单一数据源这两个原则，限定了React中要想在一个组件中更新另一个组件的状态（类似于Vue的平行组件传参，或者是子组件向父组件传递参数），需要进行状态提升。即将状态提升到他们最近的祖先组件中。子组件中Change了状态，触发父组件状态的变更，父组件状态的变更，影响到了另一个组件的显示（因为传递给另一个组件的状态变化了，这一点与Vue子组件的$emit()方法很相似）。</p> 
 <p>    Vue也是单向数据流(https://cn.vuejs.org/v2/guide/components-props.html)，只不过能实现双向绑定。</p> 
 <p>    单向数据流中的‘单向’-- 数据从父组件到子组件这个流向叫单向。</p> 
 <p>    绑定的单双向：View层与Module层之间的映射关系。<br>  </p> 
</blockquote> 
<ul><li> <h4 id="%3CSwitch%3E%20%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8">标签的作用</h4> </li></ul> 
<blockquote> 
 <p>  渲染第一个被location匹配到的并且作为子元素的或者</p> 
 <p>  使用包裹和直接用一堆有什么区别呢？</p> 
 <p>  是唯一的因为它仅仅只会渲染一个路径。相比之下（不使用包裹的情况下），每一个被location匹配到的将都会被渲染。</p> 
 <p><a href="https://www.jianshu.com/p/ed5e56994f13?from=timeline" rel="nofollow" title="react-router v4 之 啥是">react-router v4 之 啥是</a></p> 
</blockquote> 
<ul><li> <h4 id="react%E4%B8%ADkey%E5%80%BC%E4%BD%9C%E7%94%A8">react中key值作用</h4> </li></ul> 
<blockquote> 
 <p>Key 是 React 用于追踪哪些列表中元素被修改的标识。</p> 
 <p>保证某个元素的 key 在其同级元素中具有唯一性。在 Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。</p> 
</blockquote> 
<ul><li> <h4 id="%E4%B8%BA%E4%BB%80%E4%B9%88%20setState%20%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84">为什么 setState 是异步的</h4> </li></ul> 
<blockquote> 
 <p><a href="https://segmentfault.com/a/1190000014131698" rel="nofollow" title="React中setState真的是异步的吗">React中setState真的是异步的吗</a></p> 
 <p><img alt="" height="266" src="https://images2.imgbox.com/3d/ee/INk0dwok_o.png" width="1200"></p> 
</blockquote> 
<ul><li> <h4 id="item-5">react 性能优化是哪个周期函数？</h4> </li></ul> 
<blockquote> 
 <p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p> 
</blockquote> 
<ul><li> <h4 id="item-6">为什么虚拟 dom 会提高性能?(必考)</h4> </li></ul> 
<blockquote> 
 <p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p> 
 <p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p> 
</blockquote> 
<ul><li> <h4 id="react%20diff%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%87%E7%A8%8B">react diff算法的比较过程</h4> </li></ul> 
<blockquote> 
 <ul><li>把树形结构按照层级分解，只比较同级元素。</li><li>给列表结构的每个单元添加唯一的 key 属性，方便比较。</li><li>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</li><li>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</li><li>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</li></ul> 
</blockquote> 
<ul><li> <h4 id="%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%88%E7%B1%BB%E7%BB%84%E4%BB%B6%EF%BC%89%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%88%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB">状态组件（类组件）和无状态组件（函数组件）的区别</h4> </li></ul> 
<blockquote> 
 <ul><li>无状态组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当无状态组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。</li><li>容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。</li><li>无状态组件的优缺点</li></ul> 
 <p>优点：</p> 
 <ol><li>易复用，易测试</li><li>与逻辑处理数据解耦，一般来说，app里有越多无状态组件越好，这说明逻辑处理都在上层，例如redux 中处理，这样可以在不渲染的前提下，测数据逻辑。</li></ol> 
 <p>缺点：</p> 
 <ol><li> <p>没有生命周期，没办法用shouldComponentUpdate阻止重新渲染，这也就是说，它没有帮助我们提高性能的作用，这也是它跟PureComponent最大的不同。</p> </li></ol> 
</blockquote> 
<ul><li> <h4 id="item-12">状态(state)和属性(props)之间有何不同</h4> </li></ul> 
<blockquote> 
 <ul><li>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</li><li>Props是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的。组件不能改变自身的 props，只能把数据变更到数据提交给父组件去处理，让父组件改变传递给子组件的props。</li></ul> 
</blockquote> 
<ul><li> <h4 id="item-25">讲一下redux</h4> </li></ul> 
<blockquote> 
 <ul><li>redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据。</li><li>flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。</li><li>Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰</li><li>新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们。</li></ul> 
</blockquote> 
<ul><li> <h4 id="render%E5%87%BD%E6%95%B0%E4%B8%ADreturn%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8()%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">render函数中return如果没有使用()会有什么问题</h4> </li></ul> 
<blockquote> 
 <p>为了代码可读性我们一般会在return后面添加括号这样代码可以折行书写，否则就在return 后面紧跟着语句，不然的话，代码会报错</p> 
</blockquote> 
<ul><li> <h4 id="super()%E5%92%8Csuper(props)%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%C2%A0">super()和super(props)有什么区别？ </h4> </li></ul> 
<blockquote> 
 <p>如果你使用了constructor就必须写super() 这个是用来初始化this的，可以绑定事件到this上<br> 如果你想要在constructor中使用this.props,就必须给super添加参数 super(props)</p> 
</blockquote> 
<ul><li> <h4 id="react%E4%BD%BF%E7%94%A8async%2Fawait">react使用async/await</h4> </li></ul> 
<blockquote> 
 <pre><code class="language-javascript">async componentDidMount() {
    try {
        const response = await axios.get('http://XXXXXX').then(res=&gt;{
            if(res.data.err = XXX){
                 throw Error(response.statusText);        
            }else{
                this.setState(XXX:res.data.XXX)
            }
        })
    } catch (error) {
        console.log(error);
    }
}</code></pre> 
</blockquote> 
<ul><li> <h4 id="%E8%AE%B2%E4%B8%80%E4%B8%8Breact%20%E7%9A%84%20jsx">讲一下react 的 jsx</h4> </li></ul> 
<blockquote> 
 <p>JSX 是一个 JavaScript 语法扩展。它类似于模板语言，但它具有 JavaScript 的全部能力。JSX 最终会被编译为 <code>React.createElement()</code> 函数调用，返回称为 “React 元素” 的普通 JavaScript 对象。</p> 
</blockquote> 
<ul><li> <h4 id="componentWillUpdate%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9state%E7%9A%84%E5%80%BC%E5%90%97%EF%BC%9F">componentWillUpdate可以直接修改state的值吗？</h4> </li></ul> 
<blockquote> 
 <p>在<strong>componentWillUpdate</strong>中通过<strong>setState</strong>更新，会一直触发<strong>componentWillUpdate</strong>导致无限循环,最终报错。</p> 
</blockquote> 
<ul><li> <h4 id="super()%E5%92%8Csuper(props)%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%86%99super%E7%9A%84%E5%8C%BA%E5%88%AB"><code>super()</code>和<code>super(props)</code>以及不写super的区别</h4> </li></ul> 
<blockquote> 
 <p>1、如果你用到了constructor就必须写super()，是用来初始化this的，可以绑定事件到this上；</p> 
 <p>2、如果你在constructor中要使用this.props，就必须给super加参数：super(props)；（无论有没有constructor，在render中this.props都是可以使用的，这是React自动附带的；）</p> 
 <p>3、如果没用到constructor，是可以不写的；React会默认添加一个空的constructor。</p> 
</blockquote> 
<ul><li> <h4 id="Context%20%E7%9A%84%E4%BD%9C%E7%94%A8">Context 的作用</h4> </li></ul> 
<blockquote> 
 <p>Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p> 
 <p>Context 主要应用场景在于<em>很多</em>不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。</p> 
</blockquote> 
<ul><li> <h4 id="React%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E6%99%AE%E9%80%9A%E7%9A%84HTML%E4%BA%8B%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F">React的事件和普通的HTML事件有什么不同？</h4> </li></ul> 
<blockquote> 
 <ul><li>在 HTML 中事件名必须小写，而在 React 中它遵循<em>camelCase</em>(驼峰) 惯例</li><li>在 HTML 中你可以返回<code>false</code>以阻止默认的行为，而在 React 中你必须地明确地调用<code>preventDefault()，原生事件在合成事件之后，可以使用event.stopPropagation()来阻止冒泡。</code></li></ul> 
</blockquote> 
<ul><li> <h4 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E6%B2%A1%E6%9C%89%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F">为什么函数式组件没有生命周期？</h4> </li></ul> 
<blockquote> 
 <p>因为函数式组件没有继承React.Component，由于生命周期函数是React.Component类的方法实现的，所以没继承这个类，自然就没法使用生命周期函数了</p> 
</blockquote> 
<ul><li> <h4 id="%E5%9C%A8React%E4%B8%AD%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84render%EF%BC%9F">在React中如何避免不必要的render？</h4> </li></ul> 
<blockquote> 
 <p><img alt="" height="269" src="https://images2.imgbox.com/bf/ca/GAjhRdLy_o.png" width="472"></p> 
</blockquote> 
<ul><li> <h4 id="React%20%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%82%B9%E5%87%BB%E5%85%83%E7%B4%A0%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6">React 如何判断点击元素属于哪一个组件</h4> </li></ul> 
<blockquote> 
 <p><img alt="" height="151" src="https://images2.imgbox.com/39/80/IcFHgmoA_o.png" width="479"></p> 
</blockquote> 
<ul><li> <h4 id="this.refs.XXX%20%E7%9A%84%E4%BD%9C%E7%94%A8">this.refs.XXX 的作用</h4> </li></ul> 
<blockquote> 
 <ul><li>refs 引用的是虚拟DOM， document.getXXX得到的是真实DOM。</li><li>refs 可以引用到自定义的React组件，调用组件的方法，而document不能。</li><li>使用这种MVVM前端框架应该尽量不去直接访问DOM，当然某些情况下是必须要访问</li></ul> 
</blockquote> 
<ul><li> <h4 id="vue%E5%92%8Creact%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><strong>vue和react路由的区别是什么？</strong></h4> </li></ul> 
<blockquote> 
 <p>二者的设计理念大致相同，无论是vue-router还是react-router，它们的最基本的初衷就是实现前端路由。所谓前端路由，简单来说，就是当浏览器的url产生变化时，不向服务器进行请求，而是直接控制前端页面产生变化，以期待前端在比如功能切换时，产生类似页面跳转等效果。</p> 
 <p>而这里面最基本的，无论是vue-router还是react-router，都要提供一种配置方式，让使用者可以<em>配置出url路径和要展示的组件的对应关系</em>。这样一来，用户通过页面点击或者其他方式触发浏览器url变化时，VUE或者React系统就可以找到这个url对应的VUE组件或者React组件，从而有针对性地，将这个组件在页面上渲染。</p> 
</blockquote> 
<ul><li> <h4 id="react%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F">react绑定函数的四种方式</h4> </li></ul> 
<blockquote> 
 <pre><code class="language-javascript">class App extends Component{
  constructor(props){
    super(props);
    this.function1 = this.function1.bind(this)

  }

  // 1，在constructor构造函数中绑定
  function1(){

  }

  // 2，在绑定事件时使用bind
  function2(params){

  }

  // 3，在绑定事件时使用箭头函数
  function3(params){

  }

  // 4，新语法，直接使用箭头函数创建
  function3 = ()=&gt;{

  }

  render(){
    return &lt;div onClick = {this.function2.bind(this,params)}&gt;
        &lt;div onClick = {(e)=&gt;{this.function3(params,e)}}&gt;&lt;/div&gt;
    &lt;/div&gt;
  }

}</code></pre> 
</blockquote> 
<ul><li> <h4 id="react%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6">react高阶组件</h4> </li></ul> 
<blockquote> 
 <p><strong>什么是高阶组件？</strong></p> 
 <ul><li><strong>一个高阶组件只是</strong>一个包装了另外一个 React 组件的 <strong>React 组件</strong>。</li></ul> 
 <p></p> 
 <p><strong>高阶组件可以用来做什么</strong></p> 
 <ul><li>代码复用，逻辑抽象，抽离底层准备（bootstrap）代码</li><li>渲染劫持</li><li>State 抽象和更改</li><li>Props 更改</li></ul> 
 <p></p> 
 <p><strong>高阶组件工厂的实现</strong></p> 
 <p>属性代理（Props Proxy）和 反向继承（Inheritance Inversion）。下面只介绍属性代理</p> 
 <p>属性代理的实现方法如下：</p> 
 <pre><code class="language-javascript">function ppHOC(WrappedComponent) {
  return class PP extends React.Component {
    render() {
      return &lt;WrappedComponent {...this.props}/&gt;
    }
  }
}
</code></pre> 
 <p>可以看到，这里高阶组件的 render 方法<strong>返回</strong>了一个 type 为 WrappedComponent 的 React Element（也就是被包装的那个组件），我们把高阶组件收到的 props 传递给它，因此得名 <strong>Props Proxy</strong>。</p> 
 <p>注意：</p> 
 <pre><code class="language-javascript">&lt;WrappedComponent {...this.props}/&gt;
// is equivalent to
React.createElement(WrappedComponent, this.props, null)
</code></pre> 
 <p>它们都创建了一个 React Element，描述了 React 在『reconciliation』（可以理解为解析）阶段的渲染内容，如果你想了解更多关于 React Element 的内容，请看 <a href="https://link.jianshu.com?t=https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html" rel="nofollow" title="Dan Abramov 的这篇博客">Dan Abramov 的这篇博客</a> 和官方文档上关于 <a href="https://link.jianshu.com?t=https://facebook.github.io/react/docs/reconciliation.html" rel="nofollow" title="reconciliation process">reconciliation process</a> 的部分。</p> 
 <p>Props Proxy 可以做什么？</p> 
 <ul><li>更改 props</li><li>通过 refs 获取组件实例</li><li>抽象 state</li><li>把 WrappedComponent 与其它 elements 包装在一起</li></ul> 
 <p>更改 props</p> 
 <p>你可以『<strong>读取，添加，修改，删除</strong>』将要传递给 WrappedComponent 的 props。</p> 
 <p>在修改或删除重要 props 的时候要小心，你可能应该给高阶组件的 props 指定命名空间（namespace），以防破坏从外传递给 WrappedComponent 的 props。</p> 
 <p>例子：添加新 props。这个应用目前登陆的一个用户可以在 WrappedComponent 通过 this.props.user 获取</p> 
 <pre><code class="language-javascript">function ppHOC(WrappedComponent) {
  return class PP extends React.Component {
    render() {
      const newProps = {
        user: currentLoggedInUser
      }
      return &lt;WrappedComponent {...this.props} {...newProps}/&gt;
    }
  }
}
</code></pre> 
 <p>通过 refs 获取组件实例</p> 
 <p>你可以通过 ref 获取关键词 <strong><em>this</em></strong>（WrappedComponent 的实例），但是想要它生效，必须先经历一次正常的渲染过程来让 ref 得到计算，这意味着你需要在高阶组件的 render 方法中返回 WrappedComponent，让 React 进行 reconciliation 过程，这之后你就通过 ref 获取到这个 WrappedComponent 的实例了。</p> 
 <p>例子：下方例子中，我们实现了通过 ref 获取 WrappedComponent 实例并调用实例方法。</p> 
 <pre><code class="language-javascript">function refsHOC(WrappedComponent) {
  return class RefsHOC extends React.Component {
    proc(wrappedComponentInstance) {
      wrappedComponentInstance.method()
    }
    render() {
      const props = Object.assign({}, this.props, {ref: this.proc.bind(this)})
      return &lt;WrappedComponent {...props}/&gt;
    }
  }
}
</code></pre> 
 <p>当 WrappedComponent 被渲染后，ref 上的回调函数 proc 将会执行，此时就有了这个 WrappedComponent 的实例的引用。这个可以用来『<strong>读取，添加</strong>』实例的 props 或用来执行实例方法。</p> 
 <p>抽象 state</p> 
 <p>你可以通过向 WrappedComponent 传递 props 和 callbacks（回调函数）来抽象 state，这和 React 中另外一个组件构成思想 <a href="https://link.jianshu.com?t=https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.9licl3udu" rel="nofollow" title="Presentational and Container Components">Presentational and Container Components</a> 很相似。</p> 
 <p>例子：在下面这个抽象 state 的例子中，我们幼稚地（原话是naively :D）抽象出了 name input 的 value 和 onChange。我说这是幼稚的是因为这样写并不常见，但是你会理解到点。</p> 
 <pre><code class="language-javascript">function ppHOC(WrappedComponent) {
  return class PP extends React.Component {
    constructor(props) {
      super(props)
      this.state = {
        name: ''
      }
      this.onNameChange = this.onNameChange.bind(this)
    }
    onNameChange(event) {
      this.setState({
        name: event.target.value
      })
    }
    render() {
      const newProps = {
        name: {
          value: this.state.name,
          onChange: this.onNameChange
        }
      }
      return &lt;WrappedComponent {...this.props} {...newProps}/&gt;
    }
  }
}
</code></pre> 
 <p>然后这样使用它：</p> 
 <pre><code class="language-javascript">@ppHOC
class Example extends React.Component {
  render() {
    return &lt;input name="name" {...this.props.name}/&gt;
  }
}
</code></pre> 
 <p>这里的 input 自动成为一个受控的input。</p> 
 <p><br> 参考链接：<a href="https://www.jianshu.com/p/0aae7d4d9bc1" rel="nofollow" title="深入理解 React 高阶组件 - 简书">深入理解 React 高阶组件 - 简书</a><br>  </p> 
 <p>用法实例：</p> 
 <p>编写好高阶组件 withTimer用于给传入的组件注入定时器功能</p> 
 <p><img alt="" height="566" src="https://images2.imgbox.com/99/76/TD3NwDbg_o.png" width="637"></p> 
 <p>在需要使用高阶组件的组件中引入高阶组件</p> 
 <pre><code class="language-javascript">// 1 引入有定时器功能的组件
import withTImer from 'XXXX';


// 2 只在UI上添加符合高阶组件显示的标签,并传入在高阶组件中定义好的 值，time
class App from extends{

    render(){
        return &lt;div&gt;
              &lt;h4&gt;  {this.props.time.toLocaleString()}  &lt;/h4&gt;
        &lt;/div&gt;

    }
}

// 
export default withTimer(App)</code></pre> 
</blockquote> 
<ul><li> <h4 id="%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AD%90%E7%BB%84%E4%BB%B6">函数作为子组件</h4> </li></ul> 
<blockquote> 
 <p><img alt="" height="394" src="https://images2.imgbox.com/47/e9/RJlaZqal_o.png" width="481"></p> 
</blockquote> 
<ul><li> <h4 id="React%20%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F%C2%A0">React 父组件如何调用子组件中的方法？ </h4> </li></ul> 
<blockquote> 
 <p>1、如果是在方法组件中调用子组件（<code>&gt;= react@16.8</code>），可以使用 <code>useRef</code> 和 <code>useImperativeHandle</code>:</p> 
 <pre><code class="language-javascript">const { forwardRef, useRef, useImperativeHandle } = React;

const Child = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    getAlert() {
      alert("getAlert from Child");
    }
  }));
  return &lt;h1&gt;Hi&lt;/h1&gt;;
});

const Parent = () =&gt; {
  const childRef = useRef();
  return (
    &lt;div&gt;
      &lt;Child ref={childRef} /&gt;
      &lt;button onClick={() =&gt; childRef.current.getAlert()}&gt;Click&lt;/button&gt;
    &lt;/div&gt;
  );
};
</code></pre> 
 <p>2、如果是在类组件中调用子组件（<code>&gt;= react@16.4</code>），可以使用 <code>createRef</code>:</p> 
 <pre><code class="language-javascript">const { Component } = React;

class Parent extends Component {
  constructor(props) {
    super(props);
    this.child = React.createRef();
  }

  onClick = () =&gt; {
    this.child.current.getAlert();
  };

  render() {
    return (
      &lt;div&gt;
        &lt;Child ref={this.child} /&gt;
        &lt;button onClick={this.onClick}&gt;Click&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

class Child extends Component {
  getAlert() {
    alert('getAlert from Child');
  }

  render() {
    return &lt;h1&gt;Hello&lt;/h1&gt;;
  }
}
</code></pre> 
</blockquote> 
<ul><li> <h4 id="React%20%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD%E7%9A%84%E6%89%8B%E6%AE%B5%3F">React 有哪些优化性能的手段?</h4> </li></ul> 
<blockquote> 
 <p></p> 
 <h4 id="%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5">类组件中的优化手段</h4> 
 <p>1、使用纯组件 <code>PureComponent</code> 作为基类。</p> 
 <p>2、使用 <code>React.memo</code> 高阶函数包装组件。</p> 
 <p>3、使用 <code>shouldComponentUpdate</code> 生命周期函数来自定义渲染逻辑。</p> 
 <h4 id="%E6%96%B9%E6%B3%95%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5">方法组件中的优化手段</h4> 
 <p>1、使用 <code>useMemo</code>。</p> 
 <p>2、使用 <code>useCallBack</code>。</p> 
 <h4 id="%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F">其他方式</h4> 
 <p>1、在列表需要频繁变动时，使用唯一 id 作为 key，而不是数组下标。</p> 
 <p>2、必要时通过改变 CSS 样式隐藏显示组件，而不是通过条件判断显示隐藏组件。</p> 
 <p>3、使用 <code>Suspense</code> 和 <code>lazy</code> 进行懒加载，例如：</p> 
 <pre><code class="language-javascript">import React, { lazy, Suspense } from "react";

export default class CallingLazyComponents extends React.Component {
  render() {
    var ComponentToLazyLoad = null;

    if (this.props.name == "Mayank") {
      ComponentToLazyLoad = lazy(() =&gt; import("./mayankComponent"));
    } else if (this.props.name == "Anshul") {
      ComponentToLazyLoad = lazy(() =&gt; import("./anshulComponent"));
    }

    return (
      &lt;div&gt;
        &lt;h1&gt;This is the Base User: {this.state.name}&lt;/h1&gt;
        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
          &lt;ComponentToLazyLoad /&gt;
        &lt;/Suspense&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre> 
 <p><code>Suspense</code> 用法可以参考官方文档</p> 
 <p><a href="https://link.zhihu.com/?target=https%3A//www.infoq.cn/article/KVE8xtRs-uPphptq5LUz" rel="nofollow" title="更多性能优化文档">更多性能优化文档</a></p> 
</blockquote> 
<ul><li> <h4 id="react%20hook">react hook</h4> </li></ul> 
<blockquote> 
 <p> 详细用法：<a href="https://blog.csdn.net/CWH0908/article/details/110095140" title="React Hooks_友人CWH的博客-CSDN博客">React Hooks_友人CWH的博客-CSDN博客</a></p> 
 <p><img alt="" height="200" src="https://images2.imgbox.com/1f/33/8VYijXSx_o.png" width="1200"></p> 
 <ul><li>常用的react hook API为useState (允许您将 React state(状态) 添加到函数式组件中) 和 useEffect 。 </li></ul> 
 <pre><code class="language-javascript">import { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);
  // 声明一个名为 count 的 state(状态)变量，并将其设置为 0 。React 将记住它在重新渲染之间的当 
  //前值，并为我们的函数提供最新的值。如果我们想要更新当前 count ，我们可以调用 setCount。

  return &lt;div&gt;

    读取 state(状态)可以直接使用count而无需使用this.state.count {count}

    &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
    &lt;/button&gt;
  &lt;/div&gt;
}

</code></pre> 
 <p><img alt="" height="904" src="https://images2.imgbox.com/d4/37/yHCt5Ry2_o.png" width="1200"></p> 
 <ul><li>Hooks 使用的是您已经知道的 React 功能，只是采用了更直接的方式 - 例如 state(状态)，lifecycle(生命周期)，context(上下文) 和 refs 。 它们并没有从根本上改变 React 的工作方式，而且您对组件，props(属性) 和自上而下数据流的了解也同样重要。</li><li>可以将 <code>useEffect</code> Hook 视为 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 的组合。</li></ul> 
 <p><img alt="" height="1106" src="https://images2.imgbox.com/03/15/YmdhXYd2_o.png" width="1200"></p> 
 <p><a href="http://react.html.cn/docs/hooks-effect.html" rel="nofollow" title="react hook  官网">react hook  官网</a></p> 
</blockquote> 
<ul><li> <h4 id="mixin%E3%80%81hoc%E3%80%81render%20props%E3%80%81react-hooks%E7%9A%84%E4%BC%98%E5%8A%A3%E5%A6%82%E4%BD%95%EF%BC%9F">mixin、hoc、render props、react-hooks的优劣如何？</h4> </li></ul> 
<blockquote> 
 <p><strong>Mixin的缺陷：</strong></p> 
 <ul><li>组件与<code>Mixin</code>之间存在隐式依赖（<code>Mixin</code>经常依赖组件的特定⽅法，但在定义组件时并不知道这种依赖关系）</li><li>多个<code>Mixin</code>之间可能产⽣冲突（⽐如定义了相同的<code>state</code>字段）</li><li><code>Mixin</code>倾向于增加更多状态，这降低了应⽤的可预测性（The more state in your application, the harder it is to reason about it.），导致复杂度剧增</li><li>隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升： 
   <ul><li>难以快速理解组件⾏为，需要全盘了解所有依赖<code>Mixin</code>的扩展⾏为，及其之间的相互影响</li><li>组价⾃身的⽅法和<code>state</code>字段不敢轻易删改，因为难以确定有没有<code>Mixin</code>依赖它</li><li><code>Mixin</code>也难以维护，因为<code>Mixin</code>逻辑最后会被打平合并到⼀起，很难搞清楚⼀个<code>Mixin</code>的输⼊输出</li></ul></li></ul> 
 <p></p> 
 <p><strong>HOC相⽐Mixin的优势:</strong></p> 
 <ul><li><code>HOC</code>通过外层组件通过<code>Props</code>影响内层组件的状态，⽽不是直接改变其<code>State</code>不存在冲突和互相⼲扰,这就降低了 耦合度</li><li>不同于<code>Mixin</code>的打平+合并,<code>HOC</code>具有天然的层级结构（组件树结构），这⼜降低了复杂度</li></ul> 
 <p><strong>HOC的缺陷:</strong></p> 
 <ul><li>扩展性限制: <code>HOC</code>⽆法从外部访问⼦组件的<code>State</code>因此⽆法通过<code>shouldComponentUpdate</code>滤掉不必要的更新,<code>React</code>在⽀持<code>ES6 Class</code>之后提供了<code>React.PureComponent</code>来解决这个问题</li><li><code>Ref</code>传递问题: <code>Ref</code>被隔断,后来的<code>React.forwardRef</code>来解决这个问题</li><li><code>Wrapper Hell</code>:<code>HOC</code>可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本</li><li>命名冲突: 如果⾼阶组件多次嵌套,没有使⽤命名空间的话会产⽣冲突,然后覆盖⽼属性</li><li>不可⻅性: <code>HOC</code>相当于在原有组件外层再包装⼀个组件,你压根不知道外层的包装是啥,对于你是⿊盒</li></ul> 
 <p></p> 
 <p><strong>Render Props优点:</strong></p> 
 <ul><li>上述<code>HOC</code>的缺点<code>Render Props</code>都可以解决</li></ul> 
 <p><strong>Render Props缺陷:</strong></p> 
 <ul><li>使⽤繁琐: <code>HOC</code>使⽤只需要借助装饰器语法通常⼀⾏代码就可以进⾏复⽤,<code>Render Props</code>⽆法做到如此简单</li><li>嵌套过深: <code>Render Props</code>虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套</li></ul> 
 <p></p> 
 <p><strong>React Hooks优点:</strong></p> 
 <ul><li>简洁: <code>React Hooks</code>解决了<code>HOC</code>和<code>Render Props</code>的嵌套问题,更加简洁</li><li>解耦: <code>React Hooks</code>可以更⽅便地把 <code>UI</code> 和状态分离,做到更彻底的解耦</li><li>组合: <code>Hooks</code> 中可以引⽤另外的 <code>Hooks</code>形成新的<code>Hooks</code>,组合变化万千</li><li>函数友好: <code>React Hooks</code>为函数组件⽽⽣,从⽽解决了类组件的⼏⼤问题: 
   <ul><li><code>this</code>指向容易错误</li><li>分割在不同声明周期中的逻辑使得代码难以理解和维护</li><li>代码复⽤成本⾼（⾼阶组件容易使代码量剧增）</li></ul></li></ul> 
 <p><strong>React Hooks缺陷:</strong></p> 
 <ul><li>额外的学习成本（<code>Functional Component</code> 与<code>Class Component</code>之间的困惑）</li><li>写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本</li><li>破坏了<code>PureComponent</code>、<code>React.memo</code>浅⽐较的性能优化效果（为了取最新的<code>props</code>和<code>state</code>，每次<code>render()</code>都要重新创建事件处函数）</li><li>在闭包场景可能会引⽤到旧的<code>state</code>、<code>props</code>值</li><li>内部实现上不直观（依赖⼀份可变的全局状态，不再那么“纯”）</li><li><code>React.memo</code>并不能完全替代<code>shouldComponentUpdate</code>（因为拿不到<code>state change</code>，只针对 <code>props change</code>）</li></ul> 
</blockquote> 
<ul><li> <h4 id="react%20%E6%96%87%E7%AB%A0">react 文章</h4> </li></ul> 
<blockquote> 
 <p><strong><a href="https://zhuanlan.zhihu.com/p/83079398" rel="nofollow" title="react重难点">react重难点</a></strong></p> 
 <p><strong><a href="http://react-china.org/t/topic/33558" rel="nofollow" title="React 328道最全面试题(持续更新)">React 328道最全面试题(持续更新)</a></strong></p> 
 <p><strong><a href="https://segmentfault.com/a/1190000018811476" rel="nofollow" title="React深入】从Mixin到HOC再到Hook">React深入】从Mixin到HOC再到Hook</a></strong></p> 
</blockquote> 
<ul><li> <h4></h4> </li></ul> 
<p></p> 
<h3 id="Webpack%E9%9D%A2%E8%AF%95%E9%A2%98">Webpack面试题</h3> 
<ul><li> <h4 id="%E4%BB%80%E4%B9%88%E6%98%AFWebpack">什么是Webpack</h4> </li></ul> 
<blockquote> 
 <p>WebPack可以看做是模块打包机，在webpack里一切文件皆模块。它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p> 
</blockquote> 
<ul><li> <h4 id="webpack%E4%B8%8Egrunt%E3%80%81gulp%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F">webpack与grunt、gulp的不同？</h4> </li></ul> 
<blockquote> 
 <ul><li>Gulp/Grunt是一种能够优化前端的开发流程的工具。</li><li>WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。</li></ul> 
 <p><a href="https://segmentfault.com/a/1190000006178770" rel="nofollow" title="webpack入门手册">webpack入门手册</a></p> 
 <p><a href="https://blog.csdn.net/sinat_38992528/article/details/79400595" title="grunt入门手册">grunt入门手册</a></p> 
 <p>他们的工作方式也有较大区别：</p> 
 <ul><li>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。</li><li>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</li></ul> 
 <p></p> 
 <p>三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。</p> 
 <ul><li>grunt和gulp是基于任务和流的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。</li><li>webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。</li><li>gulp和grunt是流管理工具，通过一个个task配置执行用户需要的功能，如格式检验，代码压缩等，值得一提的是，经过这两者处理的代码只是局部变量名被替换简化，整体并没有发生改变，还是你的代码。</li><li>webpack则进行了更彻底的打包处理，更加偏向对模块语法规则进行转换。主要任务是<strong>突破浏览器的鸿沟，将原本浏览器不能识别的规范和各种各样的静态文件进行分析，压缩，合并，打包，最后生成浏览器支持的代码</strong>，因此，webapck打包过后的代码已经不是你写的代码了，或许你再去看，已经看不懂啦</li></ul> 
</blockquote> 
<ul><li> <h4 id="NPM%E5%92%8Cwebpack%E7%9A%84%E5%85%B3%E7%B3%BB">NPM和webpack的关系</h4> </li></ul> 
<blockquote> 
 <p><strong><a href="https://blog.csdn.net/CWH0908/article/details/90769823" title="NPM和webpack的关系（转载）">NPM和webpack的关系（转载）</a></strong></p> 
</blockquote> 
<ul><li> <h4 id="%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8Dbundle%EF%BC%8Cchunk%EF%BC%8Cmodule%E6%98%AF%E4%BB%80%E4%B9%88">分别介绍bundle，chunk，module是什么</h4> </li></ul> 
<blockquote> 
 <ul><li>bundle：是由webpack打包出来的文件，</li><li>chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分割。</li><li>module：是开发中的单个模块，在webpack的世界，一切皆模块，一个模块对应一个文件，webpack会从配置的entry中递归开始找出所有依赖的模块。</li></ul> 
</blockquote> 
<ul><li> <h4 id="%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D%E4%BB%80%E4%B9%88%E6%98%AFloader%3F%E4%BB%80%E4%B9%88%E6%98%AFplugin%3F">分别介绍什么是loader?什么是plugin?</h4> </li></ul> 
<blockquote> 
 <ul><li>loader：模块转换器，用于将模块的原内容按照需要转成你想要的内容</li><li>plugin：在webpack构建流程中的特定时机注入扩展逻辑，来改变构建结果，是用来自定义webpack打包过程的方式，一个插件是含有apply方法的一个对象，通过这个方法可以参与到整个webpack打包的各个流程(生命周期)。</li></ul> 
</blockquote> 
<ul><li> <h4 id="%E4%BB%80%E4%B9%88%20%E6%98%AF%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%9F">什么 是模块热更新？</h4> </li></ul> 
<blockquote> 
 <p>模块热更新是webpack的一个功能，他可以使得代码修改过后不用刷新浏览器就可以更新，是高级版的自动刷新浏览器。</p> 
 <p>好处：保持应用的数据状态，节省调试时间，样式调试更快</p> 
</blockquote> 
<ul><li> <h4 id="%C2%A0%E5%A6%82%E4%BD%95%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90webpack%E9%85%8D%E7%BD%AE%EF%BC%9F"> 如何可以自动生成webpack配置？</h4> </li></ul> 
<blockquote> 
 <p>webpack-cli /vue-cli /etc ...脚手架工具</p> 
</blockquote> 
<ul><li> <h4 id="webpack-dev-server%E5%92%8Chttp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82nginx%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F">webpack-dev-server和http服务器如nginx有什么区别?</h4> </li></ul> 
<blockquote> 
 <p>webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，他比传统的http服务对开发更加简单高效。</p> 
</blockquote> 
<ul><li> <h4 id="webpack%E5%92%8Cgulp%E5%8C%BA%E5%88%AB%EF%BC%88%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89">webpack和gulp区别（模块化与流的区别）</h4> </li></ul> 
<blockquote> 
 <p>gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。</p> 
 <p>webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。</p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="Git%E9%9D%A2%E8%AF%95%E9%A2%98">Git面试题</h3> 
<ul><li> <h4 id="问题3git和svn的优缺点"><strong>git和svn的优缺点。</strong></h4> </li></ul> 
<blockquote> 
 <p>Git是分布式版本控制系统，SVN是集中式版本控制系统</p> 
 <p><strong>SVN优缺点 </strong></p> 
 <ul><li>优点： </li></ul> 
 <ol><li>管理方便，逻辑明确，符合一般人思维习惯。 </li><li>易于管理，集中式服务器更能保证安全性。 </li><li>代码一致性非常高。 </li><li>适合开发人数不多的项目开发。 </li></ol> 
 <ul><li>缺点： </li></ul> 
 <ol><li>服务器压力太大，数据库容量暴增。 </li><li>如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。 </li><li>不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。</li></ol> 
 <p><strong>Git优缺点 </strong></p> 
 <ul><li>优点： </li></ul> 
 <ol><li>适合分布式开发，强调个体。 </li><li>公共服务器压力和数据量都不会太大。 </li><li>速度快、灵活。 </li><li>任意两个开发者之间可以很容易的解决冲突。 </li><li>离线工作。 </li></ol> 
 <ul><li>缺点： </li></ul> 
 <ol><li>学习周期相对而言比较长。 </li><li>不符合常规思维。 </li><li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</li></ol> 
</blockquote> 
<ul><li> <h4 id="Git%20%E9%87%8C%E9%9D%A2%E7%9A%84%20origin">Git 里面的 origin</h4> </li></ul> 
<blockquote> 
 <p>origin 是默认的远程版本库名称，你可以在 .git/config 之中进行修改，事实上 git push origin master 的意思是 git push origin master:master （将本地的 master 分支推送至远端的 master 分支，如果没有就新建一个）</p> 
</blockquote> 
<ul><li> <h4 id="fetch%E5%92%8Cmerge%E5%92%8Cpull%E7%9A%84%E5%8C%BA%E5%88%AB">fetch和merge和pull的区别</h4> </li></ul> 
<blockquote> 
 <p> pull相当于git fetch 和 git merge，即更新远程仓库的代码到本地仓库，然后将内容合并到当前分支。</p> 
 <ul><li> git fetch：相当于是从远程获取最新版本到本地，不会自动merge</li><li> git merge :  将内容合并到当前分支</li><li> git pull：相当于是从远程获取最新版本并merge到本地</li></ul> 
</blockquote> 
<ul><li> <h4 id="%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">常用命令</h4> </li></ul> 
<blockquote> 
 <ul><li>git show # 显示某次提交的内容 git show $id</li><li>git add # 将工作文件修改提交到本地暂存区</li><li>git rm # 从版本库中删除文件</li><li>git reset # 从暂存区恢复到工作文件</li><li>git reset HEAD^ # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</li><li>git diff # 比较当前文件和暂存区文件差异 git diff</li><li>git log -p # 查看每次详细修改内容的diff</li><li>git branch -r # 查看远程分支</li><li>git merge # 将branch分支合并到当前分支</li><li>git stash # 暂存</li><li>git stash pop #恢复最近一次的暂存</li><li>git pull # 抓取远程仓库所有分支更新并合并到本地</li><li>git push origin master # 将本地主分支推到远程主分支</li></ul> 
</blockquote> 
<h3 id="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">浏览器和网络协议</h3> 
<ul><li> <h4 id="http%20%E5%92%8C%20https%20%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB" style="margin-left:0cm;">http 和 https 有何区别</h4> </li></ul> 
<blockquote> 
 <ul><li>http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</li><li>https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份</li></ul> 
</blockquote> 
<ul><li> <h4 id="TCP%E4%BC%A0%E8%BE%93%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%C2%A0">TCP传输的三次握手 </h4> </li></ul> 
<blockquote> 
 <p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。</p> 
 <p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 <br> 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 <br> 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。</p> 
</blockquote> 
<ul><li> <h4 id="%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%88%90%E5%8A%9F%E6%98%BE%E7%A4%BA%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%C2%A0">从输入URL到页面加载成功显示经历了什么 </h4> </li></ul> 
<blockquote> 
 <ol><li>当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。</li><li>浏览器与远程`Web`服务器通过`TCP`三次握手协商来建立一个`TCP/IP`连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</li><li>一旦`TCP/IP`连接建立，浏览器会通过该连接向远程服务器发送`HTTP`的`GET`请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。</li><li>此时，`Web`服务器提供资源服务，客户端开始下载资源。请求返回后，便进入了我们关注的前端模块简单来说，浏览器会解析`HTML`生成`DOM Tree`，其次会根据CSS生成CSS Rule Tree，而`javascript`又可以根据`DOM API`操作`DOM`</li></ol> 
 <p>总结：</p> 
 <ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol> 
</blockquote> 
<ul><li> <h4 id="%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81" style="margin-left:0cm;">常见的HTTP状态码</h4> </li></ul> 
<blockquote> 
 <p><strong>面试常用</strong>：</p> 
 <ul><li>    200 请求成功。</li><li>    301 永久重定向。</li><li>    302  临时重定向。</li><li>    304  请求已缓存。</li><li>    403  无权限访问。</li><li>    404  找不到该网页。</li><li>    405  请求方式不支持。</li><li>    500  服务器错误。</li><li>    502 代理服务器响应错误。</li><li>    504 代理服务器响应超时。</li></ul> 
 <p><strong>汇总：</strong></p> 
 <ul><li>    100  Continue 继续，发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li><li>    200  OK   正常返回信息</li><li>    201  Created 请求成功并且服务器创建了新的资源</li><li>    202  Accepted 服务器已接受请求，但尚未处理</li><li>    301  Moved Permanently  请求的网页已永久移动到新位置。</li><li>    302  Found  临时性重定向。</li><li>    303  SeeOther  临时性重定向，且总是使用 GET 请求新的 URI。</li><li>    304  Not Modified 自从上次请求后，请求的网页未修改过。</li><li>    400  BadRequest  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li><li>    401  Unauthorized  请求未授权。</li><li>    403  Forbidden  禁止访问。</li><li>    404  NotFound  找不到如何与 URI 相匹配的资源。</li><li>    500  InternalServer Error  最常见的服务器端错误。</li><li>    503  ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li></ul> 
 <p></p> 
 <p><strong>汇总：</strong></p> 
 <ul><li>2开头 （请求成功）表示成功处理了请求的状态代码。</li></ul> 
 <p>200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 <br> 201   （已创建）  请求成功并且服务器创建了新的资源。 <br> 202   （已接受）  服务器已接受请求，但尚未处理。 <br> 203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。 <br> 204   （无内容）  服务器成功处理了请求，但没有返回任何内容。 <br> 205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br> 206   （部分内容）  服务器成功处理了部分 GET 请求。</p> 
 <p></p> 
 <ul><li>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</li></ul> 
 <p>300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 <br> 301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br> 302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br> 303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br> 304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 <br> 305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 <br> 307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p> 
 <p></p> 
 <ul><li>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</li></ul> 
 <p>400   （错误请求） 服务器不理解请求的语法。 <br> 401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 <br> 403   （禁止） 服务器拒绝请求。<br> 404   （未找到） 服务器找不到请求的网页。<br> 405   （方法禁用） 禁用请求中指定的方法。 <br> 406   （不接受） 无法使用请求的内容特性响应请求的网页。 <br> 407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br> 408   （请求超时）  服务器等候请求时发生超时。 <br> 409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 <br> 410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 <br> 411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 <br> 412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 <br> 413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 <br> 414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 <br> 415   （不支持的媒体类型） 请求的格式不受请求页面的支持。 <br> 416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 <br> 417   （未满足期望值） 服务器未满足"期望"请求标头字段的要求。</p> 
 <p></p> 
 <ul><li>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</li></ul> 
 <p>500   （服务器内部错误）  服务器遇到错误，无法完成请求。 <br> 501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 <br> 502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 <br> 503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 <br> 504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 <br> 505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p> 
</blockquote> 
<ul><li> <h4 id="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88" style="margin-left:0cm;">浏览器的内核分别是什么</h4> </li></ul> 
<blockquote> 
 <ul><li>Chrome：Blink(基于webkit，Google与Opera Software共同开发)</li><li>IE: trident内核</li><li>Firefox：gecko内核</li><li>Safari：webkit内核</li><li>Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核</li></ul> 
</blockquote> 
<ul><li> <h4 id="%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%92%8C%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA" style="margin-left:0cm;">优雅降级和渐进增强</h4> </li></ul> 
<blockquote> 
 <ul><li>优雅降级：（常用，兼容IE）</li></ul> 
 <p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p> 
 <p></p> 
 <ul><li>渐进增强：</li></ul> 
 <p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p> 
</blockquote> 
<ul><li> <h4 id="%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2" style="margin-left:0cm;">浏览器是如何渲染页面</h4> </li></ul> 
<blockquote> 
 <ol><li>解析HTML文件，创建DOM树。自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。</li><li>解析CSS。优先级：浏览器默认设置&lt;用户设置&lt;外部样式&lt;内联样式</li><li>将CSS与DOM合并，构建渲染树（Render Tree）</li><li>布局和绘制，重绘（repaint）和重排（reflow）</li></ol> 
</blockquote> 
<ul><li> <h4 id="%E5%85%B3%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%C2%A0">关于事件循环 </h4> </li></ul> 
<blockquote> 
 <p><strong>node端</strong></p> 
 <blockquote> 
  <p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p> 
 </blockquote> 
 <p><strong>Event Loop 6 个阶段：</strong></p> 
 <ol><li>timers</li><li>I/O callbacks</li><li>idle, prepare</li><li>poll</li><li>check</li><li>close callbacks</li></ol> 
 <p></p> 
 <p><strong>浏览器端</strong></p> 
 <blockquote> 
  <p><strong>浏览器端</strong> 的情况与 <strong>node端</strong> 的情况相仿，当我们执行 JS 代码的时候其实就是往执行栈中放入函数，当遇到异步的代码时，会被<strong>挂起</strong>并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行。</p> 
 </blockquote> 
 <ul><li><strong>微任务(microtask)</strong> 
   <ul><li>process.nextTick</li><li>promise</li><li>Object.observe(曾经是提案，如今已经废除)</li><li>MutationOberver</li></ul></li><li><strong>宏任务(macrotask)</strong> 
   <ul><li>script</li><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>UI渲染</li></ul></li></ul> 
 <p><strong>执行顺序如下：</strong></p> 
 <ol><li>执行同步代码，这是宏任务</li><li>执行栈为空，查询是否有微任务要执行</li><li>必要时渲染UI</li><li>进行下一轮的 <strong>EventLoop</strong> ，执行宏任务中的异步代码</li></ol> 
 <p>参考链接：<a href="https://blog.csdn.net/CWH0908/article/details/102892913" title="JS事件循环——宏任务和微任务">JS事件循环——宏任务和微任务</a></p> 
 <p><strong>setTimeout 误差</strong></p> 
 <p>上面讲了定时器是属于 <strong>宏任务(macrotask)</strong> 。如果当前 <strong>执行栈</strong> 所花费的时间大于 <strong>定时器</strong> 时间，那么定时器的回调在 <strong>宏任务</strong>里，来不及去调用，所有这个时间会有误差。</p> 
 <p>我们看以下代码：</p> 
 <pre class="has"><code class="language-javascript">setTimeout(function () {
	console.log('biubiu');
}, 1000);

//某个执行时间很长的函数();
</code></pre> 
 <p>如果定时器下面的函数执行要 5秒钟，那么定时器里的log 则需要 5秒之后再执行，函数占用了当前 <strong>执行栈</strong> ，要等执行栈执行完毕后再去读取 <strong>微任务(microtask)</strong>，等 <strong>微任务(microtask)</strong> 完成，这个时候才会去读取 <strong>宏任务</strong> 里面的 <strong>setTimeout</strong> 回调函数执行。<strong>setInterval</strong> 同理，例如每3秒放入宏任务，也要等到执行栈的完成。</p> 
 <p><a href="https://juejin.im/post/5cfc9d266fb9a07edb3939ea" rel="nofollow" title="前端进阶之setTimeout 倒计时为什么会出现误差？">前端进阶之setTimeout 倒计时为什么会出现误差？</a></p> 
</blockquote> 
<ul><li> <h4 id="%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%96%B9%E5%BC%8F" style="margin-left:0cm;">垃圾回收机制方式</h4> </li></ul> 
<blockquote> 
 <p>标记清除(常用)和引用计数。</p> 
 <ul><li>标记清除：</li></ul> 
 <p>　　定义和用法：当变量进入环境时，将变量标记"进入环境"，当变量离开环境时，标记为："离开环境"。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。</p> 
 <p>　　到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p> 
 <ul><li>引用计数：</li></ul> 
 <p>　　定义和用法：引用计数是跟踪记录每个值被引用的次数。</p> 
 <p>　　基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。</p> 
</blockquote> 
<ul><li> <h4 id="Web%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF" style="margin-left:0cm;">Web攻击技术</h4> </li></ul> 
<blockquote> 
 <ul><li>XSS 跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在url地址的请求参数中。主要是前端层面的，用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站 cookie，</li><li>预防方法：不相信用户的所有操作，对用户输入进行一个转义，不允许 js 对 cookie 的读写，为cookie设置httpOnly属性，对用户的输入进行检查，进行特殊字符过滤</li></ul> 
 <p></p> 
 <ul><li>CSRF 跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求，比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库。即以你的名义，发送恶意请求。</li><li>预防方法：使用验证码，检查https头部的refer，使用token，通过 cookie 加参数等形式过滤</li><li><img alt="" height="266" src="https://images2.imgbox.com/80/f8/vMw0vJpr_o.png" width="691"></li></ul> 
 <p></p> 
 <p>参考文章：<a href="https://www.kancloud.cn/freya001/interview/1442326" rel="nofollow" title="002.web安全 · 每天一道面试题 · 看云">002.web安全 · 每天一道面试题 · 看云</a></p> 
</blockquote> 
<ul><li> <h4 id="转载-理解cookie和session机制">理解Cookie和session机制</h4> </li></ul> 
<blockquote> 
 <p>http是无状态协议，会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</p> 
 <ul><li>Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。</li><li>Session技术则是服务端的解决方案，它是通过服务器来保持状态的。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</li><li>虽然Session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为Session需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。</li></ul> 
 <p><img alt="" height="208" src="https://images2.imgbox.com/6e/2b/DtvIhcVB_o.png" width="758"></p> 
 <p>参考文章：<a href="https://www.cnblogs.com/andy-zhou/p/5360107.html" rel="nofollow" title="理解Cookie和Session机制">理解Cookie和Session机制</a></p> 
</blockquote> 
<ul><li> <h4 id="Cookie%E5%92%8Csession%E3%80%81storage%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB">Cookie和session、storage的区别和联系</h4> </li></ul> 
<blockquote> 
 <p><img alt="" height="436" src="https://images2.imgbox.com/c0/4d/F07NVE0G_o.png" width="711"></p> 
</blockquote> 
<ul><li> <h4 id="%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84Http%E8%AF%B7%E6%B1%82%E5%A4%B4">缓存相关的Http请求头</h4> </li></ul> 
<blockquote> 
 <table><thead><tr><td>headers字段</td><td>解释</td><td>案例</td></tr></thead><tbody><tr><td> <p>Expires</p> </td><td> <p>服务端告诉浏览器，先把这个文件缓存起来，在这个过期时间之前，该文件都不会变化</p> </td><td> <p>Expires: Mon, 1 Aug 2016 22:43:02 GMT</p> </td></tr><tr><td> <p>Cache-Control</p> </td><td> <p>由于Expires给定的是绝对时间，而客户端的系统时间可以由用户任意修改, Cache-Control为相对时间</p> </td><td> <p>Cache-Control: max-age=80</p> </td></tr><tr><td> <p>Last-Modified(response header) / If-Modified-Since (request header)</p> </td><td> <p>服务端收到请求后会对比目前文件的最后修改时间和该请求头的信息，如果没有修改，那就直接返回304给浏览器，而不返回实际资源。如果有变化了，就返回200，并且带上新的资源内容</p> </td><td> <p>If-Modified-Since:Mon, 01 Aug 2016 13:48:44 GMT</p> </td></tr><tr><td> <p>Etag / If-None-Match</p> </td><td> <p>第一次请求后响应头中包含了Etag，作为时间标签,下一次请求时会把原来的Etag标签带上（在请求头中变成了If-None-Match）作为校验标准，若这个文件如果发生了改变，则Etag也会改变。服务器对比浏览器请求头中的的If-None-Match：如果相同就返回304，而不返回实际资源如果不同，就返回200和新的资源。</p> </td></tr></tbody></table> 
</blockquote> 
<ul><li> <h4 id="%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>观察者模式和发布-订阅模式的区别</strong></h4> </li></ul> 
<blockquote> 
 <p>1. 从定义上:</p> 
 <ul><li>观察者模式: 在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。</li><li>发布-订阅设计模式: 在发布-订阅模式，消息的发送方，叫做发布者，消息不会直接发送给特定的接收者，叫做订阅者。</li></ul> 
 <p>2. 区别:</p> 
 <ul><li>在观察者模式中，观察者知道被观察者，被观察者一直保持对观察者进行记录。在发布订阅模式中，发布者和订阅者不知道对方的存在, 它们只有通过消息代理进行通信•在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</li><li>观察者模式大多数时候是同步的，比如当事件触发，被观察者就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。</li><li>观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。</li></ul> 
</blockquote> 
<h3 id="%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" style="margin-left:0cm;">性能优化</h3> 
<blockquote> 
 <p style="margin-left:0cm;">1.压缩css,js,图片</p> 
 <p style="margin-left:0cm;">2.减少http请求次数，  合并css,js   合并图片（雪碧图）</p> 
 <p style="margin-left:0cm;">3.使用CDN</p> 
 <p style="margin-left:0cm;">4.减少dom元素数量</p> 
 <p style="margin-left:0cm;">5.图片懒加载</p> 
 <p style="margin-left:0cm;">6.静态资源另外用无cookie的域名</p> 
 <p style="margin-left:0cm;">7.减少dom的访问（缓存dom）</p> 
 <p style="margin-left:0cm;">8.巧用事件委托</p> 
 <p style="margin-left:0cm;">9.样式表置顶、脚本置底</p> 
</blockquote> 
<h3 id="%E5%85%B6%E4%BB%96" style="margin-left:0cm;">其他</h3> 
<blockquote> 
 <p>yran对比npm的优势</p> 
 <ul><li> <p><strong>并行安装</strong>：无论 <code>npm</code> 还是 <code>yarn</code> 在执行包的安装时，都会执行一系列任务。<code>npm</code> 是按照队列执行每个 <code>package</code>，也就是说必须要等到当前 <code>package</code> 安装完成之后，才能继续后面的安装。而 <code>yarn</code> 是同步执行所有任务，提高了性能。</p> </li><li> <p><strong>离线模式</strong>：如果之前已经安装过一个软件包，用 <code>yarn</code> 再次安装时之间从缓存中获取，就不用像 <code>npm</code> 那样再从网络下载了。</p> </li><li> <p><strong>安装版本统一</strong>：为了防止拉取到不同的版本，<code>yarn</code> 有一个锁定文件 (<code>lock file</code>) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，<code>yarn</code> 就会创建（或更新）<code>yarn.lock</code> 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。</p> </li><li> <p><strong>更好的语义化</strong>：<code>yarn</code> 改变了一些 <code>npm</code> 命令的名称，比如 <code>yarn add/remove</code>，比 <code>npm</code> 原本的 <code>install/uninstall</code> 要更清晰。</p> </li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/97e6b44967c382339f67936d3f9a5ec1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[Vue warn]: Error in render: “TypeError: Cannot read properties of undefined (reading ‘matched‘)“</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/005a55cc7854e4f61e61e5d5a768bcf5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp运行小程序教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>