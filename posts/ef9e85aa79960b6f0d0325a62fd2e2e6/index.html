<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ibatis 总结 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ibatis 总结" />
<meta property="og:description" content="SqlMap的配置是iBatis中应用的核心： 1、命名空间： &lt;sqlMap namespace=&#34;mune&#34;&gt;，在此空间外要引用此空间的元素，则需要加上命名空间名。 （在三层架构中一般在持久层调用的时候通过命名空间名访问） 2、实体的别名：&lt;typeAlias type=&#34;java.util.HashMap&#34; alias=&#34;hmap&#34;/&gt; 也可以是自己写的实体类 &lt;typeAlias alias=&#34;mune&#34; type=&#34;com.pur.mune&#34;/&gt; 3、SQL入参parameterClass 插入语句入参：parameterClass=&#34;类别名&#34; 来设定。 查询语句入参：可以设定类别名，也可以设定为map，也可以设定为iBatis支持的原生类型（比如string、int、long等），当只有一个原生类型入参时，则在SQL中用value关键字来引用。比如： &lt;select id=&#34;getById&#34; parameterClass=&#34;hamp“ resultMap=&#34;result_base&#34;&gt; select * from customer where id = #value# &lt;/select&gt; map是最强大的入参方式，任何入参方式都可以转换为这种入参方式，因为iBatis仅接受一个入参，当几个参数分布在不同对象中的时候，将这些对象的属性（或者对象本身put）到map中，然后一次传递给sql语句是非常有效。可以自己写一个将对象或者对象集合转换为map的工具（我已经实现一个了）。 另外，map的中的元素（比如pobj）是个复杂对象，则还可以在SQL中以#pobj.protyename#的格式来引用其中内嵌的属性。当然不推荐这么干。 4、返回值参数类型 返回值参数也同样有两种类型，一种是对象类型resultClass=&#34;Account&#34;，一种是resultMap=&#34;AccountResult&#34;。这两种类型的选择常常会令人迷惑不解，一言明其理：当结果集列名和类属性名完全对应的时候，则应该使用resultClass来指定查询结果类型。当然有些列明不对应，可以在sql中使用as重命名达到一致的效果。 当查询结果列名和类属性名对应不上的时候，应该选择resultMap指定查询结果集类型。否则，则查询出来填充的对象属性为空（数字的为0，对象的为null）。 但是实际上resultMap是对一个Java Bean的映射，需要先定义xml的映射后，才可以引用，例如： &lt;resultMap id=&#34;muneAccountResult&#34; class=&#34;mune&#34;&gt; &lt;result property=&#34;id&#34; column=&#34;ACC_ID&#34;/&gt; &lt;result property=&#34;firstName&#34; column=&#34;ACC_FIRST_NAME&#34;/&gt; &lt;result property=&#34;lastName&#34; column=&#34;ACC_LAST_NAME&#34;/&gt; &lt;result property=&#34;emailAddress&#34; column=&#34;ACC_EMAIL&#34;/&gt; &lt;/resultMap&gt; resultMap映射的结果的目的就是要将查询的结果集绑定到映射对象的属性上。 不管使用哪种返回值参数类型，其最终目的就是要把每条记录映射到一个类的对象或者对象集合上，如果有某个类属性映射不上，则在得到的这个对象或对象集合中这个属性为空。映射的属性可以是表与实体中的一部分。不要同时使用两种返回值参数类型，这样只会令人迷惑。 5、SQL中参数的引用 SQL中引用parameterClass的参数有三种方式： iBatis内置支持的类型，比如int、string，使用#value#来引用，这个value是关键字，不可变。 map类型的参数，使用#keyName#来引用，keyName为键名。 复杂对象的参数，使用#propertyName#来引用，propertyName类属性的名字。 6、模糊查询中参数的引用 模糊查询是针对字符串而言的，如果遇到两个单引号要包含一个参数，则不能再用#来引用变量了，而应该改为$，比如：&#39;%$varName$%&#39;，当然，也可以使用 &#39;%&#39; || #varname# || &#39;%&#39; 来绕过此问题。 7、SQL片段 可以通过&lt;sql id=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ef9e85aa79960b6f0d0325a62fd2e2e6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-07-26T10:43:28+08:00" />
<meta property="article:modified_time" content="2011-07-26T10:43:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ibatis 总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    SqlMap的配置是iBatis中应用的核心： 
<br> 
<br> 
<br>1、命名空间： &lt;sqlMap namespace="mune"&gt;，在此空间外要引用此空间的元素，则需要加上命名空间名。 （在三层架构中一般在持久层调用的时候通过命名空间名访问） 
<br> 
<br>2、实体的别名：&lt;typeAlias type="java.util.HashMap" alias="hmap"/&gt; 也可以是自己写的实体类 &lt;typeAlias alias="mune" type="com.pur.mune"/&gt; 
<br> 
<br>3、SQL入参parameterClass 插入语句入参：parameterClass="类别名" 来设定。 查询语句入参：可以设定类别名，也可以设定为map，也可以设定为iBatis支持的原生类型（比如string、int、long等），当只有一个原生类型入参时，则在SQL中用value关键字来引用。比如： &lt;select id="getById" parameterClass="hamp“ resultMap="result_base"&gt; 
<br> 
<br> select * from customer where id = #value# 
<br> 
<br> 
<br> &lt;/select&gt; map是最强大的入参方式，任何入参方式都可以转换为这种入参方式，因为iBatis仅接受一个入参，当几个参数分布在不同对象中的时候，将这些对象的属性（或者对象本身put）到map中，然后一次传递给sql语句是非常有效。可以自己写一个将对象或者对象集合转换为map的工具（我已经实现一个了）。 另外，map的中的元素（比如pobj）是个复杂对象，则还可以在SQL中以#pobj.protyename#的格式来引用其中内嵌的属性。当然不推荐这么干。 
<br> 
<br>4、返回值参数类型 返回值参数也同样有两种类型，一种是对象类型resultClass="Account"，一种是resultMap="AccountResult"。这两种类型的选择常常会令人迷惑不解，一言明其理：当结果集列名和类属性名完全对应的时候，则应该使用resultClass来指定查询结果类型。当然有些列明不对应，可以在sql中使用as重命名达到一致的效果。 当查询结果列名和类属性名对应不上的时候，应该选择resultMap指定查询结果集类型。否则，则查询出来填充的对象属性为空（数字的为0，对象的为null）。 但是实际上resultMap是对一个Java Bean的映射，需要先定义xml的映射后，才可以引用，例如： &lt;resultMap id="muneAccountResult" class="mune"&gt; 
<br> 
<br> &lt;result property="id" column="ACC_ID"/&gt; 
<br> &lt;result property="firstName" column="ACC_FIRST_NAME"/&gt; 
<br> &lt;result property="lastName" column="ACC_LAST_NAME"/&gt; 
<br> &lt;result property="emailAddress" column="ACC_EMAIL"/&gt; 
<br> 
<br> 
<br> &lt;/resultMap&gt; resultMap映射的结果的目的就是要将查询的结果集绑定到映射对象的属性上。 不管使用哪种返回值参数类型，其最终目的就是要把每条记录映射到一个类的对象或者对象集合上，如果有某个类属性映射不上，则在得到的这个对象或对象集合中这个属性为空。映射的属性可以是表与实体中的一部分。不要同时使用两种返回值参数类型，这样只会令人迷惑。 
<br> 
<br>5、SQL中参数的引用 SQL中引用parameterClass的参数有三种方式： iBatis内置支持的类型，比如int、string，使用#value#来引用，这个value是关键字，不可变。 map类型的参数，使用#keyName#来引用，keyName为键名。 复杂对象的参数，使用#propertyName#来引用，propertyName类属性的名字。 
<br> 
<br>6、模糊查询中参数的引用 模糊查询是针对字符串而言的，如果遇到两个单引号要包含一个参数，则不能再用#来引用变量了，而应该改为$，比如：'%$varName$%'，当然，也可以使用 '%' || #varname# || '%' 来绕过此问题。 
<br> 
<br>7、SQL片段 可以通过&lt;sql id="sql_xxx"&gt;...&lt;/sql&gt;定义SQL片段，然后&lt;include refid="sql_xxx"/&gt;来在各种语句中引用。达到服用目的， 
<br> 
<br>8、动态SQL 可以通过使用动态SQL来组织灵活性更大的更通过的SQL，这样极大减少了编码量，是iBatis应用的第二大亮点。 比如：一个动态的where条件 &lt;dynamic prepend="where"&gt; 
<br> 
<br> &lt;isNotEmpty prepend="and" property="$$$$$"&gt; 
<br> $name like '%'|| #$name# ||'%' 
<br> &lt;/isNotEmpty&gt; 
<br> &lt;isGreaterThan prepend="and" property="$$$$$" compareValue="$$$number"&gt; 
<br> $code like '%'|| #$code# ||'%' 
<br> &lt;/isGreaterThan&gt; 
<br> 
<br> 
<br> &lt;/dynamic&gt; 当然，prepend表示链接关键字，可以为任何字符串，当为sql关键字时，iBatis自动判断是否应该添加该关键字。该语法也很简单，关键是要会用心思考组织动态SQL。 这里面有一点要注意：区别&lt;isNotEmpty&gt;和&lt;isNotNull&gt;区别，当为空空串时&lt;isNotEmpty&gt;返回true，当为空串时&lt;isNotNull&gt;返回真。
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7e88a7a3c687122ce9b694cd3ce89162/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JDBC的单例模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7761e69bac4f0c51ebacfd7fba5cde18/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">appfuse 2.0.2 在eclipse 上的配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>