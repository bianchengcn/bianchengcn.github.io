<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CVE-2021-26411在野样本中利用RPC绕过CFG缓解技术的研究 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CVE-2021-26411在野样本中利用RPC绕过CFG缓解技术的研究" />
<meta property="og:description" content="浏览器渲染进程漏洞利用的一般思路是：在利用漏洞获得用户态任意地址读写权限后，通过篡改DOM、js等对象的虚表函数指针劫持程序执行流，通过ROP链调用VirtualProtect等Win32
API，修改保存shellcode
buffer的内存属性为PAGE_EXECUTE_READWRITE，最终由ROP链跳转到shellcode执行。Windows
8.1后，Microsoft引入了CFG（Control Flow
Guard）缓解技术[1]，对间接调用的函数指针进行验证，从而缓解了通过篡改虚表函数指针劫持程序执行流这种利用技术。
然而对抗不会因此终止，随后出现了一些绕过CFG缓解技术的新方法，比如chakra/jscript9中通过篡改栈上函数返回地址劫持程序执行流[2]，v8中利用具有可执行内存属性的WebAssembly对象执行shellcode[3]等。
2020年12月，Microsoft在Windows 10 20H1中基于Intel Tiger Lake
CPU加入了CET缓解技术[4]，防护了通过篡改栈上函数返回地址劫持程序执行流的利用方法。因此，如何在有CET防护的环境中绕过CFG再次成为漏洞利用的难题。
在分析CVE-2021-26411在野利用样本时[5]，我们发现了一种利用Windows RPC（Remote Procedure
Call）[5]绕过CFG的新方法，这种方法无需依赖ROP链，通过构造RPC_MESSAGE并调用rpcrt4!NdrServerCall2即可实现任意代码执行。
##** 1. CVE** ** -2021-26411** ** 回顾**
《IE浏览器在野0day：CVE-2021-26411分析》[5]
一文中介绍了该漏洞的根因：removeAttributeNode()触发属性对象nodeValue的valueOf回调，回调期间手动调用clearAttributes()，导致nodeValue保存的BSTR被提前释放。回调返回后，没有检查nodeValue是否存在继续使用该对象，最终导致UAF。
3月份Windows补丁中该漏洞的修复方法为，在CAttrArray::Destroy函数中删除对象操作前增加索引检查：
对于这样一个大小可控的UAF漏洞，利用思路为：利用两个不同类型的指针（BSTR和Dictionary.items）指向该空洞内存，通过类型混淆实现指针泄露和指针解引用：
##** 2. RPC原理** ** 及利用方法**
Windows RPC用来解决分布式客户端/服务端函数调用问题。基于RPC，客户端可以像调用本地函数一样调用服务端函数，RPC基本架构如下图：
客户端/服务端程序将调用参数/返回值等传给下层Stub函数，Stub函数负责封装数据成NDR（Network Data
Representation）格式，最后通过rpcrt4.dll提供的runtime库进行通信。
下面给出一示例idl：
当客户端调用add函数后，服务端由rpcrt4.dll接受处理请求并调用rpcrt4!NdrServerCall2：
rpcrt4!NdrServerCall2只有一个参数PRPC_MESSAGE，其中包含了客户端调用的函数索引、传参等重要数据，服务端RPC_MESSAGE结构及主要子数据结构如下图（32位）：
如上图所示，RPC_MESSAGE结构中，函数调用关键的两个变量为Buffer和RpcInterfaceInformation。其中Buffer存放了函数的传参，RpcInterfaceInformation指向RPC_SERVER_INTERFACE结构。RPC_SERVER_INTERFACE结构保存了服务端程序接口信息，其中&#43;0x2c
DispatchTable保存了runtime库和Stub函数的接口函数指针，&#43;0x3c
InterpreterInfo指向MIDL_SERVER_INFO结构。MIDL_SERVER_INFO结构保存了服务端IDL接口信息，其中DispatchTable保存了服务端提供的远程调用例程的函数指针数组。
下面以一个实例介绍RPC_MESSAGE的结构：
根据上面给出的idl，当客户端调用add(0x111, 0x222)，服务端程序断在rpcrt4!NdrServerCall2：
可以看到，动态调试的内存dump与RPC_MESSAGE结构分析一致，其中add函数就存放在MIDL_SERVER_INFO.
DispatchTable中。
接下来分析rpcrt4!NdrServerCall2是如何根据RPC_MESSAGE调用add函数的：
rpcrt4!NdrServerCall2内部调用rpcrt4!NdrStubCall2，rpcrt4!NdrStubCall2内部根据MIDL_SERVER_INFO.
DispatchTable的基地址和RPC_MESSAGE.
ProcNum计算调用的函数指针地址，将函数指针、函数参数和参数长度传给rpcrt4!Invoke：
rpcrt4!Invoke内部最终调用服务端例程函数：
通过上面的分析可以知道，在获得任意地址读写权限后，可以构造一个RPC_MESSAGE数据结构，传入想要调用的函数指针和函数参数，最后手动调用rpcrt4!NdrServerCall2，即可实现任意函数执行。
接下来需要解决两个问题：
1）如何通过js脚本调用rpcrt4! NdrServerCall2
2）观察rpcrt4!Invoke最后的服务端例程函数调用：
可以看到这里是一处间接调用，且有CFG检查。因此需要考虑替换MIDL_SERVER_INFO.
DispatchTable函数指针后如何绕过这里的CFG防护。
首先解决问题1: 如何通过js脚本调用rpcrt4! NdrServerCall2
这里可以复用替换DOM对象虚表函数指针劫持程序执行流的方法，因为rpcrt4!NdrServerCall2是记录在CFGBitmap里的合法指针，所以替换后依然可以通过CFG检查。样本里通过篡改MSHTML!CAttribute::normalize，最终由“xyz.normalize()”调用rpcrt4!NdrServerCall2。
接着解决问题2: 如何绕过rpcrt4!NdrServerCall2中的CFG防护
样本里的思路是:
利用伪造的RPC_MESSAGE和rpcrt4!NdrServerCall2调用VirtualProtect修改RPCRT4!__guard_check_icall_fptr内存属性为PAGE_EXECUTE_READWRITE" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/64e9328b8b7b666568ebab152510c244/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-10T22:26:12+08:00" />
<meta property="article:modified_time" content="2023-08-10T22:26:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CVE-2021-26411在野样本中利用RPC绕过CFG缓解技术的研究</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>浏览器渲染进程漏洞利用的一般思路是：在利用漏洞获得用户态任意地址读写权限后，通过篡改DOM、js等对象的虚表函数指针劫持程序执行流，通过ROP链调用VirtualProtect等Win32<br> API，修改保存shellcode<br> buffer的内存属性为PAGE_EXECUTE_READWRITE，最终由ROP链跳转到shellcode执行。Windows<br> 8.1后，Microsoft引入了CFG（Control Flow<br> Guard）缓解技术[1]，对间接调用的函数指针进行验证，从而缓解了通过篡改虚表函数指针劫持程序执行流这种利用技术。</p> 
<p>然而对抗不会因此终止，随后出现了一些绕过CFG缓解技术的新方法，比如chakra/jscript9中通过篡改栈上函数返回地址劫持程序执行流[2]，v8中利用具有可执行内存属性的WebAssembly对象执行shellcode[3]等。<br> 2020年12月，Microsoft在Windows 10 20H1中基于Intel Tiger Lake<br> CPU加入了CET缓解技术[4]，防护了通过篡改栈上函数返回地址劫持程序执行流的利用方法。因此，如何在有CET防护的环境中绕过CFG再次成为漏洞利用的难题。</p> 
<p>在分析CVE-2021-26411在野利用样本时[5]，我们发现了一种利用Windows RPC（Remote Procedure<br> Call）[5]绕过CFG的新方法，这种方法无需依赖ROP链，通过构造RPC_MESSAGE并调用rpcrt4!NdrServerCall2即可实现任意代码执行。</p> 
<p>##** <strong>1. CVE</strong>** ** <strong>-2021-26411</strong>** ** <strong>回顾</strong>**</p> 
<p>《IE浏览器在野0day：CVE-2021-26411分析》[5]<br> 一文中介绍了该漏洞的根因：removeAttributeNode()触发属性对象nodeValue的valueOf回调，回调期间手动调用clearAttributes()，导致nodeValue保存的BSTR被提前释放。回调返回后，没有检查nodeValue是否存在继续使用该对象，最终导致UAF。</p> 
<p>3月份Windows补丁中该漏洞的修复方法为，在CAttrArray::Destroy函数中删除对象操作前增加索引检查：</p> 
<p><img src="https://images2.imgbox.com/49/f4/6pj5Fbx1_o.jpg" alt=""></p> 
<p>对于这样一个大小可控的UAF漏洞，利用思路为：利用两个不同类型的指针（BSTR和Dictionary.items）指向该空洞内存，通过类型混淆实现指针泄露和指针解引用：</p> 
<p><img src="https://images2.imgbox.com/50/de/SNTo19XZ_o.jpg" alt=""></p> 
<p>##** <strong>2. RPC原理</strong>** ** <strong>及利用方法</strong>**</p> 
<p>Windows RPC用来解决分布式客户端/服务端函数调用问题。基于RPC，客户端可以像调用本地函数一样调用服务端函数，RPC基本架构如下图：</p> 
<p><img src="https://images2.imgbox.com/0d/2c/FfWWj7l9_o.jpg" alt=""></p> 
<p>客户端/服务端程序将调用参数/返回值等传给下层Stub函数，Stub函数负责封装数据成NDR（Network Data<br> Representation）格式，最后通过rpcrt4.dll提供的runtime库进行通信。</p> 
<p>下面给出一示例idl：</p> 
<p><img src="https://images2.imgbox.com/69/6d/n1YDXgLr_o.jpg" alt=""></p> 
<p>当客户端调用add函数后，服务端由rpcrt4.dll接受处理请求并调用rpcrt4!NdrServerCall2：</p> 
<p><img src="https://images2.imgbox.com/56/f4/9b9oJ87K_o.jpg" alt=""></p> 
<p>rpcrt4!NdrServerCall2只有一个参数PRPC_MESSAGE，其中包含了客户端调用的函数索引、传参等重要数据，服务端RPC_MESSAGE结构及主要子数据结构如下图（32位）：</p> 
<p><img src="https://images2.imgbox.com/e5/0f/yEtVxaig_o.jpg" alt=""></p> 
<p>如上图所示，RPC_MESSAGE结构中，函数调用关键的两个变量为Buffer和RpcInterfaceInformation。其中Buffer存放了函数的传参，RpcInterfaceInformation指向RPC_SERVER_INTERFACE结构。RPC_SERVER_INTERFACE结构保存了服务端程序接口信息，其中+0x2c<br> DispatchTable保存了runtime库和Stub函数的接口函数指针，+0x3c<br> InterpreterInfo指向MIDL_SERVER_INFO结构。MIDL_SERVER_INFO结构保存了服务端IDL接口信息，其中DispatchTable保存了服务端提供的远程调用例程的函数指针数组。</p> 
<p>下面以一个实例介绍RPC_MESSAGE的结构：</p> 
<p>根据上面给出的idl，当客户端调用add(0x111, 0x222)，服务端程序断在rpcrt4!NdrServerCall2：</p> 
<p><img src="https://images2.imgbox.com/a7/25/pfheJETk_o.jpg" alt=""></p> 
<p>可以看到，动态调试的内存dump与RPC_MESSAGE结构分析一致，其中add函数就存放在MIDL_SERVER_INFO.<br> DispatchTable中。</p> 
<p>接下来分析rpcrt4!NdrServerCall2是如何根据RPC_MESSAGE调用add函数的：</p> 
<p>rpcrt4!NdrServerCall2内部调用rpcrt4!NdrStubCall2，rpcrt4!NdrStubCall2内部根据MIDL_SERVER_INFO.<br> DispatchTable的基地址和RPC_MESSAGE.<br> ProcNum计算调用的函数指针地址，将函数指针、函数参数和参数长度传给rpcrt4!Invoke：</p> 
<p><img src="https://images2.imgbox.com/ea/f0/1lhjkuiu_o.jpg" alt=""></p> 
<p>rpcrt4!Invoke内部最终调用服务端例程函数：</p> 
<p><img src="https://images2.imgbox.com/91/4d/ArYJyGSC_o.jpg" alt=""></p> 
<p>通过上面的分析可以知道，在获得任意地址读写权限后，可以构造一个RPC_MESSAGE数据结构，传入想要调用的函数指针和函数参数，最后手动调用rpcrt4!NdrServerCall2，即可实现任意函数执行。</p> 
<p>接下来需要解决两个问题：</p> 
<p>1）如何通过js脚本调用rpcrt4! NdrServerCall2</p> 
<p>2）观察rpcrt4!Invoke最后的服务端例程函数调用：</p> 
<p><img src="https://images2.imgbox.com/a1/6b/Xu9AYdyG_o.jpg" alt=""></p> 
<p>可以看到这里是一处间接调用，且有CFG检查。因此需要考虑替换MIDL_SERVER_INFO.<br> DispatchTable函数指针后如何绕过这里的CFG防护。</p> 
<p>首先解决问题1: 如何通过js脚本调用rpcrt4! NdrServerCall2</p> 
<p>这里可以复用替换DOM对象虚表函数指针劫持程序执行流的方法，因为rpcrt4!NdrServerCall2是记录在CFGBitmap里的合法指针，所以替换后依然可以通过CFG检查。样本里通过篡改MSHTML!CAttribute::normalize，最终由“xyz.normalize()”调用rpcrt4!NdrServerCall2。</p> 
<p>接着解决问题2: 如何绕过rpcrt4!NdrServerCall2中的CFG防护</p> 
<p>样本里的思路是:</p> 
<blockquote> 
 <ol><li></ol> 
 <p>利用伪造的RPC_MESSAGE和rpcrt4!NdrServerCall2调用VirtualProtect修改RPCRT4!__guard_check_icall_fptr内存属性为PAGE_EXECUTE_READWRITE</p> 
 <p>2)替换rpcrt4!__guard_check_icall_fptr里保存的指针ntdll!LdrpValidateUserCallTarget为ntdll!KiFastSystemCallRet，从而关闭rpcrt4的CFG检查</p> 
 <ol start="3"><li>恢复RPCRT4!__guard_check_icall_fptr内存属性</li></ol> 
</blockquote> 
<p>解决了问题1，2后，后续即可利用伪造的RPC_MESSAGE实现任意函数的调用。样本中将shellcode写入msi.dll +<br> 0x5000的位置，最终通过rpcrt4!NdrServerCall2调用shellcode:</p> 
<p><img src="https://images2.imgbox.com/7e/7b/ziKvSUlJ_o.jpg" alt=""></p> 
<p>最终完整的利用演示：</p> 
<p><img src="https://images2.imgbox.com/97/c4/9g5VMWTc_o.jpg" alt=""></p> 
<p>##** <strong>一些思考</strong>**</p> 
<p>CVE-2021-26411在野样本中出现了利用RPC绕过CFG缓解技术的这一创新方法。这种利用方法无需构造ROP链，直接通过伪造RPC_MESSAGE即可实现任意代码执行，利用简单且稳定，有理由相信该方法会成为绕过CFG缓解措施的一种新的有效利用技术。</p> 
<p>##** <strong>参考文献</strong>**</p> 
<p>[1] https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard</p> 
<p>[2] https://zhuanlan.kanxue.com/article-14133.htm</p> 
<p>[3] https://www.anquanke.com/post/id/201951</p> 
<p>[4] https://windows-internals.com/cet-on-windows/</p> 
<p>[5]<br> https://mp.weixin.qq.com/s?__biz=MzI4NjE2NjgxMQ==&amp;mid=2650250070&amp;idx=1&amp;sn=5906feea0cfe498bffbb961e73f5c285</p> 
<p>[6] https://docs.microsoft.com/en-us/windows/win32/rpc/rpc-start-page</p> 
<p>##** <strong>团队简介</strong>**</p> 
<p>深信服南研安全研究团队专注于APT攻击，在野漏洞利用追踪、研究、检测，攻防对抗等方向的研究工作。团队成员曾在Windows，MacOS/iOS，Linux/Android等主流操作系统中发现了上百个安全漏洞，在BlackHat<br> USA、BlackHat Europe、BlackHat Asia、HITB、Microsoft BlueHat、CodeBlue、HITCON、Virus<br> Bulletin、Pacsec、看雪SDC、FreeBuf CIS等国内外知名安全会议上发表过演讲和论文。</p> 
<p>SA、BlackHat Europe、BlackHat Asia、HITB、Microsoft BlueHat、CodeBlue、HITCON、Virus<br> Bulletin、Pacsec、看雪SDC、FreeBuf CIS等国内外知名安全会议上发表过演讲和论文。</p> 
<h3><a id="_139"></a>最后</h3> 
<p>分享一个快速学习【网络安全】的方法，「也许是」最全面的学习方法：<br> <strong>1、网络安全理论知识（2天）</strong><br> ①了解行业相关背景，前景，确定发展方向。<br> ②学习网络安全相关法律法规。<br> ③网络安全运营的概念。<br> ④等保简介、等保规定、流程和规范。（非常重要）</p> 
<p><strong>2、渗透测试基础（一周）</strong><br> ①渗透测试的流程、分类、标准<br> ②信息收集技术：主动/被动信息搜集、Nmap工具、Google Hacking<br> ③漏洞扫描、漏洞利用、原理，利用方法、工具（MSF）、绕过IDS和反病毒侦察<br> ④主机攻防演练：MS17-010、MS08-067、MS10-046、MS12-20等</p> 
<p><strong>3、操作系统基础（一周）</strong><br> ①Windows系统常见功能和命令<br> ②Kali Linux系统常见功能和命令<br> ③操作系统安全（系统入侵排查/系统加固基础）</p> 
<p><strong>4、计算机网络基础（一周）</strong><br> ①计算机网络基础、协议和架构<br> ②网络通信原理、OSI模型、数据转发流程<br> ③常见协议解析（HTTP、TCP/IP、ARP等）<br> ④网络攻击技术与网络安全防御技术<br> ⑤Web漏洞原理与防御：主动/被动攻击、DDOS攻击、CVE漏洞复现</p> 
<p><strong>5、数据库基础操作（2天）</strong><br> ①数据库基础<br> ②SQL语言基础<br> ③数据库安全加固</p> 
<p><strong>6、Web渗透（1周）</strong><br> ①HTML、CSS和JavaScript简介<br> ②OWASP Top10<br> ③Web漏洞扫描工具<br> ④Web渗透工具：Nmap、BurpSuite、SQLMap、其他（菜刀、漏扫等）</p> 
<p><img src="https://images2.imgbox.com/a0/27/oWM717Hc_o.png" alt="在这里插入图片描述"></p> 
<p>恭喜你，如果学到这里，你基本可以从事一份网络安全相关的工作，比如渗透测试、Web 渗透、安全服务、安全分析等岗位；如果等保模块学的好，还可以从事等保工程师。薪资区间6k-15k。</p> 
<p>到此为止，大概1个月的时间。你已经成为了一名“脚本小子”。那么你还想往下探索吗？</p> 
<p>想要入坑黑客&amp;网络安全的朋友，给大家准备了一份：282G全网最全的网络安全资料包免费领取！<br> <strong>点【文末卡片】，免费领取</strong></p> 
<p>有了这些基础，如果你要深入学习，可以参考下方这个超详细学习路线图，按照这个路线学习，完全够支撑你成为一名优秀的中高级网络安全工程师：<br> <img src="https://images2.imgbox.com/db/fb/9FibIKdk_o.png" alt=""></p> 
<p><strong>[高清学习路线图或XMIND文件（点击文末卡片领取）]</strong></p> 
<p><strong>还有一些学习中收集的视频、文档资源，有需要的可以自取：</strong><br> 每个成长路线对应板块的配套视频：<br> <img src="https://images2.imgbox.com/17/23/C3SNM2FG_o.png" alt=""><br> <img src="https://images2.imgbox.com/f4/15/noCBu7FB_o.png" alt=""><br> 当然除了有配套的视频，同时也为大家整理了各种文档和书籍资料&amp;工具，并且已经帮大家分好类了。<br> <img src="https://images2.imgbox.com/f0/80/Kr5XReN2_o.png" alt=""><br> <strong>因篇幅有限，仅展示部分资料，需要的可以【点下方卡片免费领取】</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/48df707e0da83d033a294e16c13c0e96/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Gitee 产品配额说明，仓库容量与大小</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2201404eafae4955ddf20065205f0f8c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">宿主机无法ping通docker容器IP解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>