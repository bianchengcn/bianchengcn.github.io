<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>每日一题 力扣2865 美丽塔Ⅰ - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="每日一题 力扣2865 美丽塔Ⅰ" />
<meta property="og:description" content="2865. 美丽塔 I 题目描述： 给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。
你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。
如果以下条件满足，我们称这些塔是 美丽 的：
1 &lt;= heights[i] &lt;= maxHeights[i]heights 是一个 山脉 数组。 如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：
对于所有 0 &lt; j &lt;= i ，都有 heights[j - 1] &lt;= heights[j]对于所有 i &lt;= k &lt; n - 1 ，都有 heights[k &#43; 1] &lt;= heights[k] 请你返回满足 美丽塔 要求的方案中，高度和的最大值 。
示例 1：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/cf1566b03e5f91a4eb48709ebeb0e674/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-24T14:23:48+08:00" />
<meta property="article:modified_time" content="2024-01-24T14:23:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">每日一题 力扣2865 美丽塔Ⅰ</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a href="https://leetcode.cn/problems/beautiful-towers-i/" rel="nofollow" title="2865. 美丽塔 I">2865. 美丽塔 I</a></h2> 
<h2>题目描述：</h2> 
<p>给你一个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的整数数组 <code>maxHeights</code> 。</p> 
<p>你的任务是在坐标轴上建 <code>n</code> 座塔。第 <code>i</code> 座塔的下标为 <code>i</code> ，高度为 <code>heights[i]</code> 。</p> 
<p>如果以下条件满足，我们称这些塔是 <strong>美丽</strong> 的：</p> 
<ol><li><code>1 &lt;= heights[i] &lt;= maxHeights[i]</code></li><li><code>heights</code> 是一个 <strong>山脉</strong> 数组。</li></ol> 
<p>如果存在下标 <code>i</code> 满足以下条件，那么我们称数组 <code>heights</code> 是一个 <strong>山脉</strong> 数组：</p> 
<ul><li>对于所有 <code>0 &lt; j &lt;= i</code> ，都有 <code>heights[j - 1] &lt;= heights[j]</code></li><li>对于所有 <code>i &lt;= k &lt; n - 1</code> ，都有 <code>heights[k + 1] &lt;= heights[k]</code></li></ul> 
<p>请你返回满足 <strong>美丽塔</strong> 要求的方案中，<strong>高度和的最大值</strong> 。</p> 
<blockquote> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>maxHeights = [5,3,4,1,1]
<strong>输出：</strong>13
<strong>解释：</strong>和最大的美丽塔方案为 heights = [5,3,3,1,1] ，这是一个美丽塔方案，因为：
- 1 &lt;= heights[i] &lt;= maxHeights[i]  
- heights 是个山脉数组，峰值在 i = 0 处。
13 是所有美丽塔方案中的最大高度和。</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>maxHeights = [6,5,3,9,2,7]
<strong>输出：</strong>22
<strong>解释：</strong> 和最大的美丽塔方案为 heights = [3,3,3,9,2,2] ，这是一个美丽塔方案，因为：
- 1 &lt;= heights[i] &lt;= maxHeights[i]
- heights 是个山脉数组，峰值在 i = 3 处。
22 是所有美丽塔方案中的最大高度和。</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>maxHeights = [3,2,5,5,2,3]
<strong>输出：</strong>18
<strong>解释：</strong>和最大的美丽塔方案为 heights = [2,2,5,5,2,2] ，这是一个美丽塔方案，因为：
- 1 &lt;= heights[i] &lt;= maxHeights[i]
- heights 是个山脉数组，最大值在 i = 2 处。
注意，在这个方案中，i = 3 也是一个峰值。
18 是所有美丽塔方案中的最大高度和。
</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= n == maxHeights &lt;= 10^3</code></li><li><code>1 &lt;= maxHeights[i] &lt;= 10^9</code></li></ul> 
</blockquote> 
<h2>思路：</h2> 
<p>尝试：贪心，先要找出可以放的最高的位置（可能不止一个）；<br> 然后以当前位置为界，向两边遍历，每次遍历需要更新两个内容：<br> 1.如果当前高度和大于目前最大高度和，更换之<br> 2.如果当前遍历位置小于本循环内目前最大限高，把限高换成小的。</p> 
<h2>代码：</h2> 
<p>有点问题，待改进</p> 
<pre><code>class Solution:
    def maximumSumOfHeights(self, maxHeights: List[int]) -&gt; int:
        max_h = max(maxHeights)
        hill=maxHeights.index(max_h)#这是山峰位置
        i,j=hill-1,hill+1
        max_left,max_left_now=0,0
        max_right,max_right_now=0,0#右侧最大和，以及目前高度
        height_left,height_right=hill,hill#限高
        while(i&gt;=0):#往左遍历
            max_left+=min(height_left,maxHeights[i])#左侧高度和
            height_left=min(height_left,maxHeights[i])
            i-=1
       
        while j &lt; len(maxHeights) :
            max_right+=min(height_right,maxHeights[j])#右侧高度和
            height_right=min(height_right,maxHeights[j])
            j+=1
        
        return max_h+max_left+max_right
           
</code></pre> 
<p>问题在于，当峰值不唯一时存在问题，因此还是要按照遍历的方式，双重循环去做；或者想办法，找出所有的峰值点，然后依次进行遍历，对每次遍历得到的最大高度进行比较。</p> 
<p>换一个：</p> 
<pre><code>class Solution:
    def maximumSumOfHeights(self, maxHeights: List[int]) -&gt; int:
        n = len(maxHeights)
        res = 0
        for i in range(n):
            pre, psum = maxHeights[i], maxHeights[i]
            for j in range(i - 1, -1, -1):
                pre = min(pre, maxHeights[j])
                psum += pre
            suf = maxHeights[i]
            for j in range(i + 1, n):
                suf = min(suf, maxHeights[j])
                psum += suf
            res = max(res, psum)
        return res

</code></pre> 
<p>其他思路：单调栈的思路</p> 
<p>暴力法的思路是从山峰向两侧去构造一个高度之和最大的山脉数组，那么我们能否实现一个从两侧向山峰去构造这个高度之和最大的山脉数组呢？</p> 
<blockquote> 
 <p>不妨先考虑构造山峰的左侧，我们自左向右遍历 maxHeights[]，对于 nums[i]：<br> 若maxHights[i]&gt;=nums[i-1]，则 nums[i] 最高可以取到 maxHeights[i]，为了使得高度之和最大，我们不妨贪心的就先令 nums[i]=maxHights[i]<br> 否则，说明 nums[i-1] 太高了，为了使得高度之和最大，我们不妨贪心的令 nums[i-1] = maxHights[i]。同样的，当 nums[i-1] 的高度发生变化后，我们还要继续去判断 nums[i-2] nums[i-3] , ... 的高度是否需要变化<br> 从上述分析中不难看出，在我们自左向右构造山峰的左侧时，需要经常出现 「回退」，因此这里我们可以考虑用一个栈来辅助实现这一过程：</p> 
 <p>初始时向栈中添加 0 作为边界条件<br> 如果 maxHeights[i]&gt;= 栈顶元素，则说明我们可以直接令 nums[i] 为 maxHights[i]<br> 否则我们需要回去修改之前的高度，不断弹出栈中的元素，直至 maxHights[i]&gt;= 栈顶元素<br> 当遍历到 i 后，我们便构造出了山脉的左侧</p> 
 <p>显然根据上述的思路，如果我们在 i 的基础上继续遍历到 i+1，就可以构造出以 i+1 为山峰的山脉数组的左侧，因此这启发我们用两个数组 pre,suf 来分别记录以 i 为山峰时的左右两侧的高度之和（pre[i]=sum{nums[0:i]},suf[i]=sum{nums[i:n-1]}）。这样之后只要再遍历一次，取最大的 pre[i]+suf[i]-maxHights[i] 即可。</p> 
</blockquote> 
<pre><code>class Solution {
    typedef pair&lt;size_t,int&gt; PSI;
public:
    long long maximumSumOfHeights(vector&lt;int&gt;&amp; maxHeights) {
        const size_t n = maxHeights.size();
        stack&lt;PSI&gt; st;
        st.emplace(-1, 0);    // 哨兵
        vector&lt;long long&gt; mark(n);
        long long sum = 0;
        for( size_t i = 0; i &lt; n; ++i ) {
            while( st.top().second &gt; maxHeights[i] ) {
                auto [j,h] = st.top();
                st.pop();
                sum -= (h-maxHeights[i])*(j-st.top().first);
            }
            st.emplace(i, maxHeights[i]);
            mark[i] = sum;
            sum += maxHeights[i];
        }

        st = stack&lt;PSI&gt;();
        st.emplace(n, 0);       // 哨兵
        sum = 0;
        long long ans = 0;
        for( int i = n-1; i &gt;= 0; --i ) {
            while( st.top().second &gt; maxHeights[i] ) {
                auto [j,h] = st.top();
                st.pop();
                sum -= (h-maxHeights[i])*(st.top().first-j);
            }
            st.emplace(i, maxHeights[i]);
            sum += maxHeights[i];
            ans = max(ans, sum+mark[i]);
        }
        return ans;
    }
};</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b4966443e96c4f3e7e88475b5c16d783/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">el-tabs切换el-table多级表头清空sort排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6b1b388b7dd62442f1b9bd40be298566/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小程序系列--12使用 npm 包</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>