<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Makefile学习7 - 静态模式规则与动态库编译 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Makefile学习7 - 静态模式规则与动态库编译" />
<meta property="og:description" content="一. 前言 本文以一个动态库编译的Makefile作为实例，讲解make中的静态模式规则的使用，加深对Makefile全方面的学习，达到学以致用的目的。
二. 静态模式规则 1. 语法
TARGETS ...: TARGET-PATTERN: PREREQ-PATTERNS ... COMMANDS ... 从上面的语法规则可以看出，静态模式规则包含三部分：TARGETS，TARGET-PATTERN和PREREQ-PATTERNS。
TARGETS：列出此规则的一系列目标文件，可以包含通配符。
TARGET-PATTERN：目标模式。一般会包含&#34;%&#34;，其中&#34;%&#34;可以匹配目标文件中的任何部分，匹配的部分称为&#34;茎&#34;，此外，目标文件和目标模式的其余部分必须精确的匹配，例如：
目标文件：foo.o
目标模式：%.o
茎：foo -&gt; 模式符合
目标文件：foo.c
目标模式：%.o
茎：无 -&gt; 模式不符合
PREREQ-PATTERNS：依赖模式。每个目标的依赖文件使用目标模式的&#34;茎&#34;代替依赖模式中的&#34;%&#34;而得到。举例如下：
目标文件：foo.o
目标模式：%.o
目标依赖：%.c
根据目标文件foo.o和目标依赖%.o，由上面介绍可以得出，&#34;茎&#34;是&#34;foo&#34;，所以目标依赖%.c中%可以替换为foo，所以目标依赖就是foo.c了。
2. 举例
objects = foo.o bar.o all: $(objects) $(objects): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 根据上面语法的解释可知：该Makefile的目标文件是foo.o bar.o，目标模式是%.o，目标依赖是%.c。根据目标文件和目标模式，得出&#34;茎&#34;是foo和bar，所以目标模式时foo.o和bar.o，目标依赖是foo.c和bar.c。所以，相当于如下规则：
foo.o : foo.c $(CC) -c $(CFLAGS) foo.c -o foo.o bar.o : bar.c $(CC) -c $(CFLAGS) bar.c -o bar.o 二." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/9c9f3cbdf3f176370de7aafe8b4e6fd0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-20T23:17:20+08:00" />
<meta property="article:modified_time" content="2023-07-20T23:17:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Makefile学习7 - 静态模式规则与动态库编译</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一. 前言</h4> 
<p>        本文以一个动态库编译的Makefile作为实例，讲解make中的静态模式规则的使用，加深对Makefile全方面的学习，达到学以致用的目的。</p> 
<p></p> 
<h4>二. 静态模式规则</h4> 
<p><span style="color:#1a439c;"><strong>1. 语法</strong></span></p> 
<pre><code class="hljs">TARGETS ...: TARGET-PATTERN: PREREQ-PATTERNS ...
    COMMANDS
    ...</code></pre> 
<p>        从上面的语法规则可以看出，静态模式规则包含三部分：<span style="color:#fe2c24;">TARGETS</span>，<span style="color:#fe2c24;">TARGET-PATTERN</span>和<span style="color:#fe2c24;">PREREQ-PATTERNS</span>。</p> 
<p><span style="color:#fe2c24;">TARGETS</span>：列出此规则的一系列<span style="color:#fe2c24;">目标文件</span>，可以包含通配符。</p> 
<p><span style="color:#fe2c24;">TARGET-PATTERN</span>：目标模式。一般会包含"%"，其中"%"可以匹配目标文件中的任何部分，匹配的部分称为"茎"，此外，目标文件和目标模式的其余部分必须精确的匹配，例如：</p> 
<blockquote> 
 <p>目标文件：foo.<span style="color:#fe2c24;">o</span></p> 
 <p>目标模式：%.<span style="color:#fe2c24;">o</span></p> 
 <p>茎：foo      -&gt; <span style="color:#fe2c24;">模式符合</span></p> 
 <p></p> 
 <p>目标文件：foo.<span style="color:#fe2c24;">c</span></p> 
 <p>目标模式：%.<span style="color:#fe2c24;">o</span></p> 
 <p>茎：无       -&gt; <span style="color:#fe2c24;">模式不符合</span></p> 
</blockquote> 
<p><span style="color:#fe2c24;">PREREQ-PATTERNS</span>：依赖模式。每个目标的依赖文件使用目标模式的"茎"代替依赖模式中的"%"而得到。举例如下：</p> 
<blockquote> 
 <p>目标文件：foo.o</p> 
 <p>目标模式：%.o</p> 
 <p>目标依赖：%.c</p> 
</blockquote> 
<p>        根据目标文件foo.o和目标依赖%.o，由上面介绍可以得出，"茎"是"foo"，所以目标依赖%.c中%可以替换为foo，所以目标依赖就是foo.c了。</p> 
<p><strong><span style="color:#1a439c;">2. 举例</span></strong></p> 
<pre><code class="hljs">objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
	$(CC) -c $(CFLAGS) $&lt; -o $@</code></pre> 
<p>        根据上面语法的解释可知：该Makefile的<span style="color:#fe2c24;">目标文件</span>是foo.o bar.o，<span style="color:#fe2c24;">目标模式</span>是%.o，<span style="color:#fe2c24;">目标依赖</span>是%.c。根据目标文件和目标模式，得出"茎"是foo和bar，所以目标模式时foo.o和bar.o，目标依赖是foo.c和bar.c。所以，相当于如下规则：</p> 
<pre><code class="hljs">foo.o : foo.c
	$(CC) -c $(CFLAGS) foo.c -o foo.o
	
bar.o : bar.c
	$(CC) -c $(CFLAGS) bar.c -o bar.o</code></pre> 
<p></p> 
<h4>二. 动态库编译举例</h4> 
<p><span style="color:#1a439c;"><strong>1. 代码结构</strong></span></p> 
<pre><code class="hljs">├── include
│   ├── a.h
│   ├── b.h
│   ├── c.h
│   └── d.h
├── obj
└── src
    ├── a.c
    ├── b.c
    ├── c.c
    └── d.c</code></pre> 
<p><span style="color:#1a439c;"><strong>2. 目的</strong></span></p> 
<p>        将src中的所有C语言文件，编译成一个libtest.so的动态库，编译出的目标文件文件和库都放在obj目录下。</p> 
<p><span style="color:#1a439c;"><strong>3. Makefile编写</strong></span></p> 
<pre><code class="hljs">INCDIR := include
SRCDIR := src
OBJDIR := obj
TARGET := libtest.so

SRCS := $(wildcard $(SRCDIR)/*)
OBJS := $(SRCS:$(SRCDIR)/%.c=$(OBJDIR)/%.o)

CFLAGS += -Wall -g -I include -fPIC
LDFLAGS += -fPIC -shared

$(OBJDIR)/$(TARGET):$(OBJS)
	gcc $(LDFLAGS) $^ -o $@ 

$(OBJS):$(OBJDIR)/%.o:$(SRCDIR)/%.c
	@mkdir -p $(OBJDIR)
	gcc $(CFLAGS) -c $&lt; -o $@

.PHONY:clean 
clean:
	@rm -rf $(OBJDIR)/*</code></pre> 
<p>        上面的例子(<span style="color:#fe2c24;">$(OBJS):$(OBJDIR)/%.o:$(SRCDIR)/%.c</span>)就使用了Makefile的静态模式规则，其中OBJS是目标文件(obj/a.o obj/c.o obj/b.o obj/d.o)，而$(OBJDIR)/%.o是目标模式(obj/%.o)，所以，"茎"分别为a，b，c和d，目标依赖则为src/a.c，src/b.c，src/c.c和src/d.c。这块代码的作用是分别将各个C语言文件编译成目标文件。</p> 
<p>        最后，<span style="color:#fe2c24;">$(OBJDIR)/$(TARGET):$(OBJS)</span>规则，将所有目标文件编译为最终的动态库。</p> 
<p></p> 
<h4><strong>三. 总结</strong></h4> 
<p>        本文讲解了Makefile的静态模式规则的使用，并通过一个动态库编译的例子，加深了对静态模式规则的理解。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c0dbe6e88822a6e7d29876fc7fa7e892/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">为什么不建议使用数据库外键</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eb7097b6638a23573b51ec645db45f3c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">代理的三种使用方法总结，带例子</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>