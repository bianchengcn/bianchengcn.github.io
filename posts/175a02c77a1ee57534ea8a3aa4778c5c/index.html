<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>哈佛结构 和 冯·诺依曼结构 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="哈佛结构 和 冯·诺依曼结构" />
<meta property="og:description" content="程序 和 数据 程序和数据都是以0和1的形式存储在相应的存储介质当中的。
数据 数据是CPU操作的内容。相当于加工的原材料。
程序 程序是指示CPU具体的操作步骤与操作流程。相当于加工的方法。
冯·诺依曼结构 和 哈佛结构 冯·诺依曼结构 冯·诺依曼结构的计算机由CPU和存储器构成，其程序和数据共用一个存储空间，程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置；采用单一的地址及数据总线，程序指令和数据的宽度相同。程序计数器（PC）是CPU内部指示指令和数据的存储位置的寄存器。
CPU通过程序计数器提供的地址信息，对存储器进行寻址，找到所需要的指令或数据，然后对指令进行译码，最后执行指令规定的操作。处理器执行指令时，先从存储器中取出指令解码，再取操作数执行运算，即使单条指令也要耗费几个甚至几十个周期；在高速运算时，在传输通道上会出现瓶颈效应。 目前使用冯·诺依曼结构的CPU和微控制器品种有很多，例如Intel公司的8086系列及其他CPU、ARM公司的ARM7、MIPS公司的MIPS处理器等。
哈佛结构 哈佛结构的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个相互独立的存储器，每个存储器独立编址、独立访问。系统中具有程序的数据总线与地址总线及数据的数据总线与地址总线。这种分离的程序总线和数据总线可允许在一个机器周期内同时获取指令字（来自程序存储器）和操作数（来自数据存储器），从而提高了执行速度及数据的吞吐率。又由于程序和数据存储器在两个分开的物理空间中，因此取指和执行能完全重叠，具有较高的执行效率。
目前使用哈佛结构的CPU和微控制器品种有很多，除DSP处理器外，还有Freescale公司的MC68系列，Zilog公司的28系列，ATMEL公司的AVR系列和ARM公司的ARM9、ARM10、ARM11等。
对比 冯诺依曼结构中程序和数据不区分的放在一起，因此安全和稳定性是个问题，好处是处理起来简单。
哈佛结构中程序（一般放在ROM、flash中）和数据（一般放在RAM中）独立分开存放，因此好处是安全和稳定性高，缺点是软件处理复杂一些（需要统一规划链接地址等）
程序空间和数据空间是否是一体的。冯·诺依曼结构数据空间和程序空间是不分开的，哈佛结构数据空间和程序空间是分开的。
早期的微处理器大多采用冯·诺依曼结构，典型代表是Intel公司的X86微处理器。取指和取操作数都在同一总线上，通过分时复用的方式进行的。缺点是在高速运行时，不能达到同时取指令和取操作数，从而形成了传输过程的瓶颈。
哈佛总线技术应用是以DSP和ARM为代表的。采用哈佛总线体系结构的芯片内部程序空间和数据空间是分开的，这就允许同时取指和取操作数，从而大大提高了运算能力。
改进型的哈佛结构与哈佛体系结构差别 与冯.诺曼结构处理器比较，哈佛结构处理器有两个明显的特点：
使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；
使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。
后来，又提出了改进的哈佛结构，其结构特点为：
使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；
具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；
两条总线由程序存储器和数据存储器分时共用。
总结 体系结构与采用的独立与否的总线无关，与指令空间和数据空间的分开独立与否有关。51单片机虽然数据指令存储区是分开的，但总线是分时复用的，所以属于改进型的哈佛结构。ARM9虽然是哈佛结构，但是之前的版本(例如ARM7)也还是冯·诺依曼结构。早期的X86能迅速占有市场，一条很重要的原因，正是靠了冯·诺依曼这种实现简单，成本低的总线结构。现在的处理器虽然外部总线上看是诺依曼结构的，但是由于内部CACHE的存在，因此实际上内部来看已经 类似 改进型哈佛结构的了。至于优缺点，哈佛结构就是复杂，对外围设备的连接与处理要求高，十分不适合外围存储器的扩展。所以早期通用CPU难以采用这种结构。而单片机，由于内部集成了所需的存储器，所以采用哈佛结构也未尝不可。现在的处理器，依托CACHE的存在，已经很好的将二者统一起来了。
参考内容：朱有鹏老师视频教程课件 &amp; 网友文章 参考内容：http://www.weboch.com.cn/ARM/neumann-harvard.asp 参考内容：http://www.weboch.com.cn/ARM/harvard-architecture.asp" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/175a02c77a1ee57534ea8a3aa4778c5c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-10-28T10:56:27+08:00" />
<meta property="article:modified_time" content="2016-10-28T10:56:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">哈佛结构 和 冯·诺依曼结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="程序-和-数据">程序 和 数据</h3> 
<p>程序和数据都是以0和1的形式存储在相应的存储介质当中的。</p> 
<h4 id="数据">数据</h4> 
<p>数据是CPU操作的内容。相当于加工的原材料。</p> 
<h4 id="程序">程序</h4> 
<p>程序是指示CPU具体的操作步骤与操作流程。相当于加工的方法。</p> 
<h3 id="冯诺依曼结构-和-哈佛结构">冯·诺依曼结构 和 哈佛结构</h3> 
<h4 id="冯诺依曼结构"><strong>冯·诺依曼结构</strong></h4> 
<p><img src="https://images2.imgbox.com/f3/4f/O2U8GlaP_o.png" alt="冯.诺依曼结构示意图" title=""> <br> 冯·诺依曼结构的计算机由CPU和存储器构成，其程序和数据共用一个存储空间，程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置；采用单一的地址及数据总线，程序指令和数据的宽度相同。程序计数器（PC）是CPU内部指示指令和数据的存储位置的寄存器。</p> 
<p>CPU通过程序计数器提供的地址信息，对存储器进行寻址，找到所需要的指令或数据，然后对指令进行译码，最后执行指令规定的操作。处理器执行指令时，先从存储器中取出指令解码，再取操作数执行运算，即使单条指令也要耗费几个甚至几十个周期；在高速运算时，在传输通道上会出现瓶颈效应。 <br> 　 <br> 目前使用冯·诺依曼结构的CPU和微控制器品种有很多，例如Intel公司的8086系列及其他CPU、ARM公司的ARM7、MIPS公司的MIPS处理器等。</p> 
<h4 id="哈佛结构"><strong>哈佛结构</strong></h4> 
<p><img src="https://images2.imgbox.com/44/fd/OdeHdeZI_o.png" alt="哈佛结构示意图" title=""> <br> 哈佛结构的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个相互独立的存储器，每个存储器独立编址、独立访问。系统中具有程序的数据总线与地址总线及数据的数据总线与地址总线。这种分离的程序总线和数据总线可允许在一个机器周期内同时获取指令字（来自程序存储器）和操作数（来自数据存储器），从而提高了执行速度及数据的吞吐率。又由于程序和数据存储器在两个分开的物理空间中，因此取指和执行能完全重叠，具有较高的执行效率。</p> 
<p>目前使用哈佛结构的CPU和微控制器品种有很多，除DSP处理器外，还有Freescale公司的MC68系列，Zilog公司的28系列，ATMEL公司的AVR系列和ARM公司的ARM9、ARM10、ARM11等。</p> 
<h4 id="对比">对比</h4> 
<p>冯诺依曼结构中程序和数据不区分的放在一起，因此安全和稳定性是个问题，好处是处理起来简单。</p> 
<p>哈佛结构中程序（一般放在ROM、flash中）和数据（一般放在RAM中）独立分开存放，因此好处是安全和稳定性高，缺点是软件处理复杂一些（需要统一规划链接地址等）</p> 
<p><strong>程序空间和数据空间是否是一体的</strong>。冯·诺依曼结构数据空间和程序空间是不分开的，哈佛结构数据空间和程序空间是分开的。</p> 
<p>早期的微处理器大多采用冯·诺依曼结构，典型代表是Intel公司的X86微处理器。取指和取操作数都在同一总线上，通过分时复用的方式进行的。缺点是在高速运行时，不能达到同时取指令和取操作数，从而形成了传输过程的瓶颈。</p> 
<p>哈佛总线技术应用是以DSP和ARM为代表的。采用哈佛总线体系结构的芯片内部程序空间和数据空间是分开的，这就允许同时取指和取操作数，从而大大提高了运算能力。</p> 
<h4 id="改进型的哈佛结构与哈佛体系结构差别">改进型的哈佛结构与哈佛体系结构差别</h4> 
<p>与冯.诺曼结构处理器比较，哈佛结构处理器有两个明显的特点：</p> 
<ul><li><p>使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；</p></li><li><p>使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。</p></li></ul> 
<p>后来，又提出了改进的哈佛结构，其结构特点为：</p> 
<ul><li><p>使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；</p></li><li><p>具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；</p></li><li><p>两条总线由程序存储器和数据存储器分时共用。</p></li></ul> 
<h3 id="总结">总结</h3> 
<p>体系结构与采用的独立与否的总线无关，与指令空间和数据空间的分开独立与否有关。51单片机虽然数据指令存储区是分开的，但总线是分时复用的，所以属于改进型的哈佛结构。ARM9虽然是哈佛结构，但是之前的版本(例如ARM7)也还是冯·诺依曼结构。早期的X86能迅速占有市场，一条很重要的原因，正是靠了冯·诺依曼这种实现简单，成本低的总线结构。现在的处理器虽然外部总线上看是诺依曼结构的，但是由于内部CACHE的存在，因此实际上内部来看已经 类似 改进型哈佛结构的了。至于优缺点，哈佛结构就是复杂，对外围设备的连接与处理要求高，十分不适合外围存储器的扩展。所以早期通用CPU难以采用这种结构。而单片机，由于内部集成了所需的存储器，所以采用哈佛结构也未尝不可。现在的处理器，依托CACHE的存在，已经很好的将二者统一起来了。</p> 
<p><em>参考内容：朱有鹏老师视频教程课件 &amp; 网友文章</em> <br> <em>参考内容：<a href="http://www.weboch.com.cn/ARM/neumann-harvard.asp" rel="nofollow">http://www.weboch.com.cn/ARM/neumann-harvard.asp</a></em> <br> <em>参考内容：<a href="http://www.weboch.com.cn/ARM/harvard-architecture.asp" rel="nofollow">http://www.weboch.com.cn/ARM/harvard-architecture.asp</a></em></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0471b11706dda85f65471539e7bbe602/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一键端2</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/83dface3ac8a94087e6d07d0fad4ce59/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c语言指向结构体的指针作为函数参数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>