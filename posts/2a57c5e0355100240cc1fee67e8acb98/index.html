<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>你所不知道的 Typescript 与 Redux 类型优化 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="你所不知道的 Typescript 与 Redux 类型优化" />
<meta property="og:description" content="原发于知乎专栏，欢迎关注：zhuanlan.zhihu.com/p/32112508
自从 Redux 诞生后，函数式编程在前端一直很热；去年7月，Typescript 发布 2.0，OOP 数据流框架也开始火热，社区更倾向于类型友好、没有 Redux 那么冗长烦琐的 Mobx 和 dob。
然而静态类型并没有绑定 OOP。随着 Redux 社区对 TS 的拥抱以及 TS 自身的发展，TS 对 FP 的表达能力势必也会越来越强。Redux 社区也需要群策群力，为 TS 和 FP 的伟大结合做贡献。
本文主要介绍 Typescript 一些有意思的高级特性；并用这些特性对 Redux 做了类型优化，例如：推导全局的 Redux State 类型、Reducer 每个 case 下拿到不同的 payload 类型；Redux 去形式化与 Typescript 的结合；最后介绍了一些 React 中常用的 Typescript 技巧。
理论基础 Mapped Types 在 Javascript 中，字面量对象和数组是非常强大灵活。引进类型后，如何避免因为类型的约束而使字面量对象和数组死气沉沉，Typescript 灵活的 interface 是一个伟大的发明。
下面介绍的 Mapped Types 让 interface 更加强大。大家在 js 中都用过 map 运算。在 TS 中，interface 也能做 map 运算。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2a57c5e0355100240cc1fee67e8acb98/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-18T03:16:32+08:00" />
<meta property="article:modified_time" content="2017-12-18T03:16:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">你所不知道的 Typescript 与 Redux 类型优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <blockquote> 
  <p>原发于知乎专栏，欢迎关注：<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F32112508" rel="nofollow">zhuanlan.zhihu.com/p/32112508</a></p> 
 </blockquote> 
 <p>自从 <code>Redux</code> 诞生后，函数式编程在前端一直很热；去年7月，<code>Typescript</code> 发布 2.0，OOP 数据流框架也开始火热，社区更倾向于类型友好、没有 Redux 那么冗长烦琐的 Mobx 和 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fdobjs%2Fdob" rel="nofollow">dob</a>。</p> 
 <p>然而静态类型并没有绑定 OOP。随着 Redux 社区对 TS 的拥抱以及 TS 自身的发展，TS 对 FP 的表达能力势必也会越来越强。Redux 社区也需要群策群力，为 TS 和 FP 的伟大结合做贡献。</p> 
 <p>本文主要介绍 <code>Typescript</code> 一些有意思的高级特性；并用这些特性对 Redux 做了类型优化，例如：推导全局的 Redux State 类型、Reducer 每个 case 下拿到不同的 payload 类型；Redux 去形式化与 Typescript 的结合；最后介绍了一些 React 中常用的 Typescript 技巧。</p> 
 <h3 class="heading">理论基础</h3> 
 <h4 class="heading">Mapped Types</h4> 
 <p>在 <code>Javascript</code> 中，字面量对象和数组是非常强大灵活。引进类型后，如何避免因为类型的约束而使字面量对象和数组死气沉沉，<code>Typescript</code> 灵活的 interface 是一个伟大的发明。</p> 
 <p>下面介绍的 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Fadvanced-types.html%23mapped-types" rel="nofollow"><code>Mapped Types</code></a> 让 interface 更加强大。大家在 js 中都用过 map 运算。在 TS 中，interface 也能做 map 运算。</p> 
 <pre><code class="hljs javascript copyable"><span class="hljs-comment">// 将每个属性变成可选的。</span>
type Optional&lt;T&gt; = {
 [key <span class="hljs-keyword">in</span> keyof T]?: T[key];
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>从字面量对象值推导出 interface 类型，并做 map 运算：</p> 
 <pre><code class="hljs javascript copyable">type NumberMap&lt;T&gt; = {
  [key <span class="hljs-keyword">in</span> keyof T]: number;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toNumber</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">obj: T</span>): <span class="hljs-title">NumberMap</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(obj).reduce(<span class="hljs-function">(<span class="hljs-params">result, key</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> {
      ...result,
      [key]: <span class="hljs-built_in">Number</span>(result[key]),
    };
  }, {}) <span class="hljs-keyword">as</span> any;
}

<span class="hljs-keyword">const</span> obj2 = toNumber({
  <span class="hljs-attr">a</span>: <span class="hljs-string">'32'</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">'64'</span>,
});
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在 interface map 运算的支持下，obj2 能推导出精准的类型。</p> 
 <h4 class="heading">获取函数返回值类型</h4> 
 <p>在 TS 中，有些类型是一个类型集，比如 interface，function。TS 能够通过一些方式获取类型集的子类型。比如：</p> 
 <pre><code class="hljs javascript copyable">interface Person {
  <span class="hljs-attr">name</span>: string;
}

<span class="hljs-comment">// 获取子类型</span>
<span class="hljs-keyword">const</span> personName: Person[<span class="hljs-string">'name'</span>];
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>然而，对于函数子类型，TS 暂时没有直接的支持。不过江湖上有一种类型推断的方法，可以获取返回值类型。</p> 
 <p>虽然该方法可以说又绕又不够优雅，但是函数返回值类型的推导，能够更好地支持函数式编程，收益远大于成本。</p> 
 <pre><code class="hljs javascript copyable">type Reverse&lt;T&gt; = <span class="hljs-function">(<span class="hljs-params">arg: any</span>) =&gt;</span> T;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnResultType</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: Reverse&lt;T&gt;</span>): <span class="hljs-title">T</span> </span>{
  <span class="hljs-keyword">return</span> {} <span class="hljs-keyword">as</span> any <span class="hljs-keyword">as</span> T;
}

<span class="hljs-comment">// result 类型是 number</span>
<span class="hljs-keyword">const</span> result = returnResultType(<span class="hljs-function">(<span class="hljs-params">arg: any</span>) =&gt;</span> <span class="hljs-number">3</span>);
type ResultType = <span class="hljs-keyword">typeof</span> result;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>举个例子，当我们在写 React-redux connect 的时候，返回结构极有可能与 state 结构不尽相同。而通过推导函数返回类型的方法，可以拿到准确的返回值类型：</p> 
 <pre><code class="hljs javascript copyable">type MapProps&lt;NewState&gt; = <span class="hljs-function">(<span class="hljs-params">state?: GlobalState, ownProps?: any</span>) =&gt;</span> NewState;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnType</span>&lt;<span class="hljs-title">NewState</span>&gt;(<span class="hljs-params">mapStateToProps: MapProps&lt;NewState&gt;</span>) </span>{
  <span class="hljs-keyword">return</span> {} <span class="hljs-keyword">as</span> any <span class="hljs-keyword">as</span> NewState;
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>使用方法：</p> 
 <pre><code class="hljs javascript copyable"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapStateToProps</span>(<span class="hljs-params">state?: GlobalState, ownProp?: any</span>) </span>{
  <span class="hljs-keyword">return</span> {
    ...state.dataSrc,
    <span class="hljs-attr">a</span>: <span class="hljs-string">''</span>,
  };
};

<span class="hljs-keyword">const</span> mockNewState = returnType(mapStateToProps);
type NewState = <span class="hljs-keyword">typeof</span> mockNewState;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h4 class="heading">可辨识联合（Discriminated Unions）</h4> 
 <p>关于 <code>Discriminated Unions</code> ，官方文档已有详细讲解，本文不再赘述。链接如下：</p> 
 <p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Fadvanced-types.html%23discriminated-unions" rel="nofollow">查看英文文档</a></p> 
 <p><a href="https://link.juejin.im?target=https%3A%2F%2Fzhongsp.gitbooks.io%2Ftypescript-handbook%2Fcontent%2Fdoc%2Fhandbook%2FAdvanced%2520Types.html%23%25E5%258F%25AF%25E8%25BE%25A8%25E8%25AF%2586%25E8%2581%2594%25E5%2590%2588%25EF%25BC%2588discriminated-unions%25EF%25BC%2589" rel="nofollow">查看中文文档</a></p> 
 <p>可辨识联合是什么，我只引用官方文档代码片段做快速介绍：</p> 
 <pre><code class="hljs javascript copyable">interface Square {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">"square"</span>;
    size: number;
}
interface Rectangle {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">"rectangle"</span>;
    width: number;
    height: number;
}

type Shape = Square | Rectangle;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">area</span>(<span class="hljs-params">s: Shape</span>) </span>{
    <span class="hljs-keyword">switch</span> (s.kind) {
        <span class="hljs-comment">// 在此 case 中，变量 s 的类型为 Square</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">"square"</span>: <span class="hljs-keyword">return</span> s.size * s.size;
        <span class="hljs-comment">// 在此 case 中，变量 s 的类型为 Rectangle</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">"rectangle"</span>: <span class="hljs-keyword">return</span> s.height * s.width;
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在不同的 case 下，变量 s 能够拥有不同的类型。我想读者一下子就联想到 Reducer 函数了吧。注意 interface 中定义的 kind 属性的类型，它是一个字符串字面量类型。</p> 
 <h3 class="heading">redux 类型优化</h3> 
 <h4 class="heading">combineReducer 优化</h4> 
 <h5 class="heading">原来的定义：</h5> 
 <pre><code class="hljs javascript copyable">type Reducer&lt;S&gt; = <span class="hljs-function">(<span class="hljs-params">state: S, action: any</span>) =&gt;</span> S;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combineReducers</span>&lt;<span class="hljs-title">S</span>&gt;(<span class="hljs-params">reducers: ReducersMapObject</span>): <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">S</span>&gt;;
</span><span class="copy-code-btn">复制代码</span></code></pre> 
 <p>粗看这个定义，好似没有问题。但熟悉 Redux 的读者都知道，该定义忽略了 <code>ReducersMapObject</code> 和 S 的逻辑关系，S 的结构是由 <code>ReducersMapObject</code> 的结构决定的。</p> 
 <p>如下所示，先用 <code>Mapped Types</code> 拿到 <code>ReducersMapObject</code> 的结构，然后用获取函数返回值类型的方法拿到子 <code>State</code> 的类型，最后拼成一个大 <code>State</code> 类型。</p> 
 <pre><code class="hljs javascript copyable">type Reducer&lt;S&gt; = <span class="hljs-function">(<span class="hljs-params">state: S, action: any</span>) =&gt;</span> S;

type ReducersMap&lt;FullState&gt; = {
  [key <span class="hljs-keyword">in</span> keyof FullState]: Reducer&lt;FullState[key]&gt;;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combineReducers</span>&lt;<span class="hljs-title">FullState</span>&gt;(<span class="hljs-params">reducersMap: ReducersMap&lt;FullState&gt;</span>): <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">FullState</span>&gt;;
</span><span class="copy-code-btn">复制代码</span></code></pre> 
 <p>使用新的 combineReducers 类型覆盖原先的类型定义后，经过 combineReducers 的层层递归，最终可以通过 RootReducer 推导出 Redux 全局 State 的类型！这样在 Redux Thunk 中和 connect 中，可以享受全局 State 类型，再也不需要害怕写错局部 state 路径了！</p> 
 <p>拿到全局 State 类型：</p> 
 <pre><code class="hljs javascript copyable"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnType</span>&lt;<span class="hljs-title">FullState</span>&gt;(<span class="hljs-params">reducersMap: ReducersMap&lt;FullState&gt;</span>): <span class="hljs-title">FullState</span> </span>{
  <span class="hljs-keyword">return</span> ({} <span class="hljs-keyword">as</span> any) <span class="hljs-keyword">as</span> FullState;
}

<span class="hljs-keyword">const</span> mockGlobalState = returnType(RootReducer);

type GlobalState = <span class="hljs-keyword">typeof</span> mockGlobalState;
type GetState = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> GlobalState;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h4 class="heading">去形式化 &amp; 类型推导</h4> 
 <p>Redux 社区一直有很多去形式化的工具。但是现在风口不一样了，去形式化多了一项重大任务，做好类型支持！</p> 
 <p>关于类型和去形式化，由于 Redux ActionCreator 的型别取决于实际项目使用的 Redux 异步中间件。因此本文抛开笔者自身业务场景，只谈方法论，只做最简单的 ActionCreator 解决方案。读者可以用这些方法论创建适合自己项目的类型系统。</p> 
 <p>经团队同学提醒，为了读者有更好的类型体感，笔者创建了一个 repo 供读者体验：</p> 
 <p><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FjasonHzq%2Fredux-ts-helper" rel="nofollow">github.com/jasonHzq/re…</a></p> 
 <p>读者可以 clone 下来在 vscode 中进行体验。</p> 
 <h5 class="heading">Redux Type</h5> 
 <p>用 <code>enum</code> 来声明 <code>Redux Type</code> ，可以说是最精简的了。</p> 
 <pre><code class="hljs javascript copyable">enum BasicTypes {
  changeInputValue,
  toggleDialogVisible,
}

<span class="hljs-keyword">const</span> Types = createTypes(prefix, BasicTypes);
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>然后用 <code>createTypes</code> 函数修正 <code>enum</code> 的类型和值。</p> 
 <p><code>createTypes</code> 的定义如下所示，一方面用 Proxy 对属性值进行修正。另一方面用 <code>Mapped Types</code> 对类型进行修正。</p> 
 <pre><code class="hljs javascript copyable">type ReturnTypes&lt;EnumTypes&gt; = {
    [key <span class="hljs-keyword">in</span> keyof EnumTypes]: key;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTypes</span>&lt;<span class="hljs-title">EnumTypes</span>&gt;(<span class="hljs-params">prefix, enumTypes: EnumTypes</span>): <span class="hljs-title">ReturnTypes</span>&lt;<span class="hljs-title">EnumTypes</span>&gt; </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(enumTypes <span class="hljs-keyword">as</span> any, {
        get(target, <span class="hljs-attr">property</span>: any) {
            <span class="hljs-keyword">return</span> prefix + <span class="hljs-string">'/'</span> + property;
        }
    })
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>读者请注意，ReturnTypes 中，<code>Redux Type</code> 类型被修正为一个字符串字面量类型(key)！以为创造一个可辨识联合做准备。</p> 
 <h5 class="heading">Redux Action 类型优化</h5> 
 <p>市面上有很多 Redux 的去形式化工具，因此本文不再赘述 <code>Redux Action</code> 的去形式化，只说 Redux Action 的类型优化。</p> 
 <p>笔者总结如下3点：</p> 
 <ul><li>1、要有一个整体 ActionCreators 的 interface 类型。</li></ul> 
 <p>例如，可以定义定一个字面量对象来存储 actionCreators。</p> 
 <pre><code class="hljs javascript copyable"><span class="hljs-keyword">const</span> actions = {
  <span class="hljs-comment">/** 加 */</span>
  add: ...
  <span class="hljs-comment">/** 乘以 */</span>
  multiply: ...
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>一方面其它模块引用起来会很方便，一方面可以对字面量做批量类型推导。并且其中的注释，只有在这种字面量下，才能够在 vscode 中解析，以在其它模块引用时可以提高辨识度，提高开发体验。</p> 
 <ul><li>2、每一个 actionCreator 需要定义 payload 类型。</li></ul> 
 <p>如下代码所示，无论 actionCreator 是如何创建的，其 payload 类型必须明确指定。以便在 Reducer 中享用 payload 类型。</p> 
 <pre><code class="hljs javascript copyable"><span class="hljs-keyword">const</span> actions = {
  <span class="hljs-comment">/** 加 */</span>
  add() {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">type</span>: Types.add, <span class="hljs-attr">payload</span>: <span class="hljs-number">3</span> };
  },
  <span class="hljs-comment">/** 乘以 */</span>
  multiply: createAction&lt;{ <span class="hljs-attr">num</span>: number }&gt;(Types.multiply)
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ul><li>3、推导出可辨识联合类型。</li></ul> 
 <p>最后，还要能够通过 actions 推导出可辨识联合类型。如此才能在 Reducer 不同 case 下享用不同的 payload 类型。</p> 
 <p>需要推导出的 ActionType 结构如下：</p> 
 <pre><code class="hljs javascript copyable">type ActionType = { <span class="hljs-attr">type</span>: <span class="hljs-string">'add'</span>, <span class="hljs-attr">payload</span>: number }
  | { <span class="hljs-attr">type</span>: <span class="hljs-string">'multiply'</span>, <span class="hljs-attr">payload</span>: { <span class="hljs-attr">num</span>: number } };
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>推导过程如下：</p> 
 <pre><code class="hljs javascript copyable">type ActionCreatorMap&lt;ActionMap&gt; = {
  [key <span class="hljs-keyword">in</span> keyof ActionMap]: <span class="hljs-function">(<span class="hljs-params">payload?, arg2?, arg3?, arg4?</span>) =&gt;</span> ActionMap[key]
};
type ValueOf&lt;ActionMap&gt; = ActionMap[keyof ActionMap];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnType</span>&lt;<span class="hljs-title">ActionMap</span>&gt;(<span class="hljs-params">actions: ActionCreatorMap&lt;ActionMap&gt;</span>) </span>{
  type Action = ValueOf&lt;ActionMap&gt;;

  <span class="hljs-keyword">return</span> {} <span class="hljs-keyword">as</span> any <span class="hljs-keyword">as</span> Action;
}

<span class="hljs-keyword">const</span> mockAction = returnType(actions);
type ActionType = <span class="hljs-keyword">typeof</span> mockAction;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state: State, action: ActionType</span>): <span class="hljs-title">State</span> </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> Types.add: { <span class="hljs-keyword">return</span> ... }
    <span class="hljs-keyword">case</span> Types.muliple: { <span class="hljs-keyword">return</span> ... }
  }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading">前端类型优化</h3> 
 <h4 class="heading">常用的React类型</h4> 
 <ul><li>Event</li></ul> 
 <p>React 中 Event 参数很常见，因此 React 提供了丰富的关于 Event 的类型。比如最常用的 React.ChangeEvent：</p> 
 <pre><code class="hljs javascript copyable"><span class="hljs-comment">// HTMLInputElement 为触发 Event 的元素类型</span>
handleChange(e: React.ChangeEvent&lt;HTMLInputElement&gt;) {
  <span class="hljs-comment">// e.target.value</span>
  <span class="hljs-comment">// e.stopPropagation</span>
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>笔者更喜欢把 Event 转换成对应的 value</p> 
 <pre><code class="hljs javascript copyable"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pipeEvent</span>&lt;<span class="hljs-title">Element</span> = <span class="hljs-title">HTMLInputElement</span>&gt;(<span class="hljs-params">func: any</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">event: React.ChangeEvent&lt;HTMLInputElement&gt;</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> func(event.target.value, event);
  };
}

&lt;input onChange={pipeEvent(actions.changeValue)}&gt;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ul><li>RouteComponentProps</li></ul> 
 <p>ReactRoute 提供了 RouteComponentProps 类型，提供了 location、params 的类型定义</p> 
 <pre><code class="hljs javascript copyable">type Props = OriginProps &amp; RouteComponentProps&lt;Params, {}&gt;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h4 class="heading">自动产生接口类型</h4> 
 <p>一般来说，前后端之间会用一个 API 约定平台或者接口约定文档，来做前后端解耦，比如 rap、 swagger。笔者在团队中做了一个把接口约定转换成 Typescript 类型定义代码的。经过笔者团队的实践，这种工具对开发效率、维护性都有很大的提高。</p> 
 <p>接口类型定义对开发的帮助：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>在可维护性上。例如，一旦接口约定进行更改，API 的类型定义代码会重新生成，Typescript 能够检测到字段的不匹配，前端便能快速修正代码。最重要的是，由于前端代码与接口约定的绑定关系，保证了接口约定文档具有百分百的可靠性。我们得以通过接口约定来构建一个可靠的测试系统，进行自动化的联调与测试。</p> 
 <h4 class="heading">常用的默认类型</h4> 
 <ul><li>Partial</li></ul> 
 <p>把 interface 所有属性变成可选：</p> 
 <pre><code class="hljs javascript copyable">interface Obj {
  <span class="hljs-attr">a</span>: number;
  b: string;
}

type OptionalObj = Partial&lt;Obj&gt;

<span class="hljs-comment">// interface OptionalObj {<!-- --></span>
<span class="hljs-comment">//   a?: number;</span>
<span class="hljs-comment">//   b?: string;</span>
<span class="hljs-comment">// }</span>
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ul><li>Readonly</li></ul> 
 <p>把 interface 所有属性变成 readonly：</p> 
 <pre><code class="hljs javascript copyable">interface Obj {
  <span class="hljs-attr">a</span>: number;
  b: string;
}

type ReadonlyObj = Readonly&lt;Obj&gt;

<span class="hljs-comment">// interface ReadonlyObj {<!-- --></span>
<span class="hljs-comment">//   readonly a: number;</span>
<span class="hljs-comment">//   readonly b: string;</span>
<span class="hljs-comment">// }</span>
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ul><li>Pick</li></ul> 
 <pre><code class="hljs javascript copyable">interface T {
  <span class="hljs-attr">a</span>: string;
  b: number;
  c: boolean;
}

type OnlyAB = Pick&lt;T, <span class="hljs-string">'a'</span> | <span class="hljs-string">'b'</span>&gt;;

<span class="hljs-comment">// interface OnlyAB {<!-- --></span>
<span class="hljs-comment">//   a: string;</span>
<span class="hljs-comment">//   b: number;</span>
<span class="hljs-comment">// }</span>
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading">总结</h3> 
 <p>在 FP 中，函数就像一个个管道，在管道的连接处的数据块的类型总是不尽相同。下一层管道使用类型往往需要重新定义。</p> 
 <p>但是如果有一个确定的推导函数返回值类型的方法，那么只需要知道管道最开始的数据块类型，那么所有管道连接处的类型都可以推导出来。</p> 
 <p>当前 TS 版本尚不支持直接获取函数返回值类型，虽然本文介绍的间接方法也能解决问题，但最好还是希望 TS 早日直接支持：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FMicrosoft%2FTypeScript%2Fissues%2F6606" rel="nofollow">issue</a>。</p> 
 <p>FP 就像一匹脱缰的野马，请用类型拴住它。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2cb781d79dfc83210ee6b93612118c33/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">车牌号校验正则表达式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6509296fb721ab128a9f859cc8bcc2a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[游戏数据表]泰拉瑞亚Terraria 全物品属性表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>