<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>webpack 如何优雅的使用tree-shaking（摇树优化） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="webpack 如何优雅的使用tree-shaking（摇树优化）" />
<meta property="og:description" content="webpack 如何优雅的使用tree-shaking 1.什么是tree-shaking webpack 2 的到来带来的最棒的新特性之一就是tree-shaking 。tree-shaking源自于rollup.js，先如今，webpack 2也有类似的做法。
webpack 里的tree-shaking的到来不得不归功于es6规范的模块。为什么这么说，如今的前端模块规范很多，比较出流行的比如commonJS , AMD , es6 ，我简单的说一下commonJS和es6模块的区别。
commonJS 模块 commonJS的模块规范在Node中发扬光大，总的来说，它的特性有这几个：
1.动态加载模块 commonJS和es6的最大区别大概就在于此了吧，commonJS模块的动态加载能够很轻松的实现懒加载，优化用户体验。
2.加载整个模块 commonJS模块中，导出的是整个模块。
3.每个模块皆为对象 commonJS模块都被视作一个对象。
4.值拷贝 commonJS的模块输出和 函数的值传递相似，都是值的拷贝
es6 模块 1.静态解析 即在解析阶段就确定输出的模块，所以es6模块的import一般写在被引入文件的开头。
2.模块不是对象 在es6里，每个模块并不会当做一个对象看待
3.加载的不是整个模块 在es6模块中经常会看见一个模块中有好几个export 导出
4.模块的引用 es6模块中，导出的并不是模块的值拷贝，而是这个模块的引用
在结合es6模块和commonJS模块的区别之后，我们知道es6的特点是静态解析，而commonJS模块的特点是动态解析的，因此，借于es6模块的静态解析，tree-shaking的实现才能成为可能。 在webpack中，tree-shaking指的就是按需加载，即没有被引用的模块不会被打包进来，减少我们的包大小，缩小应用的加载时间，呈现给用户更佳的体验。
2.怎么使用tree-shaking 说了这么多那到底如何使用tree-shaking呢？ webpack默认es6规范编写的模块都能使用tree-shaking。这是什么意思呢？下面来看个例子。 首先奉上我的demo目录如下：
├─dist └─index.html ├─node_modules └─... ├─src ├─scripts ├─assets ├─webpack.config.js └─package.json dist用来存放打包好的代码 src相反的用来存放源文件 src里的scripts目录用来存放js脚本文件，assets用来存放静态资源文件
以下几条命令过后开始我们的tree-shaking之旅
npm install --save-dev webpack webpack-dev-server webpack.config.js
const webpack = require(&#39;webpack&#39;) const path = require(&#39;path&#39;) module." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/e7c23c26628a836eeb4103419e4b3f4e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-15T20:59:36+08:00" />
<meta property="article:modified_time" content="2017-08-15T20:59:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">webpack 如何优雅的使用tree-shaking（摇树优化）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="webpack-如何优雅的使用tree-shaking">webpack 如何优雅的使用tree-shaking</h2> 
<h4 id="1什么是tree-shaking">1.什么是tree-shaking</h4> 
<p>webpack 2 的到来带来的最棒的新特性之一就是tree-shaking 。tree-shaking源自于rollup.js，先如今，webpack 2也有类似的做法。</p> 
<p>webpack 里的tree-shaking的到来不得不归功于es6规范的模块。为什么这么说，如今的前端模块规范很多，比较出流行的比如commonJS , AMD , es6 ，我简单的说一下commonJS和es6模块的区别。</p> 
<hr> 
<h4 id="commonjs-模块">commonJS 模块</h4> 
<p>commonJS的模块规范在Node中发扬光大，总的来说，它的特性有这几个：</p> 
<p><strong>1.动态加载模块</strong> <br> commonJS和es6的最大区别大概就在于此了吧，commonJS模块的动态加载能够很轻松的实现懒加载，优化用户体验。</p> 
<p><strong>2.加载整个模块</strong> <br> commonJS模块中，导出的是整个模块。</p> 
<p><strong>3.每个模块皆为对象</strong> <br> commonJS模块都被视作一个对象。</p> 
<p><strong>4.值拷贝</strong> <br> commonJS的模块输出和 函数的值传递相似，都是值的拷贝</p> 
<h4 id="es6-模块">es6 模块</h4> 
<p><strong>1.静态解析</strong> <br> 即在解析阶段就确定输出的模块，所以es6模块的import一般写在被引入文件的开头。</p> 
<p><strong>2.模块不是对象</strong> <br> 在es6里，每个模块并不会当做一个对象看待</p> 
<p><strong>3.加载的不是整个模块</strong> <br> 在es6模块中经常会看见一个模块中有好几个export 导出</p> 
<p><strong>4.模块的引用</strong> <br> es6模块中，导出的并不是模块的值拷贝，而是这个模块的引用</p> 
<hr> 
<p>在结合es6模块和commonJS模块的区别之后，我们知道es6的特点是静态解析，而commonJS模块的特点是动态解析的，因此，借于es6模块的静态解析，tree-shaking的实现才能成为可能。 <br> 在webpack中，tree-shaking指的就是按需加载，即没有被引用的模块不会被打包进来，减少我们的包大小，缩小应用的加载时间，呈现给用户更佳的体验。</p> 
<h4 id="2怎么使用tree-shaking">2.怎么使用tree-shaking</h4> 
<p>说了这么多那到底如何使用tree-shaking呢？ <br> webpack默认es6规范编写的模块都能使用tree-shaking。这是什么意思呢？下面来看个例子。 <br> 首先奉上我的demo目录如下：</p> 
<pre class="prettyprint"><code class=" hljs r">├─dist
    └─index.html
├─node_modules
    └─<span class="hljs-keyword">...</span>
├─src
    ├─scripts
    ├─assets
├─webpack.config.js
└─package.json</code></pre> 
<p>dist用来存放打包好的代码 <br> src相反的用来存放源文件 <br> src里的scripts目录用来存放js脚本文件，assets用来存放静态资源文件</p> 
<p>以下几条命令过后开始我们的tree-shaking之旅</p> 
<pre class="prettyprint"><code class=" hljs lasso">npm install <span class="hljs-subst">--</span>save<span class="hljs-attribute">-dev</span> webpack webpack<span class="hljs-attribute">-dev</span><span class="hljs-attribute">-server</span></code></pre> 
<p>webpack.config.js</p> 
<pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-reserved">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)
<span class="hljs-reserved">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)

<span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = {
    <span class="hljs-attribute">entry</span>:<span class="hljs-string">'./src/scripts/main.js'</span>,
    <span class="hljs-attribute">output</span>:{
        <span class="hljs-attribute">path</span>:path.resolve(__dirname,<span class="hljs-string">'dist/'</span>),
        <span class="hljs-attribute">filename</span>:<span class="hljs-string">'main.bundle.js'</span>
    },
    <span class="hljs-attribute">plugins</span>:[
        <span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin()
    ],
    <span class="hljs-attribute">devServer</span>:{
        <span class="hljs-attribute">port</span>:<span class="hljs-number">4200</span>,
        <span class="hljs-attribute">contentBase</span>:path.resolve(__dirname,<span class="hljs-string">'dist/'</span>),
        <span class="hljs-attribute">historyApiFallback</span>:<span class="hljs-literal">true</span>,
        <span class="hljs-attribute">hot</span>:<span class="hljs-literal">true</span>
    }
}</code></pre> 
<p>接下来是main.js，直接引入了sayHello</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> { sayHello } <span class="hljs-keyword">from</span> <span class="hljs-string">'./greeter.ts'</span>;

sayHello();</code></pre> 
<p>相应的main.js的依赖greeter.js</p> 
<pre class="prettyprint"><code class=" hljs javascript">export <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>{<!-- --></span>
    alert(<span class="hljs-string">'hello'</span>)
}

export <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayWorld</span><span class="hljs-params">()</span>{<!-- --></span>
    alert(<span class="hljs-string">'world'</span>)
}</code></pre> 
<p>在dist目录下有个index.html 用来引入打包后的bundle</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span> <span class="hljs-attribute">lang</span>=<span class="hljs-value">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"./main.bundle.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre> 
<p>以上就是整个demo的代码，接下来的事情我们直接webpack打包试试看</p> 
<pre class="prettyprint"><code class=" hljs ">webpack</code></pre> 
<p>去掉打包后冗长的代码（如果对打包后的代码有兴趣的可以移步我的另一篇博文<a href="http://blog.csdn.net/haodawang/article/details/77126686" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/haodawang/article/details/77126686</a>），只看chunk传参的部分：</p> 
<pre class="prettyprint"><code class=" hljs scala">[
<span class="hljs-comment">/* 0 */</span>
<span class="hljs-javadoc">/***/</span> (function(module, __webpack_exports__, __webpack_require__) {

<span class="hljs-string">"use strict"</span>;
Object.defineProperty(__webpack_exports__, <span class="hljs-string">"__esModule"</span>, { value: <span class="hljs-keyword">true</span> });
<span class="hljs-comment">/* harmony import */</span> <span class="hljs-keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__person__ = __webpack_require__(<span class="hljs-number">1</span>);


Object(__WEBPACK_IMPORTED_MODULE_0__person__[<span class="hljs-string">"a"</span> <span class="hljs-comment">/* sayHello */</span>])();

<span class="hljs-javadoc">/***/</span> }),
<span class="hljs-comment">/* 1 */</span>
<span class="hljs-javadoc">/***/</span> (function(module, __webpack_exports__, __webpack_require__) {

<span class="hljs-string">"use strict"</span>;
<span class="hljs-comment">/* harmony export (binding) */</span> __webpack_require__.d(__webpack_exports__, <span class="hljs-string">"a"</span>, function() { <span class="hljs-keyword">return</span> sayHello; });
<span class="hljs-comment">/* unused harmony export sayWorld */</span>

    function sayHello(){
        alert(<span class="hljs-string">'hello'</span>);
    }
    function sayWorld(){
        alert(<span class="hljs-string">'world'</span>);
    }



<span class="hljs-javadoc">/***/</span> })
<span class="hljs-javadoc">/******/</span> ]</code></pre> 
<p>我们关注这一行</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-comment">/* harmony export (binding) */</span> __webpack_require__.d(__webpack_exports__, <span class="hljs-string">"a"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {<!-- --></span> <span class="hljs-keyword">return</span> sayHello; });</code></pre> 
<p>实际上只return了一个sayHello。 <br> 因此我们现在只需要压缩一下整个Js代码，就能把没引用的sayWorld剔除。</p> 
<p>键入以下命令进行压缩</p> 
<pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">webpack</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">optimize</span><span class="hljs-literal">-</span><span class="hljs-comment">minimize</span></code></pre> 
<p>由于压缩后的代码只有一行了，我们移步尾部：</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e,n,r)</span>{<!-- --></span><span class="hljs-string">"use strict"</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">t</span><span class="hljs-params">()</span>{<!-- --></span>alert(<span class="hljs-string">"hello"</span>)}r.d(n,<span class="hljs-string">"a"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{<!-- --></span><span class="hljs-keyword">return</span> t})}]);</code></pre> 
<p>可以看到sayWorld函数已经被成功剔除。</p> 
<p>我们启动webpack-dev-server</p> 
<pre class="prettyprint"><code class=" hljs lasso">webpack<span class="hljs-attribute">-dev</span><span class="hljs-attribute">-server</span></code></pre> 
<p>在浏览器中输入 </p> 
<pre class="prettyprint"><code class=" hljs cs">http:<span class="hljs-comment">//localhost:4200</span></code></pre> 
<p><img src="https://images2.imgbox.com/1a/49/VsYpUx6P_o.png" alt="这里写图片描述" title=""></p> 
<p>每次都需要在命令行里输入参数，岂不是很麻烦，还有没有其他更好的办法呢？</p> 
<p>（1）我们可以把这串命令放入package.json的scripts字段，然后通过npm start来自动执行</p> 
<p>（2）其实–optimize-minimize的底层实现是一个插件UglifyJsPlugin，因此，我们可以直接在webpack.config.js里配置它</p> 
<p>在webpack.config.js里配置插件</p> 
<pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-reserved">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-reserved">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);

<span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = {
    <span class="hljs-attribute">entry</span>:<span class="hljs-string">'./src/scripts/main.js'</span>,
    <span class="hljs-attribute">output</span>:{
        <span class="hljs-attribute">filename</span>:<span class="hljs-string">'main.bundle.js'</span>,
        <span class="hljs-attribute">path</span>:path.join(__dirname,<span class="hljs-string">'dist'</span>)
    },
    <span class="hljs-attribute">plugins</span>:[
        <span class="hljs-keyword">new</span> webpack.optimize.UglifyJsPlugin(), <span class="hljs-regexp">//</span> &lt;----------- 压缩js
        <span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin()
    ],
    <span class="hljs-attribute">devServer</span>:{
        <span class="hljs-attribute">port</span>:<span class="hljs-number">4200</span>,
        <span class="hljs-attribute">historyApiFallback</span>:<span class="hljs-literal">true</span>,
        <span class="hljs-attribute">hot</span>:<span class="hljs-literal">true</span>,
        <span class="hljs-attribute">contentBase</span>:path.join(__dirname,<span class="hljs-string">"dist/"</span>)
    }
}</code></pre> 
<p>然后我们webpack打包</p> 
<pre class="prettyprint"><code class=" hljs ">webpack</code></pre> 
<p>即看到同样的效果</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e,n,r)</span>{<!-- --></span><span class="hljs-string">"use strict"</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">t</span><span class="hljs-params">()</span>{<!-- --></span>alert(<span class="hljs-string">"hello"</span>)}r.d(n,<span class="hljs-string">"a"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{<!-- --></span><span class="hljs-keyword">return</span> t})}]);</code></pre> 
<p>在tree-shaking触发打包后，仅仅是撇开了模块的引用，但还是要结合压缩工具来进行，这才是完整的一次tree-shaking</p> 
<p>那如果是typescript该怎么使用tree-shaking呢？</p> 
<h4 id="3如何在typescript里使用tree-shaking">3.如何在typescript里使用tree-shaking</h4> 
<p>要在webpack里使用ts，首先我们必须安装tsc</p> 
<pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">npm</span> <span class="hljs-comment">install</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">save</span><span class="hljs-literal">-</span><span class="hljs-comment">dev</span> <span class="hljs-comment">typescript</span></code></pre> 
<p>之后我们需要解析ts文件的loader</p> 
<pre class="prettyprint"><code class=" hljs lasso">npm install <span class="hljs-subst">--</span>save<span class="hljs-attribute">-dev</span> ts<span class="hljs-attribute">-loader</span></code></pre> 
<p>然后在webpack.config.js进行配置</p> 
<pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-reserved">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)
<span class="hljs-reserved">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)

<span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = {
    <span class="hljs-attribute">entry</span>:<span class="hljs-string">'./src/scripts/main.ts'</span>,
    <span class="hljs-attribute">output</span>:{
        <span class="hljs-attribute">path</span>:path.resolve(__dirname,<span class="hljs-string">'dist/'</span>),
        <span class="hljs-attribute">filename</span>:<span class="hljs-string">'main.bundle.js'</span>
    },
    <span class="hljs-attribute">module</span>:{
        <span class="hljs-attribute">rules</span>:[
            {
                <span class="hljs-attribute">test</span>:<span class="hljs-regexp">/\.ts$/</span>,
                <span class="hljs-attribute">use</span>:[<span class="hljs-string">'ts-loader'</span>]
            }
        ]
    },
    <span class="hljs-attribute">plugins</span>:[
        <span class="hljs-keyword">new</span> webpack.optimize.UglifyJsPlugin(),
        <span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin()
    ],
    <span class="hljs-attribute">devServer</span>:{
        <span class="hljs-attribute">port</span>:<span class="hljs-number">4200</span>,
        <span class="hljs-attribute">contentBase</span>:path.resolve(__dirname,<span class="hljs-string">'dist/'</span>),
        <span class="hljs-attribute">historyApiFallback</span>:<span class="hljs-literal">true</span>,
        <span class="hljs-attribute">hot</span>:<span class="hljs-literal">true</span>
    }
}</code></pre> 
<p>献上我的两份文件main.ts , greeter.ts （这两份文件除了后缀名基本没有改动）</p> 
<p><strong>main.ts</strong></p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> { sayHello } <span class="hljs-keyword">from</span> <span class="hljs-string">'./greeter.ts'</span>;

sayHello();</code></pre> 
<p><strong>greeter.ts</strong></p> 
<pre class="prettyprint"><code class=" hljs javascript">export <span class="hljs-keyword">var</span> sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{<!-- --></span>
    alert(<span class="hljs-string">'hello'</span>)
}

export <span class="hljs-keyword">var</span> sayWorld = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{<!-- --></span>
    alert(<span class="hljs-string">'world'</span>)
}</code></pre> 
<p>之后我们需要做的是，创建一个tsconfig.json的配置文件供tsc解析，这时，坑来了。</p> 
<p>下面是我的tsconfig.json文件</p> 
<pre class="prettyprint"><code class=" hljs json">{
    "<span class="hljs-attribute">compilerOptions</span>":<span class="hljs-value">{
        "<span class="hljs-attribute">target</span>":<span class="hljs-value"><span class="hljs-string">"es5"</span></span>,
        "<span class="hljs-attribute">sourceMap</span>":<span class="hljs-value"><span class="hljs-literal">true</span>
    </span>}</span>,
    "<span class="hljs-attribute">exclude</span>":<span class="hljs-value">[
        <span class="hljs-string">"./node_modules"</span>
    ]
</span>}</code></pre> 
<p>好像没有什么不对</p> 
<p>接着我们webpack</p> 
<pre class="prettyprint"><code class=" hljs ">webpack</code></pre> 
<p>看下打包压缩后的代码的最后一部分：</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-pi">"use strict"</span>;<span class="hljs-built_in">Object</span>.defineProperty(n,<span class="hljs-string">"__esModule"</span>,{value:!<span class="hljs-number">0</span>}),n.sayHello=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{<!-- --></span>alert(<span class="hljs-string">"hello"</span>)},n.sayWorld=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{<!-- --></span>alert(<span class="hljs-string">"world"</span>)}}]);</code></pre> 
<p>sayWorld居然还是存在！！！怎么回事，为什么没有被触发tree-shaking优化？</p> 
<p>这是因为tsc编译后的代码为es5 ，而正因如此，tsc默认使用了commonJS的规范来加载模块，因此并没有触发tree-shaking，那我们要怎么做？</p> 
<p>修改一下tsconfig.json，把target改为es6即可！</p> 
<pre class="prettyprint"><code class=" hljs json">{
    "<span class="hljs-attribute">compilerOptions</span>":<span class="hljs-value">{
        "<span class="hljs-attribute">target</span>":<span class="hljs-value"><span class="hljs-string">"es6"</span></span>,
        "<span class="hljs-attribute">sourceMap</span>":<span class="hljs-value"><span class="hljs-literal">true</span>
    </span>}</span>,
    "<span class="hljs-attribute">exclude</span>":<span class="hljs-value">[
        <span class="hljs-string">"./node_modules"</span>
    ]
</span>}</code></pre> 
<p>再次打包</p> 
<pre class="prettyprint"><code class=" hljs ">webpack</code></pre> 
<p>看一下打包后的bundle</p> 
<pre class="prettyprint"><code class=" hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e,n,r)</span>{<!-- --></span><span class="hljs-string">"use strict"</span>;r.d(n,<span class="hljs-string">"a"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{<!-- --></span><span class="hljs-keyword">return</span> t});<span class="hljs-keyword">var</span> t=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">({alert<span class="hljs-params">(<span class="hljs-string">"hello"</span>)</span>}}])</span>;</span></code></pre> 
<p>果然是触发了tree-shaking</p> 
<p>开启webpack-dev-server</p> 
<pre class="prettyprint"><code class=" hljs lasso">webpack<span class="hljs-attribute">-dev</span><span class="hljs-attribute">-server</span></code></pre> 
<p>可以看到成功打印hello</p> 
<p><img src="https://images2.imgbox.com/f4/89/yasiq3c3_o.png" alt="这里写图片描述" title=""></p> 
<p>以上就是我对webpack tree-shaking的总结，希望对大家的学习有所帮助</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86eab56554f99794c96d3369523230d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MVC&#43;jQuery.Ajax异步实现增删改查和分页的实例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92fd9d6eae01156c3c09f39f63af4bd7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">javascript调用java方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>