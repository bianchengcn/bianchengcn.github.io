<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>「优选算法刷题」:在排序数组中查找元素的第一个和最后个位置 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="「优选算法刷题」:在排序数组中查找元素的第一个和最后个位置" />
<meta property="og:description" content="一、题目 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。
示例 1：
输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2：
输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3：
输入：nums = [], target = 0 输出：[-1,-1] 二、思路解析 二分查找，它很简单，但也很容易写出死循环。不过，不必过多恐惧，只要多做练习，他就会是最简单的查找算法！
我们来看这道题，主要分为 2 部分：查找区间的左端点 和 右端点。
1）查找区间左端点 左边界划分的两个区间的特点：
▪ 左边区间 [left, resLeft - 1] 都是⼩于 x 的；
▪ 右边区间（包括左边界） [resLeft, right] 都是⼤于等于 x 的；
因此，关于 mid 的落点，我们可以分为下⾯两种情况：
◦ 当我们的 mid 落在 [left, resLeft - 1] 区间的时候，也就是 arr[mid] &lt;target 。说明 [left, mid] 都是可以舍去的，此时更新 left 到 mid &#43; 1 的位置，继续在 [mid &#43; 1, right] 上寻找左边界；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/65febc35c9895144b8aa13e2c58493c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-21T12:24:05+08:00" />
<meta property="article:modified_time" content="2024-01-21T12:24:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">「优选算法刷题」:在排序数组中查找元素的第一个和最后个位置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<blockquote> 
 <h2 id="%E4%B8%80%E3%80%81">一、题目</h2> 
</blockquote> 
<p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p> 
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p> 
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p> 
<p></p> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 8
<strong>输出：</strong>[3,4]</pre> 
<p><strong>示例 2：</strong></p> 
<pre><strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 6
<strong>输出：</strong>[-1,-1]</pre> 
<p><strong>示例 3：</strong></p> 
<pre><strong>输入：</strong>nums = [], target = 0
<strong>输出：</strong>[-1,-1]</pre> 
<p></p> 
<blockquote> 
 <h2 id="%E4%BA%8C%E3%80%81">二、思路解析</h2> 
</blockquote> 
<p>二分查找，它很简单，但也很容易写出死循环。不过，不必过多恐惧，只要多做练习，他就会是最简单的查找算法！</p> 
<p>我们来看这道题，主要分为 2 部分：查找区间的左端点 和 右端点。</p> 
<h3>1）查找区间左端点</h3> 
<p class="img-center"><img alt="" height="512" src="https://images2.imgbox.com/53/4b/l7Ux30wz_o.png" width="793"></p> 
<p>左边界划分的两个区间的特点：</p> 
<blockquote> 
 <p>▪ 左边区间 [left, resLeft - 1] 都是⼩于 x 的；<br> ▪ 右边区间（包括左边界） [resLeft, right] 都是⼤于等于 x 的；</p> 
</blockquote> 
<p>因此，关于 mid 的落点，我们可以分为下⾯两种情况：</p> 
<blockquote> 
 <p>◦ 当我们的 mid 落在 [left, resLeft - 1] 区间的时候，也就是 arr[mid] &lt;target 。说明 [left, mid] 都是可以舍去的，此时更新 left 到 mid + 1 的位置，继续在 [mid + 1, right] 上寻找左边界；</p> 
 <p><br> ◦ 当 mid 落在 [resLeft， right] 的区间的时候，也就是 arr[mid] &gt;= target 。说明 [mid + 1, right] （因为 mid 可能是最终结果，不能舍去）是可以舍去的，此时更新 right 到 mid 的位置，继续在 [left, mid] 上寻找左边界；</p> 
</blockquote> 
<p>注意：这⾥找中间元素需要<strong>向下取整</strong>，即 mid = left + ( right - left ) / 2 ，而不是 mid = left + ( right - left + 1 ) / 2 。</p> 
<blockquote> 
 <p>因为后续移动左右指针的时候：<br> • 左指针： left = mid + 1 ，是会向后移动的，因此区间是会缩⼩的；<br> • 右指针： right = mid ，可能会原地踏步（⽐如：如果向上取整的话，如果剩下 1,2 两个元<br> 素， left == 1 ， right == 2 ， mid == 2 。更新区间之后， left，right，mid 的<br> 值没有改变，就会陷⼊死循环）。<br> 因此⼀定要注意，当 right = mid 的时候，要向下取整。</p> 
 <p></p> 
</blockquote> 
<p></p> 
<h3>2）查找区间右端点</h3> 
<p>我们先⽤ resRight 表⽰右边界；</p> 
<p>这时可以注意到右边界的特点：</p> 
<blockquote> 
 <p>        ▪ 左边区间 （包括右边界） [left, resRight] 都是⼩于等于 x 的；<br>         ▪ 右边区间 [resRight+ 1, right] 都是⼤于 x 的；</p> 
</blockquote> 
<p>因此，关于 mid 的落点，我们可以分为下⾯两种情况：</p> 
<blockquote> 
 <p>◦ 当我们的 mid 落在 [left, resRight] 区间的时候，说明 [left, mid - 1]（ mid 不可以舍去，因为有可能是最终结果） 都是可以舍去的，此时更新 left 到 mid的位置；<br> ◦ 当 mid 落在 [resRight+ 1, right] 的区间的时候，说明 [mid, right] 内的元素是可以舍去的，此时更新 right 到 mid - 1 的位置；</p> 
</blockquote> 
<p>• 由此，就可以通过⼆分，来快速寻找右边界；<br> 注意：这⾥找中间元素需要<strong>向上取整</strong>「 mid = left + ( right - left + 1 ) / 2」。</p> 
<blockquote> 
 <p>因为后续移动左右指针的时候：<br> • 左指针： left = mid ，可能会原地踏步（比如：如果向下取整的话，如果剩下 1,2 两个元<br> 素， left == 1， right == 2，mid == 1 。更新区间之后， left，right，mid ?的值<br> 没有改变，就会陷⼊死循环）。<br> • 右指针： right = mid - 1 ，是会向前移动的，因此区间是会缩小的；<br> 因此⼀定要注意，当? right = mid ?的时候，要向下取整。</p> 
</blockquote> 
<p></p> 
<blockquote> 
 <h2 id="%E4%B8%89%E3%80%81">三、完整代码</h2> 
</blockquote> 
<pre><code class="hljs">class Solution {
    public int[] searchRange(int[] nums, int target) {
        int ret[] = new int[2];
        ret[0] = ret[1] = -1;

        // 处理边界情况
        if(nums.length == 0){
            return ret;
            }

        // 1. ⼆分左端点    
        int left = 0;
        int right = nums.length - 1;
        while(left &lt; right){
            int mid = left + (right - left) / 2;
            if(nums[mid] &lt; target){
                left = mid + 1; 
            }else{
                right = mid;
            }
        }

        // 判断是否有结果
        if(nums[left] != target){
            return ret;
        }else{
            ret[0] = left;
        }

        // 2. ⼆分右端点
        left = 0;
        right = nums.length - 1;
        while(left &lt; right){
            int mid = left + (right - left + 1) / 2;
            if(nums[mid] &lt;= target){
                left = mid;
            }else{
                right = mid - 1;
            }
        }
        ret[1] = right;
        return ret ;
    }
}</code></pre> 
<p></p> 
<p>以上就是本篇博客的全部内容啦，如有不足之处，还请各位指出，期待能和各位一起进步！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9dbff88d9f6069050e91eaa6dbdb0ce2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决Windows下Goland的Terminal设置为Git Bash失败</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c8c6d007c14accabf2d930a71d1029b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">三、需求规格说明书（软件工程示例）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>