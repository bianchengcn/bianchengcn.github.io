<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Godot】中图像缩小后很糊怎么办 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Godot】中图像缩小后很糊怎么办" />
<meta property="og:description" content="Godot 中我们的图像缩小到很小的后，你会发现图像看起来会很糊，有些的线条都看不见了，这个时候你需要导入时勾选 Mipmaps 选项。
这样图片在缩小到尽可能小的时候还会保持相对的清晰
请看如下 Mipmap 详细介绍的文章
如下引用自：为什么你需要在图形应用中使用mipmapping技术？ 为什么你需要在图形应用中使用mipmapping技术？ PowerVR开发者文档网站已经更新上线并且运行了几个星期。我们非常高兴看到开发人员从中获得帮助，对他们的应用进行了最大化的优化，而且他们还会学习到关于图形编程和PowerVR的新知识。
如果你还没有抽出时间去浏览这个网站(你真的该去看看)，我们将在这里简单介绍关于PowerVR性能优化的一些建议。
https://docs.imgtec.com/PerfRec/topics/c_PerfRec_introduction.html
我们除了为高级图形开发人员编写了文档，还花了更多的时间来帮助那些图形应用编程的新手，比如我们推出的Vulkan和OpenGL ES入门指南。现在要讨论的主题是mipmapping技术，我们会对这个技术先做个非常简短的介绍，然后探讨一些高级的技巧，尤其是与PowerVR相关的。
Mipmapping技术介绍 简而言之对于所有图形应用来说mipmapping技术都是非常有用的，因为它提高了缓存效率，降低了带宽，而我们只需要稍微增加纹理文件的大小即可。
然而对于外行来说….
Mipmapping技术具体是什么 Mipmap是纹理图像预过滤的较小版本，表示纹理的不同层次细节(LOD)，它们通常被存储在一系列不断缩小的纹理对象中，这些纹理称为mipmap链，每一级的都会比上一级的小一半。
它们的应用场景是对象与相机之间的距离是可变的情况，随着对象离相机越来越远，对象的纹理在屏幕上比它实际的分辨率会更小，换句话说每个屏幕像素点包含不止一个对象的像素，纹理将不得不在缩小过滤的过程中不断缩小，这通常需要应用程序对多个纹理进行采样从而确定像素的颜色。当你需要运行时只为单个像素而要对整个纹理进行采样好像是个得不偿失的问题。
这也是mipmap的用武之地，应用程序可以根据对象与相机的距离在纹理链中的任何低分辨率的mipmap之间进行切换，而不是重复对单个纹理进行采样。
你能详细的解释一下这样的好处吗？ 我非常高兴你能提出这样的问题，主要有两大优势：
改进图像质量——采用mipmapping可以帮助消除由于纹理采样不足引起的混叠效果，这种效果可能会直接影响应用图像的视觉质量
提升系统性能——mipmapping提高了系统缓存效率，因为不需要经常采用全部的纹理资源，而且分辨率较低的mipmap更容易适合纹理缓存，这意味着不必经常获取纹理资源，从而在减少带宽的消耗同时提升了系统整体性能。
问题有哪些？对于大部分应用程序开发来说，唯一值得注意的是纹理资源的大小，因为完整的mipmap链必须与完整分辨率的纹理一起存储，这将使得整个资源大小增加约33%，但随着呈现速度和图像质量的提高，这实际上并不再重要。
也有一些情况mipmapping不是很适用，例如：
不改变与相机距离的对象，比如UI元素，这些元素的LOD永远不会改变，因此在这种情况下mipmapping是没有任何意义的。
无法合理使用过滤的情况，比如索引和深度纹理，它们一般会包含一些非图像数据。
生成mipmap资源 Mipmap可以在离线状态下创建，也可以在运行时创建，这个取决于离线生成的存储成本和运行时生成增加的工作负载之间的平衡，然而大多数情况下离线生成的方式是最好的。
我们推出的非常受欢迎的纹理处理工具PVRTexTool（包含在PowerVR SDK中）可以用于纹理生成完整的mipmap链，只需要几下点击操作即可。然后可以使用我们专有的压缩工具PVRTC将其他格式的纹理资源保存为mipmap资源。
如果你真的想在运行时生成mipmap（同时会失去PVRTC工具和其他压缩格式带来的优势），OpenGL ES提供了glGenerateMipmap函数，不幸的是Vulkan图形库并没有为此提供任何内置函数，所以需要开发者自己来实现这个功能。
想了解更多关于mipmapping的信息吗？ 关于mipmapping的更多信息你可以查看下面我们发表的一些文章：
采用mipmapping来提升质量和性能 https://docs.imgtec.com/PerfRec/topics/c_PerfRec_mipmapping.html
黄金法则——使用mipmapping
https://docs.imgtec.com/PowerVR_Architecture/topics/rules/c_GoldenRules_do_use_mipmapping.html
黄金法则——使用LOD https://docs.imgtec.com/PowerVR_Architecture/topics/rules/c_GoldenRules_do_use_level_of_detail__lod.html
最后…
更多关于PowerVR性能建议和其他有用的开发者信息，请大家访问我们最新推出且不断更新的网站（docs.imgtec.com）。
大家可以在论坛（https://forums.imgtec.com/）或其他网站（https://pvrsupport.imgtec.com/）留下建议和反馈。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2765051d7960528800ebfc7d69af1611/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-20T18:07:57+08:00" />
<meta property="article:modified_time" content="2021-02-20T18:07:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Godot】中图像缩小后很糊怎么办</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Godot 中我们的图像缩小到很小的后，你会发现图像看起来会很糊，有些的线条都看不见了，这个时候你需要导入时勾选 <strong>Mipmaps</strong> 选项。<br> <img src="https://images2.imgbox.com/d5/2a/U6urukxD_o.png" alt="勾选这个Mipmaps"><br> 这样图片在缩小到尽可能小的时候还会保持相对的清晰</p> 
<p><strong>请看如下 Mipmap 详细介绍的文章</strong></p> 
<blockquote> 
 <p>如下引用自：<a href="https://www.sohu.com/a/338133168_468740" rel="nofollow">为什么你需要在图形应用中使用mipmapping技术？ </a></p> 
</blockquote> 
<h2><a id="mipmapping_8"></a>为什么你需要在图形应用中使用mipmapping技术？</h2> 
<p>PowerVR开发者文档网站已经更新上线并且运行了几个星期。我们非常高兴看到开发人员从中获得帮助，对他们的应用进行了最大化的优化，而且他们还会学习到关于图形编程和PowerVR的新知识。</p> 
<p>如果你还没有抽出时间去浏览这个网站(你真的该去看看)，我们将在这里简单介绍关于PowerVR性能优化的一些建议。</p> 
<p>https://docs.imgtec.com/PerfRec/topics/c_PerfRec_introduction.html</p> 
<p>我们除了为高级图形开发人员编写了文档，还花了更多的时间来帮助那些图形应用编程的新手，比如我们推出的Vulkan和OpenGL ES入门指南。现在要讨论的主题是mipmapping技术，我们会对这个技术先做个非常简短的介绍，然后探讨一些高级的技巧，尤其是与PowerVR相关的。</p> 
<h5><a id="Mipmapping_17"></a>Mipmapping技术介绍</h5> 
<p>简而言之对于所有图形应用来说mipmapping技术都是非常有用的，因为它提高了缓存效率，降低了带宽，而我们只需要稍微增加纹理文件的大小即可。</p> 
<p>然而对于外行来说….</p> 
<h5><a id="Mipmapping_23"></a>Mipmapping技术具体是什么</h5> 
<p>Mipmap是纹理图像预过滤的较小版本，表示纹理的不同层次细节(LOD)，它们通常被存储在一系列不断缩小的纹理对象中，这些纹理称为mipmap链，每一级的都会比上一级的小一半。</p> 
<p><img src="https://images2.imgbox.com/15/12/6GDmnLG9_o.png" alt="https://docs.imgtec.com/PerfRec/topics/c_PerfRec_introduction.html"></p> 
<p>它们的应用场景是对象与相机之间的距离是可变的情况，随着对象离相机越来越远，对象的纹理在屏幕上比它实际的分辨率会更小，换句话说每个屏幕像素点包含不止一个对象的像素，纹理将不得不在缩小过滤的过程中不断缩小，这通常需要应用程序对多个纹理进行采样从而确定像素的颜色。当你需要运行时只为单个像素而要对整个纹理进行采样好像是个得不偿失的问题。</p> 
<p>这也是mipmap的用武之地，应用程序可以根据对象与相机的距离在纹理链中的任何低分辨率的mipmap之间进行切换，而不是重复对单个纹理进行采样。</p> 
<h5><a id="_33"></a>你能详细的解释一下这样的好处吗？</h5> 
<p>我非常高兴你能提出这样的问题，主要有两大优势：</p> 
<p>改进图像质量——采用mipmapping可以帮助消除由于纹理采样不足引起的混叠效果，这种效果可能会直接影响应用图像的视觉质量<br> 提升系统性能——mipmapping提高了系统缓存效率，因为不需要经常采用全部的纹理资源，而且分辨率较低的mipmap更容易适合纹理缓存，这意味着不必经常获取纹理资源，从而在减少带宽的消耗同时提升了系统整体性能。</p> 
<p>问题有哪些？对于大部分应用程序开发来说，唯一值得注意的是纹理资源的大小，因为完整的mipmap链必须与完整分辨率的纹理一起存储，这将使得整个资源大小增加约33%，但随着呈现速度和图像质量的提高，这实际上并不再重要。</p> 
<p>也有一些情况mipmapping不是很适用，例如：</p> 
<p>不改变与相机距离的对象，比如UI元素，这些元素的LOD永远不会改变，因此在这种情况下mipmapping是没有任何意义的。<br> 无法合理使用过滤的情况，比如索引和深度纹理，它们一般会包含一些非图像数据。</p> 
<h5><a id="mipmap_47"></a>生成mipmap资源</h5> 
<p>Mipmap可以在离线状态下创建，也可以在运行时创建，这个取决于离线生成的存储成本和运行时生成增加的工作负载之间的平衡，然而大多数情况下离线生成的方式是最好的。</p> 
<p>我们推出的非常受欢迎的纹理处理工具PVRTexTool（包含在PowerVR SDK中）可以用于纹理生成完整的mipmap链，只需要几下点击操作即可。然后可以使用我们专有的压缩工具PVRTC将其他格式的纹理资源保存为mipmap资源。</p> 
<p>如果你真的想在运行时生成mipmap（同时会失去PVRTC工具和其他压缩格式带来的优势），OpenGL ES提供了glGenerateMipmap函数，不幸的是Vulkan图形库并没有为此提供任何内置函数，所以需要开发者自己来实现这个功能。</p> 
<h5><a id="mipmapping_55"></a>想了解更多关于mipmapping的信息吗？</h5> 
<p>关于mipmapping的更多信息你可以查看下面我们发表的一些文章：</p> 
<p>采用mipmapping来提升质量和性能 https://docs.imgtec.com/PerfRec/topics/c_PerfRec_mipmapping.html</p> 
<p><strong>黄金法则——使用mipmapping</strong></p> 
<p>https://docs.imgtec.com/PowerVR_Architecture/topics/rules/c_GoldenRules_do_use_mipmapping.html</p> 
<p><strong>黄金法则——使用LOD</strong> https://docs.imgtec.com/PowerVR_Architecture/topics/rules/c_GoldenRules_do_use_level_of_detail__lod.html<br> 最后…</p> 
<p>更多关于PowerVR性能建议和其他有用的开发者信息，请大家访问我们最新推出且不断更新的网站（docs.imgtec.com）。</p> 
<p>大家可以在论坛（https://forums.imgtec.com/）或其他网站（https://pvrsupport.imgtec.com/）留下建议和反馈。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a7246bb2bcf801e7893a0a678c86dfe3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[Vue warn]: Error in render: “TypeError: Cannot read property ‘0‘ of undefined“  found in XXXX</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0fcd5865c13c5215e363f04f0921a0b3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python实现异步非阻塞_Python的异步编程[0] -&gt; 协程[1] -&gt; 使用协程建立自己的异步非阻塞模型...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>