<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>网易游戏研发工程师笔试题 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="网易游戏研发工程师笔试题" />
<meta property="og:description" content="题目描述
小Q最近被邀请去参加了网易最牛大脑的节目，挑战数字魔方的项目。
数字魔方为一个3x3的矩阵，矩阵中的每个数字都是（1…9）中的数字，且数字魔方中的数字可能重复。每4个相邻的数字我们称为1个子魔方，整个数字魔方共有4个子魔方（如下图所示）。每一次操作可以选择对某个子魔方顺时针旋转90度，180度或者270度。每个子魔方可以进行多次操作。
对子魔方1进行一次操作，顺时针旋转90度，180度，270度后的状态：
项目的挑战任务是，给定数字魔方的一个初始状态，以及一个目标状态，问最少操作多少次可以使得魔方从初始状态改变为目标状态。
小Q求助于你，希望你能告诉他完成任务的最少操作次数是多少，或者任务不可能完成。
输入描述:
输入的第一行为一个正整数T（T&lt;=20），表示测试数据组数。
接下来有T组数据。每组数据有6行。其中前3行为数字魔方的初始状态，后3行为目标状态。每个数据之后有一个空行。保证魔方中的数字为(1…9)中的数字。
输出描述:
对于每一组数据，输出一行，包含一个整数，为最少操作次数。如果不能完成目标，则输出-1。
示例1
输入
2
1 2 3
4 5 6
7 8 9
5 4 1
6 2 3
7 8 9
1 2 3
4 5 6
7 8 9
2 5 3
1 4 6
7 8 9
输出
3
1
说明
第一个样例为对子魔方1旋转90度，然后对子魔方2旋转90度，再对子魔方1旋转90度。
第二个样例为对子魔方1旋转270度。
1.思路：
将魔方状态转换成一组字符串，由于字符串长度为9，其可能出现的状态的总数一定（不会超过9的阶乘），因此采用BFS广度优先搜索，并使用哈希表来存储状态（若使用数组来存储状态，则需要自己实现“改进的康拓展开式”）；res初始化为-1，若得到答案，则break并返回res，若得不到答案，则返回-1.
2.代码：
#include &lt;iostream&gt; #include &lt;map&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;cstring&gt; #include &lt;unordered_map&gt; using namespace std; int movx[4]={0,1,3,4}; int fac[9]={1,1,2,6,24,120,720,5040,40320}; bool vis[362890]; //数组索引直接查找，时间复杂度O(1)，但需要用康拓展开，自己实现映射过程 //哈希表由红黑树实现，其查找时间复杂度为O(logN) //C&#43;&#43;find函数查找，时间复杂度为O(N); struct node { string str; int step; }; int str2int(string str) { int cnt[9]={0}; int res=0; int i,j; for(i=0;i&lt;9;i&#43;&#43;) cnt[str[i]-&#39;1&#39;]&#43;&#43;; for(i=0;i&lt;9;i&#43;&#43;) { int x=str[i]-&#39;1&#39;; int y=0; for(j=0;j&lt;x;j&#43;&#43;) y&#43;=cnt[j]; res&#43;=y*fac[8-i]; cnt[x]--; } return res; } string rorate_str_90(string str,int x) { char ch; int dx=movx[x]; ch=str[dx]; str[dx]=str[dx&#43;3]; str[dx&#43;3]=str[dx&#43;4]; str[dx&#43;4]=str[dx&#43;1]; str[dx&#43;1]=ch; return str; } string rorate_str_180(string str,int x) { char ch; int dx=movx[x]; ch=str[dx]; str[dx]=str[dx&#43;4]; str[dx&#43;4]=ch; ch=str[dx&#43;1]; str[dx&#43;1]=str[dx&#43;3]; str[dx&#43;3]=ch; return str; } string rorate_str_270(string str,int x) { char ch; int dx=movx[x]; ch=str[dx]; str[dx]=str[dx&#43;1]; str[dx&#43;1]=str[dx&#43;4]; str[dx&#43;4]=str[dx&#43;3]; str[dx&#43;3]=ch; return str; } string calc_str(const vector&lt;int&gt; num) { string str=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3b75d18ad4da6ecec83c45321c24f8fe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-18T18:19:13+08:00" />
<meta property="article:modified_time" content="2018-03-18T18:19:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网易游戏研发工程师笔试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p align="left" style="background:#F7F7F7;"><strong><span style="color:#333333;">题目描述</span></strong></p> 
<p align="left" style="background:#F7F7F7;"><span style="color:#333333;">小</span><span style="color:#333333;">Q</span><span style="color:#333333;">最近被邀请去参加了网易最牛大脑的节目，挑战数字魔方的项目。</span></p> 
<p align="left" style="background:#F7F7F7;"><span style="color:#333333;"> </span></p> 
<p align="left" style="background:#F7F7F7;"><span style="color:#333333;">数字魔方为一个</span><span style="color:#333333;">3x3</span><span style="color:#333333;">的矩阵，矩阵中的每个数字都是（</span><span style="color:#333333;">1…9</span><span style="color:#333333;">）中的数字，且数字魔方中的数字可能重复。每</span><span style="color:#333333;">4</span><span style="color:#333333;">个相邻的数字我们称为</span><span style="color:#333333;">1</span><span style="color:#333333;">个子魔方，整个数字魔方共有</span><span style="color:#333333;">4</span><span style="color:#333333;">个子魔方（如下图所示）。每一次操作可以选择对某个子魔方顺时针旋转</span><span style="color:#333333;">90</span><span style="color:#333333;">度，</span><span style="color:#333333;">180</span><span style="color:#333333;">度或者</span><span style="color:#333333;">270</span><span style="color:#333333;">度。每个子魔方可以进行多次操作。</span></p> 
<p align="left" style="background:#F7F7F7;"><span style="color:#333333;"> <img src="https://images2.imgbox.com/5e/4b/uB5IxhJP_o.png" alt=""></span></p> 
<p align="left" style="background:#F7F7F7;"><span style="color:#333333;">对子魔方</span><span style="color:#333333;">1</span><span style="color:#333333;">进行一次操作，顺时针旋转</span><span style="color:#333333;">90</span><span style="color:#333333;">度，</span><span style="color:#333333;">180</span><span style="color:#333333;">度，</span><span style="color:#333333;">270</span><span style="color:#333333;">度后的状态：</span></p> 
<p align="left" style="background:#F7F7F7;"><span style="color:#333333;"><img src="https://images2.imgbox.com/01/fd/DG0eCkRt_o.png" alt=""><br></span></p> 
<p align="left" style="background:#F7F7F7;"><span style="color:#333333;">项目的挑战任务是，给定数字魔方的一个初始状态，以及一个目标状态，问最少操作多少次可以使得魔方从初始状态改变为目标状态。</span></p> 
<p align="left" style="background:#F7F7F7;"><span style="color:#333333;"> </span></p> 
<p align="left" style="background:#F7F7F7;"><span style="color:#333333;">小</span><span style="color:#333333;">Q</span><span style="color:#333333;">求助于你，希望你能告诉他完成任务的最少操作次数是多少，或者任务不可能完成。</span></p> 
<p align="left" style="background:#F7F7F7;"><strong><span style="color:#333333;">输入描述</span><span style="color:#333333;">:</span></strong></p> 
<div style="background:#FEFEFE;"> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#333333;">输入的第一行为一个正整数</span><span style="color:#333333;">T</span><span style="color:#333333;">（</span><span style="color:#333333;">T&lt;=20</span><span style="color:#333333;">），表示测试数据组数。</span><span style="color:#333333;"><br></span><span style="color:#333333;">接下来有</span><span style="color:#333333;">T</span><span style="color:#333333;">组数据。每组数据有</span><span style="color:#333333;">6</span><span style="color:#333333;">行。其中前</span><span style="color:#333333;">3</span><span style="color:#333333;">行为数字魔方的初始状态，后</span><span style="color:#333333;">3</span><span style="color:#333333;">行为目标状态。每个数据之后有一个空行。保证魔方中的数字为</span><span style="color:#333333;">(1…9)</span><span style="color:#333333;">中的数字。</span></p> 
</div> 
<p align="left" style="background:#F7F7F7;"><strong><span style="color:#333333;">输出描述</span><span style="color:#333333;">:</span></strong></p> 
<div style="background:#FEFEFE;"> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#333333;">对于每一组数据，输出一行，包含一个整数，为最少操作次数。如果不能完成目标，则输出</span><span style="color:#333333;">-1</span><span style="color:#333333;">。</span></p> 
</div> 
<p align="left" style="background:#F7F7F7;"><strong><span style="color:#34495E;">示例</span><span style="color:#34495E;">1</span></strong></p> 
<p align="left" style="background:#EAF0F5;"><span style="color:#34495E;">输入</span></p> 
<div style="background:#FEFEFE;"> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">2</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">1 2 3</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">4 5 6</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">7 8 9</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">5 4 1</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">6 2 3</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">7 8 9</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;"> </span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">1 2 3</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">4 5 6</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">7 8 9</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">2 5 3</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">1 4 6</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">7 8 9</span></p> 
</div> 
<p align="left" style="background:#EAF0F5;"><span style="color:#34495E;">输出</span></p> 
<div style="background:#FEFEFE;"> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">3</span></p> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">1</span></p> 
</div> 
<p align="left" style="background:#EAF0F5;"><span style="color:#34495E;">说明</span></p> 
<div style="background:#FEFEFE;"> 
 <p align="left" style="background:#FEFEFE;"><span style="color:#34495E;">第一个样例为对子魔方</span><span style="color:#34495E;">1</span><span style="color:#34495E;">旋转</span><span style="color:#34495E;">90</span><span style="color:#34495E;">度，然后对子魔方</span><span style="color:#34495E;">2</span><span style="color:#34495E;">旋转</span><span style="color:#34495E;">90</span><span style="color:#34495E;">度，再对子魔方</span><span style="color:#34495E;">1</span><span style="color:#34495E;">旋转</span><span style="color:#34495E;">90</span><span style="color:#34495E;">度。</span><span style="color:#34495E;"><br></span><span style="color:#34495E;">第二个样例为对子魔方</span><span style="color:#34495E;">1</span><span style="color:#34495E;">旋转</span><span style="color:#34495E;">270</span><span style="color:#34495E;">度。</span></p> 
</div> 
<p> </p> 
<p> 1.思路：</p> 
<p>将魔方状态转换成一组字符串，由于字符串长度为9，其可能出现的状态的总数一定（不会超过9的阶乘），因此采用BFS广度优先搜索，并使用哈希表来存储状态（若使用数组来存储状态，则需要自己实现“改进的康拓展开式”）；res初始化为-1，若得到答案，则break并返回res，若得不到答案，则返回-1.</p> 
<p><br></p> 
<p>2.代码：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#include &lt;unordered_map&gt;
using namespace std;
int movx[4]={0,1,3,4};
int fac[9]={1,1,2,6,24,120,720,5040,40320};
bool vis[362890];
//数组索引直接查找，时间复杂度O(1)，但需要用康拓展开，自己实现映射过程
//哈希表由红黑树实现，其查找时间复杂度为O(logN)
//C++find函数查找，时间复杂度为O(N);

struct node
{
    string str;
    int step;
};

int str2int(string str)
{
    int cnt[9]={0};
    int res=0;
    int i,j;
    for(i=0;i&lt;9;i++)
        cnt[str[i]-'1']++;
    for(i=0;i&lt;9;i++)
    {
        int x=str[i]-'1';
        int y=0;
        for(j=0;j&lt;x;j++)
            y+=cnt[j];
        res+=y*fac[8-i];
        cnt[x]--;
    }
    return res;
}
string rorate_str_90(string str,int x)
{
    char ch;
    int dx=movx[x];
    ch=str[dx];
    str[dx]=str[dx+3];
    str[dx+3]=str[dx+4];
    str[dx+4]=str[dx+1];
    str[dx+1]=ch;
    return str;
}
string rorate_str_180(string str,int x)
{
    char ch;
    int dx=movx[x];
    ch=str[dx];
    str[dx]=str[dx+4];
    str[dx+4]=ch;
    ch=str[dx+1];
    str[dx+1]=str[dx+3];
    str[dx+3]=ch;
    return str;
}
string rorate_str_270(string str,int x)
{
    char ch;
    int dx=movx[x];
    ch=str[dx];
    str[dx]=str[dx+1];
    str[dx+1]=str[dx+4];
    str[dx+4]=str[dx+3];
    str[dx+3]=ch;
    return str;
}
string calc_str(const vector&lt;int&gt; num)
{
    string str="";
    for(int i=0;i&lt;9;i++)
        str+=('0'+num[i]);
    return str;
}
int main()
{
    int t,i,tmp;
    cin&gt;&gt;t;
    while(t--)
    {
        vector&lt;int&gt; init;
        vector&lt;int&gt; res;
        string init_str,res_str;
        int minx=-1;
        unordered_map&lt;string, int&gt; vis2; //初始化哈希表
//        memset(vis,0,sizeof(vis));
        queue&lt;node&gt; q;
        int num;
        for(i=0;i&lt;9;i++)
        {
            cin&gt;&gt;tmp;
            init.push_back(tmp);
        }
        for(i=0;i&lt;9;i++)
        {
            cin&gt;&gt;tmp;
            res.push_back(tmp);
        }
        init_str=calc_str(init);
        res_str=calc_str(res);
        node init_node;
        init_node.step=0;
        init_node.str=init_str;
        q.push(init_node);
//        vis[str2int(init_node.str)]=true;
        while(!q.empty())
        {
            node tn,nx;
            tn=q.front();q.pop();
            if(tn.str==res_str)
            {
                minx=tn.step;
                break;
            }
            for(i=0;i&lt;4;i++)
            {
                nx.str=rorate_str_90(tn.str,i);
                if(vis2.find(nx.str) == vis2.end()) {
                    vis2[nx.str] = 1;
                    nx.step = tn.step+1;
                    q.push(nx);
                }
//                num=str2int(nx.str);
//                if(!vis[num])
//                {
//                    vis[num]=1;
//                    nx.step=tn.step+1;
//                    q.push(nx);
//                }
                nx.str=rorate_str_180(tn.str,i);
                if(vis2.find(nx.str) == vis2.end()) {
                    vis2[nx.str] = 1;
                    nx.step = tn.step+1;
                    q.push(nx);
                }
//                num=str2int(nx.str);
//                if(!vis[num])
//                {
//                    vis[num]=1;
//                    nx.step=tn.step+1;
//                    q.push(nx);
//                }
                nx.str=rorate_str_270(tn.str,i);
                if(vis2.find(nx.str) == vis2.end()) {
                    vis2[nx.str] = 1;
                    nx.step = tn.step+1;
                    q.push(nx);
                }
//                num=str2int(nx.str);
//                if(!vis[num])
//                {
//                    vis[num]=1;
//                    nx.step=tn.step+1;
//                    q.push(nx);
//                }
            }

        }
        cout&lt;&lt;minx&lt;&lt;endl;
    }
    return 0;
}

</code></pre> 
<br> 
<p align="left"> 3.运行结果：</p> 
<p align="left"><img src="https://images2.imgbox.com/9b/1e/GfLsbc1R_o.png" alt=""><br></p> 
<p> </p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed2844027995001d1c888fbded151535/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小程序画圆</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/98b887076ffc482917689bee58e5fbce/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">结构体变量的输入输出</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>