<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单调栈第二天 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="单调栈第二天" />
<meta property="og:description" content="目录
503.下一个更大元素II
看到题目的第一想法
看到代码随想录的想法
自己实现时出现的困难
42. 接雨水
看到题目的第一想法
看到代码随想录的第一想法
自己实现时遇到的困难
503.下一个更大元素II 力扣题目链接(opens new window)
给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。
示例 1:
输入: [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 看到题目的第一想法 利用昨天的单调栈的思路来写
但是它是循环数组该怎么解决？
遍历完一次后再遍历一次，将栈中剩余的弹出
最后剩余的赋值为-1
成功做出来
看到代码随想录的想法 没有我这么麻烦，for循环范围放大为2*length，nums[i%length]取模，逻辑和之前相同
若当前比栈里的小则直接存入
若当前比栈里的大，则弹出，栈顶下标对应的第一个最大值为栈里的值
自己实现时出现的困难 把result全部赋值为-1 自己就不用处理-1了
class Solution { public int[] nextGreaterElements(int[] nums) { //也是用单调栈来写？ //for循环两次到末尾 Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); //需要遍历到当前下标的前一个位置？ stack.push(0); int[] result = new int[nums.length]; for(int i=1;i&lt;nums.length;i&#43;&#43;){ if(nums[stack." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3ec7be9531a8474258f49ff45fc0d8cd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-29T20:02:40+08:00" />
<meta property="article:modified_time" content="2024-01-29T20:02:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单调栈第二天</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="_503-下一个更大元素ii-toc" style="margin-left:0px;"><a href="#_503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii" rel="nofollow">503.下一个更大元素II</a></p> 
<p id="%E7%9C%8B%E5%88%B0%E9%A2%98%E7%9B%AE%E7%9A%84%E7%AC%AC%E4%B8%80%E6%83%B3%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E7%9C%8B%E5%88%B0%E9%A2%98%E7%9B%AE%E7%9A%84%E7%AC%AC%E4%B8%80%E6%83%B3%E6%B3%95" rel="nofollow">看到题目的第一想法</a></p> 
<p id="%E7%9C%8B%E5%88%B0%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%9A%84%E6%83%B3%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E7%9C%8B%E5%88%B0%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%9A%84%E6%83%B3%E6%B3%95" rel="nofollow">看到代码随想录的想法</a></p> 
<p id="%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9B%B0%E9%9A%BE-toc" style="margin-left:80px;"><a href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9B%B0%E9%9A%BE" rel="nofollow">自己实现时出现的困难</a></p> 
<p id="_42-接雨水-toc" style="margin-left:0px;"><a href="#_42-%E6%8E%A5%E9%9B%A8%E6%B0%B4" rel="nofollow">42. 接雨水</a></p> 
<p id="%E7%9C%8B%E5%88%B0%E9%A2%98%E7%9B%AE%E7%9A%84%E7%AC%AC%E4%B8%80%E6%83%B3%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E7%9C%8B%E5%88%B0%E9%A2%98%E7%9B%AE%E7%9A%84%E7%AC%AC%E4%B8%80%E6%83%B3%E6%B3%95" rel="nofollow">看到题目的第一想法</a></p> 
<p id="%E7%9C%8B%E5%88%B0%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%9A%84%E7%AC%AC%E4%B8%80%E6%83%B3%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E7%9C%8B%E5%88%B0%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%9A%84%E7%AC%AC%E4%B8%80%E6%83%B3%E6%B3%95" rel="nofollow">看到代码随想录的第一想法</a></p> 
<p id="%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9B%B0%E9%9A%BE-toc" style="margin-left:80px;"><a href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9B%B0%E9%9A%BE" rel="nofollow">自己实现时遇到的困难</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="_503-下一个更大元素ii">503.下一个更大元素II</h2> 
<p><a href="https://leetcode.cn/problems/next-greater-element-ii/" rel="nofollow" title="力扣题目链接(opens new window)">力扣题目链接(opens new window)</a></p> 
<p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p> 
<p>示例 1:</p> 
<ul><li>输入: [1,2,1]</li><li>输出: [2,-1,2]</li><li>解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</li></ul> 
<p></p> 
<h4 id="%E7%9C%8B%E5%88%B0%E9%A2%98%E7%9B%AE%E7%9A%84%E7%AC%AC%E4%B8%80%E6%83%B3%E6%B3%95">看到题目的第一想法</h4> 
<p>        利用昨天的单调栈的思路来写</p> 
<p>        但是它是循环数组该怎么解决？</p> 
<p>        遍历完一次后再遍历一次，将栈中剩余的弹出</p> 
<p>        最后剩余的赋值为-1</p> 
<p>        成功做出来</p> 
<p></p> 
<h4 id="%E7%9C%8B%E5%88%B0%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%9A%84%E6%83%B3%E6%B3%95">看到代码随想录的想法</h4> 
<p>        没有我这么麻烦，for循环范围放大为2*length，nums[i%length]取模，逻辑和之前相同</p> 
<p>        若当前比栈里的小则直接存入</p> 
<p>        若当前比栈里的大，则弹出，栈顶下标对应的第一个最大值为栈里的值</p> 
<h4 id="%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9B%B0%E9%9A%BE">自己实现时出现的困难</h4> 
<p>        <strong>把result全部赋值为-</strong>1 自己就不用处理-1了</p> 
<p></p> 
<pre><code>class Solution {
    public int[] nextGreaterElements(int[] nums) {
        //也是用单调栈来写？
        //for循环两次到末尾
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        //需要遍历到当前下标的前一个位置？
        stack.push(0);
        int[] result = new int[nums.length];
        for(int i=1;i&lt;nums.length;i++){
            if(nums[stack.peek()]&gt;=nums[i]){
                stack.push(i);
            }else{
                while(!stack.isEmpty()&amp;&amp;nums[stack.peek()]&lt;nums[i]){
                    result[stack.peek()] = nums[i];
                    stack.pop();
                }
                //不要忘了把这个值也push进去
                stack.push(i);
            }
        }
        //此时stack中残留的元素:
        //1 nums[i]末尾的元素
        //2 比较大的几个元素
        if(!stack.isEmpty()){
        for(int i=0;i&lt;nums.length;i++){            
            while(!stack.isEmpty()&amp;&amp;nums[stack.peek()]&lt;nums[i]){
                    //弹出来的下标对应result 的下标
                    result[stack.peek()] = nums[i];
                    stack.pop();
            }
        }
        }
        while(!stack.isEmpty()){
            result[stack.peek()] = -1;
            stack.pop();
        }
        return result;
    }
}</code></pre> 
<h2 id="_42-接雨水">42. 接雨水</h2> 
<p><a href="https://leetcode.cn/problems/trapping-rain-water/" rel="nofollow" title="力扣题目链接(opens new window)">力扣题目链接(opens new window)</a></p> 
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p> 
<p>示例 1：</p> 
<p></p> 
<p class="img-center"><img alt="" height="161" src="https://images2.imgbox.com/a3/6b/FT7V2VLP_o.png" width="412"></p> 
<ul><li>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</li><li>输出：6</li><li>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</li></ul> 
<h4>看到题目的第一想法</h4> 
<p></p> 
<p>        用单调栈，没想清楚处理逻辑，要怎么计算雨水</p> 
<p></p> 
<h4 id="%E7%9C%8B%E5%88%B0%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%9A%84%E7%AC%AC%E4%B8%80%E6%83%B3%E6%B3%95">看到代码随想录的第一想法</h4> 
<p></p> 
<p>       用单调栈，</p> 
<p>       遇到第一个比栈顶大的元素时，弹出栈顶做记录，再利用当前遍历到的值计算差值和下标差值</p> 
<p>        栈顶值(中间值)和栈顶的第二个值(前一个比栈顶大的)，当前下标(当前比栈顶大的)</p> 
<p>        </p> 
<p>        每次计算的是以栈顶值为底部能存放的雨水容量，累加起来</p> 
<p>        选择两边的最小值，然后再与栈底的差值做计算</p> 
<h4 id="%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9B%B0%E9%9A%BE">自己实现时遇到的困难</h4> 
<p>         if(height[i]==height[stack.peek()])</p> 
<p>        遍历时，当遇到栈顶与当前数值相等时，进栈的应该是第二个元素，因为要考虑下标</p> 
<pre><code class="hljs">class Solution {
    public int trap(int[] height) {
        //卡哥思路 ，单调栈
        //遇到第一个比当前大的，则弹出第一个，记录，再弹出第二个，取弹出的第二个和当前的最小值，同时下标的差值进行雨水面积计算
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int startIndex = 0;
        while(startIndex&lt;height.length-1&amp;&amp;height[startIndex]&lt;=height[startIndex+1]){
            startIndex++;
        }
        if(startIndex==height.length-1){
            return 0;
        }
        stack.push(startIndex);
        int maxArea = 0;
        for(int i=startIndex+1;i&lt;height.length;i++){
            if(height[i]&lt;height[stack.peek()]){
                stack.push(i);
            }else if(height[i]==height[stack.peek()]){
                //不能直接continue，或者说如果前面和后面相等，必须push后面的那个，比如说
                // [9,6,8,8,5,6,3] 这两个相等的8 必须push 后面这个8的下标
                //弹出前面那个
                stack.pop();
                stack.push(i);
                continue;
            }else{
                //弹出第一个栈顶,记录
                //用第二个栈顶来进行计算，取当前heit[i]和第二个栈顶的最小值，来进行计算
                while(!stack.isEmpty()&amp;&amp;height[stack.peek()]&lt;height[i]){
                        //弹出第一个
                        int topOne = stack.pop();
                        //高度为 当前高度(第二低点，于当前选中元素的最小值)减去 最低点
                        if(!stack.isEmpty()){
                        int h = Math.min(height[i],height[stack.peek()])-height[topOne];
                        maxArea += h*(i-stack.peek()-1);
                        }   
                }
                stack.push(i);
            }
        }
        return maxArea;
    }
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/43fe7edd9c9dbfb7ae796f41667c8a1c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VUE3安装vite-plugin-vue-setup-extend 直接script写name</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3b0be0d87a05596f8a730df1473f999f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Apache Paimon 介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>