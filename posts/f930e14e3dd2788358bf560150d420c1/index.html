<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Top100 数组 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Top100 数组" />
<meta property="og:description" content="1.53. 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：
输入：nums = [1] 输出：1 示例 3：
输入：nums = [5,4,-1,7,8] 输出：23 提示：
1 &lt;= nums.length &lt;= 10^5-10^4 &lt;= nums[i] &lt;= 10^4 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
思路： 1)按照前缀和，进行遍历，代码如下，超时，不可以了，而且时间复杂度有点高，需要优化！
2)
代码： class Solution(object): def maxSubArray(self, nums): sum_s=[nums[0]] max_s=nums[0] for i in range(1,len(nums)): sum_s.append(sum_s[i-1]&#43;nums[i])#前缀和 max_s=max(max_s,sum_s[i-1]&#43;nums[i]) for j in range(0,i): max_s=max(sum_s[i]-sum_s[j],max_s) return max_s 超时！没必要保存，也没必要内存循环去计算，因为只需要求值，改进如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f930e14e3dd2788358bf560150d420c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-29T18:14:19+08:00" />
<meta property="article:modified_time" content="2024-01-29T18:14:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Top100 数组</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.<a href="https://leetcode.cn/problems/maximum-subarray/" rel="nofollow" title="53. 最大子数组和">53. 最大子数组和</a></h2> 
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p> 
<p><strong>子数组 </strong>是数组中的一个连续部分。</p> 
<blockquote> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>nums = [-2,1,-3,4,-1,2,1,-5,4]
<strong>输出：</strong>6
<strong>解释：</strong>连续子数组 [4,-1,2,1] 的和最大，为 6 。
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>nums = [1]
<strong>输出：</strong>1
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>nums = [5,4,-1,7,8]
<strong>输出：</strong>23
</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul> 
 <p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p> 
</blockquote> 
<p></p> 
<h3>思路：</h3> 
<p>1)按照前缀和，进行遍历，代码如下，超时，不可以了，而且时间复杂度有点高，需要优化！</p> 
<p>2)</p> 
<p></p> 
<h3>代码：</h3> 
<pre><code>class Solution(object):
    def maxSubArray(self, nums):
        sum_s=[nums[0]]
        max_s=nums[0]
        for i in range(1,len(nums)):
            sum_s.append(sum_s[i-1]+nums[i])#前缀和
            max_s=max(max_s,sum_s[i-1]+nums[i])
            for j in range(0,i):
                max_s=max(sum_s[i]-sum_s[j],max_s)

        return max_s</code></pre> 
<p>超时！没必要保存，也没必要内存循环去计算，因为只需要求值，改进如下：</p> 
<pre><code>class Solution(object):
    def maxSubArray(self, nums):
        pre=0
        max_s=nums[0]
        for i in nums:
            pre=max(pre+i,i)
            max_s=max(max_s,pre)
        return max_s</code></pre> 
<p>java: </p> 
<pre><code>public class Solution {

    public int maxSubArray(int[] nums) {
        int pre = 0;
        int res = nums[0];
        for (int num : nums) {
            pre = Math.max(pre + num, num);
            res = Math.max(res, pre);
        }
        return res;
    }
}
</code></pre> 
<p> 鸣谢：<a href="https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai" rel="nofollow" title="力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p> 
<h2>2.<a href="https://leetcode.cn/problems/merge-intervals/" rel="nofollow" title="56. 合并区间">56. 合并区间</a></h2> 
<p> 以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p> 
<blockquote> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>intervals = [[1,3],[2,6],[8,10],[15,18]]
<strong>输出：</strong>[[1,6],[8,10],[15,18]]
<strong>解释：</strong>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>intervals = [[1,4],[4,5]]
<strong>输出：</strong>[[1,5]]
<strong>解释：</strong>区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= intervals.length &lt;= 10^4</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 10^4</code></li></ul> 
</blockquote> 
<h3>思路：</h3> 
<p>1）暴力：创建一个哈希表，以自然数为序，值为1做标记，代表该元素属于区间内；先扫描intervals数组，每个子列表从starti到endi依次进行判断标记，未出现过则置1，期间要记录一下最大endi（这是下一步扫描的结束点）；执行结束后扫描哈希表，并设置一flag，创建空的工作列表：当flag为flase且出现1时，将位置序i加入新列表中<strong>两次</strong>，并将flag置为true；当出现1但flag为true时，将末尾元素删除加入新的位置序（或置换）；当出现0时，flag置为flase，且将已有列表加入res结果数组，并将工作列表清空。</p> 
<p>2）官解思想——排序：</p> 
<p>如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。如下图所示，标记为蓝色、黄色和绿色的区间分别可以合并成一个大区间，它们在排完序的列表中是连续的：</p> 
<p><img alt="" height="219" src="https://images2.imgbox.com/81/21/qaXuRWQu_o.png" width="836"></p> 
<p>我们用数组 merged 存储最终的答案。首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：</p> 
<ol><li>如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；</li><li>否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。</li></ol> 
<h3>代码：</h3> 
<p>python</p> 
<pre><code>class Solution:
    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:
        
        #先按照starti进行排序
        intervals.sort(key=lambda x: x[0])

        merged = []
        for interval in intervals:
            # 如果列表为空，或者当前区间与上一区间不重合，直接添加
            if not merged or merged[-1][1] &lt; interval[0]:
                merged.append(interval)
            else:
                # 否则的话，我们就可以与上一区间进行合并
                merged[-1][1] = max(merged[-1][1], interval[1])

        return merged

</code></pre> 
<h2 style="background-color:transparent;">3.<a href="https://leetcode.cn/problems/rotate-array/" rel="nofollow" title="189. 轮转数组">189. 轮转数组</a></h2> 
<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code><em> </em>个位置，其中 <code>k</code><em> </em>是非负数。</p> 
<blockquote> 
 <p><strong>示例 1:</strong></p> 
 <pre><strong>输入:</strong> nums = [1,2,3,4,5,6,7], k = 3
<strong>输出:</strong> <code>[5,6,7,1,2,3,4]</code>
<strong>解释:</strong>
向右轮转 1 步: <code>[7,1,2,3,4,5,6]</code>
向右轮转 2 步: <code>[6,7,1,2,3,4,5]
</code>向右轮转 3 步: <code>[5,6,7,1,2,3,4]</code>
</pre> 
 <p><strong>示例 2:</strong></p> 
 <pre><strong>输入：</strong>nums = [-1,-100,3,99], k = 2
<strong>输出：</strong>[3,99,-1,-100]
<strong>解释:</strong> 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li><li><code>0 &lt;= k &lt;= 10^5</code></li></ul> 
</blockquote> 
<h3>思路：</h3> 
<p>1.笨办法，用空间换时间，用辅助数组来存。</p> 
<p>2.本题是右旋转，其实就是反转的顺序改动一下，优先反转整个字符串，步骤如下：</p> 
<ol><li>反转整个字符串</li><li>反转区间为前k的子串</li><li>反转区间为k到末尾的子串</li></ol> 
<h3>代码：</h3> 
<pre><code class="hljs">class Solution(object):
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        new=[]
        n=len(nums)
        for i in range(k%n,0,-1):
            new.append(nums[-i])
        for i in range(n-k%n):
            new.append(nums[i])
            print(new)
        for i in range(n):
            nums[i]=new[i]
</code></pre> 
<p>会超时，优化一下！</p> 
<p>我直接求助卡哥：（来自代码随想录python）</p> 
<pre><code class="hljs">class Solution:
    def rotate(self, A: List[int], k: int) -&gt; None:
        def reverse(i, j):
            while i &lt; j:
                A[i], A[j] = A[j], A[i]
                i += 1
                j -= 1
        n = len(A)
        k %= n
        reverse(0, n - 1)
        reverse(0, k - 1)
        reverse(k, n - 1)
</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h2 style="background-color:transparent;">4.<a href="https://leetcode.cn/problems/product-of-array-except-self/" rel="nofollow" title="238. 除自身以外数组的乘积">238. 除自身以外数组的乘积</a></h2> 
<p> 给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p> 
<p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在  <strong>32 位</strong> 整数范围内。</p> 
<p>请 <strong>不要使用除法，</strong>且在 <code>O(<em>n</em>)</code> 时间复杂度内完成此题。</p> 
<blockquote> 
 <p><strong>示例 1:</strong></p> 
 <pre><strong>输入:</strong> nums = <code>[1,2,3,4]</code>
<strong>输出:</strong> <code>[24,12,8,6]</code></pre> 
 <p><strong>示例 2:</strong></p> 
 <pre><strong>输入:</strong> nums = [-1,1,0,-3,3]
<strong>输出:</strong> [0,0,9,0,0]
</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>2 &lt;= nums.length &lt;= 10^5</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li><strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在  <strong>32 位</strong> 整数范围内</li></ul> 
 <p></p> 
 <p><strong>进阶：</strong>你可以在 <code>O(1)</code> 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 <strong>不被视为 </strong>额外空间。）</p> 
</blockquote> 
<h3>思路：</h3> 
<p>1.哈哈哈哈哈，我一眼克拉默法则求根，求出所有积，各自除哈哈哈！（开玩笑的，这个不允许）</p> 
<p>2.不能使用除法，那就是考虑两边向中间计算，用两次遍历，分别计算前缀积？（也就是求某一个元素的的前缀积？和后缀积？），然后把该位置上的前缀X后缀，就可以得到了<br> 时间复杂度O(n)</p> 
<h3>代码：</h3> 
<pre><code class="hljs">class Solution(object):
    def productExceptSelf(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        n=len(nums)
        pre=[nums[0]]
        post=[nums[n-1]]
        for i in range(1,n):
            pre.append(pre[i-1]*nums[i])
            post.append(post[i-1]*nums[n-1-i])#虽然从前往后，但用的时候从后往前
        result=[post[n-2]]
        print(result)
        for i in range(1,n):
            result.append(pre[i-1]*post[n-2-i])
            # print(result)
        result[n-1]=pre[n-2]
        return result</code></pre> 
<p>里面有些细节需要扣一扣，在考虑边界的问题上需要特别注意！！（不过还是一遍遍debug最后得到结果，来得最踏实）</p> 
<h2>5.<a href="https://leetcode.cn/problems/first-missing-positive/" rel="nofollow" title="41. 缺失的第一个正数">41. 缺失的第一个正数</a></h2> 
<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p> 
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p> 
<blockquote> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>nums = [1,2,0]
<strong>输出：</strong>3
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>nums = [3,4,-1,1]
<strong>输出：</strong>2
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>nums = [7,8,9,11,12]
<strong>输出：</strong>1
</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= nums.length &lt;= 5 * 10^5</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li></ul> 
</blockquote> 
<h3>思路：</h3> 
<p></p> 
<p></p> 
<h3>代码：</h3> 
<pre><code class="hljs">class Solution(object):
    def firstMissingPositive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums.sort()
        xxx=nums[-1]
        if xxx &lt; 0 or nums[0] &gt; 1 :
            return 1
        else:
            temp=nums[0]+1
        while temp &lt;= xxx+1 :
            if temp not in nums and temp &gt; 0:
                return temp
            else:
                temp+=1</code></pre> 
<p>超时了，哭死！看个大佬的java题解吧！学！好好学！</p> 
<pre><code class="hljs">import java.util.HashSet;
import java.util.Set;

public class Solution {

    public int firstMissingPositive(int[] nums) {
        int len = nums.length;

        Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();
        for (int num : nums) {
            hashSet.add(num);
        }

        for (int i = 1; i &lt;= len ; i++) {
            if (!hashSet.contains(i)){
                return i;
            }
        }

        return len + 1;
    }
}

</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aabf107a642def7923106171dcdcfcbb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">力扣（leetcode）第118题杨辉三角（Python）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0194b9ed4190f3bbb6d3807ae77f672a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[GN] 设计模式——面向对象设计原则概述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>