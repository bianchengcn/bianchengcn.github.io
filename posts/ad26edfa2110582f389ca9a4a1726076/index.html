<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>将两个有序链表合并 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="将两个有序链表合并" />
<meta property="og:description" content="将两个有序链表合并
思路：
1）设定两个指针，分别指向链表1的头和链表2的头;
2）创建新得链表头p;
3）如果p1的值&lt;p2的值，则p1的值为新链表的头节点值，即p=p1-&gt;value;
反之，则p2的值为新链表的头节点值，即p=p2-&gt;value;
4）对于剩下的链表用同样的方式进行比较，将较小的值拿去新链表并与上个数值链接起来。
5）可以采用递归实现，后面剩余节点的比较
6）特殊情况：当链表1为空时，新得合并链表为链表2；当链表2为空时，新得合并链表为链表1.
#include&lt;iostream&gt; using namespace std; struct Node { int value; Node* next; Node(int v) :value(v) {} }; //创建一个有序链表 Node* CreateList1() { Node *head; Node* n1 = new Node(1); Node* n3 = new Node(3); Node* n5 = new Node(5); Node* n7 = new Node(7); Node* n9 = new Node(9); head = n1; n1-&gt;next = n3; n3-&gt;next = n5; n5-&gt;next = n7; n7-&gt;next = n9; n9-&gt;next = NULL; return head; } Node* CreateList2() { Node* head; Node* n2 = new Node(2); Node* n4 = new Node(4); Node* n6 = new Node(6); Node* n8 = new Node(8); //Node* n10 = new Node(10); head = n2; n2-&gt;next = n4; n4-&gt;next = n6; n6-&gt;next = n8; n8-&gt;next = NULL; return head; } //释放链表空间 void FreeList(Node *head) { if (head == NULL) { return; } else { Node* temp = head-&gt;next; delete head; head = temp; FreeList(head); } } //递归的方式遍历链表中的元素 void BianList(Node* head) { if (head) { cout &lt;&lt; head-&gt;value &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ad26edfa2110582f389ca9a4a1726076/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-15T10:22:02+08:00" />
<meta property="article:modified_time" content="2022-08-15T10:22:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">将两个有序链表合并</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>将两个有序链表合并</p> 
<p>思路：</p> 
<p>1）设定两个指针，分别指向链表1的头和链表2的头;</p> 
<p>2）创建新得链表头p;</p> 
<p>3）如果p1的值&lt;p2的值，则p1的值为新链表的头节点值，即p=p1-&gt;value;</p> 
<p>                               反之，则p2的值为新链表的头节点值，即p=p2-&gt;value;</p> 
<p>4）对于剩下的链表用同样的方式进行比较，将较小的值拿去新链表并与上个数值链接起来。</p> 
<p>5）可以采用递归实现，后面剩余节点的比较</p> 
<p>6）特殊情况：当链表1为空时，新得合并链表为链表2；当链表2为空时，新得合并链表为链表1.</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

struct Node {
    int value;
    Node* next;
    Node(int v) :value(v) {}
};
//创建一个有序链表
Node* CreateList1()
{
    Node *head;
    Node* n1 = new Node(1);
    Node* n3 = new Node(3);
    Node* n5 = new Node(5);
    Node* n7 = new Node(7);
    Node* n9 = new Node(9);
    head = n1;
    n1-&gt;next = n3;
    n3-&gt;next = n5;
    n5-&gt;next = n7;
    n7-&gt;next = n9;
    n9-&gt;next = NULL;
    return head;

}
Node* CreateList2()
{
    Node* head;
    Node* n2 = new Node(2);
    Node* n4 = new Node(4);
    Node* n6 = new Node(6);
    Node* n8 = new Node(8);
    //Node* n10 = new Node(10);
    head = n2;
    n2-&gt;next = n4;
    n4-&gt;next = n6;
    n6-&gt;next = n8;
    n8-&gt;next = NULL;
    return head;

}
//释放链表空间
void FreeList(Node *head)
{
    if (head == NULL)
    {
        return;
    }
    else {
        Node* temp = head-&gt;next;
        delete head;
        head = temp;
        FreeList(head);
    }
}
//递归的方式遍历链表中的元素
void BianList(Node* head)
{
    if (head)
    {
        cout &lt;&lt; head-&gt;value &lt;&lt; "-&gt;";
        BianList(head-&gt;next);
    }
    else {
        cout &lt;&lt; "null" &lt;&lt; endl;
    }
}
Node* ListMerge(Node* head1, Node* head2)
{
    if (head1 == nullptr)
    {
        return head2;
    }
    else if(head2 == nullptr)
    {
        return head1;
    }
    Node* Mergehead = nullptr;
    if (head1-&gt;value &lt; head2-&gt;value)
    {
        Mergehead = head1;
        Mergehead-&gt;next = ListMerge(head1-&gt;next, head2);
    }
    else
    {
        Mergehead = head2;
        Mergehead-&gt;next = ListMerge(head1, head2-&gt;next);
    }
    return Mergehead;
}

int main()
{
    Node* head1 = CreateList1();
    Node* head2 = CreateList2();
    cout &lt;&lt; "合并前输出：" &lt;&lt; endl;
    cout &lt;&lt; "链表1：";
    BianList(head1);
    cout &lt;&lt; "链表2：";
    BianList(head2);
    cout &lt;&lt; "合并后输出：" &lt;&lt; endl;
    Node * Mergehead=ListMerge(head1, head2);
    BianList(Mergehead);
    FreeList(Mergehead);
    return 0;
}</code></pre> 
<p>参考链接：<a href="https://blog.csdn.net/jxh_123/article/details/38371523" title="(19条消息) 算法题：合并两个有序的链表_JXH_123的博客-CSDN博客">(19条消息) 算法题：合并两个有序的链表_JXH_123的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3be9aabe0abd3fb8b8a247112101be4c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用Sqlmap进行SQL注入攻击</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/22b23f822abf9abd2fe63ded38be02f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于C&#43;&#43;调用::CoCreateInstance创建对象提示没有注册类的问题的解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>