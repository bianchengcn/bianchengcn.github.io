<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>46.python之异步 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="46.python之异步" />
<meta property="og:description" content="异步 一般代码是从上而下执行的，比如有3个打印语句，正常执行是从第一个到最后一个按照顺序打印出来，也就是后面的打印语句会等待前面的打印语句执行完后在执行，这个是同步执行，同步意味着有序执行；而异步就是，后面的打印语句不会等待前面的执行完后再执行，也就是说异步不会阻塞其他任务执行，异步意味着无序执行 异步与多线程多进程：
异步是轻量级的线程，可以叫做协程多进程和多线程无法获取函数的返回值，但是异步可以获取函数的返回值，进程池和线程池可以说是有异步的效果，它们可以获取函数的返回值主进程是异步才可以使用异步更适合需要返回值的操作，比如文件读写使用多线程和多进程更适合不需要返回值的操作 async与await关键字
Python3.4后才有的async 定义异步await 执行异步 用法：
# 定义异步函数 async def test(a): return a # 执行异步 async def t2(): res = await test(1) asyncio模块： 调用异步模块执行内置了对异步IO的支持，用于处理异步IO提供了使用协程构建并发应用的工具asyncio提供的框架以事件循环(event loop)为中心，程序开启一个无限的循环，程序会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数 asyncio调用async函数
用法：
async def main(): result = await asyncio.gather(a(),b()) print(result) if __name__ == &#39;__main__&#39;: asyncio.run(main()) 例1：非异步
import time import os def test1(): for i in range(3): print(f&#39;test1,i={i},进程号:{os.getpid()}&#39;) time.sleep(1) def test2(): for j in range(3): print(f&#39;test2,j={j},进程号:{os.getpid()}&#39;) time.sleep(1) if __name__ == &#39;__main__&#39;: # 开始时间 start_time = time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/68eb1cdf90054883f75f7ccf1203eea4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-23T16:49:13+08:00" />
<meta property="article:modified_time" content="2021-08-23T16:49:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">46.python之异步</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_2"></a>异步</h3> 
<ul><li>一般代码是从上而下执行的，比如有3个打印语句，正常执行是从第一个到最后一个按照顺序打印出来，也就是后面的打印语句会等待前面的打印语句执行完后在执行，这个是同步执行，同步意味着有序执行；</li><li>而异步就是，后面的打印语句不会等待前面的执行完后再执行，也就是说异步不会阻塞其他任务执行，异步意味着无序执行</li></ul> 
<p><strong>异步与多线程多进程：</strong></p> 
<ul><li>异步是轻量级的线程，可以叫做协程</li><li>多进程和多线程无法获取函数的返回值，但是异步可以获取函数的返回值，进程池和线程池可以说是有异步的效果，它们可以获取函数的返回值</li><li>主进程是异步才可以使用</li><li>异步更适合需要返回值的操作，比如文件读写使用</li><li>多线程和多进程更适合不需要返回值的操作</li></ul> 
<p><strong>async与await关键字</strong></p> 
<ul><li>Python3.4后才有的</li><li>async 定义异步</li><li>await 执行异步</li></ul> 
<p><strong>用法：</strong></p> 
<pre><code># 定义异步函数
async def test(a):
    return a
    
# 执行异步
async def t2():
    res = await test(1)
</code></pre> 
<h3><a id="asyncio_39"></a>asyncio模块：</h3> 
<ul><li>调用异步模块执行</li><li>内置了对异步IO的支持，用于处理异步IO</li><li>提供了使用协程构建并发应用的工具</li><li>asyncio提供的框架以事件循环(event loop)为中心，程序开启一个无限的循环，程序会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数</li></ul> 
<p><strong>asyncio调用async函数</strong><br> <img src="https://images2.imgbox.com/6e/56/w8bgm2oA_o.png" alt="在这里插入图片描述"></p> 
<p><strong>用法：</strong></p> 
<pre><code>async def main():
    result = await asyncio.gather(a(),b()) 
    print(result)
    
if __name__ == '__main__':
    asyncio.run(main())
</code></pre> 
<p><strong>例1：非异步</strong></p> 
<pre><code>import time
import os

def test1():
    for i in range(3):
        print(f'test1,i={i},进程号:{os.getpid()}')
        time.sleep(1)

def test2():
    for j in range(3):
        print(f'test2,j={j},进程号:{os.getpid()}')
        time.sleep(1)

if __name__ == '__main__':
    # 开始时间
    start_time = time.time()
    test1()
    test2()

    print(f'时间间隔：{time.time()-start_time},进程号：{os.getpid()}')
</code></pre> 
<p>结果：</p> 
<ul><li>按照顺序执行，间隔时间是6s，且所有的任务都是一个进程执行<br> <img src="https://images2.imgbox.com/76/88/o9nYkYe1_o.png" alt="在这里插入图片描述"></li></ul> 
<p><em><strong>例2：异步</strong></em></p> 
<pre><code>import time
import os
import asyncio
import threading

# 定义异步函数
async def test1():
    for i in range(3):
        print(f'test1,i={i},进程号:{os.getpid()},线程名称是：{threading.current_thread().name}')
        # 注意这里的等待时间也要修改成异步
        # time.sleep是cpu阻塞，asyncio.sleep是当前业务阻塞
        await asyncio.sleep(1)
    return "test1"

async def test2():
    for j in range(3):
        print(f'test2,j={j},进程号:{os.getpid()},线程名称是：{threading.current_thread().name}')
        # 注意这里的等待时间也要修改
        await asyncio.sleep(1)
    return "test2"

# 定义主异步函数
async def main():
    # 批量执行异步函数
    result = await asyncio.gather(test1(), test2())
    # 打印函数的返回值
    print(f'函数返回值：{result},线程名称是：{threading.current_thread().name}')
    return '我是主函数'

if __name__ == '__main__':
    # 开始时间
    start_time = time.time()
    # 执行主异步函数
    ar = asyncio.run(main())
    print(f'{ar},线程名称是：{threading.current_thread().name}')

    print(f'时间间隔：{time.time()-start_time},进程号：{os.getpid()},线程名称是：{threading.current_thread().name}')
</code></pre> 
<p>结果：</p> 
<ul><li>2个函数异步执行，时间间隔是3s，进程号相同，有点类似多线程，不过都是一个线程执行的</li><li>它使用一种单线程单进程的的方式实现并发，应用的各个部分彼此合作, 可以显示的切换任务，一般会在程序阻塞I/O操作的时候发生上下文切换如等待读写文件,或者请求网络。</li><li>同时asyncio也支持调度代码在将来的某个特定事件运行，从而支持一个协程等待另一个协程完成，以处理系统信号和识别其他一些事件。<br> <img src="https://images2.imgbox.com/94/7f/FfK9awI5_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="gevent_153"></a>gevent模块：创建协程对象</h3> 
<p><strong>环境准备</strong></p> 
<pre><code>安装 pip install gevent
</code></pre> 
<p><strong>gevent模块方法</strong><br> <img src="https://images2.imgbox.com/61/60/1PVMswzq_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Gevent协程对象的方法：</strong><br> <img src="https://images2.imgbox.com/9c/d9/k9jTBYF1_o.png" alt="在这里插入图片描述"></p> 
<p><strong>例：</strong></p> 
<pre><code>import time
import os
import gevent
import threading

def test1(count):
    for i in range(count):
        print(f'test1,i={i},进程号:{os.getpid()},线程名称是：{threading.current_thread().name}')
        # 注意这里的时间也要修改成异步
        gevent.sleep(1)
    return "test1"

def test2():
    for j in range(3):
        print(f'test2,j={j},进程号:{os.getpid()},线程名称是：{threading.current_thread().name}')
        # 注意这里的时间也要修改
        gevent.sleep(1)
    return "test2"

if __name__ == '__main__':
    # 开始时间
    start_time = time.time()

    # 创建协程对象
    g1 = gevent.spawn(test1, 3)
    g2 = gevent.spawn(test2)

    # 批量处理协程对象
    g_list = [g1, g2]
    result = gevent.joinall(g_list)

    # 打印异步函数的返回值
    # 方式1:
    print(f'test1函数返回值：{g1.get()}')
    # 方式2：
    print(result[0].value, result[1].value)

    print(f'时间间隔：{time.time()-start_time},进程号：{os.getpid()},线程名称是：{threading.current_thread().name}')
</code></pre> 
<p>结果：<br> <img src="https://images2.imgbox.com/35/27/k6n068zg_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/542acd0580f6bec85b3addce1c75a4fc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Java项目】 在线OJ系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d62369d5601343266d813b94c9e3a39/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java - String equalsIgnoreCase() 方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>