<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL进阶】深入理解InnoDB数据页结构 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【MySQL进阶】深入理解InnoDB数据页结构" />
<meta property="og:description" content="【MySQL进阶】深入理解InnoDB数据页结构 参考资料：《MySQL是怎么运行的：从根儿上理解MySQL》。
数据页结构的快速浏览 数据页代表的这块 16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：
从图中可以看出，一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。下边我们用表格的方式来大致描述一下这7个部分都存储一些啥内容（快速的瞅一眼就行了）：
记录在页中的存储 存储的记录会按照我们指定的行格式存储到User Records部分一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了 记录头信息的秘密 为了故事的顺利发展，我们先创建一个表：
mysql&gt; CREATE TABLE page_demo( -&gt; c1 INT, -&gt; c2 INT, -&gt; c3 VARCHAR(10000), -&gt; PRIMARY KEY (c1) -&gt; ) CHARSET = ascii ROW_FORMAT = Compact; Query OK, 0 rows affected (0.03 sec) 这个新创建的 page_demo 表有3个列，其中 c1 和 c2 列是用来存储整数的， c3 列是用来存储字符串的。需要注意的是，我们把 c1 列指定为主键，所以在具体的行格式中InnoDB就没必要为我们去创建那个所谓的 row_id 隐藏列了。而且我们为这个表指定了 ascii 字符集以及 Compact 的行格式。所以这个表中记录的行格式示意图就是这样的：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/889060f230d83bf884ba538192c85c60/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-19T23:24:44+08:00" />
<meta property="article:modified_time" content="2023-03-19T23:24:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL进阶】深入理解InnoDB数据页结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="MySQLInnoDB_0"></a>【MySQL进阶】深入理解InnoDB数据页结构</h2> 
<p>参考资料：《MySQL是怎么运行的：从根儿上理解MySQL》。</p> 
<h3><a id="_4"></a>数据页结构的快速浏览</h3> 
<p>数据页代表的这块 16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：</p> 
<p><img src="https://images2.imgbox.com/d7/2a/abr94uwY_o.png" alt="image-20221101220324116"></p> 
<p>从图中可以看出，一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。下边我们用表格的方式来大致描述一下这7个部分都存储一些啥内容（快速的瞅一眼就行了）：</p> 
<p><img src="https://images2.imgbox.com/96/d6/MYHmfYA3_o.png" alt="image-20221101220439530"></p> 
<h3><a id="_14"></a>记录在页中的存储</h3> 
<ul><li>存储的记录会按照我们指定的行格式存储到User Records部分</li><li>一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分</li><li>当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了</li></ul> 
<p><img src="https://images2.imgbox.com/16/85/XJiCgDOl_o.png" alt="image-20221101220811539"></p> 
<h4><a id="_22"></a>记录头信息的秘密</h4> 
<p>为了故事的顺利发展，我们先创建一个表：</p> 
<pre><code class="prism language-mysql">mysql&gt; CREATE TABLE page_demo(
    -&gt;     c1 INT,
    -&gt;     c2 INT,
    -&gt;     c3 VARCHAR(10000),
    -&gt;     PRIMARY KEY (c1)
    -&gt; ) CHARSET = ascii ROW_FORMAT = Compact;
Query OK, 0 rows affected (0.03 sec)
</code></pre> 
<p>这个新创建的 page_demo 表有3个列，其中 c1 和 c2 列是用来存储整数的， c3 列是用来存储字符串的。需要注意的是，我们把 c1 列指定为主键，所以在具体的行格式中InnoDB就没必要为我们去创建那个所谓的 row_id 隐藏列了。而且我们为这个表指定了 ascii 字符集以及 Compact 的行格式。所以这个表中记录的行格式示意图就是这样的：</p> 
<p><img src="https://images2.imgbox.com/8a/da/rwT20IKG_o.png" alt="image-20221101222444127"></p> 
<p>从图中可以看到，我们特意把 记录头信息 的5个字节的数据给标出来了，说明它很重要，我们再次先把这些 <strong>记录头信息</strong> 中各个属性的大体意思浏览一下（我们目前使用 <strong>Compact</strong> 行格式进行演示）：</p> 
<p><img src="https://images2.imgbox.com/b9/84/4zBoRI85_o.png" alt="image-20221101222608679"></p> 
<p>下边我们试着向 page_demo 表中插入几条记录：</p> 
<pre><code class="prism language-mysql">mysql&gt; INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd'); 
Query OK, 4 rows affected (0.00 sec) 
</code></pre> 
<p>为了方便大家分析这些记录在 页 的 User Records 部分中是怎么表示的，我把记录中头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：</p> 
<p><img src="https://images2.imgbox.com/27/5e/zo2xD4mZ_o.png" alt="image-20221101222910182"></p> 
<p>看这个图的时候需要注意一下，各条记录在 User Records 中存储的时候并没有空隙，这里只是为了大家观看方便才把每条记录单独画在一行中。</p> 
<p>我们对照着这个图来看看<strong>记录头信息</strong>中的各个属性是啥意思：</p> 
<ul><li> <p><strong>delete_mask：</strong></p> 
  <ul><li>这个属性标记着当前记录是否被删除，占用1个二进制位，值为 0 的时候代表记录并没有被删除，为 1 的时候代表记录被删除掉了。</li><li>被删除的记录还在 页 中么？是的，你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的 <strong>垃圾链表</strong> ，在这个链表中的记录占用的空间称之为所谓的 <strong>可重用空间</strong> ，之后如果有新记录插入到表中的话，<strong>可能把这些被删除的记录占用的存储空间覆盖掉</strong>。</li></ul> </li><li> <p><strong>min_rec_mask：</strong></p> 
  <ul><li>B+树的每层非叶子节点中的最小记录都会添加该标记。</li></ul> </li><li> <p>**n_owned ：**这个暂时保密，稍后它就是主角～</p> </li><li> <p><strong>heap_no：</strong></p> 
  <ul><li>这个属性<strong>表示当前记录在本页中的位置</strong>，从图中可以看出来，我们插入的4条记录在本 页 中的位置分别是： 2 、 3 、 4 、 5 。</li><li>是不是少了点啥？是的，怎么不见 heap_no 值为 0 和 1 的记录呢？</li><li>这其实是设计 InnoDB 的大叔们玩的一个小把戏，他们自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为 伪记录 或者 虚拟记录 。这两个伪记录一个代表 最小记录 ，一个代表 最大记录 。</li><li><img src="https://images2.imgbox.com/0e/ff/j22zU4Hp_o.png" alt="image-20221101223918314"></li><li>等一下哈~，记录可以比大小么？是的，记录也可以比大小，对于一条完整的记录来说，比较记录的大小就是比较 主键 的大小。比方说我们插入的4行记录的主键值分别是： 1 、 2 、 3 、 4 ，这也就意味着这4条记录的大小从小到大依次递增。</li><li>由于这两条记录不是我们自己定义的记录，所以它们并不存放在 页 的 User Records 部分，他们被单独放在一个称为 <strong>Infimum + Supremum</strong> 的部分，如图所示：</li><li><img src="https://images2.imgbox.com/63/e4/JYrvc619_o.png" alt="image-20221101224028919"></li><li>从图中我们可以看出来，最小记录和最大记录的 heap_no 值分别是 0 和 1 ，也就是说它们的位置最靠前。</li></ul> </li><li> <p>record_type：</p> 
  <ul><li>这个属性<strong>表示当前记录的类型</strong>，一共有4种类型的记录： 
    <ul><li>0 表示普通记录</li><li>1 表示B+树非叶节点记录</li><li>2 表示最小记录</li><li>3 表示最大记录</li></ul> </li><li>从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的record_type 值都是 0 ，而最小记录和最大记录的 record_type 值分别为 2 和 3 。</li></ul> </li><li> <p>next_record：</p> 
  <ul><li><strong>它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。</strong></li><li>比方说第一条记录的 next_record 值为 32 ，意味着从第一条记录的真实数据的地址处向后找 32 个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个<strong>链表</strong> ，可以通过一条记录找到它的下一条记录。</li><li><strong>下一条记录 是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）</strong></li><li><img src="https://images2.imgbox.com/1b/29/Z04PUcqe_o.png" alt="image-20221101224819448"></li><li>如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：</li><li><img src="https://images2.imgbox.com/db/a2/OfM4lstz_o.png" alt="image-20221101225158276"></li><li>从图中可以看出来，删除第2条记录前后主要发生了这些变化： 第2条记录并没有从存储空间中移除，而是把该条记录的delete_mask值设置为1。 第2条记录的next_record值变为了0，意味着该记录没有下一条记录了。 第1条记录的next_record指向了第3条记录。 还有一点你可能忽略了，就是最大记录的n_owned值从5变成了4，关于这一点的变化我们稍后会详细说明的。</li><li>如果我们再次把这条记录插入到表中的话</li><li><img src="https://images2.imgbox.com/ae/bf/OP6gRFpi_o.png" alt="image-20221101225324511"></li><li>从图中可以看到，InnoDB并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录的存储空间。</li><li>当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。</li></ul> </li></ul> 
<h3><a id="Page_Directory_98"></a>Page Directory（页目录）</h3> 
<p>现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？</p> 
<p>比如说这样的查询语句：</p> 
<pre><code class="prism language-mysql">SELECT * FROM page_demo WHERE c1 = 3;
</code></pre> 
<h4><a id="Innodb_108"></a>Innodb查找方案：</h4> 
<p>我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。设计 InnoDB 的大叔们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：</p> 
<ul><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li><li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li><li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近 页 的尾部的地方，这个地方就是所谓的 Page Directory ，也就是 页目录 （此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为 槽 （英文名： Slot ），所以这个页面目录就是由 槽 组成的。</li></ul> 
<p>比方说现在的 page_demo 表中正常的记录共有6条， InnoDB 会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：</p> 
<p><img src="https://images2.imgbox.com/ad/a0/qDUkdnOs_o.png" alt="image-20221101225810821"></p> 
<p><strong>从这个图中我们需要注意这么几点：</strong></p> 
<ul><li>注意最小和最大记录的头信息中的n_owned属性 最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。 最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li><li>对于最小记录所在的分组只能有 *<strong>1*</strong> 条记录，最大记录所在的分组拥有的记录条数只能在 *<strong>1~8*</strong> 条件之间，剩下的分组中记录的条数范围只能在是 *<strong>4~8*</strong> 条之间。</li><li>所以 最小记录的 n_owned 是 1， 当前最大记录的 n_owned 是 5</li></ul> 
<p><img src="https://images2.imgbox.com/7d/98/qsFa1AeB_o.png" alt="image-20221101230038607"></p> 
<ul><li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li><li>再次添加12条数据</li></ul> 
<p><img src="https://images2.imgbox.com/58/d3/qGP1DTl2_o.png" alt="image-20221101230109464"></p> 
<ul><li> <p>比方说我们想找主键值为6的记录</p> 
  <ul><li>计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 6，所以设置high=2，low保持不变。</li><li>重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low=1，high保持不变。</li><li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。</li><li>我们可以拿到槽1对应的记录(主键值为4)，该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li></ul> </li><li> <p><strong>所以在一个数据页中查找指定主键值的记录的过程分为两步：</strong></p> 
  <ul><li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</li><li>通过记录的 next_record 属性遍历该槽所在的组中的各个记录。</li></ul> </li></ul> 
<h3><a id="Page_Header_144"></a>Page Header（页面头部）</h3> 
<p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第<br> 一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分，它是页 结构的第二部分，这个部分占用固定的 56 个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：</p> 
<p><img src="https://images2.imgbox.com/06/5b/jFrkt30g_o.png" alt="image-20221101230621617"></p> 
<h3><a id="File_Header_151"></a>File Header（文件头部）</h3> 
<p>Page Header 是专门针对 数据页 记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个<br> 槽了呀。我们现在描述的 File Header 针对各种类型的页都通用，也就是说不同类型的页都会以 File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁。 这个部分占用固定的 38 个字节，是由下边这些内容组成的：</p> 
<p><img src="https://images2.imgbox.com/c5/c7/oDFcgj6m_o.png" alt="image-20221101230727633"></p> 
<p><strong>对照着这个表格，我们看几个目前比较重要的部分：</strong></p> 
<ul><li> <p>FIL_PAGE_SPACE_OR_CHKSUM</p> 
  <ul><li>这个代表当前页面的校验和（checksum）。啥是个校验和？就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为 校验和 。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。</li></ul> </li><li> <p>FIL_PAGE_OFFSET</p> 
  <ul><li>每一个页都有一个单独的页号，就跟你的身份证号码一样， InnoDB 通过页号来可以唯一定位一个页。</li></ul> </li><li> <p>FIL_PAGE_TYPE</p> 
  <ul><li>这个代表当前 页 的类型，我们前边说过， InnoDB 为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的 数据页 ，其实还有很多别的类型的页。</li><li>我们存放记录的数据页的类型其实是 FIL_PAGE_INDEX ，也就是所谓的 索引页 。</li></ul> </li><li> <p>FIL_PAGE_PREV 和 FIL_PAGE_NEXT</p> 
  <ul><li>FIL_PAGE_PREV 和 FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过数据页 是有这两个属性的，所以所有的数据页其实是一个双链表，就像这样：</li><li><img src="https://images2.imgbox.com/72/ee/EaYPzxRp_o.png" alt="image-20221101231039843"></li></ul> </li></ul> 
<h3><a id="File_Trailer_172"></a>File Trailer</h3> 
<p>我们知道 InnoDB 存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以 页 为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），设计 InnoDB 的大叔们在每个页的尾部都加了一个 File Trailer 部分，这个部分由 8 个字节组成，可以分成2个小部分：</p> 
<ul><li> <p>前4个字节代表页的校验和</p> <p>这个部分是和 File Header 中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为 File Header 在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在 File Header 中的校验和就代表着已经修改过的页，而在 File Trialer 中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</p> </li><li> <p>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）</p> </li></ul> 
<h3><a id="_182"></a>总结</h3> 
<ul><li> <p>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做 数据页 。</p> </li><li> <p>一个数据页可以被大致划分为7个部分，分别是：</p> 
  <ul><li>File Header ，表示页的一些通用信息，占固定的38字节。</li><li>Page Header ，表示数据页专有的一些信息，占固定的56个字节。</li><li>Infimum + Supremum ，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的 26 个字节。</li><li>User Records ：真实存储我们插入的记录的部分，大小不固定。</li><li>Free Space ：页中尚未使用的部分，大小不确定。</li><li>Page Directory ：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。</li><li>File Trailer ：用于检验页是否完整的部分，占用固定的8个字节。</li></ul> </li><li> <p>每个记录的头信息中都有一个 next_record 属性，从而使页中的所有记录串联成一个 单链表 。</p> </li><li> <p>InnoDB 会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个 槽 ，存放在Page Directory 中，所以在一个页中根据主键查找记录是非常快的，分为两步：</p> 
  <ul><li>通过二分法确定该记录所在的槽。</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li></ul> </li><li> <p>每个数据页的 File Header 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个 双链表.</p> </li><li> <p>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的 LSN 值，如果首部和尾部的校验和和 LSN 值校验不成功的话，就说明同步过程出现了问题。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/104954ec386383ac0fe835fcbee79b17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">YOLO系列之YOLO V1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/462ca62f944b7b85a52780f0b813bd6a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu16安装ClickHouse</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>