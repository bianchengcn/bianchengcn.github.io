<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式-模板方法(TemplateMethod) - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式-模板方法(TemplateMethod)" />
<meta property="og:description" content="什么是模板方法设计模式？ 使用了JAVA的继承机制，在抽象类中定义一个模板方法，该方法引用了若干个抽象方法（由子类实现）或具体方法（子类可以覆盖重写）；
解决的问题？ 1、当功能内部一部分是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
2、编写一个抽象方法，父类提供了多个子类的通用方法，并把一个或者多个方法留给子类去实现，就是一种模板模式。
这个博主有详细解释，看完茅塞顿开，链接：https://blog.csdn.net/u013565163/article/details/79285617
此篇文章只为记录上面这个链接，方便以后自己复习。以下内容为Copy其他博主。 案例场景：
小张的团队最近接受一个需求，实现实现一家咖啡店的冲泡咖啡和茶的冲泡自动化。之前这家咖啡店都是由咖啡师傅手动进行调制咖啡和茶。现在咖啡店需要引入自动化的点单和调制饮料的系统，小张负责实现调制饮料的功能。
咖啡师傅手工冲泡咖啡和茶的流程：
冲泡咖啡：
1、把水煮沸
2、用沸水冲泡咖啡
3、把咖啡倒入杯子
4、加糖和牛奶
冲泡茶：
1、把水煮沸
2、用沸水冲泡茶叶
3、把茶倒入杯子
4、加柠檬
模版方法
模版方法实现冲泡咖啡 小张去了解了一下模版方法。针对上述冲泡步骤进行了思考。应该有一个抽象的对象来描述冲泡饮料这一行为，并且抽象的类实现了具体冲泡对象的共性步骤也就是1.把水煮沸和3.把饮料倒入杯子。有两个具体的子类来具体实现冲泡茶和咖啡。 并且有些客户不需要加调料，那么需要对最后一步进行判断，是否添加调料。
代码实现 冲泡饮料的抽象类 package xuelongjiang.designpartten.templatemethod; /** * * 模板方法 * * * @Author xuelongjiang */ abstract public class CaffeineBeverage { //算法。 抽象类的算法是final 的不允许被子类修改 public final void prepareRecipe(){ //算法的具体步骤 boilWater(); //烧水 brew();//冲泡 pourInCup();// 把饮料倒入杯子 if(hook()){ addCondiments();// 加调料 } } public abstract void brew(); public abstract void addCondiments(); public void boilWater(){ System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/b18c9e84a2b64698e7936efa772ce714/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-10T22:26:43+08:00" />
<meta property="article:modified_time" content="2019-03-10T22:26:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式-模板方法(TemplateMethod)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong>什么是模板方法设计模式？</strong></h3> 
<p>使用了JAVA的继承机制，在抽象类中定义一个模板方法，该方法引用了若干个抽象方法（由子类实现）或具体方法（子类可以覆盖重写）；</p> 
<h3><strong>解决的问题？</strong></h3> 
<p>1、当功能内部一部分是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p> 
<p>2、编写一个抽象方法，父类提供了多个子类的通用方法，并把一个或者多个方法留给子类去实现，就是一种模板模式。</p> 
<p>这个博主有详细解释，看完茅塞顿开，链接：<a href="https://blog.csdn.net/u013565163/article/details/79285617">https://blog.csdn.net/u013565163/article/details/79285617</a></p> 
<h2><span style="color:#f33b45;">此篇文章只为记录上面这个链接，方便以后自己复习。以下内容为Copy其他博主。</span></h2> 
<p>案例场景：</p> 
<p>小张的团队最近接受一个需求，实现实现一家咖啡店的冲泡咖啡和茶的冲泡自动化。之前这家咖啡店都是由咖啡师傅手动进行调制咖啡和茶。现在咖啡店需要引入自动化的点单和调制饮料的系统，小张负责实现调制饮料的功能。</p> 
<p>咖啡师傅手工冲泡咖啡和茶的流程：</p> 
<p>冲泡咖啡：</p> 
<p>1、把水煮沸<br> 2、用沸水冲泡咖啡<br> 3、把咖啡倒入杯子<br> 4、加糖和牛奶</p> 
<p> </p> 
<p>冲泡茶：</p> 
<p>1、把水煮沸<br> 2、用沸水冲泡茶叶<br> 3、把茶倒入杯子<br> 4、加柠檬<br>  </p> 
<h3><strong>模版方法<br> 模版方法实现冲泡咖啡</strong></h3> 
<p><br> 小张去了解了一下模版方法。针对上述冲泡步骤进行了思考。应该有一个抽象的对象来描述冲泡饮料这一行为，并且抽象的类实现了具体冲泡对象的共性步骤也就是1.把水煮沸和3.把饮料倒入杯子。有两个具体的子类来具体实现冲泡茶和咖啡。 <br> 并且有些客户不需要加调料，那么需要对最后一步进行判断，是否添加调料。<br>  </p> 
<h4 id="代码实现">代码实现</h4> 
<h3><strong>冲泡饮料的抽象类</strong></h3> 
<p> </p> 
<pre class="has"><code class="language-java">package xuelongjiang.designpartten.templatemethod;

/**
 *
 * 模板方法
 *
 *
 * @Author xuelongjiang
 */
abstract   public class CaffeineBeverage {

    //算法。 抽象类的算法是final 的不允许被子类修改
     public final  void   prepareRecipe(){

         //算法的具体步骤
         boilWater(); //烧水
         brew();//冲泡
         pourInCup();// 把饮料倒入杯子
         if(hook()){
             addCondiments();// 加调料
         }

    }


   public  abstract  void brew();

   public   abstract  void addCondiments();


    public void boilWater(){

        System.out.println("烧水");
    }


    public  void pourInCup(){
        System.out.println("把饮料倒入杯子");
    }

    /**
     *  钩子，具体实现可以对算法步骤做一些控制
     *
     * @return
     */
    public boolean hook(){
        return true;
    }

}</code></pre> 
<h4> </h4> 
<p>       可以看到我们在冲泡咖啡/茶的抽象类中有一个hook方法，这个方法就是钩子方法。默认返回true，如果冲泡咖啡默认是加调料的那么子类就不用重写hook方法。</p> 
<h3><strong>咖啡类</strong></h3> 
<pre class="has"><code class="language-java">package xuelongjiang.designpartten.templatemethod;

/**
 * @Author xuelongjiang
 */
public class Coffee extends  CaffeineBeverage {


    @Override
    public void brew() {
        System.out.println("用沸水冲泡咖啡粉");
    }

    @Override
    public void addCondiments() {
        System.out.println("加糖和牛奶");
    }

    @Override
    public boolean hook() {
        return super.hook();
    }
}
</code></pre> 
<h3><strong>茶类</strong></h3> 
<pre class="has"><code>package xuelongjiang.designpartten.templatemethod;

/**
 * @Author xuelongjiang
 */
public class Tea extends  CaffeineBeverage {


    @Override
    public void brew() {
        System.out.println("用沸水侵泡茶叶");
    }

    @Override
    public void addCondiments() {
        System.out.println("加柠檬");
    }


    @Override
    public boolean hook() {
        return super.hook();
    }
}
</code></pre> 
<h3> </h3> 
<h3><strong>测试类</strong></h3> 
<pre class="has"><code class="language-java">package xuelongjiang.designpartten.templatemethod;
/**
 * @Author xuelongjiang
 */
public class TemplateMethodTest {


    public static void main(String[] args) {
        CaffeineBeverage caffeineBeverage = new Tea();
        caffeineBeverage.prepareRecipe();

        System.out.println("-------------------");

        caffeineBeverage = new Coffee();
        caffeineBeverage.prepareRecipe();


    }
}
</code></pre> 
<p> </p> 
<p>总结要点</p> 
<p>模版方法定义了算法的步骤，把这些步骤的实现延迟到了子类。<br> 模版方法模式为我们提供了一种代码复用的重要技巧。<br> 模版方法的抽象类可以定义具体方法、抽象方法和钩子。<br> 抽象方法由子类实现。<br> 为了防止子类改变模版方法中的算法，可以将模版方法声明为final<br> 模版方法和策略模式都封装了算法，一个用组合（策略模式），一个用继承（模版方法）。<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5be892391e95611ac34c5a3d8fbe6279/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java基础-抽象类（Abstract）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46caa37fa1e3a6a2399fce1c468fb5cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ubuntu部署网站</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>