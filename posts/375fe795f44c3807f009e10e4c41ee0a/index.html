<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PriorityQueue用法与介绍 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PriorityQueue用法与介绍" />
<meta property="og:description" content="原文链接：PriorityQueue用法与介绍 - 简书 一、PriorityQueue介绍 队列是遵循先进先出（First-In-First-Out）模式的，PriorityQueue类在Java1.5中引入并作为 Java Collections Framework 的一部分。
优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。
优先队列不允许空值，而且不支持non-comparable（不可比较）的对象，比如用户自定义的类。优先队列要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。
优先队列的头是基于自然排序或者Comparator排序的最小元素。如果有多个对象拥有同样的排序，那么就可能随机地取其中任意一个。当我们获取队列时，返回队列的头对象。
优先队列的大小是不受限制的，但在创建时可以指定初始大小。当我们向优先队列增加元素的时候，队列大小会自动增加。
PriorityQueue是非线程安全的，所以Java提供了PriorityBlockingQueue（实现BlockingQueue接口）用于Java多线程环境。
二、实现原理 Java中PriorityQueue通过二叉小顶堆实现，可以用一棵完全二叉树表示（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为PriorityQueue的底层实现。
上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：
leftNo = parentNo*2&#43;1
rightNo = parentNo*2&#43;2
parentNo = (nodeNo-1)/2
通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。
PriorityQueue的peek()和element操作是常数时间，add(),offer(), 无参数的remove()以及poll()方法的时间复杂度都是log(N)。
1.add()&amp;offer() add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。
新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。
上述代码中，扩容函数grow()类似于ArrayList里的grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。
需要注意的是siftUp(int k, E x)方法，该方法用于插入元素x并维持堆的特性。
新加入的元素x可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;= queue[parent]为止。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。
2.element()和peek() element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。
3.remove()和poll() remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。
上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用siftDown()方法对堆进行调整，最后返回原来0下标处的那个元素（也就是最小的那个元素）。重点是siftDown(int k, E x)方法，该方法的作用是从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止。
4.remove(Object o) remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果有多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。
三、PriorityQueue实现大顶堆 参考文献：https://blog.csdn.net/u010623927/article/details/87179364" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/375fe795f44c3807f009e10e4c41ee0a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-28T19:17:56+08:00" />
<meta property="article:modified_time" content="2022-04-28T19:17:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PriorityQueue用法与介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>原文链接：<a href="https://www.jianshu.com/p/8c1f8baa0852" rel="nofollow" title="PriorityQueue用法与介绍 - 简书">PriorityQueue用法与介绍 - 简书</a></h2> 
<h2>一、PriorityQueue介绍</h2> 
<p>    队列是遵循先进先出（First-In-First-Out）模式的，PriorityQueue类在Java1.5中引入并作为 <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.journaldev.com%2F1260%2Fjava-collections-framework-tutorial" rel="nofollow" title="Java Collections Framework">Java Collections Framework</a> 的一部分。</p> 
<p>    优先队列中的元素可以默认自然排序或者通过提供的<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.journaldev.com%2F780%2Fjava-comparable-and-comparator-example-to-sort-objects" rel="nofollow" title="Comparator">Comparator</a>（比较器）在队列实例化的时排序。</p> 
<p><strong>    优先队列不允许空值，而且不支持non-comparable（不可比较）的对象，比如用户自定义的类。优先队列要求使用<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.journaldev.com%2F780%2Fjava-comparable-and-comparator-example-to-sort-objects" rel="nofollow" title="Java Comparable和Comparator接口">Java Comparable和Comparator接口</a>给对象排序，并且在排序时会按照优先级处理其中的元素。</strong></p> 
<p>    优先队列的头是基于自然排序或者<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.journaldev.com%2F780%2Fjava-comparable-and-comparator-example-to-sort-objects" rel="nofollow" title="Comparator">Comparator</a>排序的最小元素。如果有多个对象拥有同样的排序，那么就可能随机地取其中任意一个。当我们获取队列时，返回队列的头对象。</p> 
<p>    优先队列的大小是不受限制的，但在创建时可以指定初始大小。当我们向优先队列增加元素的时候，队列大小会自动增加。</p> 
<p>    <strong>PriorityQueue是非线程安全的</strong>，所以Java提供了PriorityBlockingQueue（实现<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.journaldev.com%2F1034%2Fjava-blockingqueue-example-implementing-producer-consumer-problem" rel="nofollow" title="BlockingQueue接口">BlockingQueue接口</a>）用于<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.journaldev.com%2F1079%2Fjava-thread-tutorial" rel="nofollow" title="Java多线程环境">Java多线程环境</a>。</p> 
<p></p> 
<h2>二、实现原理</h2> 
<p>        Java中PriorityQueue通过二叉小顶堆实现，可以用一棵完全二叉树表示（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b4/e0/0XmQg6YO_o.png"></p> 
<p></p> 
<p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p> 
<p>leftNo = parentNo*2+1</p> 
<p>rightNo = parentNo*2+2</p> 
<p>parentNo = (nodeNo-1)/2</p> 
<p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p> 
<p><em>PriorityQueue</em>的peek()和element操作是常数时间，add(),offer(), 无参数的remove()以及poll()方法的时间复杂度都是<em>log(N)</em>。</p> 
<p></p> 
<h3>1.add()&amp;offer()</h3> 
<p>        add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，<strong>前者在插入失败时抛出异常，后则则会返回false。</strong>对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/58/1b/ne6iVm6n_o.png"></p> 
<p></p> 
<p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b2/4d/eHEsqcv3_o.png"></p> 
<p></p> 
<p>上述代码中，扩容函数grow()类似于ArrayList里的grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。</p> 
<p>需要注意的是siftUp(int k, E x)方法，该方法用于插入元素x并维持堆的特性。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9c/9f/YibgdUm5_o.png"></p> 
<p></p> 
<p>新加入的元素x可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;= queue[parent]为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p> 
<p></p> 
<h3>2.element()和peek()</h3> 
<p>            element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以<strong>直接返回数组0下标处的那个元素即可</strong>。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/90/68/m2zxKEGd_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/52/7d/XYjFvwhC_o.png"></p> 
<p></p> 
<h3>3.remove()和poll()</h3> 
<p>        remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d4/9c/IaBirR11_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4a/92/yavtaZFS_o.png"></p> 
<p></p> 
<p>上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用siftDown()方法对堆进行调整，最后返回原来0下标处的那个元素（也就是最小的那个元素）。重点是siftDown(int k, E x)方法，该方法的作用是<strong>从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止</strong>。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/80/dc/px43EW0k_o.png"></p> 
<p></p> 
<h3>4.remove(Object o)</h3> 
<p>remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d3/ec/Aik46xHU_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2f/8f/r8t6U0BN_o.png"></p> 
<p></p> 
<p></p> 
<h2>三、PriorityQueue实现大顶堆</h2> 
<h2>        </h2> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c0/b3/eRHKGLnx_o.png"></p> 
<p></p> 
<p>参考文献：https://blog.csdn.net/u010623927/article/details/87179364</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7663479a9791ddc640d9bfa8ed94adb9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java全栈知识体系（pdai入口）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dde91705878cbce8a9f5b3ebe9a5855e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端之HTML</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>