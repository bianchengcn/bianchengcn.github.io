<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ajax调用java程序,从微信小程序到鸿蒙JS开发-JS调用Java - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ajax调用java程序,从微信小程序到鸿蒙JS开发-JS调用Java" />
<meta property="og:description" content="除轻量级智能穿戴设备，现鸿蒙支持的手机、汽车、TV、手表、平板等属于富鸿蒙，在JS语言的项目中也有Java模块，并提供了JS跨语言调用Java方法的技术。现需要实现查看商品评论时，统计出长评、中评和短评的比例，这里将评论数据请求来后调用Java进行计算。
JS调用Java有Ability方式和Internal Ability方式两种，前者可以被不同的JS方法调用，后者适用于与JS业务逻辑关联性强，响应时延要求高的服务。这里采用Ability的方式。
1、新建一个Service Ability
在项目工程目录Java模块中，右键项目的包，New-&gt;Ability-&gt;Empty Service Ability。
在自动生成的众多重载方法中，我们需要用到的是onConnect()。此方法在首次连接时回调，并返回IRemoteObject对象，用于后续的业务通信。
因此创建一个内部类，继承RemoteObject类并实现IRemoteBroker接口。代码框架如下：
publicclass ServiceAbility extends Ability {
private MyRemote remote = new MyRemote();
@Override
publicIRemoteObject onConnect(Intent intent) {
super.onConnect(intent);
returnremote.asObject();
}
staticclass MyRemote extends RemoteObject implements IRemoteBroker {
MyRemote() {
super(&#34;MyService_MyRemote&#34;);
}
MyRemote(String descriptor) {
super(descriptor);
}
@Override
publicboolean onRemoteRequest(intcode, MessageParcel data, MessageParcel reply, MessageOptionoption) {
......
}
@Override
publicIRemoteObject asObject() {
returnthis;
}
}
}
主要需实现的两个方法是onRemoteRequest()和asObject()。在onConnect()方法中返回内部类的示例，asObject()直接返回this即可。onRemoteRequest()是主要需要实现的业务方法，有四个参数：
code：JS端请求时带来的请求码，可根据code进行不同的业务处理。
data：JS端请求时带来的数据，目前仅支持json格式。Java端通过data.readString()获取请求json字符串。
reply：Java端返回给JS端的数据，目前仅支持String格式，通过reply.writeString(str)写入返回数据。
option：JS端指定同步或异步方式，Java端通过option.getFlag()获取。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/be18c48905da04c44421d5118cf029d0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-06T02:34:24+08:00" />
<meta property="article:modified_time" content="2021-08-06T02:34:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ajax调用java程序,从微信小程序到鸿蒙JS开发-JS调用Java</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p align="center"><img src="https://images2.imgbox.com/9d/6d/cWuBhaAa_o.png" alt="1a7db37525f12a48238d7c58f66554f0.png"></p> 
 <p>除轻量级智能穿戴设备，现鸿蒙支持的手机、汽车、TV、手表、平板等属于富鸿蒙，在JS语言的项目中也有Java模块，并提供了JS跨语言调用Java方法的技术。现需要实现查看商品评论时，统计出长评、中评和短评的比例，这里将评论数据请求来后调用Java进行计算。</p> 
 <p>JS调用Java有Ability方式和Internal Ability方式两种，前者可以被不同的JS方法调用，后者适用于与JS业务逻辑关联性强，响应时延要求高的服务。这里采用Ability的方式。</p> 
 <p>1、新建一个Service Ability</p> 
 <p>在项目工程目录Java模块中，右键项目的包，New-&gt;Ability-&gt;Empty Service Ability。</p> 
 <p align="center"><img src="https://images2.imgbox.com/9d/12/ZSODFw36_o.png" alt="8b3cf0e42d80d28ff133500c06b90845.png"></p> 
 <p>在自动生成的众多重载方法中，我们需要用到的是onConnect()。此方法在首次连接时回调，并返回IRemoteObject对象，用于后续的业务通信。</p> 
 <p>因此创建一个内部类，继承RemoteObject类并实现IRemoteBroker接口。代码框架如下：</p> 
 <p>publicclass ServiceAbility extends Ability {<!-- --></p> 
 <p>private MyRemote remote = new MyRemote();</p> 
 <p>@Override</p> 
 <p>publicIRemoteObject onConnect(Intent intent) {<!-- --></p> 
 <p>super.onConnect(intent);</p> 
 <p>returnremote.asObject();</p> 
 <p>}</p> 
 <p>staticclass MyRemote extends RemoteObject implements IRemoteBroker {<!-- --></p> 
 <p>MyRemote() {<!-- --></p> 
 <p>super("MyService_MyRemote");</p> 
 <p>}</p> 
 <p>MyRemote(String descriptor) {<!-- --></p> 
 <p>super(descriptor);</p> 
 <p>}</p> 
 <p>@Override</p> 
 <p>publicboolean onRemoteRequest(intcode, MessageParcel data, MessageParcel reply, MessageOptionoption) {<!-- --></p> 
 <p>......</p> 
 <p>}</p> 
 <p>@Override</p> 
 <p>publicIRemoteObject asObject() {<!-- --></p> 
 <p>returnthis;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>主要需实现的两个方法是onRemoteRequest()和asObject()。在onConnect()方法中返回内部类的示例，asObject()直接返回this即可。onRemoteRequest()是主要需要实现的业务方法，有四个参数：</p> 
 <p>code：JS端请求时带来的请求码，可根据code进行不同的业务处理。</p> 
 <p>data：JS端请求时带来的数据，目前仅支持json格式。Java端通过data.readString()获取请求json字符串。</p> 
 <p>reply：Java端返回给JS端的数据，目前仅支持String格式，通过reply.writeString(str)写入返回数据。</p> 
 <p>option：JS端指定同步或异步方式，Java端通过option.getFlag()获取。</p> 
 <p>2、完善代码逻辑</p> 
 <p>规定JS端每分页加载一次评论数据，就将目前页面中的所有评论内容发送给Java端进行计算。流程和HTTP有一点类似，获取数据、处理数据、返回数据。鸿蒙提供了ZSONObject可供处理json，完整逻辑代码如下：</p> 
 <p>publicclass ServiceAbility extends Ability {<!-- --></p> 
 <p>private MyRemote remote = new MyRemote();</p> 
 <p>@Override</p> 
 <p>publicIRemoteObject onConnect(Intent intent) {<!-- --></p> 
 <p>super.onConnect(intent);</p> 
 <p>returnremote.asObject();</p> 
 <p>}</p> 
 <p>staticclass MyRemote extends RemoteObject implements IRemoteBroker {<!-- --></p> 
 <p>private staticfinalintLIST_COMMENTS = 200;</p> 
 <p>private staticfinalintSUCCESS = 0;</p> 
 <p>private staticfinalintERROR = 500;</p> 
 <p>MyRemote() {<!-- --></p> 
 <p>super("MyService_MyRemote");</p> 
 <p>}</p> 
 <p>MyRemote(String descriptor) {<!-- --></p> 
 <p>super(descriptor);</p> 
 <p>}</p> 
 <p>@Override</p> 
 <p>publicboolean onRemoteRequest(intcode, MessageParcel data, MessageParcel reply, MessageOptionoption) {<!-- --></p> 
 <p>Map result = new HashMap&lt;&gt;(5);</p> 
 <p>if (code == LIST_COMMENTS) {<!-- --></p> 
 <p>// 获取并转化请求数据</p> 
 <p>String req = data.readString();</p> 
 <p>WordReq param = ZSONObject.stringToClass(req, WordReq.class);</p> 
 <p>List comments = param.getList().stream().filter(e -&gt; !"用户未填写评价内容".equals(e)).collect(Collectors.toList());</p> 
 <p>// 统计评论字数</p> 
 <p>intlongComments = (int) comments.stream().mapToInt(String::length).filter(len -&gt; len &gt;= 200).count();</p> 
 <p>intmediumComments = (int) comments.stream().mapToInt(String::length).filter(len -&gt; len &gt;= 30 &amp;&amp; len </p> 
 <p>intshortComments = (int) comments.stream().mapToInt(String::length).filter(len -&gt; len </p> 
 <p>// 计算占比</p> 
 <p>DecimalFormat df = new DecimalFormat("#.00");</p> 
 <p>doublelongPer = 1.0 * longComments / comments.size() * 100;</p> 
 <p>doublemediumPer = 1.0 * mediumComments / comments.size() * 100;</p> 
 <p>doubleshortPer = 1.0 * shortComments / comments.size() * 100;</p> 
 <p>// 返回结果</p> 
 <p>result.put("long", df.format(longPer) +"%");</p> 
 <p>result.put("medium", df.format(mediumPer) +"%");</p> 
 <p>result.put("short", df.format(shortPer) +"%");</p> 
 <p>result.put("code", SUCCESS);</p> 
 <p>result.put("msg","ok");</p> 
 <p>reply.writeString(ZSONObject.toZSONString(result));</p> 
 <p>returntrue;</p> 
 <p>} else{<!-- --></p> 
 <p>result.put("code", ERROR);</p> 
 <p>result.put("msg","invalid code");</p> 
 <p>reply.writeString(ZSONObject.toZSONString(result));</p> 
 <p>returnfalse;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>@Override</p> 
 <p>publicIRemoteObject asObject() {<!-- --></p> 
 <p>returnthis;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>3、JS端远程调用</p> 
 <p>Java服务部分写好了，在JS中，鸿蒙提供了FeatureAbility.callAbility()方法用于单次请求Java服务。其参数如下：</p> 
 <p>bundleName：Ability包名，在config.json中，为app.bundleName。</p> 
 <p>abilityName：调用服务端Ability类名，可省略包名，直接写".XxxAbility"。</p> 
 <p>messageCode：操作码，和Java端的"code"参数相匹配。</p> 
 <p>abilityType：Ability类型，0为Ability，1为Internal Ability。</p> 
 <p>data：请求数据，json类型。</p> 
 <p>syncOption：与Java端"option"相匹配，0为同步方式，1为异步方式。默认同步方式。</p> 
 <p>方法返回一个Promise对象，可通过.then()和.catch()处理调用成功和异常。</p> 
 <p>本例中的方法如下：</p> 
 <p>// 调用Java统计评论长度</p> 
 <p>countWords() {<!-- --></p> 
 <p>let list = [];</p> 
 <p>this.comments.forEach(e =&gt; {<!-- --></p> 
 <p>list.push(e.content);</p> 
 <p>})</p> 
 <p>FeatureAbility.callAbility({<!-- --></p> 
 <p>bundleName: "com.example.litemall",</p> 
 <p>abilityName: ".ServiceAbility",</p> 
 <p>messageCode: 200,</p> 
 <p>abilityType: 0,</p> 
 <p>data: {<!-- --></p> 
 <p>list</p> 
 <p>}</p> 
 <p>}).then(res =&gt; {<!-- --></p> 
 <p>console.info(res);</p> 
 <p>let data = JSON.parse(res);</p> 
 <p>if (data.code == 0) {<!-- --></p> 
 <p>this.lengths[0].value = data.long;</p> 
 <p>this.lengths[1].value = data.medium;</p> 
 <p>this.lengths[2].value = data.short;</p> 
 <p>}</p> 
 <p>}).catch(res =&gt; {<!-- --></p> 
 <p>console.error(res);</p> 
 <p>})</p> 
 <p>}</p> 
 <p>Java端和JS端的代码编译完成并运行，可以看到日志中的返回数据和我们在Java中定义的一致。</p> 
 <p align="center"><img src="https://images2.imgbox.com/ea/ce/SIRHexKx_o.png" alt="52d39868f48d2ce557696139c4eaf57c.png"></p> 
 <p>运行效果：</p> 
 <p align="center"><img src="https://images2.imgbox.com/b1/25/G97CnJbL_o.png" alt="218ee3eea703595d55ca2e6f7aa51984.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/7a/c9/sqNJCGa0_o.png" alt="84c326367220c1b8a4f619c6e2015449.png"></p> 
 <p>但加上Java的部分后，项目编译的速度明显变慢了，如下两步花了很长时间，有没有大神知道有没有什么加速的方法？</p> 
 <p align="center"><img src="https://images2.imgbox.com/86/0f/8JiVONIe_o.png" alt="c46cd9aea9c7dc83ce85d8d73988b75d.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/c8/ea/YlBerFsU_o.png" alt="1805adf15f908701cd21ef3f21c8a875.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/78/f4/dYW1lc6y_o.png" alt="67eeee49b4f6094f6912c511f097e042.png"></p> 
 <p>【编辑推荐】</p> 
 <p>【责任编辑：jianghua TEL：(010)68476606】</p> 
 <p>点赞 0</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c42ac13a7644ace6875db3f3ea8152c5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">日志文件服务器搭建,搭建日志服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/973a239fb8ed51ba53e7e769b94eb115/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ajax注册验证6,ajax注册验证和认证</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>