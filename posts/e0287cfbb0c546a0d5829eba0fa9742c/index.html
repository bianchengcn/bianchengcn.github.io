<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>哈弗结构和冯诺依曼结构的简介和区别 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="哈弗结构和冯诺依曼结构的简介和区别" />
<meta property="og:description" content="冯·诺依曼结构，又称为普林斯顿体系结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。取指令和取操作数都在同一总线上，通过分时复用的方式进行；缺点是在高速运行时，不能达到同时取指令和取操作数，从而形成了传输过程的瓶颈。由于程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同。
冯诺依曼结构：冯诺依曼结构则是将逻辑代码段和变量统一都存储在内存当中，他们之间一般是按照代码的执行顺序依次存储。这样就会导致一个问题，如果当程序出现BUG的时候，由于程序没有对逻辑代码段的读写限定，因此，他将拥有和普通变量一样的读写操作权限。于是就会很容易的死机，一旦他的逻辑执行出现一点该变就会出现非常严重的错误。但是，冯诺依曼结构的好处是可以充分利用有限的内存空间，并且会使CPU对程序的执行十分的方便，不用来回跑。
哈佛结构是一种将程序指令存储和数据存储分开的存储器结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问，目的是为了减轻程序运行时的访存瓶颈。
哈佛结构：哈佛结构就是将程序的逻辑代码和变量分开存放的一种结构，而他们存放的位置可以是形同的也可以是不同的，总是只要是分成两个部分单独访问的结构都可以叫哈佛结构。（例如：51的程序的逻辑代码段放在ROM中，而变量部分则放在ROM中；而ARM的逻辑代码和变量都是存放在RAM（内存）中的，但是，它在内存中划分了两部分的空间，其中一部分放逻辑代码，另一部分方变量。之间不会相互干扰）哈佛结构的优点就是逻辑代码和变量单独存放，使之不会相互干扰，进而当程序出BUG的时候，最多只会修改变量的值，而不会修改程序的执行顺序（逻辑关系）。因此，这种结构大量应用在嵌入式编程当中。
总得来说，哈佛机构的高性能体现在在单片机、DSP芯片平台上运行的程序种类和花样较少，因为各个电子娱乐产品中的软件升级比较少，应用程序可以用汇编作为内核，最高效率的利用流水线技术，获得最高的效率。
冯诺依曼结构主要是基于电脑购买者对电脑的使用途径不同—-各种娱乐型用户、各种专业开发用户等，且安装的软件的种类繁多，升级频繁，多种软件同时运行时处理的优先级比较模糊，因特尔芯片不具备彻底智能分配各程序优先级和流水线的机制，机械的分配优先和流水线反而容易使用户不便。
冯氏结构简单、易实现、成本低，但效率偏低；哈佛结构效率高但复杂，对外围设备的连接与处理要求高，十分不适合外围存储器的扩展。现在的处理器，依托CACHE的存在，已经很好的将二者统一起来了。现在的处理器虽然外部总线上看是诺依曼结构的，但是由于内部CACHE的存在，因此实际上内部来看已经类似改进型哈佛结构的了。
CISC与RISC的区别：
CISC（复杂指令集）:复杂指令集就是CPU在工作的时候需要有很多的汇编指令来完成，它可以用一个汇编指令来完成一件复杂的工作。例如：乘法，加法，乘加，乘减等处理的时候，他会每个处理方式用一条指令来完成。因此这种设计实际上是很强大的，因为同样处理一个运算，它可以用一个机器周期就可以完成了。但是其内部的硬件设计就相对而言的比较复杂了一些。而且，这样的设计势必就会遭成功耗的增加。例如现在的大部分PC机的处理器都是这种的。51单片机也是这种方式的。
RISC（精简指令集）：相对于复杂指令集而言，精简指令集所需要的汇编指令就会少很多了。例如：在完成（1&#43;1）×（2-1）这样的运算的时候，第一次先算1&#43;1等于2然后再算2-1等于1，最后在算2×1等于2。这样他就要经历好几个机器周期才能完成一次运算。而如果用复杂指令集的话可能一次就可以算出来结果了。由于现在的CPU主频基本上在原料不变的情况下是很难再提高他的（主频）运算速度了。所以，精简指令集的CPU在单核的效率上是远不如复杂指令集的CPU的。因此，为了达到与复杂指令集的CPU同样的运算效率，现在的手机经常会增加内核的数量来提升自身的处理效率。
地址总线、数据总线和控制总线的区别（这里的总线主要指外部总线，不包括内核的总线）：
地址总线（Address Bus）：当CPU要处理数据的时候首先地址总线会根据要处理的数据的地址在内存中找到要处理的数据，然后再对其进行相应的处理。也就是说，地址总线的宽度决定了CPU能够处理的数据地址的总量的大小。由于地址总线总是由CPU发起的寻址要求，因此数据总线只能由CPU主动向外部寻找它所需要的地址，而不能被外部的IO主动使用。因此，地址总线是单向（只能由CPU主动去读而不会对其进行写）三态（高电平、低电平、高阻态）的。
数据总线（Data Bus）：当CPU需要读取或写入数据的时候由地址总线先去寻址，然后再由数据总线对所读到的地址进行读或写操作（CPU一次读写的数据总量由数据总线的宽度决定）。最终实现CPU所要实现的相应功能。由于CPU会通过数据总线对所要处理的地址进行读和写两种方式的操作。因此，数据总线是双向三态的。
控制总线（Control Bus）：当CPU要对外部的外设（IO设备或内存）进行操作的时候，控制总线会对相应的外设发出相应的控制指令，然后再由数据总线对其进行操作。由于控制总线要对所有的外设进行控制，因此，他是双向的且十分的灵活，而其总线的宽度也是不确定的，主要有外设的数量决定其宽度。
统一编址和独立编址的区别：
要明白统一编址和独立编址的区别首先要知道CPU在处理数据的时候其实是要先由控制总线发送控制指令，然后再对外设（这里的外设包括IO设备和内存）进行寻址的操作，只有找到了要操作的硬件或内存的地址之后才能对其进行相应的操作。而这个寻址的方式是由CPU对地址的编址方式决定的。而编址方式就分为统一编址和独立编址。
统一编址：统一编址就是当CPU要对IO设备进行操作的时候，就直接由地址总线进行寻址，因为地址总线的宽度是一定的，也就是所寻址的范围是一定的。而如果由它直接对IO设备进行寻址，那势必会占用有限的地址，进而会导致对其能够操作的内存大小就会有所限制。这也就导致了地址总线所能寻到的内存地址并不和自己的总线宽度对应上。（假如一个32位宽度的地址总线本来可以寻址4GB的内存地址，但是由于它一般分外设占用了他的地址，因此，他所能使用的内存就会小于4GB。）
独立编址：独立编址的CPU在对IO设备进行操作的时候会有专门的操作指令，而不会用内存操作指令，这样就会使地址总线仅服务于内存，而不会被其他IO外设占用。也因此会使内存的大小等于地址总线的宽度。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/e0287cfbb0c546a0d5829eba0fa9742c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-28T14:07:59+08:00" />
<meta property="article:modified_time" content="2021-01-28T14:07:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">哈弗结构和冯诺依曼结构的简介和区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>冯·诺依曼结构，又称为普林斯顿体系结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。取指令和取操作数都在同一总线上，通过分时复用的方式进行；缺点是在高速运行时，不能达到同时取指令和取操作数，从而形成了传输过程的瓶颈。由于程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同。</p> 
<p>冯诺依曼结构：冯诺依曼结构则是将逻辑代码段和变量统一都存储在内存当中，他们之间一般是按照代码的执行顺序依次存储。这样就会导致一个问题，如果当程序出现BUG的时候，由于程序没有对逻辑代码段的读写限定，因此，他将拥有和普通变量一样的读写操作权限。于是就会很容易的死机，一旦他的逻辑执行出现一点该变就会出现非常严重的错误。但是，冯诺依曼结构的好处是可以充分利用有限的内存空间，并且会使CPU对程序的执行十分的方便，不用来回跑。</p> 
<p>哈佛结构是一种将程序指令存储和数据存储分开的存储器结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问，目的是为了减轻程序运行时的访存瓶颈。</p> 
<p>哈佛结构：哈佛结构就是将程序的逻辑代码和变量分开存放的一种结构，而他们存放的位置可以是形同的也可以是不同的，总是只要是分成两个部分单独访问的结构都可以叫哈佛结构。（例如：51的程序的逻辑代码段放在ROM中，而变量部分则放在ROM中；而ARM的逻辑代码和变量都是存放在RAM（内存）中的，但是，它在内存中划分了两部分的空间，其中一部分放逻辑代码，另一部分方变量。之间不会相互干扰）哈佛结构的优点就是逻辑代码和变量单独存放，使之不会相互干扰，进而当程序出BUG的时候，最多只会修改变量的值，而不会修改程序的执行顺序（逻辑关系）。因此，这种结构大量应用在嵌入式编程当中。</p> 
<p>总得来说，哈佛机构的高性能体现在在单片机、DSP芯片平台上运行的程序种类和花样较少，因为各个电子娱乐产品中的软件升级比较少，应用程序可以用汇编作为内核，最高效率的利用流水线技术，获得最高的效率。<br> 　　冯诺依曼结构主要是基于电脑购买者对电脑的使用途径不同—-各种娱乐型用户、各种专业开发用户等，且安装的软件的种类繁多，升级频繁，多种软件同时运行时处理的优先级比较模糊，因特尔芯片不具备彻底智能分配各程序优先级和流水线的机制，机械的分配优先和流水线反而容易使用户不便。<br> 　　冯氏结构简单、易实现、成本低，但效率偏低；哈佛结构效率高但复杂，对外围设备的连接与处理要求高，十分不适合外围存储器的扩展。现在的处理器，依托CACHE的存在，已经很好的将二者统一起来了。现在的处理器虽然外部总线上看是诺依曼结构的，但是由于内部CACHE的存在，因此实际上内部来看已经类似改进型哈佛结构的了。</p> 
<p>CISC与RISC的区别：</p> 
<p> <br> CISC（复杂指令集）:复杂指令集就是CPU在工作的时候需要有很多的汇编指令来完成，它可以用一个汇编指令来完成一件复杂的工作。例如：乘法，加法，乘加，乘减等处理的时候，他会每个处理方式用一条指令来完成。因此这种设计实际上是很强大的，因为同样处理一个运算，它可以用一个机器周期就可以完成了。但是其内部的硬件设计就相对而言的比较复杂了一些。而且，这样的设计势必就会遭成功耗的增加。例如现在的大部分PC机的处理器都是这种的。51单片机也是这种方式的。</p> 
<p> </p> 
<p>RISC（精简指令集）：相对于复杂指令集而言，精简指令集所需要的汇编指令就会少很多了。例如：在完成（1+1）×（2-1）这样的运算的时候，第一次先算1+1等于2然后再算2-1等于1，最后在算2×1等于2。这样他就要经历好几个机器周期才能完成一次运算。而如果用复杂指令集的话可能一次就可以算出来结果了。由于现在的CPU主频基本上在原料不变的情况下是很难再提高他的（主频）运算速度了。所以，精简指令集的CPU在单核的效率上是远不如复杂指令集的CPU的。因此，为了达到与复杂指令集的CPU同样的运算效率，现在的手机经常会增加内核的数量来提升自身的处理效率。</p> 
<p> </p> 
<p>地址总线、数据总线和控制总线的区别（这里的总线主要指外部总线，不包括内核的总线）：</p> 
<p> </p> 
<p>地址总线（Address Bus）：当CPU要处理数据的时候首先地址总线会根据要处理的数据的地址在内存中找到要处理的数据，然后再对其进行相应的处理。也就是说，地址总线的宽度决定了CPU能够处理的数据地址的总量的大小。由于地址总线总是由CPU发起的寻址要求，因此数据总线只能由CPU主动向外部寻找它所需要的地址，而不能被外部的IO主动使用。因此，地址总线是单向（只能由CPU主动去读而不会对其进行写）三态（高电平、低电平、高阻态）的。</p> 
<p> </p> 
<p>数据总线（Data Bus）：当CPU需要读取或写入数据的时候由地址总线先去寻址，然后再由数据总线对所读到的地址进行读或写操作（CPU一次读写的数据总量由数据总线的宽度决定）。最终实现CPU所要实现的相应功能。由于CPU会通过数据总线对所要处理的地址进行读和写两种方式的操作。因此，数据总线是双向三态的。</p> 
<p> </p> 
<p>控制总线（Control Bus）：当CPU要对外部的外设（IO设备或内存）进行操作的时候，控制总线会对相应的外设发出相应的控制指令，然后再由数据总线对其进行操作。由于控制总线要对所有的外设进行控制，因此，他是双向的且十分的灵活，而其总线的宽度也是不确定的，主要有外设的数量决定其宽度。</p> 
<p> </p> 
<p>统一编址和独立编址的区别：</p> 
<p>要明白统一编址和独立编址的区别首先要知道CPU在处理数据的时候其实是要先由控制总线发送控制指令，然后再对外设（这里的外设包括IO设备和内存）进行寻址的操作，只有找到了要操作的硬件或内存的地址之后才能对其进行相应的操作。而这个寻址的方式是由CPU对地址的编址方式决定的。而编址方式就分为统一编址和独立编址。</p> 
<p> </p> 
<p>统一编址：统一编址就是当CPU要对IO设备进行操作的时候，就直接由地址总线进行寻址，因为地址总线的宽度是一定的，也就是所寻址的范围是一定的。而如果由它直接对IO设备进行寻址，那势必会占用有限的地址，进而会导致对其能够操作的内存大小就会有所限制。这也就导致了地址总线所能寻到的内存地址并不和自己的总线宽度对应上。（假如一个32位宽度的地址总线本来可以寻址4GB的内存地址，但是由于它一般分外设占用了他的地址，因此，他所能使用的内存就会小于4GB。）</p> 
<p> </p> 
<p>独立编址：独立编址的CPU在对IO设备进行操作的时候会有专门的操作指令，而不会用内存操作指令，这样就会使地址总线仅服务于内存，而不会被其他IO外设占用。也因此会使内存的大小等于地址总线的宽度。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0659cb6167d6ded8a1f9396561842b06/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">漏洞定级标准参考</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f84ade87a11f70c369e6fd5841733bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">三防终端设备简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>