<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Node.js笔记-简介和安装，fs模块，path模块和http模块的使用 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Node.js笔记-简介和安装，fs模块，path模块和http模块的使用" />
<meta property="og:description" content="目录
node.js的简介和安装 简介
安装
在Node.js环境中打印&#34;hello,node.js&#34;
node内置模块-fs模块
readFile()-读取指定文件内容
writeFile()-读取指定文件内容
路径动态拼接的问题
node内置模块-path模块
path.join()-将多个路径进行拼接
path.basename()-获取路径中的文件名
node内置模块-http模块
创建web服务器
request请求对象和response响应对象
根据请求URL不同进行方法分发
将URL映射为本地后输出
node.js的简介和安装 简介 什么是node？
node.js是JavaScript的运行环境，将JS代码放到node环境中，就可以使用node.js提供的内置API，内置API可以对文件，数据库内容进行操作，还可以创建web服务器等许多功能的实现，这样，使用JS代码放到node环境中运行将可以做后端开发。
提到运行环境，node.js环境中不能操作DOM或BOM结构，因为node.js环境不提供操作DOM或BOM的内置API。我们在浏览器环境可以操作DOM或BOM结构是因为在浏览器环境中提供了操作DOM或BOM的内置API。
虽然在node.js环境中不能操作DOM或BOM结构，但是并不影响我们使用node.js的真实需求，我们使用node.js环境是做后端开发，是对数据库的数据操作和web服务器的创建及提供请求接口等功能。所以并不需要在node.js中操作DOM或BOM结构。
总结:使用javascript这个语言通过在node.js环境中执行做了后端的开发工作。
安装 node.js的安装非常简单，我们先到node.js官网。
我们下载LTS版本（稳定版），下载好后打开安装程序，无脑点击下一步即可。
检查是否安装成功
安装好了以后，我们打开命令行，输入node -v（查看版本），出现版本号就算安装成功。
在Node.js环境中打印&#34;hello,node.js&#34; 想要在node.js环境打印东西，那么我们就需要创建一个js文件，并且在node.js环境中运行。
// 在js文件中书写 console.log(&#34;hello,node.js&#34;); 命令行执行 node 文件名
node内置模块-fs模块 说明：fs模块是node内置的模块，可以看作是node内置的一类API。
fs模块作用：主要用来操作文件，模块中提供了一系列的方法和属性，用来对文件的各种操作。
模块的导入：
// js文件中导入模块方式 const fs = require(&#34;fs&#34;); readFile()-读取指定文件内容 方法参数说明
//前提需要先导入模块 fs.readFile(path,[,options],callback)
path:必选，文件路径
[options]:可选，指定编码格式
callback:必选，回调函数，获取读取结果。
使用 需求，定义一个文件&#34;hello.txt&#34;，使用方法fs.readFile()进行读取。
// 导入模块方式 const fs = require(&#34;fs&#34;); fs.readFile(&#34;./hello.txt&#34;,&#34;utf-8&#34;,(err,datastr)=&gt;{ if(err){return console.log(&#34;读取失败!&#34;)} console.log(&#34;读取成功!数据为&#34;,datastr); }) 回调函数的参数说明：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c5093f62617e58dad1637be9abd7fb9d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-09T23:26:27+08:00" />
<meta property="article:modified_time" content="2023-02-09T23:26:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Node.js笔记-简介和安装，fs模块，path模块和http模块的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="node.js%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85%C2%A0-toc" style="margin-left:0px;"><a href="#node.js%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85%C2%A0" rel="nofollow">node.js的简介和安装 </a></p> 
<p id="%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#%E7%AE%80%E4%BB%8B" rel="nofollow">简介</a></p> 
<p id="%E5%AE%89%E8%A3%85-toc" style="margin-left:40px;"><a href="#%E5%AE%89%E8%A3%85" rel="nofollow">安装</a></p> 
<p id="%C2%A0%E5%9C%A8Node.js%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%89%93%E5%8D%B0%22hello%2Cnode.js%22-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%9C%A8Node.js%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%89%93%E5%8D%B0%22hello%2Cnode.js%22" rel="nofollow"> 在Node.js环境中打印"hello,node.js"</a></p> 
<p id="%C2%A0node%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97-fs%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px;"><a href="#%C2%A0node%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97-fs%E6%A8%A1%E5%9D%97" rel="nofollow"> node内置模块-fs模块</a></p> 
<p id="readFile()-%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9-toc" style="margin-left:40px;"><a href="#readFile%28%29-%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9" rel="nofollow">readFile()-读取指定文件内容</a></p> 
<p id="%C2%A0writeFile()-%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9-toc" style="margin-left:40px;"><a href="#%C2%A0writeFile%28%29-%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9" rel="nofollow"> writeFile()-读取指定文件内容</a></p> 
<p id="%E8%B7%AF%E5%BE%84%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#%E8%B7%AF%E5%BE%84%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow">路径动态拼接的问题</a></p> 
<p id="node%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97-path%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px;"><a href="#node%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97-path%E6%A8%A1%E5%9D%97" rel="nofollow">node内置模块-path模块</a></p> 
<p id="path.join()-%E5%B0%86%E5%A4%9A%E4%B8%AA%E8%B7%AF%E5%BE%84%E8%BF%9B%E8%A1%8C%E6%8B%BC%E6%8E%A5-toc" style="margin-left:40px;"><a href="#path.join%28%29-%E5%B0%86%E5%A4%9A%E4%B8%AA%E8%B7%AF%E5%BE%84%E8%BF%9B%E8%A1%8C%E6%8B%BC%E6%8E%A5" rel="nofollow">path.join()-将多个路径进行拼接</a></p> 
<p id="%C2%A0path.basename()-%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D-toc" style="margin-left:40px;"><a href="#%C2%A0path.basename%28%29-%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D" rel="nofollow"> path.basename()-获取路径中的文件名</a></p> 
<p id="node%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97-http%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px;"><a href="#node%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97-http%E6%A8%A1%E5%9D%97" rel="nofollow">node内置模块-http模块</a></p> 
<p id="%E5%88%9B%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%88%9B%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">创建web服务器</a></p> 
<p id="request%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1%E5%92%8Cresponse%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#request%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1%E5%92%8Cresponse%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1" rel="nofollow">request请求对象和response响应对象</a></p> 
<p id="%C2%A0%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82URL%E4%B8%8D%E5%90%8C%E8%BF%9B%E8%A1%8C%E6%96%B9%E6%B3%95%E5%88%86%E5%8F%91-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82URL%E4%B8%8D%E5%90%8C%E8%BF%9B%E8%A1%8C%E6%96%B9%E6%B3%95%E5%88%86%E5%8F%91" rel="nofollow"> 根据请求URL不同进行方法分发</a></p> 
<p id="%E5%B0%86URL%E6%98%A0%E5%B0%84%E4%B8%BA%E6%9C%AC%E5%9C%B0%E5%90%8E%E8%BE%93%E5%87%BA-toc" style="margin-left:40px;"><a href="#%E5%B0%86URL%E6%98%A0%E5%B0%84%E4%B8%BA%E6%9C%AC%E5%9C%B0%E5%90%8E%E8%BE%93%E5%87%BA" rel="nofollow">将URL映射为本地后输出</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="node.js%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85%C2%A0">node.js的简介和安装 </h2> 
<p><img alt="" src="https://images2.imgbox.com/76/f2/NV9un36W_o.jpg"></p> 
<h3 id="%E7%AE%80%E4%BB%8B">简介</h3> 
<p><strong><span style="background-color:#fbd4d0;"> 什么是node？</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>node.js是JavaScript的运行环境</strong>，将JS代码放到node环境中，就可以使用node.js提供的内置API，内置API可以对文件，数据库内容进行操作，还可以创建web服务器等许多功能的实现，这样，使用<strong>JS代码放到node环境中运行将可以做后端开发</strong>。</p> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;">提到运行环境，<strong>node.js环境中不能操作DOM或BOM结构</strong>，因为<strong>node.js环境不提供操作DOM或BOM的内置API</strong>。我们在<strong>浏览器环境可以</strong>操作DOM或BOM结构是因为在<strong>浏览器环境中提供了操作DOM或BOM的内置API</strong>。</p> 
 <p style="margin-left:0;text-align:justify;"></p> 
 <p style="margin-left:0;text-align:justify;">虽然在node.js环境中不能操作DOM或BOM结构，但是并不影响我们使用node.js的真实需求，我们使用node.js环境是做后端开发，是对数据库的数据操作和web服务器的创建及提供请求接口等功能。所以并不需要在node.js中操作DOM或BOM结构。</p> 
 <p style="margin-left:0;text-align:justify;"></p> 
 <p style="margin-left:0;text-align:justify;"><strong>总结:使用javascript这个语言通过在node.js环境中执行做了后端的开发工作</strong>。</p> 
</blockquote> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="302" src="https://images2.imgbox.com/12/85/CMll56nD_o.png" width="503"></p> 
<p></p> 
<h3 id="%E5%AE%89%E8%A3%85">安装</h3> 
<p>node.js的安装非常简单，我们先到node.js官网。</p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/ad/ae/i0kf63Ec_o.png" width="530"></p> 
<blockquote> 
 <p> 我们下载LTS版本（稳定版），下载好后打开安装程序，无脑点击下一步即可。</p> 
</blockquote> 
<p><strong><span style="background-color:#d4e9d5;">检查是否安装成功</span></strong></p> 
<p>安装好了以后，我们打开命令行，输入node -v（查看版本），出现版本号就算安装成功。</p> 
<p><img alt="" height="77" src="https://images2.imgbox.com/13/31/helsQ9OD_o.png" width="328"></p> 
<h2 id="%C2%A0%E5%9C%A8Node.js%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%89%93%E5%8D%B0%22hello%2Cnode.js%22"> 在Node.js环境中打印"hello,node.js"</h2> 
<p> 想要在node.js环境打印东西，那么我们就需要创建一个js文件，并且在node.js环境中运行。</p> 
<pre><code class="language-javascript">// 在js文件中书写
console.log("hello,node.js");</code></pre> 
<blockquote> 
 <p>命令行执行 <strong>node 文件名</strong></p> 
</blockquote> 
<p><img alt="" height="82" src="https://images2.imgbox.com/ec/8c/HMXVL18d_o.png" width="958"> </p> 
<h2 id="%C2%A0node%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97-fs%E6%A8%A1%E5%9D%97"> node内置模块-fs模块</h2> 
<p><strong>说明</strong>：fs模块是node内置的模块，可以看作是node内置的一类API。</p> 
<p><strong>fs模块作用</strong>：主要用来<strong>操作文件</strong>，模块中提供了一系列的方法和属性，用来对文件的各种操作。</p> 
<p><strong>模块的导入</strong>：</p> 
<pre><code class="language-javascript">// js文件中导入模块方式
const fs = require("fs");
</code></pre> 
<h3 id="readFile()-%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9">readFile()-读取指定文件内容</h3> 
<p><strong><span style="background-color:#d4e9d5;">方法参数说明</span></strong></p> 
<blockquote> 
 <p>//前提需要先导入模块 </p> 
 <p><strong>fs.readFile(path,[,options],callback)</strong></p> 
 <p><span style="background-color:#f9eda6;">path</span>:必选，文件路径</p> 
 <p><span style="background-color:#d4e9d5;">[options]</span>:可选，指定编码格式</p> 
 <p><span style="background-color:#c7e6ea;">callback</span>:必选，回调函数，获取读取结果。</p> 
</blockquote> 
<p><strong><span style="background-color:#fbd4d0;"> 使用 </span></strong></p> 
<blockquote> 
 <p> 需求，定义一个文件"hello.txt"，使用方法fs.readFile()进行读取。</p> 
</blockquote> 
<pre><code class="language-javascript">// 导入模块方式
const fs = require("fs");

fs.readFile("./hello.txt","utf-8",(err,datastr)=&gt;{
    if(err){return console.log("读取失败!")}
    console.log("读取成功!数据为",datastr);
})</code></pre> 
<blockquote> 
 <p><strong>回调函数的参数说明：</strong></p> 
 <p>1.当读取文件成功，err返回null，datastr返回文件数据。</p> 
 <p>2.当读取文件失败，err返回异常对象，datastr返回undefined</p> 
</blockquote> 
<p><strong>执行输出：</strong></p> 
<p><img alt="" height="82" src="https://images2.imgbox.com/38/a2/2ID6v4M1_o.png" width="937"></p> 
<h3 id="%C2%A0writeFile()-%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"> writeFile()-读取指定文件内容</h3> 
<p><strong><span style="background-color:#d4e9d5;">方法参数说明：</span></strong></p> 
<blockquote> 
 <p><strong> fs.writeFile(file,data,[,options],callback)</strong></p> 
 <p><span style="background-color:#fbd4d0;">file</span>:需要写入的文件名</p> 
 <p><span style="background-color:#ffd7b9;">data</span>:需要写入的数据（内容）</p> 
 <p><span style="background-color:#f9eda6;">[options]</span>:指定字符集</p> 
 <p><span style="background-color:#d4e9d5;">callbaack</span>:回调函数</p> 
</blockquote> 
<blockquote> 
 <p><strong><span style="background-color:#fbd4d0;">方法使用注意点</span></strong>：</p> 
 <p style="margin-left:0;text-align:justify;">1.此方法不能够自动创建目录。</p> 
 <p style="margin-left:0;text-align:justify;">2.向同一个文件操作，是覆盖操作，不是追加操作。</p> 
</blockquote> 
<p><strong><span style="background-color:#fbd4d0;"> 使用 </span></strong></p> 
<blockquote> 
 <p><strong>需求：向文件myfile.txt中写入一些内容。 </strong></p> 
</blockquote> 
<pre><code class="language-javascript">// 导入模块方式
const fs = require("fs");

// 定义写入数据
let str = `
hello,Tom
    I am Jerry.
`
// 调用写入方法
fs.writeFile("./myfile.txt",str,"utf-8",(err)=&gt;{
    if(err){console.log("写入错误",err);}
    console.log("写入成功!");
})
</code></pre> 
<p><img alt="" height="69" src="https://images2.imgbox.com/5a/db/AAFqY9QH_o.png" width="934"> <img alt="" height="176" src="https://images2.imgbox.com/3c/15/vZOyGCjD_o.png" width="481"></p> 
<h3 id="%E8%B7%AF%E5%BE%84%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98">路径动态拼接的问题</h3> 
<blockquote> 
 <p>问题描述：在使用fs模块操作文件时，如果填写路径时使用了相对路径的写法，如./或../形式，就会出现如下问题：</p> 
 <p></p> 
 <p> 当前文件路径:<strong>D:\JavaScript\JSCode\BK3\Vue-Blog\2023-2-9\readFile().js</strong></p> 
 <p><strong>我们默认在\2023-2-9目录中执行node .\readFile().js是不会报错的。</strong></p> 
 <p>但是如果我们将目录退一级，退到Vue-Blog目录</p> 
 <p><strong>我们就需要执行 node './2023-2-9/readFile().js'，看似没有问题，其实会报错：</strong></p> 
 <p><img alt="" height="226" src="https://images2.imgbox.com/54/c0/dS6Xqtda_o.png" width="1200"></p> 
 <p>因为它<strong>不会管我们自己写的路径前缀</strong>，他<strong>只会读取文件的名字</strong>，<strong>加上当前的的目录</strong>，在当前目录中查找当前是否存在此文件。</p> 
 <p></p> 
 <p>这其实有个<strong>简易的解决方案</strong>：我们<strong>使用绝对路径</strong>就可以避免，但是，使用绝对路径是比<strong>较繁琐</strong>的。 </p> 
</blockquote> 
<p>通过上述的说明，我们不想使用绝对路径的方式解决问题，那么我们就可以使用一个<strong>内置的属性：__dirname</strong>,此属性<strong>代表着我们当前的文件所处的目录</strong>。那么我们就可以进行<strong>路径书写优化</strong>：</p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/d1/0f/vZn2ES3i_o.png" width="953"></p> 
<p> </p> 
<h2 id="node%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97-path%E6%A8%A1%E5%9D%97">node内置模块-path模块</h2> 
<p>作用：path模块是<strong>用来处理路径</strong>的模块。</p> 
<blockquote> 
 <p>说明：例如上方的案例，我们在读取文件时需要书写文件路径，我们是这样书写的：</p> 
 <p><strong> __dirname + "/hello.txt"</strong></p> 
 <p>通过手动拼接的方式书写，其实我们可以使用path模块中的方法，来对路径进行拼接操作。</p> 
</blockquote> 
<p><strong><span style="background-color:#fbd4d0;"> 模块的导入</span></strong>：</p> 
<pre><code class="language-javascript">// 导入path模块
const path = require("path");</code></pre> 
<h3 id="path.join()-%E5%B0%86%E5%A4%9A%E4%B8%AA%E8%B7%AF%E5%BE%84%E8%BF%9B%E8%A1%8C%E6%8B%BC%E6%8E%A5">path.join()-将多个路径进行拼接</h3> 
<p><strong><span style="background-color:#d4e9d5;">参数说明</span></strong>：</p> 
<blockquote> 
 <p><strong>path.join([...options])</strong></p> 
 <p><span style="background-color:#ffd7b9;">options</span>:需要拼接的路径</p> 
</blockquote> 
<p><strong><span style="background-color:#fbd4d0;"> 使用 </span></strong></p> 
<blockquote> 
 <p><strong>需求：将多个路径进行拼接。 </strong></p> 
</blockquote> 
<pre><code class="language-javascript">// 导入path模块
const path = require("path");

let pathStr = path.join("a","b","c");
console.log(pathStr);</code></pre> 
<p><img alt="" height="73" src="https://images2.imgbox.com/40/60/Luc2mC1W_o.png" width="881"></p> 
<p><strong><span style="background-color:#fbd4d0;"> 配合属性__dirname使用</span></strong></p> 
<pre><code class="language-javascript">// 导入path模块
const path = require("path");
// 导入模块方式
const fs = require("fs");


fs.readFile(path.join(__dirname,"hello.txt"),"utf8",(err,datastr)=&gt;{
    if(err){return console.log("读取失败!",err)}
    console.log("读取成功!数据为",datastr);
})</code></pre> 
<h3 id="%C2%A0path.basename()-%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"> path.basename()-获取路径中的文件名</h3> 
<p><strong><span style="background-color:#d4e9d5;"> 参数说明：</span></strong></p> 
<blockquote> 
 <p><strong>path.basename(path,[,ext])</strong></p> 
 <p><span style="background-color:#fbd4d0;">path</span>:必选，需要解析的路径</p> 
 <p><span style="background-color:#f9eda6;">[ext]</span>:可选，文件名，如果填写相当于是删除掉了扩展名，只返回文件名。</p> 
</blockquote> 
<p><strong><span style="background-color:#fbd4d0;"> 使用 </span></strong></p> 
<blockquote> 
 <p><strong>需求：给定一个路径，分别获取带后缀的文件名和不带后缀的文件名。 </strong></p> 
</blockquote> 
<pre><code class="language-javascript">// 导入path模块
const path = require("path");
// 模拟路径
let pathStr = "a/b/c/hello.txt"
// 获取带后缀的文件名
console.log(path.basename(pathStr));// 输出：hello.txt
// 获取不带后缀的文件名
console.log(path.basename(pathStr,".txt"));// 输出：hello</code></pre> 
<h2 id="node%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97-http%E6%A8%A1%E5%9D%97">node内置模块-http模块</h2> 
<p><strong>作用</strong>：http 模块可以用来<strong>创建web服务器，对外提供web资源服务</strong>。</p> 
<p><strong> 导入模块</strong>：</p> 
<pre><code class="language-javascript">// 导入http内置模块
const http = require("http");</code></pre> 
<h3 id="%E5%88%9B%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8">创建web服务器</h3> 
<pre><code class="language-javascript">// 1.导入http内置模块
const http = require("http");

// 2.调用http模块的方法createServer(),返回服务器实例
const server = http.createServer();

// 3.给服务器绑定请求事情，用于接收前端请求
server.on("request",(request,response)=&gt;{
    // 只要有请求访问此服务器，就会进入此方法进行处理
})

// 4.调用方法listen()，指定端口，开启服务器
server.listen(88,()=&gt;{ 
    console.log("服务器启动成功,运行在88端口!");
})</code></pre> 
<p><strong><span style="background-color:#fbd4d0;">执行代码：</span></strong></p> 
<p><img alt="" height="124" src="https://images2.imgbox.com/91/10/DlPESO4T_o.png" width="896"></p> 
<p> 浏览器通过URL：http://127.0.0.1:88或者http://localhost:88访问服务器。</p> 
<blockquote> 
 <p>127.0.0.1为本地主机(localhost)，88为指定的端口号，要是端口号为80，则不需要手动填写端口号:88，就能访问服务器，因为http协议默认访问80端口号。</p> 
 <p></p> 
 <p>上方执行后会处于一直加载的状态，因为我们服务器没有任何处理和响应给前端数据。</p> 
</blockquote> 
<h3 id="request%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1%E5%92%8Cresponse%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1">request请求对象和response响应对象</h3> 
<p>通过上方服务器的创建我们知道，当请求访问服务器时，会进入我们绑定的事件request的处理函数中，<strong>处理函数有两个参数，第一个是请求对象，第二个是响应对象。</strong></p> 
<blockquote> 
 <p><strong><span style="background-color:#ffd7b9;">请求对象request</span></strong>：可以访问客户端请求时的数据或属性。</p> 
 <p><strong><span style="background-color:#f9eda6;">响应对象respose</span></strong>：通过此对象可以向请求方返回数据。</p> 
</blockquote> 
<p><strong><span style="background-color:#fbd4d0;"> 使用  </span></strong></p> 
<blockquote> 
 <p><strong> 需求：获取请求时携带的参数和URL，并且给请求方响应一些提示信息。</strong></p> 
</blockquote> 
<pre><code class="language-javascript">// 导入http内置模块
const http = require("http");

// 调用http模块的方法createServer(),返回服务器实例
const server = http.createServer();

// 给服务器绑定请求事情，用于接收前端请求
server.on("request",(request,response)=&gt;{
    // 只要有请求访问此服务器，就会进入此方法进行处理

    // 获取请求URI
    let reqURL = request.url;
    // 获取请求方式
    let reqMethod = request.method;
    console.log("本次访问URL为:",reqURL,"===，请求方式为:",reqMethod);

    // 响应数据，并结束本次请求
    response.end("感谢访问!");
})

// 调用方法listen()，指定端口，开启服务器
server.listen(88,()=&gt;{ 
    console.log("服务器启动成功,运行在88端口!");
})</code></pre> 
<p><strong><span style="background-color:#fbd4d0;"> 终端输出：</span></strong><img alt="" height="106" src="https://images2.imgbox.com/07/ff/otVs4Qfy_o.png" width="900"></p> 
<p><strong><span style="background-color:#d4e9d5;"> 访问页面展示：</span></strong></p> 
<p><img alt="" height="156" src="https://images2.imgbox.com/35/df/CFNcKjNd_o.png" width="601"></p> 
<p><strong>解决中文乱码问题</strong></p> 
<p><span style="background-color:#ffd7b9;"> 在响应之前设置：</span><img alt="" height="195" src="https://images2.imgbox.com/da/45/SoX1vArT_o.png" width="868"></p> 
<p><strong><span style="background-color:#fbd4d0;">记得保存重启服务器 </span></strong></p> 
<p><img alt="" height="245" src="https://images2.imgbox.com/63/cf/HdW64Yk2_o.png" width="885"></p> 
<h3 id="%C2%A0%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82URL%E4%B8%8D%E5%90%8C%E8%BF%9B%E8%A1%8C%E6%96%B9%E6%B3%95%E5%88%86%E5%8F%91"> 根据请求URL不同进行方法分发</h3> 
<p>上方定义的服务器是有些却缺陷的，我们使用server.on()给服务器绑定了请求事件，只要有请求就进入处理函数，这样不<strong>管什么请求，我们的处理方式都是相同的，这明显是不合理的</strong>，我们想要的是<strong>根据不同的访问路径，给予不同的处理方式</strong>。</p> 
<blockquote> 
 <p>如何做呢? 其实我们可以先获取请求的URI，对RUI进行判断后指定不同的处理。</p> 
</blockquote> 
<pre><code class="language-javascript">// 导入http内置模块
const http = require("http");

// 调用http模块的方法createServer(),返回服务器实例
const server = http.createServer();

// 给服务器绑定请求事情，用于接收前端请求
server.on("request",(request,response)=&gt;{
    // 只要有请求访问此服务器，就会进入此方法进行处理

    // 获取请求属性或数据
    let reqURL = request.url;
    // 指定默认响应的字符串
    let resContent = "&lt;h2&gt;404 客户端错误 请检查!&lt;/h2&gt;"
    if(reqURL === "/" || reqURL === "/index.html"){
        resContent = "&lt;h2&gt;首页&lt;/h2&gt;"
    } else if(reqURL === "/login.html"){
        resContent = "&lt;h2&gt;登录页&lt;/h2&gt;"
    }
    //设置响应头，指定字符集
    response.setHeader("Content-type","text/html; charset=utf-8")

    // 响应数据，并结束本次请求
    response.end(resContent);
})

// 调用方法listen()，指定端口，开启服务器
server.listen(88,()=&gt;{ 
    console.log("服务器启动成功,运行在88端口!");
})</code></pre> 
<p><strong> 重启服务器，访问服务器</strong></p> 
<p> <img alt="" height="163" src="https://images2.imgbox.com/c8/59/smvnAZIl_o.png" width="446"></p> 
<p> <img alt="" height="151" src="https://images2.imgbox.com/0b/1d/3VQVJ84K_o.png" width="464"></p> 
<h3 id="%E5%B0%86URL%E6%98%A0%E5%B0%84%E4%B8%BA%E6%9C%AC%E5%9C%B0%E5%90%8E%E8%BE%93%E5%87%BA">将URL映射为本地后输出</h3> 
<p>如上方式中，我们并没有返回真实的文件或数据，仅仅是返回一些字符串，但是在真实开发中，当用户访问如index.html时，我们返回的是存在服务器上真实的html资源。</p> 
<blockquote> 
 <p><strong>需求：当有请求访问URL为hello.txt资源，我们就读取文件并将之响应到页面展示。</strong></p> 
</blockquote> 
<pre><code class="language-javascript">// 导入http内置模块
const fs= require("fs");
const http = require("http");
// 导入path模块
const path = require("path");

// 调用http模块的方法createServer(),返回服务器实例
const server = http.createServer();

// 3.给服务器绑定请求事情，用于接收前端请求
server.on("request",(request,response)=&gt;{
    // 只要有请求访问此服务器，就会进入此方法进行处理

    // 获取请求属性或数据
    let reqURL = request.url;

    // 拼接URL（用于我们查找本地文件）
    let localpath = path.join(__dirname,reqURL)

    // 读取本地文件
    fs.readFile(localpath,"utf-8",(err,dataStr)=&gt;{
        //设置响应头，指定字符集
        response.setHeader("Content-type","text/html; charset=utf-8")

        // 如果读取错误，给予提示
        if(err){
            response.end("&lt;h2&gt;路径错误或请求资源不存在!&lt;/h2&gt;");
        }
        // 读取成功，将之返回
        response.end(dataStr);
    })
    
})

// 调用方法listen()，指定端口，开启服务器
server.listen(88,()=&gt;{ 
    console.log("服务器启动成功,运行在88端口!");
})</code></pre> 
<p><strong><span style="background-color:#ffd7b9;">重启服务器，重新访问服务器 </span></strong></p> 
<p> <img alt="" height="160" src="https://images2.imgbox.com/63/a8/nH34ievW_o.png" width="593"></p> 
<p><img alt="" height="173" src="https://images2.imgbox.com/a2/cd/fWe0THpQ_o.png" width="473"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/87a5b192ed56535cbfd4958f920f7dcd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QT中完成文本编辑器的文件另存功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f559ade6a1ac6875bb35731ccc415968/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenWrt设置无线桥继教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>