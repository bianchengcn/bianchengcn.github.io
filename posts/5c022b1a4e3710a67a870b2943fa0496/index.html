<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二叉搜索树、完全二叉树、平衡二叉树 Python实现 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二叉搜索树、完全二叉树、平衡二叉树 Python实现" />
<meta property="og:description" content="1.二叉搜索树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。（即中序遍历情况下，值依次增大）
# 二叉搜索树
# 中序遍历情况下，值递增则为二叉树
def isBSTree(head):
minimum = -100000 # 设定一个最小值
if head is None:
return False
prenum = minimum
stack = []
while head or len(stack) &gt; 0:
if head:
stack.append(head)
head = head.left
else:
head = stack.pop()
if head.val &lt; prenum: # 保证中序遍历情况下值递增
return False
else:
prenum = head.val
head = head.right
return True
2.完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。）
# 判断一棵树是否为完全二叉树
# 左无、右有 ==&gt; 返回 False" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5c022b1a4e3710a67a870b2943fa0496/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-17T15:25:50+08:00" />
<meta property="article:modified_time" content="2019-05-17T15:25:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二叉搜索树、完全二叉树、平衡二叉树 Python实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.<strong>二叉搜索树</strong>：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91" rel="nofollow">二叉排序树</a>。（<strong>即中序遍历情况下，值依次增大</strong>）</p> 
<p># 二叉搜索树<br> # 中序遍历情况下，值递增则为二叉树<br> def isBSTree(head):<br>     minimum = -100000               # 设定一个最小值<br>     if head is None:<br>         return False<br>     prenum = minimum<br>     stack = []<br>     while head or len(stack) &gt; 0:<br>         if head:<br>             stack.append(head)<br>             head = head.left<br>         else:<br>             head = stack.pop()<br>             if head.val &lt; prenum:   # 保证中序遍历情况下值递增<br>                 return False<br>             else:<br>                 prenum = head.val<br>             head = head.right<br>     return True</p> 
<p>2.<strong>完全二叉树</strong>：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（<strong>除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。</strong>）</p> 
<p># 判断一棵树是否为完全二叉树<br> # 左无、右有 ==&gt; 返回 False<br> # 左无、右无 ==&gt; 激活判断：之后所有节点都是叶节点<br> # 左有、右无 ==&gt; 激活判断：之后所有节点都是叶节点        ==》      只要右无之后都必须是叶节点<br> # 左有、右有 ==&gt; 不用处理<br> import queue<br> def isCBTree(head):<br>     if not head:<br>         return False<br>     que = queue.Queue()<br>     que.put(head)<br>     flag = False                                # 是否激活判断过程<br>     while not que.empty():<br>         head = que.get()<br>         if head.left:<br>             que.put(head.left)<br>         if head.right:<br>             que.put(head.right)</p> 
<p>        if (not head.left) and head.right:      #左空、又不空必不为CBT<br>             return False</p> 
<p>        if flag:                                # 若过程激活则判断节点是否为叶节点<br>             if head.left or head.right:<br>                 return False</p> 
<p>        if not (head.left and head.right):      # 左不空、右空 | 左空、右空<br>             flag = True                         # 激活判断在此之后的节点必须为叶节点<br> return True</p> 
<p>3.<strong>平衡二叉树：</strong>平衡二叉树是一棵二叉树，其可以为空，或满足如下2个性质：①<strong>左右子树深度之差的绝对值不大于1</strong>。②<strong>左右子树都是平衡二叉树</strong>。</p> 
<p>第一种写法：递归返回判断结果和子节点深度</p> 
<p># 判断二叉树是否为平衡二叉树<br> # 先判断该节点是否平衡<br> # 再递归去判断左节点和右节点是否平衡<br> def process(head):<br>     if head is None:<br>         return True, 0<br>     leftData = process(head.left)<br>     if not leftData[0]:<br>         return False, 0<br>     rightData = process(head.right)<br>     if not rightData[0]:<br>         return False, 0<br>     if abs(leftData[1]-rightData[1]) &gt; 1:<br>         return False, 0<br>     return True, max(leftData[1],rightData[1]) + 1</p> 
<p>第二种常见写法：</p> 
<p># 判断二叉树是否为平衡二叉树<br> # 先判断该节点是否平衡<br> # 再递归去判断左节点和右节点是否平衡</p> 
<p># 递归求当前节点的深度<br> def getdepth(node):<br>     if not node:<br>         return 0<br>     ld = getdepth(node.left)<br>     rd = getdepth(node.right)<br>     return max(ld, rd) + 1</p> 
<p><br> def isB(head):<br>     if not head:<br>         return True<br>     ld = getdepth(head.left)<br>     rd = getdepth(head.right)<br>     if abs(ld - rd) &gt; 1:<br>         return False<br>     return isB(head.left) and isB(head.right)</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b8f54e16a4e8baa6ff7dee73a44c45ce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ajax 请求状态码含义（ 200、300、400、500。。。。）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f7c14e370663e43d96574399533e7f78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">结构体、结构指针作为函数参数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>