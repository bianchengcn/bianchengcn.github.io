<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统—电梯调度模拟程序（C语言，数据结构，含代码） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统—电梯调度模拟程序（C语言，数据结构，含代码）" />
<meta property="og:description" content="各位好，这里是太阳终于出来啦，这次分享的是操作系统课程中的电梯模拟程序，虽然个人的观点是这个程序和操作系统的关系不大，倒像是数据结构的练习。所以各位就姑且当数据结构来看吧。
目录
一、写在前面
二、题目要求
三、思路分析
四、主函数及变量说明
五、结果及说明
一、写在前面 1.本人并不擅长编程，各位可以交流学习，如果有错误欢迎指出。
2.不保证思路和解决方式是最佳思路，也不能保证正确性，请勿将本文当做考试复习参考。其中涉及到专业名词的部分可能会有描述错误，请谅解。
3.本人个人写代码不习惯写注释，变量的命名也很随意，请谅解。
4.本文会讲述全部代码思路，代码是按模块分段展示的（也会在文中提及主函数的编写逻辑），代码需要自己整合，有编程基础的朋友一定能在阅读后根据提示写出完整程序。因为看到很多朋友在解决此法时遇到困难，仅作为交流。如果是想要直接复制完整代码的本站有其他大佬的分享帖。
5.请谅解文章中的错别字，标点符号，以及的地得！
6.ncwu慎用。
二、题目要求 电梯的模拟程序
基本条件如下：
楼层：1-21
电梯容量：10个人
电梯每0.5s经过一个楼层
初始一楼有30人等电梯并且每5s会来0-2个人
每5s输出一次电梯一共走过的层数，电梯目前所在的层数，一楼所等待的人数
三、思路分析 这里，我的想法是为每一个乘客创建一个结构体，然后每一层的等待乘客是一个链表，电梯内的乘客自己也是一个链表，每有一个乘客上电梯，就把楼层链表中的相应乘客移动到电梯的列表中，而每有一个乘客下电梯就把电梯链表中的相应元素删除。
这里其实题目中只要求了一楼会每隔5秒来人，但是这里想优化一下就是，凡是有人下电梯（不是一楼）那么这个楼层也会来人（当然这里也是随机，且来的人数不能大于下电梯在这里楼的人数，虽然现实中会存在爬楼梯什么的不用考虑这么复杂，我们就先当这个大楼没有楼梯来着，主要是程序编好了才想到有楼梯这回事……）
具体说明如下：
typedef struct LNode //每个乘客一个链表项
{
int from;
int to;
int uod;//上行还是下行 ,1表示上行 struct LNode *next;
}LNode,*LinkList;
这里方便管理用的是链表而不是顺序表。from是每个乘客出发的楼层，to是每个乘客到达的楼层，uod是up_or_down，记录电梯是上行还是下行，因为电梯是有点像磁盘的LOOK调度，他要一直同一个方向送到（当前乘客或有人等待的楼层）最大值（或最小值）然后再转向。所以只有电梯运行方向和乘客运行方向一致时，乘客才会上电梯。
这里一共创建了三个函数，分别是链表添加，链表转移和链表删除。
void createlinklist(LinkList &amp;L,int n,int f);
int addlinklist(LinkList &amp;L,LinkList &amp;LL,int a,int b);//a表示电梯状态 void movelinklist(LinkList &amp;L,int a);//a表楼层 这里基本与链表操作一致，只说明适配这个程序的不同之处，这里的链表初始化我放在了主程序里，因为本身链表就不想多建一个函数，而在链表的添加函数中，开始需要移动指针到最后然后用后插法插入新的节点，要注意的有两点，一是生成的随机数不能与当前楼层相同，二是要判断上行还是下行。
完整代码如下：
void createlinklist(LinkList &amp;L,int n,int f){//n表示链表生成数量，f表示楼层 LNode *p=NULL, *r=NULL; int i,t; r=L; while(r-&gt;next) r=r-&gt;next; for(int i=1;i&lt;=n;i&#43;&#43;){//创建n个链表，每个链表就代表一个乘客 p=new LNode; p-&gt;from=f; t=random(1,21); while(t==f) t=random(1,21); p-&gt;to=t; if(f&lt;t) p-&gt;uod=1; if(f&gt;t) p-&gt;uod=0; p-&gt;next=NULL; r-&gt;next=p; r=p; } } Random为在程序开头的宏定义" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/cb4444c9acd6ec37c722c390bc68e2f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-25T23:57:35+08:00" />
<meta property="article:modified_time" content="2023-06-25T23:57:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统—电梯调度模拟程序（C语言，数据结构，含代码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="172" src="https://images2.imgbox.com/ff/fe/f3KTVXk7_o.png" width="172"></p> 
<p>各位好，这里是太阳终于出来啦，这次分享的是操作系统课程中的电梯模拟程序，虽然个人的观点是这个程序和操作系统的关系不大，倒像是数据结构的练习。所以各位就姑且当数据结构来看吧。</p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2-toc" style="margin-left:0px;"><a href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2" rel="nofollow">一、写在前面</a></p> 
<p id="%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82" rel="nofollow">二、题目要求</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90" rel="nofollow">三、思路分析</a></p> 
<p id="%E4%B8%89%E3%80%81%E4%B8%BB%E5%87%BD%E6%95%B0%E5%8F%8A%E5%8F%98%E9%87%8F%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E4%B8%BB%E5%87%BD%E6%95%B0%E5%8F%8A%E5%8F%98%E9%87%8F%E8%AF%B4%E6%98%8E" rel="nofollow">四、主函数及变量说明</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%AF%B4%E6%98%8E" rel="nofollow">五、结果及说明</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2">一、写在前面</h2> 
<p><br> 1.本人并不擅长编程，各位可以交流学习，如果有错误欢迎指出。</p> 
<p>2.不保证思路和解决方式是最佳思路，也不能保证正确性，请勿将本文当做考试复习参考。其中涉及到专业名词的部分可能会有描述错误，请谅解。</p> 
<p>3.本人个人写代码不习惯写注释，变量的命名也很随意，请谅解。</p> 
<p>4.本文会讲述全部代码思路，代码是按模块分段展示的（也会在文中提及主函数的编写逻辑），代码需要自己整合，有编程基础的朋友一定能在阅读后根据提示写出完整程序。因为看到很多朋友在解决此法时遇到困难，仅作为交流。如果是想要直接复制完整代码的本站有其他大佬的分享帖。</p> 
<p>5.请谅解文章中的错别字，标点符号，以及的地得！</p> 
<p>6.ncwu慎用。</p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">二、题目要求</h2> 
<p style="margin-left:0;text-align:justify;">电梯的模拟程序</p> 
<p style="margin-left:0;text-align:justify;">基本条件如下：</p> 
<p style="margin-left:0;text-align:justify;">楼层：1-21</p> 
<p style="margin-left:0;text-align:justify;">电梯容量：10个人</p> 
<p style="margin-left:0;text-align:justify;">电梯每0.5s经过一个楼层</p> 
<p style="margin-left:0;text-align:justify;">初始一楼有30人等电梯并且每5s会来0-2个人</p> 
<p style="margin-left:0;text-align:justify;">每5s输出一次电梯一共走过的层数，电梯目前所在的层数，一楼所等待的人数</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90" style="margin-left:0px;text-align:justify;">三、思路分析</h2> 
<p style="margin-left:0;text-align:justify;">这里，我的想法是为每一个乘客创建一个结构体，然后每一层的等待乘客是一个链表，电梯内的乘客自己也是一个链表，每有一个乘客上电梯，就把楼层链表中的相应乘客移动到电梯的列表中，而每有一个乘客下电梯就把电梯链表中的相应元素删除。</p> 
<p style="margin-left:0;text-align:justify;">这里其实题目中只要求了一楼会每隔5秒来人，但是这里想优化一下就是，凡是有人下电梯（不是一楼）那么这个楼层也会来人（当然这里也是随机，且来的人数不能大于下电梯在这里楼的人数，<strong>虽然现实中会存在爬楼梯什么的不用考虑这么复杂，我们就先当这个大楼没有楼梯来着，<span style="color:#fe2c24;">主要是程序编好了才想到有楼梯这回事</span></strong>……）</p> 
<p style="margin-left:0;text-align:justify;">具体说明如下：</p> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;">typedef struct LNode //每个乘客一个链表项<br> {<!-- --><br>     int from;<br>     int to;<br>     int uod;//上行还是下行 ,1表示上行 <br>     struct LNode *next;<br> }LNode,*LinkList;</p> 
</blockquote> 
<p>这里方便管理用的是链表而不是顺序表。from是每个乘客出发的楼层，to是每个乘客到达的楼层，uod是up_or_down，记录电梯是上行还是下行，因为电梯是有点像磁盘的LOOK调度，他要一直同一个方向送到（当前乘客或有人等待的楼层）最大值（或最小值）然后再转向。所以只有电梯运行方向和乘客运行方向一致时，乘客才会上电梯。</p> 
<p style="margin-left:0;text-align:justify;">这里一共创建了三个函数，分别是链表添加，链表转移和链表删除。</p> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;">void createlinklist(LinkList &amp;L,int n,int f);<br> int addlinklist(LinkList &amp;L,LinkList &amp;LL,int a,int b);//a表示电梯状态 <br> void movelinklist(LinkList &amp;L,int a);//a表楼层 </p> 
</blockquote> 
<p>这里基本与链表操作一致，只说明适配这个程序的不同之处，这里的链表初始化我放在了主程序里，因为本身链表就不想多建一个函数，而在链表的添加函数中，开始需要移动指针到最后然后用后插法插入新的节点，要注意的有两点，一是生成的随机数不能与当前楼层相同，二是要判断上行还是下行。</p> 
<p class="img-center"><img alt="" height="190" src="https://images2.imgbox.com/4b/1d/Y25sbJUE_o.png" width="266"></p> 
<p> 完整代码如下：</p> 
<pre><code class="language-cpp">void createlinklist(LinkList &amp;L,int n,int f){//n表示链表生成数量，f表示楼层
	LNode *p=NULL, *r=NULL;
	int i,t;
	r=L;
	while(r-&gt;next) r=r-&gt;next;
	for(int i=1;i&lt;=n;i++){//创建n个链表，每个链表就代表一个乘客 
		p=new LNode;
		p-&gt;from=f;
		t=random(1,21);
		while(t==f) t=random(1,21);
		p-&gt;to=t;
		if(f&lt;t) p-&gt;uod=1;
		if(f&gt;t) p-&gt;uod=0;
		p-&gt;next=NULL;
		r-&gt;next=p;
		r=p;
	}
}</code></pre> 
<p style="margin-left:0;text-align:justify;">Random为在程序开头的宏定义</p> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;">#define random(a,b) (rand()%(b-a+1)+a)</p> 
</blockquote> 
<p style="margin-left:0;text-align:justify;">链表的转移函数中，我设置了返回值，因为不一定每个楼层都有人上电梯（这个楼层可能有人在等电梯，但是可能运行方向不一致）返回值就是用来判断有没有人上电梯，因为如果没有这个判断条件仅仅是以电梯满了没或者是等待的人消失了没作为判断循环结束的条件的话就会出现死循环。代码如下：</p> 
<pre><code class="language-cpp">int addlinklist(LinkList &amp;L,LinkList &amp;LL,int a,int b){ //a表示上行or下行 
	LNode *p=NULL,*p1=NULL,*r=NULL;
	r=L;
	int i=0,flag;
	while(r &amp;&amp; (i&lt;b-1)) {//先把指针移到表尾
		r=r-&gt;next;
		i++;
	}
	p1=LL-&gt;next;
	flag=1;
	if(p1-&gt;uod==a){
		p=new LNode;
		p-&gt;from=p1-&gt;from;
		p-&gt;to=p1-&gt;to;
		p-&gt;uod=p1-&gt;uod;
		p-&gt;next=r-&gt;next;
		r-&gt;next=p;
		p1=p1-&gt;next;
		LL-&gt;next=p1;
		flag=0;
		return 1;
	}
	if(flag==1) return 0;
}</code></pre> 
<p style="margin-left:0;text-align:justify;">要注意的是，如果有人要上电梯，就要把该层的等待链表的相对应的节点删除（移动头指针就可以了，如下图画圈部分）。</p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/ad/fe/y3ok1y3E_o.png" width="198"></p> 
<p>而删除部分只要注意相应的楼层数组标记值就行了（为了这一层到时候可以出现等电梯的人，开头说的）代码如下：</p> 
<pre><code class="language-cpp">void movelinklist(LinkList &amp;L,int a){//a表示楼层
	LNode *p=NULL,*q=NULL;
	p=L;
	for(int i=1;i&lt;=amount;i++){
		if(p-&gt;next-&gt;to==a){
			q=p-&gt;next;
			p-&gt;next=q-&gt;next;
			amount--;//电梯人数减一
			FF[a]++;//楼层人数加一
			i--;
		}
		else p=p-&gt;next;
	}
}</code></pre> 
<p>这里解释一下为什么p=p-&gt;next要放到else部分执行（<span style="color:#fe2c24;"><strong>顺便复习一下链表的删除</strong></span>），假设有前后两个元素值一样的情况，如图，假设我们执行p=p-&gt;next，那么则如图所示。</p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="237" src="https://images2.imgbox.com/0f/73/hinTBESP_o.png" width="305"> 
  <figcaption>
    q=p-&gt;next 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="182" src="https://images2.imgbox.com/19/db/uMT5scGj_o.png" width="291"> 
  <figcaption>
    p-&gt;next=q-&gt;next（完成了对第一个6的删除） 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="153" src="https://images2.imgbox.com/30/ba/jl84yyR0_o.png" width="304"> 
  <figcaption>
    下一次遍历的位置p=p-&gt;next​​ 
  </figcaption> 
 </figure> 
</div> 
<p>此时由于我们的判断条件是p-&gt;next-&gt;to==a，所以第二个6被我们跳过了，所以执行删除时候不能往下遍历，而至于为什么i要--，这里也很简单，用下图说明。</p> 
<p class="img-center"><img alt="" height="74" src="https://images2.imgbox.com/48/cf/KqmufNCP_o.png" width="518"></p> 
<p>这里假设我们要删除的元素是2，那么因为i的循环长度是链表的长度，所以最后一个元素没办法遍历到啦。</p> 
<p class="img-center"><img alt="" height="82" src="https://images2.imgbox.com/59/fc/1q6ktTTx_o.png" width="536"></p> 
<p>这里还有一个函数check用来判断当前电梯最高和最低运行的层数，也就是一个很简单的遍历并寻找最大值最小值的函数。这里前面解释过了电梯不会一直都是在21和1层之间来回运动，他只会运动到当前（等待）电梯里的人要去往的最大（最小）楼层。</p> 
<p>在check函数中先将初始值定为10.5，因为没有楼层是10.5，这样如果函数结束两个变量的值还是10.5，就说明没有发生变化，我们就把他们的值变为1，让电梯回到一楼等待。这个函数用的是最简单的比大小找最大值最小值法，就不过多阐述，代码如下：</p> 
<pre><code class="language-cpp">void check(LinkList&amp; L) {
	themin = 10.5;
	themax = 10.5;
	for (int j = 1; j &lt;= 21; j++) {//比较有人等电梯楼层的极值
		if (Floor[j] &gt; 0 &amp;&amp; j &gt; themax) themax = j;
		if (Floor[j] &gt; 0 &amp;&amp; j &lt; themin) themin = j;
	}
	if(amount==0) return;
	LNode* p=NULL;
	p = L-&gt;next;
	while (p) {//遍历然后得到电梯里的人目的地的极值
		if (p-&gt;to &gt; themax) themax = p-&gt;to;
		if (p-&gt;to &lt; themin) themin = p-&gt;to;
		p = p-&gt;next;
	}
	if (themin == 10.5) themin = 1;//没有变化，归位
	if (themax == 10.5) themax = 1;
}</code></pre> 
<p style="margin-left:0;text-align:justify;">最后是一个每隔五秒来人的函数addpeople，这个很简单，随机出值，然后调用列表的添加就可以了，如果随机出的楼层有人就生成在随机的楼层，如果没人就生成在一楼。代码如下：</p> 
<pre><code class="language-cpp">void addpeople(){
	int n,f;
	n=random(0,2); //随机0-2人
	for(int i=1;i&lt;=n;i++){
		f=random(2,21);//随机一个楼层
		if(FF[f]&gt;0){//之前有人到过这个楼层，就生成到这里
			createlinklist(L[f],1,f);//楼层链表增加一项
			Floor[f]++;//楼层等待人数加一
			FF[f]--; //楼层人数减一
		}
		else {//如果不是就在一楼生成
			createlinklist(L[1],1,1);
			Floor[1]++;
			FF[f]--; 
		}
	}
}</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E4%B8%BB%E5%87%BD%E6%95%B0%E5%8F%8A%E5%8F%98%E9%87%8F%E8%AF%B4%E6%98%8E">四、主函数及变量说明</h2> 
<p>为了避免函数参数过多，我建立了很多全局变量，下面是对应的解释：</p> 
<blockquote> 
 <p>#define TIME 40//电梯运行时间</p> 
 <p>int themax,themin;//电梯运行楼层的最大值和最小值</p> 
 <p>int amount=0,F;//F是当前层数  amount是电梯当前人数<br> int Floor[22]={0},FF[22]={0};//每一层的人数,以及这层有没有人在等电梯 <br> LinkList L[22];//楼层链表，表示当前楼层的等待的乘客 </p> 
</blockquote> 
<p><strong>主函数说明（详见代码注释）：</strong></p> 
<pre><code class="language-cpp">int main(){
	srand((unsigned int)time(NULL));//随机数种子
	for(int i=1;i&lt;=21;i++){	//链表初始化
	    L[i]=new LNode;
	    L[i]-&gt;next=NULL;
	}
	createlinklist(L[1],30,1);//创建一个一楼30个人的等候链表
	LNode *p;
	LinkList EL;//电梯链表，表示当前电梯中的乘客 
	void nextfloor(int ud);//表示电梯下一个要到达的楼层，代码见下面
	int flag;//判断这层楼有没有人下电梯
	
	EL=new LNode;//初始化 
	EL-&gt;next=NULL; 
	for(int i=1;i&lt;=10;i++){//把一楼等电梯的前十个人送上电梯
		flag=addlinklist(EL,L[1],1,i);
		amount++;
	}
	Floor[1]=20; //第一层还有20个人 
	int ud;//ud表示上行或下行。
	ud=1;//先是上行
	F=1;//先是在一楼
	for(int i=TIME*2-1;i&gt;=0;i--){//0.5要换成double型太麻烦了所以乘个二
		check(EL);//确定当前运行的最大和最小楼层	
		nextfloor(ud);//运行到下一层
		if(F==themax) ud=0;//如果到达最高层，换向
		if(F==themin) ud=1;//如果到达最低层，换向
		movelinklist(EL,F);//下电梯
		
		while(Floor[F]&gt;0){//上电梯 
            //（如果这一楼有人在等电梯，考虑上行下行不一定有人等就要上）
			if(amount&lt;10){//电梯如果有空位
				flag=addlinklist(EL,L[F],ud,amount+1);//看看这楼有没有要上电梯的
				if(flag==1){//如果有（一个一个来）
					amount++;//电梯总人数加一
			    	Floor[F]--;//当前楼层等待人数减一
				}
				if(flag==0) break;//没有就退出防止死循环
			}
			else break;//没人等就退出
		} 
		if(i%10==0 &amp;&amp; i!=TIME*2) {//每五秒输出依次
			addpeople();//每隔5秒来人 
			cout&lt;&lt;"现在过了"&lt;&lt;(TIME*2-i)/2&lt;&lt;"秒"&lt;&lt;endl; 
			cout&lt;&lt;"电梯在第"&lt;&lt;F&lt;&lt;"层"&lt;&lt;endl; 
			for(int j=1;j&lt;=21;j++){
				if(Floor[j]&gt;0) cout&lt;&lt;j&lt;&lt;"楼有"&lt;&lt;Floor[j]&lt;&lt;"个人在等电梯"&lt;&lt;endl; 
			} 
			cout&lt;&lt;"电梯里有"&lt;&lt;amount&lt;&lt;"个人"&lt;&lt;endl; 
			cout&lt;&lt;endl; 
		}	
	} 
	if(amount&gt;0){//顺便看看结束时候电梯里还有几个怨种
		p=EL-&gt;next;
		cout&lt;&lt;"电梯里的人想去的楼层是：";
    	while(p){
	    	cout&lt;&lt;p-&gt;to&lt;&lt;" ";	
	    	p=p-&gt;next;	
    	}
	} 
	
}</code></pre> 
<p>这里的nextfloor函数如下：</p> 
<pre><code class="language-cpp">void nextfloor(int ud){//ud表示上行下行，上行加一下行减一
	if(ud==1) F++;
	if(ud==0) F--;
}</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%AF%B4%E6%98%8E">五、结果及说明</h2> 
<p>输出结果如下：</p> 
<p class="img-center"><img alt="" height="953" src="https://images2.imgbox.com/3f/49/ounEAOCb_o.png" width="390"></p> 
<p>当然啦，由于我们采用了链表，所以其实输出可以随心所欲一点，比如说我们可以在结束的时候看看每个楼层等待的人都想去那一层。</p> 
<p>只要插入这一段代码。</p> 
<pre><code class="language-cpp">for (int j = 1; j &lt;= 21; j++) {
	if (Floor[j] &gt; 0) {
		cout &lt;&lt; j &lt;&lt; "楼的人想去的楼层是：";
		p = L[j]-&gt;next;
		while (p) {
			cout &lt;&lt; p-&gt;to &lt;&lt; " ";
			p = p-&gt;next;
		}
		cout &lt;&lt; endl;
	}
}</code></pre> 
<p>就可以输出想要的结果了。</p> 
<p class="img-center"><img alt="" height="244" src="https://images2.imgbox.com/3c/91/oCVsTxyb_o.png" width="509"></p> 
<p>以上，谢谢阅读，感谢你的时间。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aad88d7a126423b8ca37a65128baf868/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">正则表达式之match（）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eefe16d31f74b165804989a596b16c55/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">操作系统—复杂的生产者-消费者问题（C语言，线程，含代码）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>