<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于opencv对图片进行base64格式的编解码 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于opencv对图片进行base64格式的编解码" />
<meta property="og:description" content="首先base64，了解一下：Base64就是一种基于64个可打印字符来表示二进制数据的方法。 表示二进制数，所以我得先让图片转化为二进制数据，然后对二进制数据进行base64编码； 或者先对base64字符串进行解码，然后再把二进制数据转化为图片保存或展示。
流程 编码 cv::Mat图片 -&gt; 二进制数据 bool imencode(const string&amp; ext, InputArray img, vector&amp; buf, const vector&amp; params=vector()) //ext： 图片后缀名，如&#34;.jpg&#34;或&#34;.png&#34; //img： 需要进行相关操作的图片 //buf： 输出二进制数据到该缓存。 //params：格式相关的参数 //params中的每个参数成对出现，即paramId_1, paramValue_1, paramId_2, paramValue_2, … ，当前支持如下参数： //JPEG：压缩质量 ( CV_IMWRITE_JPEG_QUALITY )，从0到100（数值越高质量越好），默认值为95。 //PNG： compression level ( CV_IMWRITE_PNG_COMPRESSION ) 从0到9。 数值越高，文件大小越小，压缩时间越长。默认值为3。 //PPM, PGM, or PBM：二进制标志 ( CV_IMWRITE_PXM_BINARY )，0 或 1。默认值为1。 2.二进制数据 -&gt; base64字符串 网上有很多的 base64编解码 源码，本文末会添加我使用的源码供参考。
附：
/*****test.cpp*****/ #include &lt;iostream&gt; #include &lt;opencv.hpp&gt; #include &lt;vector&gt; #include &lt;fstream&gt; #include &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c2b1b8775dadf6a2008967e2df1826d3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-06T11:30:07+08:00" />
<meta property="article:modified_time" content="2018-06-06T11:30:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于opencv对图片进行base64格式的编解码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>首先base64，了解一下：Base64就是一种基于64个可打印字符来<strong>表示二进制数据</strong>的方法。 <br> 表示二进制数，所以我得先让图片转化为二进制数据，然后对二进制数据进行base64编码； <br> 或者先对base64字符串进行解码，然后再把二进制数据转化为图片保存或展示。</p> 
<h3 id="流程">流程</h3> 
<ul><li>编码 <br> 
  <ol><li>cv::Mat图片 -&gt; 二进制数据</li></ol></li></ul> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> imencode(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; ext, InputArray img, <span class="hljs-built_in">vector</span>&amp; buf, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&amp; params=<span class="hljs-built_in">vector</span>())
<span class="hljs-comment">//ext：  图片后缀名，如".jpg"或".png"</span>
<span class="hljs-comment">//img：  需要进行相关操作的图片</span>
<span class="hljs-comment">//buf：  输出二进制数据到该缓存。</span>

<span class="hljs-comment">//params：格式相关的参数</span>
<span class="hljs-comment">//params中的每个参数成对出现，即paramId_1, paramValue_1, paramId_2, paramValue_2, … ，当前支持如下参数：</span>
<span class="hljs-comment">//JPEG：压缩质量 ( CV_IMWRITE_JPEG_QUALITY )，从0到100（数值越高质量越好），默认值为95。</span>
<span class="hljs-comment">//PNG：  compression level ( CV_IMWRITE_PNG_COMPRESSION ) 从0到9。 数值越高，文件大小越小，压缩时间越长。默认值为3。</span>
<span class="hljs-comment">//PPM,  PGM, or PBM：二进制标志 ( CV_IMWRITE_PXM_BINARY )，0 或 1。默认值为1。</span></code></pre> 
<p>2.二进制数据 -&gt; base64字符串 <br> 网上有很多的 base64编解码 源码，本文末会添加我使用的源码供参考。</p> 
<hr> 
<p>附：</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">/*****test.cpp*****/</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;opencv.hpp&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;fstream&gt;</span>
<span class="hljs-preprocessor">#include "base64.h"</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">void</span> write(<span class="hljs-built_in">string</span> encode_str);
<span class="hljs-built_in">string</span> read(<span class="hljs-built_in">string</span> fileName);
<span class="hljs-built_in">string</span> encode();
Mat decode();

<span class="hljs-keyword">int</span> main() {    
    Mat img = decode();
    imshow(<span class="hljs-string">"test"</span>, img);
    <span class="hljs-keyword">if</span> (waitKey(<span class="hljs-number">1</span>) == <span class="hljs-number">27</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/***编码得到的 base64字符串 写入 “base64_str” 保存***/</span>
<span class="hljs-keyword">void</span> write(<span class="hljs-built_in">string</span> encode_str)
{
    ofstream out;
    out.open(<span class="hljs-string">"base64_str"</span>, ios::out | ios::trunc);
    out &lt;&lt; encode_str &lt;&lt; endl;
    out.close();
}

<span class="hljs-comment">/***读取指定文件保存的 base64 字符串并返回***/</span>
<span class="hljs-built_in">string</span> read(<span class="hljs-built_in">string</span> fileName)
{
    <span class="hljs-built_in">string</span> base64_str;
    ifstream in;
    in.open(fileName, ios::in);
    in &gt;&gt; base64_str;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"base64_str.length() = "</span> &lt;&lt; base64_str.length() &lt;&lt; endl;
    in.close();
    <span class="hljs-keyword">return</span> base64_str;
}

<span class="hljs-comment">/***编码***/</span>
<span class="hljs-built_in">string</span> encode()
{
    <span class="hljs-built_in">string</span> img_path(<span class="hljs-string">"img.jpg"</span>);
    Mat img;
    img = imread(img_path);
    <span class="hljs-keyword">if</span> (img.empty())
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"img is empty"</span> &lt;&lt; endl;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Failed"</span>;
    }

    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uchar&gt;</span> img_data;
    imencode(<span class="hljs-string">".jpg"</span>, img, img_data);
    <span class="hljs-built_in">string</span> str_Encode(img_data.begin(), img_data.end());
    write(str_Encode);
}

<span class="hljs-comment">/***解码***/</span>
Mat decode()
{
    <span class="hljs-built_in">string</span> encode_str = read(<span class="hljs-string">"dog.base"</span>);
    <span class="hljs-built_in">string</span> decode_str;

    <span class="hljs-comment">//这里可以看到，我调用的第三方库支持std::string类的参数形式</span>
    Base64::Decode(encode_str, &amp;decode_str);
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;uchar&gt;</span> img_data(decode_str.begin(), decode_str.end());
    Mat img = imdecode(Mat(img_data), CV_LOAD_IMAGE_COLOR);
    <span class="hljs-keyword">return</span> img;
}</code></pre> 
<hr> 
<p>关于base64解码，碰到一个问题： <br> 借助在线编码器，将以下图片： <br> <img src="https://images2.imgbox.com/38/c7/pBQSTBO9_o.jpg" alt="这里写图片描述" title=""> <br> 转为base64字符串： <br> <strong>data:image/jpeg;base64,</strong>/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGB。。。。。。。。。 <br> 如果需要解析字符串，加粗部分需要删除，在未删除时，执行程序提示： <br> <img src="https://images2.imgbox.com/65/82/NuEIp7RJ_o.png" alt="这里写图片描述" title=""> <br> 删除后，运行正常： <br> <img src="https://images2.imgbox.com/10/4d/KYRBhhjz_o.png" alt="这里写图片描述" title=""></p> 
<hr> 
<p>刚刚发现csdn下载如果上传资源不能免费 0.0 </p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">/*****base64.h*****/</span>
<span class="hljs-preprocessor">#ifndef BASE64_H</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> BASE64_H</span>

<span class="hljs-preprocessor">#include &lt;string&gt;</span>

<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> kBase64Alphabet[] = <span class="hljs-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>
<span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span>
<span class="hljs-string">"0123456789+/"</span>;

class Base64 {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Encode</span>(<span class="hljs-keyword">const</span> std::<span class="hljs-keyword">string</span> &amp;<span class="hljs-keyword">in</span>, std::<span class="hljs-keyword">string</span> *<span class="hljs-keyword">out</span>) {
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;
        size_t enc_len = <span class="hljs-number">0</span>;
        unsigned <span class="hljs-keyword">char</span> a3[<span class="hljs-number">3</span>];
        unsigned <span class="hljs-keyword">char</span> a4[<span class="hljs-number">4</span>];

        <span class="hljs-keyword">out</span>-&gt;resize(EncodedLength(<span class="hljs-keyword">in</span>));

        <span class="hljs-keyword">int</span> input_len = <span class="hljs-keyword">in</span>.size();
        std::<span class="hljs-keyword">string</span>::const_iterator input = <span class="hljs-keyword">in</span>.begin();

        <span class="hljs-keyword">while</span> (input_len--) {
            a3[i++] = *(input++);
            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) {
                a3_to_a4(a4, a3);

                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
                    (*<span class="hljs-keyword">out</span>)[enc_len++] = kBase64Alphabet[a4[i]];
                }

                i = <span class="hljs-number">0</span>;
            }
        }

        <span class="hljs-keyword">if</span> (i) {
            <span class="hljs-keyword">for</span> (j = i; j &lt; <span class="hljs-number">3</span>; j++) {
                a3[j] = <span class="hljs-string">'\0'</span>;
            }

            a3_to_a4(a4, a3);

            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; i + <span class="hljs-number">1</span>; j++) {
                (*<span class="hljs-keyword">out</span>)[enc_len++] = kBase64Alphabet[a4[j]];
            }

            <span class="hljs-keyword">while</span> ((i++ &lt; <span class="hljs-number">3</span>)) {
                (*<span class="hljs-keyword">out</span>)[enc_len++] = <span class="hljs-string">'='</span>;
            }
        }

        <span class="hljs-keyword">return</span> (enc_len == <span class="hljs-keyword">out</span>-&gt;size());
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> Encode(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *input, size_t input_length, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">out</span>, size_t out_length) {
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">char</span> *out_begin = <span class="hljs-keyword">out</span>;
        unsigned <span class="hljs-keyword">char</span> a3[<span class="hljs-number">3</span>];
        unsigned <span class="hljs-keyword">char</span> a4[<span class="hljs-number">4</span>];

        size_t encoded_length = EncodedLength(input_length);

        <span class="hljs-keyword">if</span> (out_length &lt; encoded_length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

        <span class="hljs-keyword">while</span> (input_length--) {
            a3[i++] = *input++;
            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) {
                a3_to_a4(a4, a3);

                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
                    *<span class="hljs-keyword">out</span>++ = kBase64Alphabet[a4[i]];
                }

                i = <span class="hljs-number">0</span>;
            }
        }

        <span class="hljs-keyword">if</span> (i) {
            <span class="hljs-keyword">for</span> (j = i; j &lt; <span class="hljs-number">3</span>; j++) {
                a3[j] = <span class="hljs-string">'\0'</span>;
            }

            a3_to_a4(a4, a3);

            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; i + <span class="hljs-number">1</span>; j++) {
                *<span class="hljs-keyword">out</span>++ = kBase64Alphabet[a4[j]];
            }

            <span class="hljs-keyword">while</span> ((i++ &lt; <span class="hljs-number">3</span>)) {
                *<span class="hljs-keyword">out</span>++ = <span class="hljs-string">'='</span>;
            }
        }

        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">out</span> == (out_begin + encoded_length));
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> Decode(<span class="hljs-keyword">const</span> std::<span class="hljs-keyword">string</span> &amp;<span class="hljs-keyword">in</span>, std::<span class="hljs-keyword">string</span> *<span class="hljs-keyword">out</span>) {
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;
        size_t dec_len = <span class="hljs-number">0</span>;
        unsigned <span class="hljs-keyword">char</span> a3[<span class="hljs-number">3</span>];
        unsigned <span class="hljs-keyword">char</span> a4[<span class="hljs-number">4</span>];

        <span class="hljs-keyword">int</span> input_len = <span class="hljs-keyword">in</span>.size();
        std::<span class="hljs-keyword">string</span>::const_iterator input = <span class="hljs-keyword">in</span>.begin();

        <span class="hljs-keyword">out</span>-&gt;resize(DecodedLength(<span class="hljs-keyword">in</span>));

        <span class="hljs-keyword">while</span> (input_len--) {
            <span class="hljs-keyword">if</span> (*input == <span class="hljs-string">'='</span>) {
                <span class="hljs-keyword">break</span>;
            }

            a4[i++] = *(input++);
            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">4</span>) {
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
                    a4[i] = b64_lookup(a4[i]);
                }

                a4_to_a3(a3, a4);

                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
                    (*<span class="hljs-keyword">out</span>)[dec_len++] = a3[i];
                }

                i = <span class="hljs-number">0</span>;
            }
        }

        <span class="hljs-keyword">if</span> (i) {
            <span class="hljs-keyword">for</span> (j = i; j &lt; <span class="hljs-number">4</span>; j++) {
                a4[j] = <span class="hljs-string">'\0'</span>;
            }

            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) {
                a4[j] = b64_lookup(a4[j]);
            }

            a4_to_a3(a3, a4);

            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; i - <span class="hljs-number">1</span>; j++) {
                (*<span class="hljs-keyword">out</span>)[dec_len++] = a3[j];
            }
        }

        <span class="hljs-keyword">return</span> (dec_len == <span class="hljs-keyword">out</span>-&gt;size());
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> Decode(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *input, size_t input_length, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">out</span>, size_t out_length) {
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">char</span> *out_begin = <span class="hljs-keyword">out</span>;
        unsigned <span class="hljs-keyword">char</span> a3[<span class="hljs-number">3</span>];
        unsigned <span class="hljs-keyword">char</span> a4[<span class="hljs-number">4</span>];

        size_t decoded_length = DecodedLength(input, input_length);

        <span class="hljs-keyword">if</span> (out_length &lt; decoded_length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

        <span class="hljs-keyword">while</span> (input_length--) {
            <span class="hljs-keyword">if</span> (*input == <span class="hljs-string">'='</span>) {
                <span class="hljs-keyword">break</span>;
            }

            a4[i++] = *(input++);
            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">4</span>) {
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
                    a4[i] = b64_lookup(a4[i]);
                }

                a4_to_a3(a3, a4);

                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
                    *<span class="hljs-keyword">out</span>++ = a3[i];
                }

                i = <span class="hljs-number">0</span>;
            }
        }

        <span class="hljs-keyword">if</span> (i) {
            <span class="hljs-keyword">for</span> (j = i; j &lt; <span class="hljs-number">4</span>; j++) {
                a4[j] = <span class="hljs-string">'\0'</span>;
            }

            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) {
                a4[j] = b64_lookup(a4[j]);
            }

            a4_to_a3(a3, a4);

            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; i - <span class="hljs-number">1</span>; j++) {
                *<span class="hljs-keyword">out</span>++ = a3[j];
            }
        }

        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">out</span> == (out_begin + decoded_length));
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> DecodedLength(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">in</span>, size_t in_length) {
        <span class="hljs-keyword">int</span> numEq = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *in_end = <span class="hljs-keyword">in</span> + in_length;
        <span class="hljs-keyword">while</span> (*--in_end == <span class="hljs-string">'='</span>) ++numEq;

        <span class="hljs-keyword">return</span> ((<span class="hljs-number">6</span> * in_length) / <span class="hljs-number">8</span>) - numEq;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> DecodedLength(<span class="hljs-keyword">const</span> std::<span class="hljs-keyword">string</span> &amp;<span class="hljs-keyword">in</span>) {
        <span class="hljs-keyword">int</span> numEq = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> n = <span class="hljs-keyword">in</span>.size();

        <span class="hljs-keyword">for</span> (std::<span class="hljs-keyword">string</span>::const_reverse_iterator it = <span class="hljs-keyword">in</span>.rbegin(); *it == <span class="hljs-string">'='</span>; ++it) {
            ++numEq;
        }

        <span class="hljs-keyword">return</span> ((<span class="hljs-number">6</span> * n) / <span class="hljs-number">8</span>) - numEq;
    }

    inline <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> EncodedLength(size_t length) {
        <span class="hljs-keyword">return</span> (length + <span class="hljs-number">2</span> - ((length + <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>)) / <span class="hljs-number">3</span> * <span class="hljs-number">4</span>;
    }

    inline <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> EncodedLength(<span class="hljs-keyword">const</span> std::<span class="hljs-keyword">string</span> &amp;<span class="hljs-keyword">in</span>) {
        <span class="hljs-keyword">return</span> EncodedLength(<span class="hljs-keyword">in</span>.length());
    }

    inline <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> StripPadding(std::<span class="hljs-keyword">string</span> *<span class="hljs-keyword">in</span>) {
        <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">in</span>-&gt;empty() &amp;&amp; *(<span class="hljs-keyword">in</span>-&gt;rbegin()) == <span class="hljs-string">'='</span>) <span class="hljs-keyword">in</span>-&gt;resize(<span class="hljs-keyword">in</span>-&gt;size() - <span class="hljs-number">1</span>);
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">static</span> inline <span class="hljs-keyword">void</span> <span class="hljs-title">a3_to_a4</span>(unsigned <span class="hljs-keyword">char</span> * a4, unsigned <span class="hljs-keyword">char</span> * a3) {
        a4[<span class="hljs-number">0</span>] = (a3[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xfc</span>) &gt;&gt; <span class="hljs-number">2</span>;
        a4[<span class="hljs-number">1</span>] = ((a3[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x03</span>) &lt;&lt; <span class="hljs-number">4</span>) + ((a3[<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0xf0</span>) &gt;&gt; <span class="hljs-number">4</span>);
        a4[<span class="hljs-number">2</span>] = ((a3[<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0x0f</span>) &lt;&lt; <span class="hljs-number">2</span>) + ((a3[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0xc0</span>) &gt;&gt; <span class="hljs-number">6</span>);
        a4[<span class="hljs-number">3</span>] = (a3[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0x3f</span>);
    }

    <span class="hljs-keyword">static</span> inline <span class="hljs-keyword">void</span> a4_to_a3(unsigned <span class="hljs-keyword">char</span> * a3, unsigned <span class="hljs-keyword">char</span> * a4) {
        a3[<span class="hljs-number">0</span>] = (a4[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">2</span>) + ((a4[<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0x30</span>) &gt;&gt; <span class="hljs-number">4</span>);
        a3[<span class="hljs-number">1</span>] = ((a4[<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0xf</span>) &lt;&lt; <span class="hljs-number">4</span>) + ((a4[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0x3c</span>) &gt;&gt; <span class="hljs-number">2</span>);
        a3[<span class="hljs-number">2</span>] = ((a4[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0x3</span>) &lt;&lt; <span class="hljs-number">6</span>) + a4[<span class="hljs-number">3</span>];
    }

    <span class="hljs-keyword">static</span> inline unsigned <span class="hljs-keyword">char</span> b64_lookup(unsigned <span class="hljs-keyword">char</span> c) {
        <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">'A'</span> &amp;&amp; c &lt;= <span class="hljs-string">'Z'</span>) <span class="hljs-keyword">return</span> c - <span class="hljs-string">'A'</span>;
        <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">'a'</span> &amp;&amp; c &lt;= <span class="hljs-string">'z'</span>) <span class="hljs-keyword">return</span> c - <span class="hljs-number">71</span>;
        <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) <span class="hljs-keyword">return</span> c + <span class="hljs-number">4</span>;
        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">62</span>;
        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'/'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">63</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">255</span>;
    }
};

<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span> // BASE64_H</span></code></pre> 
<blockquote> 
 <p>参考:<a href="https://windrocblog.sinaapp.com/?p=465" rel="nofollow">OpenCV学习笔记（一）：读取、显示、保存图片</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9c38b7081d6e24575053c1af45951fa5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">log4j:WARN No appenders could be found for logger 解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eeabc1a65e4b98d39db8ea1b056a91af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">编译原理第六、七章总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>