<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MybatisPlus基本使用（MP快速上手） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MybatisPlus基本使用（MP快速上手）" />
<meta property="og:description" content="目录
概述
MP快速上手（基本操作）
SpringBoot中MyBatisPlus环境搭建
增删改查
分页
条件查询（聚合，模糊，匹配范围）
条件：范围匹配 （大于小于等于...）
优化查询条件书写（）
条件：查询投影
条件：模糊查询（非全文检索）
条件：聚合函数和分组
条件：排序操作 条件判断（条件为null时情况处理）
字段映射和表名映射
id生成策略
​编辑
多数据操作
概述 MyBatisplus（简称MP）是基于MyBatis框架基础上开发的增强型工具。
作用：简化开发，提高效率。 MP核心：为简化开发而生。
MP由国人开发，在 Mybatis 的基础上只做增强不做改变，MP中内置了一些常用访问数据库数据的方法，例如CRUD方法等，我们不需要声明就直接可以使用。
MP快速上手（基本操作） 下面就使用Spring-Boot工程作为基本来介绍MP的使用。如下的介绍中，只针对数据层进行使用测试，并不涉及业务层和表现层。
SpringBoot中MyBatisPlus环境搭建 ，在SpringBoot中配置MP环境很简单，只需要导入MP的起步依赖，配置数据源，完善数据表和pojo类，设置数据层接口，然后调用即可。
一、创建Boot工程，导入MP依赖
说明：
1.使用正统方式创建（start.spring.io），在选择起步依赖时，并没有MyBatisPlus的选项，没有关系，直接创建，创建好之后再导入依赖即可。
2.使用阿里云(start.aliyun.com)创建boot工程，就会存在MP的起步依赖，直接选择即可。
官方方式创建boot工程起步依赖选择
阿里云方式创建boot工程起步依赖选择
使用官方方式创建后，手动导入MP起步依赖：
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; 二、配置数据源
在此使用druid的数据源，使用druid的起步依赖后可以进行如下方式书写。方式不用一致，配置好数据源信息即可。
spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/test username: root password: root 三、准备测试数据表和实体类
在此使用test数据库下的account表，表字段和数据信息如下：
书写与之对应的实体类
说明： 在此使用lombok配置实体类，lombok为快速开发实体类的工具，只需要加几个注解就可以实现实体类的get、set、toString等方法，想要使用，需要导入依赖坐标即可。
@Data @AllArgsConstructor @NoArgsConstructor public class Account { private int id; private String name; private double balance; } lombok坐标" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ccff394ad1fd3c54a553da9ea68e064a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-31T08:43:34+08:00" />
<meta property="article:modified_time" content="2023-03-31T08:43:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MybatisPlus基本使用（MP快速上手）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E6%A6%82%E8%BF%B0" rel="nofollow">概述</a></p> 
<p id="MP%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%89-toc" style="margin-left:0px;"><a href="#MP%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%89" rel="nofollow">MP快速上手（基本操作）</a></p> 
<p id="%C2%A0SpringBoot%E4%B8%ADMyBatisPlus%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-toc" style="margin-left:40px;"><a href="#%C2%A0SpringBoot%E4%B8%ADMyBatisPlus%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" rel="nofollow"> SpringBoot中MyBatisPlus环境搭建</a></p> 
<p id="%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-toc" style="margin-left:40px;"><a href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5" rel="nofollow">增删改查</a></p> 
<p id="%E5%88%86%E9%A1%B5-toc" style="margin-left:40px;"><a href="#%E5%88%86%E9%A1%B5" rel="nofollow">分页</a></p> 
<p id="%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%EF%BC%88%E8%81%9A%E5%90%88%EF%BC%8C%E6%A8%A1%E7%B3%8A%EF%BC%8C%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%EF%BC%88%E8%81%9A%E5%90%88%EF%BC%8C%E6%A8%A1%E7%B3%8A%EF%BC%8C%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4%EF%BC%89" rel="nofollow">条件查询（聚合，模糊，匹配范围）</a></p> 
<p id="%E6%9D%A1%E4%BB%B6%EF%BC%9A%E8%8C%83%E5%9B%B4%E5%8C%B9%E9%85%8D%C2%A0%EF%BC%88%E5%A4%A7%E4%BA%8E%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E...%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E6%9D%A1%E4%BB%B6%EF%BC%9A%E8%8C%83%E5%9B%B4%E5%8C%B9%E9%85%8D%C2%A0%EF%BC%88%E5%A4%A7%E4%BA%8E%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E...%EF%BC%89" rel="nofollow">条件：范围匹配 （大于小于等于...）</a></p> 
<p id="%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%B9%A6%E5%86%99%EF%BC%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%B9%A6%E5%86%99%EF%BC%88%EF%BC%89" rel="nofollow">优化查询条件书写（）</a></p> 
<p id="%E6%9D%A1%E4%BB%B6%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%8A%95%E5%BD%B1-toc" style="margin-left:80px;"><a href="#%E6%9D%A1%E4%BB%B6%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%8A%95%E5%BD%B1" rel="nofollow">条件：查询投影</a></p> 
<p id="%E6%9D%A1%E4%BB%B6%EF%BC%9A%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%EF%BC%88%E9%9D%9E%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E6%9D%A1%E4%BB%B6%EF%BC%9A%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%EF%BC%88%E9%9D%9E%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%EF%BC%89" rel="nofollow">条件：模糊查询（非全文检索）</a></p> 
<p id="%C2%A0%E6%9D%A1%E4%BB%B6%EF%BC%9A%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%88%86%E7%BB%84-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%9D%A1%E4%BB%B6%EF%BC%9A%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%88%86%E7%BB%84" rel="nofollow"> 条件：聚合函数和分组</a></p> 
<p id="%E6%9D%A1%E4%BB%B6%EF%BC%9A%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%E6%9D%A1%E4%BB%B6%EF%BC%9A%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0" rel="nofollow">条件：排序操作        </a></p> 
<p id="%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%EF%BC%88%E6%9D%A1%E4%BB%B6%E4%B8%BAnull%E6%97%B6%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%EF%BC%88%E6%9D%A1%E4%BB%B6%E4%B8%BAnull%E6%97%B6%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86%EF%BC%89" rel="nofollow">条件判断（条件为null时情况处理）</a></p> 
<p id="%E5%AD%97%E6%AE%B5%E6%98%A0%E5%B0%84%E5%92%8C%E8%A1%A8%E5%90%8D%E6%98%A0%E5%B0%84-toc" style="margin-left:40px;"><a href="#%E5%AD%97%E6%AE%B5%E6%98%A0%E5%B0%84%E5%92%8C%E8%A1%A8%E5%90%8D%E6%98%A0%E5%B0%84" rel="nofollow">字段映射和表名映射</a></p> 
<p id="id%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5-toc" style="margin-left:40px;"><a href="#id%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5" rel="nofollow">id生成策略</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​编辑</a></p> 
<p id="%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C" rel="nofollow">多数据操作</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%A6%82%E8%BF%B0">概述</h2> 
<p>MyBatisplus（<strong>简称MP</strong>）是基于MyBatis框架基础上开发的增强型工具。</p> 
<p><strong>作用</strong>：简化开发，提高效率。 </p> 
<p><strong>MP核心</strong>：为简化开发而生。</p> 
<p>MP由国人开发，在 Mybatis 的基础上只做增强不做改变，MP中内置了一些常用访问数据库数据的方法，例如CRUD方法等，我们不需要声明就直接可以使用。</p> 
<hr> 
<h2 id="MP%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%89">MP快速上手（基本操作）</h2> 
<blockquote> 
 <p> 下面就使用<strong>Spring-Boot工程作为基本</strong>来介绍MP的使用。如下的介绍中，只针对数据层进行使用测试，并不涉及业务层和表现层。</p> 
</blockquote> 
<h3 id="%C2%A0SpringBoot%E4%B8%ADMyBatisPlus%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"> SpringBoot中MyBatisPlus环境搭建</h3> 
<p>，在SpringBoot中配置MP环境很简单，只需要导入MP的起步依赖，配置数据源，完善数据表和pojo类，设置数据层接口，然后调用即可。</p> 
<p><strong>一、创建Boot工程，导入MP依赖</strong></p> 
<blockquote> 
 <p>说明：</p> 
 <p>1.使用<strong>正统方式</strong>创建（start.spring.io），在选择起步依赖时，并<strong>没有MyBatisPlus的选项</strong>，没有关系，直接创建，创建好之后再导入依赖即可。</p> 
 <p>2.使用<strong>阿里云</strong>(start.aliyun.com)创建boot工程，就会<strong>存在MP的起步依赖</strong>，直接选择即可。</p> 
</blockquote> 
<p> 官方方式创建boot工程起步依赖选择</p> 
<p><img alt="8127d4854e064546a7e6c74244ef43ee.png" src="https://images2.imgbox.com/0a/16/mihX2QfW_o.png"></p> 
<p>阿里云方式创建boot工程起步依赖选择</p> 
<p><img alt="2e9e82f29ace4823a001dd2bf534accf.png" src="https://images2.imgbox.com/e2/dd/DHlTKLcY_o.png"></p> 
<p><strong> 使用官方方式创建后，手动导入MP起步依赖：</strong></p> 
<pre><code class="language-XML">&lt;dependency&gt;
	&lt;groupId&gt;com.baomidou&lt;/groupId&gt;
	&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
	&lt;version&gt;3.4.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p><strong>二、配置数据源</strong></p> 
<blockquote> 
 <p>在此使用druid的数据源，使用druid的起步依赖后可以进行如下方式书写。方式不用一致，配置好数据源信息即可。</p> 
</blockquote> 
<pre><code class="language-html">spring:
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/test
      username: root
      password: root</code></pre> 
<p><strong>三、准备测试数据表和实体类</strong></p> 
<p>在此使用test数据库下的account表，表字段和数据信息如下：</p> 
<p><img alt="8761124eb6424a7e967258b439833772.png" src="https://images2.imgbox.com/6d/b1/Ld9vPKhA_o.png"></p> 
<p><strong> 书写与之对应的实体类</strong></p> 
<blockquote> 
 <p>说明： 在此使用lombok配置实体类，lombok为快速开发实体类的工具，只需要加几个注解就可以实现实体类的get、set、toString等方法，想要使用，需要导入依赖坐标即可。</p> 
</blockquote> 
<pre><code class="language-java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Account {
    private int id;
    private String name;
    private double balance;
}</code></pre> 
<p><strong>lombok坐标</strong></p> 
<pre><code class="language-XML">&lt;dependency&gt;
	&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
	&lt;artifactId&gt;lombok&lt;/artifactId&gt;
	&lt;version&gt;1.18.22&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p><strong>四、设置数据层接口</strong></p> 
<pre><code class="language-java">@Mapper
public interface AccountDAO extends BaseMapper&lt;Account&gt; {
}</code></pre> 
<blockquote> 
 <p>至此，MP环境就搭建好了，因为MP内置了许多常用的方法，所有我们直接就可以测试了。 </p> 
</blockquote> 
<p><strong> 工程结构：</strong></p> 
<p><img alt="9293c67295aa408aba05ab48cb74c985.png" src="https://images2.imgbox.com/4e/ba/ecp06xJd_o.png"></p> 
<p><strong> 五、测试，通过下面的基本使用进行测试。</strong></p> 
<hr> 
<h3 id="%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">增删改查</h3> 
<p>做完上述的准备工作，把MP的环境搭建好以后，就可以开始使用MP了。先从最基本的CRUD开始：测试在测试类下进行（只使用数据层做测试）。</p> 
<p><img alt="871356b832474b9aa631b5bdf2968f54.png" src="https://images2.imgbox.com/a7/56/FgU0VBVk_o.png"></p> 
<p><strong> 基本CURD操作</strong></p> 
<pre><code class="language-java">
//自动装配数据层接口
@Autowired
private AccountDAO accountDAO;

//增添数据
@Test
void insertTest(){
	Account account = new Account(7, "Mh", 6000);
	accountDAO.insert(account);
}

//删除数据
@Test
void deleteTest(){
	accountDAO.deleteById(7);
}

//修改数据
@Test
void updateTest(){
	Account account = new Account(6, "MH", 6000);
	accountDAO.updateById(account);
}

//根据ID查询单个信息
@Test
void selectTest() {
	Account account = accountDAO.selectById(1);
	System.out.println(account);
}
//获取表中所有数据
@Test
void selecAlltTest() {
    //selectList参数为null，代表没有查询条件
	List&lt;Account&gt; accounts = accountDAO.selectList(null);
	accounts.forEach(System.out::println);
	
}</code></pre> 
<h3 id="%E5%88%86%E9%A1%B5">分页</h3> 
<p>分页操作MP内部也有实现，不过并不像上面的CRUD这样简单，我们需要去做一些配置。</p> 
<blockquote> 
 <p><strong>MP实现分页查询步骤：</strong></p> 
 <p>1.需要先<strong>添加拦截器</strong>-分页拦截器<br> 2.<strong>创建IPage实现类</strong>，构造器初始化Page<br> 3.IPage调用方法，获取数据信息</p> 
</blockquote> 
<p><strong>实现：</strong></p> 
<p>1.创建MP拦截器类，添加分页内置拦截器。</p> 
<pre><code class="language-java">@Configuration
public class MPConfig {

    @Bean
    public MybatisPlusInterceptor getInterceptor(){
		//创建MP拦截器
        MybatisPlusInterceptor MPInterceptor = new MybatisPlusInterceptor();
		//添加分页拦截器
        MPInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
		//将设置好的拦截器返回
        return MPInterceptor;
    }

}</code></pre> 
<p>2.创建并初始化IPage实现类，实现分页查询</p> 
<pre><code class="language-java">@Test
void selectPageTest(){
    //创建IPage实现类,参数为（当前页数，每页记录数）
	IPage page = new Page(1,2);
    //参数null为条件-无条件查询
	accountDAO.selectPage(page,null);
	page.getPages(); // 获取总页数
	page.getCurrent(); // 获取当前页数
	page.getRecords(); // 获取记录（数据）
	page.getSize(); // 获取每页记录数
	page.getTotal(); // 获取记录总数
    //将想要得到的信息输出即可
}</code></pre> 
<h3 id="%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%EF%BC%88%E8%81%9A%E5%90%88%EF%BC%8C%E6%A8%A1%E7%B3%8A%EF%BC%8C%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4%EF%BC%89">条件查询（聚合，模糊，匹配范围）</h3> 
<h4 id="%E6%9D%A1%E4%BB%B6%EF%BC%9A%E8%8C%83%E5%9B%B4%E5%8C%B9%E9%85%8D%C2%A0%EF%BC%88%E5%A4%A7%E4%BA%8E%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E...%EF%BC%89">条件：范围匹配 （大于小于等于...）</h4> 
<p>在上述的操作中，例如selectList，selectPage等，都有一个参数我们设置为null，如果不设置为null，那这个条件参数我们要怎么设置呢？如下说明：</p> 
<p><img alt="ad2bac740b0649e5838531982f59d8af.png" src="https://images2.imgbox.com/84/08/g5ZTDPTQ_o.png"></p> 
<p> 拿selectList举例，可以看到条件参数的类型为queryWrapper,那么我们就创建一个queryWrapper对象看看。</p> 
<blockquote> 
 <p>QueryWrapper&lt;Account&gt; qw = new QueryWrapper&lt;&gt;();</p> 
 <p>可以使用qw对象.的方式看看有哪些方法：</p> 
</blockquote> 
<p><img alt="db69387d0a7247278b4787b3e7f7b33e.png" src="https://images2.imgbox.com/6e/2c/eGz9DJxV_o.png"></p> 
<p> 看到列出来了许多条件，最基本的条件说明：</p> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;">大于<strong>gt</strong></p> 
 <p style="margin-left:0;text-align:justify;">小于 <strong>lt</strong></p> 
 <p style="margin-left:0;text-align:justify;">大于等于 <strong>ge</strong></p> 
 <p style="margin-left:0;text-align:justify;">小于等于 <strong>le</strong></p> 
 <p style="margin-left:0;text-align:justify;">等于 <strong>eq</strong></p> 
 <p style="margin-left:0;text-align:justify;">区间 <strong>between</strong></p> 
</blockquote> 
<p>我们就拿lt来举例，我们就设置条件为<strong>balance小于6000</strong>的。就应该这样写：</p> 
<p>设置好条件后将条件对象给到selectList</p> 
<pre><code class="language-java">@Test
void selecAlltTest() {
	QueryWrapper&lt;Account&gt; qw = new QueryWrapper&lt;&gt;();
	qw.lt("balance",6000);
	List&lt;Account&gt; accounts = accountDAO.selectList(qw);
	accounts.forEach(System.out::println);
}</code></pre> 
<p><strong>查询结果</strong>： </p> 
<p><img alt="4246d15fd2ef4a02b46fc300fc8d8f7d.png" src="https://images2.imgbox.com/32/a8/MTNNt3mo_o.png"></p> 
<h4 id="%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%B9%A6%E5%86%99%EF%BC%88%EF%BC%89">优化查询条件书写（）</h4> 
<p>优化说明：由于qw.lt("balance",6000);这样的写法，balance是我们手动通过字符串的方式输入的，可能会存在人为书写时的错误，这时候我们就可以<strong>使用LambdaQueryWrapper</strong>，因为这样的写法会对属性进行语法检查，可以避免一些错误，使用如下：</p> 
<pre><code class="language-java">@Test
void selecAlltTest() {
	//QueryWrapper&lt;Account&gt; qw = new QueryWrapper&lt;&gt;();
	//qw.lt("balance",6000);
	LambdaQueryWrapper&lt;Account&gt; lqw = new LambdaQueryWrapper&lt;&gt;();
	lqw.lt(Account::getBalance,6000);
	List&lt;Account&gt; accounts = accountDAO.selectList(lqw);
	accounts.forEach(System.out::println);
}</code></pre> 
<p><strong>多条件设置方式：</strong></p> 
<blockquote> 
 <p>在此设置条件为balance大于6000，小于9000。</p> 
</blockquote> 
<pre><code class="language-java">@Test
void selecAlltTest() {
	LambdaQueryWrapper&lt;Account&gt; lqw = new LambdaQueryWrapper&lt;&gt;();
	//方式1
	lqw.lt(Account::getBalance,9000);
	lqw.gt(Account::getBalance,6000);
	//方式2：链式编程
	lqw.lt(Account::getBalance,9000).gt(Account::getBalance,6000);
	List&lt;Account&gt; accounts = accountDAO.selectList(lqw);
	accounts.forEach(System.out::println);
}</code></pre> 
<p><strong>查询结果： </strong></p> 
<p> <img alt="f6f50a7deec048e6b629fade58ace3d6.png" src="https://images2.imgbox.com/a0/5d/REw5fyiN_o.png"></p> 
<blockquote> 
 <p>说明：在如上的操作中，关系均为and（默认），如果想使用or关系，可以这样写：</p> 
</blockquote> 
<pre><code class="language-java">@Test
void selecAlltTest() {
	LambdaQueryWrapper&lt;Account&gt; lqw = new LambdaQueryWrapper&lt;&gt;();
	//方式1
	lqw.lt(Account::getBalance,9000);
	lqw.or().gt(Account::getBalance,6000);
	//方式2：链式编程
	lqw.lt(Account::getBalance,9000).or().gt(Account::getBalance,6000);
	List&lt;Account&gt; accounts = accountDAO.selectList(lqw);
	accounts.forEach(System.out::println);
}</code></pre> 
<p>至于其他的范围条件，例如等于eq，范围between，用法基本一致。 </p> 
<h4 id="%E6%9D%A1%E4%BB%B6%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%8A%95%E5%BD%B1">条件：查询投影</h4> 
<p>查询投影，说白了就是：设置需要查询的字段。例如：select id from tb_test</p> 
<p>里面的id，就是我们设置查询的字段。</p> 
<pre><code class="language-java">//条件查询测试
@Test
void selectAllConditionTest() {
	LambdaQueryWrapper&lt;Account&gt; lqw = new LambdaQueryWrapper&lt;&gt;();
	lqw.select(Account::getName,Account::getBalance);
	List&lt;Account&gt; accounts = accountDAO.selectList(lqw);
	accounts.forEach(System.out::println);
}</code></pre> 
<p>说明：如果使用的是QueryWrapper，在select()中直接使用字符串传入即可。 </p> 
<h4 id="%E6%9D%A1%E4%BB%B6%EF%BC%9A%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%EF%BC%88%E9%9D%9E%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%EF%BC%89">条件：模糊查询（非全文检索）</h4> 
<p>使用模糊查询，可以使用like,leftLike,rightLike ,他们的区别就是，把%放到什么位置，like放到两边</p> 
<p>%like%,leftLike放左边%leck ，相当于是以什么结尾。rightLike相似。</p> 
<p>在此演示<strong>name中包含字符"J"的记录</strong>了：</p> 
<pre><code class="language-java">@Test
void selectAllConditionTest() {
	LambdaQueryWrapper&lt;Account&gt; lqw = new LambdaQueryWrapper&lt;&gt;();
	lqw.like(Account::getName,"J");
	List&lt;Account&gt; accounts = accountDAO.selectList(lqw);
	accounts.forEach(System.out::println);
}</code></pre> 
<p><strong>查询结果</strong></p> 
<p><img alt="a6a327eba0984eb5910150e73b538f81.png" src="https://images2.imgbox.com/9c/ec/4PUzIPwT_o.png"></p> 
<h4 id="%C2%A0%E6%9D%A1%E4%BB%B6%EF%BC%9A%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%88%86%E7%BB%84"> 条件：聚合函数和分组</h4> 
<p>在使用聚合函数和分组时，我们就不可以使用LambdaQueryWrapper了，只能使用QueryWrapper。使用如下（测试count）：</p> 
<pre><code class="language-java">//测试聚合函数和分组
@Test
void selectAllConditionTest1() {
	QueryWrapper&lt;Account&gt; qw = new QueryWrapper&lt;&gt;();
	qw.select("count(*)"); // 计数
	qw.groupBy("balance"); // 根据balance分组
	List&lt;Map&lt;String, Object&gt;&gt; maps = accountDAO.selectMaps(qw);
	System.out.println(maps);
}</code></pre> 
<p><strong>输出结果 </strong></p> 
<p><img alt="3f997e82dc3e489e8bd10061e8cc0d92.png" src="https://images2.imgbox.com/42/8d/PCRl8tWv_o.png"> 结果说明，<strong>数据表数据</strong>： </p> 
<p><img alt="7e4283c34be44e4fade3690123afc194.png" src="https://images2.imgbox.com/8f/a5/kGr7U68r_o.png"></p> 
<h4 id="%E6%9D%A1%E4%BB%B6%EF%BC%9A%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0">条件：排序操作        </h4> 
<p><strong>排序操作演示：</strong></p> 
<pre><code class="language-java"> //MP查询排序
@Test
void selectConditionSort(){
	QueryWrapper&lt;Account&gt; qw = new QueryWrapper&lt;&gt;();
	qw.orderByAsc("balance");
	List&lt;Account&gt; accounts = accountDAO.selectList(qw);
	accounts.forEach(System.out::println);
}</code></pre> 
<blockquote> 
 <p>说明：在其中orderByAsc为升序排序，要想使用降序，应该为orderByDesc ,我想这应该不用解释，SQL的知识。</p> 
</blockquote> 
<p><strong>查询结果： </strong></p> 
<p><img alt="291888437e3a4da4ae9f06f4dfc6c6b6.png" src="https://images2.imgbox.com/1e/7a/lxnPJC3h_o.png"></p> 
<p></p> 
<h4 id="%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%EF%BC%88%E6%9D%A1%E4%BB%B6%E4%B8%BAnull%E6%97%B6%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86%EF%BC%89">条件判断（条件为null时情况处理）</h4> 
<p>条件判断为null时，应用场景：当一个值的范围有上限和下限时，用户如果只设置一个，例如只设置上限，就应该以这一个条件进行查询，下限没设置就默认为null，，null的话就会报错，这是不合理的，合理情况应该是：当用户没有设置该条件时，条件应当不生效。当，因此需要对此进行判断处理（处理数据为null的情况）。相当于是动态SQL的处理情况。</p> 
<blockquote> 
 <p><strong>需求</strong>：现在想要根据余额（balance）查询用户的信息，我们可以设置单独设置上限或下限，获取两者都设置，两者都设置的情况相当于区间。理想的情况是：当我们只设置一个条件时，例如，只设置上限，那么下限这个条件就不应该设置。这个时候，我们就要使用判断来做（判断条件是否为null）。</p> 
</blockquote> 
<pre><code class="language-java">//条件查询(条件为null的处理情况)
@Test
void selectConditionCaseNull(){
//设置标记：标记为1条件存在 标记为0条件不存在
//下限标记
int downFlag = 1;
//上限标记
int upFlag = 0;

LambdaQueryWrapper&lt;Account&gt; lqw = new LambdaQueryWrapper&lt;&gt;();
//当upFlag不等于0，相当于上限条件已经设置，那么就查询记录中balance小于9000的记录。
lqw.lt(0 != upFlag ,Account::getBalance,9000);
//当upFlag不等于0，相当于下限条件已经设置，那么就查询记录中balance大于6000的记录。
lqw.gt(0 != downFlag,Account::getBalance,6000);
//由上面设置的标记，条件应该是只设置了下限，那么查询结果应该是大于6000
List&lt;Account&gt; accounts = accountDAO.selectList(lqw);
accounts.forEach(System.out::println);

}</code></pre> 
<p><strong>查询结果：</strong></p> 
<p>发现确实只有一个条件执行。 </p> 
<p><img alt="f2e5207698314679a8a54edd819e5175.png" src="https://images2.imgbox.com/8f/65/sdYWw4z8_o.png"></p> 
<hr> 
<h3 id="%E5%AD%97%E6%AE%B5%E6%98%A0%E5%B0%84%E5%92%8C%E8%A1%A8%E5%90%8D%E6%98%A0%E5%B0%84">字段映射和表名映射</h3> 
<p>字段映射和表名映射说的<strong>主体</strong>就是"编码<strong>属性</strong>"和"表中<strong>字段</strong>"。</p> 
<p><strong>作用</strong>：解决实体类编码时的属性和表中字段匹配情况，解决表名和类名匹配的情况。以及字段限值问题。</p> 
<blockquote> 
 <p><strong>**解决1**</strong></p> 
 <p><strong>情况</strong>：当我们的表名和实体类名不一致时，因为我们使用MP的内置方法时，传入的只有实体类的泛型，MP会根据这个传入的泛型去找到对应的操作表，我们知道传入的泛型就是实体类，如果实体类的类名和表中的表名不一致，那么就会导致找不到表，导致错误。先看一下报错信息：</p> 
</blockquote> 
<p><strong>表名和实体类名 </strong></p> 
<p><img alt="9d2292098aaf443487d163995f8324be.png" src="https://images2.imgbox.com/a4/69/uo6x2iwZ_o.png"></p> 
<p><img alt="43f57d10054f434d978f5b61ea9b0d88.png" src="https://images2.imgbox.com/36/dc/GxUvWyZW_o.png">  </p> 
<p>报错信息：可以看到是Table 'test.account1' doesn't exist"，同步异常，也就是无法匹配，表xx不存在。</p> 
<p><img alt="32a52fa4844e4615963889e24f1b5449.png" src="https://images2.imgbox.com/df/26/5syPcx85_o.png"></p> 
<blockquote> 
 <p><strong> 解决方案：</strong></p> 
 <p><strong>方案1</strong>：我们可以将实体类名改为Account，和数据库表保持一致。但是并不是最优解，因为我们在表的命名，一般有特殊要求，比如需要添加表名前缀tbl_等要求。则一般使用方案2。</p> 
 <p><strong>方案2</strong>：在实体类上添加注解:@TableName("account")，但是如果是以这样的方式，那么我们将要给每一个实体类都添加一个注解，这是繁琐的。所以，我们可以将这个东西写到全局配置中，也就是写到配置文件中。书写方式如下：</p> 
</blockquote> 
<blockquote> 
 <p> 说明：由于表名一般设置前缀，但是实体类名不会设置前缀才会导致实体类名和表名不一致问题。所以我们一般会到配置文件中设置表名前缀，解决问题。</p> 
</blockquote> 
<p><img alt="f0dcc22e739a42cb9e6b650ed1ad7410.png" src="https://images2.imgbox.com/b4/fc/kJW5UQa1_o.png"></p> 
<hr> 
<h3 id="id%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5">id生成策略</h3> 
<blockquote> 
 <p>前置条件：需要将实体类ID属性的类型改为Long。表中的字段类型改为bigint。</p> 
</blockquote> 
<p>id生成策略，说的就是我们insert操作时，对主键ID的设置，当我们没有设置ID的生成策略时，如果表中ID设置了自增，就会自动的生成自增ID，如果想要手动输入ID而不用自动生成，获取想要一个随机的ID，这样的设置，就是控制ID的生成策略。</p> 
<p><strong>设置方法：在配置文件中设置</strong></p> 
<p><strong>可以看到支持的id生成策略：</strong></p> 
<p><img alt="d8c7e6239e914ce1a2982aee6bffe623.png" src="https://images2.imgbox.com/6a/e9/0yJuO9RZ_o.png"></p> 
<p> 支持的ID生成策略说明：</p> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="71e911a809154ee384907930c68c9296.png" src="https://images2.imgbox.com/92/db/0jhoNE3S_o.png"></h3> 
<p><strong>雪花算法说明：</strong></p> 
<p>使用雪花算法生成的ID样子：" 一串很长的数字"</p> 
<p><img alt="36e5826112a04802a98eb7f3d3c8d74d.png" src="https://images2.imgbox.com/f8/7b/iaJEgcF8_o.png"></p> 
<blockquote> 
 <p> 雪花算法：根据时间戳，机器码和序列号生成一个64位的二进制转为十进制。</p> 
</blockquote> 
<p><img alt="62eba4456a6749c18b7bf73edf2592d7.png" src="https://images2.imgbox.com/77/af/nCThINaS_o.png"></p> 
<h3 id="%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><br> 多数据操作</h3> 
<p> 多数据操作说的就是：一次性多数据删除和多数据查询。</p> 
<p>操作：调用对应方法，参数传入集合。</p> 
<p><strong>演示：</strong></p> 
<pre><code class="language-java">//批量删除
@Test
void deletes(){
	List&lt;Long&gt; ids = new ArrayList&lt;&gt;();
	ids.add(8l);
	ids.add(9l);
	accountDAO.deleteBatchIds(ids);
}
//批量查询
@Test
void selects(){
	List&lt;Long&gt; ids = new ArrayList&lt;&gt;();
	ids.add(1l);
	ids.add(2l);
	accountDAO.selectBatchIds(ids);
}</code></pre> 
<p><strong>测试结果： </strong></p> 
<p><img alt="341251a64250434e86005e1b024b38c0.png" src="https://images2.imgbox.com/fc/0b/O0xuq11b_o.png"></p> 
<p><img alt="3b98e6a04e164741983dcf44a9918278.png" src="https://images2.imgbox.com/d2/8b/FeEclLnr_o.png"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7335087009368f02de965a0fa1d6486/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用 mapstruct 和 querydsl 时 compile 问题备忘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cfaf6f7449b9c5a420aab31ad4696740/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python 画图 解决字体无法显示的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>