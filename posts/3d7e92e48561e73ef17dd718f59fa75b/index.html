<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件流水在干嘛（转） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件流水在干嘛（转）" />
<meta property="og:description" content="以下所有内容基于个人理解，如有错误、纰漏请指出，谢谢。
1.基本思想：将有真相关的指令分隔到不同的循环周期内执行。
2.方法（以第6章第5题(2)为例）：
(1) 寻找指令依赖的关键路径（即答案中的“数据流图”）
这里暂时不需要考虑循环控制部分（指令6-9）。
(2) 在这条关键路径（1-&gt;2-&gt;4-&gt;5）上指令的数量，就是做软件流水时需要展开循环的次数（原因：保证有相关的指令能被分隔到不同循环执行）。下面先关注这条关键路径。
显然，在原来的代码中，指令执行是按上表中每一列从上到下的顺序执行的。而软件流水，实际上把它改成了每一行从左到右执行。
这种执行顺序的更改为什么是正确的？原因是(1)中确定的依赖关系。上面表格中每条指令只依赖于在它上方的指令：指令1写寄存器F2；指令2读F2，写F4；指令4读F4，写F6；指令5读F6。从左向右的执行，依然能保证：每次指令1执行后，碰到的第一条指令2一定是依赖于它的指令2；指令2往后碰到的第一条指令4一定是依赖于它的指令4；指令4往后碰到的第一条指令5一定是依赖于它的指令5。
可能导致错误的情况是：同一个寄存器被不同指令写了。可以通过事先进行重命名解决这个问题。
取循环i-3的指令5，循环i-2的指令4，循环i-1的指令2和循环i的指令1构成软件流水的循环体。
(3) 不在关键路径上的指令怎么办？将它和某个关键路径上的指令绑定在一起（所谓绑定，意思是它们在软流水中取自同一个循环）。原则是：指令和与自己有相关的指令之间不能有间隔。
在这个例子里，指令3和指令4之间有相关，它们之间不能有间隔。因此指令3要和指令2绑定在一起。这里说明一下，参考答案里的指令3和指令1绑定的图是不正确的。
不能有间隔的原因：假如3和1取自同一循环，指令4要使用3（蓝色圈）的结果，但是从左往右执行时，这个结果会被另一个3（红色圈）覆盖。而如果3和2取自同一循环就不会出错。
(4) 于是我们可以得到下面的表
其中高亮部分是软件流水的主体循环代码，上方是装入代码，下方是排空代码。
下面终于可以写代码了！激动！
(5) 四次循环展开，然后按照上面的规则取出我们需要的指令：
是不是豁然开朗！不是也没关系！仔细感受一下！
注意：指令3的目标寄存器已经被重命名成F8了，原因在(2)的末尾提过了。
(6) 我们基本上已经把循环写出来了，除了……循环。
这是用来控制循环的4条代码。显然6和7不变，它们的作用和for循环里的i&#43;&#43;一样。第8条指令Set Greater Than，当R1大于800的时候，R3 = 1；然后第9条指令根据R3的值确定是否跳转。
回顾一下(4)中的表格：主体循环结束后，代码中已经没有指令1了。也就是说，最后一次执行指令1，对应的是最后一次循环。
软件流水的正确性的关键在于保证软件流水后的代码和原来的代码逻辑相同。回顾原来的代码：最后一次执行指令1，对应的也是最后一次循环。
综合上面两段的意思，软件流水代码的最后一次循环中执行的L.D F2, 0(R1)，与原来代码中最后一次循环执行的L.D F2, 0(R1)应该取同一个内存地址的数。因此两个R1应该是相等的，第8条指令不需要改变。
最后一件事：延迟槽。指令9后有一个延迟槽，需要找一条指令来填充。第7条是最优的，因为它和8, 9没有相关关系。于是软件流水代码如下：
假如我们这里是把第6条填到了延迟槽里，那指令8中的800应该修改为792。为什么？留作思考题，感兴趣的又不是很明白的同学可以来问我。（我真是有毒）
(7) 到现在我们已经完成了这个题目的要求。现在可以尝试写一下装入和排空代码。
我先把上面的表格和代码搬运下来：
这里其实可以直接按照表格把代码写下来：
但是注意：整个程序第一次取到的应该是0(R1)和0(R2)的值，因此要对装入代码的偏移量进行修正。最简单粗暴的办法是：
当然，如果这个看起来太诡异了，也可以把它们放在后面：
这里装入和排空代码和答案上不完全一样，因为在没有相关时这些指令都可以进行调度，遇到具体的情况时具体做就可以了。
3.验证
验证自己的填写的偏移量是否正确：
给R1，R2设定一个初始值（建议刚好使原循环需要执行的次数与上述过程中展开次数相同，如R1=R2=768刚好能使循环执行4次），计算load/store指令的内存地址，比较原循环和软件流水中的内存地址是否相同。
参考资料：
[1] 胡伟武等. 计算机体系结构[M]. 2017.
[2] 习题课_第6章[S]. 2018.
[3] 第6章到第9章参考答案[H]. 2018.
[4] 循环的软流水原理和实例展示[EB/OL]. csdn链接
致谢 全文出自：hc大佬 hithub
邮箱：huangcheng14@mails.ucas.edu.cn" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3d7e92e48561e73ef17dd718f59fa75b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-12T14:40:10+08:00" />
<meta property="article:modified_time" content="2019-01-12T14:40:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件流水在干嘛（转）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>以下所有内容基于个人理解，如有错误、纰漏请指出，谢谢。<br> <strong>1.基本思想</strong>：将有真相关的指令分隔到不同的循环周期内执行。</p> 
<p><strong>2.方法</strong>（以第6章第5题(2)为例）：<br> (1) 寻找指令依赖的关键路径（即答案中的“数据流图”）<br> <img src="https://images2.imgbox.com/59/1a/NTff2pq4_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/03/80/stS8mc7O_o.png" alt="在这里插入图片描述"><br> 这里暂时不需要考虑循环控制部分（指令6-9）。</p> 
<p><strong>(2)</strong> 在这条关键路径（1-&gt;2-&gt;4-&gt;5）上指令的数量，就是做软件流水时需要展开循环的次数（原因：保证有相关的指令能被分隔到不同循环执行）。下面先关注这条关键路径。<br> <img src="https://images2.imgbox.com/c3/44/NTpOTmko_o.png" alt="在这里插入图片描述"><br> 显然，在原来的代码中，指令执行是按上表中每一列从上到下的顺序执行的。而软件流水，实际上把它改成了每一行从左到右执行。</p> 
<p>这种执行顺序的更改为什么是正确的？原因是(1)中确定的依赖关系。上面表格中每条指令只依赖于在它上方的指令：指令1写寄存器F2；指令2读F2，写F4；指令4读F4，写F6；指令5读F6。从左向右的执行，依然能保证：每次指令1执行后，碰到的第一条指令2一定是依赖于它的指令2；指令2往后碰到的第一条指令4一定是依赖于它的指令4；指令4往后碰到的第一条指令5一定是依赖于它的指令5。</p> 
<p>可能导致错误的情况是：同一个寄存器被不同指令写了。可以通过事先进行重命名解决这个问题。</p> 
<p>取循环i-3的指令5，循环i-2的指令4，循环i-1的指令2和循环i的指令1构成软件流水的循环体。<br> <strong>(3)</strong> 不在关键路径上的指令怎么办？将它和某个关键路径上的指令绑定在一起（所谓绑定，意思是它们在软流水中取自同一个循环）。原则是：指令和与自己有相关的指令之间不能有间隔。<br> <img src="https://images2.imgbox.com/31/8b/6XTCxINV_o.png" alt="在这里插入图片描述"><br> 在这个例子里，指令3和指令4之间有相关，它们之间不能有间隔。因此指令3要和指令2绑定在一起。这里说明一下，参考答案里的指令3和指令1绑定的图是不正确的。<br> 不能有间隔的原因：假如3和1取自同一循环，指令4要使用3（蓝色圈）的结果，但是从左往右执行时，这个结果会被另一个3（红色圈）覆盖。而如果3和2取自同一循环就不会出错。<br> <img src="https://images2.imgbox.com/68/9c/D8AMqmxO_o.png" alt="在这里插入图片描述"><br> <strong>(4)</strong> 于是我们可以得到下面的表<br> <img src="https://images2.imgbox.com/75/7c/6KuHhXks_o.png" alt="在这里插入图片描述"><br> 其中高亮部分是软件流水的主体循环代码，上方是装入代码，下方是排空代码。<br> 下面终于可以写代码了！激动！</p> 
<p><strong>(5)</strong> 四次循环展开，然后按照上面的规则取出我们需要的指令：<br> <img src="https://images2.imgbox.com/23/5f/ethDzchO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/bf/2d/LtlecNCo_o.png" alt="在这里插入图片描述">是不是豁然开朗！不是也没关系！仔细感受一下！<br> 注意：指令3的目标寄存器已经被重命名成F8了，原因在(2)的末尾提过了。</p> 
<p>(6) 我们基本上已经把循环写出来了，除了……循环。<br> <img src="https://images2.imgbox.com/44/fe/fWARTbLH_o.png" alt="在这里插入图片描述"><br> 这是用来控制循环的4条代码。显然6和7不变，它们的作用和for循环里的i++一样。第8条指令Set Greater Than，当R1大于800的时候，R3 = 1；然后第9条指令根据R3的值确定是否跳转。</p> 
<p>回顾一下(4)中的表格：主体循环结束后，代码中已经没有指令1了。也就是说，最后一次执行指令1，对应的是最后一次循环。</p> 
<p>软件流水的正确性的关键在于保证软件流水后的代码和原来的代码逻辑相同。回顾原来的代码：最后一次执行指令1，对应的也是最后一次循环。</p> 
<p>综合上面两段的意思，软件流水代码的最后一次循环中执行的L.D F2, 0(R1)，与原来代码中最后一次循环执行的L.D F2, 0(R1)应该取同一个内存地址的数。因此两个R1应该是相等的，第8条指令不需要改变。</p> 
<p>最后一件事：延迟槽。指令9后有一个延迟槽，需要找一条指令来填充。第7条是最优的，因为它和8, 9没有相关关系。于是软件流水代码如下：<br> <img src="https://images2.imgbox.com/eb/d7/04EaOEJL_o.png" alt="在这里插入图片描述"><br> <strong>假如</strong>我们这里是把第6条填到了延迟槽里，那指令8中的800应该修改为792。为什么？留作思考题，感兴趣的又不是很明白的同学可以来问我。（我真是有毒）</p> 
<p><strong>(7)</strong> 到现在我们已经完成了这个题目的要求。现在可以尝试写一下装入和排空代码。<br> 我先把上面的表格和代码搬运下来：<br> <img src="https://images2.imgbox.com/02/86/WBvx6SUp_o.png" alt="在这里插入图片描述"><br> 这里其实可以直接按照表格把代码写下来：<br> <img src="https://images2.imgbox.com/1a/09/3molDheN_o.png" alt="在这里插入图片描述"><br> 但是注意：整个程序第一次取到的应该是0(R1)和0(R2)的值，因此要对装入代码的偏移量进行修正。最简单粗暴的办法是：<br> <img src="https://images2.imgbox.com/78/cd/g7V1TJQm_o.png" alt="在这里插入图片描述"><br> 当然，如果这个看起来太诡异了，也可以把它们放在后面：<br> <img src="https://images2.imgbox.com/de/73/VmoFAzdB_o.png" alt="在这里插入图片描述"><br> 这里装入和排空代码和答案上不完全一样，因为在没有相关时这些指令都可以进行调度，遇到具体的情况时具体做就可以了。</p> 
<p><strong>3.验证</strong><br> 验证自己的填写的偏移量是否正确：<br> 给R1，R2设定一个初始值（建议刚好使原循环需要执行的次数与上述过程中展开次数相同，如R1=R2=768刚好能使循环执行4次），计算load/store指令的内存地址，比较原循环和软件流水中的内存地址是否相同。</p> 
<p>参考资料：<br> [1] 胡伟武等. 计算机体系结构[M]. 2017.<br> [2] 习题课_第6章[S]. 2018.<br> [3] 第6章到第9章参考答案[H]. 2018.<br> [4] 循环的软流水原理和实例展示[EB/OL]. <a href="https://blog.csdn.net/shenqiongniujiahui/article/details/50528958"> csdn链接</a></p> 
<h3><a id="_69"></a>致谢</h3> 
<p>全文出自：hc大佬 <a href="https://github.com/ChenghuangUCAS">hithub</a><br> 邮箱：huangcheng14@mails.ucas.edu.cn</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed7581f7e23f7daaf4d31ce9d30181c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS 查看Object 对象信息</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9fd45f159019f992ebf4292bd4aff2e8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网上商城的功能模块架构设计之（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>