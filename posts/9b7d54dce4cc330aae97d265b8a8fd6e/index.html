<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>完全二叉树、平衡二叉树、二叉查找树（二叉排序树） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="完全二叉树、平衡二叉树、二叉查找树（二叉排序树）" />
<meta property="og:description" content="完全二叉树 完全二叉树是一种特殊的二叉树，满足以下要求：
所有叶子节点都出现在 k 或者 k-1 层，而且从 1 到 k-1 层必须达到最大节点数；第 k 层可以不是满的，但是第 k 层的所有节点必须集中在最左边。需要注意的是不要把完全二叉树和“满二叉树”搞混了，完全二叉树不要求所有树都有左右子树，但它要求： 任何一个节点不能只有左子树没有右子树叶子节点出现在最后一层或者倒数第二层，不能再往上 用一张图对比下“完全二叉树”和“满二叉树”：
当我们用数组实现一个完全二叉树时，叶子节点可以按从上到下、从左到右的顺序依次添加到数组中，然后知道一个节点的位置，就可以轻松地算出它的父节点、孩子节点的位置。
以上面图中完全二叉树为例，标号为 2 的节点，它在数组中的位置也是 2，它的父节点就是 (k/2 = 1)，它的孩子节点分别是 (2k=4) 和 (2k&#43;1=5)，别的节点也是类似。
完全二叉树使用场景 根据前面的学习，我们了解到完全二叉树的特点是：“叶子节点的位置比较规律”。因此在对数据进行排序或者查找时可以用到它，比如堆排序就使用了它，后面学到了再详细介绍。
二叉查找树（二叉排序树） 二叉树的提出其实主要就是为了提高查找效率，比如我们常用的 HashMap 在处理哈希冲突严重时，拉链过长导致查找效率降低，就引入了红黑树。
我们知道，二分查找可以缩短查找的时间，但是它要求 查找的数据必须是有序的。每次查找、操作时都要维护一个有序的数据集，于是有了二叉查找树这个概念。
二叉查找树（又叫二叉排序树），它是具有下列性质的二叉树：
若左子树不空，则左子树上所有结点的值均小于它的根结点的值；若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；左、右子树也分别为二叉排序树。 如下图所示：
也就是说，二叉查找树中，左子树都比节点小，右子树都比节点大，递归定义。
根据二叉排序树这个特点我们可以知道：二叉排序树的中序遍历一定是从小到大的。
比如上图，中序遍历结果是：
1 3 4 6 7 8 10 13 14 二叉排序树的性能 在最好的情况下，二叉排序树的查找效率比较高，是 O(logn)，其访问性能近似于折半查找；
但最差时候会是 O(n)，比如插入的元素是有序的，生成的二叉排序树就是一个链表，这种情况下，需要遍历全部元素才行（见下图 b）。
如果我们可以保证二叉排序树不出现上面提到的极端情况（插入的元素是有序的，导致变成一个链表），就可以保证很高的效率了。
但这在插入有序的元素时不太好控制，按二叉排序树的定义，我们无法判断当前的树是否需要调整。
因此就要用到平衡二叉树（AVL 树）了。
平衡二叉树 平衡二叉树的提出就是为了保证树不至于太倾斜，尽量保证两边平衡。因此它的定义如下：
平衡二叉树要么是一棵空树要么保证左右子树的高度之差不大于 1子树也必须是一颗平衡二叉树 也就是说，树的两个左子树的高度差别不会太大。
那我们接着看前面的极端情况的二叉排序树，现在用它来构造一棵平衡二叉树。
以 12 为根节点，当添加 24 为它的右子树后，根节点的左右子树高度差为 1，这时还算平衡，这时再添加一个元素 28：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/9b7d54dce4cc330aae97d265b8a8fd6e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-03T23:34:23+08:00" />
<meta property="article:modified_time" content="2020-08-03T23:34:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">完全二叉树、平衡二叉树、二叉查找树（二叉排序树）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>完全二叉树</h2> 
<p>完全二叉树是一种特殊的二叉树，满足以下要求：</p> 
<ul><li>所有叶子节点都出现在 k 或者 k-1 层，而且从 1 到 k-1 层必须达到最大节点数；</li><li>第 k 层可以不是满的，但是第 k 层的所有节点必须集中在最左边。需要注意的是不要把完全二叉树和“满二叉树”搞混了，完全二叉树不要求所有树都有左右子树，但它要求： 
  <ul><li>任何一个节点不能只有左子树没有右子树</li><li>叶子节点出现在最后一层或者倒数第二层，不能再往上</li></ul> </li></ul> 
<p>用一张图对比下“完全二叉树”和“满二叉树”：<br> <img src="https://images2.imgbox.com/c2/57/IWrGcz9g_o.png" alt="在这里插入图片描述"><br> 当我们用数组实现一个完全二叉树时，叶子节点可以按从上到下、从左到右的顺序依次添加到数组中，然后知道一个节点的位置，就可以轻松地算出它的<strong>父节点、孩子节点</strong>的位置。</p> 
<p>以上面图中完全二叉树为例，标号为 2 的节点，它在数组中的位置也是 2，它的父节点就是 (k/2 = 1)，它的孩子节点分别是 (2k=4) 和 (2k+1=5)，别的节点也是类似。</p> 
<h3><a id="_14"></a>完全二叉树使用场景</h3> 
<p>根据前面的学习，我们了解到完全二叉树的特点是：“叶子节点的位置比较规律”。因此在对数据进行<strong>排序或者查找</strong>时可以用到它，比如<strong>堆排序</strong>就使用了它，后面学到了再详细介绍。</p> 
<h2><a id="_17"></a>二叉查找树（二叉排序树）</h2> 
<p>二叉树的提出其实主要就是为了提高查找效率，比如我们常用的 HashMap 在处理哈希冲突严重时，拉链过长导致查找效率降低，就引入了红黑树。</p> 
<p>我们知道，二分查找可以缩短查找的时间，但是它要求 查找的数据必须是有序的。每次查找、操作时都要维护一个有序的数据集，于是有了二叉查找树这个概念。</p> 
<p>二叉查找树（又叫二叉排序树），它是具有下列性质的二叉树：</p> 
<ol><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li><li>左、右子树也分别为二叉排序树。</li></ol> 
<p>如下图所示：<br> <img src="https://images2.imgbox.com/e6/c0/lZWHVvjK_o.png" alt="在这里插入图片描述"><br> 也就是说，二叉查找树中，左子树都比节点小，右子树都比节点大，递归定义。</p> 
<p>根据二叉排序树这个特点我们可以知道：二叉排序树的中序遍历一定是从小到大的。</p> 
<p>比如上图，中序遍历结果是：</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">10</span> <span class="token number">13</span> <span class="token number">14</span>
</code></pre> 
<h3><a id="_39"></a>二叉排序树的性能</h3> 
<p>在最好的情况下，二叉排序树的查找效率比较高，是 O(logn)，其访问性能近似于折半查找；</p> 
<p>但最差时候会是 O(n)，比如插入的元素是有序的，生成的二叉排序树就是一个链表，这种情况下，需要遍历全部元素才行（见下图 b）。<br> <img src="https://images2.imgbox.com/6a/11/NcGRt38s_o.png" alt="在这里插入图片描述"><br> 如果我们可以保证二叉排序树不出现上面提到的极端情况（插入的元素是有序的，导致变成一个链表），就可以保证很高的效率了。</p> 
<p>但这在插入有序的元素时不太好控制，按二叉排序树的定义，我们无法判断当前的树是否需要调整。</p> 
<p>因此就要用到平衡二叉树（AVL 树）了。</p> 
<h2><a id="_50"></a>平衡二叉树</h2> 
<p>平衡二叉树的提出就是为了保证树不至于太倾斜，尽量保证两边平衡。因此它的定义如下：</p> 
<ol><li>平衡二叉树要么是一棵空树</li><li>要么保证左右子树的高度之差不大于 1</li><li>子树也必须是一颗平衡二叉树</li></ol> 
<p>也就是说，树的两个左子树的高度差别不会太大。</p> 
<p>那我们接着看前面的极端情况的二叉排序树，现在用它来构造一棵平衡二叉树。</p> 
<p>以 12 为根节点，当添加 24 为它的右子树后，根节点的左右子树高度差为 1，这时还算平衡，这时再添加一个元素 28：<br> <img src="https://images2.imgbox.com/89/50/RxdHcqQ2_o.png" alt="在这里插入图片描述"><br> 这时根节点 12 觉得不平衡了，我左孩子一个都没有，右边都有俩了，超过了之前说的最大为 1，不行，给我调整！</p> 
<p>于是我们就需要调整当前的树结构，让它进行旋转。</p> 
<p>因为最后一个节点加到了右子树的右子树，就要想办法给右子树的左子树加点料，因此需要逆时针旋转，将 24 变成根节点，12 右旋成 24 的左子树，就变成了这样：<br> <img src="https://images2.imgbox.com/11/a8/208ifOaP_o.png" alt="在这里插入图片描述"><br> 这时又恢复了平衡，再添加 37 到 28 的右子树，还算平衡：<br> <img src="https://images2.imgbox.com/6b/98/iYPRj97h_o.png" alt="在这里插入图片描述"><br> 这时如果再添加一个 30，它就需要在 37 的左子树：<br> <img src="https://images2.imgbox.com/8b/ac/maCu9M5d_o.png" alt="在这里插入图片描述"><br> 这时我们可以看到这个树又不平衡了，以 24 为根节点的树，明显右边太重，左边太稀，想要保持平衡就 24 得让位给 28，然后变成这样：<br> <img src="https://images2.imgbox.com/6e/63/ELmVkQVd_o.png" alt="在这里插入图片描述"><br> 依次类推，平衡二叉树在添加和删除时需要进行旋转保持整个树的平衡，内部做了这么复杂的工作后，我们在使用它时，插入、查找的时间复杂度都是 O(logn)，性能已经相当好了。</p> 
<h2><a id="_77"></a>总结</h2> 
<p><img src="https://images2.imgbox.com/85/9f/BH5g86zP_o.png" alt="在这里插入图片描述"></p> 
<p>原文链接：<a href="https://juejin.im/entry/6844903606408183815" rel="nofollow">https://juejin.im/entry/6844903606408183815</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/626cee5928e19d7948f075f2968176ce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【计算机网络】孤儿进程和僵尸进程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f843b10d586a66e6550a71532b2e57f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">13.5-“制作一款私有IAP串口下载小工具”之STM32的Bootloader代码编写（包含源码）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>