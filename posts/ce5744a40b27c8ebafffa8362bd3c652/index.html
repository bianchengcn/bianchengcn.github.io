<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Breakpad在Windows，Linux双平台编译、集成以及dump文件的分析 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Breakpad在Windows，Linux双平台编译、集成以及dump文件的分析" />
<meta property="og:description" content="Breakpad在Windows，Linux双平台编译、集成以及dump文件的分析
1、Windows平台
Windows平台上非常好的参考文档：
https://r12f.com/posts/google-breakpad-1-introduction-with-windows/
https://r12f.com/posts/google-breakpad-2-implementations-on-windows/
1.1、源码下载及编译
平台：Win10 &#43; Intel
IDE：Visual Studio 2017
1.1.1、源码下载
github上的main分支一致编译不通过也没有gyp用于生成VS的sln。
当前我们使用github上breakpad的master分支即可
1.1.2、源码编译依赖
源码编译需要GYP生成VS打开的sln文件，GYP又依赖于python2.7.x版本
依赖关系：python2.7.x -&gt; GYP -&gt; Visual Studio；可顺序安装
详细请见：https://blog.csdn.net/zyhse/article/details/112577340博客
1.1.3、编译
breakpad只需要生成client中的项目，目录：breakpad-master\src\client\windows
该目录下可以看到breakpad_client.gyp文件(2023年后github main分支上已经没有该文件了)
使用安装好的GYP生成SLN（若gyp执行失败，大概率是python版本不对）
gyp --no-circular-check &#34;./breakpad_client.gyp&#34; -Dwin_release_RuntimeLibrary=2 -Dwin_debug_RuntimeLibrary=3 使用vs2017打开调整为Release|x64编译
生成如上静态库
1.2、集成到现有代码中
breakpad集成到现有VS c&#43;&#43;代码中非常的容易
1.2.1、包含头文件以及lib库
头文件：项目属性 -&gt; C/C&#43;&#43; -&gt; 附加包含目录 添加文件文件路径
lib库： 项目属性 -&gt; 链接器 -&gt; 常规 -&gt; 附加库目录 添加库目录
​ 项目属性 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项 添加 common.lib crash_generation_client.lib crash_generation_server.lib exception_handler.lib 或使用代码方式添加" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ce5744a40b27c8ebafffa8362bd3c652/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-03T17:55:22+08:00" />
<meta property="article:modified_time" content="2023-11-03T17:55:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Breakpad在Windows，Linux双平台编译、集成以及dump文件的分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Breakpad在Windows，Linux双平台编译、集成以及dump文件的分析</p> 
<p><strong>1、Windows平台</strong></p> 
<p>Windows平台上非常好的参考文档：</p> 
<p>https://r12f.com/posts/google-breakpad-1-introduction-with-windows/</p> 
<p>https://r12f.com/posts/google-breakpad-2-implementations-on-windows/</p> 
<p><strong>1.1、源码下载及编译</strong></p> 
<p>平台：Win10 + Intel</p> 
<p>IDE：Visual Studio 2017</p> 
<p><strong>1.1.1、源码下载</strong></p> 
<p>github上的main分支一致编译不通过也没有gyp用于生成VS的sln。</p> 
<p>当前我们使用github上breakpad的master分支即可</p> 
<p><strong>1.1.2、源码编译依赖</strong></p> 
<p>源码编译需要GYP生成VS打开的sln文件，GYP又依赖于python2.7.x版本</p> 
<p>依赖关系：python2.7.x -&gt; GYP -&gt; Visual Studio；可顺序安装</p> 
<p>详细请见：https://blog.csdn.net/zyhse/article/details/112577340博客</p> 
<p><strong>1.1.3、编译</strong></p> 
<p>breakpad只需要生成client中的项目，目录：breakpad-master\src\client\windows</p> 
<p>该目录下可以看到breakpad_client.gyp文件(2023年后github main分支上已经没有该文件了)</p> 
<p>使用安装好的GYP生成SLN（<em>若gyp执行失败，大概率是python版本不对</em>）</p> 
<pre><code class="prism language-powershell">gyp <span class="token operator">--</span>no-circular-check <span class="token string">"./breakpad_client.gyp"</span> <span class="token operator">-</span>Dwin_release_RuntimeLibrary=2 <span class="token operator">-</span>Dwin_debug_RuntimeLibrary=3
</code></pre> 
<p>使用vs2017打开调整为Release|x64编译</p> 
<p><img src="https://images2.imgbox.com/66/02/IfHnXRtp_o.png" alt="请添加图片描述"></p> 
<p>生成如上静态库</p> 
<p><strong>1.2、集成到现有代码中</strong></p> 
<p>breakpad集成到现有VS c++代码中非常的容易</p> 
<p><strong>1.2.1、包含头文件以及lib库</strong></p> 
<p>头文件：项目属性 -&gt; C/C++ -&gt; 附加包含目录 添加文件文件路径</p> 
<p>lib库： 项目属性 -&gt; 链接器 -&gt; 常规 -&gt; 附加库目录 添加库目录</p> 
<p>​ 项目属性 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项 添加 common.lib crash_generation_client.lib crash_generation_server.lib exception_handler.lib 或使用代码方式添加</p> 
<pre><code class="prism language-c++">#pragma comment(lib, "common.lib")
#pragma comment(lib, "crash_generation_client.lib")
#pragma comment(lib, "crash_generation_server.lib")
#pragma comment(lib, "exception_handler.lib")
</code></pre> 
<p><strong>1.2.2、使用breakpad C/S模式增加下面代码段至项目中就好</strong></p> 
<pre><code class="prism language-c++">// 头文件
#include "client/windows/handler/exception_handler.h"
#include "client/windows/crash_generation/crash_generation_server.h"
#include "client/windows/crash_generation/client_info.h"

// lib库
#pragma comment(lib, "common.lib")
#pragma comment(lib, "crash_generation_client.lib")
#pragma comment(lib, "crash_generation_server.lib")
#pragma comment(lib, "exception_handler.lib")

// server回调函数
void onClientConnected(void* context,
	const google_breakpad::ClientInfo* client_info) 
{
}

void onClientDumpRequest(void* context,
	const google_breakpad::ClientInfo* client_info,
	const std::wstring* file_path)
{
}

void onClientExited(void* context,
	const google_breakpad::ClientInfo* client_info) {
}

// client端回调函数，写完minidump后的回调函数
bool onMinidumpDumped(const wchar_t* dump_path, const wchar_t* id,
	void* context, EXCEPTION_POINTERS* exinfo,
	MDRawAssertionInfo* assertion,
	bool succeeded) {
	return succeeded;
}

bool InitBreakpad()
{
	if (_wmkdir(s_strCrashDir.c_str()) &amp;&amp; (errno != EEXIST)) {
		return false;
	}

	google_breakpad::CrashGenerationServer *pCrashServer =
		new google_breakpad::CrashGenerationServer(s_pPipeName,
			NULL,
			onClientConnected,
			NULL,
			onClientDumpRequest,
			NULL,
			onClientExited,
			NULL,
			NULL,
			NULL,
			true,
			&amp;s_strCrashDir);

	if (pCrashServer == NULL) {
		return false;
	}

	// 如果已经服务端已经启动了，此处启动会失败
	if (!pCrashServer-&gt;Start()) {
		delete pCrashServer;
		pCrashServer = NULL;
	}

	google_breakpad::ExceptionHandler *pCrashHandler =
		new google_breakpad::ExceptionHandler(s_strCrashDir,
			nullptr,
			onMinidumpDumped,
			NULL,
			google_breakpad::ExceptionHandler::HANDLER_ALL,
			MiniDumpNormal,
			(pCrashServer == NULL) ? s_pPipeName : NULL, // 如果是服务端，则直接使用进程内dump
			NULL);

	if (pCrashHandler == NULL) {
		return false;
	}
	return true;
}

int main(...)
{
    // ....
    bool ret = InitBreakpad();
    // ... 项目当前的代码 ...
}
</code></pre> 
<p><strong>1.3、dump文件分析</strong></p> 
<p>Windows上dump文件分析非常的简单，要么Visual Studio，要么Windbg。</p> 
<p>下面我们使用windbg进行分析dump文件；</p> 
<p>注意：项目生成exe文件必须要有pdb文件，该文件主要存储symbols的，如果没有请修改项目属性；<br> <img src="https://images2.imgbox.com/da/35/M0wynkBV_o.png" alt="请添加图片描述"><br> <img src="https://images2.imgbox.com/df/64/uOcX3i37_o.png" alt="请添加图片描述"></p> 
<p>打开这两个属性就可以生成pdb文件了。</p> 
<p>使用windbg打开dmp文件，配置好Symbol file path路径（就是该dump的exe对应的pdb文件路径）以及Source file path路径（该dump的exe的源码路径）<br> <img src="https://images2.imgbox.com/47/b0/b5ECXaIq_o.png" alt="请添加图片描述"></p> 
<p>点击!analyze -v就行<br> <img src="https://images2.imgbox.com/14/c3/sc1GobNw_o.png" alt="请添加图片描述"></p> 
<p>非常容易的看到保存的代码行<br> <img src="https://images2.imgbox.com/38/64/9RS7wLKH_o.png" alt="请添加图片描述"></p> 
<p><strong>2、Linux平台</strong></p> 
<p>linux平台与windows平台有些许不同。</p> 
<p>首先是依赖项；</p> 
<p>其次是分析dump文件的工具（breakpad自带的）；</p> 
<p><strong>2.1、依赖项</strong></p> 
<p>需要去google上下载lss依赖包放在/breakpad-master/src/third_party/lss目录下，里面主要就是linux_syscall_support.h文件在代码中依赖了</p> 
<p><strong>2.2、分析工具</strong></p> 
<p>在linux上编译的breakpad会生成自带的分析工具<em><strong>minidump_stackwalk</strong></em>以及symbol生成工具<em><strong>dump_syms</strong></em></p> 
<ol><li>minidump_stackwalk：./breakpad-master/src/processor目录下</li><li>dump_syms: ./breakpad-master/src/tools/linux/dump_syms目录下</li></ol> 
<p><strong>2.3、具体使用</strong></p> 
<pre><code class="prism language-c++">#include &lt;unistd.h&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;
#include "client/linux/handler/exception_handler.h"

static bool dumpCallback(const google_breakpad::MinidumpDescriptor&amp; descriptor,
void* context, bool succeeded) {
  printf("Dump path: %s\n", descriptor.path());
  return succeeded;
}

void crash() { volatile int* a = (int*)(NULL); *a = 1; }

void task1(string msg)
{
    std::cout &lt;&lt; "task1 says: " &lt;&lt; msg &lt;&lt; std::endl;
    crash();
}

int main(int argc, char* argv[]) {
  google_breakpad::MinidumpDescriptor descriptor("/tmp/hzh");
  google_breakpad::ExceptionHandler eh(descriptor, NULL, dumpCallback, NULL, true, -1);
  std::thread t1(task1, "Hello");
  t1.detach();
  sleep(2);
  return 0;
}
</code></pre> 
<pre><code class="prism language-shell">$ g++ <span class="token parameter variable">-g</span> a.cpp -I/home/hzh/soft/softy/breakpad/include/breakpad -L/home/hzh/soft/softy/breakpad/lib <span class="token parameter variable">-lbreakpad</span> <span class="token parameter variable">-lbreakpad_client</span> <span class="token parameter variable">-pthread</span> <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span>
</code></pre> 
<p>1，运行test，会崩溃并产生 179cac63-2e41-4de0-09e8b58c-56069f80.dmp 文件。</p> 
<p>2，从可执行程序生成符号表：</p> 
<pre><code class="prism language-shell">$ /home/xxx/soft/softy/breakpad/bin/dump_syms <span class="token builtin class-name">test</span> <span class="token operator">&gt;&gt;</span> test.sym
</code></pre> 
<p>3，建立一个目录结构，目录名必须为“可执行程序的名字”，然后再该目录里面建立一个目录，名字为 test.sym 的第一行的某个数据，具体如下：</p> 
<pre><code class="prism language-shell">$ <span class="token function">head</span> <span class="token parameter variable">-n1</span> test.sym
</code></pre> 
<p>得到: MODULE Linux x86_64 A35260606902350047A2A3559926FE410 test ，我们就要 A35260606902350047A2A3559926FE410 作为目录名。</p> 
<pre><code class="prism language-shell">$  <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> ./symbols/test/A35260606902350047A2A3559926FE410
</code></pre> 
<p>4，将 test.sym 移动到目录里：</p> 
<pre><code class="prism language-shell">$  <span class="token function">mv</span> test.sym symbols/test/A35260606902350047A2A3559926FE410/
</code></pre> 
<p>5，开始分析：</p> 
<pre><code class="prism language-shell">$  /home/xxx/soft/softy/breakpad/bin/minidump_stackwalk 179cac63-2e41-4de0-09e8b58c-56069f80.dmp ./symbols
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/67c2e2f3cdcdc3625c4f365c14b9724f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【PyQt学习篇 · ⑩】：QAbstractButton的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7f604f58627117ac9b1fd66278fde4d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">云服务器中jdk的安装与tomact的部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>