<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vite理解与配置 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vite理解与配置" />
<meta property="og:description" content="初识vite 前言：最近项目要从vue2.x迁移到vue3，于是借此机会打算重构整个项目。在搭建项目的时候发现vue3更新了构建方式，放弃了webpack，使用了新的构建机制vite。再经过一番了解后发现vite借助了esbuild与rollup。
vite开发大致分两个阶段
开发阶段：
vite采用no-bundle的方式,借助现代浏览器支持了esmodule的能力，在开发阶段项目无需打包即可运行调试，这让开发编译速度得到很大提升。生产阶段：
为了在生产环境中获得最佳的加载性能，不能完全 no-bundle，且由于rollup 对于代码的 tree-shaking 和 ES6 模块有着算法优势上的支持，项目只需要打包出一个简单的bundle包，于是vite打包借助了rollup来用来实现代码分割、tree-shaking等操作，并且vite的插件机制是借鉴rollup来实现的。 esbuild的作用 依赖预构建，esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。加速文件编译,如webpack等以往的编译工具需要借助babel,tsc等工具编译代码，速度相对较慢，在利用esbuild后避免了terser、babel重复解析的问题，可以大大加快快速编译速度代码压缩,vite统一采用esbuild,共用ast树只进行一次解析，解决了terser 和 babel 单独使用了ast造成的重复编译问题。 rollup的作用： 现代浏览器基本支持了esmodule，考虑到要在生产环境获得最佳的加载性能，vite在生产环境使用rollup来进行打包构建，由于vite的插件机制是借鉴rollup来实现的，使得rollup大部分插件可以直接在vite中使用，可以说是双向奔赴了
vite基本配置 当以命令行方式运行 vite 时，vite 会自动解析项目根目录下名为 vite.config.js 的文件。以下是基础的配置文件：
1. IDE智能提示 通过 IDE 和 jsdoc 的配合来实现智能提示
// vite.config.js /** @type {import(&#39;vite&#39;).UserConfig} */ export default { // 一些自定义基础配置 } 使用工具函数 defineConfig
import { defineConfig } from &#39;vite&#39;; export default defineConfig({ // 一些自定义基础配置 }) 2. 开发/生产环境情景配置 使用defineConfig工具函数并以箭头函数作为callback函数接收command, mode, ssrBuild来获取一些基本参数，用于区分环境亦或者是一个 SSR 构建（ssrBuild）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/0867bd866c4719359913a7a9aa485669/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-08T17:10:45+08:00" />
<meta property="article:modified_time" content="2023-02-08T17:10:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vite理解与配置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="vite_1"></a>初识vite</h2> 
<ul><li> <p>前言：最近项目要从vue2.x迁移到vue3，于是借此机会打算重构整个项目。在搭建项目的时候发现vue3更新了构建方式，放弃了webpack，使用了新的构建机制vite。再经过一番了解后发现vite借助了esbuild与rollup。</p> </li><li> <p>vite开发大致分两个阶段</p> 
  <ol><li>开发阶段：<br> vite采用no-bundle的方式,借助现代浏览器支持了esmodule的能力，在开发阶段项目无需打包即可运行调试，这让开发编译速度得到很大提升。</li><li>生产阶段：<br> 为了在生产环境中获得最佳的加载性能，不能完全 no-bundle，且由于rollup 对于代码的 tree-shaking 和 ES6 模块有着算法优势上的支持，项目只需要打包出一个简单的bundle包，于是vite打包借助了rollup来用来实现代码分割、tree-shaking等操作，并且vite的插件机制是借鉴rollup来实现的。</li></ol> </li><li> <h6><a id="esbuild_9"></a>esbuild的作用</h6> 
  <ol><li>依赖预构建，esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。</li><li>加速文件编译,如webpack等以往的编译工具需要借助babel,tsc等工具编译代码，速度相对较慢，在利用esbuild后避免了terser、babel重复解析的问题，可以大大加快快速编译速度</li><li>代码压缩,vite统一采用esbuild,共用ast树只进行一次解析，解决了terser 和 babel 单独使用了ast造成的重复编译问题。</li></ol> </li><li> <h6><a id="rollup_13"></a>rollup的作用：</h6> <p>现代浏览器基本支持了esmodule，考虑到要在生产环境获得最佳的加载性能，vite在生产环境使用rollup来进行打包构建，由于vite的插件机制是借鉴rollup来实现的，使得rollup大部分插件可以直接在vite中使用，可以说是双向奔赴了</p> </li></ul> 
<h2><a id="vite_16"></a>vite基本配置</h2> 
<p>当以命令行方式运行 vite 时，vite 会自动解析项目根目录下名为 vite.config.js 的文件。以下是基础的配置文件：</p> 
<h6><a id="1_IDE_19"></a>1. IDE智能提示</h6> 
<p>通过 IDE 和 jsdoc 的配合来实现智能提示</p> 
<pre><code>// vite.config.js
/** @type {import('vite').UserConfig} */  
export default {  
    // 一些自定义基础配置  
}  
</code></pre> 
<p>使用工具函数 defineConfig</p> 
<pre><code>import { defineConfig } from 'vite';  
export default defineConfig({
    // 一些自定义基础配置
})
</code></pre> 
<h6><a id="2__37"></a>2. 开发/生产环境情景配置</h6> 
<p>使用defineConfig工具函数并以箭头函数作为callback函数接收command, mode, ssrBuild来获取一些基本参数，用于区分环境亦或者是一个 SSR 构建（ssrBuild）</p> 
<pre><code>// vite.config.js 

export default defineConfig(({ command, mode, ssrBuild }) =&gt; {
  if (command === 'serve') {
    return {
      // dev 独有配置
    }
  } else {
    // command === 'build'
    return {
      // build 独有配置
    }
  }
})
</code></pre> 
<h6><a id="3__55"></a>3. 引入路径配置</h6> 
<p>路径配置可以自定义配置或者借助插件</p> 
<ol><li> <p>自定义配置</p> <pre><code>// vite.config.js

import { defineConfig } from 'vite';
import path from 'path';
export default defineConfig({
    resolve: {
        alias: {
        '@': path.resolve(__dirname, './src') // 路径别名
        }
    }
})
</code></pre> <p>假如你的项目使用 typescript 进行开发,则需要在 tsconfig.json 文件中配置paths，否则IDE引入路径飘红</p> <pre><code>// tsconfig.json
{
    "paths": {
        "@src/*": ["./src/*"],
        },
    "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.vue"] // 编译对以下文件进行ts检测
    "exclude": ["dist", "node_modules"] // 编译排除以下文件ts检测
}
</code></pre> </li><li> <p>使用 vite-aliases 插件<br> 默认别名示例：src -&gt; @src; hooks -&gt; @hooks,即使用@符号作为前缀</p> <pre><code>import { defineConfig } from 'vite';
import { ViteAliases } from 'vite-aliases';

export default defineConfig({
    plugins: [
        ViteAliases()
    ]
})

</code></pre> <p>使用/引入路径示例：</p> 
  <blockquote> 
   <p>import xxx from ‘@src/xxxx’;<br> import xxx from ‘@hooks/xxxx’;</p> 
  </blockquote> </li></ol> 
<h6><a id="4_CSS_100"></a>4. CSS样式预处理</h6> 
<p>vite虽然内置了css预处理器,如需要按需引入则需要手动引入css工具</p> 
<pre><code>css: {
    preprocessorOptions: {
      scss: {
        additionalData: `@import '/xxx/xx.scss;` // 引入全局变量文件
      }
    },
  },
</code></pre> 
<h6><a id="5__111"></a>5. 本地调试代理流量转发</h6> 
<pre><code>export default defineConfig({
    server: {
        host: true, // 对所有地址进行监听
        proxy: {
            // 字符串 
            '/foo': 'http://localhost:8080',  

            // 选项写法
            '/api': {
                target: 'http://xxxx.xxxx.com',
                changeOrigin: true,
                rewrite: (path) =&gt; path.replace(/^\/api/, '')
            },  

            // 正则表达式写法  
            '^/fallback/.*': {
                target: 'http://xxxx.xxxx.com',
                changeOrigin: true,
                rewrite: (path) =&gt; path.replace(/^\/fallback/, '')
            },
        }
    }，
  },
})
</code></pre> 
<h2><a id="vite_138"></a>vite服务入口模版</h2> 
<p>vite默认引用外部index.html,在里面通过type="module"实现ES Module注入模版，如果需要调整则需要在 vite.config.js 添加root属性，也可以配置 build 属性（支持多入口）。</p> 
<h6><a id="root_140"></a>修改root</h6> 
<pre><code>import { defineConfig } from 'vite';
export default defineConfig({
    root: 'src/packages/index/', // 模版路径
})

</code></pre> 
<h6><a id="_148"></a>多入口配置尝试</h6> 
<p>rollup打包并不允许相对路径的存在，多入口需要配置不同的npm scripts命令来进入不同的入口（即使这么做是没意义的），试着探索一下可行性，于是有了以下操作：</p> 
<h6><a id="1_viteconfigjs_150"></a>1. vite.config.js</h6> 
<pre><code>import { defineConfig } from 'vite';
export default defineConfig({
    build: {
        rollupOptions: {
            input: {
                mono1: path.resolve(__dirname, 'src/packages/template1/index.html'),
                mono2: path.resolve(__dirname, 'src/packages/template2/index.html'),
            },
        },
    },
})
</code></pre> 
<h6><a id="2_packagejson__164"></a>2. package.json 启动脚本配置</h6> 
<pre><code>// package.json

"scripts": {
    "mono1": "vite serve src/packages/template1/ --config ./vite.config.ts",
    "mono2": "vite serve src/packages/template2/ --config ./vite.config.ts",
}
</code></pre> 
<h2><a id="_173"></a>静态资源管理</h2> 
<ol><li>vite对大多数静态资源类型进行了内置处理,如果还有不支持的通过assetsInclude添加支持.</li><li>静态资源体积 &gt;= 4KB时会提取成单独的文件, &lt; 4KB时则作为 base64 格式的字符串内联</li><li>通过build.assetsInlineLimit自定义配置</li><li>svg属于html类型文件，始终打包成文件</li><li>图片压缩,可借助vite-plugin-imagemin插件</li></ol> 
<pre><code>import { defineConfig } from 'vite';
import viteImagemin from 'vite-plugin-imagemin';

export default defineConfig({
    plugins: [
      viteImagemin({
        gifsicle: {
          optimizationLevel: 7,
          interlaced: false
        },
        optipng: {
          optimizationLevel: 7
        },
        mozjpeg: {
          quality: 20
        },
        pngquant: {
          quality: [0.8, 0.9],
          speed: 4
        },
        svgo: {
          plugins: [
            {
              name: 'removeViewBox'
            },
            {
              name: 'removeEmptyAttrs',
              active: false
            }
          ]
        }
      })
    ],
})
</code></pre> 
<h2><a id="_216"></a>后记</h2> 
<p>这是我第一次写关于vite的文章，由于个人水平有限，也是刚接触到vite，而且每个人的观点和方法可能都存在差异。因此文章中难免会有不严谨甚至不正确的地方，并且每个人的开发环境略有差别，可能会导致代码表现差异，如有发现，欢迎大家指出来并多多交流。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/73754e3160c194d4b62fc9042baae07b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java学生信息管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/476bd7eceb334ffe2ff7e53ae716574a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">qqmap-wx-jssdk.js</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>