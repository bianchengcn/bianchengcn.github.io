<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用udp协议需要服务器监听吗,Nodemcu：如果有/不是udp监听器，UDP通信会受到影响吗？... - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用udp协议需要服务器监听吗,Nodemcu：如果有/不是udp监听器，UDP通信会受到影响吗？..." />
<meta property="og:description" content="我在ESP8266上有一个奇怪的问题，使用nodemcu固件(2.1.0)，在那里我没有任何想法可以尝试解决这个问题。Nodemcu：如果有/不是udp监听器，UDP通信会受到影响吗？
我有一个简单的lua脚本正在运行，它正在侦听UDP命令以开启和关闭中继，并且每隔60秒通过UDP发送活动消息到指定的IP地址。
如果在服务器端没有听到应该得到UDP“活动”消息的东西，ESP反应良好，都很好。 只要我启动netcat来收听来自ESP的UDP包，ESP就会每隔几分钟开始挂起至少30-60秒。 这是特别令人困惑，因为我期待UDP是一个无连接协议。那么UDP上的听众如何影响发送者的行为呢？ 这些是LUA脚本的相关部分：
[...]
alive=60000
[...]
function srvupd(s)
if (connected==1) then
s = s ..&#34; &#34;..ip
srv:send(serverport, serveradr, s..&#34;\n&#34;)
end;
end;
if (alive&gt;0) then
tmr.alarm(2, alive, 1, function()
srvupd(&#34;alive&#34;)
end)
end
srv=net.createUDPSocket()
srv:listen(80)
srv:on(&#34;sent&#34;, function()
srv:close();
srv:listen(80);
end)
srv:on(&#34;receive&#34;,function(client,request, port, ip)
if (alive&gt;0) then tmr.stop(2) end
print(string.format(&#34;received &#39;%s&#39; from %s:%d&#34;, request, ip, port))
buf=&#34;unknown&#34;
if (request == &#34;ch1on&#34;) then gpio.write(relay1, relayon);buf=&#34;ok&#34; end
[...]
client:send(port, ip, buf)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/1c806797b032a1425e5ebf3286f5b290/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-12T05:56:51+08:00" />
<meta property="article:modified_time" content="2021-08-12T05:56:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用udp协议需要服务器监听吗,Nodemcu：如果有/不是udp监听器，UDP通信会受到影响吗？...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>我在ESP8266上有一个奇怪的问题，使用nodemcu固件(2.1.0)，在那里我没有任何想法可以尝试解决这个问题。Nodemcu：如果有/不是udp监听器，UDP通信会受到影响吗？</p> 
 <p>我有一个简单的lua脚本正在运行，它正在侦听UDP命令以开启和关闭中继，并且每隔60秒通过UDP发送活动消息到指定的IP地址。</p> 
 <p>如果在服务器端没有听到应该得到UDP“活动”消息的东西，ESP反应良好，都很好。 只要我启动netcat来收听来自ESP的UDP包，ESP就会每隔几分钟开始挂起至少30-60秒。 这是特别令人困惑，因为我期待UDP是一个无连接协议。那么UDP上的听众如何影响发送者的行为呢？ 这些是LUA脚本的相关部分：</p> 
 <p>[...]</p> 
 <p>alive=60000</p> 
 <p>[...]</p> 
 <p>function srvupd(s)</p> 
 <p>if (connected==1) then</p> 
 <p>s = s .." "..ip</p> 
 <p>srv:send(serverport, serveradr, s.."\n")</p> 
 <p>end;</p> 
 <p>end;</p> 
 <p>if (alive&gt;0) then</p> 
 <p>tmr.alarm(2, alive, 1, function()</p> 
 <p>srvupd("alive")</p> 
 <p>end)</p> 
 <p>end</p> 
 <p>srv=net.createUDPSocket()</p> 
 <p>srv:listen(80)</p> 
 <p>srv:on("sent", function()</p> 
 <p>srv:close();</p> 
 <p>srv:listen(80);</p> 
 <p>end)</p> 
 <p>srv:on("receive",function(client,request, port, ip)</p> 
 <p>if (alive&gt;0) then tmr.stop(2) end</p> 
 <p>print(string.format("received '%s' from %s:%d", request, ip, port))</p> 
 <p>buf="unknown"</p> 
 <p>if (request == "ch1on") then gpio.write(relay1, relayon);buf="ok" end</p> 
 <p>[...]</p> 
 <p>client:send(port, ip, buf)</p> 
 <p>if (alive&gt;0) then tmr.start(2) end</p> 
 <p>end)</p> 
 <p>这就是我如何使用netcat来聆听来自ESP在bash脚本的UDP消息：</p> 
 <p>#!/bin/bash</p> 
 <p>while true</p> 
 <p>do</p> 
 <p>msg=$(netcat -4 -u -n -l -D 192.168.0.5 2701 -w0 -q0)</p> 
 <p>echo -e "$msg"</p> 
 <p>done</p> 
 <p>在情况ESP不再对UDP命令作出反应，活着的消息仍然每分钟发送一次。 UDP命令甚至可以被ESP接收，因为只要处理继续，一段时间之前发送的“通道开启”命令就会被执行。</p> 
 <p>ESP的这些临时阻塞仅在我侦听其UDP消息时才会发生。 我已经检查过所有类型的组合，例如监听器的独立UDP套接字和ESP上的活动发送，关闭并打开服务器，发送消息后(如上面的当前版本)等。 甚至试图通过TCP接收命令，只通过UDP发送活动消息。 行为保持不变。所有的工作，只要没有收到来自ESP的UDP消息。只要我启动netcat，ESP就会在几分钟内开始挂起。</p> 
 <p>任何想法？因为它是UDP，所以很难理解它是如何发生的。</p> 
 <p>亲切的问候 Tjareson</p> 
 <p>2017-06-13</p> 
 <p>Tjareson</p> 
 <p>+0</p> 
 <p>您是否尝试过像Wireshark这样的其他工具来查看它是否仅仅是您的bash脚本而不是导致问题的ESP？ –</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5b58bf32c0717b4d584b140c30815d55/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何通过网站漏洞攻击服务器,网站服务器如何有效防御PHP木马攻击</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7d18325957292e4092554ddabe70e78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">echarts 柱状图颜色渐变效果</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>