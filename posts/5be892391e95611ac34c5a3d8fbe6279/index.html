<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java基础-抽象类（Abstract） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java基础-抽象类（Abstract）" />
<meta property="og:description" content="什么是抽象类？ 随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该能够保证父类和子类共享特性。有时将一个父类设计的非常抽象，以至于他没有具体的实例，不能被实例化，只能被继承，这样的类叫做抽象类。
关键字：Abstract（可以用来修饰类和方法）
Abstract修饰类和方法的使用 1、Abstract 修饰类，抽象类
1）不可被实例化；
2）抽象类有构造器（凡是类都有构造器）
3）抽象方法所在的类，一定是抽象类
4）抽象类中可以没有抽象方法
2、Abstract 修饰方法，抽象方法
1）格式，没有方法体，包括{}，如public abstract void eat()；
2）抽象方法只保留方法的功能，而具体的执行，交给继承抽象类的子类，由子类重写此方法。
3）若子类继承了抽象类，并且重写了所有抽象方法，则此类是一个“实体类”，既可以实例化。
4）若子类继承了抽象类，没有重写抽象类中所有的抽象方法，以为着此类中仍有抽象方法，则此类还是一个抽象类。
3、Abstract 使用的限制
不能用Abstract修饰属性、私有方法、构造器、静态方法、final方法
抽象类练习：
编写一个Employee类，声明为抽象类，包含如下三个属性：name，id，salary。提供必要的构造器和抽象方法：work() 。对弈Manager类来说，他既是员工，它还具有奖金(bonus)的属性，请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。
Code
class CommonEmployee extends Employee { @Override public void work() { System.out.println(&#34;在流水线工作&#34;); } } class Manager extends Employee{ private String bonus; public String getBonus() { return bonus; } public void setBonus(String bonus) { this.bonus = bonus; } @Override public void work() { System.out.println(&#34;监督员工工作，提高员工工作效率&#34;); } } abstract class Employee{ private int id; private String name; private Double salary; public abstract void work(); public Double getSalary() { return salary; } public int getId() { return id; } public String getName() { return name; } public void setId(int id) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5be892391e95611ac34c5a3d8fbe6279/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-10T18:31:32+08:00" />
<meta property="article:modified_time" content="2019-03-10T18:31:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java基础-抽象类（Abstract）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong>什么是抽象类？</strong></h3> 
<p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该能够保证父类和子类共享特性。有时将一个父类设计的非常抽象，以至于他没有具体的实例，不能被实例化，只能被继承，这样的类叫做抽象类。</p> 
<p><strong>关键字</strong>：Abstract（可以用来修饰类和方法）</p> 
<h3><strong>Abstract修饰类和方法的使用</strong></h3> 
<p><strong>1、Abstract 修饰类，抽象类</strong></p> 
<p>1）不可被实例化；</p> 
<p>2）抽象类有构造器（凡是类都有构造器）</p> 
<p>3）抽象方法所在的类，一定是抽象类</p> 
<p>4）抽象类中可以没有抽象方法</p> 
<p> </p> 
<p><strong>2、Abstract 修饰方法，抽象方法</strong></p> 
<p>1）格式，没有方法体，包括{}，如public abstract void eat()；</p> 
<p>2）抽象方法只保留方法的功能，而具体的执行，交给继承抽象类的子类，由子类重写此方法。</p> 
<p>3）若子类继承了抽象类，并且重写了所有抽象方法，则此类是一个“实体类”，既可以实例化。</p> 
<p>4）若子类继承了抽象类，没有重写抽象类中所有的抽象方法，以为着此类中仍有抽象方法，则此类还是一个抽象类。</p> 
<p>3、<strong>Abstract 使用的限制</strong></p> 
<p>      不能用Abstract修饰属性、私有方法、构造器、静态方法、final方法</p> 
<p>抽象类练习：</p> 
<p>编写一个Employee类，声明为抽象类，包含如下三个属性：name，id，salary。提供必要的构造器和抽象方法：work() 。对弈Manager类来说，他既是员工，它还具有奖金(bonus)的属性，请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。</p> 
<p>Code</p> 
<pre class="has"><code class="language-java">class CommonEmployee extends  Employee {

    @Override
    public void work() {
        System.out.println("在流水线工作");
    }

}

class Manager extends  Employee{
    private String bonus;

    public String getBonus() {
        return bonus;
    }

    public void setBonus(String bonus) {
        this.bonus = bonus;
    }

    @Override
    public void work() {
        System.out.println("监督员工工作，提高员工工作效率");
    }
}

abstract class Employee{
    private int id;
    private String name;
    private Double salary;

    public abstract  void work();

    public Double getSalary() {
        return salary;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setSalary(Double salary) {
        this.salary = salary;
    }
}

public class TestAbstract {
    public static void main(String[] arg){
        Employee e = new Manager();
        e.work();

        Employee e1 = new CommonEmployee();
        e1.work();
    }
}
</code></pre> 
<p>代码输出</p> 
<p>监督员工工作，提高员工工作效率<br> 在流水线工作</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be110e98551ce6d6289032d0bef0b62d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jquery一个ajax方法结束后，再执行下一个ajax方法。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b18c9e84a2b64698e7936efa772ce714/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">设计模式-模板方法(TemplateMethod)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>