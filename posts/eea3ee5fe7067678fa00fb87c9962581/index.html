<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>1003.斐波那契数列 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="1003.斐波那契数列" />
<meta property="og:description" content="题目描述： 在数学上，斐波那契数列（Fibonacci Sequence），是以递归的方法来定义：
F0 = 0
F1 = 1
Fn = Fn - 1 &#43; Fn - 2
用文字来说，就是斐波那契数列由0和1开始，之后的斐波那契数就由之前的两数相加。首几个斐波那契数是：
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946，………………
特别指出：0不是第一项，而是第零项。
在西方，最先研究这个数列的人是比萨的列奥纳多（又名斐波那契），他描述兔子生长的数目时用上了这数列。
n 第一个月有一对刚诞生的兔子
n 第两个月之后它们可以生育
n 每月每对可生育的兔子会诞生下一对新兔子
n 兔子永不死去
假设在n月有新生及可生育的兔子总共a对，n&#43;1月就总共有b对。在n&#43;2月必定总共有a&#43;b对：因为在n&#43;2月的时候，所有在n月就已存在的a对兔子皆已可以生育并诞下a对后代；同时在前一月(n&#43;1月)之b对兔子中，在当月属于新诞生的兔子尚不能生育。
现请以较短的时间，求出斐波那契数列第n项数值，0≤n≤40。
解析： 对于斐波那契数列，兔子生育问题不能再经典和形象了，这个例子很好的将数列应用化，再详细解释下为什么N&#43;2=N&#43;（N&#43;1）.见下： 兔子类型一共是两种要记住：1已长大可以生孩子的兔子 2新生的兔子 注意这里是一对老兔子生一对新兔子，为了不说起来麻烦，我只直接说1生1喽。
首先N月的兔子包括已长大可以生孩子的兔子 群体A和本月是新生儿的兔子群体B，生产力为A，那么在N&#43;1月，A又生了A，而B刚长大，下个月即N&#43;2月才能生，所以N&#43;1月兔子数应为A(N月就能生了)&#43;A（N&#43;1月新生儿）&#43;B（本月刚成熟）,生产力为A&#43;B，所以这样来看就很简单了，N&#43;2月的总数量就是N&#43;1月的兔子总量A&#43;A&#43;B加上N&#43;1月新生产的新生儿A&#43;B,即3A&#43;2B，正好是N月和N&#43;1月的总和。 不知道这样讲能否让你明白，如果还是云里雾里，不妨自己画图看一下。其实有个很直观的理解，就是，我们应该明白， 一个月的兔子数就应该是上个月已有的兔子数&#43;本月又新生产的兔子，那么本月又新生产的兔子是怎么来的呢，无疑看公式来说必须是上上个月所有兔子的总数，因为上上个月还不能生孩子的兔子在第三个月（也就是N&#43;2月）生出来了第一批！而N&#43;1月比N月多出来的兔子对N&#43;2月是没有生产力的！
这就是斐波那契数列应用模型。
下面是自己写的比较挫的一个代码。检验无错，但是提交显示ERROR at test 2 ，不理解，有知道的朋友麻烦指正我。
#include&lt;iostream&gt; using namespace std; unsigned long int Fibonacci(unsigned long int F0,unsigned long int F1, int n, int count){ unsigned long int F2; F2=F0&#43;F1; count&#43;&#43;; if(count!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/eea3ee5fe7067678fa00fb87c9962581/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-04-27T15:52:12+08:00" />
<meta property="article:modified_time" content="2015-04-27T15:52:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">1003.斐波那契数列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>题目描述： <br> 在数学上，斐波那契数列（Fibonacci Sequence），是以递归的方法来定义：</p> 
<p>F0 = 0</p> 
<p>F1 = 1</p> 
<p>Fn = Fn - 1 + Fn - 2</p> 
<p>用文字来说，就是斐波那契数列由0和1开始，之后的斐波那契数就由之前的两数相加。首几个斐波那契数是：</p> 
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946，………………</p> 
<p>特别指出：0不是第一项，而是第零项。</p> 
<p>在西方，最先研究这个数列的人是比萨的列奥纳多（又名斐波那契），他描述兔子生长的数目时用上了这数列。</p> 
<p>n 第一个月有一对刚诞生的兔子</p> 
<p>n 第两个月之后它们可以生育</p> 
<p>n 每月每对可生育的兔子会诞生下一对新兔子</p> 
<p>n 兔子永不死去</p> 
<p>假设在n月有新生及可生育的兔子总共a对，n+1月就总共有b对。在n+2月必定总共有a+b对：因为在n+2月的时候，所有在n月就已存在的a对兔子皆已可以生育并诞下a对后代；同时在前一月(n+1月)之b对兔子中，在当月属于新诞生的兔子尚不能生育。</p> 
<p>现请以较短的时间，求出斐波那契数列第n项数值，0≤n≤40。</p> 
<hr> 
<p><strong>解析：</strong> <br> 对于斐波那契数列，兔子生育问题不能再经典和形象了，这个例子很好的将数列应用化，再详细解释下为什么N+2=N+（N+1）.见下： <br> 兔子类型一共是两种要记住：1已长大可以生孩子的兔子 2新生的兔子 <br> 注意这里是一对老兔子生一对新兔子，为了不说起来麻烦，我只直接说1生1喽。</p> 
<p>首先N月的兔子包括已长大可以生孩子的兔子 群体A和本月是新生儿的兔子群体B，生产力为A，那么在N+1月，A又生了A，而B刚长大，下个月即N+2月才能生，所以N+1月兔子数应为A(N月就能生了)+A（N+1月新生儿）+B（本月刚成熟）,生产力为A+B，所以这样来看就很简单了，N+2月的总数量就是N+1月的兔子总量A+A+B加上N+1月新生产的新生儿A+B,即3A+2B，正好是N月和N+1月的总和。 <br> 不知道这样讲能否让你明白，如果还是云里雾里，不妨自己画图看一下。其实有个很直观的理解，就是，我们应该明白， 一个月的兔子数就应该是上个月已有的兔子数+本月又新生产的兔子，那么本月又新生产的兔子是怎么来的呢，无疑看公式来说必须是上上个月所有兔子的总数，因为上上个月还不能生孩子的兔子在第三个月（也就是N+2月）生出来了第一批！而N+1月比N月多出来的兔子对N+2月是没有生产力的！</p> 
<p>这就是斐波那契数列应用模型。</p> 
<p>下面是自己写的比较挫的一个代码。检验无错，但是提交显示ERROR at test 2 ，不理解，有知道的朋友麻烦指正我。</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> Fibonacci(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> F0,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> F1, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> count){

    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> F2;
    F2=F0+F1;
    count++;
    <span class="hljs-keyword">if</span>(count!=n)
    Fibonacci(F1,F2,n,count);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> F2;
}

<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> F0=<span class="hljs-number">0</span>,F1=<span class="hljs-number">1</span>;
     <span class="hljs-keyword">int</span> n;
     <span class="hljs-keyword">int</span> count=<span class="hljs-number">1</span>;
    <span class="hljs-built_in">cin</span>&gt;&gt;n;
    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;Fibonacci(F0,F1,n,count);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}



</code></pre> 
<p>之后换了个最简单的方法，反而AC了。</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;


<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> a[<span class="hljs-number">41</span>]={<!-- --><span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>};
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-built_in">cin</span>&gt;&gt;n;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++){
        a[i]=a[i-<span class="hljs-number">1</span>]+a[i-<span class="hljs-number">2</span>];
    }
    <span class="hljs-built_in">cout</span>&lt;&lt;a[n];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6627367e1e4627199852f1406cea8465/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">int a; int* a; int** a; int (*a)[]; int (*a)(int)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d546de66653f121d2befdf25d25f5f70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LSTM简介以及数学推导(FULL BPTT)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>