<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>变量声明-TS学习笔记（2） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="变量声明-TS学习笔记（2）" />
<meta property="og:description" content="let和const是JavaScript里相对较新的变量声明方式。 像我们之前提到过的，let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。
因为TypeScript是JavaScript的超集，所以它本身就支持let和const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替var。
var 声明 一直以来我们都是通过var关键字定义JavaScript变量。
var a = 10; 大家都能理解，这里定义了一个名为a值为10的变量。
我们也可以在函数内部定义变量：
function f() { var message = &#34;Hello, world!&#34;; return message; } 并且我们也可以在其它函数内部访问相同的变量。
function f() { var a = 10; return function g() { var b = a &#43; 1; return b; } } var g = f(); g(); // returns 11; 上面的例子里，g可以获取到f函数里定义的a变量。 每当g被调用时，它都可以访问到f里的a变量。 即使当g在f已经执行完后才被调用，它仍然可以访问及修改a。
function f() { var a = 1; a = 2; var b = g(); a = 3; return b; function g() { return a; } } f(); // returns 2 作用域规则 对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2d739d044709bc56c98773d8cc4ab7c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-10-14T15:57:23+08:00" />
<meta property="article:modified_time" content="2016-10-14T15:57:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">变量声明-TS学习笔记（2）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>let和const是JavaScript里相对较新的变量声明方式。 像我们之前提到过的，let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。</p> 
<p>因为TypeScript是JavaScript的超集，所以它本身就支持let和const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替var。</p> 
<ul><li><strong>var 声明</strong></li></ul> 
<p>一直以来我们都是通过var关键字定义JavaScript变量。</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">var a </span>=<span class="hljs-string"> 10;</span></code></pre> 
<p>大家都能理解，这里定义了一个名为a值为10的变量。</p> 
<p>我们也可以在函数内部定义变量：</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> {<!-- --></span>
    <span class="hljs-keyword">var</span> message = <span class="hljs-string">"Hello, world!"</span>;

    <span class="hljs-keyword">return</span> message;
}</code></pre> 
<p>并且我们也可以在其它函数内部访问相同的变量。</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> {<!-- --></span>
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> {<!-- --></span>
        <span class="hljs-keyword">var</span> b = a + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> b;
    }
}
<span class="hljs-keyword">var</span> g = f();
g(); <span class="hljs-comment">// returns 11;</span></code></pre> 
<p>上面的例子里，g可以获取到f函数里定义的a变量。 每当g被调用时，它都可以访问到f里的a变量。 即使当g在f已经执行完后才被调用，它仍然可以访问及修改a。</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> {<!-- --></span>
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;

    a = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> b = g();
    a = <span class="hljs-number">3</span>;

    <span class="hljs-keyword">return</span> b;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> {<!-- --></span>
        <span class="hljs-keyword">return</span> a;
    }
}

f(); <span class="hljs-comment">// returns 2</span></code></pre> 
<ul><li><strong>作用域规则</strong></li></ul> 
<p>对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子：</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(shouldInitialize: boolean)</span> {<!-- --></span>
    <span class="hljs-keyword">if</span> (shouldInitialize) {
        <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;
    }

    <span class="hljs-keyword">return</span> x;
}

f(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// returns '10'</span>
f(<span class="hljs-literal">false</span>); <span class="hljs-comment">// returns 'undefined'</span></code></pre> 
<p>有些读者可能要多看几遍这个例子。 变量x是定义在if语句里面，但是我们却可以在语句的外面访问它。 这是因为var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问，包含它的代码块对此没有什么影响。 有些人称此为var作用域或函数作用域。 函数参数也使用函数作用域。</p> 
<p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p> 
<pre class="prettyprint"><code class=" hljs scilab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumMatrix</span><span class="hljs-params">(matrix: number[][])</span> {<!-- --></span>
    var <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-transposed_variable">matrix.</span><span class="hljs-built_in">length</span>; i++) {
        var currentRow = <span class="hljs-built_in">matrix</span><span class="hljs-matrix">[i]</span>;
        <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-transposed_variable">currentRow.</span><span class="hljs-built_in">length</span>; i++) {
            <span class="hljs-built_in">sum</span> += currentRow<span class="hljs-matrix">[i]</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>;
}</code></pre> 
<p>这里很容易看出一些问题，里层的for循环会覆盖变量i，因为所有i都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p> 
<ul><li><strong>变量获取怪异之处</strong></li></ul> 
<pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; <span class="hljs-number">10</span>; <span class="hljs-built_in">i</span>++) <span class="hljs-cell">{
    setTimeout(function() { console.log(i); }</span>, <span class="hljs-number">100</span> * <span class="hljs-built_in">i</span>);
}</code></pre> 
<p>代码会返回结果是：</p> 
<pre class="prettyprint"><code class=" hljs ">10
10
10
10
10
10
10
10
10
10</code></pre> 
<p>setTimeout会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。并且是在for循环结束后。 for循环结束后，i的值为10。 所以当函数被调用的时候，它会打印出10！</p> 
<p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时i的值：</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    <span class="hljs-comment">// capture the current state of 'i'</span>
    <span class="hljs-comment">// by invoking a function with its current value</span>
    (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(i)</span> {<!-- --></span>
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {<!-- --></span> console.log(i); }, <span class="hljs-number">100</span> * i);
    })(i);
}</code></pre> 
<p>这种奇怪的形式我们已经司空见惯了。 参数i会覆盖for循环里的i，但是因为我们起了同样的名字，所以我们不用怎么改for循环体里的代码。</p> 
<ul><li><strong>let 声明</strong></li></ul> 
<p>现在你已经知道了var存在一些问题，这恰好说明了为什么用let语句来声明变量。 除了名字不同外，let与var的写法一致。</p> 
<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-built_in">let</span> hello = <span class="hljs-string">"Hello!"</span>;</code></pre> 
<p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p> 
<ul><li><strong>块作用域</strong></li></ul> 
<p>当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(input: boolean)</span> {<!-- --></span>
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">100</span>;

    <span class="hljs-keyword">if</span> (input) {
        <span class="hljs-comment">// 仍然可以引用 'a'</span>
        <span class="hljs-keyword">let</span> b = a + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> b;
    }

    <span class="hljs-comment">// Error: 'b' 并不存在这里</span>
    <span class="hljs-keyword">return</span> b;
}</code></pre> 
<p>这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里。</p> 
<p>在catch语句里声明的变量也具有同样的作用域规则。</p> 
<pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-string">"oh no!"</span>;
}
<span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Oh well."</span>);
}

 <span class="hljs-regexp">//</span><span class="hljs-attribute">Error</span>: <span class="hljs-string">'e'</span> 不存在
<span class="hljs-built_in">console</span>.log(e);</code></pre> 
<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于时间死区。 它只是用来说明我们不能在let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。</p> 
<pre class="prettyprint"><code class=" hljs vhdl">a++; // illegal <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span> <span class="hljs-attribute">'a</span>' before it<span class="hljs-attribute">'s</span> declared;
let a;</code></pre> 
<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> {<!-- --></span>
    <span class="hljs-comment">// okay to capture 'a'</span>
    <span class="hljs-keyword">return</span> a;
}

<span class="hljs-comment">// 不能在'a'被声明前调用'foo'</span>
<span class="hljs-comment">// 运行时应该抛出错误</span>
foo();

<span class="hljs-keyword">let</span> a;</code></pre> 
<ul><li><strong>重定义及屏蔽</strong></li></ul> 
<p>我们提过使用var声明时，它不在乎你声明多少次；你只会得到1个。</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span> {<!-- --></span>
    <span class="hljs-keyword">var</span> x;
    <span class="hljs-keyword">var</span> x;

    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> x;
    }
}</code></pre> 
<p>在上面的例子里，所有x的声明实际上都引用一个相同的x，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是，let声明就不会这么宽松了。</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;
<span class="hljs-keyword">let</span> x = <span class="hljs-number">20</span>; <span class="hljs-comment">// 错误，不能在1个作用域里多次声明`x`</span></code></pre> 
<p>并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span> {<!-- --></span>
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">100</span>; <span class="hljs-comment">// error: interferes with parameter declaration</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> {<!-- --></span>
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">100</span>;
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">100</span>; <span class="hljs-comment">// error: 不能2次声明 'x'</span>
}</code></pre> 
<p>并不是说块级作用域变量不能在函数作用域内声明。 而是块级作用域变量需要在不用的块里声明。</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(condition, x)</span> {<!-- --></span>
    <span class="hljs-keyword">if</span> (condition) {
        <span class="hljs-keyword">let</span> x = <span class="hljs-number">100</span>;
        <span class="hljs-keyword">return</span> x;
    }

    <span class="hljs-keyword">return</span> x;
}

f(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// returns 0</span>
f(<span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// returns 100</span></code></pre> 
<p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用let重写之前的sumMatrix函数。</p> 
<pre class="prettyprint"><code class=" hljs scilab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumMatrix</span><span class="hljs-params">(matrix: number[][])</span> {<!-- --></span>
    let <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-transposed_variable">matrix.</span><span class="hljs-built_in">length</span>; i++) {
        var currentRow = <span class="hljs-built_in">matrix</span><span class="hljs-matrix">[i]</span>;
        <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-transposed_variable">currentRow.</span><span class="hljs-built_in">length</span>; i++) {
            <span class="hljs-built_in">sum</span> += currentRow<span class="hljs-matrix">[i]</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>;
}</code></pre> 
<p>这个版本的循环能得到正确的结果，因为内层循环的i可以屏蔽掉外层循环的i。</p> 
<p>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。</p> 
<ul><li><strong>块级作用域变量的获取</strong></li></ul> 
<p>在我们最初谈及获取用var声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">theCityThatAlwaysSleeps</span><span class="hljs-params">()</span> {<!-- --></span>
    <span class="hljs-keyword">let</span> getCity;

    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">let</span> city = <span class="hljs-string">"Seattle"</span>;
        getCity = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {<!-- --></span>
            <span class="hljs-keyword">return</span> city;
        }
    }

    <span class="hljs-keyword">return</span> getCity();
}</code></pre> 
<p>因为我们已经在city的环境里获取到了city，所以就算if语句执行结束后我们仍然可以访问它。</p> 
<p>回想一下前面setTimeout的例子，我们最后需要使用立即执行的函数表达式来获取每次for循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。</p> 
<p>当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在setTimeout例子里我们仅使用let声明就可以了。</p> 
<pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-keyword">for</span> (let <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; <span class="hljs-number">10</span> ; <span class="hljs-built_in">i</span>++) <span class="hljs-cell">{
    setTimeout(function() {console.log(i); }</span>, <span class="hljs-number">100</span> * <span class="hljs-built_in">i</span>);
}</code></pre> 
<p>会输出与预料一致的结果：</p> 
<pre class="prettyprint"><code class=" hljs ">0
1
2
3
4
5
6
7
8
9</code></pre> 
<h3 id="const-声明">const 声明</h3> 
<p>const 声明是声明变量的另一种方式。</p> 
<p>const numLivesForCat = 9; <br> 它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与let相同的作用域规则，但是不能对它们重新赋值。</p> 
<p>这很好理解，它们引用的值是不可变的。</p> 
<pre class="prettyprint"><code class=" hljs avrasm">const numLivesForCat = <span class="hljs-number">9</span><span class="hljs-comment">;</span>
const kitty = {
    name: <span class="hljs-string">"Aurora"</span>,
    numLives: numLivesForCat,
}

// Error
kitty = {
    name: <span class="hljs-string">"Danielle"</span>,
    numLives: numLivesForCat
}<span class="hljs-comment">;</span>

// all <span class="hljs-string">"okay"</span>
kitty<span class="hljs-preprocessor">.name</span> = <span class="hljs-string">"Rory"</span><span class="hljs-comment">;</span>
kitty<span class="hljs-preprocessor">.name</span> = <span class="hljs-string">"Kitty"</span><span class="hljs-comment">;</span>
kitty<span class="hljs-preprocessor">.name</span> = <span class="hljs-string">"Cat"</span><span class="hljs-comment">;</span>
kitty<span class="hljs-preprocessor">.numLives</span>--<span class="hljs-comment">;</span></code></pre> 
<p>除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 接口一章有详细说明。</p> 
<ul><li><strong>let vs. const</strong></li></ul> 
<p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。</p> 
<p>使用最小特权原则，所有变量除了你计划去修改的都应该使用const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用const也可以让我们更容易的推测数据的流动。</p> 
<p>另一方面，用户很喜欢let的简洁性。 这个手册大部分地方都使用了let。</p> 
<p>跟据你的自己判断，如果合适的话，与团队成员商议一下。 Fortunately, TypeScript allows you to specify that members of an object are readonly. The chapter on Interfaces has the details.</p> 
<h3 id="解构">解构</h3> 
<ul><li><strong>解构数组</strong></li></ul> 
<p>最简单的解构莫过于数组的解构赋值了：</p> 
<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">let</span> input = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-keyword">let</span> [first, second] = input;
console.<span class="hljs-keyword">log</span>(first); <span class="hljs-comment">// outputs 1</span>
console.<span class="hljs-keyword">log</span>(second); <span class="hljs-comment">// outputs 2</span></code></pre> 
<p>这创建了2个命名变量 first 和 second。 相当于使用了索引，但更为方便：</p> 
<pre class="prettyprint"><code class=" hljs ini"><span class="hljs-setting">first = <span class="hljs-value">input[<span class="hljs-number">0</span>];</span></span>
<span class="hljs-setting">second = <span class="hljs-value">input[<span class="hljs-number">1</span>];</span></span></code></pre> 
<p>解构作用于已声明的变量会更好：</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">// swap variables 交换变量
[first, second] </span>=<span class="hljs-string"> [second, first];</span></code></pre> 
<p>作用于函数参数：</p> 
<pre class="prettyprint"><code class=" hljs applescript">function f([<span class="hljs-keyword">first</span>, <span class="hljs-keyword">second</span>]: [<span class="hljs-type">number</span>, <span class="hljs-type">number</span>]) {
    console.<span class="hljs-command">log</span>(<span class="hljs-keyword">first</span>);
    console.<span class="hljs-command">log</span>(<span class="hljs-keyword">second</span>);
}
f(input);</code></pre> 
<p>你可以使用…name语法创建一个剩余变量列表：</p> 
<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">let</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
console.<span class="hljs-keyword">log</span>(first); <span class="hljs-comment">// outputs 1</span>
console.<span class="hljs-keyword">log</span>(rest); <span class="hljs-comment">// outputs [ 2, 3, 4 ]</span></code></pre> 
<p>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p> 
<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">let</span> [first] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
console.<span class="hljs-keyword">log</span>(first); <span class="hljs-comment">// outputs 1</span></code></pre> 
<p>或其它元素：</p> 
<pre class="prettyprint"><code class=" hljs autohotkey">let [, second, , fourth] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<span class="hljs-comment">;</span></code></pre> 
<p>对象解构</p> 
<p>你也可以解构对象：</p> 
<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-built_in">let</span> o = {
    a: <span class="hljs-string">"foo"</span>,
    b: <span class="hljs-number">12</span>,
    c: <span class="hljs-string">"bar"</span>
}
<span class="hljs-built_in">let</span> {a, b} = o;</code></pre> 
<p>这通过 o.a and o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。</p> 
<p>就像数组解构，你可以用没有声明的赋值：</p> 
<pre class="prettyprint"><code class=" hljs clojure"><span class="hljs-list">(<span class="hljs-collection">{a, b}</span> = <span class="hljs-collection">{a: <span class="hljs-string">"baz"</span>, b<span class="hljs-number">: 101</span>}</span>)</span><span class="hljs-comment">;</span></code></pre> 
<p>注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。</p> 
<ul><li><strong>属性重命名</strong></li></ul> 
<p>你也可以给属性以不同的名字：</p> 
<p>let {a: newName1, b: newName2} = o; <br> 这里的语法开始变得混乱。 你可以将 a: newName1 读做 “a 作为 newName1”。 方向是从左到右，好像你写成了以下样子：</p> 
<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-built_in">let</span> newName1 = o.a;
<span class="hljs-built_in">let</span> newName2 = o.b;</code></pre> 
<p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">let</span> {a, b}: {a: <span class="hljs-keyword">string</span>, b: number} = o;</code></pre> 
<p>默认值</p> 
<p>默认值可以让你在属性为 undefined 时使用缺省值：</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">keepWholeObject</span><span class="hljs-params">(wholeObject: {a: string, b?: number})</span> {<!-- --></span>
    <span class="hljs-keyword">let</span> {a, b = <span class="hljs-number">1001</span>} = wholeObject;
}</code></pre> 
<p>现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。</p> 
<ul><li><strong>函数声明</strong></li></ul> 
<p>解构也能用于函数声明。 看以下简单的情况：</p> 
<pre class="prettyprint"><code class=" hljs actionscript">type C = {a: string, b?: number}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">({a, b}: C)</span><span class="hljs-type">: void</span> {<!-- --></span>
    <span class="hljs-comment">// ...</span>
}</code></pre> 
<p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要知道在设置默认值之前设置其类型。</p> 
<pre class="prettyprint"><code class=" hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">({a, b} = {a: <span class="hljs-string">""</span>, b: 0})</span><span class="hljs-type">: void</span> {<!-- --></span>
    <span class="hljs-comment">// ...</span>
}
f(); <span class="hljs-comment">// ok, default to {a: "", b: 0}</span></code></pre> 
<p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p> 
<pre class="prettyprint"><code class=" hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">({a, b = 0} = {a: <span class="hljs-string">""</span>})</span><span class="hljs-type">: void</span> {<!-- --></span>
    <span class="hljs-comment">// ...</span>
}
f({a: <span class="hljs-string">"yes"</span>}) <span class="hljs-comment">// ok, default b = 0</span>
f() <span class="hljs-comment">// ok, default to {a: ""}, which then defaults b = 0</span>
f({}) <span class="hljs-comment">// error, 'a' is required if you supply an argument</span></code></pre> 
<p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构也会有很多问题。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7db171c6cdfca15f291a3cfbdc7fb507/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jquery 实时监听输入框值变化的完美方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d914b60b215c6c34b2c5fa12a9e53d02/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Matconvnet工具箱在Matlab中的安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>