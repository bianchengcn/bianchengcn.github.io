<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Scala学习（基础篇）待更新 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Scala学习（基础篇）待更新" />
<meta property="og:description" content="文章目录 引言大数据介绍大数据与云计算区别大数据和人工智能的区别大数据和传统的分析（excel）的区别scala的特性面向对象特性函数式编程函数式编程的特点：函数式编程的优势静态类型扩展性并发性 为什么要学scalascala安装简单测试了解ScalaScala来源 Scala解释器Scala集成环境配置命名规范Scala基本语法换行符Scala 包定义包引用 Scala 数据类型Scala 基础字面量Scala 转义字符 Scala变量变量类型声明变量推断Scala 多个变量声明其他类型var和val的区别可变和不可变？ Maven项目整合scalaScala类型转换Scala访问修饰符私有(Private)成员保护(Protected)成员公共(Public)成员 作用域保护 引言 推荐学习视频
大数据介绍 主要工作：数据统计分析（hadoop工程师、spark工程师、flink工程师、数仓工程师、BI工程师、ETL工程师 、大数据平台工程师）
大数据与云计算区别 大数据可以做数据分析统计，而云计算可以为大数据提供一套资源利用的平台，因此大数据很多时候基于云计算。
大数据和人工智能的区别 首先人工智能基于大数据，大数据为人工智能提供重要的海量数据
大数据和传统的分析（excel）的区别 采用excel处理数据的方式早已不能承担海量数据的处理
scala的特性 面向对象特性 Scala是一种纯面向对象的语言，每个值都是对象，包括基本数据类型（即布尔值、数字等）在内，当然函数也是对象。
类可以被子类化，对象的数据类型以及行为由类和特质描述。
类抽象机制的扩展有两种途径：一种途径是子类继承，另一种途径是灵活的混入机制。这两种途径能避免多重继承的种种问题。
函数式编程 Scala也是一种函数式语言，其函数也能当成值来使用。Scala提供了轻量级的语法用以定义匿名函数，支持高阶函数，允许嵌套多层函数，并支持柯里化。Scala的case class及其内置的模式匹配相当于函数式编程语言中常用的代数类型。
更进一步，程序员可以利用Scala的模式匹配，编写类似正则表达式的代码处理XML数据。
纯粹的函数编程语言编写的函数没有变量。因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可有得到不同的输出，因此，这种函数式有副作用的。
函数式编程的特点： 函数是一等公民
以表达式为中心
无副作用
只用纯函数来构造函程序，或者说函数没有副作用。 不修改状态
引用透明
函数式编程的优势 代码简洁，开发速度快
接近自然语言，易理解
易于代码管理
适合并发编程
适用于热升级
静态类型 Scala具备类型系统，通过编译时检查，保证代码的安全性和一致性。类型系统具体支持以下特性：
泛型类
协变和逆变
标注
类型参数的上下限约束
把类别和抽象类型作为对象成员
复合类型
引用自己时显式指定类型
视图
多态方法
扩展性 Scala的设计秉承一项事实，即在实践中，某个领域特定的应用程序开发往往需要特定于该领域的语言扩展。Scala提供了许多独特的语言机制，可以以库的形式轻易无缝添加新的语言结构：
任何方法可用作前缀或后缀操作符。
可以根据预期类型自动构造闭包。
并发性 Scala使用Actor作为其并发模型，Actor是类似线程的实体，通过邮箱发收消息。Actor可以复用线程，因此可以在程序中可以使用数百万个Actor,而线程只能创建数千个。在2.10之后的版本中，使用Akka作为其默认Actor实现。
为什么要学scala 1.优雅
框架的而用户是应用开发程序员，API是否优雅直接影响用户体验
2.速度快
Scala语言表达能力强，一行代码抵得上java多行，开发速度快，scala是静态编译的，所以和JRuby，Groovy比起来速度会快很多" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/b5e96ee79d148c89553d52b44aace255/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-15T16:20:08+08:00" />
<meta property="article:modified_time" content="2023-03-15T16:20:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Scala学习（基础篇）待更新</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">引言</a></li><li><ul><li><a href="#_3" rel="nofollow">大数据介绍</a></li><li><a href="#_5" rel="nofollow">大数据与云计算区别</a></li><li><a href="#_7" rel="nofollow">大数据和人工智能的区别</a></li><li><a href="#excel_10" rel="nofollow">大数据和传统的分析（excel）的区别</a></li><li><a href="#scala_13" rel="nofollow">scala的特性</a></li><li><ul><li><a href="#_14" rel="nofollow">面向对象特性</a></li><li><a href="#_18" rel="nofollow">函数式编程</a></li><li><a href="#_24" rel="nofollow">函数式编程的特点：</a></li><li><a href="#_32" rel="nofollow">函数式编程的优势</a></li><li><a href="#_39" rel="nofollow">静态类型</a></li><li><a href="#_52" rel="nofollow">扩展性</a></li><li><a href="#_58" rel="nofollow">并发性</a></li></ul> 
    </li><li><a href="#scala_60" rel="nofollow">为什么要学scala</a></li><li><a href="#scala_71" rel="nofollow">scala安装</a></li><li><a href="#_74" rel="nofollow">简单测试</a></li><li><a href="#Scala_80" rel="nofollow">了解Scala</a></li><li><ul><li><a href="#Scala_81" rel="nofollow">Scala来源</a></li></ul> 
    </li><li><a href="#Scala_100" rel="nofollow">Scala解释器</a></li><li><a href="#Scala_109" rel="nofollow">Scala集成环境配置</a></li><li><a href="#_118" rel="nofollow">命名规范</a></li><li><a href="#Scala_122" rel="nofollow">Scala基本语法</a></li><li><ul><li><a href="#_143" rel="nofollow">换行符</a></li><li><a href="#Scala__149" rel="nofollow">Scala 包</a></li><li><ul><li><a href="#_150" rel="nofollow">定义包</a></li><li><a href="#_167" rel="nofollow">引用</a></li></ul> 
    </li></ul> 
    </li><li><a href="#Scala__193" rel="nofollow">Scala 数据类型</a></li><li><ul><li><a href="#Scala__228" rel="nofollow">Scala 基础字面量</a></li><li><a href="#Scala__290" rel="nofollow">Scala 转义字符</a></li></ul> 
    </li><li><a href="#Scala_305" rel="nofollow">Scala变量</a></li><li><ul><li><a href="#_337" rel="nofollow">变量类型声明</a></li><li><a href="#_347" rel="nofollow">变量推断</a></li><li><a href="#Scala__359" rel="nofollow">Scala 多个变量声明</a></li><li><a href="#_419" rel="nofollow">其他类型</a></li><li><a href="#varval_463" rel="nofollow">var和val的区别</a></li><li><a href="#_472" rel="nofollow">可变和不可变？</a></li></ul> 
    </li><li><a href="#Mavenscala_476" rel="nofollow">Maven项目整合scala</a></li><li><a href="#Scala_485" rel="nofollow">Scala类型转换</a></li><li><a href="#Scala_514" rel="nofollow">Scala访问修饰符</a></li><li><ul><li><a href="#Private_521" rel="nofollow">私有(Private)成员</a></li><li><a href="#Protected_540" rel="nofollow">保护(Protected)成员</a></li><li><a href="#Public_558" rel="nofollow">公共(Public)成员</a></li></ul> 
    </li><li><a href="#_572" rel="nofollow">作用域保护</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>引言</h3> 
<p><a href="https://www.bilibili.com/video/BV15t411H776?p=196" rel="nofollow">推荐学习视频</a></p> 
<h4><a id="_3"></a>大数据介绍</h4> 
<p>主要工作：数据统计分析（hadoop工程师、spark工程师、flink工程师、数仓工程师、BI工程师、ETL工程师 、大数据平台工程师）</p> 
<h4><a id="_5"></a>大数据与云计算区别</h4> 
<p>大数据可以做数据分析统计，而云计算可以为大数据提供一套资源利用的平台，因此大数据很多时候基于云计算。</p> 
<h4><a id="_7"></a>大数据和人工智能的区别</h4> 
<p>首先人工智能基于大数据，大数据为人工智能提供重要的海量数据</p> 
<h4><a id="excel_10"></a>大数据和传统的分析（excel）的区别</h4> 
<p>采用excel处理数据的方式早已不能承担海量数据的处理</p> 
<h4><a id="scala_13"></a>scala的特性</h4> 
<h5><a id="_14"></a>面向对象特性</h5> 
<p>Scala是一种纯面向对象的语言，每个值都是对象，包括基本数据类型（即布尔值、数字等）在内，当然函数也是对象。<br> 类可以被子类化，对象的数据类型以及行为由类和特质描述。<br> 类抽象机制的扩展有两种途径：一种途径是子类继承，另一种途径是灵活的混入机制。这两种途径能避免多重继承的种种问题。</p> 
<h5><a id="_18"></a>函数式编程</h5> 
<p>Scala也是一种函数式语言，其函数也能当成值来使用。Scala提供了轻量级的语法用以定义匿名函数，支持高阶函数，允许嵌套多层函数，并支持柯里化。Scala的case class及其内置的模式匹配相当于函数式编程语言中常用的代数类型。</p> 
<p>更进一步，程序员可以利用Scala的模式匹配，编写类似正则表达式的代码处理XML数据。</p> 
<p>纯粹的函数编程语言编写的函数没有变量。因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可有得到不同的输出，因此，这种函数式有副作用的。</p> 
<h5><a id="_24"></a>函数式编程的特点：</h5> 
<p>函数是一等公民<br> 以表达式为中心<br> 无副作用</p> 
<pre><code>只用纯函数来构造函程序，或者说函数没有副作用。
</code></pre> 
<p>不修改状态<br> 引用透明</p> 
<h5><a id="_32"></a>函数式编程的优势</h5> 
<p>代码简洁，开发速度快<br> 接近自然语言，易理解<br> 易于代码管理<br> 适合并发编程<br> 适用于热升级</p> 
<h5><a id="_39"></a>静态类型</h5> 
<p>Scala具备类型系统，通过编译时检查，保证代码的安全性和一致性。类型系统具体支持以下特性：</p> 
<blockquote> 
 <p>泛型类<br> 协变和逆变<br> 标注<br> 类型参数的上下限约束<br> 把类别和抽象类型作为对象成员<br> 复合类型<br> 引用自己时显式指定类型<br> 视图<br> 多态方法</p> 
</blockquote> 
<h5><a id="_52"></a>扩展性</h5> 
<p>Scala的设计秉承一项事实，即在实践中，某个领域特定的应用程序开发往往需要特定于该领域的语言扩展。Scala提供了许多独特的语言机制，可以以库的形式轻易无缝添加新的语言结构：</p> 
<p>任何方法可用作前缀或后缀操作符。<br> 可以根据预期类型自动构造闭包。</p> 
<h5><a id="_58"></a>并发性</h5> 
<p>Scala使用Actor作为其并发模型，Actor是类似线程的实体，通过邮箱发收消息。Actor可以复用线程，因此可以在程序中可以使用数百万个Actor,而线程只能创建数千个。在2.10之后的版本中，使用Akka作为其默认Actor实现。</p> 
<h4><a id="scala_60"></a>为什么要学scala</h4> 
<p>1.优雅<br> 框架的而用户是应用开发程序员，API是否优雅直接影响用户体验</p> 
<p>2.速度快<br> Scala语言表达能力强，一行代码抵得上java多行，开发速度快，scala是静态编译的，所以和JRuby，Groovy比起来速度会快很多</p> 
<p>3.能融合到Hadoop生态圈<br> Hadoop现在是大数据实施标准，Spark并不是要取代Hadoop，而是要完善Hadoop生态。<br> JVM语言大部分可能会想到Java，但java做出来的API太丑，或者想实现一个优雅的API太费劲</p> 
<h4><a id="scala_71"></a>scala安装</h4> 
<p><a href="https://blog.csdn.net/yilulvxing/article/details/89473522">安装参考</a></p> 
<h4><a id="_74"></a>简单测试</h4> 
<pre><code class="prism language-scala"><span class="token keyword">var</span> a <span class="token operator">=</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">20</span>
</code></pre> 
<p>可以看出scala是一种弱类型语言</p> 
<h4><a id="Scala_80"></a>了解Scala</h4> 
<h5><a id="Scala_81"></a>Scala来源</h5> 
<p>Scala 是 Scalable Language 的简写，是一门多范式的编程语言</p> 
<p>联邦理工学院洛桑（EPFL）的Martin Odersky于2001年基于Funnel的工作开始设计Scala。</p> 
<p>Funnel是把函数式编程思想和Petri网相结合的一种编程语言。</p> 
<p>Odersky先前的工作是Generic Java和javac（Sun Java编译器）。Java平台的Scala于2003年底/2004年初发布。.NET平台的Scala发布于2004年6月。该语言第二个版本，v2.0，发布于2006年3月。</p> 
<p>截至2009年9月，最新版本是版本2.7.6 。Scala 2.8预计的特性包括重写的Scala类库（Scala collections library）、方法的命名参数和默认参数、包对象（package object），以及Continuation。</p> 
<p>2009年4月，Twitter宣布他们已经把大部分后端程序从Ruby迁移到Scala，其余部分也打算要迁移。此外， Wattzon已经公开宣称，其整个平台都已经是基于Scala基础设施编写的。</p> 
<p>Scala的预期目标是将面向对象、函数式编程和强大的类型系统结合起来，同时让人能写出优雅、简介的代码。</p> 
<p>Scala博采众长，Scala采用了Java和C#语法的大部分，而他们大部分借自于C，C++语法。表达式、语句和代码块和Java一样，还有类、包和引用的语法。除语法之外，Scala还采用了java的其他元素，如他的基本类型、类库和它的执行模式。<br> 函数式编程借鉴了SML，OCaml，和F#为代表的ML家族语言很接近，Scala的隐式参数灵感来自Haskell,基于actor的并发库来自EeLang的思想。</p> 
<h4><a id="Scala_100"></a>Scala解释器</h4> 
<p><img src="https://images2.imgbox.com/4b/84/0WlcR9CB_o.png" alt="在这里插入图片描述">REPL：Read（取值）-&gt;Evaluation（求值）-&gt;Printf(打印)-&gt; Loop(循环)。<br> scala解释器被称为REPL，会快速编译scala代码为字节码，然后交给JVM来执行。<br> 1.计算表达式<br> 2.内置变量<br> 3.自动补全：<br> 在scala&gt;命令行内，可以使用Tab键进行自动补全<br> 例如：输入a.to，按tab键，解析器会显示出一下选项，tocharArray，toLowerCase，toString，toUpperCase。</p> 
<h4><a id="Scala_109"></a>Scala集成环境配置</h4> 
<p>Scala的开发工具分两种：<br> Eclispe 和Idea<br> 安装方式：<br> 在线和离线</p> 
<p>idea在线方式介绍：<br> File-&gt;Settings-&gt;Plugins-&gt;输入"Scala"<br> <img src="https://images2.imgbox.com/f8/b8/FeOkfDHF_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_118"></a>命名规范</h4> 
<p>基本原则：驼峰命名，命名有业务含义。<br> var|val orderName=“name”</p> 
<h4><a id="Scala_122"></a>Scala基本语法</h4> 
<p>Scala 基本语法需要注意以下几点：</p> 
<p>区分大小写 - Scala是大小写敏感的，这意味着标识Hello 和 hello在Scala中会有不同的含义。</p> 
<p>类名 - 对于所有的类名的第一个字母要大写。<br> 如果需要使用几个单词来构成一个类的名称，每个单词的第一个字母要大写。</p> 
<p>示例：<code>class MyFirstScalaClass</code></p> 
<p>方法名称 - 所有的方法名称的第一个字母用小写。<br> 如果若干单词被用于构成方法的名称，则每个单词的第一个字母应大写。</p> 
<p>示例：<code>def myMethodName()</code></p> 
<p>程序文件名 - 程序文件的名称应该与对象名称完全匹配(新版本不需要了，但建议保留这种习惯)。<br> 保存文件时，应该保存它使用的对象名称（记住Scala是区分大小写），并追加".scala"为文件扩展名。 （如果文件名和对象名称不匹配，程序将无法编译）。</p> 
<p>示例: 假设"HelloWorld"是对象的名称。那么该文件应保存为’HelloWorld.scala"</p> 
<p>def main(args: Array[String]) - Scala程序从main()方法开始处理，这是每一个Scala程序的强制程序入口部分。</p> 
<h5><a id="_143"></a>换行符</h5> 
<p>Scala是面向行的语言，语句可以用分号（;）结束或换行符。Scala 程序里,语句末尾的分号通常是可选的。如果你愿意可以输入一个,但若一行里仅 有一个语句也可不写。另一方面,如果一行里写多个语句那么分号是需要的。例如</p> 
<pre><code class="prism language-scala"><span class="token keyword">val</span> s <span class="token operator">=</span> <span class="token string">"you are a dog！"</span><span class="token punctuation">;</span> println<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
</code></pre> 
<h5><a id="Scala__149"></a>Scala 包</h5> 
<h6><a id="_150"></a>定义包</h6> 
<p>Scala 使用 package 关键字定义包，在Scala将代码定义到某个包中有两种方式：</p> 
<p>第一种方法和 Java 一样，在文件的头定义包名，这种方法就后续所有代码都放在该包中。 比如：</p> 
<pre><code class="prism language-scala"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>org<span class="token punctuation">.</span>analysis</span>
<span class="token keyword">class</span> HelloWorld
</code></pre> 
<p>第二种方法有些类似 C#，如：</p> 
<pre><code class="prism language-scala"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>org<span class="token punctuation">.</span>analysis</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">class</span> HelloWorld 
<span class="token punctuation">}</span>
</code></pre> 
<p>第二种方法，可以在一个文件中定义多个包</p> 
<h6><a id="_167"></a>引用</h6> 
<p>Scala 使用 import 关键字引用包</p> 
<pre><code class="prism language-scala"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>awt<span class="token punctuation">.</span></span>Color  <span class="token comment">// 引入Color</span>
 
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>awt<span class="token punctuation">.</span></span>_  <span class="token comment">// 引入包内所有成员</span>
 
<span class="token keyword">def</span> handler<span class="token punctuation">(</span>evt<span class="token operator">:</span> event<span class="token punctuation">.</span>ActionEvent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// java.awt.event.ActionEvent</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// 因为引入了java.awt，所以可以省去前面的部分</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>import语句可以出现在任何地方，而不是只能在文件顶部。import的效果从开始延伸到语句块的结束。这可以大幅减少名称冲突的可能性。</p> 
<p>如果想要引入包中的几个成员，可以使用selector（选取器）：</p> 
<pre><code class="prism language-scala"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>awt<span class="token punctuation">.</span></span><span class="token punctuation">{<!-- --></span>Color<span class="token punctuation">,</span> Font<span class="token punctuation">}</span>
 
<span class="token comment">// 重命名成员</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token punctuation">{<!-- --></span>HashMap <span class="token keyword">=&gt;</span> JavaHashMap<span class="token punctuation">}</span>
 
<span class="token comment">// 隐藏成员</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token punctuation">{<!-- --></span>HashMap <span class="token keyword">=&gt;</span> _<span class="token punctuation">,</span> _<span class="token punctuation">}</span> <span class="token comment">// 引入了util包的所有成员，但是HashMap被隐藏了</span>
</code></pre> 
<p><font color="red">注意：默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._，这里也能解释，为什么以scala开头的包，在使用时都是省去scala.的。</font></p> 
<h4><a id="Scala__193"></a>Scala 数据类型</h4> 
<p><img src="https://images2.imgbox.com/3c/01/8b7wAnRe_o.png" alt="在这里插入图片描述"><br> 分为<strong>值类型</strong>和<strong>引用类型</strong></p> 
<p>scala中所有的值都有类型，包括数值和函数。</p> 
<blockquote> 
 <p>Unit是值类型，它只有一个实例对象</p> 
</blockquote> 
<blockquote> 
 <p>Nothing是所有类型的子类，它没有一个具体的实例对象，一个产能关键的应用如：抛出异常、程序exit、无限循环等。</p> 
</blockquote> 
<blockquote> 
 <p>Nothing是所有类型的子类，也是NULL的子类，Nothing没有对象，但是可以用来定义类型。例如：如果一个方法抛出异常，则异常的返回值类型就是Nothing（虽然不会返回）</p> 
</blockquote> 
<blockquote> 
 <p>Null是所有引用类型的子类，它只有一个实例对象null，主要用来和其他的JVM语言进行互操作。</p> 
</blockquote> 
<p>Scala 与 Java有着相同的数据类型，下表列出了 Scala 支持的数据类型：</p> 
<table><thead><tr><th>Byte</th><th>8位有符号补码整数。数值区间为 -128 到 127</th></tr></thead><tbody><tr><td>Short</td><td>16位有符号补码整数。数值区间为 -32768 到 32767</td></tr><tr><td>Int</td><td>32位有符号补码整数。数值区间为 -2147483648 到 2147483647</td></tr><tr><td>Long</td><td>64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807</td></tr><tr><td>Float</td><td>32 位, IEEE 754 标准的单精度浮点数</td></tr><tr><td>Double</td><td>64 位 IEEE 754 标准的双精度浮点数</td></tr><tr><td>Char</td><td>16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF</td></tr><tr><td>String</td><td>字符序列</td></tr><tr><td>Boolean</td><td>true或false</td></tr><tr><td>Unit</td><td>表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。</td></tr><tr><td>Null</td><td>null 或空引用</td></tr><tr><td>Nothing</td><td>Nothing类型在Scala的类层级的最底端；它是任何其他类型的子类型。</td></tr><tr><td>Any</td><td>Any是所有其他类的超类</td></tr><tr><td>AnyRef</td><td>AnyRef类是Scala里所有引用类(reference class)的基类</td></tr></tbody></table> 
<p>提示：<br> 和java不同的是，scala没有基本类型和包装类型之分，这些类型都是类，有自己的属性和方法。</p> 
<h5><a id="Scala__228"></a>Scala 基础字面量</h5> 
<p>Scala 非常简单且直观。接下来我们会详细介绍 Scala 字面量。<br> 整型字面量<br> 整型字面量用于 Int 类型，如果表示 Long，可以在数字后面添加 L 或者小写 l 作为后缀。</p> 
<pre><code class="prism language-scala"><span class="token number">0777L</span>
</code></pre> 
<p>浮点型字面量<br> 如果浮点数后面有f或者F后缀时，表示这是一个Float类型，否则就是一个Double类型的。实例如下：</p> 
<pre><code class="prism language-scala"><span class="token number">0.0</span> 
<span class="token number">1e30f</span> 
<span class="token number">3.14159f</span> 
<span class="token number">1.0e100</span>
<span class="token number">.1</span>
</code></pre> 
<p>布尔型字面量<br> 布尔型字面量有 true 和 false。</p> 
<p>符号字面量<br> 符号字面量被写成： '&lt;标识符&gt; ，这里 &lt;标识符&gt; 可以是任何字母或数字的标识（注意：不能以数字开头）。这种字面量被映射成预定义类scala.Symbol的实例。</p> 
<p>如： 符号字面量 'x 是表达式 scala.Symbol(“x”) 的简写，符号字面量定义如下：</p> 
<pre><code class="prism language-scala"><span class="token keyword">package</span> <span class="token namespace">scala</span>
<span class="token keyword">final</span> <span class="token keyword">case</span> <span class="token keyword">class</span> Symbol <span class="token keyword">private</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">override</span> <span class="token keyword">def</span> toString<span class="token operator">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token string">"'"</span> <span class="token operator">+</span> name
<span class="token punctuation">}</span>
</code></pre> 
<p>字符字面量<br> 在 Scala 字符变量使用单引号 ’ 来定义，如下：</p> 
<pre><code class="prism language-scala"><span class="token char">'a'</span> 
<span class="token char">'\u0041'</span>
<span class="token char">'\n'</span>
</code></pre> 
<p>其中 \ 表示转义字符，其后可以跟 u0041 数字或者 \r\n 等固定的转义字符。<br> 字符串字面量<br> 在 Scala 字符串字面量使用双引号 " 来定义，如下：</p> 
<pre><code class="prism language-scala"><span class="token string">"Hello,\nWorld!"</span>
</code></pre> 
<p>多行字符串的表示方法<br> 多行字符串用三个双引号来表示分隔符，格式为：“”" … “”"。<br> 实例如下：</p> 
<pre><code class="prism language-scala"><span class="token keyword">val</span> foo <span class="token operator">=</span> <span class="token triple-quoted-string string">"""锋芒极客
www.baidu.com
www.w3cschool.cc
www.pc.qq.com
以上三个地址都能访问"""</span>
</code></pre> 
<p>Null 值<br> 空值是 scala.Null 类型。<br> Scala.Null和scala.Nothing是用统一的方式处理Scala面向对象类型系统的某些"边界情况"的特殊类型。<br> Null类是null引用对象的类型，它是每个引用类（继承自AnyRef的类）的子类。Null不兼容值类型。</p> 
<h5><a id="Scala__290"></a>Scala 转义字符</h5> 
<p>下表列出了常见的转义字符：</p> 
<table><thead><tr><th>转义字符</th><th>Unicode</th><th>描述</th></tr></thead><tbody><tr><td>\b</td><td>\u0008</td><td>退格(BS) ，将当前位置移到前一列</td></tr><tr><td>\t</td><td>\u0009</td><td>水平制表(HT) （跳到下一个TAB位置）</td></tr><tr><td>\n</td><td>\u000a</td><td>换行(LF) ，将当前位置移到下一行开头</td></tr><tr><td>\f</td><td>\u000c</td><td>换页(FF)，将当前位置移到下页开头</td></tr><tr><td>\r</td><td>\u000d</td><td>回车(CR) ，将当前位置移到本行开头</td></tr><tr><td>\ "</td><td>\u0022</td><td>代表一个双引号(")字符</td></tr><tr><td>\ ’</td><td>\u0027</td><td>代表一个双引号(")字符</td></tr><tr><td>\</td><td>\u005c</td><td>代表一个反斜线字符 ’ \ ’</td></tr></tbody></table> 
<p>0 到 255 间的 Unicode 字符可以用一个八进制转义序列来表示，即反斜线‟\‟后跟 最多三个八进制。</p> 
<h4><a id="Scala_305"></a>Scala变量</h4> 
<p>在学习如何声明变量与常量之前，我们先来了解一些变量与常量。<br> 变量： 在程序运行过程中其值可能发生改变的量叫做变量。如：时间，年龄。<br> 常量 在程序运行过程中其值不会发生变化的量叫做常量。如：数值 3，字符’A’。</p> 
<p>变量声明<br> 在 Scala 中，使用关键词 “var” 声明变量，使用关键词 “val” 声明常量。<br> 基本语法：</p> 
<pre><code class="prism language-scala"><span class="token keyword">var</span><span class="token operator">|</span><span class="token keyword">val</span> 变量名<span class="token punctuation">[</span><span class="token operator">:</span>变量类型<span class="token punctuation">]</span> <span class="token operator">=</span>变量值
</code></pre> 
<p>使用var 或val定义一个变量<br> 使用var（variable）声明变量-可以被重新赋值。<br> 使用val（value）声明常量-引用不可变<br> val修饰的变量，想当于java中final修饰的变量；</p> 
<p>声明变量实例如下：</p> 
<pre><code class="prism language-scala"><span class="token keyword">var</span> myVar <span class="token operator">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token string">"flag"</span>
<span class="token keyword">var</span> myVar <span class="token operator">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token string">"laughter"</span>
</code></pre> 
<p>以上定义了变量 myVar，我们可以修改它。<br> 声明常量实例如下：</p> 
<pre><code class="prism language-scala"><span class="token keyword">val</span> myVal <span class="token operator">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token string">"Foo"</span>
</code></pre> 
<p>以上定义了常量 myVal，它是不能修改的。如果程序尝试修改常量 myVal 的值，程序将会在编译时报错。</p> 
<h5><a id="_337"></a>变量类型声明</h5> 
<p>变量的类型在变量名之后等号之前声明。定义变量的类型的语法格式如下：</p> 
<pre><code class="prism language-scala"><span class="token keyword">var</span> VariableName <span class="token operator">:</span> DataType <span class="token punctuation">[</span><span class="token operator">=</span>  Initial Value<span class="token punctuation">]</span>

或

<span class="token keyword">val</span> VariableName <span class="token operator">:</span> DataType <span class="token punctuation">[</span><span class="token operator">=</span>  Initial Value<span class="token punctuation">]</span>
</code></pre> 
<h5><a id="_347"></a>变量推断</h5> 
<p>在 Scala 中声明变量和常量不一定要指明数据类型，在没有指明数据类型的情况下，其数据类型是通过变量或常量的初始值推断出来的。</p> 
<p>所以，如果在没有指明数据类型的情况下声明变量或常量必须要给出其初始值，否则将会报错。</p> 
<pre><code class="prism language-scala"><span class="token keyword">var</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">val</span> charact <span class="token operator">=</span> <span class="token string">"Hello, Scala!"</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上实例中，number 会被推断为 Int 类型，charact 会被推断为 String 类型。</p> 
<h5><a id="Scala__359"></a>Scala 多个变量声明</h5> 
<p>Scala 支持多个变量的声明：</p> 
<pre><code class="prism language-scala"><span class="token keyword">val</span> xmax<span class="token punctuation">,</span> ymax <span class="token operator">=</span> <span class="token number">100</span>  <span class="token comment">// xmax, ymax都声明为100</span>
</code></pre> 
<p>如果方法返回值是元组，我们可以使用 val 来声明一个元组：</p> 
<pre><code class="prism language-scala">scala<span class="token operator">&gt;</span> <span class="token keyword">val</span> pa <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token string">"try"</span><span class="token punctuation">)</span>
pa<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token keyword">try</span><span class="token punctuation">)</span>
</code></pre> 
<p>注意事项：<br> 1.变量名要使用字母或者下划线开始，不要使用数字、特殊符号开始<br> 2.变量名不建议使用关键字<br> 3.变量必须赋值（因为根据值来推断类型）<br> 4.声明变量时，可以不指定变量类型，编译器会根据赋值内容自动推断当前变量的类型。</p> 
<p>实例：</p> 
<pre><code class="prism language-scala"><span class="token keyword">package</span> <span class="token namespace">try_demo</span>

<span class="token keyword">object</span> var_demo <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">val</span> name<span class="token operator">:</span><span class="token builtin">String</span><span class="token operator">=</span><span class="token string">"try"</span>
    <span class="token keyword">var</span> password<span class="token operator">:</span><span class="token builtin">String</span><span class="token operator">=</span><span class="token string">"catch"</span><span class="token punctuation">;</span>
    <span class="token comment">//password="it";</span>
    println<span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//多个变量声明</span>
    <span class="token keyword">val</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"abc"</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> e<span class="token punctuation">,</span>f<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
    print<span class="token punctuation">(</span>a<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    println<span class="token punctuation">(</span>e<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//定义数组</span>
    <span class="token keyword">val</span> arr<span class="token operator">=</span>Array<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span>
    println<span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
    <span class="token keyword">val</span> flag<span class="token operator">:</span><span class="token builtin">Boolean</span><span class="token operator">=</span><span class="token boolean">true</span>
    <span class="token keyword">val</span> money<span class="token operator">:</span><span class="token builtin">Double</span><span class="token operator">=</span><span class="token number">6666.66</span><span class="token punctuation">;</span>
    <span class="token keyword">val</span> salary<span class="token operator">=</span><span class="token number">99999.99</span> <span class="token comment">//推断类型</span>
      <span class="token comment">//定义带了类型的方法</span>
    <span class="token keyword">def</span> add<span class="token punctuation">(</span>a<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">,</span>b<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">Int</span><span class="token operator">=</span>a<span class="token operator">+</span>b<span class="token punctuation">;</span>
      <span class="token comment">//if</span>
     <span class="token keyword">val</span> res<span class="token operator">:</span><span class="token builtin">String</span><span class="token operator">=</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"false"</span> <span class="token keyword">else</span> <span class="token string">"true"</span>
      <span class="token comment">//Unit为空类型，相当于void，使用()进行初始化</span>
      
      <span class="token keyword">var</span> u<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      println<span class="token punctuation">(</span>u<span class="token punctuation">)</span>
      println<span class="token punctuation">(</span>flag<span class="token punctuation">)</span>
      println<span class="token punctuation">(</span>money<span class="token punctuation">)</span>
      println<span class="token punctuation">(</span>add<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_419"></a>其他类型</h5> 
<p>Any<br> Any可以接受任意的基本类型和引用类型</p> 
<pre><code class="prism language-scala">    <span class="token keyword">var</span> any<span class="token operator">:</span><span class="token builtin">Any</span><span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> anyR<span class="token operator">:</span><span class="token builtin">Int</span><span class="token operator">=</span><span class="token number">1</span>
    <span class="token keyword">var</span> anyv<span class="token operator">:</span><span class="token builtin">Int</span><span class="token operator">=</span><span class="token number">2</span>
    any<span class="token operator">=</span>anyR
    any<span class="token operator">=</span>anyv
</code></pre> 
<p>AnyRef<br> 使用AnyRef接收任意的引用类型</p> 
<pre><code class="prism language-scala"><span class="token keyword">var</span> anyR<span class="token operator">:</span><span class="token builtin">AnyRef</span><span class="token operator">=</span><span class="token keyword">null</span>
</code></pre> 
<p>AnyVal<br> 可以使用AnyVal接收任意的基本类型</p> 
<pre><code class="prism language-scala"><span class="token keyword">var</span> anyV<span class="token operator">:</span><span class="token builtin">AnyVal</span><span class="token operator">=</span>u <span class="token comment">//unit</span>
anyV<span class="token operator">=</span>b1   <span class="token comment">//Boolean</span>
anyV<span class="token operator">=</span>b    <span class="token comment">//Byte</span>
</code></pre> 
<p>Null<br> null值只能被推断为Null类型，null代表空值，可以被赋值给任何AnyRef类型的常量或变量</p> 
<p>Nothing<br> Nothing类型在Scala的类层级的最低端；它是任何其他类型的子类型。<br> 当一个函数，我们确定没有正常的返回值，可以用Nothing来指定返回的类型，这样有一个好处，就是我们可以把返回的值(异常)赋值给其他的函数或变量（兼容性）</p> 
<p>Option<br> Scala Option(选项)类型用来表示一个值是可选的（有值或无值）</p> 
<pre><code class="prism language-scala"> <span class="token keyword">val</span> myMap<span class="token operator">:</span>Map<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">,</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token operator">=</span>Map<span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token operator">-&gt;</span><span class="token string">"value1"</span><span class="token punctuation">)</span>
 <span class="token keyword">val</span> value1<span class="token operator">:</span>Option<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token operator">=</span>myMap<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span>
 <span class="token keyword">val</span> value2<span class="token operator">:</span>Option<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token operator">=</span>myMap<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"key2"</span><span class="token punctuation">)</span>
 println<span class="token punctuation">(</span>value1<span class="token punctuation">)</span>   <span class="token comment">//Some("value1")</span>
 println<span class="token punctuation">(</span>value2<span class="token punctuation">)</span>  <span class="token comment">//None</span>
 println<span class="token punctuation">(</span>value1<span class="token punctuation">.</span>get<span class="token punctuation">)</span>
</code></pre> 
<h5><a id="varval_463"></a>var和val的区别</h5> 
<p>1.内容是和否不变<br> 2.val修饰的变量在编译后，等同于加上final<br> 3.val修饰的变量可以用lazy修饰，而var不能，使用lazy定义变量后，只有在调用该变量时才会实例化这个变量的值。而且惰性变量只能是不可变变量</p> 
<pre><code class="prism language-scala"><span class="token comment">//lazy修饰val的变量，表示懒加载；var不行</span>
<span class="token keyword">lazy</span> <span class="token keyword">val</span> age<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="_472"></a>可变和不可变？</h5> 
<p>可变和不可变，指的的是变量本身存的内容，值类型变量存的是数据本身，变量存的是数据的引用。</p> 
<h4><a id="Mavenscala_476"></a>Maven项目整合scala</h4> 
<p><img src="https://images2.imgbox.com/58/ea/ZbYp0O9d_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/75/2c/1Pfh6hCt_o.png" alt="在这里插入图片描述"><br> 发现不能创建类，需要修改目录的标注：<br> <img src="https://images2.imgbox.com/e2/58/IRlwhI6i_o.png" alt="在这里插入图片描述"><br> 然后发现只能创.java的类，不能创建.scala类，将scala的sdk绑定到我们的项目：<br> <img src="https://images2.imgbox.com/bd/1e/B2K81UKM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3f/86/BqkCPDU3_o.png" alt="在这里插入图片描述"><br> 点击OK</p> 
<h4><a id="Scala_485"></a>Scala类型转换</h4> 
<p><img src="https://images2.imgbox.com/52/a1/1jU4N0ob_o.png" alt="在这里插入图片描述"><br> 自动类型转换<br> 允许低类型的向高类型的转换</p> 
<pre><code class="prism language-scala">    <span class="token keyword">val</span> test1<span class="token operator">:</span><span class="token builtin">String</span><span class="token operator">=</span><span class="token string">"67"</span>
    <span class="token keyword">val</span> b<span class="token operator">=</span>test1<span class="token punctuation">.</span>toInt
    println<span class="token punctuation">(</span>b<span class="token punctuation">)</span>

    <span class="token keyword">val</span> c<span class="token operator">:</span><span class="token builtin">Int</span><span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">val</span> d<span class="token operator">:</span><span class="token builtin">Long</span><span class="token operator">=</span>c
    println<span class="token punctuation">(</span>d<span class="token punctuation">)</span>

    <span class="token keyword">val</span> ch<span class="token operator">:</span><span class="token builtin">Char</span><span class="token operator">=</span><span class="token char">'0'</span>
    <span class="token keyword">val</span> ch1<span class="token operator">:</span><span class="token builtin">Int</span><span class="token operator">=</span>ch
    println<span class="token punctuation">(</span>ch1<span class="token punctuation">)</span>

    <span class="token comment">/*定义double*/</span>
    <span class="token keyword">val</span> test2<span class="token operator">:</span><span class="token builtin">Double</span><span class="token operator">=</span><span class="token number">1111.111</span>
    <span class="token keyword">val</span> k<span class="token operator">:</span><span class="token builtin">Int</span><span class="token operator">=</span>test2<span class="token punctuation">.</span>toInt
    println<span class="token punctuation">(</span>k<span class="token punctuation">)</span>
</code></pre> 
<p>提示：<br> 1.scala没有像Java一样的强制类型转换<br> 2.自动转时，要求小类型向高类型转换<br> 3.高级类型向低级类型转换的时候需要使用富类型（当前类型中的toInt（）等）</p> 
<h4><a id="Scala_514"></a>Scala访问修饰符</h4> 
<p>Scala 访问修饰符基本和Java的一样，分别有：private，protected，public。</p> 
<p>如果没有指定访问修饰符，默认情况下，Scala 对象的访问级别都是 public。</p> 
<p>Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。</p> 
<h5><a id="Private_521"></a>私有(Private)成员</h5> 
<p>用 private 关键字修饰，带有此标记的成员仅在包含了成员定义的类或对象内部可见，同样的规则还适用内部类。</p> 
<pre><code class="prism language-scala"><span class="token keyword">class</span> Outer<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token keyword">try</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">def</span> f<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    		println<span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token keyword">class</span> InnerMost<span class="token punctuation">{<!-- --></span>
        f<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 正确</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">try</span><span class="token punctuation">)</span><span class="token punctuation">.</span>f<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//错误</span>
<span class="token punctuation">}</span>
<span class="token comment">//(new try).f( ) 访问不合法是因为 f 在 try 中被声明为 private，而访问不在类 try 之内。</span>
<span class="token comment">//但在 InnerMost 里访问 f 就没有问题的，因为这个访问包含在 Inner 类之内。</span>

Java中允许这两种访问，因为它允许外部类访问内部类的私有成员。
</code></pre> 
<h5><a id="Protected_540"></a>保护(Protected)成员</h5> 
<p>在 scala 中，对保护（Protected）成员的访问比 java 更严格一些。因为它只允许保护成员在定义了该成员的的类的子类中被访问。而在java中，用protected关键字修饰的成员，除了定义了该成员的类的子类可以访问，同一个包里的其他类也可以进行访问。</p> 
<pre><code class="prism language-scala"><span class="token keyword">package</span> <span class="token namespace">p</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">class</span> Super<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">protected</span> <span class="token keyword">def</span> f<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>println<span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
        <span class="token keyword">class</span> Sub <span class="token keyword">extends</span> Super<span class="token punctuation">{<!-- --></span>
            f<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">class</span> Other<span class="token punctuation">{<!-- --></span>
                <span class="token punctuation">(</span><span class="token keyword">new</span> Super<span class="token punctuation">)</span><span class="token punctuation">.</span>f<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//错误</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>Sub 类对 f 的访问没有问题，因为 f 在 Super 中被声明为 protected，而 Sub 是 Super 的子类。相反，Other 对 f 的访问不被允许，因为 other 没有继承自 Super。而后者在 java 里同样被认可，因为 Other 与 Sub 在同一包里。</p> 
<h5><a id="Public_558"></a>公共(Public)成员</h5> 
<p>Scala 中，如果没有指定任何的修饰符，则默认为 public。这样的成员在任何地方都可以被访问。</p> 
<pre><code class="prism language-scala"><span class="token keyword">class</span> Outer <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">class</span> <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">def</span> f<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> println<span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
      <span class="token keyword">class</span> InnerMost <span class="token punctuation">{<!-- --></span>
         f<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 正确</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">try</span><span class="token punctuation">)</span><span class="token punctuation">.</span>f<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 正确因为 f() 是 public</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_572"></a>作用域保护</h4> 
<p>Scala中，访问修饰符可以通过使用限定词强调。格式为:</p> 
<pre><code class="prism language-scala"><span class="token keyword">private</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span>  
<span class="token keyword">protected</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span>
</code></pre> 
<p>这里的x指代某个所属的包、类或单例对象。如果写成private[x],读作"这个成员除了对[…]中的类或[…]中的包中的类及它们的伴生对像可见外，对其它所有类都是private。</p> 
<pre><code class="prism language-scala"><span class="token keyword">package</span> <span class="token namespace">bobsrockets</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">package</span> <span class="token namespace">navigation</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span><span class="token punctuation">[</span>bobsrockets<span class="token punctuation">]</span> <span class="token keyword">class</span> Navigator<span class="token punctuation">{<!-- --></span>
         <span class="token keyword">protected</span><span class="token punctuation">[</span>navigation<span class="token punctuation">]</span> <span class="token keyword">def</span> useStarChart<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
         <span class="token keyword">class</span> LegOfJourney<span class="token punctuation">{<!-- --></span>
             <span class="token keyword">private</span><span class="token punctuation">[</span>Navigator<span class="token punctuation">]</span> <span class="token keyword">val</span> distance <span class="token operator">=</span> <span class="token number">100</span>
             <span class="token punctuation">}</span>
            <span class="token keyword">private</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token keyword">var</span> speed <span class="token operator">=</span> <span class="token number">200</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">package</span> <span class="token namespace">launch</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">import</span> <span class="token namespace">navigation<span class="token punctuation">.</span></span>_
        <span class="token keyword">object</span> Vehicle<span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span><span class="token punctuation">[</span>launch<span class="token punctuation">]</span> <span class="token keyword">val</span> guide <span class="token operator">=</span> <span class="token keyword">new</span> Navigator
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述例子中，类 Navigator 被标记为 private[bobsrockets] 就是说这个类对包含在 bobsrockets 包里的所有的类和对象可见。</p> 
<p>比如说，从 Vehicle 对象里对 Navigator 的访问是被允许的，因为对象 Vehicle 包含在包 launch 中，而 launch 包在 bobsrockets 中，相反，所有在包 bobsrockets 之外的代码都不能访问类 Navigator。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e3789825d8cb160f7485d1e1a2e7e61f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DockerCompose构建Spring Boot项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b50aad294b53e64973bfde9c1056a794/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MapReduce综合学习（含Word Count案例）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>