<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Makefile模板以及多层Makefile编译(附源码) - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Makefile模板以及多层Makefile编译(附源码)" />
<meta property="og:description" content="本文将介绍几个Makefile模板：编译可执行程序、编译静态库、编译动态库。以及简单地介绍在项目工程多目录下多层Makefile如何编译
关于Makefile的介绍，欢迎查阅之前发过的文章，认识Makefile以及基础知识 和 Linux库概念、静态库、动态库
1、前言 现在很多IDE都集成了编译器，如Visual Studio等等，点击相关的编译按钮的一个操作即可完成编译、链接、生成目标文件。
在Linux系统下，开发并编译程序一般用的gcc/g&#43;&#43;编译器，如果是开发ARM架构环境下的Linux程序，还需用到arm-linux-gcc/arm-linux-g&#43;&#43;交叉编译器。
其实Linux下也可以实现“一键编译”功能，特别是在大工程项目下，此时需要借助Makefile，一个命令就完成编译、链接、生成目标文件就显得很有用处了。Makefile可以手动编写，也可以借助自动化构建工具（如scons、CMake、autotools等）生成。一般地一个通用的Makefile能够适合大部分Linux项目程序。
2、Makefile工程管理 工程管理器，顾名思义，是指管理较多的文件 Make工程管理器也就是个“自动编译管理器”，这里的“自动”是指它能构根据文件时间戳自动发现更新过的文件而减少编译的工作量，同时，它通过读入Makefile文件文件的内容来执行大量的编译工作。
在一个makefile中通常包含如下内容：
需要由make工具创建的目标体（target），通常是目标文件或可执行文件；
要创建的目标体所依赖的文件（dependency_file）;
创建每个目标体时需要运行的命令（command），这一行必须以制表符（tab键）开头。
makefile格式 target: dependency_files &lt;TAB&gt;command #该行必须以tab键开头 3、Makefile模板 3.1 使用Makefile编译可执行文件 PROJECT_ROOT_PATH = /home/yimning/MakefileTemplate VERSION = 1.0.0 CC = gcc DEBUG = -DUSE_DEBUG CFLAGS = -Wall SOURCES = $(wildcard *.c) INCLUDES = -I../../include #LIB_NAMES =-lfun_a -lfun_so	# 如果使用到相关库，可添加。若没有就注释该行。 LIB_NAMES = -lfoo -lbar # 比如我这里分别使用了静态库libfoo.a.1.0.0和libbar.so.1.0.0(已放到了/lib下) LIB_PATH = -L./lib	#使用到库的路径，一般放于/lib或在/usr/lib目录下 OBJ = $(patsubst %.c, %.o, $(SOURCES)) TARGET = app #links $(TARGET):$(OBJ) @mkdir -p output $(CC) $(OBJ) $(LIB_PATH) $(LIB_NAMES) -o output/$(TARGET)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/d8e7a766c72ad834dd6aaf381ee6bc79/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-03T15:56:48+08:00" />
<meta property="article:modified_time" content="2022-08-03T15:56:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Makefile模板以及多层Makefile编译(附源码)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文将介绍几个Makefile模板：编译可执行程序、编译静态库、编译动态库。以及简单地介绍在项目工程多目录下多层Makefile如何编译</p> 
<p>关于Makefile的介绍，欢迎查阅之前发过的文章，<a href="https://mp.weixin.qq.com/s?__biz=Mzg4MDgyNDM4Mw==&amp;mid=2247483770&amp;idx=1&amp;sn=3bc8eb996905f1d15400528ad1e15207&amp;chksm=cf6e182af819913ca7a75dc00898b69eadce60583363cd320b24c08d33ebc53c4fa0982e8526&amp;token=698406402&amp;lang=zh_CN#rd" rel="nofollow">认识Makefile以及基础知识</a> 和 <a href="https://mp.weixin.qq.com/s?__biz=Mzg4MDgyNDM4Mw==&amp;mid=2247484116&amp;idx=1&amp;sn=e757cd2b8b067f82af9f0f723378977e&amp;chksm=cf6e1b84f81992928dceff7cd619b543b8403907df0ad216eed7f269db3e679e87d601cf8dbe&amp;token=1695839983&amp;lang=zh_CN#rd" rel="nofollow">Linux库概念、静态库、动态库</a></p> 
<h2><a id="1_4"></a>1、前言</h2> 
<p> 现在很多IDE都集成了编译器，如Visual Studio等等，点击相关的编译按钮的一个操作即可完成编译、链接、生成目标文件。</p> 
<p> 在Linux系统下，开发并编译程序一般用的gcc/g++编译器，如果是开发ARM架构环境下的Linux程序，还需用到arm-linux-gcc/arm-linux-g++交叉编译器。</p> 
<p> 其实Linux下也可以实现“一键编译”功能，特别是在大工程项目下，此时需要借助Makefile，一个命令就完成编译、链接、生成目标文件就显得很有用处了。Makefile可以手动编写，也可以借助自动化构建工具（如scons、CMake、autotools等）生成。一般地一个通用的Makefile能够适合大部分Linux项目程序。</p> 
<h2><a id="2Makefile_10"></a>2、Makefile工程管理</h2> 
<p> 工程管理器，顾名思义，是指管理较多的文件 Make工程管理器也就是个“自动编译管理器”，这里的“自动”是指它能构根据文件时间戳自动发现更新过的文件而减少编译的工作量，同时，它通过读入Makefile文件文件的内容来执行大量的编译工作。<br>  在一个makefile中通常包含如下内容：<br><br>   需要由make工具创建的目标体（target），通常是目标文件或可执行文件；<br><br>   要创建的目标体所依赖的文件（dependency_file）;<br><br>   创建每个目标体时需要运行的命令（command），这一行必须以制表符（tab键）开头。</p> 
<h3><a id="makefile_16"></a>makefile格式</h3> 
<pre><code class="prism language-shell">target: dependency_files
  <span class="token operator">&lt;</span>TAB<span class="token operator">&gt;</span>command      <span class="token comment">#该行必须以tab键开头</span>
</code></pre> 
<h2><a id="3Makefile_21"></a>3、Makefile模板</h2> 
<h3><a id="31_Makefile_22"></a>3.1 使用Makefile编译可执行文件</h3> 
<pre><code class="prism language-shell">PROJECT_ROOT_PATH <span class="token operator">=</span> /home/yimning/MakefileTemplate
VERSION     <span class="token operator">=</span> <span class="token number">1.0</span>.0

CC   <span class="token operator">=</span>  gcc
DEBUG   <span class="token operator">=</span>  -DUSE_DEBUG
CFLAGS  <span class="token operator">=</span>  -Wall
SOURCES   <span class="token operator">=</span>  <span class="token variable"><span class="token variable">$(</span>wildcard *.c<span class="token variable">)</span></span>
INCLUDES   <span class="token operator">=</span>  -I<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/include
<span class="token comment">#LIB_NAMES  =-lfun_a -lfun_so	# 如果使用到相关库，可添加。若没有就注释该行。</span>
LIB_NAMES  <span class="token operator">=</span>  -lfoo -lbar      <span class="token comment"># 比如我这里分别使用了静态库libfoo.a.1.0.0和libbar.so.1.0.0(已放到了/lib下)</span>
LIB_PATH  <span class="token operator">=</span>  -L./lib		  <span class="token comment">#使用到库的路径，一般放于/lib或在/usr/lib目录下 </span>
OBJ   <span class="token operator">=</span>  <span class="token variable"><span class="token variable">$(</span>patsubst %.c, %.o, <span class="token punctuation">$(</span>SOURCES<span class="token punctuation">)</span><span class="token variable">)</span></span>
TARGET  <span class="token operator">=</span>  app

<span class="token comment">#links</span>
<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span>
	@mkdir -p output
	<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_PATH<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_NAMES<span class="token variable">)</span></span> -o output/<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>
	@rm -rf <span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span>
 
<span class="token comment">#compile</span>
%.o: %.c
	<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>INCLUDES<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>DEBUG<span class="token variable">)</span></span> -c <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> $<span class="token operator">&lt;</span> -o <span class="token variable">$@</span>

.PHONY:clean
clean:
	@echo <span class="token string">"Remove linked and compiled files......"</span>
	<span class="token function">rm</span> -rf <span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span> output 
</code></pre> 
<p>本文将使用到的项目目录如下图所示：<br> <img src="https://images2.imgbox.com/67/ec/z7E2N2k6_o.png" alt=""></p> 
<h3><a id="_55"></a>【要点说明】</h3> 
<h4><a id="01_56"></a>(01)程序版本</h4> 
<p>开发调试过程可能产生多个程序版本，可以在目标文件后（前）增加版本号标识。如果不指定输出路径则会默认放到当前目录下。</p> 
<pre><code class="prism language-shell">VERSION     <span class="token operator">=</span> <span class="token number">1.0</span>.0
<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_PATH<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_NAMES<span class="token variable">)</span></span> -o output/<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>
</code></pre> 
<h4><a id="02_62"></a>(02)编译器选择</h4> 
<p>Linux下为gcc/g++；arm下为arm-linux-gcc；不同CPU厂商提供的定制交叉编译器名称可能不同，如使用“arm-linux-gnueabi-gcc”。</p> 
<pre><code class="prism language-shell">VERSION <span class="token operator">=</span> <span class="token number">1.00</span>
<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_PATH<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_NAMES<span class="token variable">)</span></span> -o output/<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>
CC <span class="token operator">=</span> gcc
</code></pre> 
<h4><a id="03_71"></a>(03)宏定义</h4> 
<p>开发过程中，特殊代码一般增加宏条件来选择是否编译，如调试打印输出代码。-D是标识，后面接着的是“宏”。</p> 
<pre><code class="prism language-shell">VERSION <span class="token operator">=</span> <span class="token number">1.0</span>.0
<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_PATH<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_NAMES<span class="token variable">)</span></span> -o output/<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>
DEBUG <span class="token operator">=</span> -DUSE_DEBUG
</code></pre> 
<h4><a id="04_78"></a>(04)编译选项</h4> 
<p>可以指定编译条件，如显示警告（-Wall），优化等级（-O）。</p> 
<pre><code class="prism language-shell">VERSION <span class="token operator">=</span> <span class="token number">1.0</span>.0
<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_PATH<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_NAMES<span class="token variable">)</span></span> -o output/<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>
CFLAGS <span class="token operator">=</span>  -Wall -O
</code></pre> 
<h4><a id="05_85"></a>(05)源文件</h4> 
<p>指定源文件目的路径(相对路径或者绝对路径)，利用“wildcard”获取路径下所有依赖源文件。</p> 
<pre><code class="prism language-shell">VERSION <span class="token operator">=</span> <span class="token number">1.0</span>.0
<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_PATH<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_NAMES<span class="token variable">)</span></span> -o output/<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>
SOURCES   <span class="token operator">=</span>  <span class="token variable"><span class="token variable">$(</span>wildcard *.c<span class="token variable">)</span></span>
</code></pre> 
<h4><a id="06_92"></a>(06)头文件</h4> 
<p>包含依赖的头文件，包括源码文件和库文件的头文件。</p> 
<pre><code class="prism language-shell">VERSION <span class="token operator">=</span> <span class="token number">1.0</span>.0
<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_PATH<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_NAMES<span class="token variable">)</span></span> -o output/<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>
INCLUDES   <span class="token operator">=</span>  -I<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/include
</code></pre> 
<h4><a id="07_99"></a>(07)库文件名称</h4> 
<p>指定库文件名称，库文件有固定格式，静态库为libxxx.a;动态库为libxxx.so，指定库文件名称只需写“xxx”部分，</p> 
<pre><code class="prism language-shell"><span class="token comment">#LIB_NAMES  =-lfun_a -lfun_so	# 如果使用到相关库，可添加。若没有就注释该行。</span>
LIB_NAMES  <span class="token operator">=</span>  -lfoo -lbar      <span class="token comment"># 比如我这里分别使用了静态库libfoo.a.1.0.0和libbar.so.1.0.0(默认已放到了/lib下)</span>
</code></pre> 
<h4><a id="08_105"></a>(08)库文件路径</h4> 
<p>指定依赖库文件的存放路径。注意如果引用的是动态库，动态库也许拷贝到“/lib”或者“/usr/lib”目录下，执行应用程序时，系统默认在该文件下索引动态库。</p> 
<pre><code class="prism language-shell">LIB_PATH  <span class="token operator">=</span>  -L./lib		  <span class="token comment">#使用到库的路径，一般放于/lib或在/usr/lib目录下 </span>
</code></pre> 
<h4><a id="09_110"></a>(09)目标文件</h4> 
<p>调用“patsubst”将源文件（.c）编译为目标文件（.o）。</p> 
<pre><code class="prism language-shell">OBJ   <span class="token operator">=</span>  <span class="token variable"><span class="token variable">$(</span>patsubst %.c, %.o, <span class="token punctuation">$(</span>SOURCES<span class="token punctuation">)</span><span class="token variable">)</span></span> <span class="token comment">#符合模式[%.c]的单词替换成[%.o] 即将.c文件转为.o文件 </span>
</code></pre> 
<h4><a id="10_115"></a>(10)执行文件</h4> 
<p>执行文件名称</p> 
<pre><code class="prism language-shell">TARGET  <span class="token operator">=</span>  app
</code></pre> 
<h4><a id="11_120"></a>(11)编译</h4> 
<pre><code class="prism language-shell"><span class="token comment">#compile</span>
%.o: %.c
	<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>INCLUDES<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>DEBUG<span class="token variable">)</span></span> -c <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> $<span class="token operator">&lt;</span> -o <span class="token variable">$@</span>
</code></pre> 
<h4><a id="12_126"></a>(12)链接</h4> 
<p>可创建一个“output”文件夹存放目标执行文件。链接完输出目标执行文件，可以删除编译产生的临时文件（.o）。</p> 
<pre><code class="prism language-shell"><span class="token comment">#links</span>
<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span>
	@mkdir -p output
	<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_PATH<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_NAMES<span class="token variable">)</span></span> -o output/<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>
	@rm -rf <span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span>
</code></pre> 
<h4><a id="13_135"></a>(13)清除编译信息</h4> 
<p>执行“make clean”清除编译产生的临时文件。</p> 
<pre><code class="prism language-shell">.PHONY:clean
clean:
	@echo <span class="token string">"Remove linked and compiled files......"</span>
	<span class="token function">rm</span> -rf <span class="token variable"><span class="token variable">$(</span>OBJ<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span> output 
</code></pre> 
<h4><a id="14_143"></a>(14)使用与编译</h4> 
<p>在对应例程目录下，输入make即可把编译后的执行文件放到output目录下(注：本例程使用到静态库和动态库。)<br> <img src="https://images2.imgbox.com/9e/2d/rcfcpV04_o.png" alt=""><br> 然后执行可执行文件如下：<br> <img src="https://images2.imgbox.com/92/f6/BnJ5SZB3_o.png" alt=""></p> 
<h3><a id="MakefileMakefileMakefile_149"></a>小结：上面已经大概介绍了使用Makefile编译可执行程序的通用模板。接下来将介绍如何使用Makefile编译静态库与动态库，以及简单地介绍在项目工程多目录下多层Makefile如何编译。</h3> 
<h3><a id="22_Makefile_150"></a>2.2 使用Makefile编译静态库</h3> 
<pre><code class="prism language-shell">LIB_NAME <span class="token operator">=</span> libfoo

PROJECT_ROOT_PATH <span class="token operator">=</span> /home/yimning/MakefileTemplate
VERSION     <span class="token operator">=</span> <span class="token number">1.0</span>.0

CCSRCS	<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>wildcard *.c<span class="token variable">)</span></span>
CCOBJS <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>patsubst %.c,%.o, <span class="token punctuation">$(</span>CCSRCS<span class="token punctuation">)</span><span class="token variable">)</span></span>

CC <span class="token operator">=</span> gcc
DEBUG   <span class="token operator">=</span>-DUSE_DEBUG
CFLAGS  <span class="token operator">=</span>-Wall
AR <span class="token operator">=</span> ar
ARFLAGS <span class="token operator">=</span> -rv
SOFLAGS <span class="token operator">=</span> -fPIC -shared
INCPATH <span class="token operator">=</span> -I<span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/include
LDFLAGS <span class="token operator">=</span> -L.
LIB_NAMES <span class="token operator">=</span>  

<span class="token comment">#links</span>
ifdef TARGET_SO
	TARGET <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>LIB_NAME<span class="token variable">)</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>.so
endif

ifdef TARGET_AR
	TARGET <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>LIB_NAME<span class="token variable">)</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>.a
endif

ifdef TARGET_SO
<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">:</span> <span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span>
	<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>SOFLAGS<span class="token variable">)</span></span> $^ -o <span class="token variable">$@</span> <span class="token variable"><span class="token variable">$(</span>LDFLAGS<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_NAMES<span class="token variable">)</span></span>
endif

ifdef TARGET_AR
<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span>
	<span class="token variable"><span class="token variable">$(</span>AR<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>ARFLAGS<span class="token variable">)</span></span> <span class="token variable">$@</span> $^
endif

<span class="token comment">#compile</span>
<span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span><span class="token builtin class-name">:</span> %.o: %.c
	<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>INCPATH<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> -c $<span class="token operator">&lt;</span> -o <span class="token variable">$@</span>
	
.PHONY: <span class="token function">install</span>
install:
	<span class="token function">mkdir</span> -p <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/lib
	<span class="token function">cp</span> <span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/lib
	
.PHONY: clean
clean:
	@echo <span class="token string">"Remove linked and compiled files......"</span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/include/<span class="token variable"><span class="token variable">$(</span>LIB_NAME<span class="token variable">)</span></span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/lib/<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span>
</code></pre> 
<h3><a id="_206"></a>【要点说明】</h3> 
<h4><a id="1Makefile_207"></a>(1)基本格式与“使用Makefile编译可执行文件”大体一致。</h4> 
<h4><a id="2aroalibxxxa_208"></a>(2)使用到“ar”命令将目标文件（.o）链接成静态库文件（.a）。静态库文件固定命名格式为：libxxx.a。以及自己定义的版本信息。</h4> 
<h4><a id="3_209"></a>(3)使用了条件编译与链接。</h4> 
<pre><code class="prism language-shell"><span class="token comment">#links</span>
ifdef TARGET_AR
 TARGET <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>LIB_NAME<span class="token variable">)</span></span>.a.<span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>
endif

ifdef TARGET_AR
<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span>
 <span class="token variable"><span class="token variable">$(</span>AR<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>ARFLAGS<span class="token variable">)</span></span> <span class="token variable">$@</span> $^
endif
</code></pre> 
<h4><a id="4_221"></a>(4)使用与编译</h4> 
<p>在对应例程目录下，输入“make TARGET_AR=1”命令即可在当前目录下编译生成静态库；输入“make TARGET_AR=1 clean”清空链接与编译生成的相关文件。(注：使用了条件编译)。如下图所示。<br> <img src="https://images2.imgbox.com/1b/c6/iAHztbP6_o.png" alt=""></p> 
<h3><a id="23_Makefile_224"></a>2.3 使用Makefile编译动态库</h3> 
<pre><code class="prism language-shell">LIB_NAME <span class="token operator">=</span> libbar

PROJECT_ROOT_PATH <span class="token operator">=</span> /home/yimning/MakefileTemplate
VERSION     <span class="token operator">=</span> <span class="token number">1.0</span>.0

CCSRCS	<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>wildcard *.c<span class="token variable">)</span></span>
CCOBJS <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>patsubst %.c,%.o, <span class="token punctuation">$(</span>CCSRCS<span class="token punctuation">)</span><span class="token variable">)</span></span>

CC <span class="token operator">=</span> gcc
DEBUG   <span class="token operator">=</span>-DUSE_DEBUG
CFLAGS  <span class="token operator">=</span>-Wall
AR <span class="token operator">=</span> ar
ARFLAGS <span class="token operator">=</span> -rv
SOFLAGS <span class="token operator">=</span> -fPIC -shared
INCPATH <span class="token operator">=</span> -I<span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/include
LDFLAGS <span class="token operator">=</span> -L.
LIB_NAMES <span class="token operator">=</span>  

<span class="token comment">#links</span>
ifdef TARGET_SO
	TARGET <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>LIB_NAME<span class="token variable">)</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>.so
endif

ifdef TARGET_AR
	TARGET <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>LIB_NAME<span class="token variable">)</span></span><span class="token builtin class-name">.</span><span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>.a
endif

ifdef TARGET_SO
<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">:</span> <span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span>
	<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>SOFLAGS<span class="token variable">)</span></span> $^ -o <span class="token variable">$@</span> <span class="token variable"><span class="token variable">$(</span>LDFLAGS<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_NAMES<span class="token variable">)</span></span>
endif

ifdef TARGET_AR
<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span>
	<span class="token variable"><span class="token variable">$(</span>AR<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>ARFLAGS<span class="token variable">)</span></span> <span class="token variable">$@</span> $^
endif

<span class="token comment">#compile</span>
<span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span><span class="token builtin class-name">:</span> %.o: %.c
	<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>INCPATH<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> -c $<span class="token operator">&lt;</span> -o <span class="token variable">$@</span>
	
.PHONY: <span class="token function">install</span>
install:
	<span class="token function">mkdir</span> -p <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/lib
	<span class="token function">cp</span> <span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/lib
	
.PHONY: clean
clean:
	@echo <span class="token string">"Remove linked and compiled files......"</span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/include/<span class="token variable"><span class="token variable">$(</span>LIB_NAME<span class="token variable">)</span></span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/lib/<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span>
</code></pre> 
<h3><a id="_280"></a>【要点说明】</h3> 
<h4><a id="1Makefile_281"></a>(1)基本格式与“使用Makefile编译可执行文件”大体一致。</h4> 
<h4><a id="2fPIC_shared_libxxxso_282"></a>(2)编译选项和链接选项增加“-fPIC -shared ”选项。动态库文件固定命名格式为libxxx.so。以及自己定义的版本信息。</h4> 
<h4><a id="3_283"></a>(3)使用了条件编译与链接。</h4> 
<pre><code class="prism language-shell"><span class="token comment">#links</span>
ifdef TARGET_SO
 TARGET <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>LIB_NAME<span class="token variable">)</span></span>.so.<span class="token variable"><span class="token variable">$(</span>VERSION<span class="token variable">)</span></span>
endif

ifdef TARGET_SO
<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span><span class="token builtin class-name">:</span> <span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span>
 <span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>SOFLAGS<span class="token variable">)</span></span> $^ -o <span class="token variable">$@</span> <span class="token variable"><span class="token variable">$(</span>LDFLAGS<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_NAMES<span class="token variable">)</span></span>
endif
</code></pre> 
<h4><a id="4_295"></a>(4)使用与编译</h4> 
<p>在对应例程目录下，输入“make TARGET_SO=1”命令即可在当前目录下编译生成动态库；输入“make TARGET_SO=1 clean”清空链接与编译生成的相关文件。(注：使用了条件编译)。如下图所示。<br> <img src="https://images2.imgbox.com/c7/6b/CAiF3YOX_o.png" alt=""></p> 
<h2><a id="4Makefile_298"></a>4、Makefile多目标多层次编译</h2> 
<p>本小节来简单地介绍在工程项目多目录下多层Makefile如何编译。多个Makefile文件编译，多目标编译，多层次编译。以该项目例程为例，标红色框的Makefile为一级Makefile(也称顶层Makefile)，标蓝色框的Makefile为二级Makefile。实际开发中还可以有更多层级的Makefile对工程进行多目标编译与链接等等。这里就简单的举例子介绍。其目录树结构如下：<br> <img src="https://images2.imgbox.com/db/81/URTsubrF_o.png" alt=""><br> 其中二级的Makefile在前文贴出来了。那么顶层的Makefile如何写？总的来说，写法有点类似于总分结构（或者说父子关系）。本例程的顶层Makefile如下：</p> 
<pre><code class="prism language-shell"><span class="token assign-left variable">PROJECT_ROOT_PATH</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>shell <span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>
VERSION  <span class="token operator">=</span> <span class="token number">1.0</span>.0

MFLAGS <span class="token operator">=</span> <span class="token string">"CFLAGS=-w"</span>
DFLAGS <span class="token operator">=</span> <span class="token string">"CFLAGS=-w -g -fPIC -DDEBUG -DREENTRANT"</span>

<span class="token comment">#如果想编译静态库 指定TARGET_AR=1即可	</span>
all <span class="token builtin class-name">:</span>
	<span class="token builtin class-name">cd</span> <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/src/bar <span class="token operator">&amp;&amp;</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>DFLAGS<span class="token variable">)</span></span> <span class="token assign-left variable">TARGET_SO</span><span class="token operator">=</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token function">install</span> <span class="token assign-left variable">TARGET_SO</span><span class="token operator">=</span><span class="token number">1</span>		
	<span class="token builtin class-name">cd</span> <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/src/foo <span class="token operator">&amp;&amp;</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>DFLAGS<span class="token variable">)</span></span> <span class="token assign-left variable">TARGET_AR</span><span class="token operator">=</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token function">install</span> <span class="token assign-left variable">TARGET_AR</span><span class="token operator">=</span><span class="token number">1</span>
	<span class="token builtin class-name">cd</span> <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/src/test <span class="token operator">&amp;&amp;</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>DFLAGS<span class="token variable">)</span></span> <span class="token operator">&amp;&amp;</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token function">install</span> 

.PHONY: clean
clean <span class="token builtin class-name">:</span>
	@echo <span class="token string">"Remove linked and compiled files......"</span>
	<span class="token builtin class-name">cd</span> <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/src/bar <span class="token operator">&amp;&amp;</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> clean <span class="token assign-left variable">TARGET_SO</span><span class="token operator">=</span><span class="token number">1</span>
	<span class="token builtin class-name">cd</span> <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/src/foo <span class="token operator">&amp;&amp;</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> clean <span class="token assign-left variable">TARGET_AR</span><span class="token operator">=</span><span class="token number">1</span>
	<span class="token builtin class-name">cd</span> <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/src/test <span class="token operator">&amp;&amp;</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> clean
	-rm -rf <span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/lib/<span class="token variable"><span class="token variable">$(</span>TARGET<span class="token variable">)</span></span>

<span class="token comment">#export出来的变量将被子make进程继承。 </span>
<span class="token builtin class-name">export</span> PROJECT_ROOT_PATH VERSION
</code></pre> 
<p>注：makeFile中export的使用。export出来的变量将被子make进程继承。 如果在确定是需要这种方式去传输变量，那么可以在子Makefile中注释相关的变量(比如注释下文test/Makefile中的PROJECT_ROOT_PATH和VERSION)。（也就说顶层Makefile中export的变量在子Makefile中可使用生效(<font color="red">相当于export全局变量</font>)，当然在子Makefile中可以重复定义变量，只在局部生效(<font color="red">相当于局部变量</font>)）。</p> 
<h4><a id="_330"></a>测试例程</h4> 
<p>使用Makefile多目标编译和多层次编译的方式测试整个例程，其中包含使用静态库与动态库来进行编译与链接等，最终生成可执行文件。</p> 
<p>测试例程的bar.h、bar.c</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">BAR_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BAR_H</span></span>
<span class="token keyword">int</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<pre><code class="prism language-c"><span class="token comment">/*
 * @Author: Yimning 1148967988@qq.com
 * @Date: 2022-07-02 10:05:07
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"bar/bar.h"</span></span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试例程的foo.h、foo.c</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">FOO_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOO_H</span></span>
<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<pre><code class="prism language-c"><span class="token comment">/*
 * @Author: Yimning 1148967988@qq.com
 * @Date: 2022-07-02 10:20:07
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"foo/foo.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"bar/bar.h"</span></span>

<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"foo use bar function---output:%d\n"</span><span class="token punctuation">,</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">,</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试例程的test/main.c</p> 
<pre><code class="prism language-c"><span class="token comment">/*
 * @Author: Yimning 1148967988@qq.com
 * @Date: 2022-07-02 10:05:07
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"bar/bar.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"foo/foo.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this is bar function---output:%d\n"</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 88</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this is foo function---output:%d\n"</span><span class="token punctuation">,</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 99</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试例程的test/Makefile</p> 
<pre><code class="prism language-shell">EXE_NAME <span class="token operator">=</span> app
DEBUG <span class="token operator">=</span> -D_MACRO <span class="token comment">#宏定义 </span>

<span class="token comment">#PROJECT_ROOT_PATH = /home/yimning/MakefileTemplate</span>
<span class="token comment">#VERSION     = 1.0.0</span>

CC <span class="token operator">=</span> gcc
DEBUG   <span class="token operator">=</span>-DUSE_DEBUG
CFLAGS  <span class="token operator">=</span>-Wall
CCSRCS	<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>wildcard *.c<span class="token variable">)</span></span>			<span class="token comment">#获取所有的.c文件 </span>
CCOBJS <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>patsubst %.c,%.o, <span class="token punctuation">$(</span>CCSRCS<span class="token punctuation">)</span><span class="token variable">)</span></span>		<span class="token comment">#符合模式[%.c]的单词替换成[%.o] 即将.c文件转为.o文件 </span>
INCPATH <span class="token operator">=</span> -I<span class="token punctuation">..</span>/include -I<span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/include			<span class="token comment">#头文件路径 </span>
LDFLAGS <span class="token operator">=</span> -L<span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/lib			<span class="token comment">#库文件路径</span>
LIB_NAMES <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>LIB_SO_OBJS<span class="token variable">)</span></span>	<span class="token variable"><span class="token variable">$(</span>LIBS_A_OBJS<span class="token variable">)</span></span>		<span class="token comment">#链接库文件名字 </span>

<span class="token comment"># 获取静态库名字</span>
LIBS_A	<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>wildcard <span class="token punctuation">$(</span>PROJECT_ROOT_PATH<span class="token punctuation">)</span>/lib/*.a<span class="token variable">)</span></span>   <span class="token comment"># 获取该目录下动态库(*.a)的路径名</span>
LIBS_A_NOTDIR    <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>notdir <span class="token punctuation">$(</span>LIBS_A<span class="token punctuation">)</span><span class="token variable">)</span></span>			<span class="token comment"># 去掉路路径，只留下文件名为libxxx.a</span>
LIBS_A_NOTLIB    <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>subst lib,,<span class="token punctuation">$(</span>LIBS_A_NOTDIR<span class="token punctuation">)</span><span class="token variable">)</span></span>	<span class="token comment"># 去掉文件名的lib,留下部分为xxx.a</span>
LIBS_A_OBJS <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>patsubst %.a,-l%, <span class="token punctuation">$(</span>LIBS_A_NOTLIB<span class="token punctuation">)</span><span class="token variable">)</span></span>		<span class="token comment"># 去掉文件名的后缀并在前面添加-l,留下部分为-lxxx</span>

<span class="token comment"># 获取动态库名字</span>
LIBS_SO	<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>wildcard <span class="token punctuation">$(</span>PROJECT_ROOT_PATH<span class="token punctuation">)</span>/lib/*.so<span class="token variable">)</span></span>   <span class="token comment"># 获取该目录下动态库(*.so)的路径名</span>
LIBS_SO_NOTDIR    <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>notdir <span class="token punctuation">$(</span>LIBS_SO<span class="token punctuation">)</span><span class="token variable">)</span></span>			<span class="token comment"># 去掉路路径，只留下文件名为libxxx.so</span>
LIBS_SO_NOTLIB    <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>subst lib,,<span class="token punctuation">$(</span>LIBS_SO_NOTDIR<span class="token punctuation">)</span><span class="token variable">)</span></span>	<span class="token comment"># 去掉文件名的lib,留下部分为xxx.so</span>
LIB_SO_OBJS <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>patsubst %.so,-l%, <span class="token punctuation">$(</span>LIBS_SO_NOTLIB<span class="token punctuation">)</span><span class="token variable">)</span></span>		<span class="token comment"># 去掉文件名的后缀并在前面添加-l,留下部分为-lxxx</span>

<span class="token comment">#links</span>
<span class="token variable"><span class="token variable">$(</span>EXE_NAME<span class="token variable">)</span></span><span class="token builtin class-name">:</span> <span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span>
	<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> $^ -o <span class="token variable">$@</span> <span class="token variable"><span class="token variable">$(</span>LDFLAGS<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LIB_NAMES<span class="token variable">)</span></span>

<span class="token comment">#compile</span>
<span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span><span class="token builtin class-name">:</span> %.o: %.c
	<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>INCPATH<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> -c $<span class="token operator">&lt;</span> -o <span class="token variable">$@</span>
	
.PHONY: <span class="token function">install</span>
install:
	<span class="token function">cp</span> <span class="token variable"><span class="token variable">$(</span>EXE_NAME<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>
<span class="token comment"># 	make print						#调试打印变量</span>

.PHONY: clean
clean:
	@echo <span class="token string">"Remove linked and compiled files......"</span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>CCOBJS<span class="token variable">)</span></span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>EXE_NAME<span class="token variable">)</span></span>
	-rm -rf <span class="token variable"><span class="token variable">$(</span>PROJECT_ROOT_PATH<span class="token variable">)</span></span>/<span class="token variable"><span class="token variable">$(</span>EXE_NAME<span class="token variable">)</span></span>

print:
	@echo <span class="token variable"><span class="token variable">$(</span>LIBS_SO<span class="token variable">)</span></span>
	@echo <span class="token variable"><span class="token variable">$(</span>LIBS_SO_NOTDIR<span class="token variable">)</span></span>
	@echo <span class="token variable"><span class="token variable">$(</span>LIBS_SO_NOTLIB<span class="token variable">)</span></span>
	@echo <span class="token variable"><span class="token variable">$(</span>LIB_SO_OBJS<span class="token variable">)</span></span>
</code></pre> 
<h4><a id="_441"></a>使用与编译</h4> 
<p>在对应例程目录下，输入“make”命令即可在当前目录下编译生成可执行文件app.1.0.0；输入“make clean”清空链接与编译时生成的相关文件。(注：动态库已放到/lib/下)。如下图所示。<br> <img src="https://images2.imgbox.com/44/ac/0pmAaXQf_o.png" alt=""></p> 
<hr> 
<p>好了。本期的介绍到这里就结束了。感谢阅读与分享！搜索微信公众号：嵌入式IoT杂谈，回复"0728"即可获取本文例程。扫码关注我们世间万物，千奇百怪，都等待着你去发觉…</p> 
<div align="center"> 
</div> 
<div align="center"> 
 <text>
   微信扫一扫关注该公众号 
 </text> 
</div> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/825b87bbfe93ffcb203aad7f52064aec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端传file文件和json报文到java后端处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9cf2f130a37d273d940dfaa709b96ee2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何解决’telent’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。正在连接127.0.0.1无法打开到主机的连接。 在端口 23: 连接失败</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>