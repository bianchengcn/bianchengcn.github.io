<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d51b47ba2b45746fb095375f80c55801/" rel="bookmark">
			10个Python完整小项目入门爬虫实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点:
web是如何交互的requests库的get、post函数的应用response对象的相关函数，属性python文件的打开，保存 代码中给出了注释，并且可以直接运行。
如何安装requests库(安装好python的朋友可以直接参考，没有的，建议先装一哈python环境这里也给朋友们提前准备了 点击领取福利
windows用户，Linux用户几乎一样:
打开cmd输入以下命令即可，如果python的环境在C盘的目录，会提示权限不够，只需以管理员方式运行cmd窗口
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple requests Linux用户类似(ubantu为例): 权限不够的话在命令前加入sudo即可
sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple requests 案例目录 一、爬取强大的BD页面，打印页面信息二、常用方法之get方法实例，下面还有传参实例级目录三、常用方法之post方法实例，下面还有传参实例四、put方法实例五、常用方法之get方法传参实例(1)六、常用方法之get方法传参实例(2)七、常用方法之post方法传参实例八、关于绕过反爬机制九、爬取信息并保存到本地十、爬取图片，保存到本地 一、爬取强大的BD页面，打印页面信息 # 第一个爬虫示例,爬取百度页面 import requests #导入爬虫的库，不然调用不了爬虫的函数 response = requests.get("http://www.baidu.com") #生成一个response对象 response.encoding = response.apparent_encoding #设置编码格式 print("状态码:"+ str( response.status_code ) ) #打印状态码 print(response.text)#输出爬取的信息 二、常用方法之get方法实例，下面还有传参实例级目录 # 第二个get方法实例 import requests #先导入爬虫的库，不然调用不了爬虫的函数 response = requests.get("http://httpbin.org/get") #get方法 print( response.status_code ) #状态码 print( response.text ) 三、常用方法之post方法实例，下面还有传参实例 # 第三个 post方法实例 import requests #先导入爬虫的库，不然调用不了爬虫的函数 response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d51b47ba2b45746fb095375f80c55801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6209bf5fc6f2df308fdd59f4c9dc28b6/" rel="bookmark">
			chatGlm报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		File "/root/.cache/huggingface/modules/transformers_modules/chatglm-6b/quantization.py", line 157, in quantize layer.attention.query_key_value = QuantizedLinear( File "/root/.cache/huggingface/modules/transformers_modules/chatglm-6b/quantization.py", line 137, in __init__ self.weight = compress_int4_weight(self.weight) File "/root/.cache/huggingface/modules/transformers_modules/chatglm-6b/quantization.py", line 78, in compress_int4_weight kernels.int4WeightCompression( File "/root/miniconda3/envs/glm/lib/python3.10/site-packages/cpm_kernels/kernels/base.py", line 48, in __call__ func = self._prepare_func() File "/root/miniconda3/envs/glm/lib/python3.10/site-packages/cpm_kernels/kernels/base.py", line 36, in _prepare_func curr_device = cudart.cudaGetDevice() File "/root/miniconda3/envs/glm/lib/python3.10/site-packages/cpm_kernels/library/base.py", line 72, in wrapper raise RuntimeError("Library %s is not initialized" % self.__name) RuntimeError: Library cudart is not initialized 报以上错
可能没有装cudnn(Ubuntu22.04)
#ubuntu 22.04 #wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-keyring_1.0-1_all.deb #sudo dpkg -i cuda-keyring_1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6209bf5fc6f2df308fdd59f4c9dc28b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2eeb5b4c5182cd902eb62ee35a4c031/" rel="bookmark">
			Python学习笔记-20(面向对象案例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023.5.10
努力学习python，想为以后可以有一份额外收入，如果有大神可以指点一下，我将不胜感激
如果有大神想以后拥有一个合作伙伴进行交流，我会尽力赶上您的脚步！
#根据面向对象写一个 小花猫的案例 class Cat: type = '猫' #下面是猫的变化什么，属性之类 通过init初始化的特征 def __init__(self,nickname , age , color): self.nickname = nickname #小猫称为nickname self.age = age self.color = color #猫喜欢吃什么东西 def eat(self , food): print('{}喜欢吃{}'.format(self.nickname , food)) #猫抓老鼠，抓多重，什么颜色的老鼠 def catch_mouse(self , color ,weight): print('{},抓了一只{}kg的，{}的大老鼠!'.format(self.nickname,weight,color)) #抓完就睡觉 def sleep(self , hour): if hour &lt; 5: #如果睡觉小于五个小时怎么办 print('继续酣睡!') else: print('起床抓老鼠！') def show(self): print('猫的详细信息:') print(self.nickname , self.age , self.color) #创建猫 cat1 = Cat('花花' , 2 , '灰色') #定义了init有三个参数，需要传参 猫的参数 cat1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2eeb5b4c5182cd902eb62ee35a4c031/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f9322c43746377c743bcaf4731f31b/" rel="bookmark">
			YOLOv5下载编译运行-口罩检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、YOLOv5程序下载
1. yolov5程序下载
2.口罩数据集下载 二、编译运行代码 1.使用pycharm打开上面的文件夹 2.pycharm训练参数配置 3.编译运行
三、使用训练好的模型进行预测
1. 预测环境配置 四、训练和预测过程遇到的错误及解决办法
1. 训练遇到的报错 2. 预测编译遇到的错误及解决办法 3. 一些其它错误的解决办法 4. YOLOv5训练不显示GFLOPs问题
一、YOLOv5程序下载 1. yolov5程序下载 GitHub - ultralytics/yolov5: YOLOv5 🚀 in PyTorch &gt; ONNX &gt; CoreML &gt; TFLite
依赖包安装 在命令行下进入yolov5目录，执行下面的命令，会把依赖包安装
pip install -r requirements.txt # install 而我的环境有的依赖包已经安装过，不执行，编译遇到缺少什么，就安装什么 2.口罩数据集下载 链接：https://pan.baidu.com/s/1RP3wXuQnGsO87JqgK_bK3g 提取码：j236 --来自百度网盘超级会员V1的分享 解压后文件夹如下，标出来的就是数据集，解压下来的yolov5代码是旧版的，不用，只要数据集。 将上面两步得到的代码和数据集放到同一个目录 二、编译运行代码 1.使用pycharm打开上面的文件夹 2.pycharm训练参数配置 上图第2步的参数设置如下
--data D:/deep_learn/yolov5_20230418/MaskDataSet/data.yaml --weights '' --cfg D:/deep_learn/yolov5_20230418/yolov5-master/models/yolov5s.yaml --data 数据集指定， --weights 预训练权重，用单引号‘ ’代码不使用迁移学习，从0开始训练 -- cfg 模型配置文件，其它参数不设置就使用默认的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50f9322c43746377c743bcaf4731f31b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd8dceb05b77bb58236bd39c5ad8be3/" rel="bookmark">
			VSCode使用Remote SSH连接远程服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 最近在搭建一套 VSCode 的远端开发环境，主要想解决 C/C++ 代码不能 100% 跳转的问题。
闲言少叙，安装过程奉上。
2 操作步骤 2.1 安装 SSH
由于我们是使用 SSH 连接远程服务器，因此 Windows 需要支持 SSH 。
可以通过安装 Git 来获取 SSH 功能，如何验证?使用 Win + R ，输入 cmd 打开控制窗口，直接输入 ssh ，如下提示，则代表 SSH 已经安装成功;
2.2 添加插件
使用 VSCode 最方便的一点，就是有很多插件可供选择。
本次我们需要使用 Remote - SSH 插件，长这个样子，不要搞错了
安装完插件后，在侧边栏可以看到 “远程资源管理器” 图标。
2.3 配置SSH密钥
目的：将本机添加到远程服务器连接白名单，让服务器知道是已认证的电脑在连接。过程类似于 GitHub 网站添加本地电脑的 SSH 公钥。
1、使用如下命令，生成 SSH 公钥文件。如果已经生成，则可直接使用，跳到步骤二。
复制
# 方法一 ssh-keygen # 方法二，参考使用Git生成密钥 ssh-keygen -t rsa -C "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afd8dceb05b77bb58236bd39c5ad8be3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a8c60c16febc3d5e00b00c9f633cc73/" rel="bookmark">
			如何设置Word文档公式序号在右边
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Word里怎么使得公式的序号停靠在最右边呢？很简单，只需要四步！
1、插入公式
2、输入公式
3、然后在公式的最后边紧跟着 输入一个空格后输入一个#号，#号后接你要的序号（切记 公式里面不能有分隔符）
4、然后按回车。注意整个过程光标要在公式框里。（回车后就会自动公式居中，序号靠右了）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98dc5bfbd62a58cd960995552a9ea791/" rel="bookmark">
			Python基础—重试机制与请求缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重试机制 1.retrying模块：Retrying 是一个使用Python编写的通用重试库，用于简化向几乎所有内容添加重试行为的任务 python中的retrying模块提供的retry方法，可以直接以语法糖的形式装饰给需要重试的函数 @retry —— 这样的写法等于永久性的重试 2.安装Retrying模块： Windows：pip install retrying Mac：pip3 install retrying 3.@retry中常用属性 ①stop_max_attempt_number=5：最多重试5次 ②wait_fixed=2000：等待两秒再重试 ③wait_random_min=1000, wait_random_max=3000：最少等待1秒，最多等待3秒，在 import requests from retrying import retry @retry(stop_max_attempt_number=5, wait_random_min=1000, wait_random_max=3000) def requests_get(href): print('正在请求或正在重试', href) response = requests.get(url=href) print(response) URL_List = [ 'https://www.baidu.com/', 'https://jd.com/', 'https://a123b.123/', # 该网站不可访问 'https://www.taobao.com/' ] for i in URL_List: requests_get(i) 运行结果：正在请求或正在重试 https://www.baidu.com/ &lt;Response [200]&gt; 正在请求或正在重试 https://jd.com/ &lt;Response [200]&gt; 正在请求或正在重试 https://a123b.123/ 正在请求或正在重试 https://a123b.123/ 正在请求或正在重试 https://a123b.123/ 正在请求或正在重试 https://a123b.123/ 正在请求或正在重试 https://a123b.123/ # 由于重试5次之后还是无法访问该网页，报错 请求缓存 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98dc5bfbd62a58cd960995552a9ea791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/295647ab05e55ebb08d3ecd7518afd08/" rel="bookmark">
			重磅插件 - Bito – GPT-4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.介绍 Bito – GPT-42.Bito AI 功能一览2.1 AI Chat2.2 常用快捷方式2.3 生成的代码可直接插入光标处2.4 优化后的代码与源代码鲜明对比2.5 定制自己的提示模板2.6 Bito 插件2.7 Bito CLI 3.安装 Bito – GPT-44.登陆 Bito – GPT-4 创作不易，如果本文对你有帮助，胖友记得一键三连 😭。更多 AI 优质内容推荐请关注主页 “AI” 专栏，笔者会不定期更新觉得自己用下来还不错的 AI 相关产品。
1.介绍 Bito – GPT-4 Bito – GPT-4 &amp; ChatGPT to write code, explain code, create tests 是一款 AI 插件，Bito 通过将 GPT-4 和 ChatGPT 引入 IDE 和 CLI，帮助开发人员显着加快他们的影响力。Bito 使用 OpenAI 的模型，你不必拥有 OpenAI 密钥。
Bito 每天可以为您节省一个小时！ Bito AI 可以轻松编写代码、理解语法、编写测试用例、解释代码、评论代码、检查安全性，甚至解释高级概念。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/295647ab05e55ebb08d3ecd7518afd08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dd72b8e2c1c46c7f3410fdaac115e62/" rel="bookmark">
			flex布局详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 说明display属性flex-direction属性主轴与交叉轴justify-content属性align-items属性flex-wrap属性flex-flow属性align-content属性align-self属性order属性flex-grow属性flex-shrink属性flex-basis属性flex属性row-gap与column-gap属性gap属性其他示例 说明 后面的flex布局示例代码都会在此示例的flexTest样式上增加代码以做说明。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt;	.box{ height:500px; width:700px; border: 1px solid gray; } .number{ width:40px; text-align: center; } .number1{ background-color: #009688; height:40px; } .number2{ background-color: #eb064a; height:50px; } .number3{ background-color: #9c27b0; height:60px; } .number4{ background-color: #ebea06; height:70px; } .number5{ background-color: #1cdd30; height:80px; } .flexTest{ height:500px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;div class="flexTest"&gt; &lt;div class="number number1"&gt;1&lt;/div&gt; &lt;div class="number number2"&gt;2&lt;/div&gt; &lt;div class="number number3"&gt;3&lt;/div&gt; &lt;div class="number number4"&gt;4&lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dd72b8e2c1c46c7f3410fdaac115e62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ca18ef50d45b62d604caeaf431443f/" rel="bookmark">
			mysql分页查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
分页查询
聚合函数
求最大值：
求最小值：
求平均值：
求行数：
求和：
分组查询
group by和 group_concat()搭配使用：
运行结果：
group by和 with rollup使用： 运行结果：
group by和聚合函数使用：
运行结果：
group by和having使用： 运行结果：
分页查询 select * from 表名称 limit start,count; 说明：
limit为分页查询关键字
start开始值默认为0
count表示查询的结束值
使用 limit 关键字可以限制数据显示数量，通过 limit 关键可以完成分页查询
limit 关键字后面的第一个参数是开始行索引(默认是0，不写就是0)，第二个参数是查询条数
聚合函数 聚合函数又叫组函数，通常是对表中的数据进行统计和计算，一般结果分组（group by）来使用，用于统计和计算分组数据
1.max：求最大值
2.min：求最小值
3.avg：求平均值
4.count：求行数
5.sum：求和
求最大值： --聚合函数不会对空值进行统计 --求最大值：max select max(列名称) from 表名称; 求最小值： --求最小值：min select min(列名称) from 表名称; 求平均值： --求平均值：avg,不会统计空值 select avg(列名称) from 表名称; --isfull统计空值,null用0代替 select avg(isfull(列名称,0)) from 表名称; ps:ifnull函数：表示判断指定字段的值是否为null，如果为空使用自己提供的值 求行数： --求行数：count --求所有列 select count(*) from 表名称; --求某一列行数 select count(行数) from 表名称; 求和： --求和：sum select sum(列名称) from 表名称; 分组查询 group by使用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99ca18ef50d45b62d604caeaf431443f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d423b4128ac9cb510df3ed3867acd565/" rel="bookmark">
			33 基于8086洗衣机仿真系统设计【毕设课设】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料地址：https://pan.baidu.com/s/1EN7bewMhEfb-hM7SmNH70w?pwd=8888
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c754ae86df4987c355fa02c15a2851/" rel="bookmark">
			Python爬虫基础—代理IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代理IP 一、什么是代理IP 代理IP又叫代理服务器，其功能就是代理用户去获取网络信息，形象的说，它是网络的中转站 二、提取代理IP 1. 芝麻代理：https://jahttp.zhimaruanjian.com/ 2. 注册登录之后实名认证 3. 点击获取API选项 依次选择IP属性（如下图） 获取链接后将该链接放入API_URL中 import requests API_URL = 'http://webapi.http.zhimacangku.com/getip?num=1&amp;type=2&amp;pro=&amp;city=0&amp;yys=0&amp;port=1&amp;pack=299708&amp;ts=1&amp;ys=1&amp;cs=1&amp;lb=1&amp;sb=0&amp;pb=45&amp;mr=1&amp;regions=' API_response = requests.get(url=API_URL) print(API_response) 运行结果：&lt;Response [200]&gt; 我们知道API接口中是json数据，可以使用json模块的loads方法做转换 同时，requests模块也提供了对应的转换方法：json( ) import requests API_URL = 'http://webapi.http.zhimacangku.com/getip?num=1&amp;type=2&amp;pro=&amp;city=0&amp;yys=0&amp;port=1&amp;pack=299708&amp;ts=1&amp;ys=1&amp;cs=1&amp;lb=1&amp;sb=0&amp;pb=45&amp;mr=1&amp;regions=' API_response = requests.get(url=API_URL) IP_data = API_response.json() print(IP_data, type(IP_data)) 运行结果：{'code': 0, 'data': [{'ip': '121.232.72.175', 'port': 4231, 'expire_time': '2023-05-06 19:37:37', 'city': '江苏省南通市', 'isp': '电信'}], 'msg': '0', 'success': True} &lt;class 'dict'&gt; 三、构建IP地址 IP地址的形式是 http://ip: port ip（地址）、port（端口） 例如百度网址：‘https://www.baidu.com/’ —— 使用ip: port映射而来 百度的ip（地址）：202.108.22.5 百度的port（端口号）：80 由上一步中我们得到的API_data中的字典中data这个键对应的值是一个列表，列表中又是一个字典，我们需要拿到data这个键对应的值中的ip键和port键分别对应的值，从而构建IP地址 Ip = IP_data['data'][0]['ip'] Port = IP_data proxy_ip = { 'http': f'http://{Ip}: {Port}' 'https': f'http://{Ip}: {Port}' } print(proxy_ip) 运行结果：{'http': 'http://113.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1c754ae86df4987c355fa02c15a2851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153df20e3b972f1f7c478527a72d0346/" rel="bookmark">
			jquery插件无缝滚动通知栏js特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址
一款实用的jquery插件无缝滚动网页，常见的通知栏滚动播报特效
dd:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a155ec219ba3e058a42590566fe320b/" rel="bookmark">
			MySQL-分页查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分页查询 1 简要介绍1.1 应用场景1.2 语法1.3 特点 2 简单使用 1 简要介绍 1.1 应用场景 应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求
1.2 语法 select 查询列表 from 表 【join type join 表2 on 连接条件 where 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序的字段】 limit 【offset,】size; # offset要显示条目的起始索引（起始索引从0开始） # size 要显示的条目个数 1.3 特点 limit语句放在查询语句的最后
公式：
要显示的页数 page，每页的条目数size
select 查询列表
from 表
limit (page-1)*size,size;
size=10
page
第一页 0-9
第二页 10-19
第三页 20-29
2 简单使用 案例1：查询前五条员工信息
SELECT * FROM employees LIMIT 0,5; SELECT * FROM employees LIMIT 5; 案例2：查询第11条——第25条（一共15条数据）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a155ec219ba3e058a42590566fe320b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3bd9e7eab0a2613b8a57379baa4594c/" rel="bookmark">
			MYSQL中varchar和text的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql中varchar和text最大长度都是65535，都是变长，varchar字段长度超过255，创建单列索引就会报错，也无法使用索引
那我们为什么在不需要索引的情况下不直接使用text呢
1， 由于MySQL的内存临时表不支持BLOB、TEXT类型，如果包含该类型列的查询需要用到临时表，就会使用基于磁盘的临时表，性能将会急剧降低。
PS: InnoDB只将767字节的文本或BLOB放入内联，其余的放入其他块中。
所以，编写查询语句时，如果没有必要包含BLOB、TEXT列，就不要写入查询条件。
规避的办法：
使用substring()函数。
设置MySQL变量tmpdir，把临时表存放在基于内存的文件系统中。如Linux下的tmpfs。可以设置多个临时表的路径(用分号分隔)，MySQL将使用轮询的方式。
优化的方法：
如果必须使用，可以考虑拆分表，把BLOB、TEXT字段分离到单独的表。
如果有许多大字段，可以考虑合并这些字段到一个字段，存储一个大的200kb比存储20个10kb更高效。
考虑使用compress()，或者在应用层进行压缩，再存储到BLOB字段中。
————————————————
版权声明：本文为CSDN博主「若水如斯」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/shefin90/article/details/124650501
2，排序
max_sort_length：如果排序BLOB、TEXT字段，则仅排序前max_sort_length个字节。
3，索引
上面说过的不能创建索引
text字段，MySQL不允许有默认值。建立索引必须给出前缀索引长度.
varchar允许有默认值,对索引长度没限制,
4，不影响单行65535字节长度限制
即不影响所有字段定义长度的和，当然也不是完全没有。当然超长的varchar也会存储到磁盘。
本质是溢出存储,innodb默认只会存放前768字节在数据页中,而剩余的数据则会存储在溢出段中,虽然也受单表65535最大行宽度限制,但mysql表中每个BLOB和TEXT列实际只占其中的5至9个字节，其他部分将进行溢出存储.所以实际占用表最大行宽度为9+2字节,外加的是额外开销,跟表的实际宽度没有关系.
————————————————
版权声明：本文为CSDN博主「郑志恒」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_35631730/article/details/113136813
更多请访问梯哥哥
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44730811727f33e3a873312031b3cdc9/" rel="bookmark">
			Java volatile关键字最全总结：原理剖析与实例讲解(简单易懂)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、简介
二、并发编程的3个基本概念
1.原子性
2.可见性
3.有序性
三、锁的互斥和可见性
四、Java的内存模型JMM以及共享变量的可见性
五、volatile变量的特性
1.保证可见性，不保证原子性
2.禁止指令重排
六、volatile不适用的场景
七、volatile原理
八、单例模式的双重锁为什么要加volatile
一、简介 volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。
二、并发编程的3个基本概念 1.原子性 定义： 即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
原子性是拒绝多线程操作的，不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。例如 a=1是原子性操作，但是a++和a +=1就不是原子性操作。Java中的原子性操作包括：
（1）基本类型的读取和赋值操作，且赋值必须是值赋给变量，变量之间的相互赋值不是原子性操作。
（2）所有引用reference的赋值操作。
（3）java.concurrent.Atomic.* 包中所有类的一切操作。
2.可见性 定义：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
3.有序性 定义：即程序执行的顺序按照代码的先后顺序执行。
Java内存模型中的有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。
在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
三、锁的互斥和可见性 锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。
（1）互斥即一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用该共享数据。
（2）可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。也即当一条线程修改了共享变量的值，新值对于其他线程来说是可以立即得知的。如果没有同步机制提供的这种可见性保证，线程看到的共享变 量可能是修改前的值或不一致的值，这将引发许多严重问题。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：
a.对变量的写操作不依赖于当前值。
b.该变量没有包含在具有其他变量的不变式中。
实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。事实上就是保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。
四、Java的内存模型JMM以及共享变量的可见性 JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。
对于普通的共享变量来讲，线程A将其修改为某个值发生在线程A的本地内存中，此时还未同步到主内存中去；而线程B已经缓存了该变量的旧值，所以就导致了共享变量值的不一致。解决这种共享变量在多线程模型中的不可见性问题，较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，比较合理的方式其实就是volatile。
需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存
五、volatile变量的特性 1.保证可见性，不保证原子性 （1）当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去。
（2）这个写操作会导致其他线程中的volatile变量缓存无效。
2.禁止指令重排 重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：
（1）重排序操作不会对存在数据依赖关系的操作进行重排序。
比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。
（2）重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变
比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44730811727f33e3a873312031b3cdc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f85bfb7af8f2e22b74baa8d47eedff6/" rel="bookmark">
			java：for循环内部设置多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 语言：java问题：在for循环中，需要顺序执行，效率太低。如何并发多线程的执行for循环？解决方法： import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; .... //外层循环 for (Map typeIdMap : typeIdList) { //设置线程数 ExecutorService executorService = Executors.newFixedThreadPool(1); //内部循环 for (Map endTsMap : endTsList) { //多线程 executorService.execute(new Runnable() { @Override public void run() { ... // 做你想做的 } }); } executorService.shutdown(); //关闭线程 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760a213d4c77594eefbfb5d40f447fe1/" rel="bookmark">
			【Java基础知识 1】Java入门级概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪
，专注Java硬核干货分享，立志做到Java赛道全网Top N。
🏆本文收录于，Java基础教程系列，目前已经700+订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
🏆姐妹篇，Java基础教程（入门篇），包含面向对象、基本数据类型、数组、继承和多态、泛型、枚举等Java基础知识点。
🏆姐妹进阶篇，Java基础教程（进阶篇），包含Java高并发、Spring、MySQL等Java进阶技术栈。
🏆全部订阅，可加入Java学习星球，完成Java从入门、实战、进阶全方位的Java知识体系学习。
小编之前写过一期Java学习路线总结❤️搬砖工逆袭Java架构师❤️（全网最强，建议收藏） 广受大家喜爱，有的粉丝问我，能不能出一期入门级别的博客，好吧，是我考虑不周了，今天我就将它补上。
目录 一、Java成名史
二、JDK 与 JRE 三、语言的五大特性
四、对象间的四种关系
1、依赖
2、关联
3、聚合
4、组合
五、封装、继承、多态
1、封装
2、继承
3、多态
六、我的第一个Java程序
1、先配置环境变量
2、hello world
七、八种基本数据类型
八、Java的重要概念
1、类
2、普通类和抽象类
3、接口和抽象类
4、成员变量和局部变量
5、对象的创建和声明周期
6、final 和 static 7、final、finally、finalize
8、Java运算符
9、循环结构
10、条件表达式
11、super与this
12、方法的重写
13、在 Java 中，什么时候用重载，什么时候用重写？
14、抽象类和接口
15、克隆
16、javac
九、Java Character 类
十、String
十一、数组
1、概念
2、格式
3、初始化
4、遍历
5、常见异常
十二、数据保存在哪里
1、寄存器
2、堆与栈
3、常量存储
4、非RAM存储
十三、java异常
十四、序列化与反序列化
十五、Java IO流
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/760a213d4c77594eefbfb5d40f447fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a0ca0ec176c8340376aa72cda87475/" rel="bookmark">
			matlab读取excel文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB是一种十分强大的科学计算软件，不仅可以进行数值计算、矩阵运算，还可以处理Excel、CSV和其他常见格式的数据。在现实生活中，Excel文件是非常常见的数据文件，它包含了各种信息，诸如数据记录、计算和预测等。MATLAB提供了一组工具，可以轻松地将Excel文件读入和处理。本文将介绍如何使用MATLAB读取Excel文件。
准备Excel文件 首先，我们需要一个要读取的Excel文件。我们可以使用Excel软件创建一个包含数据的Excel文件并将其保存到计算机上，或者我们可以使用MATLAB的“xlsread”函数来读取现有的Excel文件。这是一个基本的xlsread语法：
[num,txt,raw] = xlsread(filename); 其中，“filename”是要读取的Excel文件名称，函数返回的“num”、“txt”和“raw”是数据和文本的数组。当我们没有特别指定输出参数时，“xlsread”会默认返回数组“num”，其中包含Excel文件中的数字。请注意，如果Excel表格中包含文本或其他非数字信息，将无法读取这些信息，需要使用txt或raw输出参数来获取相关的数据。
读取数值数据 读取Excel的数字数据很简单，只需要使用“xlsread”函数。以下是一个常见的例子，在Excel文件“example.xlsx”中，有两列数据，“Column A”和“Column B”，分别为1~10的数字：
[num,txt,~] = xlsread('example.xlsx'); columnA = num(:,1); columnB = num(:,2); 该代码首先使用“xlsread”函数读取“example.xlsx”文件的所有数据，然后将第一列和第二列的数据分别存储到 MATLAB 变量“columnA” 和“columnB”中。
读取文本数据 如果Excel表格包含文本数据，则需要使用txt输出参数来提取相关数据。例如，假设我们要读取第一列包含的字符串，我们需要在“xlsread”函数中加上“txt”参数：
[num,txt,~] = xlsread('example.xlsx'); columnA_txt = txt(2:end,1); 该代码读取“example.xlsx”文件中的所有数据，并获取第一列的字符串。请注意，由于 Excel 的第一行通常包含标题而不是实际数据，因此我们使用“2:end”来跳过第一行。
读取公式数据 Excel也能够包含公式，而不是固定的数值或文本。公式包含了应用于特定单元格或单元格范围的计算公式。MATLAB的“xlsread”函数能够将这些公式计算为数值，并将它们读入 MATLAB。以下是一个例子，其中Excel文件“example.xlsx”包含了两列数据，第一列为1~10的数字，第二列为第一列数字的平方和两倍的倍数：
[num,~,~] = xlsread('example.xlsx'); columnC = num(:,3); Excel文件的第三列中包含一个计算公式，它将使用第一列中的数字进行计算。xlsread函数会自动计算公式并将结果存储在第三列中的“num”数组。
读取多个表格 其中，一个Excel文件可以包含多个表格，任何一个表格都可以通过使用表格名称或表格索引来读取。以下是一个例子，其中 Excel 文件“example.xlsx”包含 3 个不同的表格 “Sheet1”、“Sheet2”和“Sheet3”：
[num_sheet1,~,~] = xlsread('example.xlsx', 'Sheet1'); [num_sheet2,~,~] = xlsread('example.xlsx', 2); % 使用表格索引 [num_sheet3,~,~] = xlsread('example.xlsx', 'Sheet3'); 第 1 行中的代码读取名为“Sheet1”的表格中的所有数值数据，并将其存储在“num_sheet1”数组中。第 2 和 4 行使用表格索引来获取“Sheet2”和“Sheet3”中的数据。在这个例子中，“Sheet2”是第二个表格，因此使用数字“2”代替表格名称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0a0ca0ec176c8340376aa72cda87475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d65f988736f9a0cac0f6ec58465e0d/" rel="bookmark">
			vue实现全局消息提醒功能（vue-extend）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需求背景 （1）在一般的管理系统或者H5应用中，需要交互反馈提醒。这种交互反馈，往往需要在多个组件中使用到，那么是否可以将其抽离出来，封装一个组件呢？答案是肯定的，我们可以根据日常的业务，对消息提醒功能进行封装，那么问题来了，如何实现一次注册，多次使用呢，关键时刻，vue.extend API就派上用场了
2. vue.extend（{组件选项}）的用法 （1）官方的解释是：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。
按照我的理解是extend方法可以把一个组件选项作为参数，使用此方法，可以获得该组件的构造函数，然后通过new 方法创建一个组件出来。最后通过amount 方法挂载到对应的结点上。废话不多说，直接上代码。
// 创建构造器 var Profile = Vue.extend({ template: '&lt;p&gt;{{firstName}} {{lastName}} aka {{alias}}&lt;/p&gt;', data: function () { return { firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' } } }) // 创建 Profile 实例，并挂载到一个元素上。 new Profile().$mount('#mount-point') （2）疑惑：这么方法何种场景适用？
解释一下，对比正常的组件挂载流程，需要我们在 .vue 文件中的component进行注册，然后在template文件中，编写相应的代码。
但很多时候，我们需要在组件之外的地方，使用到这个组件的一些api，比如在axios 拦截响应请求时，对异常消息提示，做出反馈，这个时候无法使用普通的组件注册方式调用消息提醒组件的api。因为这个是一个js文件，因此，通过这个extend API，提供了我们一个可以在.vue 文件之外，创建组件，并挂载，调用其api实现相应功能的能力。
3 封装消息提醒组件 &lt;template&gt; &lt;div class="toast" v-show="showToast"&gt; &lt;div class="info" v-if="type == 'info'"&gt;{{ message }}&lt;/div&gt; &lt;div class="loading" v-if="type == 'loading'"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d65f988736f9a0cac0f6ec58465e0d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/63/">«</a>
	<span class="pagination__item pagination__item--current">64/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/65/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>