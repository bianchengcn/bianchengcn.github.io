<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00c9b9238de032b5a8fca4be0f6e6f8f/" rel="bookmark">
			基于随机森林算法的森林生物量反演【Matlab Python】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、意义以及技术路线 估算森林生物量的方法大致可归为以下两种 ：一是传统估算方法，大多是采用抽样方法获取野外调查数据估算森林生物量，这种方法往往需要较多的人力物力来完成，并且获取的数据不具有空间连续性特征，无法反映环境因子对估算结果的影响；二是遥感技术估算方法，遥感影像波段具有空间连续性特征，且具有宏观、快速以及可重复等特点，为研究森林生物量及其空间分布提供了必要条件，使得估算结果不仅接近实际，而且可提供直观的森林生物量空间分布信息。
本次使用的路线是后者，遥感技术估算方法，利用LandSat-8卫星观测的数据，使用各种算法使用各波段对生物量构建拟合模型并训练，得到拟合效果较好的模型，反演森林地上生物量（AGB）。
二、 变量提取 使用ENVI根据下列植被指数计算公式使用Band Math公式计算出五个所选指数，这里选取的五个植被指数分别为ARVI、NDVI、SR、OSAVI和VIGreen五个指数，得到了五幅影像，如下所示。
这次选择ARVI、NDVI、OSAVI、SR和VIGreen植被指数作为参数反演。
使用ENVI软件对遥感图像做纹理特征计算，计算其Mean、Variance、Homogeneity、Contrast、Dissimilarity、Entropy、Second Moment以及Correlation，得到八幅图像。
Mean Homogeneity 在这里只展示两幅图像。
三、样点提取 使用Matlab对预处理好的遥感影像数据、纹理数据和AGB实测值选取相应的随机同名像点，本次选取了556个点构成模型训练的训练集与验证集。
提取到的点 clear; AGB_data=readgeoraster("AGB_lidarplots.tif"); ARVI_data=readgeoraster("ARVI.tif"); VIGreen_data=readgeoraster("VIGreen.tif"); NDVI_data=readgeoraster("NDVI.tif"); SR_data=readgeoraster("SR.tif"); OSAVI_data=readgeoraster("OSAVI.tif"); Multi_data=readgeoraster("Multispec_ref_layer_stack_clip_corre_allstudyarea_resam_AGB.tif"); Swir1=Multi_data(:,:,2); Nir=Multi_data(:,:,3); Red=Multi_data(:,:,4); Green=Multi_data(:,:,5); Blue=Multi_data(:,:,6); Coastal=Multi_data(:,:,7); texture_data=readgeoraster("texture_NIR.tif"); Mean=texture_data(:,:,1); Variance=texture_data(:,:,2); Homogeneity=texture_data(:,:,3); Contrast=texture_data(:,:,4); Dissimilarity=texture_data(:,:,5); Entropy=texture_data(:,:,6); SecondMoment=texture_data(:,:,7); Correlation=texture_data(:,:,8); x=randi(266,1,1000); y=randi(400,1,1000); AGB_selected=zeros(1,1000); SWIR1_selected=zeros(1,1000); NIR_selected=zeros(1,1000); RED_selected=zeros(1,1000); GREEN_selected=zeros(1,1000); Blue_selected=zeros(1,1000); COASTAL_selected=zeros(1,1000); NDVI_selected=zeros(1,1000); SR_selected=zeros(1,1000); OSAVI_selected=zeros(1,1000); ARVI_selected=zeros(1,1000); VIGreen_selected=zeros(1,1000); MEAN_selected=zeros(1,1000); Variance_selected=zeros(1,1000); Homogeneity_selected=zeros(1,1000); Contrast_selected=zeros(1,1000); Dissimularity_selected=zeros(1,1000); Entropy_selected=zeros(1,1000); SecondMoment_selected=zeros(1,1000); Correlation_selected=zeros(1,1000); for i=1:size(x,2) xi=x(1,i); yi=y(1,i); if xi==0 || yi==0 xi=1; yi=1; end AGB_selected(1,i)=AGB_data(xi,yi); SWIR1_selected(1,i)=Swir1(xi,yi); NIR_selected(1,i)=Nir(xi,yi); RED_selected(1,i)=Red(xi,yi); GREEN_selected(1,i)=Green(xi,yi); Blue_selected(1,i)=Blue(xi,yi); COASTAL_selected(1,i)=Coastal(xi,yi); NDVI_selected(1,i)=NDVI_data(xi,yi); SR_selected(1,i)=SR_data(xi,yi); OSAVI_selected(1,i)=OSAVI_data(xi,yi); ARVI_selected(1,i)=ARVI_data(xi,yi); VIGreen_selected(1,i)=VIGreen_data(xi,yi); MEAN_selected(1,i)=Mean(xi,yi); Variance_selected(1,i)=Variance(xi,yi); Homogeneity_selected(1,i)=Homogeneity(xi,yi); Contrast_selected(1,i)=Contrast(xi,yi); Dissimularity_selected(1,i)=Dissimilarity(xi,yi); Entropy_selected(1,i)=Entropy(xi,yi); SecondMoment_selected(1,i)=SecondMoment(xi,yi); Correlation_selected(1,i)=Correlation(xi,yi); end %输出到excel中 data=cell(1000,20); %title={'AGB','SWIR1','NIR','RED',"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00c9b9238de032b5a8fca4be0f6e6f8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681bdc97d9696aef224f6393e30df9ee/" rel="bookmark">
			BS和CS分别是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BS（Business-to-Server）和 CS（Client-Server）是两种常见的系统架构模式。
1. BS（Business-to-Server）：
- BS 架构是一种将业务逻辑主要放置在服务器端的架构模式。
- 在 BS 架构中，客户端（一般是浏览器）负责展示界面，接收用户输入，然后将用户请求发送给服务器。
- 服务器端负责处理业务逻辑，包括数据处理、计算、存储等，并将结果返回给客户端展示。
- BS 架构可以简化客户端的业务逻辑，使客户端变得轻量化，主要负责展示和用户交互的功能。
- 常见的 BS 架构应用包括 Web 应用程序，例如使用浏览器访问的网站、基于 Web 的管理系统等。
2. CS（Client-Server）：
- CS 架构是一种将业务逻辑主要分布在客户端和服务器端的架构模式。
- 在 CS 架构中，客户端负责展示界面、用户交互和部分业务逻辑处理。
- 服务器端负责处理业务逻辑的一部分，例如数据存储、安全验证、复杂计算等。
- 客户端和服务器之间通过网络进行通信，交换数据和请求。
- CS 架构可以灵活分配业务逻辑，可以在客户端和服务器端分别处理适合的部分。
- 常见的 CS 架构应用包括桌面应用程序、移动应用程序、游戏客户端等。
总结：
- BS 架构将业务逻辑主要放置在服务器端，客户端主要负责展示和用户交互，适用于 Web 应用程序等场景。
- CS 架构将业务逻辑分布在客户端和服务器端，灵活地处理适合的业务逻辑部分，适用于桌面应用程序、移动应用程序等场景。
- 选择 BS 架构还是 CS 架构，取决于具体的应用需求、业务逻辑复杂性、数据安全性要求和用户体验等因素。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d770589e64814eb9d4eae38af74d1f/" rel="bookmark">
			如何在 Windows 10 家庭版中启用 Windows 沙盒功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从 Windows 10 内部版本 18305 开始，Microsoft 引入了 Windows Sandbox。Windows Sandbox 是一个新的轻量级桌面环境，专门用于隔离运行安全的应用程序。您下载了多少个可执行文件，但又害怕运行它？您是否曾经遇到过需要全新安装 Windows 但又不想设置虚拟机的情况？
在 Microsoft，他们经常遇到这些情况，因此他们开发了 Windows Sandbox：一个隔离的桌面环境，您可以在其中运行不受信任的软件，而不必担心会对设备造成持久的影响。Windows 沙箱中安装的所有软件仅保留在沙箱中，不会影响您的主机。关闭 Windows 沙箱后，所有软件及其所有文件和状态将被永久删除。
启用 Windows 沙盒后，将自动创建一个没有驱动器号的只读 8 GB PortableBaseLayer 系统分区，并且不应将其删除。禁用 Windows 沙箱后，将自动删除 PortableBaseLayer 分区。
Windows 沙盒具有下列属性： Windows 的一部分： Windows 10 专业版和企业版中包含了此功能所需的全部内容。 无需下载 VHD。
Pristine：每次运行 Windows 沙盒时，它都是 Windows 全新安装的全新安装。
可处置：设备上不存在任何内容。 当用户关闭应用程序时，所有内容都会被丢弃。
安全：使用基于硬件的虚拟化进行内核隔离。 它依赖 Microsoft 虚拟机管理程序来运行隔离来自主机的 Windows 沙盒的单独内核。
高效： 使用集成的内核计划程序、智能内存管理和虚拟 GPU。
使用功能的先决条件 Windows 10 专业版、企业版或教育版内部版本18305或更高版本 目前在家庭 sku 上不受支持 (Windows 沙箱)
AMD64 体系结构
BIOS 中启用的虚拟化功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0d770589e64814eb9d4eae38af74d1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fb3a710efa225ace73b0ad66af71e1e/" rel="bookmark">
			前端---【Node.JS的fs(文件系统)操作模块】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. nodeJS fs模块介绍
二. fs文件系统的操作
2.1 文件写入
2.2文件写入方法 2.2.1 writeFile 异步写入
2.2.2 writeFileSync 同步写入
2.2.3 appendFile / appendFileSync 追加写入
2.2.4 createWriteStream 流式写入
2.2.5 写入文件的场景
2.3 文件读取
2.3.1异步读取
2.3.2 同步读取
2.3.3 流式读取
2.3.4 读取文件应用场景
2.4 文件重命名与移动
2.4.1文件重命名
2.4.2 文件移动
2.5文件删除
2.6文件夹操作
2.6.1创建一个新的文件夹
2.6.2读取文件夹
三. 路径
3.1相对路径
3.2绝对路径
3.3 __dirname
一. nodeJS fs模块介绍 概念解释:fs 全称为 `file system`，称之为`文件系统`，是 Node.js 中的`内置模块`，可以对计算机中的磁盘进行操作。
本章节会介绍如下几个操作：
1. 文件写入2. 文件读取3. 文件移动与重命名4. 文件删除5. 文件夹操作6. 查看资源状态 二. fs文件系统的操作 2.1 文件写入 文件写入就是将`数据`保存到`文件`中，我们可以使用如下几个方法来实现该效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fb3a710efa225ace73b0ad66af71e1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b80c19c379a2ed60be1c98648bfd21b/" rel="bookmark">
			前端---【Vue2基础props子传父】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
props实现子传父
1.1props的由来：
1.2.props的子传父
1.3props子传父举例实现：
props实现子传父 1.1props的由来： Vue官网文档这样描述props，早些时候，我们提到了创建一个博文组件的事情。问题是如果你不能向这个组件传递某一篇博文的标题或内容之类的我们想展示的数据的话，它是没有办法使用的。这也正是 prop 的由来。
1.2.props的子传父 数据在哪里，修改数据的方法就在哪里，或者说：只有数据的拥有者，才能修改数据。
具体实现：
父先给子传递一个函数。
子收到函数后，在合适的时候调用函数，并传递参数，从而实现：子传父。
1.3props子传父举例实现： 前置知识 ，需要有安装过vue脚手架环境;我们这边默认vue脚手架环境已经安装成功，我们需要对项目进行初始化npm init。在src源码目录下创建两个文件。
好的我们开始了。 第一步 在src的根目录下创建App.vue父文件 src/app.vue
第二步 创建子文件 src/component/Person.vue
我们回顾下组件的概念：组件=结构+交互+样式
结构：就是&lt;template&gt;&lt;/template&gt;之间的内容，可以把它想象成一个骨架。交互：&lt;script&gt;&lt;/script&gt;之间的内容，用户可以点击有效果的。样式：&lt;style&gt;&lt;/style&gt; 之间的内容，这里可以想象是网页化妆。 第一步的文件： src/app.vue(父组件)
&lt;template&gt; &lt;div class="app"&gt; &lt;h1&gt;我是今天也在码前端-霖， 我叫父组件&lt;/h1&gt; &lt;!-- 向Person组件传递str和updateStr prop --&gt; &lt;Person :str="str" :updateStr="updateStr" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Person from "./components/Person"; export default { name: "App", // 组件名称 components: { //注册Person子组件 Person, }, data() { return { str: "我是APP父组件", // 定义str数据 }; }, methods: { // 定义updateStr方法,更新str数据 updateStr(value) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b80c19c379a2ed60be1c98648bfd21b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a3988b3d4df10e11c42f3cc7e26bd76/" rel="bookmark">
			mysql更新关联字段问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 ### 表结构 CREATE TABLE `wjf_test_update_num` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `num1` int(11) DEFAULT NULL, `num2` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 | ## 插入两行数据 insert into wjf_test_update_num values (null,1,2); insert into wjf_test_update_num values (null,1,2); select * from wjf_test_update_num; +----+------+------+ | id | num1 | num2 | +----+------+------+ | 1 | 1 | 2 | | 2 | 1 | 2 | +----+------+------+ ## 更新语句1 update wjf_test_update_num set num2=num2+1,num1=num1+num2 where id = 1; ## 更新语句2 update wjf_test_update_num set num1=num1+num2,num2=num2+1 where id = 2; ### 结果 select * from wjf_test_update_num; +----+------+------+ | id | num1 | num2 | +----+------+------+ | 1 | 4 | 3 | ----set语句里的字段顺序影响到了最后的结果 | 2 | 3 | 3 | +----+------+------+ 官方说明： https://dev.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a3988b3d4df10e11c42f3cc7e26bd76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c8a842a99fb5bea791ecf4040d9e3e/" rel="bookmark">
			Qt源码阅读(四) 事件循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件系统 文章为本人理解，如有理解不到位之处，烦请各位指正。🙋‍♂️
文章目录 事件系统什么是事件循环？事件是如何产生的？事件是如何处理的？sendEventpostEvent 事件循环是怎么遍历的？事件过滤器夹带私货时间 Qt的事件循环是所有Qt开发者都无法避免的一个重要概念。因此，本篇博客将介绍Qt源码中与事件循环相关的部分，帮助读者更好地理解Qt事件循环的机制。
在深入源码之前，先抛出几个问题。随后，我们将通过源码，逐一解析，揭开事件循环的面纱。
事件循环是什么？事件是怎么产生的？事件是如何处理的？ 什么是事件循环？ 在ChatGPT💬上搜索到的概念是：
在Qt中，事件循环是一种机制，用于处理各种异步事件。事件循环通过一个事件队列来管理和调度事件，当队列中有事件时，事件循环会从队列中依次取出事件并处理，直到队列为空或者事件循环被中断。
事件的产生可以是用户输入、系统信号、网络请求、定时器等，Qt提供了一系列的事件处理函数和信号槽机制，可以方便地将这些事件与具体的操作相绑定。
因此，Qt的事件循环机制是Qt应用程序实现异步响应和多线程编程的基础。
个人理解，Qt的事件循环是通过一个队列来循环处理事件的机制。当队列中有事件时，事件循环会处理事件；如果队列中没有事件，则事件循环会阻塞等待。
事件是如何产生的？ 事件的产生可以分为两种：
程序外部产生：指系统产生的事件，例如鼠标按下（MouseButtonPress）、按键按下（KeyPress）等。Qt通过捕捉系统事件，将其封装成自己的QEvent类，再将事件发送出去。
程序内部产生：指在代码中手动创建一个事件，然后通过sendEvent/postEvent将事件发送到事件循环中。其中，sendEvent是阻塞型的发送方式，会等待事件处理完成后再继续执行；而postEvent是非阻塞型的发送方式，会将事件放入事件队列中，并立即返回。
事件是如何处理的？ 让我们通过一个流程图简单了解事件从发出到处理的过程。
在接下来的解析中，我们将通过分析源代码，逐步验证流程图中的每个步骤。请各位读者耐心继续往下阅读😏
下面我们将通过分析源码，来揭秘为什么sendEvent/postEvent是阻塞和非阻塞的、以及事件的处理流程。
sendEvent 首先，我们看sendEvent：
bool QCoreApplication::sendEvent(QObject *receiver, QEvent *event) { // sendEvent是阻塞调用 Q_TRACE(QCoreApplication_sendEvent, receiver, event, event-&gt;type()); if (event) event-&gt;spont = false; return notifyInternal2(receiver, event); } 可以看到，sendEvent是调用了notifyInternal2这个函数
bool QCoreApplication::notifyInternal2(QObject *receiver, QEvent *event) { ... // Qt enforces the rule that events can only be sent to objects in // the current thread, so receiver-&gt;d_func()-&gt;threadData is // equivalent to QThreadData::current(), just without the function // call overhead.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c8a842a99fb5bea791ecf4040d9e3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f8e1576ccad1679b07a82c0fb8af2d8/" rel="bookmark">
			mysql查询结果返回e9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 MySQL 数据库时，我们经常会进行查询操作。然而，有时候我们会发现，查询结果返回的数值中会有一个奇怪的字符“e9”，这个字符代表的是科学计数法中的10的9次方，也就是十亿。那么，为什么会出现这个字符，该如何解决呢？下面我们一起来探讨。
SELECT * FROM table_name WHERE column_name = 'value'; 以上是简单的 SQL 查询语句，其中“value”为需要查询的值。如果在查询结果中出现了“e9”，那么说明该列的数据类型为 BIGINT，且数据极大， 超出了 MySQL 可以表示的范围，因此返回了科学计数法的结果。 解决方法有两种：
1. 将数据类型改为更大的数据类型（例如 DECIMAL 或 FLOAT） 这样就可以避免数据在 MySQL 中溢出，不会出现“e9”的情况。但是需要注意的是，需要根据具体的需求，选择合适的数据类型，以免出现数据精度问题。
2. 在查询结果中使用 FORMAT() 函数 格式化函数 FORMAT() 可以将科学计数法的数据转换为常规格式，并可以自定义小数点位数、千位分隔符等。使用方法如下：
SELECT FORMAT(column_name, digits) FROM table_name; 其中，digits 为小数点后位数。 例如：
SELECT FORMAT(column_name, 2) FROM table_name; 以上语句可以将查询结果中的科学计数法转换为小数点后两位的浮点数格式。 总之，出现“e9”的情况并不是什么大问题，只需要根据具体情况选择合适的解决方法即可。希望本文可以帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d75013fd3886ed5f78066894dfcc66/" rel="bookmark">
			基于Vue3&#43;Element-Plus的拖拽式表单设计器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： 在项目开发中，总少不了各类表单的设计，常规开发中总是复制粘贴，包括各种校验规则，提交表单获取列表等操作。一个好的表单设计器可以很好的解决这些问题。
AK-Design拖拽式表单设计器 AK-Design 是一个纯前端的拖拽式、可视化、低代码数据可视化设计器开发平台，主包括表单设计、列表页设计、流程设计、数据可视化大屏设计、数据统计设计
使用基于 Vue 3.x 的桌面端组件库 Elemnet-Plus ，使用广泛，扩展方便
通过可视化的操作，可轻松快速完成表单设计、列表页设计、流程管理设计、数据可视化屏设计、数据统计设计等页面的创建
提供功能强大的各类组件，可适用在各种复杂的场景中
代码简洁、易于二次开发
演示地址：https://337547038.github.io/vue-form-design/
git源码：https://github.com/337547038/vue-form-design
表单设计器 支持各种常见表单组件、页面布局、富文本编辑器、扩展自定义组件等，适用于各种复杂场景。轻松拖拽，快速实现
列表设计 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e93c17085a1209761a9aa17b9d1e08b5/" rel="bookmark">
			第五届字节跳动青训营后端基础班笔试编程题题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端基础班的编程第一题很明显是力扣原题：997. 找到小镇的法官
leetcode.cn/problems/fi…
思路 除了力扣官方的题解外，我们还能进一步优化如下（可能更适合小白）：
1.如果存在法官，那么所有人都会信任法官，再结合条件1，可以得出信任法官的人数为n-1。
2.如果不存在法官，那么也可能存在某些人被所有人信任，这个人的信任人数也为n-1，但是他也会信任别人。
3.以此来区分other和judge。假设每个人都有信任值，那么定义一个数组长度为n，用来存放n个人的信任值:
1)如果一个人信任了别人，那么将这个人的信任值-1
2)如果一个人被别人信任，那么这个人的信任值＋1
当一个人被所有人信任，并且他没有信任其它人时，这个人的信任值就是n- 1，那么此人就是法官。
当一个人被所有人信任，但是他也信任了其他人时，这个人的信任值&lt;n - 1。
代码 public int findJudge(int N, int[][] trust) { int []trusted = new int[N]; for (int [] arr : trust){ trusted[arr[0]-1]--; trusted[arr[1]-1]++; } for (int i=0;i&lt;N;i++){ if (trusted[i]==N-1){ return i+1; } } return -1; } 小孩排队（一个圈） 其实就是小孩排队问题
// 从右往左冒泡 // @s 小孩队列 // @move 该移动的小孩，'B'为男孩，'G'为女孩 public static int bubbleCount(char[] s, char move) { int count = 0; for (int i = 0; i &lt; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e93c17085a1209761a9aa17b9d1e08b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd153eab0ba0be02290252436732fe0/" rel="bookmark">
			[SSTI自动化工具]TPLMap安装&amp;使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍：Tplmap通过多种沙盒转义技术协助利用代码注入和服务器端模板注入漏洞，以访问底层操作系统。开发该工具及其测试套件是为了研究SSTI漏洞类，并在web应用程序渗透测试中用作攻击性安全工具。
它可以利用多种代码上下文和盲注入场景。它还支持Python、Ruby、PHP、Java和通用的非沙盒模板引擎中类似eval（）的代码注入。
下载地址： [SSTI]TPLMap
安装教程：
Step1.首先将压缩包解压，然后进入其目录创建一个虚拟Venv环境
python -m venv vv_tplmap Step2.进入对应的Venv虚拟环境,对Venv虚拟环境有疑问的可以看完之前的博客
CMD : vv_tplmap\Scripts\activate.bat PowerShell : vv_tplmap\Scripts\Activate.ps1 Step3.安装对应的依赖
pip install -r requirements.txt -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com pip install pyyaml -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com pip install requests -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com 使用说明
Usage: python tplmap.py [options]
选项:
-h, --help 显示帮助并退出
目标:
-u URL, --url=URL 目标 URL
-X REQUEST, --re.. 强制使用给定的HTTP方法 (e.g. PUT)
请求:
-d DATA, --data=.. 通过POST发送的数据字符串 它必须作为查询字符串: param1=value1&amp;param2=value2
-H HEADERS, --he.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bd153eab0ba0be02290252436732fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e8b21f6fc908fc8ab1898cee7078516/" rel="bookmark">
			【C&#43;&#43;】枚举enum使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.什么是枚举enum(WHAT)
二.使用枚举enum的场景(WHEN and WHERE)
三.如何使用枚举enum(HOW)
1）枚举的定义
2）枚举的初始化
3）指定枚举类型 4)声明枚举对象
5)枚举对象赋值问题
6）枚举的取值范围
四.枚举enum的应用
一.什么是枚举enum(WHAT) 枚举(enumeration)和类相似，能够定义一种新的数据类型，不同的是，枚举是将一组整形常量组织在一起，所以和类的使用方法有一些类似之处。
二.使用枚举enum的场景(WHEN and WHERE) 实际中经常使用枚举来做数据的标识，可以实现对数据的分类，打个比方类似于用Ture和False区分是与非，而枚举也可以在此基础上也用整形常量的方式对数据进行更多的分类。
三.如何使用枚举enum(HOW) 1）枚举的定义 1.不限定作用域的枚举
enum color { RED, GREEN, BLUE }; 2.限定作用域的枚举 在enum后面加关键字class或者struct
enum class color { RED, GREEN, BLUE }; 3.二者区别 解决枚举值重名的问题，保持代码的可读性
//定义两种枚举 enum class color_inner { RED, GREEN, BLUE }; enum color_out { RED, GREEN, BLUE }; //声明并赋值 color_out backColor = RED; //正确 color_inner forntColor = RED; //错误，默认使用了out中的RED，没有指定作用域 color_out backColor = color_out::RED; //正确，out也可以显示指定作用域 color_inner forntColor = color_inner::RED; //正确，inner必须指定作用域 2）枚举的初始化 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e8b21f6fc908fc8ab1898cee7078516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c121d0b4d0cae641024c38ec921fe95f/" rel="bookmark">
			Windows 开机自动执行bat脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 打开“我的电脑”，地址栏输入
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup 按回车进入该目录，将需要开机立即执行的bat脚本放入该目录下即可。
注意：该脚本也仅仅是临时的，一次性的，如果你在脚本里边设置了环境变量，那也仅在这个脚本里边有效，不会全局有效。
如果要设置全局变量，可使用 setx 进行设置，例如设置java_home：
SETX /M JAVA_HOME "D:\Program Files (x86)\Java\jdk1.8.0_181" 通过 setx 设置的环境变量是写入到注册表中的，所以设置完成后，在系统环境变量中是可以看到的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89274fcb7ec5422cea23ef2251d47395/" rel="bookmark">
			小程序 uView-ui u-popup打开关闭延迟问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uView-ui 为 1.8.8 版本，具体问题是在真机上时，点击打开弹窗会有几秒钟的延迟，很影响体验，这个问题暂时只在安卓机有出现
经过源码排查发现是uView-ui的popup在打开时会添加一个定时器，给一定的组件渲染时间，再让遮罩和弹窗的动画起作用，默认过渡时间是250毫秒
因为u-popup 用到的地方太多了，没办法二次封装，只能改动源码
具体改动：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96afa8ed6bddf885793bcb0896baa3a1/" rel="bookmark">
			Python采集某网站文档，并保存word格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽兄弟们
我们平常需要下载文档的时候，是不是发现，要么不能下载，要么不能复制，就能难受。
常见的文档网站很多，但是这里就不一一说名字了，emmm
那么我们今天来分享一下，如何用Python将这些不给下载的文档给批量下载下来。
你需要准备
开发环境
python 3.8 pycharm 模块使用
两个需要安装的第三方模块，安装命令也写出来了。
requests --&gt; pip install requests re base64 docx --&gt; pip install python-docx 本文实现思路
一、数据来源分析
明确需求
明确采集网址以及数据内容是什么?
网址: https://www.***.com/p-3282300896.html
数据: 文档内容抓包分析, 我们需要数据内容是可以请求那个链接能够得到
文档形式: 图片样式
通过浏览器自带工具: 开发者工具抓包
打开开发者工具: F12 / 右键点击检查选择network
刷新网页
开发者工具搜索: docinpic
文档图片数据
链接: http://221.122.117.73/docinpic.jsp
sid: P1ekRarOT5ID*deCCfQPHapgA9Z5X3NNn0xfBxPIDApUnSY9yIVtfuxey1BsO1BG &lt;获取&gt;
file: 文档ID &lt;可以自己获取&gt;
width: 图片分辨率
pageno: 页码 &lt;可以用for循环&gt; 二、代码实现步骤
发送请求, 模拟浏览器对于 文档页面url地址 发送请求
请求链接: https://www.***.com/p-3282300896.html获取数据, 获取服务器返回响应数据解析数据, 提取我们需要的内容:
sid参数 / 文档页数 / 文档名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96afa8ed6bddf885793bcb0896baa3a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/048acd8d62905947a995baf2ccc14e21/" rel="bookmark">
			如何使用Python和sqlite3构建一个轻量级的数据采集和分析平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 数据采集和分析是当今时代的一项重要技能，它可以帮助我们从互联网上获取有价值的数据，并对其进行处理和挖掘，从而获得有用的信息和洞察。但是，数据采集和分析并不是一件容易的事情，它需要我们掌握各种工具和技术，如爬虫、数据库、编程语言、统计方法、可视化工具等。
在本文中，我们将介绍如何使用Python和sqlite3构建一个轻量级的数据采集和分析平台，它可以让我们方便地爬取、存储、查询、处理和展示数据，而无需安装复杂的数据库服务器或其他软件。我们将使用Python作为主要的编程语言，它是一种简洁、优雅、易学、功能强大的语言，广泛应用于数据科学领域。我们将使用sqlite3作为主要的数据库系统，它是一种嵌入式的关系型数据库，它可以将整个数据库存储在一个单独的文件中，而无需配置或管理任何服务器。我们还将使用一些Python的第三方库，如requests、BeautifulSoup、pandas、numpy、matplotlib等，来辅助我们进行数据采集和分析。
本文的目的是让你了解Python和sqlite3的基本用法和特点，以及如何结合它们进行数据采集和分析。本文不涉及太多的细节和高级功能，如果你想深入学习，请参考相关的文档和教程。本文假设你已经具备一定的Python和SQL基础知识。
正文 创建和连接数据库 首先，我们需要创建一个数据库文件来存储我们采集到的数据。我们可以使用Python自带的sqlite3模块来实现这一步骤。sqlite3模块提供了一个connect()函数，它可以接受一个文件名作为参数，并返回一个Connection对象，表示与数据库的连接。如果文件名不存在，则会自动创建一个新的数据库文件。例如：
import sqlite3 conn = sqlite3.connect("data.db") 这样就创建了一个名为data.db的数据库文件，并建立了与之的连接。我们可以通过Connection对象来执行各种操作，如创建表、插入数据、查询数据等。为了方便操作，我们还可以创建一个Cursor对象，它是一个用于执行SQL语句并获取结果的游标。例如：
cur = conn.cursor() 创建表 接下来，我们需要在数据库中创建一些表来存储我们采集到的数据。表是由行和列组成的二维结构，每一行表示一条记录，每一列表示一个字段。每个表都有一个唯一的名字，并且每个字段都有一个类型和一个名字。sqlite3支持以下几种类型：NULL、INTEGER、REAL、TEXT、BLOB。
为了创建表，我们需要使用CREATE TABLE语句，并指定表名、字段名、字段类型等信息。例如：
cur.execute("CREATE TABLE news (id INTEGER PRIMARY KEY, title TEXT, content TEXT, url TEXT, source TEXT, date TEXT)") 这样就创建了一个名为news的表，并定义了六个字段：id、title、content、url、source、date。其中id字段是主键，表示每条记录的唯一标识符；title字段是文本类型，表示新闻标题；content字段是文本类型，表示新闻内容；url字段是文本类型，表示新闻链接；source字段是文本类型，表示新闻来源；date字段是文本类型，表示新闻日期。注意，每条SQL语句都需要以分号结尾。
我们可以使用PRAGMA table_info()语句来查看表的结构信息，例如：
cur.execute("PRAGMA table_info(news)") print(cur.fetchall()) 这样就可以打印出表的结构信息，如字段名、字段类型、是否主键等。输出结果如下：
[(0, 'id', 'INTEGER', 0, None, 1), (1, 'title', 'TEXT', 0, None, 0), (2, 'content', 'TEXT', 0, None, 0), (3, 'url', 'TEXT', 0, None, 0), (4, 'source', 'TEXT', 0, None, 0), (5, 'date', 'TEXT', 0, None, 0)] 爬取数据 创建好表之后，我们需要从互联网上爬取一些数据来填充我们的表。为了爬取数据，我们需要使用Python的第三方库requests和BeautifulSoup来实现。requests库可以让我们方便地发送HTTP请求并获取响应内容；BeautifulSoup库可以让我们方便地解析HTML文档并提取所需的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/048acd8d62905947a995baf2ccc14e21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb87b3c4bd9461e2617cd6de41233e61/" rel="bookmark">
			微信小程序背景渐变写法加占比以及微信小程序开发过程中长使用的代码段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写微信小程序的过程中，ui设计了一个渐变的背景图，网上一搜很多都只写了怎么样让微信渐变色，但是我的需求就是渐变色而且控制渐变色范围，比如三个颜色一个头部是深蓝，中间浅蓝，最底下是白色，那么直接套用网上的列子（第一段代码），三个色渐变范围是一样的不是很好，我希望的效果是深蓝色占一小部分，浅蓝色占一半，其余的都是白色那么怎么写呢，我们需要给每个颜色占比设置大小，代码如（第二段代码）
（1）代码段一渐变色（写在app.wxss文件中） page { font-family: Monospaced Number, Chinese Quote, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Helvetica, Arial, sans-serif !important; background: -webkit-linear-gradient(top, #1f70c9, #02b0ea, #f2f2f2); background-repeat: no-repeat; } （2）代码段二 （重点在颜色后面的百分比） page { font-family: Monospaced Number, Chinese Quote, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Helvetica, Arial, sans-serif !important; background: -webkit-linear-gradient(top, #1f70c9 10%, #02b0ea 40%, #f2f2f2 60%); background-repeat: no-repeat; } （3）if用法 wx:if="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb87b3c4bd9461e2617cd6de41233e61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f5dbc0abefc5c49582154f78e8f4c9c/" rel="bookmark">
			卷积神经网络：LeNet网络手写数字识别代码实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 LeNet-5详解及代码实现LeNet模型Lenet的pytorch实现搭建LeNet-5网络加载数据集训练网络自己手写的数字处理测试自己手写的数字完整代码 LeNet-5详解及代码实现 LeNet是在1998年LeCuu等人提出来的，用于解决手写数字识别的视觉任务，被认为是卷积神经网络的开创性工作，是卷积神经网络的祖师爷，是深度学习领域的里程碑，自那时起，CNN的最基本的架构就定下来了：卷积层、池化层、全连接层。论文地址：Gradient-Based Learning Applied to Document Recognition
LeNet模型 LeNet5网络包含了深度学习的基本模块：卷积层，池化层，全连接层。
LeNet5共有7层，不包含输入，每层都包含可训练参数；每个层有多个Feature Map，每个FeatureMap通过一种卷积滤波器提取输入的一种特征，然后每个FeatureMap有多个神经元。
论文中用的数据集输入大小为单通道，32×32大小的图片。
本次实践采用MNIST 数据集，可在 http://yann.lecun.com/exdb/mnist/ 获取，也可以通过pytorch代码。MNIST数据集输入大小为单通道，28×28大小的图片。因此实践中的LeNet，特征图大小与论文不一致，如下表所示。
操作论文的输出尺寸实践的输出尺寸input1, 32, 321, 28, 28）conv16, 28, 286, 24, 24）pool16, 14, 146, 12, 12）con16, 10, 1016, 8, 8）pool216, 5, 516, 4, 4fc1120120fc28484fc31010 Lenet的pytorch实现 实践加载的库
# 加载库 import torch import torch.nn as nn import torch.optim as optim import torchvision.datasets as datasets import torchvision.transforms as transforms import matplotlib.pyplot as plt from torchsummary import summary from PIL import Image 搭建LeNet-5网络 class LeNet5(nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f5dbc0abefc5c49582154f78e8f4c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4562d825adca5d930d9aa4a0f1840fb9/" rel="bookmark">
			【leetcode刷题之路】剑指Offer（3）——搜索与回溯算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 7 搜索与回溯算法7.1 【BFS】剑指 Offer 32 - I - 从上到下打印二叉树7.2【BFS】剑指 Offer 32 - II - 从上到下打印二叉树 II7.3 【BFS】【双端队列】剑指 Offer 32 - III - 从上到下打印二叉树 III7.4 【BFS】剑指 Offer 26 - 树的子结构7.5 【递归】剑指 Offer 27 - 二叉树的镜像7.6 【递归】【双指针】剑指 Offer 28 - 对称的二叉树7.7 【DFS】【回溯】【剪枝】剑指 Offer 12 - 矩阵中的路径7.8 【DFS】剑指 Offer 13 - 机器人的运动范围7.9 【DFS】【递归】剑指 Offer 34 - 二叉树中和为某一值的路径7.10 【DFS】【递归】【双指针】剑指 Offer 36 - 二叉搜索树与双向链表7.11 【DFS】剑指 Offer 54 - 二叉搜索树的第k大节点7.12 【DFS】剑指 Offer 55 - I - 二叉树的深度7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4562d825adca5d930d9aa4a0f1840fb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97dc3e457b067d4df7960a928e4559b/" rel="bookmark">
			echarts单个图表随屏幕放大或缩小自适应调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当页面放大 或者缩小时，页面中的图表不随页面变化而变化，需要刷新后才可以恢复到正常状态！！！
Vue中的ECharts图表随屏幕放大或缩小自适应调整，您可以使用ECharts提供的resize方法和Vue的生命周期函数来实现 。
在Vue组件中引入ECharts库，并在mounted生命周期函数中初始化和渲染图表 如下：
&lt;template&gt; &lt;div ref="chartContainer" style="width: 100%; height: 400px;"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import echarts from 'echarts'; export default { mounted() { this.chart = echarts.init(this.$refs.chartContainer); this.renderChart(); // 渲 染图表 }, methods: { renderChart() { // 使用this.chart绘 制图表 } } } &lt;/script&gt; 然后，您可以使用window的resize事件监听器来捕获屏幕大小的变化，并在变化时触发ECharts的resize方法进行图表的自适应调整。
&lt;script&gt; import echarts from 'echarts'; export default { data() { return { chart: null }; }, mounted() { this.chart = echarts.init(this.$refs.chartContainer); this.renderChart(); // 渲染图表 window.addEventListener('resize', this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e97dc3e457b067d4df7960a928e4559b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/52/">«</a>
	<span class="pagination__item pagination__item--current">53/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/54/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>