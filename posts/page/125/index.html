<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c7ef426173499d90c0a9829de183349/" rel="bookmark">
			PythonPyQt5限定input输入框只能输10以内的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间一个项目，要求输入框内只能输入10以内的整数，找了好久，终于摸索出解决问题的方法。
首先定义一个整数限定变量
int_num = QIntValidator() int_num.setRange(1, 10) input输入框设定如下
self.xx_input.setValidator(int_num) 这样就可以限定输入框的输入类型了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c7cd0c4dd007583abcac6fa749a571/" rel="bookmark">
			有序链表合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 两个有序的链表按照从小到大合并
思路 1.找出头节点小的链表作为最终返回的起始节点
2.两个节点分别指向小头的下一个节点，以及大头的头节点
3.定义pre指针，作为指向当前节点的指针
4.比较2中两个节点的大小，让pre指针指向这个节点，并让这个节点向后移动，循环往复。
5.最终当任何一个链表的next为空了，则pre的next指向不为空的链表，结束返回。
代码实现 public static ListNode mergeTwoListNode(ListNode node1,ListNode node2){ // 只要有一个为空就返回不为空的。 if (node1 == null || node2 == null){ return node1 == null ? node2 :node1; } // 找到头节点小的链表记为要返回的head。 ListNode head = node1.value &lt;= node2.value ? node1 : node2; // 记录小头链表的下一个节点。 ListNode cur1 = head.next; // 记录大头节点的下一个节点。 ListNode cur2 = head == node1 ? node2 : node1; // 记录移动指针。 ListNode pre = head; // 只要有一个链表为空了则跳出循环。 while (cur1 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95c7cd0c4dd007583abcac6fa749a571/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a34a744cbd64c626a7e13cbf22f689d4/" rel="bookmark">
			JAVA 简单练习——简单计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照蓝桥云课实验，Java实现简单的计算器，运算逻辑简单。
主要是为了熟悉Java 中的图形化编程，相较于MFC编程，简单清晰，注意对按键事件的注册和监听。
import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.math.BigDecimal; import java.security.Key; import java.util.Vector; public class Calculator { JFrame frame = new JFrame("Calculator"); String str1 = ""; String str2 = ""; String signal = ""; String result = ""; JButton store; Vector vt = new Vector(20, 10); //状态变量 int k1 = 1;// 开关1用于选择输入方向，将要写入str1或str2// 为 1 时写入 str1，为 2 时写入 str2 int k2 = 1;// 开关 2 用于记录符号键的次数//如果 k2&gt;1 说明进行的是 2+3-9+8 这样的多符号运算 int k3 = 1;// 开关3用于标识 str1 是否可以被清 0// 等于 1 时可以，不等于1时不能被清0 int k4 = 1;// 开关4用于标识 str2 是否可以被清 0// 等于 1 时可以，不等于1时不能被清0 int k5 = 1;// 开关5用于控制小数点可否被录入// 等于1时可以，不为1时，输入的小数点被丢掉 //所需组件 JTextField result_TextField = new JTextField(result,20); //清除按钮 JButton clear_Button = new JButton("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a34a744cbd64c626a7e13cbf22f689d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e13a5ef780c25661f56a1940b1017614/" rel="bookmark">
			国内服务器带宽价格是多少?国内服务器带宽为什么贵?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国内服务器方便、快捷、实用优势深受广大用户喜欢，但是国内服务器带宽价格被很多人所不喜，认为国内服务器带宽的价格过高。那么国内服务器带宽价格一般是多少呢?国内服务器带宽为什么贵呢?
1、国内服务器带宽价格是多少?
一般购买国内服务器的时候都建议2核起步，以某站为案例，国内服务器2核2G 2M带宽大概是182元一个月，一年价格为1820元。
而且公网带宽不同区域价格也不一样，国内服务器以阿里云和腾讯云为例，公网带宽以北京地域为例，一般1M带宽价格是23元/月，当带宽达到6M及以上时，每M带宽上涨到80元/月。
2、国内服务器带宽为什么贵?
①共享带宽而非独享
像阿里云、腾讯云提供的都是独享带宽，而有的时候用户看到的百兆带宽，实际上是共享带宽，在网络高峰时段根本达不到独享的效果。
②被垄断导致带宽价格贵
国内服务器带宽主要围绕三大运营商，电信、移动和联通，像阿里云、腾讯云都是租用运营商的带宽，垄断占有主导权，价格也就那样。
③带宽被浪费
网络上大多数的小网站，日均也就几百IP。由于带宽资源的浪费，很多时候用户用不到这么多带宽，打着百兆带宽的旗号，实际上是多租户模式。
④带宽价格受限于公网IP地址
服务器带宽网以阿里云为例，只要云服务器购买公网带宽，阿里云系统就会分配一个独享的公网IP地址给到云服务器。公网IPv4地址受美国控制，阿里云的IP地址也是向ICANN申请租来的。
⑤国外VPS限制流量
服务器带宽网看到国外很多VPS带宽动辄百兆，价格还很便宜，但是这是VPS，非服务器，很多情况是限制流量的。
⑥BGP网路线路
云服务器通过公网带宽对外提供服务时，要同时覆盖电信、移动、联通、铁通及教育网等运营商，无论用户使用哪个网络访问云服务器上的资源，都要满足快速高效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d713e8ec7593cb94721d1917d84534e3/" rel="bookmark">
			Excel如何快速提取单元格括号内数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下图，A列数据中含有一部分括号，现在先要快速将括号内内容提取出来。
将A列数据复制一份到B列中
全选B列所有单元格数据区域
点击下图选项（Excel工具箱，具体下载安装方法百度即可，本文不作详细解说）
点击【截取文本】
选择【截取中间文本】
在【起始】选项中勾选【从左数】，并在后面方框内输入“（”左括号
然后在【终止】选项中，勾选【从左数……】，并在后面方框内输入“）”右括号。然后点击【确定】
截取效果如下图，最后我们点击【退出】即可完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c77e5b75d9d691e062aca3d766156045/" rel="bookmark">
			QSPI协议详解(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.QSPI协议简介
QSPI是Queued SPI的简写，是Motorola公司推出的SPI接口的扩展，比SPI应用更加广泛。在SPI协议的基础上，Motorola公司对其功能进行了增强，增加了队列传输机制，推出了队列串行外围接口协议（即QSPI协议）。QSPI 是一种专用的通信接口，连接单、双或四（条数据线） SPI Flash 存储介质。
该接口可以在以下三种模式下工作：
① 间接模式：使用 QSPI 寄存器执行全部操作
② 状态轮询模式：周期性读取外部 Flash 状态寄存器，而且标志位置 1 时会产生中断（如擦除或烧写完成，会产生中断）
③ 内存映射模式：外部 Flash 映射到微控制器地址空间，从而系统将其视作内部存储器
采用双闪存模式时，将同时访问两个 Quad-SPI Flash，吞吐量和容量均可提高二倍。
1.1 QSPI功能框图
QSPI功能框图，双闪存模式禁止见图1。
我们的开发板采用的是双闪存禁止的模式连接单片QSPI Flash。QSPI 使用 6 个信号连接Flash，分别是四个数据线BK1_IO0~BK1_IO3，一个时钟输出CLK，一个片选输出（低电平有效）BK1_nCS，它们的作用介绍如下：
(1) BK1_nCS：片选输出（低电平有效），适用于 FLASH 1。如果 QSPI 始终在双闪存模式下工作，则其也可用于 FLASH 2从设备选择信号线。QSPI通讯以BK1_nCS线置低电平为开始信号，以BK1_nCS线被拉高作为结束信号。
(2) CLK：时钟输出，适用于两个存储器，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样，如STM32的QSPI时钟频率最大为fpclk/2，两个设备之间通讯时，通讯速率受限于低速设备。
(3) BK1_IO0：在双线 / 四线模式中为双向 IO，单线模式中为串行输出，适用于FLASH 1。
(4) BK1_IO1：在双线 / 四线模式中为双向 IO，单线模式中为串行输入，适用于FLASH 1。
(5) BK1_IO2：在四线模式中为双向 IO，适用于 FLASH 1。
(6) BK1_IO3：在四线模式中为双向 IO，适用于 FLASH 1。
QSPI命令序列
QUADSPI 通过命令与 Flash 通信 每条命令包括指令、地址、交替字节、空指令和数据这五个阶段 任一阶段均可跳过，但至少要包含指令、地址、交替字节或数据阶段之一。nCS 在每条指令开始前下降，在每条指令完成后再次上升。先看看QSPI四线模式下的读命令时序，见图2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c77e5b75d9d691e062aca3d766156045/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dad07683ddd7d530399f22029457bfd/" rel="bookmark">
			3种常见的渗透测试漏洞总结，快来收藏√
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		越权漏洞 越权访问（Broken Access Control，简称BAC）是Web应用程序中一种常见的漏洞，由于其存在范围广、危害大，被OWASP列为Web应用十大安全隐患的第二名。
所谓越权，顾名思义即超过当前用户的权力范围，越至不同用户或获得更高的系统权限的一类漏洞。
具体到应用当中，当服务器处理用户发起的请求时，没有对该用户的操作权限进行判定，从而导致不法分子利用该漏洞篡改用户信息，达到增删改查的目的。
该类漏洞在当前的测试中可通过Fiddler手工测试或Appscan自动扫描测试。越权漏洞一般可分为两类，即水平越权和垂直越权。
水平越权 水平越权是指角色权限相同的用户之间能非法地互相操作对方的数据。
例如，我们有用户A和用户B，可以通过Fiddler来代理抓包，截取用户A登录时的WEB请求报文，然后分析其Cookie、Uid等信息，通过将相关值篡改为用户B的信息，从而发掘该类漏洞。
垂直越权 垂直越权是指不同角色权限的用户之间能非法地互相操作对方的数据。
该类漏洞的测试原理同水平越权，区别为被篡改的目标用户B可能为系统管理员等更高权限的用户，从而达到获取不同层级权限的目的。
XSS跨站脚本漏洞 跨站脚本攻击XSS（Cross Site Scripting）是指恶意攻击者向Web页面里插入恶意Script代码，当用户浏览该页时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。
XSS漏洞可以理解为借彼之手、诱其上钩。该漏洞一般通过PHP的输出函数将Javascript代码输出到HTML中，通过用户本地浏览器执行，所以测试XSS漏洞关键就是寻找未过滤的输出函数。
在一般的研发实践中，通过查找常用函数如echo、print、var等来定位目标。具体XSS可以分为三类，分别为反射型XSS、存储型XSS、DOM型XSS。
反射型XSS 该类漏洞在实际操作中较为常见，攻击者通过使用带有恶意脚本的链接接触用户，由用户触发XSS来实现攻击。
主要步骤拆分：
①用户收到带有恶意脚本的链接；
②通过访问该目标抵达目标服务器；
③HTML展示预期内容同时将未过滤的用户输入记入XSS；
④该部分XSS恶意代码向恶意服务器发起请求；
⑤攻击者从恶意服务器获取用户原始输入。
存储型XSS 该类漏洞相对反射型更加隐蔽，攻击者绕开用户层预先在目标数据库铺底恶意脚本，实现用户被动触发进而实现信息窃取和后续攻击。
主要步骤拆分：
①攻击者在目标数据库预埋恶意XSS脚本；
②用户正常操作访问服务器并触发该部分XSS；
③HTML展示预期内容同时将未过滤的用户输入记入XSS；
④该部分XSS恶意代码向恶意服务器发起请求；
⑤攻击者从恶意服务器获取用户原始输入。
DOM型XSS 该漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，通过利用当前URL将返回的HTML静态文本写入DOM中的document当做JavaScrip代码执行，从而导致敏感信息泄露。
主要步骤拆分：
①类比反射型XSS攻击者给用户发送目标URL；
②用户访问目标服务器；
③服务器返回包含JavaScrip的HTML展示给用户；
④该部分XSS利用①中的URL返回给攻击者；
⑤攻击者获取敏感信息对目标发起攻击。
文件上传漏洞 文件上传类漏洞指文件上传功能模块或接口，未对文件类型、附件大小等信息进行校验，从而导致攻击者通过文件上传接口上传恶意文件。
如果上传的文件类型和访问权限不作控制，则攻击者可利用此漏洞上传恶意脚本或后门程序，获取服务器权限，控制服务器。
同时，也可达到消耗服务器资源使其拒绝服务进而瘫痪。
文件上传漏洞在测试中的关注要点：
关注是否限制了上传文件的大小，通过比对Post支持的大小来判断上传大文件是否会导致内存、磁盘耗尽从而拒绝服务。
关注上传文件类型是否进行了控制，通过修改文件名最后一个点号后面的后缀（包括点号）后做上传，判断是否可以绕过文件类型、扩展名等校验判断。
关注上传的文件存放路径安全性、上传目录解析、读取、下载等权限控制。
以上三类为渗透测试中较为常见的漏洞，也是研发过程中容易被忽视的地方。
工欲善其事，必先利其器。在针对漏洞的测试过程中，通过对Fiddler、Wireshark、Jmeter、Burpsuite等工具的应用可以在操作层面掌握截取、抓包、断点、篡改、再请求等操作，结合研发过程中的通用实践来判断程序结构和目标函数。
工具、知识及经验的不断积累与组合应用会助你更高效地开展渗透测试，发掘各类漏洞。
下面是一份配套资料，对于做【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴我走过了最艰难的路程，希望也能帮助到你！
这些都可以以在公众号：伤心的辣条 ！ 免费领取，还有一份216页软件测试工程师面试宝典文档资料。以及相对应的视频学习教程免费分享！，其中资料包括了有基础知识、Linux必备、Shell、互联网程序原理、Mysql数据库、抓包工具专题、接口测试工具、测试进阶-Python编程、Web自动化测试、APP自动化测试、接口自动化测试、测试高级持续集成、测试架构开发测试框架、性能测试、安全测试等。
学习不要孤军奋战，最好是能抱团取暖，相互成就一起成长，群众效应的效果是非常强大的，大家一起学习，一起打卡，会更有学习动力，也更能坚持下去。
喜欢软件测试的小伙伴们，如果我的博客对你有帮助、如果你喜欢我的博客内容，请 “点赞” “评论” “收藏” 一键三连哦！
好文推荐 转行面试，跳槽面试，软件测试人员都必须知道的这几种面试技巧！
面试经：一线城市搬砖！又面软件测试岗，5000就知足了…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dad07683ddd7d530399f22029457bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11adc6cae7a47b176ae3c31b7c4dd857/" rel="bookmark">
			强化学习笔记：Q_learning （Q-table）示例举例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 示例介绍 在右侧有宝藏，探险者到达宝藏所在的位置，就可以获得奖励
比如某一时刻的状态是这个样子的：“-o---T”
T 就是宝藏的位置, o 是探索者的位置
如果在某个地点 s1, 探索者计算了他能有的两个行为, Q(s1, a1) &gt; Q(s1, a2), 那么探索者就会选择 left 这个行为. 否则就是right
‘
参考内容：小例子 - 强化学习 (Reinforcement Learning) | 莫烦Python (mofanpy.com)
2 导入库&amp; 超参数设定 import numpy as np import pandas as pd import time np.random.seed(2) # 随机种子 N_STATES = 6 # 探宝者可能在的位置 ACTIONS = ['left', 'right'] # 探索者的可用动作 EPSILON = 0.9 # 贪婪度 greedy #0.9的概率选择最大的Q对应的action #0.1的概率随机选action ALPHA = 0.1 # 学习率 GAMMA = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11adc6cae7a47b176ae3c31b7c4dd857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9687a54fcc93e892bdc91fd9303cff9/" rel="bookmark">
			890行。设计最强最全学生成绩管理系统（C语言大作业）（文后附解析说明的博客）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周太忙，拖更了一期博客，这里先给大家赔个不是哈...
并再说明一下，大学进入期末月啦，笔者得专心复习，所以这个月更完这两期就不更了，等放寒假以后再和大家分享。
话不多说，进入正题，相信很多计算机专业的同学在这临近期末的时候，都遇见了类似的计算机大作业——设计信息系统。笔者收到的大作业具体要求如下：
不同学校的要求不尽相同，这里分享的是笔者的设计思想。
当然，如上要求对于不同的人来说难易感受也不同，不过尽可能严格要求自己吧，设计你能设计出的最好的系统，来证明给自己看——这学期真的收获很多很多。 这篇博客我将按照作业形式来写，可能稍显简略。详细的如何思考分析，实现过程，注意事项，知识分享都将在下一篇博客提到。
说明：在《C Prime Plus》中有提到编写C程序的7个步骤，从前往后分别是：定义程序的目标，设计程序，编写代码，编译，运行程序，测试和调试程序，维护和修改代码，说明。并指出许多初学者经常忽略第一步和第二步，直接开始编写代码，以致像编写这种”庞大”的大作业程序时，会写出一些非常难找的隐藏错误，跳过前期规划，往往找bug上花费了更多的时间。“因为他们写出的程序难看、缺乏条理、让人难以理解”。个人觉得十分在理，所以在作业的“结果分析”前加上了“功能的设计与分析”
正文：
四、功能的设计与分析
1、结合内容①⑦，皆为录入信息，但为给后续增加信息留够空间，所以开始可以定义一个很大的数组。但静态定义一个“用不完”的数组实在浪费空间，不如在堆上动态申请内存空间（malloc，calloc...），现学现用，用最好的。同时注意到录入的信息包括姓名、成绩。结合实际情况，成绩可分为多门科目的成绩，而信息还可添加性别，学号，总分，排名等，用好结构体，这些都可实现。
2、发现②其实被后面的多个功能包含，如排序、查找、输出总分大于指定分数的同学信息等，所以后续结合其他功能考虑。
3、③④皆为查找，结合我们将录入学号，还可通过学号查找。设计程序时可以考虑遍历结构体中的指定信息，与目标对比，一旦找到printf输出。
4、⑤排序，可降序就可升序，这也是可以添加的功能，这里想到学过的选择，冒泡排序。但提高对自己的要求，考虑用实现最复杂，但时间复杂度最小的快速排序实现。
5、⑥删除，开始想用数组存储信息，遍历找到需要删除的学生（数组元素），将其后的所有元素前移一位，覆盖掉需要删除的位置，达成目的。但这样做时间复杂度太高，所以考虑用新学的链表来实现。
6、⑧划定分数线，即遍历+判断语句，当判断总分比指定分数大时，printf输出。
7、关注实验里的额外要求，菜单调用。即printf出一个菜单，显示出各个选项，当输入选项时，可以采用switch语句，调用各个case中的具体函数中去。
8、增加功能。结合实际情况，一个成绩管理系统难免出现录入信息出错的地方，所以考虑增加修改信息的功能。而录入一次考试所有学生的信息后，大家往往会关注考试结果（不只是排名），这就需要统计功能，考虑增加统计平均分和各科考试情况的功能。
9、当使用者还未录入便选择查询、删除等操作时，程序肯定就不知道该怎么做了，所以还可以增加一些判断条件，解决不正确输入问题，提高程序容错率。
五、具体代码：
#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;windows.h&gt; int flag = 0, numstudent = 0, numcourse, choice;	//宏定义，变量声明 int* pc; typedef struct information	//结构体定义,每一个都代表着一个学生 { long int ID;//学号 char name[20];//姓名 char sex[10];//性别（男/女） int score[12];//各科分数 int total = 0;//总分 }information; typedef struct node	//链表嵌套调用“信息”结构体 { information data; node* next; }node; node* t, * head; //主要功能函数	//函数声明 int Input();//选项输入 void Enter();//信息录入 void Revise();//修改 void Delete();//删除 void Find();//查找 void Statistic();//统计 void Sort();//排序 void Total_Level();//划线查看 //辅助函数 void Menu();//菜单 void Tips();//提示功能函数 void Tips();//智能提示 int Legal_Check();//合法性检查 void Header1();//输入表头 void Header2();//输出表头 void Header3();//统计表头 void Swap();//交换 void Down_Sort();//降序排列 void Up_Sort();//升序排列 void Find_by_name();//姓名查找 void Find_by_ID();//学号查找 void Find_by_rank();//排名查找 void Find_by_total();//总分查找 void Play_On_Play();//“我为自己找事干”函数 void Course_Average();//统计平均分 void Tips(char a[]) { int i; for (i = 0; i &lt; strlen(a); i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9687a54fcc93e892bdc91fd9303cff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3289de7fe41cec9f5cd31f5388692ef/" rel="bookmark">
			【综合实训】数字图像处理——基于内容的图像检索系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要Abstract1 绪论1.1 课题研究背景1.2 课题研究目的与意义 2 系统设计2.1 图像检索系统框架2.2 图像检索系统展示 3 数据集处理3.1 数据预处理3.2 预处理结果展示 4 基于颜色特征的图像检索4.1 颜色直方图特征4.1.1 颜色直方图特征介绍4.1.2 颜色直方图特征提取步骤4.1.3 颜色直方图特征存储结果4.1.4 相似度度量方法4.1.5 检索结果展示 4.2 颜色中心矩特征4.2.1 颜色中心矩特征介绍4.2.2 颜色中心矩特征提取步骤4.2.3 颜色中心矩特征存储结果4.2.4 相似度度量方法4.2.5 检索结果展示 5 基于纹理特征的图像检索5.1 灰度共生矩阵法提取特征原理5.2 灰度共生矩阵法提取特征步骤5.3 灰度共生矩阵法特征存储结果5.4 相似度度量方法5.5 检索结果展示 6 基于形状特征的图像检索6.1 形状不变矩法提取特征原理6.2 形状不变矩法提取特征步骤6.3 形状不变矩法特征存储结果6.4 相似度度量方法6.5 检索结果展示 7 基于phash的图像检索7.1 感知哈希算法原理介绍7.2 phash算法哈希值计算步骤7.3 哈希值存储结果7.4 相似度度量方法7.5 检索结果展示 8 基于Hog和SVM的图像检索8.1 Hog特征介绍8.2 SVM算法介绍8.3 基于Hog和SVM特征值提取步骤8.4 Hog特征和模型存储结果8.5 检索结果展示 9 结果分析与心得体会9.1结果分析9.1.1颜色直方图和颜色中心矩的比较9.1.2纹理特征与形状特征的结果分析9.1.3 phash特征提取的结果分析9.1.4 Hog+SVM特征提取的结果分析9.1.5 欧氏距离和余弦相似度的结果分析 9.2 心得体会 参考文献 摘要 图像作为最基本，最重要的多媒体信息交流形式之一，已经随着信息技术和网络技术的发展，而越来越广泛地应用于人们的社会生活和工作密切相关的各个领域。人们希望能够利用图像自身的可视化特征对图像信息进行检索。
基于内容的图像检索系统（Content Based Image Retrieval, 以下简称 CBIR），是计算机视觉领域中关注大规模数字图像内容检索的研究分支。典型的 CBIR 系统，允许用户输入一张图像，在图像数据库（或本地机、或网络）中查找具有相同或相似内容的其它图片。本实训的基本功能要求是实现基于视觉特征的图像检索。具体包括：（1）实现基于颜色信息的图像检索，采用颜色直方图和颜色中心矩两种方法实现。（2）实现基于纹理特征的图像检索，采用了灰度共生矩阵法实现。（3）实现基于形状特征的图像检索，采用了形状不变矩法实现。（4）实现基于phash的图像检索。（5）实现HOG+SVM进行图片分类检索。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3289de7fe41cec9f5cd31f5388692ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dac4b7ea1b29cec5fe77ba6be61ee35/" rel="bookmark">
			抖音云控PHP 18.7框架图 autojs脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://idouq.lanzouo.com/i8iznx9km1a
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc2ad9475488ae48c10d74ab6a6aec1f/" rel="bookmark">
			python:如何对float保留两位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：
round(f,2)并不会保留两位小数，只是四舍五入，然后会去掉最后的0，只能保证最多不超过两位小数
因此，要用格式化输出，这里提供一种方案
解决方法：
print(f’ {x:.2f} ')
代码：
print(f' Cash | 1 | {cash:.2f} | {cash:.2f}') 看看结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d6f5c59a48f20c401b0c0d53cd6723a/" rel="bookmark">
			分享一个Python写的恶搞代码，给对方无限自动发送消息，就是容易挨打
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上班闲的没事，想找找乐子，于是整了个简易版的自动发消息小代码。
安装模块
在开始前，我们先得安装一下这个叫 pynput 的模块，win+R打开运行框，输入cmd。
点击确定弹出命令提示符窗口，输入 pip install pynput ，然后按回车，像我这样就安装成功了。
代码展示
我们直接来看代码
from pynput.mouse import Button, Controller as mouse_Controller from pynput.keyboard import Key, Controller as key_Controller import time time.sleep(3) mouse = mouse_Controller() # 控制鼠标 keyboard = key_Controller() mouse.press(Button.left) # 按住鼠标左键 mouse.release(Button.left) # 松开鼠标左键 for i in range(99): #总共发多少次 time.sleep(0.1) #消息发送间隔时间 keyboard.type('今晚来我房间！') #发送的消息内容 keyboard.press(Key.enter) keyboard.release(Key.enter) 运行效果
我这里设置的99条消息，发了两遍，直接就99+了。
不说了，女神来打我了~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9474a0ac1d44d09792f7ed2c26e488e/" rel="bookmark">
			1. Spring中Bean的生命周期详解(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring最重要的功能就是帮助程序员创建对象（也就是IOC），而启动Spring就是为创建Bean对象做准备，所以我们先明白Spring到底是怎么去创建Bean的，也就是先弄明白Bean的生命周期。
Bean的生命周期就是指：在Spring中，一个Bean是如何生成的，如何销毁的？
Bean的生成过程 1. 生成BeanDefinition Spring启动的时候会进行扫描，会先调用
Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); 拿到所指定的包路径下的所有文件资源（******.class文件）
然后会遍历每个Resource，为每个Resource生成一个MetadataReader对象，这个对象拥有三个功能：
获取对应的Resource资源获取Resource对应的class的元数据信息，包括类的名字、是不是接口、是不是一个注解、是不是抽象类、有没有父类，父类的名字，所实现的所有接口的名字，内部类的类名等等。获取Resource对应的class上的注解信息，当前类上有哪些注解，当前类中有哪些方法上有注解 在生成MetadataReader对象时，会利用ASM技术解析class文件，得到类的元数据集信息合注解信息，在这个过程中也会利用ClassLoader去加载注解类（ClassUtils.getDefaultClassLoader()所获得的类加载器），但是不会加载本类。
有了MetadataReader对象，就相当于有了当前类的所有信息，但是当前类并没有加载，也是可以理解的，真正在用到这个类的时候才加载。
然后利用MetadataReader对象生成一个ScannedGenericBeanDefinition对象，注意此时的BeanDefinition对象中的beanClass属性存储的是当前类的名字，而不是class对象。（beanClass属性的类型是Object，它即可以存储类的名字，也可以存储class对象）
2. 合并BeanDefinition 如果某个BeanDefinition存在父BeanDefinition，那么则要进行合并
3. 加载类 有了BeanDefinition之后，后续就会基于BeanDefinition去创建Bean，而创建Bean就必须实例化对象，而实例化就必须先加载当前BeanDefinition所对应的class，在AbstractAutowireCapableBeanFactory类的createBean()方法中，一开始就会调用：
Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); 这行代码就是去加载类，该方法是这么实现的：
if (mbd.hasBeanClass()) { return mbd.getBeanClass(); } if (System.getSecurityManager() != null) { return AccessController.doPrivileged((PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;) () -&gt; doResolveBeanClass(mbd, typesToMatch), getAccessControlContext()); } else { return doResolveBeanClass(mbd, typesToMatch); } public boolean hasBeanClass() { return (this.beanClass instanceof Class); } 如果beanClass属性的类型是Class，那么就直接返回，如果不是，则会根据类名进行加载（doResolveBeanClass方法所做的事情）
会利用BeanFactory所设置的类加载器来加载类，如果没有设置，则默认使用ClassUtils.getDefaultClassLoader()所返回的类加载器来加载。
ClassUtils.getDefaultClassLoader()
优先获取当前线程中的ClassLoader如果为空，则获取加载ClassUtils类的类加载器（正常情况下，就是AppClassLoader，但是如果是在Tomcat中运行，那么则会是Tomcat中为每个应用所创建的WebappClassLoader）如果为空，那么则是bootstrap类加载器加载的ClassUtils类，那则获取系统类加载器进行加载 4. 实例化前 允许第三方可以不按照Spring的正常流程来创建一个Bean，可以利用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法来提前返回一个Bean对象，直接结束Bean的生命周期
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9474a0ac1d44d09792f7ed2c26e488e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47858056aab6d8a94f7d019e5419ac73/" rel="bookmark">
			nacos启动报错java.lang.RuntimeException: [db-load-error]load jdbc.properties error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nacos启动报错java.lang.RuntimeException: [db-load-error]load jdbc.properties error 介绍报错内容说明强调一下nacos-mysql.sql集群模式 介绍 下载了最新的nacos2.0.3，并通过脚本启动，出现如下异常
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'externalStoragePersistServiceImpl': Invocation of init method failed; nested exception is java.lang.RuntimeException: java.lang.RuntimeException: [db-load-error]load jdbc.properties error at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:139) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:413) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1761) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:592) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:514) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:321) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:319) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1276) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1196) at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:595) ... 146 common frames omitted Caused by: java.lang.RuntimeException: java.lang.RuntimeException: [db-load-error]load jdbc.properties error at com.alibaba.nacos.config.server.service.datasource.DynamicDataSource.getDataSource(DynamicDataSource.java:60) at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47858056aab6d8a94f7d019e5419ac73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d76f574da2033a1e22662bac47fd006/" rel="bookmark">
			【JDK8】default
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 官方文档default static多个默认方法 官方文档 https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html
http://cr.openjdk.java.net/~briangoetz/lambda/Defender%20Methods%20v4.pdf
接口可以有实现方法，而且不需要实现类去实现其方法。
Java 8中出现，接口添加default方法，不强制实现了该接口的类也实现这个新加的方法
效率高：在字节码层面提供了支持
不打破现有继承体系的基础上改进接口。
警告：在复杂的继承体系中，默认方法可能引起歧义和编译错误。
default static B实现且默认继承默认方法
C实现且重写默认方法，提供不同的实现
private interface A { default String aa() { return "Default implementation"; } } private static class B implements A { } private static class C implements A { @Override public String aa() { return "Overridden implementation"; } } private interface D { static A create( Supplier&lt; A &gt; supplier ) { return supplier.get(); } } public static void main( String[] args ) { A a = D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d76f574da2033a1e22662bac47fd006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/106938d3c35eba52b82aee5dc5882252/" rel="bookmark">
			Idea创建项目出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.出现这个问题是因为父工程的pom文件下&lt;modules&gt;标签没有把子工程加进去。
问题：
解决方案：
2.一个项目多个模块创建模块时出现pom 文件置灰的情况。
问题：
解决方案：把勾选的放开即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f03b36e7cd30c3d3a4fe2a5a0bacbae/" rel="bookmark">
			如何nginx-ingress对外提供服务_nginx-ingress原理?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何nginx-ingress对外提供服务_nginx-ingress原理? 主机 nginxpod nginx-ingress1、Pod2、ingress 资源3、nginx-ingress对外提供服务4、nginx-ingress工作流程 主机 nginx 一般 nginx 做主机反向代理（网关）有以下配置
upstream order{ server 192.168.1.10:5001; server 192.168.1.11:5001; } server { listen 80; server_name order.example.com; access_log /var/log/nginx/order.example.com-access.log; error_log /var/log/nginx/order.example.com-error.log; location / { proxy_pass_header Server; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_pass http://order; } } 其中 192.168.1.10:5001，192.168.1.10:5001 我们把他们称为 Endpoint，就是所谓的具体的服务，比如 order 订单服务。
pod nginx-ingress nginx-ingress也是一种代理，是一个pod，外部的数据统一经过（必经）这个pod，然后通过该pod内部的nginx方向代理到各各服务（Endpoint）。nginx-ingress是ingress控制器插件的一种，这些插件有很多，比如istio-ingressgateway。
1、Pod nginx-ingress pod有两个功能，controller 和 nginx：
controller：和kubernetes api通讯实时更新nginx配置（就是ingress yaml资源了） nginx：正常的反向代理 与主机nginx的区别是，该pod nginx-ingress是运行在pod里。主机在定义反向代理配置文件时，需要监听一个对外开放的端口，比如上边的80端口。那么pod中的nginx端口是如何配置的呢？
我们在github上找到了nginx-ingress的deployment.yaml
https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml 其中一段
apiVersion: apps/v1 kind: Deployment metadata: name: nginx-ingress-controller namespace: ingress-nginx labels: app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f03b36e7cd30c3d3a4fe2a5a0bacbae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d9c6ffdfaeed0063f0ecea5614eddc/" rel="bookmark">
			Python网络编程——客户端与服务端简单信息发送与接受
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python网络编程—服务端与客户端简单信息发送与接受 思考一下我们进行网络中信息通信都需要什么或者说需要具备什么条件才能进行网络通信？
首先我们需要知道给谁发送，也就是目标机是谁，然后我们需要知道对方的IP地址以及对方接受消息的端口，这样才能正确通过网络数据传输，将我们的消息发送给对方
作为目标机，我们需要绑定我们的IP地址，以及接受消息的端口，通过这个端口接受发送消息方的消息并处理消息，这样才能完成通信
2.那么在python中客户端与服务端如何进行通信，我们通过代码进行解释 客户端代码 #客户端代码 import socket #同样在客户端也需要创建socket对象才能完成网络通信 clicent = socket.socket() #连接给谁发的IP地址以及端口号 clicent.connect(("10.132.5.70",8000)) #输入要发送的消息 msg = input() #通过socket对象发送消息 clicent.send(msg.encode("utf-8")) #接受来自服务端回复的消息,最多接受1024字节 ret = clicent.recv(1024) print(ret) #关闭连接 clicent.close() 服务端代码 #服务端代码 import socket #获取socket对象 serve = socket.socket() #绑定自己的IP地址以及端口号 serve.bind(('10.132.5.70',8000)) #表示最多处理5个连接请求，当连接请求超过5个时候，就不再处理之后的请求 serve.listen(5) #等待客户端的连接，注意在这里会发生阻塞，如果没有客户端连接就会一直等待 #conn表示与客户端连接对象，之后与客户端发送消息以及接受客户端的消息都是通过这个对象来完成，addr表示客户端的地址 conn,addr = serve.accept() print("客户端连接：",conn,addr) #接受来自客户端的消息，最多接受1024字节，我们要知道，在网络上消息的传输都是通过字节流来进行输送的，所以我们进行发送消息以及接受消息都是字节 ret = conn.recv(1024) print(ret) msg = input("") conn.send(msg.encode("utf-8")) #关闭连接 conn.close() serve.close() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c8433c98740e578fd383a1f2d219506/" rel="bookmark">
			【Python PyQt5 中combobox用clear()崩溃的问题及解决】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python PyQt5 中combobox用clear()崩溃的问题及解决
今天使用QCombobox控件时，使用clear()清空下拉列表时，程序崩了，在本站搜索了好久，都没有很好解决，只是看到要用disconnect方法解除函数的绑定，但没有实际解决我的问题。经过思考和一步一步调试，解决了问题，直接上程序
修改前
def __init__(self): super(***********, self).__init__() super().__init__() self.setupUi(self) self.plan_num.currentTextChanged.connect(lambda:self.show_deploy(self.plan_num.currentText())) def plan_change(self, text): self.plan_num.clear() self.plan_num.addItem("请选择") result = service.query('select plan_num from plan_sheet where plan_model=%s', text) for i in result: self.plan_num.addItem(i[0]) 解决办法
修改 plan_change 函数
如下
def plan_change(self, text): self.plan_num.currentTextChanged.disconnect() self.plan_num.clear() self.plan_num.addItem("请选择") result = service.query('select plan_num from plan_sheet where plan_model=%s', text) for i in result: self.plan_num.addItem(i[0]) self.plan_num.currentTextChanged.connect(lambda: self.show_deploy(self.plan_num.currentText())) 对比一下该函数修改前和修改后
在函数开始先解除槽函数的绑定
self.plan_num.currentTextChanged.disconnect() 函数末尾再将槽函数重新连接即可
self.plan_num.currentTextChanged.connect(lambda: self.show_deploy(self.plan_num.currentText())) 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/124/">«</a>
	<span class="pagination__item pagination__item--current">125/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/126/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>