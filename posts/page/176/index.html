<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e250edcc9d264d868abc531f3d6c24/" rel="bookmark">
			C/C&#43;&#43;中的const int *a与int *const a，const int *const a
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[TOC] ----------- 【参考链接】[const int *a与int *const a，const int *const a的区别](https://blog.csdn.net/zhangheng837964767/article/details/33783511) ----------- 关键问题点：const属于修饰符，关键是看const修饰的位置在那里 # 1.`const int *a` 这里const 修饰的是int,而int定义的是一个整值，因此*a 所指向的对象值不能通过*a来修改,但是 可以重新给 a 来赋值，使其指向不同的对象。 例子: ```C++ const int *a = 0; const int b = 1; int c = 1; a = &amp;b; //ok！ 额外：注意不能通过a 来修改 b值 a = &amp;c; //ok！ 额外：虽然c本身不是一个常量 *a = 2; //errno！ 为题就在这里，不能修改通过 *a 所指向的对象值，最后赋值得对象是c，因此不能通过*a 来修改c值。 ``` # 2.`int *const a` 这里const修饰的是a,a代表的是一个指针地址，因此不能赋给a其他的地址值，但可以修改a指向的值，这有点和cont int *a相反的意味，例子就不说了 # 3.`int const *a 和 const int *a` 他们的意义是相同的 他们两个的作用等价 # 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5e250edcc9d264d868abc531f3d6c24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40e9685f498935b0ca1c8d3ff275ced2/" rel="bookmark">
			angular拦截器的使用（缓存）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没登录CDSN的账号，居然有人给我点赞，还有人关注我了，哈哈，无名之辈的开心就是这么简单，谢谢(๑╹◡╹)ﾉ"""
什么是拦截器 回归今天的主题， 我建议大家主要是去看官方文档的拦截请求和响应，跳到顶部，可以下载官方例子源码的。
拦截器就是在发送请求给服务器之前，拦截请求，隐式进行处理。
也可以在接受服务器的响应之后，拦截响应，隐式进行处理。
简单的应用就像官方说的，记日志，缓存等等，我也用其实现了在请求数据时，改变光标的类型的一个小功能。
使用拦截器 自定义的拦截器CachingInterceptor继承接口HttpInterceptor，实现其中的方法intercept拦截请求 intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { // 在发送请求给服务器之前，拦截请求的处理 // 强调下虽然拦截器有能力改变请求和响应，但 HttpRequest 和 HttpResponse 实例的属性却是只读 // 此让它们基本上是不可变的。 //要想修改该请求，就要先克隆它，并修改这个克隆体，然后再把这个克隆体传给 next.handle()。 const secureReq = req.clone({ url: req.url.replace('http://', 'https://')}); //next.handle()，把请求传给下一个拦截器，最终传给后端处理器。 return next.handle(secureReq); } 碎碎念一下， intercept() 和 handle() 方法返回的是 HttpEvent 的可观察对象，而不是大多数 HttpClient 中的方法那样返回 HttpResponse 的可观察对象。HttpEvent 这个可观察对象很有用，他拥有以下六种事件，在官方案例监听进度事件起到了重要作用。
export declare enum HttpEventType { /** * The request was sent out over the wire. */ Sent = 0, /** * An upload progress event was received.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40e9685f498935b0ca1c8d3ff275ced2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610856047a3c9b489330e4ed5e3b53ab/" rel="bookmark">
			c语言中int *a，int a和int* a什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int *a指的是定义一个指向int类型数据的指针a，
int a指的是定义一个整数变量a,
int* a跟int *a是一样的，只是int *a更严谨，
比如，int *a,b; 只有a是指针变量
int* a,b; 容易让人觉得a和b都是指针
#include &lt;stdio.h&gt; void huhuan(int a,int b) { printf("%d\n", a); //5 printf("%d\n", b); //3 int t; t = a; a = b; b = t; } void huhuan_1(int *a, int *b) { printf("%d\n", a); //a表示是是一个指针 输出的的 7600000 printf("%d\n", b); //7599988 int *t; //t必须是 int * 类型 否则类型不一致 t = a; a = b; b = t; } void huhuan_2(int *a, int *b) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/610856047a3c9b489330e4ed5e3b53ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07509d7d92e90deec6018c9ef9b993fb/" rel="bookmark">
			Qt IFW基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在上一篇文章中简单介绍了Qt IFW的优势，并且介绍了如何下载安装软件，那么，在本篇中来看一下如何使用IFW创建一个最简单的应用安装包，并介绍一些基本用法。
运行示例 在介绍之前我们首先跑一个Qt IFW安装过后自带的一个示例，以startmenu为例，打开安装目录下的example文件夹：
找到startmenu示例：
其目录结构是这样的：
是不是很熟悉，pro文件，不就是Qt的工程文件吗， 这和一个常规的Qt工程项目差不多，那么直接在Qt creator中打开这个startmenu.pro文件，目录结构如下：
然后二话不说，直接编译运行，运行后会弹出一个对话框：
别管它，回到文件夹中找到刚刚编译生成的文件，会发现生成了一个install.exe
ok，这就是最终生成出来的安装包，直接双击运行：
欢迎页面：
选择安装目录
选择需要安装的组件
开始菜单快捷方式
准备安装
这就完成了整个安装流程。
打包文件分析 以上演示了最基础的一个打包流程，那么接下来开始分析目录结构以及配置文件。
目录结构 还是以上面的示例来讲解，其目录结构为：
这里主要包含了两个文件夹，config和packages，其中config下面有一个config.xml文件，packages下面的meta目录包含package.xml和installscript.qs文件
其中，这里最重要的两个文件就是config.xml和package.xml
config.xml：打包文件的基本配置信息package.xml：软件包信息配置文件data：该文件夹存放将要打包的所有文件installscript.qs：软件包信息脚本，在package.xml中引用 创建安装程序 前面通过运行Qt IFW自带的示例已经对打包文件目录结构及基本的运行流程有了大致的了解，那么接下来就看看如何创建一个自己的安装程序。
步骤 创建安装程序必须完成的以下任务：
1.创建一个软件包目录，其中将包含所有配置文件和可安装的软件包。2.创建一个配置文件config.xml，其中包含有关如何构建安装程序二进制文件和联机存储库的信息。3.创建一个软件包信息文件package.xml，其中包含有关可安装组件的信息。4.创建安装程序内容并将其复制到软件包目录，比如上面的data。5.使用该binarycreator工具创建安装程序。 创建配置文件 在config目录中，创建一个config.xml包含以下内容的文件：
基本信息如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Installer&gt; &lt;Name&gt;Your application&lt;/Name&gt; &lt;Version&gt;1.0.0&lt;/Version&gt; &lt;Title&gt;Your application Installer&lt;/Title&gt; &lt;Publisher&gt;Your vendor&lt;/Publisher&gt; &lt;StartMenuDir&gt;Super App&lt;/StartMenuDir&gt; &lt;TargetDir&gt;@HomeDir@/InstallationDirectory&lt;/TargetDir&gt; &lt;/Installer&gt; 说明：
&lt;Name&gt;元素指定程序名称&lt;Version&gt;元素指定的应用程序版本号&lt;Publisher&gt;元素指定软件（Windows控制面板中所示）的发布者。&lt;StartMenuDir&gt;元素指定用于开始菜单中默认程序名称。&lt;TargetDir&gt;元素指定的是程序默认安装位置，其可选的位置可参考这里 配置文件中所有可配置项，请参考这里
创建包装信息文件 要向安装程序提供有关组件的信息，需要创建一个package.xml文件，并包含以下内容，并将其放置在meta目录中：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Package&gt; &lt;DisplayName&gt;The root component&lt;/DisplayName&gt; &lt;Description&gt;Install this example.&lt;/Description&gt; &lt;Version&gt;0.1.0-1&lt;/Version&gt; &lt;ReleaseDate&gt;2010-09-21&lt;/ReleaseDate&gt; &lt;Licenses&gt; &lt;License name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07509d7d92e90deec6018c9ef9b993fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/674a9d70bfc088de0e11a57ef8157f4d/" rel="bookmark">
			Prometheus联邦模式relabel_configs遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用Prometheus联邦模式，中心节点收集子节点数据时，需要动态生成一些新的标签，例如将三个标签合成一个新的标签，无奈发现没有合成。查了一下prometheus的 Before relabeling，没有找到想要的那三个标签，但是指标中是有这三个标签的。
后来上网查了下，发现Before relabeling里面只会列出静态的标签，这些标签的值在scrape之前是已知的。
但我想要的那三个标签的值在不同的指标中是不一样的，那怎么搞？
后来在官网找到了 metric_relabel_configs relabel_configs和metric_relabel_configs 的区别是：前者发生在scrape之前（所以无法对动态标签做relabel_configs，因为scrape之前不知道值是什么），后者发生在scrape之后。
于是将relabel_configs换成metric_relabel_configs，问题解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6370e4b3a47b7708a18db98e6e006f68/" rel="bookmark">
			JAVA中集合List练习之获取10个1-20之间的随机数，要求不能重复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.cg.listtext2; import java.util.ArrayList; import java.util.Random; /** * @author life * @create 2019-11-26 18:52 * 获取10个1-20之间的随机数，要求不能重复 * * 分析： 用集合进行实现 * A：创建产生随机数的对象 * B：创建一个储存随机数的集合 * C：定义一个统计变量，从0开始 * D：判断统计变量是否小于10 * 是：先产生一个随机数，判断随机数在集合中是否存在 * 如果不存在就添加，统计变量++ * 如果存在 ， 就不用管 * */ public class random { public static void main(String[] args) { // A：创建产生随机数的对象 Random random = new Random(); //B：创建一个储存随机数的集合 ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); //C：定义一个统计变量，从0开始 int count = 0; // D：判断统计变量是否小于10 while(count&lt;10){ //产生一个随机数 int number = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6370e4b3a47b7708a18db98e6e006f68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12cac5fc38e36c51b9724edeac925c0/" rel="bookmark">
			Unity渲染管线基础知识学习与总结（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Unity渲染管线基础知识学习与总结 引言渲染流程概述GPU渲染管线（GPU流水线） 引言 鄙人只是对游戏开发感兴趣，所以在不断学习游戏相关知识，越往深入去学习游戏开发与制作，越感觉自己会的东西很少。鄙人想深入了解特效的开发制作，对渲染管线流程深入学习。做一个上架游戏或者demo需要很多计算机、物理、数学、动画以及美术等多学科基础，做一个demo为例包括以下几个部分：
游戏剧情及内容策划：做一个游戏首先要确定你的游戏主题及风格，自己做个demo主要看你想做什么风格的游戏。游戏模型及场景制作：这是游戏的根本元素，游戏对象模型制作的是否精美、是否入目直接影响整个游戏的玩赏性，这个需要一定的美术功底，可以学习3dmax、maya、blender、zbrush等软件来进行人物及场景建模。游戏动画制作：主角的行走、奔跑以及攻击等动画，可以通过Unity、3dmax、maya等制作，2D像素游戏可以由PS制作。游戏编程：Unity通过C#、JS编写，UE4由C++编写；主要编写游戏运动逻辑、UI界面、状态机管理等，需要了解数据结构、多线程甚至GPU计算等知识。特效渲染制作：通过编写Shader实现游戏中炫酷的特效，这里需要知道GPU渲染流程及原理，会shader编程应该是做游戏开发中比较高级的技术。 渲染流程概述 渲染流程可以由上图概述：
该过程表示将CPU内存(RAM)中存储的模型顶点、法线、三角面以及UV等渲染所需要的信息加载到显存当中(VRAM),这是因为GPU对于显存的访问速度更快，而且大多数GPU不能直接访问RAM。该过程包含两个内容，一个是读取显存中模型的顶点等渲染数据，另一个是接收来自CPU的Draw Call指令，该指令告诉GPU按照CPU设置的方式渲染。将经过GPU渲染管线后的颜色缓冲区的颜色输出到屏幕上，上述所有的操作需要我们编程操作的便是GPU渲染管线阶段，也是我们编写shader的核心。 GPU渲染管线（GPU流水线） 该图来自书籍《Unity Shader入门精要》，讲的比较详细，国内Shader方面的书比较少，推荐这本入门。
顶点着色器：是完全可以编程的，它的是流水线的第一个阶段，用于顶点坐标变换以及顶点颜色计算等，在这里改变顶点的位置可以模拟水面和布料等的运动。其中，顶点着色器将顶点坐标从模型空间转换到齐次裁剪空间，接着进行裁剪剔除不渲染的点后，最终得到归一化的设备坐标（NDC），Unity设备坐标范围同OpenGL一样在[-1,1]之间。曲面细分着色器、几何着色器：都是可选的着色器，不必过于了解。裁剪：由于我们的场景会很大，摄像机视野外的画面不需要进行渲染计算，所以裁剪的作用便是剔除视野外的图元。如下图一条线段A点在视野内，B点在视野外，将会剔除B点，取线段与视野交点处C点。注意裁剪这一步我们不可以编辑，这是硬件上的固定操作。 屏幕映射：将图元的x和y坐标转换到屏幕坐标系，这与屏幕的分辨率有关，而图元的z坐标表示各物体与摄像机的远近，用于判断各图元的遮挡关系，这一阶段输出屏幕坐标系下的顶点坐标，Z深度信息，法线方向等。光栅化：我的理解是将屏幕坐标系坐标转换为图像像素的过程。光栅化处理包含以下几个部分：
1）三角形设置：计算三角形网格的边界像素坐标。
2）三角形遍历：该阶段将会检查每个像素是否被三角网格覆盖，对应覆盖像素会生成一个片元，而片元的状态由三角网格三个顶点插值得到，注意片元不是像素。这些片元包含屏幕坐标、深度、法线、UV等。
3）片元着色器：可以编程，对纹理进行采样，输出该片元的颜色信息。逐片元操作：这一阶段决定片元的可见性，通过模板测试、深度测试后，将片元的颜色和已经存储在颜色缓冲区的颜色进行混合存入颜色缓冲区。为了避免看到正在栅格化的图元，GPU使用双重缓冲，场景渲染是在幕后的后置缓冲区进行的，一旦场景渲染完成后会将后置缓冲区内容与前置缓冲区交换，保证图像的连续性。
这一小节主要了解渲染基本流程，后面会进行实例编程讲解，这个过程有些枯燥，但这是必经之路，加油老铁们！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99942246f147494f993f357a5bf0d6fd/" rel="bookmark">
			NX二次开发    获取图纸页上的全部注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境： Win7 x64，VS2015, NX12.0.2.9
目标： NX12图纸模块，需要获取某个图纸上的全部注释。
注：图纸和注释仿佛是两个体系，没有找到两者直接的关系，于是自己写了一个，仅供参考！！！
代码：
test.cpp
#include &lt;NXOpen/Annotations_Annotation.hxx&gt; #include &lt;NXOpen/Annotations_AnnotationManager.hxx&gt; #include &lt;NXOpen/Annotations_BreakSettingsBuilder.hxx&gt; #include &lt;NXOpen/Annotations_DimensionStyleBuilder.hxx&gt; #include &lt;NXOpen/Annotations_DisplayStyleBuilder.hxx&gt; #include &lt;NXOpen/Annotations_DraftingNoteBuilder.hxx&gt; #include &lt;NXOpen/Annotations_ForeshorteningSymbolBuilder.hxx&gt; #include &lt;NXOpen/Annotations_ForeshorteningSymbolSettingsBuilder.hxx&gt; #include &lt;NXOpen/Annotations_FrameBarElementStyleBuilder.hxx&gt; #include &lt;NXOpen/Annotations_FrameBarStyleBuilder.hxx&gt; #include &lt;NXOpen/Annotations_HatchStyleBuilder.hxx&gt; #include &lt;NXOpen/Annotations_HoleCalloutSettingsBuilder.hxx&gt; #include &lt;NXOpen/Annotations_LeaderBuilder.hxx&gt; #include &lt;NXOpen/Annotations_LeaderData.hxx&gt; #include &lt;NXOpen/Annotations_LeaderDataList.hxx&gt; #include &lt;NXOpen/Annotations_LetteringStyleBuilder.hxx&gt; #include &lt;NXOpen/Annotations_LineArrowStyleBuilder.hxx&gt; #include &lt;NXOpen/Annotations_OrdinateStyleBuilder.hxx&gt; #include &lt;NXOpen/Annotations_OriginBuilder.hxx&gt; #include &lt;NXOpen/Annotations_PlaneBuilder.hxx&gt; #include &lt;NXOpen/Annotations_RadialStyleBuilder.hxx&gt; #include &lt;NXOpen/Annotations_SingleSidedDisplayBuilder.hxx&gt; #include &lt;NXOpen/Annotations_StyleBuilder.hxx&gt; #include &lt;NXOpen/Annotations_SymbolStyleBuilder.hxx&gt; #include &lt;NXOpen/Annotations_TextWithEditControlsBuilder.hxx&gt; #include &lt;NXOpen/Annotations_TextWithSymbolsBuilder.hxx&gt; #include &lt;NXOpen/Annotations_UnitsStyleBuilder.hxx&gt; #include &lt;NXOpen/BasePart.hxx&gt; #include &lt;NXOpen/Body.hxx&gt; #include &lt;NXOpen/Builder.hxx&gt; #include &lt;NXOpen/DisplayableObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99942246f147494f993f357a5bf0d6fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/820bea49da2dc364a1c36f0e85b94265/" rel="bookmark">
			最新java面试笔试编程题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【程序1】
题目：古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？
//这是一个菲波拉契数列问题
public class lianxi01 { public static void main(String[] args) { System.out.println("第1个月的兔子对数: 1"); System.out.println("第2个月的兔子对数: 1"); int f1 = 1, f2 = 1, f, M=24; for(int i=3; i&lt;=M; i++) { f = f2; f2 = f1 + f2; f1 = f; System.out.println("第" + i +"个月的兔子对数: "+f2); } } } 【程序2】
题目：判断101-200之间有多少个素数，并输出所有素数。
程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除， 则表明此数不是素数，反之是素数。
public class lianxi02 { public static void main(String[] args) { int count = 0; for(int i=101; i&lt;200; i+=2) { boolean b = false; for(int j=2; j&lt;=Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/820bea49da2dc364a1c36f0e85b94265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f58a69a6bfade1cc293fa4acb958c98/" rel="bookmark">
			idea去掉拼写等不必要的检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果对单项目可以直接点Setting 如果对所有项目就用点图中的Default Settings 一劳永逸
把上面的ProjectecDefault、Default 把下面的项目后面的勾去掉
大片重复代码黄色波浪线去掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ebeeea8eb962dade69636039d55d77/" rel="bookmark">
			centos7输入systemctl status network.service出现Unit network.service could not be found的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没安装NetworkManager，安装一个就行
命令：yum install NetworkManager*
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5453108c23d551ac17fbbe773db24551/" rel="bookmark">
			踩坑之SpringBoot WebSocker 部署Tomcat冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动tomcat容器，部署SpringBoot项目，启动项目报错，如下图：
看1、2的顺序就知道是WebSocket冲突了。
上网找了一下资料发现，使用@ServerEndpoint创立websocket endpoint的时候，首先要注入ServerEndpointExporter，这个bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint。
如果使用独立的servlet容器，而不是直接使用springboot的内置容器，就不要注入ServerEndpointExporter，因为它将由容器自己提供和管理。
原本代码是这样的
更改后：
然后注释了这一段Bean的注入，重新打包就解决了问题。 参考：https://www.cnblogs.com/bianzy/p/5822426.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703bfa1c67fed82a4b22054158574c22/" rel="bookmark">
			界面布局之控件stackedWidget的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、有切换的效果：如图所示：
这样可以控制两个界面的切换，使用的时候可以使用按钮的点击事件，加上代码：
ui-&gt;stackedWidget-&gt;setCurrentIndex(0); setCurrentIndex(0)里面的0，指的是当前的页码数，就代表第一面，可以是1或者2，那就切换到下一页中去 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/084328529d502499f707e097709973c8/" rel="bookmark">
			【牛客网】排序子序列问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
牛牛定义排序子序列为一个数组中一段连续的子序列, 并且这段子序列是非递增或者非递减排序的。牛牛有一
个长度为n的整数数组A, 他现在有一个任务是把数组A分为若干段排序子序列, 牛牛想知道他最少可以把这个数
组分为几段排序子序列.
如样例所示, 牛牛可以把数组A划分为[1, 2, 3]和[2, 2, 1]两个排序子序列, 至少需要划分为2个排序子序列, 所以输出2
输入输出
输入的第一行为一个正整数n(1 ≤ n ≤ 10 ^ 5)
第二行包括n个整数A_i(1 ≤ A_i ≤ 10 ^ 9), 表示数组A的每个数字。
输出描述：
输出一个整数表示牛牛可以将A最少划分为多少段排序子序列
示例1 :
输入
6
1 2 3 2 2 1
输出
2
解题思路
遍历整个数组，当a[i] 与 a[i+1] 的关系发生改变的时候count++, 注意最后一个位置的数字如果是单独的数字，
例如： 1 2 3 2 1 3 这样的话，给最后一个数字的后一个位置置为0就可以帮助判断。
代码
#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { int n; cin &gt;&gt; n; // 注意这里多给了一个值，是处理越界的情况的比较 vector&lt;int&gt; a; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/084328529d502499f707e097709973c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f97ea3a250f48668e8fe61e54e7f48f/" rel="bookmark">
			CocosCreator官方示例 - spine系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.动态加载spine动画 挂载spine动画依赖sp.Skeleton组件 设置spine动画三个重要的属性，也可以代码动态设置 Skeleton Data骨骼信息数据，拖拽 Spine 导出后的骨骼资源到该属性中Default Skin选择默认的皮肤Animation 当前播放的动画名称
通过代码加载，读取assets/resources目录下的资源初始化spine动画 cc.loader.loadRes('loadSpine/alien-ess', sp.SkeletonData, this.onProcess.bind(this), this.onComplete.bind(this));
在onComplete回调里执行下面操作 let spine = this.getComponent('sp.Skeleton');
spine.skeletonData = res;
let animate = spine.setAnimation(0, 'run', true);
这样就完成了动态加载spine动画
2.spine动画的动作 setMix(fromAnimation, toAnimation, duration) 为所有关键帧设定混合及混合时间（从当前值开始差值）
说白了就是两个动作切换时，不在是生硬的切换，而是上一个动作快结束时，下一个动作开始进入
具体详情点击 https://www.cnblogs.com/BigFeng/p/6781855.html
setAnimation(trackIndex, name, loop) 设置当前动画。队列中的任何的动画将被清除，返回一个 sp.spine.TrackEntry 对象。
set相同的trackIndex 上一个动作会被覆盖
假如trackIndex == 0是walk动作，此时想播放射击动作，因为walk动作不能停下，那么就将shoot动作的trackIndex设置为1
addAnimation(trackIndex, name, loop, delay) 添加一个动画到动画队列尾部，还可以延迟指定的秒数，返回一个 sp.spine.TrackEntry 对象
3.Spine 换装 具体详见 https://docs.cocos.com/creator/2.2/manual/zh/components/spine.html#spine-%E6%8D%A2%E8%A3%85
部分换装 简单点说就是通过替换 findSlot 插槽的 attachment 对象，产生局部换装的效果，attachment 对象的是通过 findSlot 找到的
下面是spine动画的部分json数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f97ea3a250f48668e8fe61e54e7f48f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba21019715adc8666237e3eadcdedec5/" rel="bookmark">
			LeNet-5详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeNet-5详解
参考：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665407436e92997655f31d2ae4058d55/" rel="bookmark">
			java 获取两个日期相差的月份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前两天要用到获取两个时间之间的月份差，今天总结下。
/** * 获取连个日期之间相差的月份 * @param startDate * @param endDate * @return * @throws ParseException */ private static List getMonth(String startDate, String endDate) throws ParseException { List list = new ArrayList(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM"); Calendar c1 = Calendar.getInstance(); Calendar c2 = Calendar.getInstance(); c1.setTime(sdf.parse(startDate)); c2.setTime(sdf.parse(endDate)); int year = c2.get(Calendar.YEAR) - c1.get(Calendar.YEAR); int month = c2.get(Calendar.MONTH)+year*12 - c1.get(Calendar.MONTH); for(int i = 0;i&lt;=month;i++){ c1.setTime(sdf.parse(startDate)); c1.add(c1.MONTH, i); list.add(sdf.format(c1.getTime())); } return list; } 当前月份向前或向后推。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/665407436e92997655f31d2ae4058d55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ef6ffebc6b1150a80346bc3d5195acd/" rel="bookmark">
			【java】本地客户端内嵌浏览器3 - Swing 使用 Spring 框架 &#43; 打包项目 &#43; 转exe &#43; 源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 ★☆★ 写在前面 ★☆★★☆★ 本系列文章 ★☆★★☆★ 开源网址 ★☆★一、给 Swing 加上 Spring0、前期努力I. SpringBootII. SpringMVC 1、开始搞起：搭建 spring 框架2、添加 Service 并使用I. 准备II. 使用 3、异步 @AsyncI. 准备II. 使用III. 涅槃重生IV. 补充 二、给项目打包成 exe1、打包2、转exe 三、完 ★☆★ 写在前面 ★☆★ 请通过目录，选择感兴趣的部分阅读。
★☆★ 本系列文章 ★☆★ 【java】本地客户端内嵌浏览器1 - Swing、SWT、DJNativeSwing、javaFX
【java】本地客户端内嵌浏览器2 - chrome/chromium/cef/jcef
【java】本地客户端内嵌浏览器3 - Swing 使用 Spring 框架 + 打包项目 + 转exe + 源码
★☆★ 开源网址 ★☆★ https://github.com/supsunc/swing-jcef-spring
一、给 Swing 加上 Spring ★ 这里说一下为什么使用 Spring，是因为本项目的一个功能：“搜寻仪器”，该功能调用了 dll 的方法，此方法至少要等待 7 - 8 秒才会返回结果，而正常写的话，因为是单线程，所以会导致 client 完全卡住，但不是 GG，在卡住期间，js正常运行，且在卡完之后，会直接表现当前 js 运行的状态，给人一种时间消失的感觉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ef6ffebc6b1150a80346bc3d5195acd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85fc77d3d8b6f6dc59ddfe1547cb4d06/" rel="bookmark">
			java实现base64及图片路径转换mat的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中涉及到了图像算法识别，涉及到传递mat，于是就有了这样的一篇博客 由于对外接口要求对方提供的是base64编码的jpg图像数据，但是算法需要的是Mat类型的数据，这样就需要引入opencv_java来实现这样的转换。
实际上整个过程就需要几个步骤：
1.实现base64的解码；
2.将解码后的数据转换为BufferedImage；
3.将BufferedImage转换为Mat类型数据；
前两步都很好实现，难点在第三步上，我们就具体讲讲第三步的实现 1.首先，maven项目引入几个pom依赖：
&lt;dependency&gt; &lt;groupId&gt;org.bytedeco&lt;/groupId&gt; &lt;artifactId&gt;javacv&lt;/artifactId&gt; &lt;version&gt;1.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.bytedeco/javacpp --&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco&lt;/groupId&gt; &lt;artifactId&gt;javacpp&lt;/artifactId&gt; &lt;version&gt;1.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/opencv/opencv --&gt; &lt;dependency&gt; &lt;groupId&gt;opencv&lt;/groupId&gt; &lt;artifactId&gt;opencv&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.bytedeco.javacpp-presets/opencv --&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt; &lt;artifactId&gt;opencv&lt;/artifactId&gt; &lt;version&gt;4.0.1-1.4.4&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt; &lt;artifactId&gt;opencv&lt;/artifactId&gt; &lt;version&gt;2.4.11-0.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 需要自己安装配置opencv --&gt; &lt;dependency&gt; &lt;groupId&gt;org&lt;/groupId&gt; &lt;artifactId&gt;opencv&lt;/artifactId&gt; &lt;version&gt;2413&lt;/version&gt; &lt;/dependency&gt; 除最后一个pom依赖外，其余的应该都能够从maven仓库中下载得到。
那我们就来讲下如何获得最后一个maven依赖。
1.1）首先，我们来到opencv的官网：https://opencv.org/releases.html
选择自己需要下载的平台及版本，因为要和公司算法做兼容，所以我选用的是2.4.13版本，window下安装配置极其简单，将下载得到的.exe文件解压缩，然后将到opencv\build\java下即可得到需要的jar包，再然后将jar包转换为maven库里的依赖就可以了。
具体命令我就不放在这了，拿一个通用的模板命令挂在这，按自己实际去转换吧。
mvn install:install-file -Dfile=XX.jar -DgroupId=org -DartifactId=opencv -Dversion=2413 -Dpackaging=jar 1.2）引入了pom依赖之后，windows下还需要opencv\build\java
下需要的opencv的dll文件，将86（32位系统）或64（64位系统）下的
opencv_java2413.dll文件引入到系统的jdk的bin目录下
1.3）上边的是windows的例子，实际很多情况下代码是在GPU的linux服务器上运行的，那么就需要下载linux平台下的文件，在服务器上使用Cmake编译安装，安装之后得到的会是.so文件，将对应的.so文件移入到/usr/lib下即可。
如果不移动就需要将将.so文件的具体路径放入到/etc/profile配置文件中，然后使用source命令更新系统配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85fc77d3d8b6f6dc59ddfe1547cb4d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f901356ec96dfbc7238afb365b47e05/" rel="bookmark">
			Python-变量类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 变量类型¶ 严格意义上讲,python只有一种类型标准数据类型六种 数字Number字符串类型 str列表 list元组 tuple字典 dict集合 set 数字类型 Number python中的数字没有大小限制 常见数字分类 整数 没有小数部分包括正数，负数，0二进制八进制十进制十六进制 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/175/">«</a>
	<span class="pagination__item pagination__item--current">176/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/177/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>