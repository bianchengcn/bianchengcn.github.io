<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730b32a8af827082931a880a566f185d/" rel="bookmark">
			如何使用Java采集汽车之家车辆配置参数信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、采集工具选择
三、采集流程设计
1、确定采集目标
2、确定采集URL
3、发送HTTP请求
4、解析HTML页面
5、CSS选择器或jQuery选择器。
6、异常处理和日志记录
四、代码实现示例
五、结果与分析
六、结论
随着互联网的普及和信息技术的不断发展，网络上积累了大量的车辆配置参数信息。本文将介绍如何使用Java采集汽车之家车辆配置参数信息，帮助用户快速获取所需车型的配置参数，为购车决策提供参考。
一、引言 汽车之家是一个知名的汽车信息平台，提供了大量车型的配置参数信息。这些配置参数包括发动机、变速器、悬挂、制动等关键部件的性能和参数。通过采集这些参数信息，用户可以全面了解车型的性能和特点，从而做出更明智的购车决策。
二、采集工具选择 采集汽车之家车辆配置参数信息，需要选择一款合适的网络爬虫工具。常用的网络爬虫工具包括HttpClient、Jsoup和WebMagic等。其中，Jsoup是一款基于Java的HTML解析库，可以方便地解析和提取HTML中的数据。因此，本文将使用Jsoup作为采集工具。
三、采集流程设计 1、确定采集目标 首先需要确定采集的目标车型和配置参数。可以通过汽车之家网站上的分类和筛选功能，选择需要采集的目标车型。同时，需要根据实际需求，确定需要采集的配置参数列表。
2、确定采集URL 汽车之家的车型配置参数页面URL结构相对固定，可以通过已知车型的URL结构推断出其他车型的URL结构。具体来说，可以通过目标车型的型号和配置参数关键词，构造出对应的URL。
3、发送HTTP请求 使用Jsoup库中的connect()方法发送HTTP请求，获取目标车型的HTML页面内容。可以使用timeout()方法设置请求超时时间，以确保采集过程不会因为网络延迟而中断。
4、解析HTML页面 使用Jsoup库中的parse()方法将HTML页面解析为DOM树结构，然后通过选择器表达式定位到目标配置参数所在的元素节点。选择器表达式的编写需要根据HTML页面的具体结构来确定，可以使用
5、CSS选择器或jQuery选择器。 一旦定位到目标配置参数所在的元素节点，就可以使用Jsoup库中的方法提取该节点的文本内容，即配置参数的值。根据具体的需求，可以将这些值存储到数据库或文件中，以便后续处理和分析。
6、异常处理和日志记录 在采集过程中，可能会遇到各种异常情况，如网络连接中断、目标页面不存在等。因此，需要设计适当的异常处理机制，以确保采集过程的健壮性。同时，为了方便问题排查和追踪，需要记录详细的日志信息，包括请求的URL、响应状态码、解析结果等。
四、代码实现示例 以下是一个简单的示例代码，展示如何使用Jsoup库采集汽车之家某款车型的配置参数信息：
import org.jsoup.Jsoup; import org.jsoup.nodes.Document; import org.jsoup.nodes.Element; import org.jsoup.select.Elements; public class CarConfigParser { public static void main(String[] args) { String url = "https://car.autohome.com.cn/config/index?mod=car&amp;id=10155"; // 目标车型配置页面URL try { Document doc = Jsoup.connect(url).timeout(5000).get(); // 发送HTTP请求并获取HTML页面内容 Elements configParams = doc.select(".config-param"); // 选择目标配置参数所在的元素节点 for (Element param : configParams) { String name = param.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/730b32a8af827082931a880a566f185d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78045b4a3df6d4c13bd65d05dfc547e/" rel="bookmark">
			macOS 配置Python指令：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接在终端中输入python3，能够正常执行。如果想要使用python命令，而非python3命令运行python程序，需要执行以下命令。
echo 'alias python="python3"' &gt;&gt; .bash_profile
执行python指令，报错：
zsh: command not found: python
MacOS默认的SHELL连接软件是zsh，需要执行chsh命令，把zsh更改为bash。具体操作如下：
a. 查看mac默认的SHELL连接文件:
echo $SHELL
b. 查看mac自带的SHELL连接文件，如图所示，有7个:
more /etc/shells
c. 使用chsh命令更改系统的SHELL连接文件为bash:
chsh -s /bin/bash
d. 执行下面的命令，设置别名python=python3:
echo 'alias python="python3"' &gt;&gt; .bash_profile
e. 运行python，显示如下图所示的界面，问题解决:
python
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c5a15bf16aaceda427f4fe5facb1bac/" rel="bookmark">
			Pytorch的BN层使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提知识 BN层包括mean var gamma beta四个参数，。对于图像来说（4，3，2，2），一组特征图，一个通道的特征图对应一组参数，即四个参数均为维度为通道数的一维向量，图中gamma、beta参数维度均为[1,3]
其中gamma、beta为可学习参数（在pytorch中分别改叫weight和bias），训练时通过反向传播更新；
而running_mean、running_var则是在前向时先由X计算出mean和var，再由mean和var以动量momentum来更新running_mean和running_var。所以在训练阶段，running_mean和running_var在每次前向时更新一次；在测试阶段，不用再计算均值方差，则通过net.eval()固定该BN层的running_mean和running_var，此时这两个值即为训练阶段最后一次前向时确定的值，并在整个测试阶段保持不变。
class torch.nn.BatchNorm1d(num_features, eps=1e-05, momentum=0.1, affine=True) nn.BatchNorm2d(self, num_features, eps=1e-5, momentum=0.1, affine=True, track_running_stats=True) 1d 参数：
num_features： 来自期望输入的特征数，C from an expected input of size (N,C,L) or L from input of size (N,L)
eps： 为保证数值稳定性（分母不能趋近或取0）,给分母加上的值。默认为1e-5。
momentum：滑动平均的参数，用来计算running_mean和running_var。默认为0.1。
track_running_stats，是否记录训练阶段的均值和方差，即running_mean和running_var
affine： 一个布尔值，当设为true，给该层添加可学习的仿射变换参数。
输入：（N, C）或者(N, C, L)
输出：（N, C）或者（N，C，L）（输入输出相同）
在每一个小批量（mini-batch）数据中，计算输入各个维度的均值和标准差。gamma与beta是可学习的大小为C的参数向量（C为输入大小）
2d num_features： 来自期望输入的特征数，C from an expected input of size (N,C,H,W)
eps： 为保证数值稳定性（分母不能趋近或取0）,给分母加上的值。默认为1e-5。
momentum： 动态均值和动态方差所使用的动量。默认为0.1。
affine： 一个布尔值，当设为true，给该层添加可学习的仿射变换参数，表示weight和bias将被使用
输入：（N, C，H, W) 输出：（N, C, H, W）（输入输出相同）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c5a15bf16aaceda427f4fe5facb1bac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/660bfc3d9a2e2898d19e423101b7c09a/" rel="bookmark">
			解决vs2019下进行跨平台开发，出现引用的头文件显示无法打开，但是可以通过编译的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 本人在进行Linux跨平台开发的时候，由于云服务器是刚配置的，就直接与vs2019进行了ssh连接。所以当时的Linux系统上还没有安装开发用到的一些头文件，后来要进行MySQL数据库方面的开发，在Linux服务器上已经安装好了，但是在vs的项目中引用头文件的时候出现源文件无法打开的问题，但是在引用头文件之后代码的编译是可以通过的。
具体问题如下：
vs2019如何与Linux通过ssh连接进行项目开发可以参考博客：https://blog.csdn.net/weixin_64647426/article/details/131341970?spm=1001.2014.3001.5501
不说废话，我们来分析一下报错的原因。以及提供给大家VS自带的解决方案
原因 这个问题是由于你的Linux系统上虽然开发和编译的环境都已经配置好了，但是你的Windows上跨平台开发的vs并不知道现在你是什么情况，vs只会在你第一次连接到Linux系统的时候，会把你Linux上的一些开发用到的头文件、库文件等等一系列的东西在你的Windows电脑上复制一份出来
复制文件的位置可以在“项目资源管理器”的外部依赖项中看到，随便打开一个文件然后打开文件的所在位置就可以看到VS为你在Linux系统上复制的所有开发相关的文件
我们可以看到，这个就是vs为我们从Linux系统上复制过来开发所用的文件
我们来找一下为什么VS说mysql.h头文件打开失败的原因
我们可以看到在当前Windows这个文件夹里面确实没有mysql这个文件夹，但是在我们的Linux系统上是存在mysql这个目录的
所以VS报错的原因就是在当前这个Windows的文件夹里面找不到这个mysql.h的头文件和mysql这个文件夹
好了我们现在知道了原因，下一步就是去解决这个问题
解决方法 当我遇到这个问题的时候，也是比较蒙的一个状态，就去网上找了一下这个问题的解决方案，但是大多数的解决方案都是让你从Linux上把这个东西拷贝到VS在Windows上复制的这个文件夹里面，我感觉这个方法还是比较麻烦的
所以我就在想，VS的设计团队，也一定会想到有这个问题的发生，所以我就准备在VS的设置选项里面找找答案
果真VS确实考虑到了这一点，就在VS跨平台的选项里面就提供了这种问题的解决办法
就在跨平台→连接管理器→远程标头IntelliSense管理器下面就有解决方案
我们可以看到，VS给我们提供了一个更新的选项，这个更新就是用来更新文件夹下的文件的
点击对应的Linux系统的IP地址，再点击更新
出现下面的对话框，就表示正在更新
更新完成之后，我们就会在Windows那个文件夹下，看到mysql的文件夹了，并且时间也是和Linux上目录的时间可以对上的
这时头文件的报错也没有了，这个问题就解决了
现在再进行MySQL数据库开发的时候，就会有类型和方法的提示了
到这里vs进行跨平台开发，出现引用的头文件显示无法打开，但是可以通过编译的问题发生的原因和解决方法就介绍完了
感谢观看学习，大佬们多多指点，愿明天的自己会感谢当下的努力！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe033a8cb25b763fedb74644346753be/" rel="bookmark">
			【flink番外篇】13、Broadcast State 模式示例-简单模式匹配（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink 系列文章 一、Flink 专栏
Flink 专栏系统介绍某一知识点，并辅以具体的示例进行说明。
1、Flink 部署系列
本部分介绍Flink的部署、配置相关基础内容。
2、Flink基础系列
本部分介绍Flink 的基础部分，比如术语、架构、编程模型、编程指南、基本的datastream api用法、四大基石等内容。
3、Flik Table API和SQL基础系列
本部分介绍Flink Table Api和SQL的基本用法，比如Table API和SQL创建库、表用法、查询、窗口函数、catalog等等内容。
4、Flik Table API和SQL提高与应用系列
本部分是table api 和sql的应用部分，和实际的生产应用联系更为密切，以及有一定开发难度的内容。
5、Flink 监控系列
本部分和实际的运维、监控工作相关。
二、Flink 示例专栏
Flink 示例专栏是 Flink 专栏的辅助说明，一般不会介绍知识点的信息，更多的是提供一个一个可以具体使用的示例。本专栏不再分目录，通过链接即可看出介绍的内容。
两专栏的所有文章入口点击：Flink 系列文章汇总索引
文章目录 Flink 系列文章一、示例：按照分组规则进行图形匹配-KeyedBroadcastProcessFunction1、maven依赖2、实现3、验证1）、规则输入2）、item输入3）、控制台输出 本文详细的介绍了通过broadcast state的实现简单的模式匹配，其中需要用到KeyedBroadcastProcessFunction。
如果需要了解更多内容，可以在本人Flink 专栏中了解更新系统的内容。
本文除了maven依赖外，没有其他依赖。
一、示例：按照分组规则进行图形匹配-KeyedBroadcastProcessFunction 本示例是简单的应用broadcast state实现简单模式匹配，即实现：
1、按照相同颜色进行分组，在相同颜色组中按照规则进行匹配。
2、相同颜色的规则1：长方形后是三角形
3、相同颜色的规则2：正方形后是长方形
如匹配上述规则1或规则2则输出匹配成功。
1、maven依赖 &lt;properties&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;scala.version&gt;2.12&lt;/scala.version&gt; &lt;flink.version&gt;1.17.0&lt;/flink.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-clients&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe033a8cb25b763fedb74644346753be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05bb7f18cf8475eaab165372d78652d0/" rel="bookmark">
			【PyQt小知识 - 7】：QLineEdit设置输入的文本以圆点或星号等方式显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 setEchoMode setEchoMode 在PyQt中，QLineEdit是一种用于接收用户输入的小部件（widget）。setEchoMode是QLineEdit类中的一个方法，可以用于设置文本输入框中的文本显示模式。它接受一个参数来指定要使用的模式。
setEchoMode可以设置以下几种显示模式：
QLineEdit.Normal: 正常模式下，文本会按照用户输入的内容显示。这是setEchoMode的默认模式。
QLineEdit.NoEcho: 无回显模式下，文本框中输入的文本将不会显示出来。这种模式通常用于密码输入或其他敏感信息的输入。
QLineEdit.Password: 密码模式下，文本框中输入的文本将以圆点或星号等方式显示，以隐藏实际的文本内容。
QLineEdit.PasswordEchoOnEdit: 在编辑时密码模式下，文本框中输入的文本将以圆点或星号等方式显示，但在编辑时可以看到实际文本内容。这种模式适用于需要查看正在输入的密码的情况。
下面是一个使用setEchoMode方法的示例：
from PyQt5.QtWidgets import QApplication, QLineEdit, QWidget, QVBoxLayout import sys app = QApplication(sys.argv) window = QWidget() layout = QVBoxLayout() line_edit = QLineEdit() line_edit.setEchoMode(QLineEdit.Password) # 设置为密码模式 layout.addWidget(line_edit) window.setLayout(layout) window.show() sys.exit(app.exec_()) 在上述示例中，我们创建了一个QWidget窗口，并在其中添加了一个QLineEdit小部件。我们通过调用setEchoMode方法并传入QLineEdit.Password参数，将文本框设置为密码模式。这意味着在文本框中输入的文本将以圆点或星号等方式显示。
运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b196a59ba59a5a2624324ba38f4ac10a/" rel="bookmark">
			JavaScript系列——闭包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 闭包定义词法作用域闭包示例使用场景创建私有变量ES5 中，解决循环变量的作用域问题 小结 闭包定义 闭包，是函数及其关联的周边环境的引用的组合，在闭包里面，内部函数可以访问外部函数的作用域，而外部函数不能范围内部函数的作用域，从而在内部函数形成一个相对封闭的环境。在JavaScript中，闭包随着函数创建而被创建。
词法作用域 词法作用域指的是在源码声明的变量，能够起作用的环境范围，一般是从变量所定义的位置来决定。
看以下代码：
function init() { var name = "Mozilla"; // name 是一个被 init 创建的局部变量 function displayName() { // displayName() 是内部函数，一个闭包 alert(name); // 使用了父函数中声明的变量 } displayName(); } init(); init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。
displayName() 是定义在 init() 里的内部函数，并且仅在 init() 函数体内可用。
请注意，displayName() 没有自己的局部变量。然而，因为它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。
在ES6出现以前，声明变量使用 var 关键字，这样声明的变量，其实词法作用域是全局的。在此之前，会遇到很多奇怪的问题，闭包的出现，就是为了解决这些问题。
闭包示例 我们将刚刚的init 方法改造一下
function makeFunc() { var name = "Mozilla"; function displayName() { alert(name); } return displayName; } var myFunc = makeFunc(); myFunc(); 运行这段代码的效果和之前 init() 函数的示例完全一样。其中不同的地方（也是有意思的地方）在于内部函数 displayName() 在执行前，从外部函数返回。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b196a59ba59a5a2624324ba38f4ac10a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf930707b7364833e1687dec8c505603/" rel="bookmark">
			【PyQt5设计】：自动点击神器 - 解决重复性的点击和输入操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 自动点击神器介绍测试窗口介绍自动点击神器的使用教程资源领取注意事项 自动点击神器介绍 本次使用PyQt5设计的【自动点击神器】旨在解决重复性的点击工作，解放双手，具有及时性和准确性，可选择坐标位置或图片两种方式实现鼠标的定位和点击，并可设置点击后输入相应的内容，这一功能主要解决具有重复工作的“点击-输入-点击”，最后设置时分秒或倒计时两种方式设置开始点击的时间，设置重复次数，点击“开始”按钮即可。
测试窗口介绍 本次将设计以下测试窗口，来检测和展示自动点击神器的使用效果。
测试窗口代码：
from PyQt5.QtWidgets import * from PyQt5.QtGui import * import sys class Label(QLabel): def __init__(self, imgPath, parent=None): super().__init__(parent) self.imgPath = imgPath self.setPixmap(QPixmap(self.imgPath).scaled(100, 100)) def mousePressEvent(self, evt): print('点击了：', self.imgPath) class MainWindow(QMainWindow): def __init__(self, parent=None): super().__init__(parent) self.setWindowTitle('测试窗口') self.setup_ui() def setup_ui(self): self.widget = QWidget() self.setCentralWidget(self.widget) hbox = QHBoxLayout(self.widget) vbox1 = QVBoxLayout() hbox.addLayout(vbox1) btu1 = QPushButton('A') btu2 = QPushButton('B') btu3 = QPushButton('C') btu1.clicked.connect(lambda: self.Click('A')) btu2.clicked.connect(lambda: self.Click('B')) btu3.clicked.connect(lambda: self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf930707b7364833e1687dec8c505603/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452ea5c9ce343a5fdec6640de4650830/" rel="bookmark">
			【论文简述】GeoNet&#43;&#43;: Iterative Geometric Neural Networkwith Edge-Aware Refinement for Joint D（PAMI 2022）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、论文简述 1. 第一作者：Xiaojuan Qi
2. 发表年份：2022
3. 发表期刊：PAMI
4. 关键词：深度估计，表面法线估计，3D点云，3D几何一致性，3D重建，边缘感知，卷积神经网络(CNN)，几何神经网络
5. 探索动机：以前的大多数方法独立执行深度和正态估计，可能导致预测不一致和较差的3D表面重建。预测深度图在平面区域可能会发生畸变。利用表面法线在这些区域不改变的事实可以帮助对平面进行降噪。这促使探索深度和表面法线之间的几何关系。一种可能的设计是建立一个卷积神经网络(CNN)直接从数据中学习这种几何关系。然而实验证明了目前存在的CNN架构(例如，VGG-16)不能从深度预测好的法线。发现训练总是收敛到非常差的局部最小值，即使是经过精心调整的体系结构和超参数。另一个挑战来自池化操作和大的感受野，这使得当前的体系结构在对象边界附近表现不佳。由于边界模糊，红色边界框内的点在3D中是分散的。因此，对于需要障碍物检测和避障的机器人应用来说，这是一个问题。
深度和表面法线之间的几何关系。点云是通过针孔相机模型将深度值投射到3D中获得的。通过求解线性方程组，从点云中估计表面法线；深度受到由邻近点及其表面法线确定的局部平面的约束。一方面，表面法线由与三维点的切平面确定，可以从它们的深度估计法线；另一方面，深度受到由表面法线确定的切平面局部表面的约束。
6. 工作目标：上述事实促使设计一种新的架构，明确地结合并执行考虑物体边界的3D几何约束。
7. 核心思想：提出了具有边缘感知细化的几何神经网络(GeoNet++)，它将几何约束和边界信息集成到CNN中，用于从单个图像中联合预测深度和表面法线图。
Building on top of two-stream CNNs, GeoNet++ captures the geometric relationships between depth and surface normals with the proposed depth-to-normal and normal to-depth modules. In particular, the “depth-to-normal” module exploits the least square solution of estimating surface normals from depth to improve their quality, while the “normal-to-depth” module refines the depth map based on the constraints on surface normals through kernel regression.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452ea5c9ce343a5fdec6640de4650830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad244ec662f0c1816b6cdb4458e0cc0/" rel="bookmark">
			【论文简述】Multi-sensor large-scale dataset for multi-view 3D reconstruction（CVPR 2023）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、论文简述 1. 第一作者：Oleg Voynov
2. 发表年份：2023
3. 发表期刊：CVPR
4. 关键词：三维重建、数据集、多传感器
5. 探索动机：商品硬件越来越多地提供多传感器数据。使用来自不同传感器的数据，特别是RGB-D数据，有可能大大提高3D重建的质量。例如，多视图立体算法从RGB数据生成高质量的3D几何图形，但可能会错过无特征的表面；用深度传感器数据补充RGB图像可以获得更完整的重建。相反，商品深度传感器往往缺乏RGB相机提供的分辨率。
6. 工作目标：基于学习的技术极大地简化了组合来自多个传感器的数据的挑战性任务。然而，学习方法需要合适的数据进行训练。本数据集旨在补充现有的数据集，最重要的是，通过为具有挑战性反射特性的物体提供多传感器数据和高精度真值。
7. 核心思想：提出了一种新的多传感器数据集，用于多视图三维表面重建。它包括来自不同分辨率和模式的传感器的注册RGB和深度数据：智能手机，英特尔RealSense，微软Kinect，工业相机和结构光扫描仪。场景的选择是为了强调对现有算法具有挑战性的各种材料属性。提供在14种照明条件下，从100个观看方向获取107个不同场景的140万张图像。我们期望我们的数据集将对三维重建算法的评估和训练以及相关任务有用。
8. 论文下载：
https://skoltech3d.appliedai.tech/
https://openaccess.thecvf.com/content/CVPR2023/papers/Voynov_Multi-Sensor_Large-Scale_Dataset_for_Multi-View_3D_Reconstruction_CVPR_2023_paper.pdf
二、实现过程 1. 介绍 3D重建中使用的传感器数据包括高度专业化和昂贵的CT、激光和结构光扫描仪，以及来自普通摄像机和深度传感器的视频，计算三维重建方法通常是针对特定类型的传感器量身定制的。然而，即使是商品硬件也越来越多地提供多传感器数据：例如，许多最近的手机都有多个RGB摄像头以及低分辨率深度传感器。使用来自不同传感器的数据，特别是RGB-D数据，有可能大大提高3D重建的质量。例如，多视图立体算法从RGB数据生成高质量的3D几何图形，但可能会错过无特征的表面；用深度传感器数据补充RGB图像可以获得更完整的重建。相反，商品深度传感器往往缺乏RGB相机提供的分辨率。
基于学习的技术极大地简化了组合来自多个传感器的数据的挑战性任务。然而，学习方法需要合适的数据进行训练。本数据集旨在补充现有的数据集，最重要的是，通过为具有挑战性反射特性的物体提供多传感器数据和高精度真值。
我们的数据集结构有望在几个方面有利于三维重建的研究。
多传感器数据。我们提供来自7种不同设备的高质量校准数据，包括来自商品传感器(手机、
Kinect, RealSense)，来自结构光扫描仪的高分辨率几何数据，以及来自不同分辨率和不同相机的RGB数据。这使得依赖于传感器数据的不同组合的重建方法能够进行监督学习，特别是越来越常见的高分辨率RGB与低分辨率深度数据的组合。此外，多传感器数据简化了基于不同传感器类型(RGB、depth和RGB- d)的方法比较。
灯光和位姿的可变性。我们选择专注于所有场景的受控(但可变)照明和固定摄像机位置的设置，以实现来自多个传感器的高质量数据对齐，并系统地比较算法对各种因素的敏感性。我们的目标是使数据集足够大(总共1.39 M不同模式的图像)以支持训练机器学习算法，并提供相机位姿(每个对象100个)，照明(14个照明设置，包括“硬”和漫射照明，闪光灯和背光)以及这些算法所需的反射属性的系统可变性。
目标选择。在我们数据集中的107个对象中，我们主要包括可能对上述现有算法提出挑战的对象；我们特别努力提高这些物体的三维高分辨率结构光数据的质量。
本文重点是实验室环境中单个对象的RGB和深度数据，类似于DTU数据集，而不是像Tanks and Temples或ETH3D那样具有自然光的复杂场景。这为系统探索和隔离不同算法优缺点的不同因素提供了手段，并补充了具有复杂场景的数据集提供的更全面的评估和训练数据。
图1所示。本数据集包含(a)用7种不同设备(b)在不同光照条件下捕获的RGB-D数据。(c)专注于具有3D重建算法挑战性的材料，例如无特征(F)，具有尖锐反射的高度镜面(S)或半透明(T)，如由最先进算法产生的重建所示(与右下角的“简单”对象相比)。
2. 相关工作 开发了许多与3D重建任务相关的数据集(例如，参见对同步定位和地图绘制(SLAM)相关数据集的调查)；只讨论与本文最密切相关的数据集。U表示非受控光照，帧是每个传感器计算的，也就是说，来自RGB-D传感器的所有数据都被计算为单个帧。获得的独立图像的数量可能相当大(我们的数据集为1.4 M)。对训练集和测试集的所有场景进行计数。
RGB数据集与高分辨率3D真值。许多数据集被设计用于多视图立体(MVS)方法。这些数据集还用于评估从一组RGB图像中重建由神经网络编码的隐式表面表示的方法，以及新视角合成任务。这类数据集通常包括高分辨率RGB，照片或视频，以及使用结构光扫描仪(SLS)或地面激光扫描仪(TLS)获得的高分辨率3D真值。Middlebury数据集侧重于两帧立体，除了RGB之外，还提供了准确的视差真值。在这一组中，具有可控光照和高分辨率真值的DTU数据集最常用于训练基于学习的MVS方法。大多数其他MVS数据集，虽然包含一些孤立物体的图像，但专注于完整的场景，通常是由手持、自由定位的相机收集的。与以前开发的具有高分辨率3D扫描仪数据的数据集相比，本文提供了最多数量的传感器，物体和照明条件，以及最具挑战性的物体。
低分辨率深度数据集。为SLAM、目标识别和分割等任务设计的数据集通常使用低分辨率深度传感器收集，如微软Kinect或英特尔RealSense；其中一些数据集结合了高分辨率RGB和低分辨率深度，但不提供高分辨率的深度真实值。一个明显的例外是CoRBS数据集，但它只包含四个场景。在这些数据集中，对相机位置和光照的控制程度从完全到没有不等。这些数据集通常用于非基于学习的深度融合方法的定性评估，这些方法从深度图中产生基于体素或基于表面的表面表示；它们还用于训练基于学习的方法，这些方法从RGB、深度或RGB- D数据中生成基于体素的表面表示。这些方法可能会受益于在训练中包含高分辨率深度数据。
合成数据集。ShapeNet和ModelNet常用于训练基于学习的深度融合方法。采用综合ICL-NUIM SLAM基准进行评价。这种方法受到现实数据和合成数据之间差异的限制。合成基准允许通过模拟采集过程轻松生成大型训练集。然而，真实世界的数据仍然需要准确地建模传感器，训练生成器和测试训练算法。本数据集可以用于这些目的。
具有多个深度分辨率的数据集。最近提出的RGB-D-D和ARKitScenes数据集朝着与本文类似的方向迈出了一步，分别将智能手机获取的低分辨率深度数据与中分辨率(0.3 MPix)飞行时间数据和高分辨率激光扫描数据配对。本文的数据集包含来自多个低分辨率和高分辨率深度传感器的输入，以及相关的高分辨率RGB图像，为评估和训练深度融合和RGB-D融合算法提供了一个框架，这些算法之前是在合成数据上训练的，以及开发新的。多重深度分辨率还支持深度图超分辨率等应用和深度图补全。
与本文的数据集类似，一项同时进行的工作将英特尔RealSense的RGB-D序列与通过结构光扫描捕获的注册真值进行了补充。本文提供注册深度图像从常见的传感器在三个级别的精度，并控制照明变化。
3. 数据集 本数据集由107个场景组成，其中有一个单一的日常物体或一小组物体在黑色背景上，参见图1中的示例。
使用安装在Universal Robots UR10机械臂上的多个传感器收集数据集，该传感器具有6个自由度和亚毫米级位置重复性。使用了如图2所示的传感器:(1)RangeVision光谱结构光扫描仪(SLS)，(2)两台成像源DFK 33UX250工业RGB相机，(3)两台搭载飞行时间(ToF)深度传感器的华为Mate 30 Pro手机，(4)英特尔RealSense D435立体RGB-D摄像头，(5)微软Kinect v2 ToF RGB-D摄像头。
用金属框架包围了扫描区域，并在上面安装了光源，如图2所示。7个定向灯，3个漫射软盒，以及模仿环境光的LED条。还使用手机上的手电筒作为光源随着相机移动。为了防止深度传感器之间的串扰，增加了外部百叶窗，在其他传感器成像时关闭一个传感器的红外(IR)投影仪。
对于每个场景，在物体周围半径为70厘米的球体上移动摄像机钻机100个位置，对所有场景使用相同的轨迹，并使用14个照明设置收集数据。对于每个设备，除了SLS，收集了原始的RGB，深度和IR图像，包括RealSense的左和右IR图像。总共收集了每个场景、相机位置和照明设置的15张原始图像：6张RGB图像、5张IR图像和4张深度图像。由于来自手机和Kinect的ToF传感器的IR和深度数据不受光照条件的影响，在每个相机位置捕获一次这些数据。收集了SLS的部分扫描把27个位置合并成一个扫描图。下表提供了RGB，深度和IR图像，内在(Intr.)和外在(Extr.)校准参数，以及参考网格重建(Rec.)。标记为*的数据是在每次照明设置中捕获的。
数据集包含了大量具有挑战性和不同表面材料属性的对象，如表3所示。基于对关键表面反射参数的视觉估计，为每个目标分配一组对应于这些参数的定性标签。例如，镜面率表示物体的主要材料之一的镜面反射率与漫反射反射率的比率，反射清晰度表征反射函数峰值的尖锐程度。
表3. 数据集中的表面材料属性。 ​4. 讨论 召回最好的方法是w.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ad244ec662f0c1816b6cdb4458e0cc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1321db5135216766498778703fdee4/" rel="bookmark">
			TypeError: LinearRegression.__init__() got an unexpected keyword argument ‘normalize‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 normalize在新版本的scikit-learn中已经被移除了。你可以手动normalize data。
Example:
from sklearn.preprocessing import StandardScaler from sklearn.linear_model import LinearRegression from sklearn.pipeline import make_pipeline # Create a pipeline that first standardizes the data then applies linear regression pipeline = make_pipeline(StandardScaler(), LinearRegression()) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96fbecea629fa03e0dfe33a5f6bb39f3/" rel="bookmark">
			【论文简述】GigaMVS: A Benchmark for Ultra-large-scale Gigapixel-level 3D Reconstruction（TPAMI 2021）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、论文简述 1. 第一作者：Jianing Zhang
2. 发表年份：2021
3. 发表期刊：TPAMI 4. 关键词：多视角立体视觉基准，十亿像素图像数据集，大规模场景重建
5. 探索动机：从特征工程方法到数据驱动方法，多视图立体视觉(MVS)方法得到了快速发展和广泛研究，它可以从多幅图像中重建三维几何和纹理。然而，目前还没有包含大规模场景的3D几何图形和小细节的高分辨率观测数据集来对算法进行基准测试。
6. 核心思想：为此，本文提出了GigaMVS，这是第一个用于超大规模场景的基于十亿像素图像的3D重建基准。真实几何图形由激光扫描仪捕获，覆盖超大尺度场景，平均面积为8667m2，最大面积为32007m2。由于超大规模、复杂遮挡和千兆像素级的图像，GigaMVS暴露了现有MVS算法可扩展性和效率差的问题。本文在几何和纹理测量方面彻底研究了最先进的方法，指出了现有方法的弱点和未来工作的有希望的机会。本文相信GigaMVS可以使3D重建社区受益，并支持平衡鲁棒性，可扩展性和准确性的新算法的发展。
7. 论文下载：
https://github.com/THU-luvision/GigaMVS
https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9547729
二、实现过程 1. 概述 在众多的三维重建方案中，多视角立体视觉(MVS)方法可以被动地从多幅图像中重建三维几何形状和精细纹理，被认为是一种有效、高效、低成本的方法3D建模方法。近年来，从特征工程方法到数据驱动方法，MVS方法得到了迅速发展和广泛研究。同时，MVS基准在推进和分析最新技术方面发挥着越来越重要的作用MVS方法。从历史上看，基准测试具有从小型对象到大型户外场景，从受控到自然照明条件，以及从低分辨率到高分辨率图像的增长趋势。
审查现有的基准，他们很难同时获得大尺度场景的三维几何和高分辨率观测数据。例如，优秀的坦克和寺庙[1]基准关注的是大型物体，如火车(35m2)和小寺庙(713m2)，然而，这是唯一获得低分辨率观测(800万像素)的途径。
审查现有的基准，他们很难获得大规模场景的三维几何和高分辨率观测。 例如，优秀的Tanks
and Temples基准侧重于像火车（35m2）和小寺庙（713m2）这样的大型物体，然而，然而，这是唯一的低分辨率观测(800万像素)。 相比之下，ETH3D基准提供高分辨率图像（2400万像素）。 而它只扫描实验室和庭院等中等规模的建筑（100m2）。随着MVS向大规模场景移动，它有望有一个具有挑战性的基准，包括许多详细的观察，以支持新算法的开发和研究。
本文提出了一种新的MVS基准，称为GigaMVS，它支持使用十亿像素级图像重建超大规模的3D模型。基准也被称为Palace&amp;Refelo，具有以下特点：（1）多尺度：激光扫描的三维模型包含了palace尺度的场景和Refolo尺度的局部细节，其点云由多达15亿个激光融合点组成。（2）大规模：收集的场景，最多32007m2，平均比最近的大规模数据集大20倍。（3）高分辨率：大量的千兆像素级图像（同时具有宽视场和高空间分辨率）可以为多尺度重建提供极高分辨率的细节，比现有的高分辨率三维重建基准大10倍左右。
在评估方面，基准测试提供了来自激光扫描仪的精确的地面真实3D模型，其中嘈杂的点云或不可避免的移动物体通过后处理被仔细抛光或消除。在评估过程中，不仅测量几何性能，还测量视觉质量，这可以作为三维重建基准的补充评估协议。考虑到视点稀疏度和图像分辨率会影响三维重建的性能，设置了不同的空间角度分辨率来研究现有的MVS算法。
总之，本文提出了一种新的以千兆像素级图像为输入的超大规模三维场景重建基准，即GigamVS。 MVS社区面临的挑战和机遇可以归纳如下：
大规模：扫描的场景是超大规模的，其面积比最近大规模MVS数据集的面积大一个数量级。 这种可扩展性对基于图像的三维重建技术的鲁棒性和效率提出了极大的挑战。
千兆像素图像：输入的千兆像素级图像具有宽视场和高分辨率的特性，支持高度多尺度的观察，如Palace尺度的场景和Relievo尺度的局部细节。这样的超高分辨率图像对现有算法的可扩展性和效率提出了挑战。
评估：基准提供密集的激光扫描真实三维模型，以及预先简明标记的相机位姿进行评估。除了传统的几何测量之外，还提出了纹理测量，它计算了人工图像与真实图像之间的视觉精度和完整性。
鉴于上述特点，基准GigamVS区别于现有的基准，这必将对社区产生影响，推动基于MVS的三维重建算法的发展，特别是对现实世界中具有挑战性的大规模场景的重建。
2. 相关 2.1. MVS基准
著名的Middlebury基准提供低分辨率图像(640 X 480)、激光扫描的真实模型和精确的相机位姿。作为最早的基准，Middlebury基准只扫描受控光照条件下的小物体。最近，Aanæs等人构建了包含数十个不同材料和光照条件的室内物体的DTU数据集。在DTU数据集中，100多张图像是由受控的机械臂在受控照明的实验室中捕获的。DTU数据集的图像分辨率(1600 X 1200)高于Middlebury基准。虽然DTU数据集可以为训练提供更多的图像，但受控的实验室环境和固定的摄像机轨迹使任务更容易完成。此外，许多在DTU数据集上训练的基于学习的模型对现实场景不具有鲁棒性。
由于室内基准测试的局限性，最近的基准测试更多地关注真实的室外场景。与Middlebury基准测试不同，EPFL基准测试中的图像是在室外环境中拍摄的，分辨率为620万像素。然而，EPFL的基准，只包括三个室外建筑立面，缺乏足够的数据来更好地评估。同样，Merrell等人提出的UNC数据集。同样侧重于室外场景重建，但场景规模比EPFL基准更大。UNC数据集强调在没有受控光线和常规相机姿势的情况下捕获图像的逼真条件。然而，UNC数据集只提供了一个场景，这是一个很大的限制。
Knapitsch等人从受控条件转向现实条件，构建了Tanks and Temples基准，该基准包含更多的室内和室外场景，并提供了过多的视频图像以及图像3d模型。但是，相机位姿不包括在这个基准中，因为这个基准是用于评估完整的重建管道，包括来自运动和多视图立体的结构。虽然Tanks and Temples的基准宣称专注于大规模场景的重建，但超过300平方米的场景只有3个，3万平方米左右的场景只有1个。
ETH3D基准提供了一个低分辨率(40万像素)和一个高分辨率(2400万像素)集。与Tanks and Temples基准中的评估方案类似，ETH3D中的指标通过测量精度、完整性和超过一定阈值的F分数来明确评估3D点云。然而，它只能扫描实验室和庭院等少数中型建筑(~100 m2)。在GigaMVS基准测试中，遵循几何评估协议，但用于评估的3D点云要大20倍，其中包含宫殿规模的场景和浮雕规模的局部细节。
最近的BlendedMVS数据集利用了Altizure在线平台生成100多个大型户外3D模型，并合成相应的多视图图像。然而，BlendedMVS数据集不能作为基准，因为它的三维真实模型是由Altizure重建算法生成的，而不是精确的扫描仪。相比之下，GigaMVS基准可以提供精确的3D模型进行全面评估。
一些基准测试评估了没有真实三维模型的重建结果。Chil等人利用渲染后的图像对基于人类观察者的实验重建结果进行评价。Waechter等通过将渲染后的图像与对应的真实图像进行对比，评估重建结果的质量。这些方法可以同时对重建的纹理质量和几何形状进行评价，但由于评价的视角有限，对几何形状的评价不够精确。在我们的评价方法中，除了基于真实三维模型的评价外，还采用了基于图像的纹理评价方法。
高分辨率图像。考虑到细节丰富的高分辨率图像对算法的可扩展性和鲁棒性构成挑战，Yang等提出了一种用于立体匹配的高分辨率合成数据集，输入图像分辨率为507万像素。ETH3D提供高分辨率图像，与2400万像素图像进行多视点立体匹配。近年来，随着DLSR、阵列相机等记录设备的飞速发展，以及智能手机内置的功能强大的智能摄像头，可以轻松捕捉到超高分辨率甚至千兆像素级的图像，从而引发了高分辨率数据集的革命。Wang等人提出了PANDA数据集，这是第一个千兆像素级的以人为中心的视频数据集。为了捕获大视场的高分辨率图像，PANDA使用了特殊的相机阵列，提供的图像分辨率超过25000X14000，这对现有的计算机视觉算法提出了很大的挑战。
大规模户外场景的多尺度三维重建需要高分辨率的图像，同时具有大视场和远距离细节。受PANDA数据集的启发，采用了千兆像素的成像管道来捕获输入图像，这增加了基准测试的难度。通过实验，可以清楚地看到，更高分辨率的图像可以提供更详细的信息。但是现有的算法，特别是基于学习的方法，无法处理这种高分辨率的输入图像。
2.2. 基于MVS的三维重建
MVS重建大致可分为深度图融合算法和体方法。深度图融合算法将复杂的MVS问题解耦为基于视图的深度图估计和深度图融合。一些实现良好的算法和开源的MVS库都是从这个管道开始的。例如，PMVS是一种基于块的多视点立体图像，用于处理超大规模的非结构化照片集；OpenMVS是一个开源的多视点立体图像库，它提供了一套算法，用于从局部相机和地标生成密集的点云。一些工作旨在通过使用鲁棒描述符来实现高效匹配，设计超高分辨率图像集的高效匹配管道。这些方法从匹配关键点的稀疏集开始，在过滤虚假匹配之前，将其反复扩展到附近的像素对应，然后在多个视图上聚合图像相似度。而准密集的工作等研究则侧重于更精确、鲁棒的匹配结果，甚至可以用于未校准的图像。
自第一个基于学习的MVS方法以来，许多基于学习的MVS方法都表现出了良好的性能。他们将2D图像或特征投影到3D体中，使用部署在场景空间或参考摄像机空间中的3D代价体，并通过3D CNN进行正则化。与直接通过2D特征进行处理不同，在场景空间中处理3D体的主要优点是，相机位置将隐式地包含在3D体中，并且场景的3D几何形状可以通过3D卷积层显式地预测。此外，在卷积过程中，网络在不考虑图像畸变和各种光照的情况下，以高度并行的方式获得更鲁棒的patch匹配结果。一些方法进一步将代价体改进为可变形的点云结构或点云结构，以考虑内存和效率。
体方法将三维空间划分为规则网格，并使用隐式函数或显式表面表示在全局框架中表示和优化。为了提高重构的可扩展性，一些方法要么采用八叉树表示，或者允许分层多尺度结构首次揭示了稀疏MVS问题，并在实际场景中显示出巨大的潜力。然而，这些表示中的体素点并不能直接表示具有形状和颜色的邻域信息，因此难以在超大区域内生成高保真曲面。
3. 数据集情况 GigaMVS的显著特点是为超大规模的现实场景(高达32007平方米)提供真实的3d模型和高分辨率图像(高达十亿像素级)。提出了一种新的数据收集管道来捕获和重建大规模的三维场景。利用激光扫描仪获取真值几何。然后，通过拼接多个高分辨率图像来捕获十亿像素的图像。最后，将纹理映射到真实几何，生成具有十亿像素纹理的大规模3D模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96fbecea629fa03e0dfe33a5f6bb39f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d594cca4b5d08a07c72f61ba5076f57b/" rel="bookmark">
			el-table合计行单元格合并、合并行金额四舍五入保留两位小数、合计行样式修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在写项目的时候用到了合计行，本篇文章提供了el-table使用合计行的方案。
最终效果： 合计行单元格合并3格。合计行金额四舍五入保留两位小数。合计行样式修改。 首先，先看一下Element的el-table组件的相关代码：
&lt;el-table :data="tableData" ref="tableRef" show-summary :summary-method="summaryMethod" :span-method="spanMethod"&gt; &lt;!-- 内容省略 --&gt; &lt;/el-table&gt; 这些属性或事件都是Element自带的，是本文章需要用到的，使用ElementPlus的用户可能有所差异，自行根据官方文档替换即可。
show-summary 是否在表尾显示合计行summary-method 自定义的合计计算方法span-method 合并行或列的计算方法 ok，基本属性与方法介绍完毕，下面我们直接展示代码，复制即可使用。
1. 合并单元格： methods:{ spanMethod({ row, column, rowIndex, columnIndex }) { this.$nextTick(() =&gt; { if (this.$refs.tableRef.$el) { let current = this.$refs.tableRef.$el .querySelector(".el-table__footer-wrapper") .querySelector(".el-table__footer"); let cell = current.rows[0].cells; cell[0].style.textAlign = "center"; // 合计行第一列字段居中显示。 cell[1].style.display = "none"; cell[2].style.display = "none"; // 隐藏被合并的单元格，不隐藏的话还会占着位置。 cell[0].colSpan = "3"; // 合并单元格 cell[cell.length - 3].style.color = "red"; // 修改合计行某一个单元格的样式。 } }); }, } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d594cca4b5d08a07c72f61ba5076f57b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b1bf403a2829b56d15f578bf207bcb/" rel="bookmark">
			canvas&#43;fabric实现自定义封面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div { margin: 0 auto; } &lt;/style&gt; &lt;script src="http://cdnjs.cloudflare.com/ajax/libs/fabric.js/2.4.6/fabric.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;button class="btn"&gt;点击&lt;/button&gt; &lt;button class="add-text"&gt;添加文案&lt;/button&gt; &lt;button class="to-base64"&gt;生成图片&lt;/button&gt; &lt;canvas id="canvas" width="500" style="border:1px solid black"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; const btn = document.querySelector('.btn') const addText = document.querySelector('.add-text') const base64Image = document.querySelector('.to-base64') var canvas = document.getElementById("canvas") var ctx = canvas.getContext('2d'); var left = 0 // 实例化 let fabricObj = new fabric.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5b1bf403a2829b56d15f578bf207bcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4949a74ae1c68863bb72e339a7a6a57c/" rel="bookmark">
			【⭐AI工具⭐】AI工具导航推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 零 工具导航👉【[AI工具集导航](https://ai-bot.cn/)】👈👉【[iForAI](https://iforai.com/)】👈👉【[AInav](https://www.ainav.cn/)】👈👉【[Navi AI 导航](https://www.naviai.cn/)】👈👉【[一起用AI](https://17yongai.com/)】👈👉【[AI帮您](https://www.ai8080.com/)】👈👉【[跨境卖家导航](https://www.amz123.com/ai)】👈👉【[工具达人](https://toolsdar.cn/ai)】👈👉【[AI工具箱](https://www.ailookme.com/)】👈👉【[AIGC GET](https://www.aigcget.com/)】👈👉【[优设](https://hao.uisdc.com/ai/)】👈👉【[Futurepedia](https://www.futurepedia.io/)】👈👉【[FutureTools](https://www.futuretools.io/)】👈👉【[Airadar.getinference](https://airadar.getinference.com/)】👈👉【[Theres An AI For That](https://theresanaiforthat.com/)】👈👉【[今日AI工具资源库](https://www.chinaz.com/ai/tools)】👈👉【[AiKey](https://ai.seoml.com/)】👈👉【[Top100热门AI工具](https://gpt100.ai/)】👈👉【[AIHub](https://www.aihub.cn/)】👈👉【[AILib](https://www.ai-lib.club/)】👈👉【[GPT-4 DEMO](https://gpt4demo.com/)】👈 零 工具导航 👉【AI工具集导航】👈 点此进入网页👉→⭐⭐⭐AI工具集导航
AI工具集导航将AI工具以写作、图像、视频、办公、设计、对话、编程、翻译等类别分类列出，便于用户找到适合当下使用的AI工具。
AI工具集导航还附有AI快讯、AI百科等功能，内容丰富，强烈推荐！！！
其它类似的导航：
👉【iForAI】👈 👉【AInav】👈 👉【Navi AI 导航】👈 👉【一起用AI】👈 👉【AI帮您】👈 👉【跨境卖家导航】👈 👉【工具达人】👈 👉【AI工具箱】👈 👉【AIGC GET】👈 👉【优设】👈 👉【Futurepedia】👈 点此进入网页👉→⭐⭐Futurepedia
Futurepedia当前共收录54种类别的AI工具共5000多个，用户可按类别、价格和功能搜索和过滤，找到心仪的那一款。
其它类似的导航：
👉【FutureTools】👈 👉【Airadar.getinference】👈 👉【Theres An AI For That】👈 👉【今日AI工具资源库】👈 点此进入网页👉→⭐今日AI工具资源库
今日AI工具资源库以用户收藏AI工具的热度对工具进行排行，用户在右侧所有产品分类也可对这些工具进行筛选，找到适合自己的AI工具。
其它类似的导航：
👉【AiKey】👈 👉【Top100热门AI工具】👈 👉【AIHub】👈 👉【AILib】👈 👉【GPT-4 DEMO】👈 GPT-4 DEMO汇集基于GPT-4的各种开发案例。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa6a44109d032b42709d52e98e49c780/" rel="bookmark">
			Digital Audio (HDMI)未插入 用Hdmi连接电脑 显示高清数字音频未插入 win10电脑没声音，喇叭上一个叉❌
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先说结论，出现这些问题的原因： 未插入音频设备或者硬件问题（10%）设置错误，未使用显示器音频 （30%）音频驱动不兼容或者没有驱动（50%）其他驱动有问题 （10%） 分步骤排查 首先使用系统工具扫描一下，根据建议尝试解决一次
未插入音频设备或者硬件问题 如果是显示器输出音频，先确认下耳机或者外置音响是否损坏，可以插入到其他硬件设备上 设置错误，未使用显示器音频 存在多个音频输入设备，未切换音频输出设备导致
音频驱动不兼容或者没有驱动 本质上是重新安装或者卸载驱动 参考资料：电脑没声音，喇叭上一个叉❌，显示无法找到输出设备。求大佬帮助。
其他驱动有问题 上面所有办法都尝试了，都没有解决声音疑难问题解答一直重复一个解决方案查看一下其他驱动是否有问题先体检了所有驱动，发现其他驱动有问题提前给系统创建了还原点升级错误的驱动重启，解决下面是升级完成后的解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c244c89cbac0fcdb6179aa993148f1f9/" rel="bookmark">
			C语言之三子棋小游戏的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、前期准备模块化设计 二、框架搭建三、游戏实现打印棋盘代码优化玩家下棋电脑下棋判断输赢 四、结束 前言 三子棋是一种民间传统游戏，又叫九宫棋、圈圈叉叉棋、一条龙、井字棋等。游戏分为双方对战，双方依次在9宫格棋盘上摆放棋子，率先将自己的三个棋子走成一条线就视为胜利，而对方就算输了，但是三子棋在很多时候会出现和棋的局面。
本篇博客就来进行讲解这个三子棋小游戏，跟着我来一起看把！（本文使用的编译器是VS2022）
一、前期准备 模块化设计 在写三子棋的时候，我们先要了解一下什么事模块化设计：
模块化程序设计是指在进行程序设计时将一个大程序按照功能划分为若干小程序模块，每个小程序模块完成一个确定的功能，并在这些模块之间建立必要的联系，通过模块的互相协作完成整个功能的程序设计方法
上面是百度百科的介绍，可能有同学看不懂，简单来说就是份文件写在我们写一些程序的时候就会遇到一个.c文件里写很多，会显得杂乱，可读性会变的非常差，那么我们就要使用份文件来写代码，这样就会变得条理清晰，可读性强，这样是一种良好的编程习惯，那么怎么做呢？接下来看~~ 建立一个game.h头文件：存储行列信息，包含函数库，对函数进行声明建立一个game.c文件：实现游戏中的函数建立一个test.c文件：实现函数主体逻辑，在书写时可用此函数进行测试将game.c和test.c文件中包含#include"game.h" 二、框架搭建 创建好文件后，将game.c和test.c引入game.h，头文件的包含和函数的声明就在这里面
游戏界面：
game.h
这里定义一个三行三列，并且初始化，当想要变成n行m列的只需要改一下这里define定义的就行 //行 #define ROW 3 //列 #define COL 3 //初始化棋盘 void InitBoard(char board[ROW][COL],int row,int col); 玩家输入选择，switch处理对应逻辑，输入值顺便还可以作为循环结束的条件。 test.c
#define _CRT_SECURE_NO_WARNINGS 1 #include"game.h" void menu() { printf("\n"); printf("**************************\n"); printf("***** 1.play ******\n"); printf("***** 0.exit ******\n"); printf("**************************\n"); printf("\n"); } void game() { printf("玩游戏\n"); } int main() { int input = 0; do { menu(); printf("请选择:&gt;"); scanf("%d", &amp;input); switch (input) { case 1: game(); break; case 0: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c244c89cbac0fcdb6179aa993148f1f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1ab170c4da6124afba806ca681aca79/" rel="bookmark">
			uniApp下载图片到手机相册，适配Android、Ios、微信小程序、H5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp下载图片到手机，适配Android、Ios、微信小程序、H5 1.根据不同设备展示不同的按钮1.1 图片显示1.2 微信小程序显示的按钮1.3 h5显示的按钮1.4 app显示的按钮 2. 引入需要用到的文件3. data中需要的数据4. onload方法5. methods需要用到的方法6. 获取手机相册的访问权限文件7. 注释：在使用微信小程序的时候，下载需要将域名配置一下白名单，否则没效果哦~~~ 1.根据不同设备展示不同的按钮 1.1 图片显示 &lt;view class="image"&gt; &lt;image :src="url" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; 1.2 微信小程序显示的按钮 &lt;!-- #ifdef MP-WEIXIN --&gt; &lt;view class="uni-flex align-items justify-align-center download backgroundColor" v-if="openSettingBtnHidden" @click="saveEwm"&gt;下 载&lt;/view&gt; &lt;button class="uni-flex align-items justify-align-center download backgroundColor" v-else hover-class="none" open-type="openSetting" @opensetting="handleSetting"&gt;下 载&lt;/button&gt; &lt;!-- #endif --&gt; 1.3 h5显示的按钮 &lt;!-- #ifdef H5 --&gt; &lt;view class="uni-flex align-items justify-align-center btn backgroundColor" @click="saveImgToLocal"&gt;下 载 &lt;/view&gt; &lt;!-- #endif --&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1ab170c4da6124afba806ca681aca79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c97aa66b8ec3480876fa4f9836b53b11/" rel="bookmark">
			uni-app 运行到app 报错 TypeError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行到手机、模拟器报错：
TypeError: r[t] is not a function. (In ‘rt’, ‘r[t]’ is undefined)[ERROR] : TypeError: r[t] is not a function. (In ‘rt’, ‘r[t]’ is undefined)[ERROR] : TypeError: undefined is not an object (evaluating ‘r.addVData’)[ERROR]
解决办法：
更新hbuilderX,但是我之前的HX的版本是3.1.x的，
更新后是3.2.3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c252dace87fb6615be364eb864260d/" rel="bookmark">
			网络安全人士必知的14个威胁建模方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言
网络安全的本质是攻防双方的对抗与博弈。攻击方往往凭借天赋、脑洞和个人兴趣发起五花八门的攻击活动，执行单点式攻击；但是防御方却要防住所有，全靠脑洞不讲究方法就难免会有疏漏。因此防御方需要有方法论的指导。威胁建模就是其中一种方法论和指导思想。
二、什么是威胁建模
威胁建模就是通过结构化的方法，系统地识别、评估产品的安全风险和威胁，并针对这些风险、威胁制定消减措施的一个过程。威胁模型用于分析可能的攻击者和黑客，并识别最可能的攻击途径以及最有可能成为目标的硬件和软件。防御者可以确定保护系统免受这些威胁所需的安全控制，并根据每种威胁的成本和收益决定实施哪些控制。未知攻，焉知防，我们应当站在攻击者的视角去审视网络安全问题，识别威胁，规避风险。威胁建模是结构化的理论框架，是在网络安全前辈们基于工程实践情况下总结出的理论体系框架，从审视者和践行者的眼光去构建威胁模型，在理论框架指导下，不再茫然和手足无措，有利于识别不断变化的安全威胁。
三、威胁建模的目标
威胁建模评估信息系统的威胁和风险，识别每个威胁成功的可能性，并评估组织响应每个已识别威胁的能力。主要目的如下：
识别安全要求和漏洞
量化威胁和漏洞的严重性
确定修复方法的优先顺序
四、如何进行威胁建模？
威胁建模可识别软件应用程序或计算机系统面临的威胁类型。最好在软件或系统的设计过程中进行威胁建模，以便可以在系统上线之前解决漏洞。软件、基础设施和威胁环境的变化也是重新审视威胁模型的重要机会。威胁建模一般遵循以下五个步骤：
设定分析目标。
创建要分析的系统的可视化模型。
使用可视化模型来识别系统面临的威胁。
采取措施减轻威胁。
验证威胁是否已得到缓解。
五、识别威胁建模方法的差异
威胁建模通过关注潜在攻击、系统资产或软件本身来识别威胁。以资产为中心的威胁建模侧重于系统资产以及每个目标资产损失的业务影响。以攻击为中心的威胁建模可识别针对系统的威胁，成功机会最大。以系统为中心的威胁建模侧重于在评估针对系统的威胁之前了解正在建模的系统。
六、威胁建模分类
CIA模型 CIA模型是威胁建模的一个基本框架，它有助于组织全面了解其信息资产所面临的潜在风险，围绕着保密性（C）、完整性（I）、可用性（A）三原则展开。
保密性（Confidentiality）：涉及确保信息只对授权人员可用。保密性的目标是防止未经授权的访问、披露或泄漏敏感信息。在威胁建模中，分析人员会考虑各种可能导致信息泄露的威胁和漏洞。
完整性（Integrity）： 关注信息是否在未经授权的情况下遭到修改或破坏。威胁建模的过程中，分析人员会研究可能威胁到数据完整性的因素，包括未经授权的修改、损坏或篡改。
可用性（Availability）：指的是确保信息和系统在需要时可用。可用性的目标是防止服务中断、拒绝服务攻击以及其他可能导致信息无法访问的事件。在CIA建模中，分析人员会考虑可能导致系统不可用的威胁因素，例如DDOS攻击等。
攻击树模型（Attack trees） 攻击树由90年代后期的信息安全传奇人物布鲁斯·施耐尔（Bruce Schneier）开创，提供了一种正式而条理清晰的方法来描述系统所面临的安全威胁和系统可能受到的多种攻击，是一种用于可视化和分析信息系统安全威胁的工具，它通过图形化的方式展示攻击者可能使用的路径来达到其攻击目标。我们用树型结构来表示系统面临的攻击，其中根节点表示攻击者的目标，而分支和叶子节点则表示攻击者可能采取的不同策略和步骤。该模型基于树状结构，从根节点开始，通过分支表示攻击的不同途径，直至达到叶子节点，其中包含具体的攻击手段或方法。通过穷举和抽丝剥茧的方法不断找到最清晰的攻击手段和攻击路径。
攻击树模型有助于系统管理员和安全专业人员全面了解潜在威胁和系统脆弱性。通过分析攻击树，可以识别系统中的关键节点和弱点，从而采取有针对性的安全措施。此模型可用于不同层次的威胁建模，从高级别的系统整体安全分析到详细的单个攻击路径探讨。
3. STRIDE威胁建模
STRIDE是威胁建模的鼻祖，由Microsoft安全研究人员于1999年创建，从攻击者的角度，把威胁划分成6个类别，分别是Spooling（仿冒）、Tampering(篡改)、Repudiation（抵赖）、InformationDisclosure（信息泄露）、Dos(拒绝服务)和Elevation of privilege (权限提升)。
Spoofing（欺骗）： 指攻击者伪装成合法用户或系统，以获取未经授权的访问权限。这可能涉及伪造身份、IP地址或其他标识。
Tampering（篡改）：意味着攻击者可能修改数据、配置或代码，以损害系统的完整性。这可能导致数据损坏、信息泄露或系统崩溃。
Repudiation（否认）：涉及攻击者否认其操作或交易，使其难以追踪或追究责任。这可能导致法律纠纷或证据缺失。
Information Disclosure（信息泄露）：表示攻击者可能获取系统中的敏感信息，如用户凭证、业务数据等。信息泄露可能导致隐私侵犯或敏感数据曝光。
Denial of Service（拒绝服务）：攻击者可能采取措施阻止合法用户访问系统或服务，导致系统不可用。这可能通过超载、资源耗尽或其他方式实现。
Elevation of Privilege（权限提升）：指攻击者试图获取比其正常权限更高的权限级别。这可能导致未经授权的访问和操作系统的敏感功能。
STRIDE框架提供了一个系统性的方法，有助于安全专业人员在设计和评估系统时识别潜在的威胁。通过了解这些威胁，组织能够更有效地采取措施，提高其系统的安全性。STRIDE常常与其他威胁建模方法和工具结合使用，以全面评估系统的安全性。
随着全球对隐私保护重视程度的加大，隐私安全也成了产品的一个重要威胁，STRIDE的6个威胁也添加了一项隐私（Privacy），变成了ASTRIDE，A代表Advanced。
4. DREAD威胁建模
DREAD是一种用于评估和量化安全风险的威胁建模方法，它考虑了以下五个关键方面：Damage（损害）、Reproducibility（可重复性）、Exploitability（可利用性）、Affected Users（受影响用户）和Discoverability（可发现性）。这个方法有助于组织更系统地理解潜在威胁，并优先处理最具风险的问题。
Damage（损害）：表示攻击成功发生后可能对系统造成的实际损害程度。这包括数据泄露、服务中断、财务损失等。
Reproducibility（可重复性）：表示攻击的复杂度以及攻击者是否能够轻松地重复该攻击。高可重复性意味着攻击很容易被多次执行。
Exploitability（可利用性）：衡量攻击者实施攻击的难度，以及攻击是否需要先前的专业知识或技能。较低的可利用性表示攻击相对难以实现。
Affected Users（受影响用户）：表示攻击可能影响的用户数量。如果攻击影响广泛的用户群体，风险程度可能会更高。
Discoverability（可发现性）：衡量攻击是否容易被检测或发现。低可发现性表示攻击者能够在系统中潜伏而不容易被察觉。
DREAD通过对这五个方面进行评分（通常在1到10的范围内），帮助安全专业人员量化潜在威胁的风险水平。这种评估使组织能够有针对性地制定和实施安全对策，将资源集中在最具风险的领域。DREAD常常与其他威胁建模方法结合使用，提供更全面的安全分析。
5. PASTA威胁建模
攻击模拟和威胁分析（PASTA)过程是一种由七个阶段构成的威胁建模方法，是以风险为核心，旨在选择或开发与要保护的资产价值相关的防护措施。PASTA的七个阶段如下。
阶段1：为风险分析定义目标
首先，明确定义组织的业务目标。这包括了对于组织的核心任务、服务、产品以及其它关键业务方面的清晰认知。业务目标的明确定义是PASTA威胁建模的起点，确保整个过程对业务需求有明确的了解。
阶段2：定义技术范围
确定威胁建模的技术范围，包括系统、网络、应用程序等。明确技术范围帮助建模团队集中精力于关键组件，从而更有效地识别潜在威胁。
阶段3：分解和分析应用程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1c252dace87fb6615be364eb864260d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/24/">«</a>
	<span class="pagination__item pagination__item--current">25/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/26/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>