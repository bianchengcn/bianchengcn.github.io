<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5728d24d93b9791b62824883d1399e48/" rel="bookmark">
			跟着cherno手搓游戏引擎【13】着色器（shader）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建着色器类： shader.h:初始化、绑定和解绑方法：
#pragma once #include &lt;string&gt; namespace YOTO { class Shader { public: Shader(const std::string&amp; vertexSrc, const std::string&amp; fragmentSrc); ~Shader(); void Bind()const; void UnBind()const; private: uint32_t m_RendererID; } ; } shader.cpp:主打一个粘贴代码
#include"ytpch.h" #include "Shader.h" #include &lt;glad/glad.h&gt; #include &lt;YOTO/Log.h&gt; namespace YOTO { Shader::Shader(const std::string&amp; vertexSrc, const std::string&amp; fragmentSrc) { // 1.1.创建顶点着色器对象 GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER); // Send the vertex shader source code to GL // Note that std::string's .c_str is NULL character terminated.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5728d24d93b9791b62824883d1399e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb84091792f315bdcca6c21092d48227/" rel="bookmark">
			Python进阶(1) | 使用VScode写单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python进阶(1) | 单元测试 2024.01.28
VSCode: 1.85.1
Linux(ubuntu 22.04)
文章目录 Python进阶(1) | 单元测试1. 目的2. Python Profile3. 单元测试框架3.1 什么是单元测试3.2 选一个单元测试框架3.3 编写 Python 单元测试代码3.4 在 VSCode 里发现单元测试3.5 再写一个单元和测试: IoU 的计算 4. 总结5. References 1. 目的 使用 Python 实现一些小工具、库的时候，增加单元测试来保证正确性。
重读 VSCode 的 Python 官方文档， 更新个人的 Python 开发效率。
2. Python Profile VSCode 提供了定制 profile 的功能， 个人目前理解为类似于 vim/emacs 里的模式的升级版。以前我只是配置VSCode的全局配置和当前工程配置， 而 Profile 则是建立了不同的配置，每个打开的VSCode工程都可以在不同的 profile 之间切换。
举例： 分别设置 C++ Profile 和 Python profile， 在 Python profile 和 C++ profile 中使用不同的快捷键、不同的UI布局等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb84091792f315bdcca6c21092d48227/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef4d720296fb7f92bf17968e3bdad7e/" rel="bookmark">
			ABC338(A-C)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A #include&lt;bits/stdc++.h&gt; using namespace std; int main() { string s; cin&gt;&gt;s; int l=s.length(); if(s[0]&lt;'A'||s[0]&gt;'Z'){ cout&lt;&lt;"No"&lt;&lt;endl; return 0; } else{ for(int i=1;i&lt;l;i++){ if(s[i]&lt;'a'||s[i]&gt;'z'){ cout&lt;&lt;"No"&lt;&lt;endl; return 0; } } } cout&lt;&lt;"Yes"&lt;&lt;endl; return 0; } B #include&lt;bits/stdc++.h&gt; using namespace std; int main() { string s; cin&gt;&gt;s; int l=s.length(); map&lt;char,int&gt; mp; for(int i=0;i&lt;l;i++){ mp[s[i]]++; } int max=1; char ans=s[0]; for(auto i:mp){ if(i.second&gt;max){ max=i.second; ans=i.first; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { ll n; cin&gt;&gt;n; ll q[n]; ll a[n]; ll b[n]; for(ll i=0;i&lt;n;i++){ cin&gt;&gt;q[i]; } for(ll i=0;i&lt;n;i++){ cin&gt;&gt;a[i]; } for(ll i=0;i&lt;n;i++){ cin&gt;&gt;b[i]; } ll maxs1=1e18; for(ll i=0;i&lt;n;i++){ if(a[i]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aef4d720296fb7f92bf17968e3bdad7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72ba0f12456a43099adfbfb47c042622/" rel="bookmark">
			2023年12月-华南师范大学教育技术考研回忆版真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc037469c417fb3d9c514029953e6580/" rel="bookmark">
			在腾讯云上部署幻兽帕鲁，实现游戏自由！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在帕鲁的世界，你可以选择与神奇的生物「帕鲁」一同享受悠闲的生活，也可以投身于与偷猎者进行生死搏斗的冒险。帕鲁可以进行战斗、繁殖、协助你做农活，也可以为你在工厂工作。你也可以将它们进行售卖，或肢解后食用。引用自：https://store.steampowered.com/app/1623730/Palworld
想要部署属于自己的幻兽帕鲁服务器（Dedicated Server），您首先需要拥有一台服务器，服务器是幻兽帕鲁运行的基础。部署完成后，您和您的朋友便可以登入专属的游戏服进行体验。使用云服务器搭建幻兽帕鲁服务器，便可以让您与您的朋友在一个相对独立且私密的空间中进行游戏，确保获得更加畅快的游戏体验。
您可以选择腾讯云轻量应用服务器作为游戏服务器，并按照下面教程来部署幻兽帕鲁，enjoy～
本文概要
选购服务器（内含活动推荐）
方式一：Windows 部署教程
方式二：Linux 部署教程【一键部署、手动部署】
方式三：Docker 部署教程
防火墙放通
手动配置游戏参数（可选）
登录游戏
内存优化
更多教程
常见问题
选购服务器 本文以腾讯云轻量应用服务器为例，首先来介绍如何进行选购：
登录腾讯云轻量应用服务器购买页
https://curl.qcloud.com/teQMH5wk
或选择腾讯云免费试用、年末 · 感恩回馈等活动进行选购
https://curl.qcloud.com/66hbMyRs
【活动推荐】1、如果您是腾讯云的新用户，建议您优先选择：
腾讯云免费试用（https://curl.qcloud.com/t9xK112y），4核8G轻量应用服务器免费试用一个月，还可享受专属续费优惠。
2、如果您已经是腾讯云的老用户，也不用担心，Lighthouse助力搭建游戏服重磅来袭（https://curl.qcloud.com/66hbMyRs），推荐配置（4核CPU、16G内存）的轻量应用服务器低至4折，新老同享（更多优惠陆续上新中）～
选择应用创建方式，您可以根据自己常用的操作系统进行选择，并在后续按照对应的部署教程操作：
选择Windows Server 2022，后续您可以按照【方式一：Windows 部署教程】进行部署。
选择 Windows Server 2022
选择Ubuntu 22.04 LTS，后续您可以按照【方式二：Linux 部署教程（一键部署、手动部署）】进行部署。
选择 Ubuntu 22.04 LTS
选择Debian12-Docker24（容器镜像），后续您可以按照【方式三：Docker 部署教程】进行部署。
选择Docker环境进行部署
选择地域及套餐配置:
地域：我们优先建议您选择距离较近的地域，联机体验更佳。 Tips：选择中国内地地域的轻量应用服务器套餐，可能会在部署过程中由于网络问题失败，您只需重试几次即可。
套餐规格：我们根据幻兽帕鲁官方的推荐配置，建议您选择CPU：4核，内存：16GB或以上的套餐配置。
官方配置推荐
选择套餐规格
确认其余选项后，并单击立即购买即可:
服务器名称（可选）
登录凭证
如您选择自动生成密码，那么密码将通过站内信发送给您，后续您也可登录控制台重置密码。
如您通过活动页选购服务器，创建方式、地域、套餐规格等均可参考上述内容进行选择。
登录服务器 服务器购买成功后，您首先需要登录服务器才可以进行部署。
登录 Windows 服务器 1、登录腾讯云轻量应用服务器控制台。获取服务器登录密码。如您忘记密码，可以在控制台重置密码：
重置密码
2、选中服务器实例，点击登录按钮，并在登录页面输入登录密码即可。
输入服务器登录密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc037469c417fb3d9c514029953e6580/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0a1c4d686cf398c24224980772fee95/" rel="bookmark">
			风口抓猪-借助亚马逊云科技EC2服务器即刻构建PalWorld(幻兽帕鲁)私服~~~持续更新中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pocketpair出品的生存类游戏《幻兽帕鲁》最近非常火，最高在线人数已逼近200万。官方服务器亚历山大，游戏开发商也提供了搭建私人专用服务器的方案，既可以保证稳定的游戏体验，也可以和朋友一起联机游戏，而且还能自定义经验翻倍等游戏里的一些选项。
那么如何构建一个专属于您和您的小伙伴的游戏服务器呢？这也是本文将要描述的主要内容，我们将引导您在亚马逊云科技上从最基础的服务器选型创建到Step By Step搭建游戏服务器环境，其主要步骤如下：
服务器的选型及创建脚本部署游戏优化存档备份及导入 视频教程 【亚马逊云科技】幻兽帕鲁-风口抓猪-借助亚马逊云科技EC2服务器即刻构建PalWorld(幻兽帕鲁)私服~~~持续更新中
Palworld / 幻兽帕鲁 在PalWorld中，您可以在广阔的世界中收集神奇的生物“帕鲁”，派他们进行战斗、建造、做农活，工业生产等，这是一款支持多人游戏模式的全新开放世界生存制作游戏。
在帕鲁的世界，你可以选择与神奇的生物「帕鲁」一同享受悠闲的生活，也可以投身于与偷猎者进行生死搏斗的冒险。
帕鲁可以进行战斗、繁殖、协助你做农活，也可以为你在工厂工作。当然你也可以将它们进行售卖，或肢解后食用。
利用亚马逊云科技EC2实例快速搭建私服 推荐配置 EC2服务器选型及创建 建议配置 首先参阅《Palworld tech guild》中的Requirements，我们需要4H16G的配置，那么此处建议选型m6i/7i的通用服务器，其规格比例为1:4
服务器创建 首先进入EC2控制台台，启动新实例 设置服务器名称、操作系统选择 选择实例类型、登录密钥对、网络及安全组设置 设置存储 设置User-Data 填充如下内容
#!/bin/bash wget -O - https://raw.githubusercontent.com/flying1574/PalServerInstallScript/main/ubuntuInstall.sh|sh sleep 5 export steam_user=steam export log_path=/tmp/pal_server.log export steam_user_path=~steam export steamcmd_path=$(whereis steamcmd|awk '{print $2}') sudo \cp $steam_user_path/Steam/steamapps/common/PalServer/DefaultPalWorldSettings.ini $steam_user_path/Steam/steamapps/common/PalServer/Pal/Saved/Config/LinuxServer/PalWorldSettings.ini sudo chmod 777 $steam_user_path/Steam/steamapps/common/PalServer/Pal/Saved/Config/LinuxServer/PalWorldSettings.ini # 更新游戏(可选) # sudo -u $steam_user $steamcmd_path +login anonymous +app_update 2394010 validate +quit &gt;&gt; $log_path sudo systemctl restart pal-server 登入服务器，查看pal-server是否正常运行 netstat -nulp systemctl status pal-server 登入游戏 加入多人游戏 填入已配置好的EC2实例的公网IP地址 开始游戏 查看PalWorld Server连接状况 进阶配置 游戏优化-第三方优化patch # 定义初始变量 steam_user=steam log_path=/tmp/pal_server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0a1c4d686cf398c24224980772fee95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2fe1d4fd188f6d8c74addb70143bd0/" rel="bookmark">
			layui.use是干嘛的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 layui.use是干嘛的？ ​ layui.use 是Layui框架中的一个重要方法，用于引入并使用Layui模块。Layui是一个流行的前端UI框架，它提供了一系列的模块，如表单、表格、弹出层、导航栏等，帮助开发人员构建现代化的网页界面。
​ 使用 layui.use 方法，您可以按需加载Layui的模块，并在需要的地方使用它们。这可以帮助减小页面加载时间，提高网页性能，因为您只加载了实际需要的模块，而不是全部的Layui库。
layui.use(['layer', 'form'], function(){ var layer = layui.layer; var form = layui.form; // 在这里可以使用 layer 和 form 模块提供的功能 }); Layui框架中有许多常见的模块，用于构建各种类型的网页界面。以下是一些常见的Layui模块：
layui.laytpl：用于渲染模板的模块，通常与数据结合使用，用于生成动态内容。layui.layer：用于创建弹出层、提示框和对话框的模块，用于展示信息或与用户进行交互。layui.form：用于处理表单元素、表单验证和数据提交的模块，使表单操作更加方便和灵活。layui.table：用于创建和操作数据表格的模块，包括数据的显示、分页、排序和自定义操作等。layui.upload：用于实现文件上传功能的模块，支持图片、文件等多种类型的上传。layui.carousel：用于创建轮播图和图片切换的模块，用于展示多张图片或内容。layui.element：用于处理页面元素、导航栏和选项卡的模块，用于构建多页面应用。layui.tree：用于创建树形结构的模块，通常用于导航菜单或分类展示。layui.flow：用于实现瀑布流布局的模块，适用于展示多列内容。layui.util：提供一些实用的工具函数，用于常见的操作，如日期处理、加密解密等。layui.code：用于实现代码高亮和显示的模块，通常用于展示源代码。layui.linkSelect：用于创建联动选择框的模块，支持多级联动选择。layui.date：用于创建日期选择器的模块，用于日期和时间的选择。layui.colorpicker：用于创建颜色选择器的模块，支持选择各种颜色。layui.slider：用于创建滑块（拖动条）的模块，用于选择数值范围。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/955c4e504b33b7b68f1c1729914b9fc2/" rel="bookmark">
			【C语言】（8）宏定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 宏定义(#define)是C语言预处理指令的一种，用于为程序中的值或代码片段创建别名。宏定义可以使代码更加简洁、易于维护，并且可以提高代码重用性。
2. 基本用法 定义常量 宏可以用来定义常量，代替硬编码的数字或字符串，使代码更具有可读性。
#define MAX_SIZE 100 #define GREETING "Hello, World!" 示例：
#include &lt;stdio.h&gt; #define MAX_SIZE 100 #define PI 3.14 int main() { int numbers[MAX_SIZE]; // 使用宏定义的数组大小 printf("%s\n", "Hello, World!"); // 使用宏定义的字符串 printf("The value of PI is: %f\n", PI); // 使用宏定义的常量 return 0; } 定义宏函数 宏也可以定义类似函数的代码片段，但它在编译时会被直接替换成相应的代码，而不是执行函数调用。
#define SQUARE(x) ((x) * (x)) #define MIN(a, b) ((a) &lt; (b) ? (a) : (b)) 示例：
#include &lt;stdio.h&gt; #define SQUARE(x) ((x) * (x)) #define MIN(a, b) ((a) &lt; (b) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/955c4e504b33b7b68f1c1729914b9fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e23b0e45fe03ba9eca73c92340b6bf9/" rel="bookmark">
			代码随想录算法训练营|day18
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第六章 二叉树 513.找树左下角的值112.路径总和113.路径总和ii106.从中序与后序遍历序列构造二叉树105.从前序与中序遍历序列构造二叉树代码随想录文章详解总结 513.找树左下角的值 (1)递归：复用求最大深度
先递归遍历左子树，后右子树，所以当取到最大深度时，返回对应的节点值
func findBottomLeftValue(root *TreeNode) int { if root == nil { return 0 } height := 0 leftVal := 0 var getDepth func(root *TreeNode, depth int) getDepth = func(root *TreeNode, depth int) { if root == nil { return } depth++ getDepth(root.Left, depth) getDepth(root.Right, depth) if depth &gt; height { height = depth leftVal = root.Val } } getDepth(root, 0) return leftVal } (2)迭代：最后一层第一个值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e23b0e45fe03ba9eca73c92340b6bf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd534c63b4f0c0ed5126ef400031618a/" rel="bookmark">
			操作系统（6）----线程相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.线程与进程的关系
2.线程的属性
3.线程的实现方式
用户级线程
内核级线程
多线程模型
一对一模型:
多对一模型：
多对多模型：
4.线程的状态和转换
5.线程的组织与控制
1.线程与进程的关系 可以把线程理解为“轻量级进程”。线程是一个基本的CPU执行单元也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务 (如QQ视频、文字聊天、传文件)
引入线程后，进程只作为除CPU之外的系统资源的分配单元 (如打印机、内存地址空间等都是分配给进程的)。
现在来总结一下引入线程机制后发生了哪些变化
1.传统进程机制中，进程是资源分配、调度的基本单位。引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
2.传统进程机制中，只能进程间并发。引入线程后，各线程间也能并发，提升了并发度
3.传统的进程间并发，需要切换进程的运行环境，系统开销很大。线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小引入线程后，并发所带来的系统开销减小
2.线程的属性 （1）线程是处理机调度的单位
（2）多CPU计算机中，各个线程可占用不同的CPU
（3）每个线程都有一个线程ID、线程控制块 (TCB)
（4）线程也有就绪、阻塞、运行三种基本状态
（5）线程几乎不拥有系统资源
（6）同一进程的不同线程间共享进程的资源
（7）由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
（8）同一进程中的线程切换，不会引起进程切换
（9）不同进程中的线程切换，会引起进程切换
（10）切换同进程内的线程，系统开销很小
（11）切换进程，系统开销较大
3.线程的实现方式 用户级线程 早期的操作系统 (如: 早期Unix）只支持进程不支持线程。当时的“线程”是由线程库实现的
从代码角度看，线程其实就是一段代码逻辑。上述三段代码逻辑上可以看作三个"线程"，下述while循环就可以看作一个"线程库"，线程库完成了对线程的管理调度工作。
很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。那么线程的管理工作由谁完成呢？从上面的例子可以看出，线程的管理是由应用程序完成的，不需要操作系统的介入。线程的切换工作也不需要CPU参与，直接在用户态下就能完成线程的切换工作。
注：操作系统是不知道用户级线程的存在的，他只知道这是一个进程，而进程才被分为多个线程。
所以这样的线程被称为用户级线程，只有用户才知道线程的存在，操作系统是不知道的。
用户级线程的优点和缺点：
优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行
我们之前提到过，在引入线程后，线程是CPU调度的基本单位，但是在用户级线程中，CPU调度的基本单位还是进程
内核级线程 内核级线程(Kernel-LevelThread,KLT，又称“内核支持的线程”)是操作系统支持的线程，即操作系统视角也可以看得到的线程
那么这种实现方式线程的管理工作由谁来完成呢？由于此线程是在操作系统层面实现的线程，所以管理工作由操作系统完成。并且线程的切换需要从用户态转变为内核态。
内核级线程的优点和缺点
优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
缺点:一个用户进程会占用多个内核级线程线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
多线程模型 如何将两种方式结合起来，只要在支持内核级线程的系统中，再引入线程库，就可以实现将若干个用户级线程映射到某一个内核级线程
一对一模型: 一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。
优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
缺点：一个用户进程会占用多个内核级线程线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
多对一模型： 多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。
优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行,因为只有内核级线程才是处理机的分配单位，如果一个进程只对应一个内核级线程的话，在同一时间内这个进程只能被分配一个CPU的核心，若一个进程对应多个内核级线程，那么在多核CPU的环境下，这些内核级线程肯定是可以并行执行的。
多对多模型： n用户及线程映射到m个内核级线程(n&gt;= m)。每个用户进程对应m个内核级线程。克服了多对一模型并发度不高的缺点 (一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。
总结一下：
用户级线程是"代码逻辑"的载体，而内核级线程是"运行机会"的载体，内核级线程才是处理机分配的单位。例如:多核CPU环境下，上面这个进程最多能被分配两个核。一段“代码逻辑”只有获得了“运行机会”才能被CPU执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd534c63b4f0c0ed5126ef400031618a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66bc48bb1b0393778c8d16adbda37250/" rel="bookmark">
			pytorch 卷积神经网络CNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		www.ai-xlab.com AI MOOC 卷积神经网络CNN 1 www.ai-xlab.com AI MOOC 卷积神经网络是近年发展起来，并广泛应用于图像处理，NLP等领域的一 种多层神经网络。 传统BP处理图像时的问题： 1.权值太多，计算量太大 2.权值太多，需要大量样本 进行训练。 CNN www.ai-xlab.com AI MOOC 1962年哈佛医学院神经生理学家Hubel和Wiesel通过对猫视觉皮层细 胞的研究，提出了感受野(receptive field)的概念，1984年日本学者 Fukushima基于感受野概念提出的神经认知机(neocognitron)可以看 作是卷积神经网络的第一个实现网络，也是感受野概念在人工神经网 络领域的首次应用。 局部感受野 www.ai-xlab.com AI MOOC CNN通过 局部感受野 和 权值共享 减少了神经网络需要训练的参数个数 局部感受野和权值共享 www.ai-xlab.com AI MOOC 1*1+1*0+1*1+0*0+1*1+1*0+0*1+0*0+1*1 = 4 特征图:feature map 卷积核/滤波器 卷积计算 www.ai-xlab.com AI MOOC 步长为1 步长为2 不同步长的卷积 www.ai-xlab.com AI MOOC 滤波器 www.ai-xlab.com AI MOOC Pooling常用的三种方式： 1.max-pooling 2.mean-pooling 3.stochastic pooling 池化Pooling www.ai-xlab.com AI MOOC SAME PADDING: 给平面外部补0 卷积窗口采样后得到一个跟原来大小相同的平面 VALID PADDING: 不会超出平面外部 卷积窗口采样后得到一个比原来平面小的平面 VALID PADDING SAME PADDING Padding www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66bc48bb1b0393778c8d16adbda37250/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8769be99aff81823d0be30db2c4715f1/" rel="bookmark">
			C语言与操作符相关的经典例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一道变态的面试题：不能创建临时变量（第三个变量），实现两个数的交换。
编写代码实现：求一个整数存储在内存中的二进制中1的个数。 二进制位置0或者置1
如果以下的知识点不是很清楚的可以去看这篇文章：操作符详解（上）-CSDN博客
一道变态的面试题：不能创建临时变量（第三个变量），实现两个数的交换。 这个题如果没有那个限制条件，我们一般都是创建第三个变量来处理。
法一：
//创建临时变量 #include &lt;stdio.h&gt; int main() { int a = 0; int b = 0; printf("请输入交换前的变量a与b:"); scanf("%d%d", &amp;a, &amp;b); int c = 0; c = a; a = b; b = c; printf("交换后a=%d,b=%d\n", a, b); return 0; } 第二种方法可能也是比较容易想到的，通过计算和来减去对应的。
法二：
//加减法 #include &lt;stdio.h&gt; int main() { int a = 0; int b = 0; printf("请输入交换前的变量a与b:"); scanf("%d%d", &amp;a, &amp;b); a = a + b; b = a - b;//a+b-b a = a - b;//a+b-a printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8769be99aff81823d0be30db2c4715f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2109c8efbd4e391aa51e7143481010a4/" rel="bookmark">
			Windows/MacOS 上 VSCode 配置 C&#43;&#43;：LLVM（Clang &#43; Clangd &#43; LLDB)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN 版本已不再更新，请查看 文档。
CSDN 版本已不再更新，请查看 文档。
CSDN 版本已不再更新，请查看 文档。
CSDN 版本已不再更新，请查看 文档。
CSDN 版本已不再更新，请查看 文档。
CSDN 版本已不再更新，请查看 文档。
特别声明 本教程并没有创建一个 C++ 项目，只是提供了一个配置好的开发/学习环境；为方便日常学习 C++，内置了运行/调试单个 .cpp 源代码（必须是这个后缀！）或整个文件夹的便捷脚本。
如果需要配置项目，请自行学习 CMake，并修改根目录下的 CMakeLists.txt; 同时，建议参考[附录]给出的文档修改配置。
CMake 推荐读物见文章末[CMake 推荐读物]。
前言 本教程基于 2022/3/24 发布的 LLVM 14.
教程于 2022 年 3 月 24 日即完成，奈何 Homebrew 至今（2022 年 5 月 17 日）未更新 LLVM 14，便拖延没发。
当前教程状态：Windows 已使用 LLVM 14；MacOS 仍使用 LLVM 13.
[教程目标][教程采用的形式][重写新教程的原因] 教程目标 详尽地、逐步地、手把手地给出每一步的操作：当前需要按的按键，需要按下回车的次数，可能出现的各种情况，相对应的图片……
尽量简化步骤：能由我配置好的部分，都先配置好。
教程采用的形式 先傻瓜式地配置好软件： [下载和安装]：[Windows] – [MacOS][配置][检验配置结果] 给出各配置的逐条解释：[解释] 教程中所有的资源，都集成在了 Gitee 仓库中，在相应的位置会给出链接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2109c8efbd4e391aa51e7143481010a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa960c7da82db6a414ec1dbb6eb5349/" rel="bookmark">
			第15次修改了可删除可持久保存的前端html备忘录：换了一个容器时钟，匹配背景主题：现代深色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第15次修改了可删除可持久保存的前端html备忘录：换了一个容器时钟，匹配背景主题：现代深色
备忘录代码
&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;与妖为邻的备忘录&lt;/title&gt; &lt;style&gt; /* &lt;!-- ------------------------备忘录--------------------------- --&gt; */ textarea { font-size: 20px; &amp;::placeholder { color: rgb(248, 0, 0); font-size: 12px; } } h1 { text-indent: 7em; line-height: 2em; } sub { /* 外边距: 上右下左 */ margin: 0px 40px 0px 20px; } .down-div { text-indent: 2em; } .delete { color: #ff0101; /* 靠右 */ float: right; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa960c7da82db6a414ec1dbb6eb5349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04a6057a5d593e5ce4d33049e8e6f0e1/" rel="bookmark">
			c语言的分支语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、“C语言中的分支和循环语句详解”：这篇文章详细介绍了C语言中的分支语句（if-else语句、switch语句）和循环语句（for循环、while循环、do-while循环）。它解释了每种语句的语法和用法，提供了一些示例代码，帮助读者理解如何在程序中使用这些语句来进行条件判断和重复执行。
2、“深入理解C语言中的分支和循环结构”：这篇文章深入探讨了C语言中的分支和循环结构的工作原理和用法。它解释了条件语句（if-else、switch）和循环语句（for、while、do-while）的执行流程，讨论了一些常见的陷阱和注意事项，并提供了一些实例来演示如何正确地使用这些语句。
3、“C语言控制结构：分支语句和循环语句详解”：这篇文章系统地介绍了C语言中的分支语句和循环语句。它提供了详细的语法解释、示例代码和运行结果，让读者了解如何使用条件语句和循环语句来进行程序控制。此外，文章还涵盖了嵌套分支和循环、循环控制语句（break和continue），以及一些常见的编程技巧和技巧。
demo1、分支语句示例（if-else语句）：
#include &lt;stdio.h&gt; int main() { int num = 10; if (num &gt; 0) { printf("The number is positive.\n"); } else if (num &lt; 0) { printf("The number is negative.\n"); } else { printf("The number is zero.\n"); } return 0; } demo2、分支语句示例（switch语句）：
#include &lt;stdio.h&gt; int main() { int choice; printf("Enter a number (1-3): "); scanf("%d", &amp;choice); switch (choice) { case 1: printf("You selected option 1.\n"); break; case 2: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04a6057a5d593e5ce4d33049e8e6f0e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ff2a95f2af57c2403485b4eb10670b/" rel="bookmark">
			如何在docker中安装elasticsearch中的拼音分词器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 拼音分词器的安装与IK分词器的安装这篇文章基本上是一样的，不同的是将压缩包插件换成了拼音分词器而已，其余都是一样的。最后测试如下：
GET /_analyze { "text":"我爱英雄联盟", "analyzer": "pinyin" } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a786ce04be4992c093d321a064a1b75b/" rel="bookmark">
			递增的整数序列链表的插入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List Insert( List L, ElementType X ) { PtrToNode p; p=L; while(p-&gt;Next) { if(p-&gt;Data&lt; X &amp;&amp; X&lt; p-&gt;Next -&gt; Data){ break; } if(X&lt;=p-&gt;Data){ break; } p=p-&gt;Next; } PtrToNode q; q=(List)malloc(sizeof(List)); q-&gt;Data=X; q-&gt;Next=p-&gt;Next; p-&gt;Next=q; return L; } 1.p=L而不是p=L-&gt;Next ，因为并不能确定L--&gt;Next存在不存在。
2.注意返回 return L;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9429fcb551ffbfaf3d7aec7b9850cab6/" rel="bookmark">
			PyTorch初探：基本函数与案例实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正文： 在熟悉了PyTorch的安装和环境配置后，接下来让我们深入了解PyTorch的基本函数，并通过一个简单的案例来实践这些知识。 1. 基本函数 PyTorch的核心是张量（Tensor），它类似于多维数组，但可以在GPU上运行以加速计算。张量上的操作是构建神经网络层的基础。
以下是PyTorch中一些常用的张量操作函数： torch.tensor(): 创建一个新的张量。torch.ones(), torch.zeros(): 创建全1或全0的张量。torch.randn(): 创建一个具有随机数的张量，这些随机数服从均值为0和标准差为1的正态分布（标准正态分布）。torch.matmul(): 执行矩阵乘法。torch.sum(): 计算张量中所有元素的和。 此外，PyTorch还提供了自动求导机制，这是训练神经网络的关键。通过设置张量的requires_grad属性为True，PyTorch会跟踪对该张量执行的所有操作，以便后续计算梯度。
2. 案例实践：线性回归 为了演示PyTorch的基本用法，我们将实现一个简单的线性回归模型。线性回归是一种预测模型，其中输出是输入的线性组合。
步骤如下：
导入必要的库： import torch import torch.nn as nn import torch.optim as optim 准备数据： 这里我们使用简单的人工数据来演示。
# 输入数据 x_data = torch.tensor([[1.0], [2.0], [3.0]]) # 输出数据 y_data = torch.tensor([[2.0], [4.0], [6.0]]) 定义模型： 线性回归模型可以表示为y = wx + b，其中w是权重，b是偏置。
class LinearRegressionModel(nn.Module): def __init__(self): super(LinearRegressionModel, self).__init__() self.linear = nn.Linear(1, 1) # 输入和输出都是1维的 def forward(self, x): y_pred = self.linear(x) return y_pred model = LinearRegressionModel() 定义损失函数和优化器： criterion = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9429fcb551ffbfaf3d7aec7b9850cab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18028d41bde4dd0cdccbc8f845ab67eb/" rel="bookmark">
			VR拍摄&#43;制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.VR制作需要的图片宽高是2:1，需要360°✖️180°的图片，拍摄设备主要有两种：
1）通过鱼眼相机拍摄，拍摄一组图片，然后通过PTGui来合成(拍摄复杂)
2）全景相机，一键拍摄直接就能合成需要的图片
2.通过VR制作软件进行制作，世面上常用的有720云，酷雷曼等，今天给大家推荐一个我在用的，
BZ全景编辑器BZ全景可视化编辑器 - YLong软件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afaf1e65f021e0dd148d6991850a3a16/" rel="bookmark">
			B.修改数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个长度为 n 的正整数数列 a1,a2,…,an。
你可以对其中任意个（可以是 0 个）元素进行修改。
但是，每个元素最多只能修改一次，每次修改：要么令其加 1，要么令其减 1。
请问，至少需要修改多少个元素，才能使得数列 a 变成一个等差数列。
输入格式
第一行包含整数 n (1 ≤ n ≤ 1e5)。
第二行包含 n 个整数 a1,a2,…,an (1 ≤ ai ≤ 1e9)。
输出格式
一个整数，表示需要修改的元素的最少数量。
如果无解，则输出 -1。
输入样例1：
4
24 21 14 10
输出样例1：
3
输入样例2：
2
500 500
输出样例2：
0
输入样例3：
3
14 5 1
输出样例3：
-1
输入样例4：
5
1 3 6 9 12
输出样例4：
1
解析：
我的思路是暴力枚举第 1 项和第 2 项的情况，一共 9 种情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afaf1e65f021e0dd148d6991850a3a16/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/12/">«</a>
	<span class="pagination__item pagination__item--current">13/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/14/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>