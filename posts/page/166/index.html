<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84a237ef9cb978874d5f98f0721fbd6/" rel="bookmark">
			一文搞定剑指Offer刷题(Python&amp;&amp;C&#43;&#43;)【已完结】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		03 数组中重复的数字
04 二维数组中的查找
05 替换空格
06 从尾到头打印链表
07 重建二叉树
09 用两个栈实现队列
10-1 斐波那契数列
10-2 青蛙跳台阶问题
11 旋转数组的最小数字
12 矩阵中的路径
13 机器人的运动范围
14-1 剪绳子
14-2 剪绳子2
15 二进制中1的个数
16 数值的整数次方
17 打印从1到最大的n位数
18 删除链表的节点
19 正则表达式匹配
20 表示数值的字符串
21 调整数组顺序使奇数位于偶数前面
22 链表中倒数第k个节点
24 反转链表
25 合并两个排序的链表
26 树的子结构
27 二叉树的镜像
28 对称的二叉树
29 顺时针打印矩阵
30 包含min函数的栈
31 栈的压入、弹出序列
32-1 从上到下打印二叉树
32-2 从上到下打印二叉树2
32-3 从上到下打印二叉树3
33 二叉搜索树的后序遍历序列
34 二叉树中和为某一值的路径
35 复杂链表的复制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a84a237ef9cb978874d5f98f0721fbd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd0319011beaad6b9933c7295fcebef/" rel="bookmark">
			Unity3D animator动画的性能问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		角色数目 ----同屏角色数目 高耗时函数 ----Animator.Update -----MeshSkinning.Update -----Camera.Render 角色数目 影响整体耗时面片数目 Camera.Render(PutGeometryJobFence) 渲染耗时骨骼数目 Animators.Update（DirtySceneObjects）动画相关计算MeshSkinning.Update( CalcMatrices) mesh变换矩阵的计算影响的主要是相关移动的计算 优化设置选项 Multithreaded Rendering 多线程渲染 unity5.x 以后已经稳定 optimize GameObject 选项打开 动画模式一般都要选择 Generic 模式 耗时会少 比 apply root motion 选项 Animation compression 动画压缩 推荐optimal 耗时截图 不开多线程
开启optimize 和多线程 其实 压力都到了渲染的线程，主线程其实还得等，让cpu有更多时间的干别的逻辑
Bake Mesh SkinnedMeshRenderer.BakeMesh 从蒙皮网格（skinned Mesh）转为普通网格（Mesh）提升了CPU的性能
插件 Mesh Animator 但是内存有占用，需要一个mesh数据
GPU Skinning github里面的 GPUSkinning2
作者：李偌闲
链接：https://www.jianshu.com/p/a3c18f9e32e1
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fbde659acfa88cec29a234591b94f57/" rel="bookmark">
			electron&#43;electron-builder实现能运行&#43;打包的c/s桌面应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先为了方便起见可以直接去官方获取一个快速运行的示例 直接去获取一个官方仓库的示例git clone https://github.com/electron/electron-quick-start
然后运行npm install,npm install可能会因为数据源是国外的导致下载失败或过慢的情况，可以通过
npm i -g cross-env
然后
cross-env ELECTRON_MIRROR="https://npm.taobao.org/mirrors/electron/" npm i electron
注意： npm i -g cross-env 之前需要删除原先下载失败的node_moudules后再执行。
执行完上述语句再执行 npm install 一遍。
然后就可以通过 npm start 启动这个示例项目了。
接下来是加入electron-builder实现打包 npm install electron-builder 来引入
然后在 package.json 文件中加入
"build": { "appId": "app", "productName":"electron", "win": { "icon": "images/favicon.ico" }, "electronDownload": { "mirror": "https://npm.taobao.org/mirrors/electron-builder-binaries/" } } 截图如下：
然后在 script 中加入 "dist":"electron-builder --win --x64" 这个代码意为打包为window平台 X64的exe包，如需要打成其他平台的程序，可以查阅官方文档。
注意：build中 win-&gt;icon指的是打包后.exe的图标,图标需要为256*256，并且大小在20KB以下最好，否则可能会出现界面左上角图标无法显示的问题
然后运行
npm config set ELECTRON_BUILDER_BINARIES_MIRROR=https://npm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fbde659acfa88cec29a234591b94f57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aaf9a98c69106595a1d0e2ace9adef3/" rel="bookmark">
			./与../区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 “./”：代表目前所在的目录。
“../”：代表上一层目录。
”/”开头：代表根目录。
根目录下有Site1和Image/Image.jpg，Site1下有Page1.html文件和Site2文件夹。Site2下有Page2.html和Page2Image.jpg图片文件。
1、文件在当前目录
Page2.html访问Page2Image.jpg &lt;img src=”./Page2Image.jpg”&gt;或者&lt;img src=”Page2Image. jpg”&gt; 2、文件在上一层目录
Page1.html访问Image下的Image.jpg &lt;img src=”../Image/Image.jpg”&gt; Page2.html访问Image下的Image.jpg &lt;img src=”../../Image/Image.jpg”&gt; 3、文件在下一层目录
Page1.html访问Site2文件夹下的Page2Image.jpg &lt;img src=” ./Site2/Image.jpg”&gt;&lt;img src=” Site2/Image.jpg”&gt; 4、根目录表示法,任何页面访问Image下的Image.jpg图片
&lt;img src=”/Image/Image.jpg”&gt; 三、常使用且要注意的地方
A、Css中的图片路径。写css里的图片路径，url是图片针对样式文件的位置
– index.html
– css /main.css
– images/1.jpg
如果： index.html引用main.css，且在main.css 引用images目录里的1.jpg ：
background: url(../images/1.jpg) *** 正确 background: url(images/1.jpg) *** 错误 B、Js中图片地址均相对于调用JS的页面的相对位置。
document.getElementById("IMG1").style.backgroundImage = "url(../Images/login.jpg)"; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447f38d0875843174fae0300db85134e/" rel="bookmark">
			【python】裁剪图片为指定大小，按位置截取，cv2（批量制作主图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		京东电商的主图需要800*800和624*800两种不同的尺寸（不同类目有所不同），
得到的素材是一份800*800的图片，手动裁剪成624*800效率太低了，
python又派上用场了！
用cv2模块，可以快速将图片裁剪成所需要的大小，至于裁剪的位置嘛，需要事先计算一下。
改进方向：自动按中间的位置裁剪，再升级可以改进为自动识别中心位置并进行裁剪
import cv2 img = cv2.imread("./cut/1.jpg") print(img.shape) cropped = img[0:800, 88:712] # 裁剪坐标为[y0:y1, x0:x1] cv2.imwrite("./out/1_o.jpg", cropped) 运行结果：
裁剪完成之后图片就是624*800的了。
超级方便吧~
升级版：批量裁剪
【python】批量裁剪图片为指定大小，按位置截取，cv2 （点我跳转链接）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49fcaa14f09593018f71a8fe9b46813a/" rel="bookmark">
			LearnOpenGL学习笔记—入门07：Coordinate Systems
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LearnOpenGL学习笔记—入门07：Coordinate Systems 0 前言1 坐标系统概述1.1 局部空间1.2 世界空间/模型矩阵1.3 观察空间/观察矩阵1.4 裁剪空间/投影矩阵1.4.1 正射投影1.4.2 透视投影 1.5 总结 2 代码实现2.1 更多的3d2.2 更多的立方体！2.2.1 关于DrawCall2.2.2 main代码 0 前言 本节笔记对应的内容 坐标系统
在入门01中我们配置好了环境
在入门02中我们可以检测输入并出现一个有颜色的窗口
在入门03中我们初步学习了图形渲染管线，尝试用不同方法画出了三角形和四边形
在入门04（上）中我们学习了shader和GLSL的相关知识，并给图形加上了变换的颜色以及彩色。
在入门04（下）中我们建立自己的shader类，并能够从外部读取shader的内容。
在入门05中我们了解了有关材质的内容
在入门06中，我们尝试用旋转矩阵以及四元数的方法组成变换矩阵，让它动起来，并对四元数的理解进行了一定阐述。
这一节我们会讲讲坐标系统，讲讲从3D空间得到2D平面的过程
1 坐标系统概述 在上一个教程中，我们学习了如何有效地利用矩阵的变换来对所有顶点进行变换，但是OpenGL希望在每次顶点着色器运行后，所有可见的所有顶点都为标准化设备坐标(Normalized Device Coordinate, NDC)。
标准化设备坐标，即每个顶点的x，y，z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见。将坐标变换为标准化设备坐标，接着再转化为屏幕坐标，这个过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。
将物体的坐标变换到几个过渡坐标系(Intermediate Coordinate System)的优点在于，在特定的坐标系统中，一些操作或运算更加方便和容易。对我们来说比较重要的总共有5个不同的坐标系统：
局部空间(Local Space，或者称为物体空间(Object Space))
世界空间(World Space)
观察空间(View Space，或者称为视觉空间(Eye Space))
裁剪空间(Clip Space)
屏幕空间(Screen Space)
这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。 为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是
模型(Model)矩阵、观察(View)矩阵、投影(Projection)矩阵。联合起来就是我们常说的MVP矩阵我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束。 下面的这张图展示了整个流程以及各个变换过程做了什么：
局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。最后，将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。 我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。
1.1 局部空间 拿拍照来举例，给一群人拍照，里面每个人都会调整各自的仪容仪表，各自调整就是在局部空间。 局部空间是指物体所在的坐标空间，即对象最开始所在的地方。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49fcaa14f09593018f71a8fe9b46813a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19634c55f618ea6d0873ea8d145bf5f/" rel="bookmark">
			Centos7通过Docker搭建Replication集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介 Replication集群是Mysql自带的数据同步机制；
Mysql通过读取、执行另一个Mysql的bin_log日志，实现数据同步；
集群中数据同步是单项的，从主节点（Master）同步到从节点（Slave）
安装 oracle没有提供官方的Replication镜像，所以只能安装第三方的。
docker pull mishamx/mysql docker tag mishamx/mysql rep docker rmi mishamx/mysql 创建主节点 主节点用来与其他节点之间的同步，而且主节点固定不变。
docker run -d -p 9003:3306 --name rn1 -e MYSQL_MASTER_PORT=3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_REPLICATION_USER=backup -e MYSQL_REPLICATION_PASSWORD=123456 -v rnv1:/var/lib/mysql --privileged --net=swarm_mysql rep MYSQL_ROOT_PASSWORD=123456：数据库root账户密码
MYSQL_REPLICATION_USER=backup：数据同步账户的用户名
MYSQL_REPLICATION_PASSWORD=123456：数据同步账户的密码
创建从节点 从节点需要与主节点同步数据，没有主节点不能创建从节点
docker run -d -p 9003:3306 --name rn2 -e MYSQL_MASTER_HOST=rn1 -e MYSQL_MASTER_PORT=3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_REPLICATION_USER=backup -e MYSQL_REPLICATION_PASSWORD=123456 -v rnv2:/var/lib/mysql --privileged --net=swarm_mysql rep MYSQL_MASTER_HOST=rn1：主节点的名字
注意事项 主节点关闭，从节点依然可以使用，只是主从机制失效 不启动主节点，从节点也能启动，只是主从机制失效 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75b7c3cab5de46a0ade33a9b3a2bad55/" rel="bookmark">
			byte数组与MultipartFile相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MultipartFile转化为byte数组 byte[] imgBytes = multipartFile.getBytes(); byte数组转化为MultipartFile 转换中我们会使用MockMultipartFile这个类，所有要引用相应包。 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; byte[] testFile = new byte[1024]; InputStream inputStream = new ByteArrayInputStream(testFile); MultipartFile file = new MockMultipartFile(ContentType.APPLICATION_OCTET_STREAM.toString(), inputStream); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c87347350f690b55b81ca76065d89545/" rel="bookmark">
			Java字符串或数组去掉前后的中括号标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组:
public static void main(String[] args) {
List&lt;String&gt; list = new ArrayList&lt;String&gt;();
list.add("1");
list.add("2");
list.add("3");
System.out.println(list.toString());
System.out.println(StringUtils.strip(list.toString(),"[]"));
}结果：[1, 2, 3]　1, 2, 3
字符串：
String str=list.get(0).get("phoneList");
String phoneIdList =StringUtils.strip(str,"[]");
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b02d5ccafdd58599908ef605cccd63/" rel="bookmark">
			LearnOpenGL学习笔记—入门06  附：关于四元数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LearnOpenGL学习笔记—入门06 附：关于四元数 关于四元数1 四元数的可视化1.1 从一维到复数1.1.1 左为变换作用，右为点1.1.2 从一维看旋转？1.1.3 球极投影 1.2 从二维到球体旋转1.3 三维人看四元数1.3.1 四元数1.3.2 四元数的球极投影1.3.3 四元数的乘法 2 四元数与三维转动2.1 公式如何产生？2.2 四元数化为旋转矩阵形式2.3 实现 关于四元数 避免万向节死锁的真正解决方案是使用四元数(Quaternion)
本节关于四元数的理解以及它对三维旋转的作用，主要对3Blue1Brown的视频进行了描述和理解，可以从这两个视频找到它：四元数的可视化，四元数和三维转动
官方网站是这里，有互动视频可以实操一下。
1 四元数的可视化 这个视频中，3B1B给我们建立了直观印象，看四元数对四维空间都干了什么，以此来可以更好理解四元数的公式
视频中分了以下几个主题展开
1.怎样让一个只能理解一维的人来理解复数2.向只能理解二维的人描述三维旋转3.在三维的约束下，表现四元数在干什么 1.1 从一维到复数 假设一个一维人，“小莱”，它只能理解一维几何和实数，我们向他描述复数。
我们可以选择纯代数的方法来定义复数。
以及定义复数的乘法
但是这样，“小莱”并没有清楚复数的意义在几何和空间直觉，它那非常有用的作用究竟是什么。
1.1.1 左为变换作用，右为点 我们作为理解二维空间的人，可以这么理解复数乘法
如下图的Z·W，我们可以把Z看成是对这个平面的一个变换，1通过这个变换得到了Z，而0通过这个变换则没有改变
于是Z·W，是让W以及它所在的平面进行了这么个变换，得到了对应的结果，并且在二维空间中有且只有这一种拉伸旋转（Z这种变换）才能做到。
我们在接下来理解四元数乘法时，也需要用到这种思想，即左边是一个变换的“函数”，去变换右边的数，并且理解左边的这个“函数”，是怎么变换整个空间的。
对于复数是一种“作用”的理解，可以点击这里进行复习。
1.1.2 从一维看旋转？ 现在回到“小莱”的身上，作为一维人的它，非常熟悉拉伸的变换，也就是实数的乘法。
多维上，每一维度的变换本质上没什么不同，“小莱”都可以理解，难的是如何和“小莱”介绍旋转。
比如复平面上的单位圆，上面的点到0的距离都是1，所以乘上这些点就对应着纯旋转，我们要如何对“小莱”解释这些复数乘法呢？
我们可能会觉得很难考虑，毕竟旋转是一个二维的东西。
但是旋转只有一个自由度，只有代表角度的数字，每一个角度唯一确定一个旋转。
所以所有二维旋转的集合可以把它映射到一维的数轴上，那里就是“小莱”的家。
如何进行映射，有很多方法，这次使用的是“球极投影”。
球极投影可以将圆映射到直线，球映射到平面，乃至四维超球到三维空间
1.1.3 球极投影 从-1出发做直线，穿过单位圆上的每一个点，取这条线与纵轴的交点，这便是圆上的点被投影到的地方。
点1被映射到直线的中心保持不动，i与-i也是如此。从i到1上这个90度上的所有的点，被映射到，1的对应点和i的对应点之间。i到-1这个圆弧上的点，则被映射到，i的对应点与正无穷之间。-1到i的圆弧上的点，则被映射到，-i的对应点与负无穷之间。-1本来不会映射到上面去，但是我们可以说，-1被映射到了无穷远的点上，无论沿着什么方向，走到无穷远就能看到-1对应的位置。 而这组由映射点组成的线，就是“小莱”能看懂的东西了。
这根线，仅仅是复数中距离原点长度为1的那些，即单位圆，其他的复数比如0,1+i,2等等，“小莱”并看不到。
但是没有关系，我们要做的，只是让“小莱”了解那些乘法中代表旋转的复数Z，所以只需要理解单位圆就可以了。
在圆上的旋转作用，映射到线上成为了变形的效果。
i·1=i → 1这个点进行了i这个变换（逆时针90度），对应到线上，1这个位置的点移动到了i的位置上。i·i=-1 → i这个点进行了i这个变换（逆时针90度），对应到线上，i这个位置的点移动到了-1，即移动到了无穷远。i·-1=-i → -1这个点进行了i这个变换（逆时针90度），对应到线上，-1这个位置的点移动到了-i，即从无穷远移到了-i。i·-i=1 → -i这个点进行了i这个变换（逆时针90度），对应到线上，-i这个位置的点移动到了1的位置上。 虽然是有些奇怪的运动，但是我们依靠这个方法传达了一些思想，比如，被i连乘了四次，对应着转了4次90度，我们会回到原来的地方。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03b02d5ccafdd58599908ef605cccd63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/353b379b63944c04794700cd4ac6f378/" rel="bookmark">
			VR全景的制作与拍摄
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的发展，全景技术也是在急速的发展，VR虚拟的体验也是越来越多的。VR全景技术也已经应用到了现在市场的很多行业，比如说2020疫情期间恒大推出的VR看房，汽车之家的VR看车等等。全景图成为了新的宣传潮流，全景摄影、全景视频也得到了飞速的发展。
目前实体店行业确实不太好做，成本年年增加，利润也是越来越低，市场竞争也是越来越大，很多商家都入住了美团、携程等等。商家花大价钱装修布置的精美的环境，还有商家的服务，这些都是消费者没有办法通过传统的二维平面图片感受到的。VR全景正是解决这些问题的更好的办法，VR全景把商家的服务信息更加全面无死角的还原到了互联网上面，使消费者可以真实的感受到商家的真实环境，从而提升推广效率增加客流量。这些都是传统的宣传方式所不能做到的。
VR全景看似只是一个720°无死角的展示，实际是代表着科技的进步，人们体验的一个升级，VR全景图取代传统的二维图片，这是未来的发展趋势，现在已经广泛的房地产、景区、餐饮等行业，实体店商家想把自己的企业信息完美的展示给消费者，那么VR全景将会是最好的宣传方式。而且VR全景的制作成本很低，拍摄一次就可以一直使用，而且传播渠道很广，手机电脑都可以展示。VR全景的市场前景可谓是十分的广阔。
那么VR全景是如何制作的？
拍摄的设备 全景的拍摄和传统的平面图像的拍摄方法有很大的差距。一般VR全景的拍摄有两种方式，一是使用全景自动相机拍摄，但是价格相对比较便宜的全景自动相机拍摄出来的效果不是很好，一般不用于商业用途；二是单反相机+鱼眼镜头+三脚架+全景云台的组合，这种方式拍摄出来的效果更好，可以用于商业用途。不管是使用哪种方式，拍摄出来的图片比例一定要是2:1。
全景制作平台（如：九商VR云） 可以将拍摄的制作完成的全景图上传到九商VR云里面，将拍摄的每个场景通过箭头或者是其他的标志链接起来，全方位的展示场景中的每一个细节，还可以转发到微信、微博等平台，从而达到更好的宣传效果。
现在市场上的全景拍摄是收费的，一般一个场景是五百到一千不等，市场空间跟大，收入也是很可观的。 VR全景的发展还是刚刚起步，发展前景还是很大的，而且客户的群体也很广泛，想要利用VR全景挣钱的一定要把握住机会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895e5e5b3be54640abf674fdfc835035/" rel="bookmark">
			解决IDEA的dependencies红色波浪线问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.如果是项目里面的Dependencies里面的红色波浪线，可以在pom文件里面找到相对应的依赖，剪切保存后回撤。
2.如果是项目本身的红色波浪线，可以在右键点击Reimport进行解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741f79c06a5622f92318fe687f76f852/" rel="bookmark">
			C&#43;&#43;中public、protected、private三种权限继承详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 C++中public、protected、private三种权限继承详解publicprivateprotected 总结 C++中public、protected、private三种权限继承详解 先看一下C++在继承中的访问权限
权限/作用域全局派生类当前类private✖✖✔protected✖✔✔public✔✔✔ public public继承是一种最简单的继承，基类的成员在派生类中保持原有的权限不会被更改。
public继承示例：
#include &lt;iostream&gt; using namespace std; /* 公有继承Test. */ class Father { //基类的私有变量 private: void test() { cout &lt;&lt; "Father's Private." &lt;&lt; endl; } //基类的保护变量 protected: void test1() { cout &lt;&lt; "Father's Protected" &lt;&lt; endl; } //基类的公共变量 public: void test2() { cout &lt;&lt; "Father's Public" &lt;&lt; endl; } }; //基类的派生类: 共有继承 class Son:public Father { public: //派生类的成员 void son_func() { test1(); //基类的protect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/741f79c06a5622f92318fe687f76f852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44859007e08660582ebc1772e91cf6bd/" rel="bookmark">
			Java 中用SCPClient远程上传下载文件到linux服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 中用SCPClient远程上传下载文件到linux服务器 记录一次最近在工作中用到的，需求是在一台服务器部署代码，需要远程上传下载文件到另一台服务器（Linux系统）
，核心方法用到的就是SCPClient类，看了一下源码 ，就是远程连接目标服务器，通过linux命令上传和下载，不多上源码
SCPClient 需要导入的jar包 （maven形式） &lt;dependency&gt; &lt;groupId&gt;ch.ethz.ganymed&lt;/groupId&gt; &lt;artifactId&gt;ganymed-ssh2&lt;/artifactId&gt; &lt;version&gt;262&lt;/version&gt; &lt;/dependency&gt; SCPClient 实现上传 public static void main(String[] args) { //连接服务器 服务器名称和端口号 //xx.xx.xx.xx 就是目标服务器的ip 端口是22 Connection connection = new Connection("xx.xx.xx.xx",22); //你要上传文件所在地址，linux和window路径不一样看你自己的系统 String filePath1 ="C:/JepsFile/202007211503.png" ; File f = new File(filePath1); try(FileInputStream fis = new FileInputStream(f)) { connection.connect(); //yuan服务器用户名和密码 boolean isAuthenticated = connection.authenticateWithPassword("root","root"); if(!isAuthenticated){ System.out.println("连接建立失败"); return ; } SCPClient scpClient = new SCPClient(connection); //这个是你要上传文件的目标服务器的文件路径 String remoteTargetDirectory = "/app/JepsUpload/sup/202007/"; SFTPv3Client sftpv3Client = new SFTPv3Client(connection); //判断是否有这个文件夹 如果没有就创建一个 Boolean isdir = isDir(sftpv3Client, remoteTargetDirectory); if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44859007e08660582ebc1772e91cf6bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fd2650227c02611b95aee6a7bdea045/" rel="bookmark">
			LeetCode算法 ——  K 个一组翻转链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
示例：
给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5
当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5
当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5
说明：
你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
只要我们会对链表进行一个翻转就行了，然后就是对每一组的头部与尾部的处理，我把翻转的代码写好之后，直接把别人的java版本的代码转为C++ 版本的 . . .
.
相关代码文章如下所示：
LeetCode算法 —— 反转链表（递归 + 迭代）
代码如下所示：
#include &lt;iostream&gt; using namespace std; struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} }; class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { if (head == nullptr || head-&gt;next == nullptr) return head; ListNode* retList = new ListNode(0); retList-&gt;next = head; ListNode* pre = retList;	// 指向当前组的头 ListNode* end = retList;	// 指向当前组的最后一个节点 while (end-&gt;next) { // 遍历到当前组的最后一个节点 for (int i = 0; i &lt; k &amp;&amp; end !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fd2650227c02611b95aee6a7bdea045/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da9fdd5838840173749a52737ea40919/" rel="bookmark">
			安装visdom可视化工具以及解决一直卡在Downloading scripts的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装visdom 1,直接在控制命令符中使用pip install visdom
2,下载最新的visdom，然后解压安装
(1)下载地址：https://github.com/facebookresearch/visdom，下载压缩包，解压
(2)在cmd中进入相应的目录，并执行命令pip install -e .进行安装
我安装成功的版本：
检查安装结果： 执行命令：python -m visdom.server
代表安装成功
会出现的错误： 一直卡在Downloading scripts, this may take a little while，无法继续进行。
试过很多办法，包括重新下载，使用更新命令都不行。
解决办法： 打开visdom的安装目录，我是在anaconda下，所以依次打开D:\soft\Anaconda3\Lib\site-packages\visdom
打开server.py，并修改函数download_scripts_and_run()，函数在最下面
如图：注释掉download_scripts()
最后执行
成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725cb6ae2f886e7d1c9dfc81b51714ae/" rel="bookmark">
			MySQL sql语句获取当前日期|时间|时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章转载于：博客园——水狼一族
文章地址：《MySQL sql语句获取当前日期|时间|时间戳》
一、基础时间函数 1.1 获得当前日期+时间（date + time）函数：now() MySQL&gt; select now(); +———————+ | now() | +———————+ | 2013-04-08 20:56:19 | +———————+ 除了 now() 函数能获得当前的日期时间外，MySQL 中还有下面的函数：
current_timestamp() ,current_timestamp ,localtime() ,localtime ,localtimestamp — (v4.0.6) ,localtimestamp() — (v4.0.6) 这些日期时间函数，都等同于 now()。鉴于 now() 函数简短易记，建议总是使用 now() 来替代上面列出的函数。
1.2 获得当前日期+时间（date + time）函数：sysdate() sysdate() 日期时间函数跟 now() 类似，不同之处在于：now() 在执行开始时值就得到了， sysdate() 在函数执行时动态得到值。看下面的例子就明白了：
mysql&gt; select now(), sleep(3), now(); +———————+———-+———————+ | now() | sleep(3) | now() | +———————+———-+———————+ | 2013-04-08 20:57:46 | 0 | 2013-04-08 20:57:46 | +———————+———-+———————+ mysql&gt; select sysdate(), sleep(3), sysdate(); +———————+———-+———————+ | sysdate() | sleep(3) | sysdate() | +———————+———-+———————+ | 2013-04-08 20:58:47 | 0 | 2013-04-08 20:58:50 | +———————+———-+———————+ 可以看到，虽然中途 sleep 3 秒，但 now() 函数两次的时间值是相同的； sysdate() 函数两次得到的时间值相差 3 秒。MySQL Manual 中是这样描述 sysdate() 的：Return the time at which the function executes。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/725cb6ae2f886e7d1c9dfc81b51714ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feec0a36def3066eda09c2621c73eda3/" rel="bookmark">
			【剑指Offer系列14-1】剪绳子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 题目代码PythonC++ 题目 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
示例 1：
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
提示：
2 &lt;= n &lt;= 58
代码 Python # 思路： # 动态规划问题，自下而上求解 # 复杂度： # O(N^2) class Solution: def cuttingRope(self, n: int) -&gt; int: # 初始化动态数组 dp = [0 for _ in range(n+1)] dp[2] = 1 for i in range(n+1): for j in range(i): dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j])) # “上一次最大值，j处剪且不再剪，j处剪且再剪”三者的最大值 return dp[n] C++ class Solution { public: int cuttingRope(int n) { vector&lt;int&gt; dp(n+1,0); dp[2]=1; for (int i=3;i&lt;=n;i++) for (int j=0;j&lt;=i;j++) dp[i]=max(dp[i], max(j*(i-j), j*dp[i-j])); return dp[n]; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980939559cd6ea96b1fc2d9a3e9b0fde/" rel="bookmark">
			【剑指Offer系列13】机器人的运动范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目代码PythonC++ 题目 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
示例 1：
输入：m = 2, n = 3, k = 1
输出：3
示例 2：
输入：m = 3, n = 1, k = 0
输出：1
提示：
1 &lt;= n,m &lt;= 100
0 &lt;= k &lt;= 20
代码 Python # 思路： # 类似于矩阵路径问题，采用回溯法+剪枝 # 复杂度： # O(MN) class Solution: def movingCount(self, m: int, n: int, k: int) -&gt; int: def dfs(i,j,si,sj): # 索引越界或数位和溢出或当前元素已访问，返回0 if i&gt;=m or j&gt;=n or k&lt;si+sj or (i,j) in visited: return 0 visited.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/980939559cd6ea96b1fc2d9a3e9b0fde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21cb8951d247792ea8e5be1335288b30/" rel="bookmark">
			LearnOpenGL学习笔记—入门05：Texture
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LearnOpenGL学习笔记—入门05：Texture 0 前言1 纹理简介2 stb_image.h3 纹理坐标4 纹理环绕方式/纹理过滤5 代码实现/彩色木箱6 纹理单元/多材质代码7 完整代码 小学期终于结束了（并且摸鱼了一个星期后）,可以回来更新了Orz，总是拖拖拉拉的（瘫 0 前言 本节笔记对应的内容 纹理
在入门01中我们配置好了环境
在入门02中我们可以检测输入并出现一个有颜色的窗口
在入门03中我们初步学习了图形渲染管线，尝试用不同方法画出了三角形和四边形
在入门04（上）中我们学习了shader和GLSL的相关知识，并给图形加上了变换的颜色以及彩色。
在入门04（下）中我们建立自己的shader类，并能够从外部读取shader的内容。
在这一节，我们将会了解有关材质的内容
1 纹理简介 在之前的学习中，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。
但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色，这将会产生很多额外开销。
程序员更喜欢使用纹理(Texture)。
纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；可以想象纹理是一张墙纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像墙纸的外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。
2 stb_image.h 使用纹理之前要做的第一件事是把它们加载到我们的应用中。
所以我们如何才能把这些图像加载到应用中呢？
使用一个支持多种流行格式的图像加载库来为我们解决这个问题。比如说要用的stb_image.h库。
在这里下载，进去以后点选Raw，在新出现的页面中，右键另存为，存到自己的目录里，在VS中右键，添加现有项目，将这个库导进来。
3 纹理坐标 如何将这么一份材质映射(Map)到一个三角形上呢？
我们需要指定三角形的每个顶点，各自对应纹理的哪个部分。
这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样。
之后在图形的其它片段上进行片段插值(Fragment Interpolation)。
纹理坐标在x和y轴上，范围为0到1之间（2D纹理图像）。
使用纹理坐标获取纹理颜色叫做采样(Sampling)。
纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。
4 纹理环绕方式/纹理过滤 关于纹理环绕方式，原教材感觉写的蛮精简了，不过需要注意的是，导入的材质图片最好是2的幂次方的边长
关于纹理过滤
纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel)映射到纹理坐标。
当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。
OpenGL有对于纹理过滤(Texture Filtering)的选项。
纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。
GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。
当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。
下图中有四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：
GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）是基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。
一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。
下图中可以看到返回的颜色是邻近像素的混合色：
但是想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。
有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。
由于远处的物体所产生的片段很少，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它只拾取一个纹理颜色却要跨过纹理很大的部分。
在小物体上这会产生不真实的感觉，并且对它们使用高分辨率纹理很浪费内存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21cb8951d247792ea8e5be1335288b30/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/165/">«</a>
	<span class="pagination__item pagination__item--current">166/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/167/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>