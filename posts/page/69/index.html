<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e6bc0289ee01fc8f7d15ad20b8a5c2/" rel="bookmark">
			服务器环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载安装anaconda wget https://repo.anaconda.com/archive/Anaconda3-5.3.1-Linux-x86_64.sh
bash Anaconda3-5.3.1-Linux-x86_64.sh
source /root/anaconda3/etc/profile.d/conda.sh
echo “. /root/anaconda3/etc/profile.d/conda.sh” &gt;&gt; ~/.bashrc
conda update conda
创建环境 cd /root/codedir
conda create -n py38 python=3.8
conda env list
conda activate py38
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple
更新nodejs 初次拿到服务器 node版本可能不是最新的 建议更新一下。
下载npm
apt-get update
apt install npm
更新nodejs 并且查看版本
sudo npm install -g n
sudo n stable
node -v
安装pm2 apt-get update
apt install npm
npm install pm2 -g
后台模式运行 nohup python -u startup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90e6bc0289ee01fc8f7d15ad20b8a5c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad08ee5c3ac4c7e9ba1c0afc74314fed/" rel="bookmark">
			在anconda虚拟环境中导入whl文件类的第三方库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把下载好的whl文件导入虚拟环境（以导入pooch库为例）：
1.打开虚拟环境的小黑框
2.输入：
activate CNN(CNN是我要激活的虚拟环境名称，也就是我要把这个库安装到CNN这个环境里)
3.进入到CNN的虚拟环境，输入 ：
pip install E:\AIhellword\pooch-0.7.1-py3-none-any.whl
（.whl文件存放的位置，随便哪里都可以）
4.出现successfully即安装成功，在pycharm中就可以用啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb475af63d84830306f560db51a1af89/" rel="bookmark">
			WPS表格Excel：数字前补0和字符拼接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WPS表格Excel：数字前补0和字符拼接 原始数据与目标数据 步骤 1、拆分数据 使用=LEFT(A2,2)取出字母和符号部分 使用=MID(A2,3,3)取出数字部分，第2个参数3和第3个参数3应根据实际情况调整（也可使用FIND函数和LEN函数进行动态计算） 2、对数字进行补0 复制数字列并粘贴为数值（ctrl+shift+V） 选中该列，点击开始-类型转换-文本型数字转为数字 右键该列，设置单元格格式 重点：再次点击开始-类型转换 数字转为文本型数字（只有转换后我们补上去的0在拼接时才不会丢失） 3、重新拼接字母、符号和数字 使用=C2&amp;E2进行字符拼接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fa27aa5454e94fedcc6bf330e3f1fb5/" rel="bookmark">
			FPGA：什么是IO单元、IO标准、Bank、VCCO、VREF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I/O单元 是芯片与外界电路的接口部分
I/O bank 含义：组
特征：共用一个电源的一组I/O管脚
FPGA的IOB（input/output buffer）被划分为若干个组（bank），每个BANK都有VCCO和VREF
VCCO 端口电压，电平标准，同一个VCCO下可兼容不同的IO标准
VREF 参考电压，给部分输入标准提供参考电压
IO标准 根据外部器件需求，选择IO标准
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beec6eeb519661d03115814cc09547d5/" rel="bookmark">
			训练AI数据模型所需要的高性能计算机配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
配置一
配置二
配置三
云服务器和超级计算机
AI模型训练是一种机器学习的过程，通过训练深度学习模型来自动化处理数据和完成任务。AI训练可以帮助企业和研究人员开发出更加智能、高效的应用，从而提高生产力和创新能力。
以下是按训练性能从低到高的3种高性能计算机配置：
配置一： 要训练更大的AI数据模型，需要配备高性能的计算机，以下是一些常见的高性能计算机配置：
处理器：选择处理器时，建议选择具有高性能的多核心CPU，例如Intel Core i9、AMD Ryzen Threadripper等。
显卡：显卡是训练深度学习模型时最重要的组件之一，建议选择NVIDIA的GPU，如GeForce RTX、Quadro、Titan等。
内存：建议选择具有高速的ECC或DDR5内存。
存储器：建议选择大容量、高速的SSD，NVMe固态硬盘，以确保数据能够快速地被读取和处理。
网络：建议选择支持高速网络连接的计算机，以便在多个节点之间进行分布式训练。
电源：为了满足计算机高负载的需求，建议选择高功率的电源，例如800W或以上。
在购买计算机时，可以根据具体的需求和预算选择适当的配置。同时，还可以考虑使用云计算平台，如AWS、GCP、Azure等，以获得更高的灵活性和可扩展性。无论是购买自己的计算机还是使用云计算平台，都需要确保计算机的配置满足训练高性能AI数据模型的需求。
配置二： 如果需要训练更大规模、更复杂的AI数据模型，还有更高端的配置可供选择。以下是一些常见的高端配置：
处理器：可以选择Intel Xeon、AMD Epyc等高端服务器级别的多核心CPU，以获得更高的计算性能和更好的稳定性。
显卡：可以选择更高级别的NVIDIA GPU，如Tesla、A100等，以获得更大的显存、更高的计算性能和更好的精度。
内存：可以选择更高速、更大容量的内存，例如DDR4 3600MHz以上，甚至可以使用HBM2内存。
存储器：可以选择更高速、更大容量的SSD，NVMe固态硬盘，或者使用RAID阵列技术以提高磁盘I/O性能。
网络：可以选择更高速的网络连接，例如40Gbps、100Gbps以太网或InfiniBand等。
电源：可以选择更高功率的电源，例如1000W或以上，以确保计算机的稳定性和可靠性。
配置三： 如果需要训练更加复杂和大规模的AI数据模型，还有更高端的配置可供选择。以下是一些最高端的配置：
处理器：可以选择更高端的服务器级别处理器，如AMD EPYC Rome、Intel Xeon Scalable等，这些处理器能够提供更高的计算能力和更多的内存带宽。
显卡：可以选择更高端的GPU，如NVIDIA A100 Tensor Core等，这些GPU具有更高的显存、更高的计算性能和更高的精度。
内存：可以选择更高速、更大容量的内存，如DDR4 5600MHz以上，甚至可以使用HBM2E内存。
存储器：可以选择更高速、更大容量的NVMe固态硬盘或Intel Optane SSD，或者使用更高端的存储技术，如3D XPoint等。
网络：可以选择更高速的网络连接，如InfiniBand EDR 100Gbps或HDR 200Gbps等。
电源：可以选择更高功率的电源，如2000W或以上，以确保计算机的稳定性和可靠性。
需要注意的是，这些最高端的配置需要相应更高的预算，并且需要在软件、工具和算法等方面有更高的要求，才能充分发挥其优势。因此，在选择最高端的配置时，需要仔细考虑实际需求和预算，并选择与之匹配的软件、工具和算法。
云服务器和超级计算机： 目前全球最高端的AI数据模型训练配置是由一些超级计算机中心和云服务提供商提供的超级计算机集群，它们由成千上万个处理器、显卡和大容量存储器组成，能够以每秒数百万亿次浮点运算的速度进行计算，同时处理大规模的数据集。这些计算机集群通常采用了先进的技术，如高速互联网络、液冷技术、错误容错等，以提高能效和可靠性。
此外一些云服务提供商还提供了具有极高性能和灵活性的AI数据模型训练服务，这些服务可以在云端提供数千个GPU或者TPU的计算资源，以及高效的存储和互联网络。这些服务支持多种不同的AI框架和算法，并提供了丰富的AI开发和调试工具，以帮助用户快速开发和部署AI模型。
虽然这些超级计算机集群和云服务的价格非常昂贵，但是它们能够支持极其复杂和大规模的AI数据模型训练任务，如图像识别、自然语言处理、智能推荐、语音识别等。同时，它们还可以帮助企业降低成本和提高效率，加速AI应用的部署和推广。
总之，选择适合自己需求和预算的AI数据模型训练配置非常重要，需要仔细考虑实际需求和预算，并选择与之匹配的软件、工具和算法。
另外我准备了一些训练模型和云服务器配置的资料持续更新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e6acceee0e5b39d06dbdd8a4a4fc9b/" rel="bookmark">
			云主机操作系统为ubuntu，如何使用root用户来远程登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云主机操作系统为ubuntu，如何使用root用户来远程登录 Ubuntu 操作系统默认用户名为ubuntu ，并且默认关闭root用户。
从安全角度，一般不建议使用root用户来远程登录。
如果确实有需要，操作步骤如下：
以Ubuntu 18.04.2 LTS 为例，如需开启请做以下步骤：
启用root用户，并设置密码 sudo passwd root 修改sshd_config配置文件 不同ubuntu版本的sshd_config 文件位置可能不一致；常见位置如下：
sudo vim /etc/ssh/sshd_config 原始为“#PermitRootLogin prohibit-password” ，添加一条“PermitRootLogin yes”
修改完毕后保存并重启ssh 服务
sudo /etc/init.d/ssh restart 此时即可使用root用户远程登录操作系统为ubuntu的云主机
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa211f028f62b283a07522f499b3fdd/" rel="bookmark">
			SQLMAP的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、SQLMAP 介绍
1、SQLMAP 简介
2、SQLMAP 支持的注入类型
3、运行 sqlmap
4、SQLMAP 常用参数介绍 二、SQLMAP 常用探测方式
1、探测单个目标
2、探测多个目标
3、从文件加载 HTTP 请求进行探测
4、从 burpsuite 日志记录中进行探测
5、检测 SQL 注入漏洞存在的技术类型
6、枚举数据库信息
三、SQLMAP 请求参数
1、默认的请求参数
2、修改默认请求参数
3、使用代理进行探测
4、忽略未验证错误
5、sqlmap 安全模式
6、关闭 URL 编码
一、SQLMAP 介绍 1、SQLMAP 简介 SQLmap 是一款用来检测与利用 SQL 注入漏洞的免费开源工具，有一个非常棒的特性，即对检测与 利用的自动化处理（数据库指纹、访问底层文件系统、执行命令）。 官方网站下载 http://sqlmap.org/ 2、SQLMAP 支持的注入类型 sqlmap 支持 5 种漏洞检测类型： 1. 基于布尔的盲注检测 2. 基于时间的盲注检测 3. 基于错误的检测 4. 基于 union 联合查询的检测 5. 基于堆叠查询的检测 拓展：堆叠查询注入 Less-38 http://192.168.1.63/sqli-labs/Less-38/?id=1 '; insert into users(id,username,password) values ('66','root','123')--+ 使用;分号来直接添加一条新的 SQL 语句来进行执行就是堆叠查询注入。 例： 3、运行 sqlmap Kali 中运行 sqlmap 的方式 其实这种方法其实就是在终端执行了 sqlmap -h 这样一条命令 └─# sqlmap -h 4、SQLMAP 常用参数介绍 sqlmap --version #查看 sqlmap 版本信息.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fa211f028f62b283a07522f499b3fdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b003daf5da3305a90d3a03e9d44575f/" rel="bookmark">
			Markdown是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		● markdown 指的是一种文本格式, 是一种轻量级标记语言, 大多都是程序员在使用, 不管什么语言的程序员, 其实都比较喜欢这种格式.
● 他是一种极简的文本格式, 用最简单的方式写出带有格式的内容
● 对于程序员来说, 写出来的文本类内容, 是不是好看并不那么重要, 我们主要关注内容.
○ 也就是说, 只要标题清晰, 有个代码段能让我比较好的格式的写一些代码
○ 大致的缩进能区别出标题级别也就可以了
○ 多了就是一个 图片, 超链接, 表格啥的, 如果能有就最好了
● markdown 就是这样一种格式的文本
如何查看 markdown ● markdown 格式文本, 文件后缀是 .md
● 只要打开编辑器基本上都能编辑
● 但是如果你想单独查看 markdown 格式文档
● 那么需要下载一个可视化软件
○ 比如你要看 word 文档, 需要安装一个 office
○ 比如你要看 mp4 文件, 需要安装是一个 快播
○ 是一个道理
○ 那么你要看 markdown 就要下载一个能适配的软件
● 一般来说, 我们会使用 typora 软件来查看
○ 因为这个软件比较轻量, 也很方便
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b003daf5da3305a90d3a03e9d44575f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1739e3e40ce1768ee0e959da6b2ade/" rel="bookmark">
			java基础知识汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Java基础语法
1、类型转换问题
1. 运算符
1.1 算术运算符（理解）
1.2 赋值运算符（应用）
1.3 自增自减运算符（理解）
1.4 关系运算符（应用）
1.5 逻辑运算符（应用）
1.6 三元运算符（理解）
2. 数据输入（应用）
3、流程控制语句（应用）
1.1 流程控制语句分类
1.2 顺序结构
1.3 分支结构：if语句
1.4 分支结构：switch语句
1.5 循环结构：for循环
1.6 循环结构： while循环
1.7 循环结构：do-while循环
1.8 三种循环的区别（理解）
1.9 跳转控制语句（掌握）
1.10 循环嵌套（理解）
1.11 Random
4.数组
1.1什么是数组【理解】
1.2数组定义格式【记忆】
1.3数组动态初始化【应用】
1.4数组元素访问【应用】
1.5内存分配【理解】
1.6单个数组的内存图【理解】
1.7多个数组的内存图【理解】
1.8多个数组指向相同内存图【理解】
1.9数组静态初始化【应用】
1.10数组操作的两个常见小问题【应用】
1.11数组遍历【应用】
1.12数组最值【应用】
5. 方法概述
1.1 方法的概念（理解）
2. 方法的定义和调用
2.1 无参数方法定义和调用（掌握）
2.2 方法调用过程图解（理解）
2.3 无参数方法的练习（应用）
3. 带参数方法定义和调用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d1739e3e40ce1768ee0e959da6b2ade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df738878f3d82158dde534b05edba84a/" rel="bookmark">
			Unity 中的 DrawCall
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity DrawCall是游戏中一个非常重要的概念，也是开发者在优化游戏性能时需要重点考虑的问题。本文将会从以下几个方面详细介绍Unity DrawCall的相关知识：
1. 什么是DrawCall
2. DrawCall的影响因素
3. 如何减少DrawCall的数量
4. Unity中DrawCall的优化手段
一、什么是DrawCall？
在理解DrawCall之前，我们要先知道渲染引擎的工作方式。在大多数游戏中，渲染引擎会首先处理场景中的每一个物体，将其转换为一系列的三角形和顶点。随后，这些三角形和顶点将被发送到GPU进行处理和渲染，最终形成输出图像。
一个DrawCall表示一次将物体（或者场景中的所有三角形）发送到GPU进行处理和渲染的操作。也就是说，当我们在游戏中添加物体，或者为它们设置新的材质或者纹理时，都会导致DrawCall数量增加。
通常情况下，任何绘制或渲染操作都会对DrawCall数量产生影响。因此，在游戏设计的过程中，我们应该尽可能地减少DrawCall的数量，以提高游戏的性能。
二、DrawCall的影响因素
下面是几个可能导致DrawCall数量增加的因素：
1. 物体数量：不同的游戏物体会生成不同数量的DrawCall。
2. 网格和三角形数量：一个物体的三角形数量越多，它的DrawCall数量就越高。
3. 材质数量：在游戏中使用不同数量的材料和纹理也会影响DrawCall数量。
4. 相同物体排序：当多个相同的物体重叠在一起时，会产生更多的DrawCall数量。
三、如何减少DrawCall的数量
为了减轻渲染引擎的工作负担，提高游戏性能，我们可以采取以下措施：
1. 合并网格
合并网格是一种有效的方法，可以将多个物体合并为一个大的物体。使用该方法可以将物体数量减少，从而减少DrawCall的数量。在Unity中，可以通过将多个游戏物体添加到父物体并为其设置合适的网格，将其合并为一个单独的物体。
2. 使用LOD模型
Level of Detail（LOD）模型是一种方法，通过在距离相机较远时使用更简单的模型来减少三角形的数量。LOD模型可以显著减少DrawCall数量，从而提高游戏性能。在Unity中，可以通过使用Unity Pro版本中的LOD Group组件来实现。
3. 合并材料和纹理
Unity的批量处理功能可以将许多物体合并为一个DrawCall。当多个物体使用的材质和纹理相同时，它们可以被合并为一个batch。可以使用图集或纹理集等技术将多个材料和纹理组合成一个batch，从而减少DrawCall数量。
4. 避免过度半透明的材料
半透明材料会增加游戏中的DrawCall数量。尤其当一个半透明物体放在另一个半透明物体上时，开销会非常昂贵。因此，在游戏中应该尽量减少半透明材料的使用。
5. 使用Culling技术
Culling是一种用于从屏幕外剔除不可见对象的技术。使用Culling技术，只有在屏幕上可见的物体才会被渲染，从而减少DrawCall的数量。
四、Unity中DrawCall的优化手段
除了上述几种方法，Unity中还提供了许多其他的DrawCall优化方法。
1. 合并Mesh
在Unity中，可以使用MeshCombiner组件将多个网格对象合并成一个大网格对象。该方法可以减少DrawCall的数量，同时还可以减少GPU带宽的使用。在使用该方法时，我们需要注意保持原始物体的转换和状态不变，以确保游戏的行为和显示效果不受影响。
2. Batching
Unity的批处理功能可以将多个网格或物体合并为一个大的物体，从而减少DrawCall的数量。在Unity中，开发者可以通过将多个游戏物体放置在一个空物体的层次结构中，将它们合并成一个Batch。Batching是一种非常高效的方法，可以大大减少DrawCall的数量。
3. 静态Batching
静态Batching是一种只能用于被标记为“静态”的游戏对象的批量渲染方法。静态对象的网格和材质应该是不可更改的。在使用该方法时，Unity将会使用一个单独的DrawCall来处理所有静态物体，从而减少DrawCall的数量。这种方法对游戏中静态元素的渲染效果特别好。
4. 动态Batching
与静态批处理不同，动态批处理可以用于所有类型的游戏对象。动态批处理通过将这些物体分组而不需要更改它们的网格或材质来优化游戏中的DrawCall。此外，动态批处理还可以快速绘制多个对象。
5. GPU Instance
GPU Instance是一种可以通过使用GPU能力来实现对大量重复几何对象的快速渲染的技术。GPU Instance可以提高渲染速度，减少DrawCall数量。在使用GPU Instance时，只需将一个大网格复制多次，然后将其发送到GPU进行渲染。
总结
通过使用上述的优化方案，我们可以显著减少游戏中的DrawCall数量，从而提高游戏性能。其中，网格合并、LOD模型、材质和纹理合并、Culling技术等，是常用的DrawCall优化手段。通过使用这些方法，我们可以充分发挥现代计算机系统的性能，从而为玩家带来更好的游戏体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f241c48824673ea4b358767e52db60/" rel="bookmark">
			python pyqt5 全选 和反选 demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import sys from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QGroupBox, QCheckBox, QPushButton class CheckBox(QWidget): def __init__(self): super().__init__() self.setGeometry(300, 300, 300, 200) self.vbox = QVBoxLayout() self.groupbox = QGroupBox("开盒") self.layout = QVBoxLayout() self.groupbox.setLayout(self.layout) self.vbox.addWidget(self.groupbox) self.btn = QPushButton("全选") self.btn_1 = QPushButton("反选") self.btn.clicked.connect(self.quan_xuan) self.btn_1.clicked.connect(self.fan_xuan) self.vbox.addWidget(self.btn) self.vbox.addWidget(self.btn_1) self.setLayout(self.vbox) self.setGeometry(300, 300, 300, 200) for i in range(1, 21): self.checkbox = QCheckBox(f"{i}") self.groupbox.layout().addWidget(self.checkbox) def quan_xuan(self): for checkbox in self.findChildren(QCheckBox): checkbox.setChecked(True) def fan_xuan(self): for checkbox in self.findChildren(QCheckBox): checkbox.setChecked(not checkbox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1f241c48824673ea4b358767e52db60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7afe1ed715065e82a96204c7d2bf25b/" rel="bookmark">
			使用 Github Action 将 github 仓库同步到 gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近将 CI/CD 流程改造了一波，使用 ArgoCD 做 gitops，这样所有的集群 Yaml 文件就都存放在了 github 上的一次仓库里。
但是小服务器放在家里，从 github 上拉代码时总是时不时有网络问题，导致集群资源无法及时更新。
Gitee 提供了一个仓库镜像的功能，所以我目前采用的方式就是：
CI 构建镜像 -&gt; 推送最新配置代码到 Github 仓库 -&gt; Gitee 仓库同步 Github 仓库 -&gt; 集群 ArgoCD 拉取 Gitee 仓库配置。
但是到 3 月底这个功能就要关闭了，得寻找个替代方案了。
要么就是在 CI 过程中，既推送到 Github 仓库，又推送到 Gitee 仓库，但是这样感觉好麻烦，在搜索的过程中，看到了一个 Github Action：sync-gitee-mirror，专门用来将 Github 的仓库，推送到 Gitee 中。
这样就可以在 Github 的配置仓库中，增加一个 workflow，每当配置文件更新时，就触发此 action，主动将代码同步到 Gitee 仓库中。
使用 以我的集群配置仓库 gitops-configs 为例，在此仓库根目录下新建文件 .github/workflows/micrror-to-gitee.yaml，并填入如下内容：
name: 镜像仓库到 Gitee on: push: branches: - main env: # 仓库名称 REPO_NAME: ${{ github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7afe1ed715065e82a96204c7d2bf25b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa34d77e5075fd33766e06f58eeaaba4/" rel="bookmark">
			Visual Studio开发Qt5.12.3，使用QChartView widget时报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Studio开发Qt5.12.3，使用QChartView widget时报错问题
使用场景：在Visual studio2017上开发Qt5.12.3项目，在ui界面上将一个QWidget提升为QChartView作为图标展示区域；而在编译时出现如下的错误：
在uic生成的ui_xxx.h文件中出现如下错误：”未定义标识符 ‘QChartView’“
解决方式：
在xxx.ui对应的头文件包含”ui_xxx.h“的前方添加如下代码：
#include &lt;qchart.h&gt; QT_CHARTS_USE_NAMESPACE 如下图所示：
问题得到解决。
注：之前的Qt+vs版本可能不会出现类似的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfaf6f7449b9c5a420aab31ad4696740/" rel="bookmark">
			python 画图 解决字体无法显示的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先需要用下面的代码查看本地有什么字体库
一般：有songti heiti 这些就是中文的字体
import matplotlib.font_manager as fm def list_system_fonts(): font_list = fm.findSystemFonts(fontpaths=None, fontext='ttf') font_names = sorted(set([fm.FontProperties(fname=fname).get_name() for fname in font_list])) return font_names if __name__ == "__main__": fonts = list_system_fonts() for font_name in fonts: print(font_name) 最后再往画图的程序中加入以下代码即可 后面就是你要使用的字体。
plt.rcParams['font.sans-serif'] = ['songti SC'] # 显示汉字 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccff394ad1fd3c54a553da9ea68e064a/" rel="bookmark">
			MybatisPlus基本使用（MP快速上手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概述
MP快速上手（基本操作）
SpringBoot中MyBatisPlus环境搭建
增删改查
分页
条件查询（聚合，模糊，匹配范围）
条件：范围匹配 （大于小于等于...）
优化查询条件书写（）
条件：查询投影
条件：模糊查询（非全文检索）
条件：聚合函数和分组
条件：排序操作 条件判断（条件为null时情况处理）
字段映射和表名映射
id生成策略
​编辑
多数据操作
概述 MyBatisplus（简称MP）是基于MyBatis框架基础上开发的增强型工具。
作用：简化开发，提高效率。 MP核心：为简化开发而生。
MP由国人开发，在 Mybatis 的基础上只做增强不做改变，MP中内置了一些常用访问数据库数据的方法，例如CRUD方法等，我们不需要声明就直接可以使用。
MP快速上手（基本操作） 下面就使用Spring-Boot工程作为基本来介绍MP的使用。如下的介绍中，只针对数据层进行使用测试，并不涉及业务层和表现层。
SpringBoot中MyBatisPlus环境搭建 ，在SpringBoot中配置MP环境很简单，只需要导入MP的起步依赖，配置数据源，完善数据表和pojo类，设置数据层接口，然后调用即可。
一、创建Boot工程，导入MP依赖
说明：
1.使用正统方式创建（start.spring.io），在选择起步依赖时，并没有MyBatisPlus的选项，没有关系，直接创建，创建好之后再导入依赖即可。
2.使用阿里云(start.aliyun.com)创建boot工程，就会存在MP的起步依赖，直接选择即可。
官方方式创建boot工程起步依赖选择
阿里云方式创建boot工程起步依赖选择
使用官方方式创建后，手动导入MP起步依赖：
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; 二、配置数据源
在此使用druid的数据源，使用druid的起步依赖后可以进行如下方式书写。方式不用一致，配置好数据源信息即可。
spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/test username: root password: root 三、准备测试数据表和实体类
在此使用test数据库下的account表，表字段和数据信息如下：
书写与之对应的实体类
说明： 在此使用lombok配置实体类，lombok为快速开发实体类的工具，只需要加几个注解就可以实现实体类的get、set、toString等方法，想要使用，需要导入依赖坐标即可。
@Data @AllArgsConstructor @NoArgsConstructor public class Account { private int id; private String name; private double balance; } lombok坐标
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccff394ad1fd3c54a553da9ea68e064a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7335087009368f02de965a0fa1d6486/" rel="bookmark">
			使用 mapstruct 和 querydsl 时 compile 问题备忘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：https://stackoverflow.com/questions/74825653/querydsl-5-with-mapstruct-issues-while-generating-resources
问题 在使用 springboot3 + mapstruct + querydsl 的过程中，遇到了一个问题。
如果不配置 maven-compiler-plugin，能正常生成 querydsl 的 Q ，但是不能生成 mapstruct 的实现类。
如果配置了，querydsl 的 Q 类又无法正常生成了。
解决方案 移除 pom 文件中的 maven-compiler-plugin，然后使用如下依赖即可（其中 mapstruct-processor 是我之前没有引入的） ：
&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;classifier&gt;jakarta&lt;/classifier&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-jpa&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;classifier&gt;jakarta&lt;/classifier&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;1.5.3.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;1.5.3.Final&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b89d1e5af00486da27c49b8141d227/" rel="bookmark">
			chatdoc读文献
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注册：https://chatdoc.com/chatdoc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/854ac89b6cee8072926bec7c298422af/" rel="bookmark">
			【Spring】八种常见Bean加载方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚩本文已收录至专栏：Spring家族学习之旅
一.引入 (1) 概述 ​ 关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是由spring维护对象的生命周期，所以bean的加载可以从大的方面划分成2种形式：
已知类通过（类名.class）交给spring管理已知类名通过（类名字符串）并交给spring管理。 两种形式内部其实都一样，都是通过spring的BeanDefinition对象初始化spring的bean。
bean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是spring管控的bean@Import注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有@Bean相关的定义，会被一同加载spring开放出了若干种可编程控制的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean 本文介绍八种常见的bean加载方式：
xmlxml+注解注解@Import导入使用register方法编程形式注册@Import导入实现ImportSelector接口的类@Import导入实现ImportBeanDefinitionRegistrar接口的类@Import导入实现BeanDefinitionRegistryPostProcessor接口的类 此外还介绍一些相关涉及知识
@Bean定义FactoryBean接口@ImportResource@Configuration注解的proxyBeanMethods属性 (2) 环境搭建 在开始讲解之前，我们需要先介绍一下测试所用的环境。
创建Maven工程，可以选择导入如下Spring坐标用于测试 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 演示加载第三方bean--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; 创建一些用于后续示例演示的bean
二.八种加载方式 (1) XML方式 ​ 最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是提供类名，然后spring就可以管理了。所以第一种方式就是给出bean的类名，至于内部就是通过反射机制加载成class。
创建Spring的xml配置文件，通过其中的 &lt;bean/&gt;标签加载bean，我们可以在其中声明加载自己创建的bean,也可以加载第三方开发的bean。 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--xml方式声明 自己 开发的bean--&gt; &lt;bean class="com.guanzhi.bean.Cat"/&gt; &lt;bean class="com.guanzhi.bean.Dog"/&gt; &lt;!--xml方式声明 第三方 开发的bean--&gt; &lt;bean class="com.alibaba.druid.pool.DruidDataSource"/&gt; &lt;/beans&gt; 我们可以测试一下是否成功加载了这些bean public class App { public static void main(String[] args) { // 加载配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/854ac89b6cee8072926bec7c298422af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af844ae8560c841833953eaa2d7cc690/" rel="bookmark">
			Oracle用户密码过期，修改永不过期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改密码有效过期时间，可以通过以下四步设置，如果再第一步发现本身的密码过期时间为无限期的，那就请各位小伙伴绕过，如果发现不是无期限的，那么必须设置第四步，才会生效。
目录
第一步：查询密码有效时长
第二步：查看当前用户密码到期日期 第三步：设置密码永不过期
第四步：重置密码
第一步：查询密码有效时长 以管理员用户(sys)登录plsql，查询密码过期时间，sql语句如下，
SELECT * FROM dba_profiles s WHERE s.profile='DEFAULT'AND resource_name='PASSWORD_LIFE_TIME';
查询结果如下图，
可以看到密码过期时间是180天
第二步：查看当前用户密码到期日期 以管理员用户(sys)登录plsql，查询未被锁的用户信息，sql语句如下，
select username,account_status,expiry_date,profile from dba_users where account_status='OPEN'; 查询结果如下图，
可以看到密码过期时间为2023年5月1号
第三步：设置密码永不过期 以管理员用户(sys)登录plsql，为用户设置密码过期时间，sql语句如下，
alter profile default limit password_life_time '90';--90天期限
alter profile default limit password_life_time unlimited; --永久期限
修改结果如下图，
可以看到 有效时长，为无限制
第四步：重置密码 ！！！！！！！！！！！！！非常重要，用户密码必须重置，重置后才生效！！！！！！！！
过期的账户，重置密码后期不会再过期，重置为以前的密码，不用换新密码。重置sql语句
alter user 用户名 identified by 原来的密码;
至此，我们Oracle密码才重置结束，当前用户密码才会永久。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d43bfee40ec5a10bdfbf339fff1642fd/" rel="bookmark">
			02 Mybatis-Plus collection标签嵌套查询(select)的写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述： 前置：
在association标签中 javaType属性指向的是实体类的属性。
在collection标签中 javaType属性指向的是集合的类型 ofType指向的是集合的泛型类型 。
mybatis-plus selectPage与一对多查询时存在问题。
1.1实体类
@Data @NoArgsConstructor @AllArgsConstructor @TableName("sys_class") public class ClassInfo { @TableId(type = IdType.AUTO) private Integer id; private String grade; private String className; private String classNickname; private String ratedNum; @TableField(fill = FieldFill.INSERT) @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss",timezone = "GMT+8") private Date createTime; //创建时间 @TableField(fill = FieldFill.UPDATE) @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss",timezone = "GMT+8") private Date updateTime; //更新时间 @TableField(exist = false) // 属性字段在表中不存在 private List&lt;Student&gt; studentList; //该班级的学生 @TableField(exist = false) // 属性字段在表中不存在 private List&lt;Teacher&gt; teacherList; //管理该班级的教师 } @Data @NoArgsConstructor @AllArgsConstructor @TableName("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d43bfee40ec5a10bdfbf339fff1642fd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/68/">«</a>
	<span class="pagination__item pagination__item--current">69/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/70/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>