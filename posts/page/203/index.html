<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f337ce4fa02f502b05830373dd8e5f/" rel="bookmark">
			windows安装tortoiseGIT图文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇我们讲了在windows上安装git，安装完成后，需要使用命令框模式，对于入门级选手，操作起来比较费劲，所以这节讲一个操作git很好用的工具tortoiseGIT。
一、官网下载
到tortoise官网下载我们需要的版本，
如图：
我选择的64位，下载版本是：TortoiseGit-2.5.0.0-64bit.msi
二、安装
1）双击TortoiseGit-2.5.0.0-64bit.msi文件，启动安装界面，next，进入下一步
2）继续next，下一步
3）基于Putty，对TortoiseGit做了优化/Git默认的SSH客户端,next,下一步
4）选择安装目录，安装的程序组件保持默认即可，next，下一步
5）点击 Install按钮安装
6）安装
安装完成，点击Finish按钮，
勾选的Run first start wizard 是第一次运行启动向导
如果勾选，Finish后会有弹窗出来设置Git.exe 文件的路径，Git账号、密码
7）进入欢迎页面，直接下一步
8）设置git.exe路径，下一步
9）配置用户信息，下一步
10）权限保存，完成
11）桌面，鼠标右键，可以看到已经有小乌龟了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cf0110a7f9453d985348d0487b38666/" rel="bookmark">
			微信小程序  功能函数  将对象的键添加到数组 （函数深入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 将对象的键添加到数组 var arr = Object.keys(site); //英文 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys 中文 https://developer.mozilla.org/zh-CN/ https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys 转载于:https://www.cnblogs.com/dianzan/p/7784050.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04f179e2e5e628753a9dbbb02c5b33b1/" rel="bookmark">
			HTML5新增标签有哪些你知道吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html5新增标签 &lt;article&gt;标签定义外部的内容。
比如来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容。
HTML5:&lt;article&gt;&lt;/article&gt;
HTML4:&lt;div&gt;&lt;/div&gt;&lt;aside&gt;标签定义 article 以外的内容。
aside 的内容应该与 article 的内容相关。
HTML5:&lt;aside&gt;Aside 的内容是独立的内容，但应与文档内容相关。&lt;/aside&gt;
HTML4:&lt;div&gt;Aside 的内容是独立的内容，但应与文档内容相关。&lt;/div&gt;&lt;audio&gt; 标签定义声音，比如音乐或其他音频流。
HTML5:&lt;audio src="someaudio.wav"&gt;您的浏览器不支持 audio 标签。&lt;/audio&gt;
HTML4:&lt;object type="application/ogg" data="someaudio.wav"&gt;&lt;param name="src" value="someaudio.wav"&gt;&lt;/object&gt;&lt;canvas&gt; 标签定义图形，比如图表和其他图像。
这个 HTML 元素是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。
HTML5:&lt;canvas id="myCanvas" width="200" height="200"&gt;&lt;/canvas&gt;
HTML4:&lt;object data="inc/hdr.svg" type="image/svg+xml" width="200" height="200"&gt;&lt;/object&gt;&lt;command&gt; 标签定义命令按钮，比如单选按钮、复选框或按钮。
HTML5: &lt;command onclick=cut()" label="cut"&gt;
HTML4: none&lt;datalist&gt; 标签定义可选数据的列表。
与 input 元素配合使用，就可以制作出输入值的下拉列表。
HTML5: &lt;datalist&gt;&lt;/datalist&gt;
HTML4: see combobox.&lt;details&gt; 标签定义元素的细节，用户可进行查看，或通过点击进行隐藏。
与 &lt;legend&gt; 一起使用，来制作 detail 的标题。该标题对用户是可见的，当在其上点击时可打开或关闭 detail。
HTML5: &lt;details&gt;&lt;/details&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04f179e2e5e628753a9dbbb02c5b33b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0e49aa83ab70aeced44b35cb40ae012/" rel="bookmark">
			OpenWrt：通过tftp下载程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建tftp服务器 TFTP（Trivial File Transfer Protocol，简单文件传输协议），是一个基于UDP协议实现的用于在客户机和服务器之间进行简单文件传输的协议，适合于开销不大、不复杂的应用场合。tftp协议专门为小文件传输而设计，只能从服务器上获取文件，或者向服务器写入文件，不能列出目录，也不能进行认证。
在嵌入式Linux开发中，TFTP协议在很多场合都被用到，甚至是必不可少的，特别是在内核调试阶段，在U-Boot下通过tftp协议从服务器上加载内核并运行，既方便又快捷。
一般的发行版默认都没有安装tftp服务以及tftp服务器。tftp服务依赖于网络守护进程服务程序，可选择安装inetd或者升级版的xinetd，然后安装tftp和tftp-server，接着修改或者创建/etc/xinetd.d/tftp配置文件，最后重启xinetd，启动tftp服务。
安装xinetd：
$ sudo apt-get install xinetd 安装tftp和tftpd：
$ sudo apt-get install tftp tftpd 或者安装tftp的增强版本tftp-hpa：
$ sudo apt-get install tftp-hpa tftpd-hpa 建立/etc/default/tftpd-hpa文件，写入如下内容：
# /etc/default/tftpd-hpa TFTP_USERNAME="tftp" TFTP_DIRECTORY="/opt/tftpboot" TFTP_ADDRESS=":69" TFTP_OPTIONS="--secure" 其中TFTP_DIRECTORY设置的/var/tftpboot目录是tftp服务器的目录，设置其访问权限为777：
$ sudo mkdir -pv /opt/tftpboot/ $ sudo chmod 777 /opt/tftpboot/ 启动或者重启tftpd-hpa服务：
$ sudo service tftpd-hpa start // 或者restart 在tftpboot目录下创建一个test.txt文件，启动另外一个终端，输入：
$ tftp 127.0.0.1 tftp&gt; get test.txt # 获取test.txt文件 tftp&gt; q # 退出tftp 在终端输入ls命令，可以看到当前目录下获取到的test.txt文件。
开发板烧录程序 启动板子，系统打印如下日志：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0e49aa83ab70aeced44b35cb40ae012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c76d92b876b724ee0c973b626807b68/" rel="bookmark">
			解决多浏览器的兼容问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决多浏览器的不兼容问题 一、浏览器不兼容会怎样？
浏览器不兼容主要表现为某些特定功能无法使用、网站错位、网站某些内容不显示、网站特效在浏览器中无效等，无论是哪种不兼容，都会给浏览者造成非常不友好的体验效果。
二、什么原因导致浏览器不兼容？
技术因素。非IE内核的浏览器都是遵守W3C标准的, 如网页代码遵循W3C标准，那么所有浏览器的不兼容性会很低。这主要在于前端开发者，在样式编写上应注意兼容问题。
浏览器因素。因为浏览器的内核是不一样的，目前国内主浏览器依旧以IE为主，所以某些标签、样式本身在浏览器中就存在不兼容，如“margin不一致”、“div居中问题” 三、处理要点
DOCTYPE 影响 CSS 处理FF: 设置 padding 后， div 会增加 height 和 width， 但 IE 不会， 故需要用 !important 多设一个 height 和 widthFF: 支持 !important， IE 则忽略， 可用 !important 为 FF 特别设置样式div 的垂直居中问题: vertical-align:middle; 将行距增加到和整个DIV一样高 line-height:200px; 然后插入文字，就垂直居中了。缺点是要控制内容不要换行在mozilla firefox和IE中的BOX模型解释不一致导致相差2px解决方法div{margin:30px!important;margin:28px;} 注意这两个margin的顺序一定不能写反，!important这个属性IE不能识别，但别的浏览器可以识别。所以在IE下其实解释成这样：div{maring:30px;margin:28px}重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important 四、浏览器差异
ul和ol列表缩进问题消除ul、ol等列表的缩进时，样式应写成：list-style:none;margin:0px;padding:0px;其中margin属性对IE有效，padding属性对FireFox有效。[注经验证，在IE中，设置margin:0px可以去除列表的上下左右缩进、空白以及列表编号或圆点，设置padding对样式没有影响；在 Firefox 中，设置margin:0px仅仅可以去除上下的空白，设置padding:0px后仅仅可以去掉左右缩进，还必须设置list- style:none才 能去除列表编号或圆点。也就是说，在IE中仅仅设置margin:0px即可达到最终效果，而在Firefox中必须同时设置margin:0px、 padding:0px以及list-style:none三项才能达到最终效果。]CSS透明问题IE：filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60)。FF：opacity:0.6。[注 最好两个都写，并将opacity属性放在下面。]CSS圆角问题IE：ie7以下版本不支持圆角。FF：-moz-border-radius:4px，或者-moz-border-radius-topleft:4px``;-moz- border- radius-topright:4px``;-moz-border-radius-bottomleft:4px``;-moz- border- radius- bottomright:4px;。[注 圆角问题是CSS中的经典问题，建议使用JQuery框架集来设置圆角，让这些复杂的问题留给别人去想吧。不过jQuery的圆角只看到支持整个区域的圆角，没有支持边框的圆角，不过这个边框的圆角可以通过一些简单的手段来实现，下次有机会介绍下。]cursor:hand VS cursor:pointer问题说明：firefox不支持hand，但ie支持pointer ，两者都是手形指示。解决方法：统一使用pointer。字体大小定义不同对字体大小small的定义不同，Firefox中为13px，而IE中为16px，差别挺大。解决方法：使用指定的字体大小如14px。并列排列的多个元素（图片或者链接）的div和div之间，代码中的空格和回车在firefox中都会被忽略，而IE中却默认显示为空格（约3px）。CSS双线凹凸边框IE：border:2px outset;。FF：-moz-border-top-colors: #d4d0c8 white;-moz-border-left-colors: #d4d0c8 white;-moz-border-right-colors:#404040 #808080;-moz-border-bottom-colors:#404040 #808080;浏览器bug1、IE的双边距bug设置为float的div在ie下设置的margin会加倍。这是一个ie6都存在的bug。 五、解决方案
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c76d92b876b724ee0c973b626807b68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103c652c732fa704b30f3a6bed470d29/" rel="bookmark">
			Image控件的Stretch属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stretch 状态类似于许多电视机上的图片大小设置。
None 显示原始大小的内容的原始分辨率。Uniform 在保持纵横比和图像内容的同时填充尽可能多的空间。这可能会导致在视频的边缘出现水平和垂直黑色条。这类似于宽屏模式。UniformToFill 在保持纵横比的同时填充整个空间。这可能会导致某些图像被裁剪。这类似于全屏模式。Fill 填充整个空间，但不保持纵横比。 图像不会被裁剪，但可能会发生拉伸。这类似于拉伸模式。 转载于:https://www.cnblogs.com/Markshome/p/7744851.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74dda3e5b8f115cce5ef72a04286963f/" rel="bookmark">
			Unity截屏分享朋友圈(微信)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity2017.1 ShareSDK GalleryScreenshot.unitypackage
一、SharSDK注册产品 后台&gt;概括
二、微信开放平台上注册产品
2.1Unity: PlayerSettings&gt;OtherSetting: com.wfj.snailshell
Android平台 应用下载地址：未填写
应用签名：xxxxb98a448d45e37cc7b3fa5c0fxxxx
包名：com.wfj.snailshell
2.2应用签名的获取
2.2.1修改apk后缀名为zip,解压得到其中的META-INF文件夹;
2.2.2把META-INF文件夹放到C盘根目录下;
2.2.3在dos面板中, 敲入命令: keytool -printcert -file C:\META-INF\CERT.RSA 命令,即可获取签名信息
2.2.4去冒号
2.3检查签名
https://open.weixin.qq.com/cgi-bin/readtemplate?t=resource/app_download_android_tmpl&amp;lang=zh_CN 签名生成工具
安装apk后输入com.wfj.snailshell
三、Unity配置
3.1修改AndroidManifest
http://bbs.mob.com/thread-23519-1-1.html
3.2替换DemoCallback.jar
Unity：Assets\Plugins\Android\ShareSDK\libs
代码：
using cn.sharesdk.unity3d; using System.Collections; using System.IO; using UnityEngine; using UnityEngine.UI; public class SharePhoto : MonoBehaviour { public Image ImagePreview; public ShareSDK Ssdk; string photoNamePrefix = "jimmy"; string albumName = "SnailShellShots"; string filePath; void Start() { ScreenshotManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74dda3e5b8f115cce5ef72a04286963f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a888df3d0f95601a9ef0b6d0eb585455/" rel="bookmark">
			toDF需要导入的包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //导入隐饰操作，否则RDD无法调用toDF方法 import sparkSession.implicits._ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e315106f0536430356b34141439c9c/" rel="bookmark">
			二层交换机和三层交换机和路由器的原理分析及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 二层交换机:
二层交换技术是发展比较成熟，二层交换机属数据链路层设备，可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。
具体如下：
（1）当交换机从某个端口收到一个数据包，它先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上；
（2）再去读取包头中的目的MAC地址，并在地址表中查找相应的端口；
（3）如表中有与这目的MAC地址对应的端口，把数据包直接复制到这端口上。
三层交换机: 三层交换技术就是将路由技术与交换技术合二为一的技术。在对第一个数据流进行路由后，它将会产生一个MAC地址与IP地址的映射表，当同样的数据流再次通过时，将根据此表直接从二层通过而不是再次路由，从而消除了路由器进行路由选择而造成网络的延迟，提高了数据包转发的效率。
路由器：传统地，路由器工作于OSI七层协议中的第三层，其主要任务是接收来自一个网络接口的数据包，根据其中所含的目的地址，决定转发到下一个目的地址。因此，路由器首先得在转发路由表中查找它的目的地址，若找到了目的地址，就在数据包的帧格前添加下一个MAC地址，同时IP数据包头的TTL（Time To Live）域也开始减数，并重新计算校验和。当数据包被送到输出端口时，它需要按顺序等待，以便被传送到输出链路上。
路由器在工作时能够按照某种路由通信协议查找设备中的路由表。如果到某一特定节点有一条以上的路径，则基本预先确定的路由准则是选择最优（或最经济）的传输路径。由于各种网络段和其相互连接情况可能会因环境变化而变化，因此路由情况的信息一般也按所使用的路由信息协议的规定而定时更新。
主要区别：二层交换机工作在数据链路层，三层交换机工作在网络层，路由器工作在网络层。
具体区别如下：
二层交换机和三层交换机的区别：
三层交换机使用了三层交换技术
简单地说，三层交换技术就是：二层交换技术＋三层转发技术。它解决了局域网中网段划分之后，网段中子网必须依赖路由器进行管理的局面，解决了传统路由器低速、复杂所造成的网络瓶颈问题。
什么是三层交换
三层交换（也称多层交换技术，或IP交换技术）是相对于传统交换概念而提出的。众所周知，传统的交换技术是在OSI网络标准模型中的第二层——数据链路层进行*作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发。简单地说，三层交换技术就是：二层交换技术＋三层转发技术。
三层交换技术的出现，解决了局域网中网段划分之后，网段中子网必须依赖路由器进行管理的局面，解决了传统路由器低速、复杂所造成的网络瓶颈问题。
其原理是：假设两个使用IP协议的站点A、B通过第三层交换机进行通信，发送站点A在开始发送时，把自己的IP地址与B站的IP地址比较，判断B站是否与自己在同一子网内。若目的站B与发送站A在同一子网内，则进行二层的转发。若两个站点不在同一子网内，如发送站A要与目的站B通信，发送站A要向“缺省网关”发出ARP(地址解析)封包，而“缺省网关”的IP地址其实是三层交换机的三层交换模块。当发送站A对“缺省网关”的IP地址广播出一个ARP请求时，如果三层交换模块在以前的通信过程中已经知道B站的MAC地址，则向发送站A回复B的MAC地址。否则三层交换模块根据路由信息向B站广播一个ARP请求，B站得到此ARP请求后向三层交换模块回复其MAC地址，三层交换模块保存此地址并回复给发送站A,同时将B站的MAC地址发送到二层交换引擎的MAC地址表中。从这以后，当A向B发送的数据包便全部交给二层交换处理，信息得以高速交换。由于仅仅在路由过程中才需要三层处理，绝大部分数据都通过二层交换转发，因此三层交换机的速度很快，接近二层交换机的速度，同时比相同路由器的价格低很多。
第二层交换机和路由器的区别：
传统交换机从网桥发展而来，属于OSI第二层即数据链路层设备。它根据MAC地址寻址，通过站表选择路由，站表的建立和维护由交换机自动进行。路由器属于OSI第三层即网络层设备，它根据IP地址进行寻址，通过路由表路由协议产生。交换机最大的好处是快速，由于交换机只须识别帧中MAC地址，直接根据MAC地址产生选择转发端口算法简单，便于ASIC实现，因此转发速度极高。但交换机的工作机制也带来一些问题。
1.回路：根据交换机地址学习和站表建立算法，交换机之间不允许存在回路。一旦存在回路，必须启动生成树算法，阻塞掉产生回路的端口。而路由器的路由协议没有这个问题，路由器之间可以有多条通路来平衡负载，提高可靠性。
2.负载集中：交换机之间只能有一条通路，使得信息集中在一条通信链路上，不能进行动态分配，以平衡负载。而路由器的路由协议算法可以避免这一点，OSPF路由协议算法不但能产生多条路由，而且能为不同的网络应用选择各自不同的最佳路由。
3.广播控制：交换机只能缩小冲突域，而不能缩小广播域。整个交换式网络就是一个大的广播域，广播报文散到整个交换式网络。而路由器可以隔离广播域，广播报文不能通过路由器继续进行广播。
4.子网划分：交换机只能识别MAC地址。MAC地址是物理地址，而且采用平坦的地址结构，因此不能根据MAC地址来划分子网。而路由器识别IP地址，IP地址由网络管理员分配，是逻辑地址且IP地址具有层次结构，被划分成网络号和主机号，可以非常方便地用于划分子网，路由器的主要功能就是用于连接不同的网络。
5.保密问题：虽说交换机也可以根据帧的源MAC地址、目的MAC地址和其他帧中内容对帧实施过滤，但路由器根据报文的源IP地址、目的IP地址、TCP端口地址等内容对报文实施过滤，更加直观方便。
6.介质相关：交换机作为桥接设备也能完成不同链路层和物理层之间的转换，但这种转换过程比较复杂，不适合ASIC实现，势必降低交换机的转发速度。因此目前交换机主要完成相同或相似物理介质和链路协议的网络互连，而不会用来在物理介质和链路层协议相差甚元的网络之间进行互连。而路由器则不同，它主要用于不同网络之间互连，因此能连接不同物理介质、链路层协议和网络层协议的网络。路由器在功能上虽然占据了优势，但价格昂贵，报文转发速度低。近几年，交换机为提高性能做了许多改进，其中最突出的改进是虚拟网络和三层交换。
划分子网可以缩小广播域，减少广播风暴对网络的影响。路由器每一接口连接一个子网，广播报文不能经过路由器广播出去，连接在路由器不同接口的子网属于不同子网，子网范围由路由器物理划分。对交换机而言，每一个端口对应一个网段，由于子网由若干网段构成，通过对交换机端口的组合，可以逻辑划分子网。广播报文只能在子网内广播，不能扩散到别的子网内，通过合理划分逻辑子网，达到控制广播的目的。由于逻辑子网由交换机端口任意组合，没有物理上的相关性，因此称为虚拟子网，或叫虚拟网。虚拟网技术不用路由器就解决了广播报文的隔离问题，且虚拟网内网段与其物理位置无关，即相邻网段可以属于不同虚拟网，而相隔甚远的两个网段可能属于不同虚拟网，而相隔甚远的两个网段可能属于同一个虚拟网。不同虚拟网内的终端之间不能相互通信，增强了对网络内数据的访问控制。 第三层交换机和路由器的区别：
在第三层交换技术出现之前，几乎没有必要将路由功能器件和路由器区别开来，他们完全是相同的：提供路由功能正在路由器的工作，然而，现在第三层交换机完全能够执行传统路由器的大多数功能。作为网络互连的设备，第三层交换机具有以下特征：
1.转发基于第三层地址的业务流；
2.完全交换功能；
3.可以完成特殊服务，如报文过滤或认证；
4.执行或不执行路由处理。
第三层交换机与传统路由器相比有如下优点：
1.子网间传输带宽可任意分配：传统路由器每个接口连接一个子网，子网通过路由器进行传输的速率被接口的带宽所限制。而三层交换机则不同，它可以把多个端口定义成一个虚拟网，把多个端口组成的虚拟网作为虚拟网接口，该虚拟网内信息可通过组成虚拟网的端口送给三层交换机，由于端口数可任意指定，子网间传输带宽没有限制。
2.合理配置信息资源：由于访问子网内资源速率和访问全局网中资源速率没有区别，子网设置单独服务器的意义不大，通过在全局网中设置服务器群不仅节省费用，更可以合理配置信息资源。
3.降低成本：通常的网络设计用交换机构成子网，用路由器进行子网间互连。目前采用三层交换机进行网络设计，既可以进行任意虚拟子网划分，又可以通过交换机三层路由功能完成子网间通信，为此节省了价格昂贵的路由器。
4.交换机之间连接灵活：作为交换机，它们之间不允许存在回路，作为路由器，又可有多条通路来提高可靠性、平衡负载。三层交换机用生成树算法阻塞造成回路的端口，但进行路由选择时，依然把阻塞掉的通路作为可选路径参与路由选择。
交换机和路由器是性能和功能的矛盾体，交换机交换速度快，但控制功能弱，路由器控制性能强，但报文转发速度慢。解决这个矛盾的最新技术是三层交换，既有交换机线速转发报文能力，又有路由器良好的控制功能。
三层交换机与路由器的主要区别 之所以有人搞不清三层交换机和路由器之间的区别，最根本就是三层交换机也具有“路由”功能，与传统路由器的路由功能总体上是一致的。虽然如此，三层交换机与路由器还是存在着相当大的本质区别的，下面分别予以介绍。
1. 主要功能不同 虽然三层交换机与路由器都具有路由功能，但我们不能因此而把它们等同起来，正如现在许多网络设备同时具备多种传统网络设备功能一样，就如现在有许多宽带路由器不仅具有路由功能，还提供了交换机端口、硬件防火墙功能，但不能把它与交换机或者防火墙等同起来一样。因为这些路由器的主要功能还是路由功能，其它功能只不过是其附加功能，其目的是使设备适用面更广、使其更加实用。这里的三层交换机也一样，它仍是交换机产品，只不过它是具备了一些基本的路由功能的交换机，它的主要功能仍是数据交换。也就是说它同时具备了数据交换和路由 由发两种功能，但其主要功能还是数据交换；而路由器仅具有路由转发这一种主要功能。
2. 主要适用的环境不一样三层交换机的路由功能通常比较简单，因为它所面对的主要是简单的局域网连接。正因如此，三层交换机的路由功能通常比较简单，路由路径远没有路由器那么复杂。它用在局域网中的主要用途还是提供快速数据交换功能，满足局域网数据交换频繁的应用特点。 而路由器则不同，它的设计初哀就是为了满足不同类型的网络连接，虽然也适用于局域网之间的连接，但它的路由功能更多的体现在不同类型网络之间的互联上，如局域网与广域网之间的连接、不同协议的网络之间的连接等，所以路由器主要是用于不同类型的网络之间。它最主要的功能就是路由转发，解决好各种复杂路由路径网络的连接就是它的最终目的，所以路由器的路由功能通常非常强大，不仅适用于同种协议的局域网间，更适用于不同协议的局域网与广域网间。它的优势在于选择最佳路由、负荷分担、链路备份及和其他网络进行路由信息的交换等等路由器所具有功能。
3. 性能体现不一样 从技术上讲，路由器和三层交换机在数据包交换操作上存在着明显区别。路由器一般由基于微处理器的软件路由引擎执行数据包交换，而三层交换机通过硬件执行数据包交换。三层交换机在对第一个数据流进行路由后，它将会产生一个MAC地址与IP地址的映射表，当同样的数据流再次通过时，将根据此表直接从二层通过而不是再次路由，从而消除了路由器进行路由选择而造成网络的延迟，提高了数据包转发的效率。同时，三层交换机的路由查找是针对数据流的，它利用缓存技术，很容易利用ASIC技术来实现，因此，可以大大节约成本，并实现快速转发。而路由器的转发采用最长匹配的方式，实现复杂，通常使用软件来实现，转发效率较低。 正因如此，从整体性能上比较的话，三层交换机的性能要远优于路由器，非常适用于数据交换频繁的局域网中；而路由器虽然路由功能非常强大，但它的数据包转发效率远低于三层交换机，更适合于数据交换不是很频繁的不同类型网络的互联，如局域网与互联网的互联。如果把路由器，特别是高档路由器用于局域网中，则在相当大程度上是一种浪费（就其强大的路由功能而言），而且还不能很好地满足局域网通信性能需求，影响子网间的正常通信。
综上所述，三层交换机与路由器之间还是存在着非常大的本质区别的。无论从哪方面来说，在局域网中进行多子网连接，最好还选用三层交换机，特别是在不同子网数据交换频繁的环境中。一方面可以确保子网间的通信性能需求，另一方面省去了另外购买交换机的投资。当然，如果子网间的通信不是很频繁，采用路由器也无可厚非，也可达到子网安全隔离相互通信的目的。具体要根据实际需求来定
三层交换机的最重要的目的是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的，能够做到一次路由，多次转发。对于数据包转发等规律性的过程由硬件高速实现，而像路由信息更新、路由表维护、路由计算、路由确定等功能，由软件实现。
出于安全和管理方便的考虑，主要是为了减小广播风暴的危害，必须把大型局域网按功能或地域等因素化成一个个小的局域网，这就使得VLAN技术在网络中得到大量应用，而不同VLAN之间的通信都要经过路由器来完成转发，随着网间互访的不断增加。单纯使用路由器来实现网间访问，不但由于端口数量有限，而且路由速度较慢。从而限制了网络的规模和访问速度。基于这种情况三层交换机便应用而生。三层交换机是为IP设计的，接口类型简单；拥有很强二层包处理能力，非常适合用于大型局域网内的数据路由与交换，它既可以工作在协议第三层替代或是部分完成传统路由器的功能，同时又具有几乎第二层交换的速度，且价格相对便宜。
三层交换机出现最重要的目的是加快大型局域网内部的数据交换，所具有的路由功能也多是围绕这个目的而展开的，所以它的路由功能没有同一档次的专业路由器强。毕竟在安全、协议支持等方面还有许多欠缺，并不能完全取代路由器的工作。
在实际中的典型用法是：处于同一个局域网中的各个子网的互联以及局域网中VLAN间的路由，用三层交换机来代替路由。而只有局域网与公网互联之间要实现跨地域的网络访问，才通过专业路由器。
从表面上看，第三层交换机是第二层交换器与路由器的合二为一，然而这种结合并非简单的物理结合，而是各取所长的逻辑结合。其重要表现是，当某一信息源的第一个数据流进行第三层交换后，其中的路由系统会产生一个MAC地址与IP地址的映射表，并将该表存储起来，当同一信息源的后续数据流再次进入交换环境时，交换机将根据第一次产生并保存的地址映射表，直接从第二层由源地址传输到目的地址，不再经过第三路由系统处理，从而消除路由选择的网络延迟。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae36c2c297da2128feed7fd18d6ff892/" rel="bookmark">
			Linux中强制结束一个进程的终极方法和其他常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查进程 ps命令查找与进程相关的PID号： ps a 显示现行终端机下的所有程序，包括其他用户的程序。 ps -A 显示所有程序。 ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。 ps -e 此参数的效果和指定"A"参数相同。 ps e 列出程序时，显示每个程序所使用的环境变量。 ps f 用ASCII字符显示树状结构，表达程序间的相互关系。 ps -H 显示树状结构，表示程序间的相互关系。 ps -N 显示所有的程序，除了执行ps指令终端机下的程序之外。 ps s 采用程序信号的格式显示程序状况。 ps S 列出程序时，包括已中断的子程序资料。 ps -t&lt;终端机编号&gt; 指定终端机编号，并列出属于该终端机的程序的状况。 ps u 以用户为主的格式来显示程序状况。 ps x 显示所有程序，不以终端机来区分。 最常用的方法是ps aux,然后再通过管道使用grep命令过滤查找特定的进程,然后再对特定的进程进行操作。 ps aux | grep program_filter_word,ps -ef |grep tomcat ps -ef|grep java|grep -v grep 显示出所有的java进程，去处掉当前的grep进程。 2.杀进程 使用kill命令结束进程：kill xxx 常用：kill －9 324 Linux下还提供了一个killall命令，可以直接使用进程的名字而不是进程标识号，例如：# killall -9 NAME 3.进入到进程的执行文件所在的路径下，执行文件 ./文件名 附： 这是本人花了两天时间整理得来的，一些最常用的地球人都知道的命令就省去啦！最后提供pdf手册下载 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae36c2c297da2128feed7fd18d6ff892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75f779d620a3d8d50730154b83ab2b3c/" rel="bookmark">
			如何理解和熟练运用js中的call及apply？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作者：杨志
链接：https://www.zhihu.com/question/20289071/answer/14644278
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
LZ要先明白存在call和apply的原因，才能记得牢一点：
在javascript OOP中，我们经常会这样定义： function cat(){
}
cat.prototype={
food:"fish",
say: function(){
alert("I love "+this.food);
}
}
var blackCat = new cat;
blackCat.say(); 但是如果我们有一个对象whiteDog = {food:"bone"},我们不想对它重新定义say方法，那么我们可以通过call或apply用blackCat的say方法：blackCat.say.call(whiteDog);
所以，可以看出call和apply是为了动态改变this而出现的，当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。
用的比较多的，通过document.getElementsByTagName选择的dom 节点是一种类似array的array。它不能应用Array下的push,pop等方法。我们可以通过：
var domNodes = Array.prototype.slice.call(document.getElementsByTagName("*"));
这样domNodes就可以应用Array下的所有方法了。
其他的就不提了，讲多了反而迷惑。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9f42f4fe3ed6c69f75da5f0ace6e425/" rel="bookmark">
			【Photoshop】合并一系列序列帧图片成序列帧大图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在2D游戏中，序列帧图片的大图是很常见很常用的东西，他用于记录游戏主角的所有动作。比如上图，就是lf2中的一张序列帧大图。
其实大部分软件都不支持gif或者直接拉个视频进去这样，序列帧图片来完成游戏主角的动作表现这项技术一直很经典。所以我们需要学会利用Photoshop合并一系列序列帧图片成序列帧大图。
一般用视频软件或者Gif处理软件导出来的帧系列图片是这样的：
你不可能拿这多达100张图片，导入程序。一般在编程时候，图片的合并为一张序列帧大图。
肯定不可能一张张自己慢慢拼，就算你有这个心思，你未必能拼到鳞次栉比，符合游戏批量切割的要求。
无须什么工具，你只要用photoshop cc以上的版本即可完成序列帧大图的拼接。
具体如下操作：
通过“文件”-&gt;“自动”-&gt;"联系表II"打开序列帧大图的批处理。
选择源文件夹，最终的序列帧大图的大小，序列帧中的缩览图排序方式。最好先批量修改缩略图分辨率的大小。具体可以参考《【Photoshop】批量修改图片分辨率》（点击打开链接）。
序列帧大图的大小和缩览图的排序方式应该根据缩览图的数量来定。缩览图也就是序列帧中的每一帧的小图。你要算一下，帧的数量，比如我这里有53个帧图。那就取一个近似的2次幂，也就是64。预计进行8x8的点阵排列这些序列帧图片成序列帧大图。所以缩览图的列数与行数都应该修改8x8。
比如我这里缩览图分辨率已经修改为32x32，因此这里的序列帧大图宽高，都应该修改为32x8=256。
设置好按确定，等待photoshop处理完成即可。最终效果如下图所示。
一张gif：
就被我弄成这样，当然，原本256x216的gif给我弄成每一张都是32x32帧图失真太严重了，现在技术发展了，一帧图弄成256x256也行。32x32一张帧图是以前VC6时代的做法~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd24b6124e7fcffa72639903c7d5429/" rel="bookmark">
			go 设置 GOROOT 和 GOPATH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击在我的博客 xuxusheng.com 中查看，有更好的排版哦~ 发表失败全部丢失，写完了又重写一遍，csdn 都没个自动保存功能，强烈吐槽
go 里面有两个非常重要的环境变量 GOROOT 和 GOPATH，其中 GOROOT 是安装 go 的路径，而 GOPATH 是我们定义的自己的工作空间。
如果在安装的时候是一路 next 完的，那么默认就配置好了 ，无需手动配置。
如果在安装的时候修改了默认的安装路径，那么可能需要自己添加一下 。
首先在环境变量中添加 GOPATH，值为 go 的安装目录： 然后在环境变量 PATH 中添加 go 安装目录下的 bin 文件夹。 接着添加一个环境变量 GOPATH，值为你自己希望的工作目录。 最后重启一下 命令行工具，输入 go env 命令即可查看： Tips:
一定要记得重启下命令行工具，cmd 或者 cmder 啥的，不然修改的环境变量没有生效，我一开始忘记了重启，纳闷半天为啥没生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca264a8d2110259e4eefc263174860f7/" rel="bookmark">
			Linux环境搭建（最全的搭建过程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux环境搭建 打开centOS,点击右下方的网络适配器，如图一所示。打开设置，出现图二所示。
图一 图二 在图二中选择网络适配器，其中有网络连接，常见有桥接模式以及NAT模式， 桥接模式相当于我们的虚拟机和我们的Windows主机并列的另外一台独立的机器， 通常点击桥接模式，确定之后，当图三所示，再次变成蓝色即表示桥接完毕。 这种方式并不适合做实验，因为各个人的网络环境不一样，用桥接的方式会需要申请一个独立的ip,若在公司，很有可能与别人的ip地址冲突，造成不必要的麻烦。 使用NAT模式，相当于构造了独立的局域网环境，这个局域网环境是不受外界网络干扰，而且内部局域网络可以通过Windows主机共享上网。 NET网络配置 为了我们都能统一使用linux网络环境，那么我们需要继续设置 操作如下：在vmware左上角那里有一个编辑选项，点击编辑选项，然后出现一个：虚拟网络编辑器（如下图所示） 然后选中VMvet8选项，点击删除网络，再重新添加新的VMvet8网络，在VMnet信息里选中NAT模式，此时要记住：该选项的子网地址，这是VMware给虚拟机配的网络地址，此时可以在windows环境下点击cmd命令，输入ipconfig，得到Windows环境下的ip地址，选中默认网关有值的那个字段的ipv4地址，ip地址与VMware分配的子网ip地址不同。 在点击 图示的NAT设置，跳出如下图片 在配置linux网络环境的网关时用到这个网关ip地址：192.168.78.2，不用修改，点击确定后，点击应用，最后再确定，结束对话框。 此时要初始化网络环境，点击右下角的像电脑一样的图标进入设置模式。 点击桥接模式，确定。 当右下角的电脑图案变亮后，再次点击进入设置，改成“NAT模式”，再确定 打开终端，输入ifconfig 上述这句话显示当前没有分配ip etc/sy 输入：cd /etc/sysconfig/network-scripts/回车后输入ls 如图所示： 注意： 先输入su，输入密码，进入管理员模式， 如图所示 在管理员模式下输入vim ifcfg-eth0进入界面，如下： 配置本机的ip地址：IPADDR=192.168.78.10 源码：NETMASK=255.255.255.0 设置一下网关：GATEWAY=192.168.78.2与之前的一致 输入联通的DNS DNS1=202.106.0.20 保存退出，如图所示 重启网络服务 命令:/etc/init.d/network restart,成功如图所示： 输入ifconfig看是否查看成功： 这里的inet addr：192.168.78.10与我们设置的ip相同 查看我们设置的ip命令：cat ifcfg-eth0 查看当前环境是否可以上网： curl www.baidu.com,发现可以上网 在ping www.baidu.com,也能拼的通。如图所示 本机的ip地址为192.168.78.10和Windows下的ip地址不会冲突，不在同一网段，尽量采用NET模式
SecureCRT 7.3这个工具进行远程控制我们的虚拟机， 在实际使用时，一般会采用终端的方式远程操作，工作中使用用的最多的方式是SecureCRT 1.如何安装及注册SecureCRT教程 http://blog.csdn.net/stephenbruce/article/details/48649625
2.如何用SecureCRT 连接vm的虚拟机教程： http://www.cnblogs.com/shuangxinye/p/6283171.html
用SecureCRT连接我们刚刚已经配置好的linux环境， 鼠标放到标签上，点击右键，如图所示 点击进去，设置终端环境 terminal改成linux,500改成128000 在 Appearance中修改如图所示
配置环境完毕！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206efd94879dc670539395aa1f6bb598/" rel="bookmark">
			Centos7 远程无法连接mysql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下方法就是我在碰到远程连接不到Mysql数据库后试过的方法，最终也是解决掉了问题。所以总结一下。
有两种原因 数据库没有授权服务器防火墙没有开放3306端口 数据库没有授权 对于mysql数据库没有授权，只需要用一条命令就可以了。
mysql&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; //远程连接数据库的时候需要输入用户名和密码 用户名：root 密码:123456 指点ip:%代表所有Ip,此处也可以输入Ip来指定Ip 输入后使修改生效还需要下面的语句 mysql&gt;FLUSH PRIVILEGES; 服务器防火墙没有开放3306端口 centos 有两种防火墙 FirewallD和iptables防火墙
centos7 使用的是FirewallD防火墙。
FirewallD 是 iptables 的前端控制器，用于实现持久的网络流量规则。它提供命令行和图形界面，在大多数 Linux 发行版的仓库中都有。与直接控制 iptables 相比，使用 FirewallD 有两个主要区别： 1.FirewallD 使用区域和服务而不是链式规则。 2.它动态管理规则集，允许更新规则而不破坏现有会话和连接。
FirewallD 是 iptables 的一个封装，可以让你更容易地管理 iptables 规则 - 它并不是 iptables 的替代品。虽然 iptables 命令仍可用于 FirewallD，但建议使用 FirewallD 时仅使用 FirewallD 命令。
1.FirewallD防火墙开放3306端口 firewall-cmd --zone=public --add-port=3306/tcp --permanent 命令含义： --zone #作用域 --add-port=3306/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 重启防火墙 systemctl restart firewalld.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/206efd94879dc670539395aa1f6bb598/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3000627dd66a8842ac5f2c55543c6be/" rel="bookmark">
			idea 如何像eclipse一样打开多个项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.将两个项目或多个项目放在同一个文件夹下,之后用idea打开该文件夹,默认加载该文件夹下所有项目.
2.将右侧"Maven Projects"打开点击"+",再将各个项目的pom.xml文件选中,点击"OK",重新编译项目即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56148407427537255a53cc280d4494a0/" rel="bookmark">
			libcurl使用流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先几个关键的函数： curl_global_init();	//全局初始化 curl_easy_init();	//初始化一个easy handle curl_easy_setopt();	//给easy handle设置参数 curl_easy_perform();	//执行easy handle，阻塞式的 curl_easy_cleanup();	//销毁easy handle curl_global_cleanup();	//清理全局 大致流程如此：
程序开始时执行curl_global_init(),初始化libcurl要用到的一系列环境调用curl_easy_init()，初始化一个easy handle使用curl_easy_setopt()给easy handle设置一些http传输的参数，比如设置url，设置传输完成接收到的数据怎么处理，设置http头部等curl_easy_perform()字如其名，真正开始进行http通信了如果你还需要继续进行http通信的话，再次调用curl_easy_perform任务完成了，调用curl_easy_cleanup(),释放掉easy handle所占用的内存不再需要使用libcurl时，调用curl_global_cleanup()释放内存 CURLcode curl_global_init(long flags); flags取值： CURL_GLOBAL_ALL: 初始化全部可能要用到的功能，&lt;推荐&gt; CURL_GLOABL_WIN32: 在windows平台使用 CURL_GLOBAL_SSL: 使用ssl库，支持https的话用这个（前提是，编译libcurl的时候添加了支持的ssl的选项） 1.这个函数只需要被执行一次。 2.当你没有显式调用这个函数的话，这个函数将会在你调用curl_easy_init()的时候被自动执行 3.一般情况下，没有调用这个函数而在curl_easy_init()中被隐式调用是没有问题的，但是当多线程的情况下，则可能会出现被多次调用的问题 4.所以，还是手动调用一次比较稳妥 CURL *curl_easy_init(void); 返回值: 一个CURL类型的指针 CURLcode curl_easy_setopt(CURL *handle, opt, param); handle: curl_easy_init()函数初始化返回的easy handle opt和param相对应: CURLOPT_URL: 对应一个url字符串，也就是想要请求的url地址 CURLOPT_VERBOSE: 对应1，表示要求输出调试信息(是libcurl内部另开一个线程输出的) CURLOPT_DEBUGFUNCTION: 表示调试信息要输出的级别 CURLOPT_WRITEFUNCTION: 设置回调函数，这个回调函数将在内部socket一旦接收到数据时被调用 (**注意并不是接收到全部数据才被调用，而是只要接收到数据就调用，数据大时将会被多次调用**) 例子: curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, back); 回调函数的原型： size_t back(void *buffer, size_t size, size_t nmemb, void *userpt); buffer: 执行接收到的数据的首地址 size: 接收到的每一个数据项的字节数 nmemb: 接收到的数据项的个数 userpt: 用户可以自由使用的指针,一般是用来传递一个文件指针，用来在函数体内部保存数据 CURLOPT_HTTPHEADER: 设置http请求的头部 例子：curl_easy_setopt(handle, CURLOPT_HTTPHEADER, headers); headers: 一个curl_slist类型的指针，设置方法如下： struct curl_slist *headers = NULL;//必须被赋予NULL headers = curl_slist_append(headers, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56148407427537255a53cc280d4494a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/348c8ad53cd3177a5eb26a02ce3f7053/" rel="bookmark">
			为什么说BP神经网络就是人工神经网络的一种？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BP( Back Propagation)网络是由Rinehart等于1986年提出的，是一种按误差逆传播算法训练的，多层前馈网络，是目前应用最广泛的神经网络模型之一。 –BP网络能学习和存储大量的输入、输出模式映射关系，而无须事前揭示描述这种映射关系的数学方程。 –其学习规则是使用梯度下降法，通过反向传播来不断调整网络的权值和阈值，使网络的误差平方和最小。 BP神经网络模型拓扑结构包括： 输入层(Input)，这一区域相当于外界的刺激，是刺激的来源并且将刺激传递给神经元。 隐藏层( Hide layer)，这一区域表示神经元相互之间传递刺激，相当于人脑里面。 输出层(Output layer)，这一区域表示神经元经过多层次相互传递后，对外界的反应。 BP反馈机制 简单的描述就是，输入层将刺激传递给隐藏层，隐藏层通过神经元之间，联系的权重和激活函数，将刺激传到输出层，输出层整理隐藏层处理后的刺激，产生最终结果。 若有正确的结果，那么将正确的结果和产生的结果进行比较，得到误差，再逆推对神经网中的链接权重进行反馈修正，从而来完成学习的过程。 这就是BP (Back Propagation)神经网的反馈机制，也是名字的来源，即运用向后反馈的学习机制，来修正神经网中的权重，最终达到输出正确结果的目的。 双向信号传播 BP算法由数据流的前向(正向)传播和误差信号的反向传播两个过程构成。 –正向传播时，传播方向为输入层-隐层-输出层，每层神经元的状态只影响下一层神经元。 –若在输出层得不到期望的输出，则转向误差信号的反向传播流程。 这两个过程的交替进行 –在权向量空间，执行误差函数梯度下降策略，动态迭代搜索一组权向量。 –使网络误差函数达到最小值，从而完成信息提取，和记忆过程。 正向传播 设BP神经网络的输入层有n个节点，隐层有q个节点，输出层有m个节点，输入层与隐层之间有权值为vki，隐层与输出层之间的权值为wjk，三层神经网络的拓扑结构，如下图所示。 隐层传递函数为ƒ1(•)，输出层的传递函数为ƒ2(•)，则隐层节点的输出为(将阈值写入求和项中,k=1,2,…q) •输出层节点的输出为(j=l,2,…,m)： •至此BP网络完成n维空间向量对m维空间的近似映射 反向传播 反向传播，目的是传递误差信号 –所以要进行定义误差函数、输出层权值变化、以及隐层权值变化等操作。 –以上作用可分别以数据公式表达出来： –式中x1,x2,…,xq为输入信号，wj1,wj2,…,wji,…,wjn为神经元k之权值，uk为线性组合结果，θk为阈值，f (•)为激活函数，yk为神经元k的输出。 –若把输入的维数增加一维，则可把阈值θk包括进去。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe5787fee3847384395b547e90f69c2/" rel="bookmark">
			Vagrant Failed to open/create the internal network
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天还好好运行的 vagrant，今天突然运行不起了，执行 vagrant up 一直报这个错：
There was an error while executing `VBoxManage`, a CLI used by Vagrant for controlling VirtualBox. The command and stderr is shown below. Command: ["startvm", "0688d1d9-6ef1-4b8b-9870-6c437fd11e3f", "--type", "headless"] Stderr: VBoxManage.exe: error: Failed to open/create the internal network 'HostInterfaceNetworking-VirtualBox Host-Only Ethernet Adapter' (VERR_SUPDRV_COMPONENT_NOT_ FOUND). VBoxManage.exe: error: Failed to attach the network LUN (VERR_SUPDRV_COMPONENT_NOT_FOUND) VBoxManage.exe: error: Details: code E_FAIL (0x80004005), component ConsoleWrap, interface IConsole 由于 windows10 更新我没有关掉，天杀的不知道给更新了神马东西，导致 vagrant 一直启动不鸟。这个问题在低版本的 VirtualBox 中是不会出现的，解决办法就是更新 VirtualBox 版本为 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfe5787fee3847384395b547e90f69c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b9530e729d6b5c281cad99f82ce7e9d/" rel="bookmark">
			typescript 中通过构造函数的参数直接定义属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击在我的博客 xuxusheng.com 中查看，有更好的排版哦~ 在通常情况下，我们定义一个类时：
class Info { public name: string private age: number constructor() { // ... } } 采用 ts 中简写的语法：
class Info { constructor( public name: string private age: number ) {} } 它可能看上去不像是有属性的类，但它确实有，利用的是 Typescript 提供的简写形式 — 用构造函数的参数直接定义属性。
这个简写语法做了很多：
声明了一个构造函数参数及其类型声明了一个同名的公共属性当我们 new 出该类的一个实例时，把该属性初始化为相应的参数值 在 ng4 中，就可以通过此种写法来注入服务。
对比转换前后的代码如下：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/202/">«</a>
	<span class="pagination__item pagination__item--current">203/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/204/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>