<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0f3be3816782ebc75e629e4c9bf4f54/" rel="bookmark">
			VitePress搭建技术文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VitePress 使用vitepress搭建类似element-plus、layui-vue、Naive UI等技术文档博客。
个人认为vitepress就是vite+vue3+markdown。
一、vitepress 创建项目 // 1.创建demo文件夹，并且进入demo文件夹 mkdir demo &amp;&amp; cd demo // 2.使用npm命令初始化项目，会生成一个package.json文件 npm init // 3.使用npm命令安装vitepress npm install --dev vitepress 4、在项目的根目录下创建一个docs文件夹，在其目录下创建一个index.md文件
touch index.md 5、在 package.json.添加一些script命令
{ "scripts": { "docs:dev": "vitepress dev docs", "docs:build": "vitepress build docs", "docs:serve": "vitepress serve docs" } } 7、启动项目
npm run docs:dev 8、文档结构:
|-- docs
|-- docs |-- .vitepress |-- config.js
|-- docs |-- theme |-- index.js
|-- docs |-- index.md
|-- node_modules
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0f3be3816782ebc75e629e4c9bf4f54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62dc38fc82db3bcb589fbafef4d0fbd2/" rel="bookmark">
			Python实现Excel切片删除功能（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Python实现Excel中的“切片删除”功能（附源码） 先上效果图！！！ 如下是需要处理的Excel文件，可以看到在27行和117行处的E列存在数据不一致情况，需进行“切片删除”
运行结果图如下：
我们可以发现，E列27行至117行处的不一致数据已经被删除，即实现了在Excel文件内部进行进行**“切片化”**的数据删除操作！！！
什么是“切片删除”？ 在Excel中，切片是一种数据筛选工具，它允许您以交互的方式对数据进行过滤和分析。切片删除功能是指删除已创建的切片。
要删除切片，您可以按照以下步骤操作：
在Excel工作表中，单击任意一个包含切片的单元格。在“切片工具”选项卡上，选择“切片操作”组中的“删除”按钮。或者，您可以右键单击切片，然后选择“删除”。 删除切片后，相关的切片将从工作表中移除。注意，这不会影响数据本身，只是移除了用于筛选数据的切片控件。请注意，切片删除功能只适用于Excel 2013及更高版本。在较早的版本中，删除切片的步骤可能略有不同，但大致思路是一样的。
如何使用Python进行批量Excel数据文件的切片删除功能？ delete_slices方法是openpyxl库提供的一个函数，用于删除Excel工作表中的切片。
底层原理涉及以下几个步骤：
openpyxl库加载Excel文件：通过调用load_workbook函数，openpyxl库可以读取Excel文件，并将其加载到内存中以进行后续操作。定位要操作的工作表：使用workbook['Sheet1']语句，我们选择要操作的具体工作表。这里假设工作表的名称为"Sheet1"。删除切片：调用delete_slices方法，可以删除工作表中的所有切片。保存修改后的Excel文件：使用save方法将修改后的Excel文件保存到硬盘上。这样可以确保我们对切片的删除操作得以保存。 openpyxl库是一个强大的Python库，它允许我们处理Excel文件的各种操作。在删除切片的底层实现中，openpyxl库会解析Excel文件的结构，并找到切片相关的数据及其位置信息。然后，它会对这些数据进行相应的删除操作，并将修改后的数据重新写入到Excel文件中。
需要注意的是，openpyxl库只能操作XLSX格式的Excel文件，无法处理旧版本（.xls）的Excel文件。
代码如下： import pandas as pd import openpyxl # 读取Excel文件 df = pd.read_excel('筛选后文件.xlsx') # 获取要遍历的列号，假设列号为4（第5列） column_num = 4 start_row = None end_row = None # 标记变量 flag_A = False flag_B = False # 保存要删除的行索引 rows_to_delete = [] # 遍历指定列的数据 for index, value in df.iloc[:, column_num].items(): if value == '执行机构类型': # 获取坐标 cell = df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62dc38fc82db3bcb589fbafef4d0fbd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847a7d9104f1eae7e9cb7e3af1e8e7a5/" rel="bookmark">
			【论文阅读】（2023）Lower and Upper Bounding Procedures for the Bin Packing Problem with Concave Loading...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Abstract 摘要二、Introduction 介绍三、Literature review 文献综述四、Mathematical programming formulations 数学规划公式4.1 An exponential set partitioning formulation of the BPPC BPPC的指数集划分公式4.2 A polynomial formulation for the piecewise-linear case 分段线性情况下的多项式公式 五、Lower Bounds 下界5.1 The continuous lower bound 连续下界5.2 Column generation 列生成5.3 The pricing algorithm 定价算法 六、Heuristics 启发式方法6.1 A constructive subset-sum heuristic 一个构造性的子集和启发式6.2 A local improvement subset-sum heuristic 局部改进子和启发式6.3 Worst-case analysis 最坏情况分析 七、Computational results 计算结果八、Conclusion 结论 论文来源：（2023）Lower and Upper Bounding Procedures for the Bin Packing Problem with Concave Loading Cost
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847a7d9104f1eae7e9cb7e3af1e8e7a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e16911c92bede8472e07c82435ed98/" rel="bookmark">
			Windows OhmGraphite 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows OhmGraphite 配置 由于windows_exporter无法监控温度相关的指标，那么就需要使用OhmGraphite进行监控该指标。
下载 访问 https://github.com/nickbabcock/OhmGraphite/releases/ 地址进行下载最新的版本，下载后解压到你自己放的目录
修改配置 编辑OhmGraphite.exe.config文件，增加prometheus作为接收数据源。
&lt;?xml version="1.0" encoding="utf-8" ?&gt; &lt;configuration&gt; &lt;appSettings&gt; &lt;add key="host" value="localhost" /&gt; &lt;add key="port" value="2003" /&gt; &lt;add key="interval" value="5" /&gt; &lt;!--开启prometheus--&gt; &lt;add key="type" value="prometheus" /&gt; &lt;add key="prometheus_port" value="4445" /&gt; &lt;add key="prometheus_host" value="*" /&gt; &lt;/appSettings&gt; &lt;/configuration&gt; 安装 执行安装将OhmGraphite以服务的方式运行。打开Windows PowerShell (管理员版本),cd到你刚刚解压的目录。运行安装命令。
.\OhmGraphite.exe install 启动 .\OhmGraphite.exe start 访问 启动后用浏览器打开：http://127.0.0.1:4445/metrics 查看是否能够读取到数据。看到数据后，说明配置成功了。然后在配置prometheus接收数据。
Prometheus增加配置 global: scrape_interval: 15s scrape_configs: - job_name: 'ohmgraphite' static_configs: - targets: ['127.0.0.1:4445'] 添加配置之后，重启服务即可
Grafana面版配置 https://grafana.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6e16911c92bede8472e07c82435ed98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce431d53641dff4efd578eaeabc8f68/" rel="bookmark">
			解决Visio中公式变形问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每次输入公式都通过
插入-&gt;对象-&gt;mathType Equation 新建一个公式。
正常情况下第一个公式通过新建创建后，后面的公式就可以复制第一个公式然后在它基础上修改了，也一般也不会发生变形。
新建的时候麻烦一点，但后面都不用担心变形了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d19363bb65556c4894cb146f058d4a4/" rel="bookmark">
			visio画图取消图周围空白边距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 已经选择了“适应绘图”后发现流程图边缘依旧存在白边
需要将边距都修改为0 ①点击左上角的“文件” ②在接下来的窗口点击”选项“ ③点击”选项“后，在弹出的页面点击“自定义功能区”，再勾选上“开发工具”， 然后点击“确定” ④回到主界面后在“开发工具”选项卡下点击“显示ShapeSheet”---“页” ⑤在弹出的页面将以下几项边距全部改为合适数字 ⑥修改完毕后再次设置适应绘图比例即可： ⑦修改完毕后白边就消失了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcfcfc75f2cd21e48430af54e3cbb33b/" rel="bookmark">
			更新node之后重新安装node_modules报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新node版本之后一定要重新安装依赖。
安装依赖的时候可能会遇到各种各样的报错，具体解决方法如下：
1.全局安装npm包：
npm install rimraf -g
2.删除 node_modules 文件夹命令：
rimraf node_modules
3.清理npm缓存：
npm cache clean --force
4.重新安装依赖库：
npm install
以上方法能解决90%的node更新之后安装依赖时的报错，over~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/986089ef0b119c5fb5302199287cff59/" rel="bookmark">
			跟着cherno手搓游戏引擎【3】事件系统和预编译头文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不多说了直接上代码，课程中的架构讲的比较宽泛，而且有些方法写完之后并未测试。所以先把代码写完。理解其原理，未来使用时候会再此完善此博客。
文件架构： Event.h:核心基类
#pragma once #include"../Core.h" #include&lt;string&gt; #include&lt;functional&gt; namespace YOTO { // Hazel中的事件当前是阻塞的，这意味着当一个事件发生时，它立即被分派，必须立即处理。 //将来，一个更好的策略可能是在事件总线中缓冲事件，并在更新阶段的“事件”部分处理它们。 //事件类型 enum class EventType { None = 0, WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved, AppTick, AppUpdate, AppRender, KeyPressed, KeyReleased, MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled }; //事件分类 enum EventCategory { None = 0, EventCategoryApplication = BIT(0), EventCategoryInput = BIT(1), EventCategoryKeyboard = BIT(2), EventCategoryMouse = BIT(3), EventCategoryMouseButton = BIT(4) }; //定义一些重复的重写的函数，只需要传入固定参数，就能少些一大部分代码 #define EVENT_CLASS_TYPE(type) static EventType GetStaticType(){return EventType::##type; }\ virtual EventType GetEventType() const override {return GetStaticType();}\ virtual const char* GetName() const override {return #type;} #define EVENT_CLASS_CATEGORY(category) virtual int GetCategoryFlags() const override {return category; } /// &lt;summary&gt; /// 事件基类，事件需要继承此类 /// &lt;/summary&gt; class Event { public: //获得该事件的具体类型 virtual EventType GetEventType() const = 0; //获得事件的名称 virtual const char* GetName() const = 0; //获得该事件的大类型 virtual int GetCategoryFlags() const = 0; //toString方法，返回事件名 virtual std::string ToString() const { return GetName(); } //判断该事件是否是category类 inline bool IsInCategory(EventCategory category) { return GetCategoryFlags() &amp; category; } protected: //事件是否被处理了 bool m_Handled = false; }; /// &lt;summary&gt; /// 事件拦截器 /// &lt;/summary&gt; class EventDispatcher { template &lt;typename T&gt; using EventFn = std::function&lt;bool(T&amp;)&gt;; public: EventDispatcher(Event&amp; event) :m_Event(event) { } template &lt;typename T&gt; bool Dispatch(EventFn&lt;T&gt; func) { if (m_Event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/986089ef0b119c5fb5302199287cff59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40fcebeeabf52e08572ca3243c5337cf/" rel="bookmark">
			23种设计模式都适用于哪些场景？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据对设计模式的学习，总结出各类设计模式的使用场景，了解哪些场景下适合使用哪种设计模式来解决该场景的问题，这样才能学而致用，仅仅了解设计模式但不能实践那学了又有什么用呢？下面来看看各种设计模式的使用场景（个人理仅供参考）
一、创建模式
1.工厂方法：一个工厂通过方法创建多个产品
2.抽象工厂方法：多个工厂创建多个产品族
3.建造者模式：分解构建步骤，分步构建
4.原型模式：一个对象需要多次修改部分值，利用克隆实现
5.单例模式：只要一个实例，减少系统开销
二、结构模式
6.适配器模式：重构时，不修改已有模块，增加适配器来协调2个模块工作
7.桥接模式：开发时，jdbc,需要增加桥对象，可切换对接对象，实现不同桥功能
8.组合模式：开发时，组织机构，文档结构
9.装饰器模式：重构时，不修改已有模块，对已有模块功能进行扩展
10.外观模式：开发重构
11.享元模式：开发时，创建对象池，共享对象，减少系统开销
12.代理模式：重构时，代理目标对象执行，主要是控制目标对象方式是否执行
三、行为模式
13.责任链模式：审批流
14.命令模式：浏览器的请求方式，封装请求，分离请求者与接收者
15.解释器模式：表达式解析
16.迭代器模式：迭代器
17.备忘录模式：ghost，保存当前对象状态，用于恢复
18.中介者模式：QQ，多个构件间通信的枢纽
19.观察者模式：消息通知，广播机制，通过注册接收者，观察者发消息给多个接收者
20.状态模式：针对对象切换，将状态封装成对象，通过切换状态来用不同状态对象实现相同方法。
21.策略模式：针对方法切换，对某个方法进行切换，实现不同的实现方式。
22.模板方法模式：sitmesh，tiles,freemarker就是类似装饰模式，只不过如同模板一般，只需要关注变动的地方即可
23.访问者模式：利用多态特性
应用场景总结
设计模式是一种在软件设计中用于解决常见问题的方法。它们提供了一组可重用的设计，可以被用来解决软件设计中的各种问题。下面是23种常见的设计模式，以及它们的适用场景：
🍊1️⃣工厂模式：在这种模式中，一个类用于创建另一个类的实例。这种模式适用于在不知道具体实现细节的情况下创建对象的场景。
🍊2️⃣抽象工厂模式：这种模式提供了一种方法来创建相关或依赖对象的家族，而不需要指定它们的具体类。它适用于需要创建多个不同类型的对象的场景。
🍊3️⃣单例模式：这种模式确保某个类只有一个实例，并提供一个全局访问点来访问它。这种模式适用于需要控制实例数量的场景。
🍊4️⃣建造者模式：这种模式允许将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。它适用于需要生成复杂对象的场景。
🍊5️⃣原型模式：这种模式是通过复制一个现有对象来生成新对象的。它适用于需要快速创建大量同类对象的场景。
🍋6️⃣代理模式：这种模式为另一个对象提供了一个替身或占位符，以便控制对这个对象的访问。它适用于需要在访问某个对象时增加额外控制的场景。
🍋7️⃣适配器模式：这种模式允许将一个类的接口转换成另一个接口，以便于不兼容的类可以一起工作。它适用于需要让两个不兼容的类一起工作的场景。
🍋8️⃣桥接模式：这种模式将抽象部分和实现部分分离，以便它们可以独立变化。它适用于需要将一个类的抽象部分和实现部分独立改变的场景。
🍋9️⃣组合模式：这种模式允许将对象组成树形结构来表现“整体/部分”层次结构。它适用于需要表示树形结构的场景。
🍋1️⃣0️⃣装饰模式：这种模式允许在不改变现有对象的情况下动态地给它们添加新的职责。它适用于需要动态地为对象添加新职责的场景。
🍋1️⃣1️⃣外观模式：这种模式提供了一个统一的接口，用来访问子系统中的一群接口。它适用于需要为一个复杂的子系统提供一个简单的接口的场景。
🍋1️⃣2️⃣享元模式：这种模式允许共享对象，以便最大限度地减少内存占用。它适用于需要在多个地方共享大量细粒度对象的场景。
🍏1️⃣3️⃣策略模式：这种模式定义了一组算法，并将它们封装起来，使它们可以相互替换。它适用于需要在不同情况下使用不同算法的场景。
🍏1️⃣4️⃣模板方法模式：这种模式定义了一个操作中的算法骨架，而将一些步骤延迟到子类中。它适用于需要在不改变算法结构的情况下重定义算法中的某些步骤的场景。
🍏1️⃣5️⃣观察者模式：这种模式定义了对象之间的一对多依赖，以便当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。它适用于需要在对象之间松散耦合的场景。
🍏1️⃣6️⃣迭代器模式：这种模式提供了一种方法来访问一个容器对象中各个元素，而又不暴露该对象的内部细节。它适用于需要为容器对象提供多种遍历方式的场景。
🍏1️⃣7️⃣中介者模式：这种模式用一个中介对象来封装一系列的对象交互，使各对象不需要显式地相互引用，从而使耦合松散，而且可以独立地改变它们之间的交互。它适用于需要在多个对象之间松散耦合的场景。
🍏1️⃣8️⃣解释器模式：这种模式定义了一个语言的文法，并且建立一个解释器来解释该语言中的句子。它适用于需要定义一个语言并为该语言实现一个解释器的场景。
🍏1️⃣9️⃣状态模式：这种模式允许一个对象在其内部状态改变时改变它的行为。它适用于需要根据对象的状态来改变它的行为的场景。
🍏2️⃣0️⃣访问者模式：这种模式把作用于某个对象结构中各元素的操作分离出来封装成独立的类，使其在不改变各元素的类的前提下可以添加作用于这些元素的新操作。它适用于需要在不改变各元素的类的前提下定义对这些元素的新操作的场景。
🍏2️⃣1️⃣命令模式：这种模式将一个请求封装为一个对象，以便使用不同的请求、队列或日志来参数化其他对象。它适用于需要支持命令的撤销和恢复、延迟调用或日志操作的场景。
🍏2️⃣2️⃣责任链模式：这种模式为请求创建了一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，它会把相同的请求传给下一个接收者，依此类推。它适用于需要在多个对象之间松散耦合的场景，并且希望在不明确指定接收者的情况下，向多个对象中的一个提交一个请求的场景。
🍏2️⃣3️⃣备忘录模式：这种模式提供了一种方法来在不破坏封装性的情况下获取一个对象的内部状态，并在需要的时候将对象恢复到先前的状态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01826f3ea6d8bab50bc841526133bced/" rel="bookmark">
			vue2实现自定义主题webpack-theme-color-replacer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：根据element的自定义主题色，之后改变element的全局所有颜色，解决页面刷新后主题色失效问题，这个需要把颜色存入到浏览器的存储中，如果换个浏览器就得重新选择了哈，如果需要在不同的浏览器保持一致的主题，需要跟后端沟通
之前还写过一个简单的，有需要的可以去看：vue实现element-ui自定义主题色切换(简单版)_element主题切换_请叫我欧皇i的博客-CSDN博客
效果如下：
1.下载颜色插件 我下的是1.4.6版本,最好下载的版本一致吧，不然报错了我也没办法
npm install webpack-theme-color-replacer@1.4.6 2.建个js文件themeColorClient.js 直接复制粘贴以下代码
import client from 'webpack-theme-color-replacer/client' import forElementUI from 'webpack-theme-color-replacer/forElementUI' // 注意自己项目里的引入路径 export let curColor = '#409EFF' // 动态切换主题色 export function changeThemeColor(newColor) { var options = { newColors: [...forElementUI.getElementUISeries(newColor), '#ff0000', '#ffff00'] } return client.changer.changeColor(options, Promise) .then(() =&gt; { curColor = newColor localStorage.setItem('theme_color', curColor) }) } // 页面刷新的时候会触发 export function initThemeColor() { const savedColor = localStorage.getItem('theme_color') if (savedColor) { curColor = savedColor changeThemeColor(savedColor) } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01826f3ea6d8bab50bc841526133bced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd98d587d26061a46b2483b1234e0dd9/" rel="bookmark">
			windows_exporter 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows_exporter 安装 背景 如果想使用Prometheus监控Windows主机相关参数，那么就需要在Windows系统的主机上进行安装指标收集器。
windows_exporter 是 Prometheus 官方所提供的指标收集器。
下载 https://github.com/prometheus-community/windows_exporter/releases
访问此地址，即可下载最新版本
运行 下载完成后，双击即可完成运行，但是这种方式需要将应用一直放置在前台运行，为了以后的管理，可以将应用注册为服务项。
sc create windows_exporter binpath= "C:\windwos_exporter\windows_exporter.exe" type= own start= auto displayname= windows_exporter 注：binpath后接的是.exe程序所在的目录及程序名称
配置 打开一个新的CMD窗口，在CMD窗口中输入services.msc即可打开Windows的服务管理窗口。在此窗口中，找到windows_exporter服务，使用鼠标右击点击属性按钮，在启动参数中添加–telemetry.addr=0.0.0.0:9182，配置完成后，重启即可。
访问 服务启动完成后，访问主机的IP+端口即可，例如：192.168.1.100:9182
Prometheus增加配置 - job_name: "windwos_exporter" scrape_interval: 15s static_configs: - targets: ["192.168.1.100:9182"] 添加配置之后，重启服务即可
Grafana面版配置 在https://grafana.com/grafana/dashboards/?search=windows_exporter网页中寻找一个监控面版，导入Grafana即可。
关于
https://www.oiox.cn/
https://www.oiox.cn/index.php/start-page.html
CSDN、GitHub、51CTO、知乎、开源中国、思否、博客园、掘金、简书、华为云、阿里云、腾讯云、哔哩哔哩、今日头条、新浪微博、个人博客
全网可搜《小陈运维》
文章主要发布于微信公众号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1463ac3e53f8671a427a6742c6bae32b/" rel="bookmark">
			【RPC】序列化：对象怎么在网络中传输？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来聊下RPC框架中的序列化。在不同的场景下合理地选择序列化方式，对提升RPC框架整体的稳定性和性能是至关重要的。
一、为什么需要序列化？ 首先，我们得知道什么是序列化与反序列化。
网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是不能直接在网络中传输的，所以我们需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，这个过程我们一般叫做“序列化”。 这时，服务提供方就可以正确地从二进制数据中分割出不同的请求，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象，这个过程我们称之为“反序列化”。
这两个过程如下图所示：
总结来说，序列化就是将对象转换成二进制数据的过程，而反序列就是反过来将二进制转换为对象的过程。
那么RPC框架为什么需要序列化呢？来看下下RPC的通信流程：
因为网络传输的数据必须是二进制数据，所以在RPC调用中，对入参对象与返回值对象进行序列化与反序列化是一个必须的过程。
二、有哪些常用的序列化？ 那这么看来，你会不会觉得这个过程很简单呢？实则不然，很复杂。我们可以先看看都有哪些常用的序列化，下面我来简单地介绍下几种常用的序列化方式。
2.1、JDK原生序列化 如果你会使用Java语言开发，那么你一定知道JDK原生的序列化，下面是JDK序列化的一个例子：
public class Student implements Serializable { //学号 private int no; //姓名 private String name; public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; }@ Overridepublic String toString() { return "Student{" + "no=" no + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1463ac3e53f8671a427a6742c6bae32b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acba674c4a5ef2f28f26b157d5c6029d/" rel="bookmark">
			Qat&#43;&#43;，轻量级开源C&#43;&#43; Web框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.简介
二.编译Oat++
1.环境
2.编译/安装
三.试用
1.创建一个 CMake 项目
2.自定义客户端请求响应
3.将请求Router到服务器
4.用浏览器验证
一.简介 Oat++是一个面向C++的现代Web框架
官网地址：https://oatpp.io
github地址：https://github.com/oatpp/oatpp
Oat++具有如下特性：
●随处运行
Oat++没有任何依赖性，可以很容易地移植到各种支持的平台上（Linux、BSD、MacOS、OpenWRT、Windows）。
●构建健壮的api
使用Oat++的Simple-API，很容易就能构建出灵活而健壮的High-Level API。
●高并发
使用Oat++的Async-API，可以在单个服务器上处理超过500万个并发连接。
●访问数据库
Oat++ ORM提供了一种简单而统一的方式来访问数据库。
●保持代码一致
Oat++在整个代码中依靠对象映射（Object-Mapping）来确保API和数据模型的一致性。详见：更多
●生成API文档
使用Swagger-UI和OpenAPI 3.0.0自动记录endpoints。详见：更多
Qat++可以应用于多种不同的领域，比如构建运行在嵌入式设备的REST API，构建微服务和高负载的云应用程序。目前主要的应用案例是IOT和Robotics。
那么在实践中该如何选择Oat++的API类型呢？
优先选择Simple API，因为它开发得更加完善。如果是并发任务，就可以考虑使用Async API了，Async API通常用于以下几种场景：
●文件上传、下载
●向大量客户端推流
●Websocket聊天服务器
说起Web开发，大多数人会想到 Java、Python、Golang ... ，因为用它们实现的主流Web框架有很多：Java有非常知名的Spring全家桶，Python有大而全的Django、小而精的Flask、高性能的Tornado，Golang也有快速灵活的Gin、Echo等框架。
不过现在做C/C++开发的同学可以收回羡慕的眼神啦，Oat++作为C/C++ Web框架的后起之秀，还是非常值得研究的。
二.编译Oat++ 这里以Windows为例，其他平台可参考官网。
1.环境 Window 10
Visual Studio 2017（官网测试用的就是这个版本）
CMake 3.25.1（推荐用最新版）
2.编译/安装 以管理员权限打开“VS 2017的开发人员命令提示符”窗口
否则安装的时候会报如下错误：
git clone https://github.com/oatpp/oatpp.git cd oatpp MD build cd build cmake .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acba674c4a5ef2f28f26b157d5c6029d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8dee79149188ee1d2a60242d13119d2/" rel="bookmark">
			Github 2024-01-14 Go开源项目日报 Top10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据Github Trendings的统计，今日(2024-01-14统计)共有10个项目上榜。根据开发语言中项目的数量，汇总情况如下：
开发语言项目数量Go项目10TypeScript项目1 frp: 一个开源的快速反向代理 创建周期：2946 天开发语言：Go协议类型：Apache License 2.0Star数量：75872 个Fork数量：12424 次关注人数：75872 人贡献人数：93 人Open Issues数量：102 个Github地址：https://github.com/fatedier/frp.git frp是一个开源的快速反向代理，允许用户将位于NAT或防火墙后面的本地服务器暴露到互联网上。
Harbor - 开源的云原生注册表项目 创建周期：2908 天开发语言：Go协议类型：Apache License 2.0Star数量：21549 个Fork数量：4526 次关注人数：21549 人贡献人数：297 人Open Issues数量：597 个Github地址：https://github.com/goharbor/harbor.git项目首页: https://goharbor.io Harbor是一个开源的可信的云原生注册表项目，用于存储、签名和扫描内容。它通过添加安全性、身份验证和管理等功能，扩展了开源的Docker Distribution。它支持镜像在注册表之间的复制，并提供用户管理、访问控制和活动审计等高级安全功能。
OpenTofu: 声明性云基础设施管理工具 创建周期：151 天开发语言：Go协议类型：Mozilla Public License 2.0Star数量：17366 个Fork数量：602 次关注人数：17366 人贡献人数：360 人Open Issues数量：166 个Github地址：https://github.com/opentofu/opentofu.git项目首页: https://opentofu.org OpenTofu是一个开源工具，用于声明性地管理云基础设施。它支持基础设施即代码、执行计划、资源图和变更自动化，提供了高效和安全的基础设施管理。
Apache Answer - 问答平台软件 创建周期：472 天开发语言：Go, TypeScript协议类型：Apache License 2.0Star数量：10391 个Fork数量：711 次关注人数：10391 人贡献人数：49 人Open Issues数量：63 个Github地址：https://github.com/apache/incubator-answer.git项目首页: https://answer.apache.org Apache Answer是一种面向任何规模团队的问答平台软件，可作为社区论坛、帮助中心或知识管理平台。
Bytebase: 高级数据库DevOps和CI/CD解决方案 创建周期：1082 天开发语言：Go协议类型：OtherStar数量：9086 个Fork数量：615 次关注人数：9086 人贡献人数：69 人Open Issues数量：39 个Github地址：https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8dee79149188ee1d2a60242d13119d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576fdbe5be4aa3235a2c488f15ebf2c9/" rel="bookmark">
			看书标记【R语言数据分析项目精解：理论、方法、实战 7】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看书标记——R语言 Chapter 7 构建用户画像7.1项目背景、目标和方案7.1.1项目背景7.1.2项目目标 7.2项目技术理论简介7.2.1用户画像的基本概念7.2.2用户画像应用领域7.2.3用户画像分类7.2.4用户画像构建1.数据源2.用户画像构建粒度3.用户画像构建抽象方法4.用户画像标签创建流程5.用户画像标签构建难点 7.2.5用户画像标签的数值处理方法1.数值归一化2.连续型数值的离散化方法 7.3项目实践 【R语言数据分析项目精解：理论、方法、实战】 Chapter 7 构建用户画像 7.1项目背景、目标和方案 7.1.1项目背景 大部分服务性企业从以产品为中心的理念转变成了以用户为中心的理念。产品的设计从企业想让用户用什么产品变成了企业为用户的需求设计产品，所以应尽量多地收集用户信息并分析用户特征。首先需要搞清用户画像系统的整个全貌和构建方法，并且制定用户画像系统的标准。
7.1.2项目目标 （1）梳理用户画像理论，了解用户画像指标制作流程。
（2）针对公司业务情况，创建用户画像系统指标大类。
（3）制定用户画像指标规范。
7.2项目技术理论简介 7.2.1用户画像的基本概念 用户画像就是用户信息的标签化过程，这些标签的集合反映了一个用户的整体全貌。
7.2.2用户画像应用领域 市场营销：市场营销人员可以根据用户画像标签挑选合适的用户进行有针对性的营销，可以有效提高活动效果、降低成本，也称数据库营销。
业务产品设计、功能界面设计：找出主要用户，得到用户画像系统的任务。
智能化推荐：最常用的就是协同过滤算法，分为两类：根据用户属性（找与用户相似的用户喜欢的东西，需要事先对用户打标签）、根据产品属性。
监控运营环境：监控某几个类别用户的行为，可以及早发现运营情况的局部变化。
用户统计数据：有助于发现被整体数据所掩盖的数据问题。
7.2.3用户画像分类 静态信息标签：确定后不会变动的标签。
动态信息标签：会随着时间的推移及用户行为的不同而发生变化的标签。
or
确定性指标：数值准确、含义清晰的指标。
非确定性指标：预测型的标签，其数值是统计推断的结果而非真实发生的，如潜在高价值用户、使用偏好等。
7.2.4用户画像构建 1.数据源 （1）用户基本信息：用户注册信息表、收件人信息、通过活动收集、模型预测。
（2）用户行为数据：通过埋点的方式记录用户的浏览记录得到。
（3）用户订单数据：高利润用户、忠诚度用户、价格敏感用户、产品偏好等。
（4）用户投诉信息：游客一般不会有反馈，用户信息也包括反馈信息。
2.用户画像构建粒度 用户id的唯一标识：Cookie、uid、E-mail、微信、QQ、微博、手机号、身份证。
3.用户画像构建抽象方法 将数据聚集到适当的粒度、将数据旋转到相应时间序列、对已有值进行适当的变换、各种方式创造派生变量（虚拟变量）。
4.用户画像标签创建流程 1、由业务方提出需求，共同探讨标签内容，确定标签使用的业务场景，指定标签含义。
2、确定标签用途后，由标签含义收集或寻找相应的基础数据，之后整合到统一的数据平台。
3、对数据统一处理，用统计方法对明细数据进行适当的汇总。
4、离散型数据（直接用于用户画像标签）、连续数据（离散化处理），五级分和十级分等。
业务方的一个需求可以创建出至少一个用户画像，需注意，在创建用户画像标签时必须注明应用场景和使用方法，有时不同场景的指标数据会有差异，所以需要附上指标说明书。
5.用户画像标签构建难点 1、打通不同数据源，链接来自不同数据源的用户数据。
2、用户画像的时效性，针对动态标签，可以建立一套自动化更新流程，一旦源头更新，下游指标数据可以自动更改。对于预测型数据，可以建立一套机制来提醒分析人员定期或者不定期对标签数据进行修改，保证数据的时效性。
3、将连续型指标合理地离散化。
7.2.5用户画像标签的数值处理方法 1.数值归一化 min-max标准化（把数据归一到0~1）、log函数标准化（较适用于偏态数据）、atan函数标准化（如果想映射的区间为[0,1]，则数据都应该大于等于0，小于0的数据将被映射到[-1,0]区间上。）、Z-score函数标准化（最常用）。
2.连续型数值的离散化方法 1、等距划分：将取值范围均匀的划分成n分，每份间距相等。
2、等频划分：把数据均匀的划分为n份，每份的样本数量相同，常会将数据排序后划分，达到分层抽样的目的。
3、聚类分析：常用的是k-means聚类。k-means聚类的聚类类别数需要事先指定，可采用“伪F值”判断，k越大，组间距离与总方差的比例越大，F就越接近1，但增加的比例会逐步减少，增加比例的绝对量出现拐点时，k的取值可以用做最终的划分类别数。
7.3项目实践 粒度（指统一用什么样的id作为用户的唯一标识）选为uid，包括4个类别的用户画像标签，基本信息、会员信息、浏览行为、订单信息
用户年龄标签有用k-means做离散化处理。
1.指标数据的描述性统计
setwd("C:\\Users\\用户路径") age_uid&lt;-read.csv("age.csv",header=TRUE,stringsAsFactors=FALSE) ##################################################################### #函数功能：画出数据分布函数及QQ图 #参数说明：input.data：连续型指标数据 index_dispic&lt;-function(input.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576fdbe5be4aa3235a2c488f15ebf2c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d436d8c39c3c6e1ba5a27398105299/" rel="bookmark">
			ABC210(A-C)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,a,x,y; cin&gt;&gt;n&gt;&gt;a&gt;&gt;x&gt;&gt;y; if(n&lt;=a)cout&lt;&lt;n*x&lt;&lt;endl; else cout&lt;&lt;a*x+(n-a)*y&lt;&lt;endl; return 0; } B #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; cin&gt;&gt;n; string s; cin&gt;&gt;s; int l=s.length(); int i; for(i=0;i&lt;l;i++){ if(s[i]=='1')break; } if(i%2==0)cout&lt;&lt;"Takahashi"&lt;&lt;endl; else cout&lt;&lt;" Aoki"&lt;&lt;endl; return 0; } C #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { ll n,k; cin&gt;&gt;n&gt;&gt;k; ll num[n]; map&lt;ll,ll&gt; mp; for(ll i=0;i&lt;n;i++){ cin&gt;&gt;num[i]; } ll max=0; for(ll i=0;i&lt;k;i++){ mp[num[i]]++; } max=mp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d436d8c39c3c6e1ba5a27398105299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd0abf91f8dfe7f6c7bc22b8fedfbfb/" rel="bookmark">
			layui 表单提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML 代码
&lt;link rel="stylesheet" href="/tp5/public/static/layui/css/layui.css"&gt; &lt;form class="layui-form" action="{:url('admin/adminRoleSave')}" method="post"&gt; &lt;div class="layui-form-item"&gt; &lt;label class="layui-form-label"&gt;角色名称&lt;/label&gt; &lt;div class="layui-input-block"&gt; &lt;input type="text" name="name" placeholder="请输入" autocomplete="off" class="layui-input"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="layui-form-item layui-form-text"&gt; &lt;label class="layui-form-label"&gt;请填写描述&lt;/label&gt; &lt;div class="layui-input-block"&gt; &lt;textarea name="remarks" placeholder="请输入内容" class="layui-textarea"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="layui-form-item"&gt; &lt;div class="layui-input-block"&gt; &lt;button class="layui-btn" lay-submit lay-filter="demo"&gt;新增角色&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; javascript代码
script src="/tp5/public/static/js/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="/tp5/public/static/layui/layui.js"&gt;&lt;/script&gt; &lt;script&gt; layui.use('form', function(){ var form = layui.form(); //监听提交 form.on('submit(*)', function(data){ $.ajax({ url:data.form.action, type:data.form.method, data: data.field, success: function (info) { if (info.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd0abf91f8dfe7f6c7bc22b8fedfbfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d005c221327bb10efa48ed5b3f69d289/" rel="bookmark">
			Nue Js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装 使用npm安装nue
# clone the repository git clone https://github.com/nuejs/create-nue.git # cd to the cloned repository cd create-nue # install dependencies bun install # or with Node: npm install # Build demo site and start a HTTP server bun --bun start # or with Node: npm run start # Open the demo on the browser open "http://localhost:8080" # optional: detach the repository from github rm -rf .git npm install nuejs - core npm run start 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/164c24dc2515e76df020c1a94d62d582/" rel="bookmark">
			Github 2024-01-13 C#开源项目日报 Top8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据Github Trendings的统计，今日(2024-01-13统计)共有8个项目上榜。根据开发语言中项目的数量，汇总情况如下：
开发语言项目数量C项目8 Redis - 内存数据库和数据结构服务器 创建周期：5411 天开发语言：C协议类型：BSD 3-Clause “New” or “Revised” LicenseStar数量：62974 个Fork数量：23165 次关注人数：62974 人贡献人数：385 人Open Issues数量：2517 个Github地址：https://github.com/redis/redis.git项目首页: http://redis.io Redis是一种内存数据库，可以持久化到磁盘，通过一组命令提供对可变数据结构的访问。它提供了诸如复制、可调节的耐久性级别、集群和高可用性等功能。Redis支持各种数据类型，并可以在多个平台上编译和使用。它还提供了构建TLS支持、systemd支持和选择内存分配器的选项。Redis可以使用默认配置运行，也可以通过命令行参数进行修改。安装过程包括安装二进制文件和配置init脚本和配置文件的选项。
Windows工作环境改善项目 创建周期：887 天开发语言：C协议类型：GNU General Public License v2.0Star数量：18848 个Fork数量：876 次关注人数：18848 人贡献人数：9 人Open Issues数量：127 个Github地址：https://github.com/valinet/ExplorerPatcher.git 这个项目旨在改善Windows上的工作环境。
BCC - 用于内核跟踪和操作的BPF工具包 创建周期：3179 天开发语言：C协议类型：Apache License 2.0Star数量：18728 个Fork数量：3716 次关注人数：18728 人贡献人数：357 人Open Issues数量：910 个Github地址：https://github.com/iovisor/bcc.git BCC是一个工具包，用于使用扩展BPF创建高效的内核跟踪和操作程序。它包括各种工具和示例，使用C语言进行内核仪器化和Python和Lua的前端，使得编写BPF程序更加容易。它适用于诸如性能分析和网络流量控制等任务。
WindTerm: 专业的跨平台SSH/SFTP/Shell/Telnet/串行终端 创建周期：1557 天开发语言：CStar数量：18515 个Fork数量：1466 次关注人数：18515 人贡献人数：2 人Open Issues数量：1418 个Github地址：https://github.com/kingToolbox/WindTerm.git项目首页: https://kingtoolbox.github.io WindTerm是一个专业的跨平台SSH/SFTP/Shell/Telnet/串行终端，旨在为DevOps提供更快更好的客户端。它完全免费，无论是商业用途还是非商业用途，没有任何限制。该项目在Apache-2.0许可下提供开源代码，源代码将逐步开放。WindTerm还欢迎与SSH、Sftp、Shell、Telnet、串行以及客户端本身相关的问题、功能请求和讨论。
开源时间序列SQL数据库：PostgreSQL扩展 创建周期：2503 天开发语言：C协议类型：OtherStar数量：15982 个Fork数量：838 次关注人数：15982 人贡献人数：85 人Open Issues数量：595 个Github地址：https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/164c24dc2515e76df020c1a94d62d582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d02867085bbc0d9362590b896abef16/" rel="bookmark">
			【Linux】编写第一个小程序：进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 预备知识1.1 简单认识几个函数1.1.1 sleep()1.1.2 fflush()1.1.3 usleep()1.1.4 memset() 1.2 缓冲区1.3 回车与换行 2. 编写入门版的进度条2.1 基本逻辑2.2 美化效果2.3 代码实现2.4 执行效果 3. 编写升级版的进度条3.1 代码实现3.2 执行效果 1. 预备知识 1.1 简单认识几个函数 1.1.1 sleep() unsigned int sleep(unsigned seconds); 作用：让程序休眠指定秒数，如：sleep(3); //让程序休眠3秒与 Windows 上的 Sleep() 函数不同需要包含头文件&lt;unistd.h&gt; 1.1.2 fflush() int fflush(FILE* stream); 作用：刷新缓冲区需要传入一个流需要包含头文件&lt;stdio.h&gt; 1.1.3 usleep() int usleep(useconds_t usec); 作用：让程序休眠指定微秒，如：usleep(100000); //让程序休眠100000微秒（0.1秒）1秒 = 1000000微秒需要包含头文件&lt;unistd.h&gt; 1.1.4 memset() void* memset(void* ptr, int value, size_t num); 作用：将 ptr 指向的内存块的前 num 个字节设置为指定的 value 值返回设置后的 ptr需要包含头文件&lt;string.h&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d02867085bbc0d9362590b896abef16/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/23/">«</a>
	<span class="pagination__item pagination__item--current">24/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/25/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>