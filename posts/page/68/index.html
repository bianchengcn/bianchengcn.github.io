<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6135e444e41f1c4b7acb38f552eece22/" rel="bookmark">
			Python学习笔记-4(二进制和三目运算符)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023/4/10
努力学习python，想为以后可以有一份额外收入，如果有大神可以指点一下，我将不胜感激
如果有大神想以后拥有一个合作伙伴进行交流，我会尽力赶上您的脚步！
二进制与十进制之间的转换 二进制的数字只能是0或1，十进制的范围是0-9，是如何进行转换呢?
在程序中，十进制显示二进制是如何输入代码转换：
a = 5 print(bin(a)) #输出a，以二进制的方式输出 在程序中，二进制如何显示十进制呢?
b = 0b10111 print(int(b)) #输出b，以十进制的方式 二进制在Python中的表示方法要在前面添加 0b，并且0b后面只能跟0和1的数字，转换为二进制使用bin函数，转换成十进制使用int函数，二进制和十进制如何计算请自行查找资料学习
在程序中，八进制与十六进制如何表达呢?
#八进制 a = 0o6430 print(int(a)) #八进制表示方法需要使用0o ,且后面数字范围是0-7 #十六进制 a = 0x918 print(int(a)) #十六进制表示方法需要0x，且范围为0-9,a-f *如何表达负数的二进制?
我们会将' 5 '分解成二进制为0000 0101 如何使用二进制表达-5呢?
第一步，先按照正数转换为二进制，5 = 0000 0101。第二步，将正数的二进制进行取反，例如0000 0101的取反结果为1111 1010(将1变为0，将0变为1)。第三步，将取反的二进制末尾+1，得到1111 1011的表达为-5。 如果最后一位为1，则往前进一，直到没有 二进制比较符
&amp;(与)，!(或)，~(取反负数)，^( 异或)，&lt;&lt;(左移)，&gt;&gt;(右移)
三目运算符
三目运算符可以理解为一个简单的判断表达式
如果为真，则返回一个值，如果为假，则返回另外一个值
格式:在Python中的表达格式与其他语言格式不同，Python的格式为result = 结果(True) if 表达式 else 结果(False)，例如:
a = 6 b = 5 result = (a+b) if a&gt;b else (b-a) print(result) #判断a是否大于b，答案是肯定的，则运行a+b,否则运行b-a #结果为11 判断表达式是True还是False，如果是True则将if前面的内容运算，并将结果赋值给result，如果是False则将else后面的内容运算结果，并将结果赋值给result 以上为总结知识点，出自哔哩哔哩千峰宋如宁老师课程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242c2f586628a6052a82873345c76e89/" rel="bookmark">
			华为交换机telnet远程配置方法（仅密码验证和AAA验证）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拓扑图
仅密码验证 LSW1配置：
&lt;Huawei&gt;system-view -----进入配置模式
[Huawei]vlan 10 -----创建vlan10
[Huawei]interface vlan 10 -----进入管理vlan 10
[Huawei-Vlanif10]ip address 192.168.10.1 255.255.255.0 -----配置管理ip地址
[Huawei-Vlanif10]quit -----退出
[Huawei] interface GigabitEthernet 0/0/1 -----进入端口模式
[Huawei] port link-type trunk----端口类型修改为trunk
[Huawei] port trunk allow-pass vlan 10-----trunk端口允许vlan 10 通过
[Huawei]telnet server enable -----打开telnet服务 （一般默认开启）
[Huawei]user-interface vty 0 4 -----用户指定虚拟用户终端接口
[Huawei-ui-vty0-4]authentication-mode password -----配置用户终端接口认证方式 密码验证
[Huawei-ui-vty0-4]set authentication password cipher 123.com -----设置接口验证密码,密码为123.com
[Huawei-ui-vty0-4]user privilege level 15 -----设置用户优先级
[Huawei-ui-vty0-4]idle-timeout 5-----设置登陆超时五分钟 （可选）
&lt;Huawei&gt;save -----保存
LSW2配置：
&lt;Huawei&gt;system-view -----进入配置模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/242c2f586628a6052a82873345c76e89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ab6cd8a79c4dd198497fb507a7c09a/" rel="bookmark">
			【Anaconda3】常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Anaconda3】常用命令 文章目录 【Anaconda3】常用命令一、anaconda3安装与换源1.anaconda3在不同操作系统下安装2.数据源管理显示目前conda的数据源添加数据源删除数据源修改数据源 3.升级Anaconda 二、conda常用命令1.虚拟环境管理常用命令创建新的虚拟环境删除虚拟环境复制/重命名虚拟环境激活指定虚拟环境退出当前虚拟环境显示所有的虚拟环境开启/关闭自动激活base虚拟环境 2.文件包管理常用命令查看当前虚拟环境下已安装文件包查看指定虚拟环境下已安装文件包查看指定文件包各个版本安装文件包更新文件包卸载文件包清理没用包 一、anaconda3安装与换源 1.anaconda3在不同操作系统下安装 参考ubuntu18.04环境下安装anaconda红框部分
Windows10环境下安装anaconda
2.数据源管理 显示目前conda的数据源 conda config --show-source # 查看所有信息 conda config --show # 具体查看某个部分信息 conda config --show channels conda config --show custom_channels conda config --show default_channels conda config --show show_channel_urls 添加数据源 # 添加清华anaconda镜像 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ 删除数据源 # 添加清华anaconda镜像 conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ 修改数据源 解决"conda install"下载速度慢问题:
# 首先生成这个配置文件(第一次使用) conda config # 修改~/.condarc文件 sudo gedit ~/.condarc # 清除索引缓存,保证用的是镜像站提供的索引 conda clean -i # 查看conda设置 conda config --show-source 配置文件详解参考
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1ab6cd8a79c4dd198497fb507a7c09a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8c708e98cefed1adc1f01391ba9c93/" rel="bookmark">
			C语言--函数指针的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义：函数指针，顾名思义就是指向函数的指针。
使用场合：
1. 需要在同一个函数接口使用不同函数。如，对不同驱动初始化函数的切换。
2. 注册回调函数，由用户定义函数执行内容，系统自动执行。
...
示例代码：
1. 在结构体中定义及其使用：
/* 代码可直接在VS中运行 */ #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;stdlib.h&gt; typedef struct { int a; int (*func)(int a, int b); //定义函数指针 } ts_t; int add(int a, int b) { return a + b; } int main() { ts_t ts; ts.func = add; //传递add的函数指针 int ret = ts.func(1, 2); //使用 printf("ret = %d \n", ret); system("pause"); return 0; } 运行结果：ret = 3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f8c708e98cefed1adc1f01391ba9c93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc329681e4b7a7e18f9b9dc3144b9c8/" rel="bookmark">
			【网络】SNAT和DNAT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.SNAT和DNAT都是网络地址转换技术，有什么不同？ SNAT是“Source Network Address Translation”的缩写，指的是一种将源IP地址转换为另一个IP地址的技术。在网络通信中，当内部网络的主机向外部网络发送数据包时，数据包的源IP地址会被修改为一个公共IP地址，这样外部网络就无法直接访问内部网络的真实IP地址。SNAT的主要作用是隐藏内部网络的真实IP地址，从而增强网络的安全性。
DNAT是“Destination Network Address Translation”的缩写，指的是一种将目标IP地址转换为另一个IP地址的技术。在网络通信中，当外部网络的主机向内部网络发送数据包时，数据包的目标IP地址会被修改为内部网络的某个主机的IP地址，从而实现数据包的路由。DNAT的主要作用是将外部网络的请求路由到内部网络的某个主机上，从而实现网络服务的访问。
总的来说，SNAT和DNAT都是网络地址转换技术，但它们的作用不同。SNAT主要用于隐藏内部网络的真实IP地址，增强网络的安全性；DNAT主要用于将外部网络的请求路由到内部网络的某个主机上，实现网络服务的访问。
2.SNAT也能解决路由的问题吧？例如源地址为内网ip，通过转换为外部ip，实现对外部资源的访问？ SNAT也可以解决路由的问题。当内部网络的主机需要访问外部网络的资源时，数据包的源IP地址会被修改为一个公共IP地址，这样外部网络就可以将数据包路由回内部网络的主机。通过这种方式，SNAT可以实现内部网络主机对外部资源的访问。
在这种情况下，SNAT的作用类似于一个代理服务器。内部网络的主机将数据包发送到代理服务器，代理服务器将数据包的源IP地址修改为一个公共IP地址，然后将数据包发送到外部网络。外部网络将数据包路由回代理服务器，代理服务器再将数据包的源IP地址修改为内部网络的真实IP地址，最终将数据包发送到内部网络的主机。
需要注意的是，SNAT只能实现单向的路由，即内部网络主机访问外部资源。如果外部网络的主机需要访问内部网络的资源，就需要使用DNAT技术将外部网络的请求路由到内部网络的某个主机上。
3.DNAT也是可以解决访问的问题，作为回包路由转换？ DNAT也可以解决访问的问题。当外部网络的主机需要访问内部网络的资源时，数据包的目标IP地址会被修改为内部网络的某个主机的IP地址，从而实现数据包的路由。通过这种方式，DNAT可以实现外部网络主机对内部资源的访问。
在这种情况下，DNAT的作用类似于一个端口映射。外部网络的主机将数据包发送到DNAT设备，DNAT设备将数据包的目标IP地址修改为内部网络的某个主机的IP地址，然后将数据包发送到内部网络。内部网络将数据包的回复发送到DNAT设备，DNAT设备再将数据包的目标IP地址修改为外部网络的真实IP地址，最终将数据包发送到外部网络的主机。
需要注意的是，DNAT只能实现单向的路由，即外部网络主机访问内部网络资源。如果内部网络的主机需要访问外部网络的资源，就需要使用SNAT技术将数据包的源IP地址修改为一个公共IP地址，从而实现数据包的路由。
4.SNAT和DNAT，仅仅时转化ip的区别吗？ SNAT和DNAT的区别不仅仅是转换IP地址的不同，它们的作用和应用场景也不同。
SNAT是“Source Network Address Translation”的缩写，指的是一种将源IP地址转换为另一个IP地址的技术。在网络通信中，当内部网络的主机向外部网络发送数据包时，数据包的源IP地址会被修改为一个公共IP地址，这样外部网络就无法直接访问内部网络的真实IP地址。SNAT的主要作用是隐藏内部网络的真实IP地址，从而增强网络的安全性。同时，SNAT还可以实现负载均衡功能，将网络流量分配到多个服务器上，提高网络的性能和可靠性。
DNAT是“Destination Network Address Translation”的缩写，指的是一种将目标IP地址转换为另一个IP地址的技术。在网络通信中，当外部网络的主机向内部网络发送数据包时，数据包的目标IP地址会被修改为内部网络的某个主机的IP地址，从而实现数据包的路由。DNAT的主要作用是将外部网络的请求路由到内部网络的某个主机上，从而实现网络服务的访问。同时，DNAT还可以实现端口映射功能，将外部网络的请求映射到内部网络的某个端口上，提高网络的灵活性和可扩展性。
因此，虽然SNAT和DNAT都是网络地址转换技术，但它们的作用和应用场景不同，不能简单地认为它们只是转换IP地址的区别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc07d4f279a624bc9baf08c6edd4249/" rel="bookmark">
			实战讲解及分析Spring新建Bean的几种方式以及创建过程（图&#43;文&#43;源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 缘起 作为一个应用开发人员而言，会使用某一个工具分为两个层次（个人观点）：
第一个层次，知道工具，会使用这个工具解决问题；
第二个层次，理解工具的实现原理。
关于Spring的学习，还在第一个层次转悠，缺少原理的研究，
随着学习的深入，开始研究些Spring源码，配合IDEA调试，
逐渐理解一些Spring原理，先从创建Bean开始，
分享如下。
2 新建Bean 对于Spring学习、使用和研究人员而言，
Bean必修课，Bean从何而来，又如何获取，
弄清楚这些，会加深对Spring的理解。
首先从创建Bean开始，常见的创建方式有3种：
注解@Bean方式XML方式BeanDefinitionBuilder方式 通过XML实现的Bean注入有多种方式：构造方法注入、set方法注入、静态工厂注入和实例工厂注入
Spring提供了多种方式创建Bean，这里的创建Bean是创建自定义的Bean，
不涉及Spring启动时需要创建的系统Bean，
但是殊途同归，最终都是通过BeanDefinition构建Bean，
创建自定义的Bean会经历两个核心步骤：
注册BeanDefinition
填充beanDefinitionMap和beanDefiinitionNames，为填充singletonObjects准备创建单例Bean
填充singletonObjects，供后续获取Bean使用 2.1 @Bean方式 通过@Bean方式创建自定义Bean是最明显的方式，
直接在对应的方法上添加@Bean注解，表明这是Bean，
结合@Configuration，Spring会自动创建Bean，
测试样例及注释如下：
package com.monkey.springboottemplate.modules.bean_definition; import com.monkey.springboottemplate.common.entity.UserEntity; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * 注解新建Bean. * * @author xindaqi * @since 2022-12-14 16:01 */ @Configuration public class BeanDefinitionByAnnotation { private static final Logger logger = LoggerFactory.getLogger(BeanDefinitionByAnnotation.class); @Bean public UserEntity myUserBean() { return new UserEntity("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bc07d4f279a624bc9baf08c6edd4249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c48a9a18b200dc731031fe379685c0e/" rel="bookmark">
			Node.js -- JavaScript的运行环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一初识Node.js 1.前端三剑客 HTML ： 骨架
CSS ：外观
JS ： 灵魂
2.浏览器中JavaScript的组成部分 JavaScript可以在浏览器中被执行的原因是浏览器里面都有一个JavaScript的解析引擎
浏览器解析引擎ChromeV8FirefoxOdinMonkey (奥丁猴)SafriJSCoreIEChakra（查克拉） 3.为什么JavaScript可以操作DOM和BOM 每个浏览器都内置了DOM、BOM这样的API函数。
4.浏览器中的JavaScript的运行环境 V8引擎负责解析和执行JavaScript代码内置API是由运行环境提供的特殊接口，只能在所属的运行环境中被调用 5.JavaScript能否做后端开发 可以做，需要运行在Node.js
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93d546d56d095f2a40460acd2336e08/" rel="bookmark">
			Python学习笔记-3(运算分类)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023.4.7
努力学习python，想为以后可以有一份额外收入，如果有大神可以指点一下，我将不胜感激
如果有大神想以后拥有一个合作伙伴进行交流，我会尽力赶上您的脚步！
算术运算 算术运算分类:在我们的学习中，一般认为是1 + 1 = 2 将左边的值赋值给右边，但在计算机运算中，一般为2 = 1 + 1，将右边的值赋值给左边
+号加法运算是有特殊情况的，如果两方都为整型，则按照正常情况相加，如果两方都为字符串类型，+号则为连接符，且双方不可以是一个为整型一个为字符串，举例为a = 'a' b = 'b' c = a+b，输出结果为ab ，在这里需要了解连接符和加法运算的用法
以下为算术运算的举例
a = 1 b = 2 c = a + b #加法运算 print(c) #运算结果为 3 c = b - a #减法运算 print(c) #运算结果为1 c = a * b #乘法运算 print(c) #运算结果为2 c = b / a #除法运算 2/1 print(c) #运算结果为2 a = 9 b = 2 sum = a % b #取余运算 print(sum) #结果为1 因为9除以2余1 sum = a // b #取商运算 print(sum) #结果为4，取商运算就是取整，9除以2等于4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f93d546d56d095f2a40460acd2336e08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d25612c68b9b4204e970ae5f30c72c/" rel="bookmark">
			wireshark网络安全流量分析基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01.介绍 网络安全流量分析领域中，wireshark和csnas是取证、安全分析的好工具，包括很多研究安全规则、APT及木马流量特征的小伙伴，也会常用到两个工具。这两款流量嗅探、分析软件，今天先介绍wireshark作为安全分析工具的基本使用。
02.基本使用 Wireshark对pcap包分析过程中常用的功能基本上包括：数据包筛选、数据包搜索、流还原、流量提取等。本次的演示找到了CTF相关pcap包，如感兴趣可自己下载分析：
链接：https://pan.baidu.com/s/1UlmTrXG-botu0M3c4W-lfA 提取码：k0y4 2.1 数据包筛选
海量数据中要想能察觉到可疑通信，找到攻击的蛛丝马迹，那就需要对一些端口、协议、请求方式和攻击特征等进行过滤，不断缩小可疑流量范围，才能更好进一步分析达到最终溯源的目的。
2.1.1 筛选IP
※流量过滤中可以使用过滤可疑IP或排除一些无用信息，减少无关流量包的干扰，更直接定位目标。
&gt;筛选特定IP，过滤出所有与192.168.94.233相关的流量
语法：ip.addr==192.168.94.233
&gt;筛选源IP，过滤出所有源ip都为192.168.94.233
语法：ip.src==192.168.94.233
同样过滤目的IP语法：ip.dst==192.168.94.233
且关系使用&amp;&amp;：ip.dst==192.168.94.233&amp;&amp; ip.dst==192.168.32.189
或关系使用||：ip.dst==192.168.94.233||ip.dst==192.168.32.189
非关系：!=
2.1.2HTTP模式过滤
※在web攻击流量分析中，http显得尤为重要，根据攻击特点过滤http流量能更准确定位攻击；如常见上传webshell使用POST请求、指定URI可疑发现一些上传路径或者后台等，另也可以从包含的一些关键特征判断使用的工具、木马、脚本等。
http请求方式为GET语法：http.request.method==”GET”
http请求方式为POST语法：http.request.method==”POST”
请求的URI为/login.php语法：http.request.uri==”/login.php”
请求的http中包含sqlmap的语法：http contains “sqlmap”
请求方式为GET且请求中包含UA信息：http.request.method==”GET” &amp;&amp; http contain “User-Agent”
2.1.3 mac地址筛选:
※这部分过滤和IP过滤作用一样
eth.dst ==A0:00:00:04:C5:84 筛选目标mac地址
eth.addr==A0:00:00:04:C5:84 筛选MAC地址
2.1.4 端口筛选：
※通过常见端口如445、1433、3306等可以定位相关特殊的服务。
tcp.dstport == 80 筛选tcp协议的目标端口为80 的流量包
tcp.srcport == 80 筛选tcp协议的源端口为80 的流量包
udp.srcport == 80 筛选udp协议的源端口为80 的流量包
2.1.5 协议筛选：
※协议过滤可以根据相关服务使用的协议类型进行
tcp 筛选协议为tcp的流量包
udp 筛选协议为udp的流量包
arp/icmp/http/ftp/dns/ip 筛选协议为arp/icmp/http/ftp/dns/ip的流量包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d25612c68b9b4204e970ae5f30c72c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a73c08656ae4a40f5aab65ae7b3438dc/" rel="bookmark">
			JAVA根据模板生成WORD文件并导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA根据模板生成WORD并导出 实现功能一 : WORD导出效果二 : 编写WORD模板三 : 引入所需maven依赖四 : JAVA代码工具类五 : 配置信息说明六 : 在固定位置插入表格6.1 : 情况说明6.2 : 编码实现6.3 : 导出效果 七 : 可能出现的问题八 : 相关链接 实现功能 根据模板生成WORD文件,模板文件参数可配. 一 : WORD导出效果 先看一下导出的demo文件,具体参数可手动修改
下图为word_demo.docx导出的WORD文件
下图为word_list.docx导出的WORD文件
二 : 编写WORD模板 WORD文件模板,新建WORD文件,将所需参数用特殊符号 ${} 配置,如下图. demo模板(数据替换模板中的配置参数) : word_demo.docx
demo模板(导出数据列表,数据表格在文件下方自动拼接) : word_list.docx
三 : 引入所需maven依赖 项目采用springboot框架
&lt;!--WORD导出POM--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;3.8&lt;/version&gt; &lt;/dependency&gt; 四 : JAVA代码工具类 WORD导出接口类 WordController.java
package com.chang.word; import org.springframework.stereotype.Controller; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a73c08656ae4a40f5aab65ae7b3438dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b361f55d90a638ce307f5f9c62a6f8d/" rel="bookmark">
			JAVA根据模板生成PDF文件并导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA根据模板生成并导出PDF 实现功能 根据模板生成PDF文件,模板文件参数可配,可手动修改. 一 : PDF导出效果 先看一下导出的demo文件,具体样式可手动修改
下图为demo_pdf.ftl导出PDF文件
下图为list_pdf.ftl导出PDF文件
二 : 编写PDF模板 PDF文件模板,使用原生HTML文件编写,编写完成样式等参数,将文件后缀名修改为 .ftl 模板文件配置 demo模板(数据替换模板中的配置参数) : demo_pdf.ftl
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"/&gt; &lt;style type="text/css"&gt; body {font-family: SimSun;} .mybody h1 {font-size: 24px;text-align: center;line-height: 30px;padding: 20px 0;padding-top: 30px;} .content_class p {display: block;margin-block-start: 1em;margin-block-end: 1em;margin-inline-start: 0px;margin-inline-end: 0px;} .content_class{box-shadow:none;line-height:30px;margin:15px auto;height: auto !important;padding: 30px 75px 100px 75px !important;} .t_tail{ position:relative;text-align:right;} .Gzimg{ position:absolute;left: 400px;top:-35px;width: 140px;height: 140px;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b361f55d90a638ce307f5f9c62a6f8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69de67501c2482631a311d0a43a3d4ca/" rel="bookmark">
			java定时调度任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java常用定时调度任务方式：
1. Timer
2.scheduleThreadPool
3.spring task
4.quartz
5.xxl-job
6. date.calendar.localdatetime
1.Timer 使用方式：
public class Test { public static void main(String[] args) { Timer time=new Timer(); TimerTask task=new TimerTask() { @Override public void run() { System.out.println("start!!!!!"); } }; //延迟一秒执行 time.schedule(task,1000); //立刻执行 // time.schedule(task,System.currentTimeMillis()); // //延迟一秒执行，每一秒重复执行 // time.schedule(task,1000,1000); //立刻执行 // time.schedule(task,System.currentTimeMillis(),1000); // time.scheduleAtFixedRate(task,1000,1000); // time.scheduleAtFixedRate(task,System.currentTimeMillis(),1000); } } class timer 由一个queue和 timerthread组成，time里面包含内部类threadreaper用于当time对象没有应用或者队列为空时的退出；而time的声明方式只要是名称+是否是守护进程
守护线程与非守护线程：
jvm中规定但不存在非守护进程时jvm就会退出；
也就是有非守护线程时，程序不会退出；而守护线程会随主程序一起退出；
thread.setDeamon(true)设置为守护；默认非守护 Taskqueue:
初始128大小的数组，扩容每次扩建2倍
本质是一个最小堆，按照执行时间排序，重排序从根往下（任务重复执行），插入从下往上（插入新任务）；
private void fixDown(int k) { int j; while ((j = k &lt;&lt; 1) &lt;= size &amp;&amp; j &gt; 0) { if (j &lt; size &amp;&amp; queue[j].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69de67501c2482631a311d0a43a3d4ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a5d61652f7fc2efe16927f61bc029dc/" rel="bookmark">
			vue根据URL链接生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载
npm install qrcode --save-dev
2.引入（在所需要的页面中引入）
import QRCode from “qrcode”; //引入生成二维码插件
3.生成二维码
&lt;img :src="QRImgUrl" /&gt;
&lt;script&gt;
import QRCode from "qrcode";
export default {
name: "phone",
data() {
return {
QRImgUrl: "",
QRlink: "https://152.136.245.230:7784/play/index.html?uid=1&amp;zid=1&amp;roomid=53",
};
},
mounted() {},
created() {
this.getQRcode();
},
methods: {
getQRcode() {
let opts = {
errorCorrectionLevel: "L", //容错级别
type: "image/png", //生成的二维码类型
quality: 0.3, //二维码质量
margin: 4, //二维码留白边距
width: 256, //宽
height: 256, //高
text: "", //二维码内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a5d61652f7fc2efe16927f61bc029dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534b525a062045d541063c342ef70dc8/" rel="bookmark">
			Python学习笔记-1(格式化输出)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023.4.6日 坚持自学第一天
努力学习python，想为以后可以有一份额外收入，如果有大神可以指点一下，我将不胜感激
如果有大神想以后拥有一个合作伙伴进行交流，我会尽力赶上您的脚步！
格式化输出，格式化输出的类型暂时有两种(目前已学) 第一种类型为占位符，第二种format
占位的类型分为多种，较为常用的为%s,%d,%f，而format是字符串中的函数，输出字符串
占位符: %s 的占位输出类型为字符串类型，可以使用于英文，汉字，符号等类型
%d 的占位输出类型为整型，可以使用于整数数字，如果转换非整型的数字，将直接 取整(不会进行四舍五入)
%f 的占位输出类型为浮点型，他适用于所有小数数字，%d无法四舍五入，但%f解 决了该问题，默认取小数点后六位。 如果我只想取小数点后1位如何做？ 在占位符 的f前，添加一个.1即可，例如 %.1f 取后二位 %.2f 他只会取后二位，并且四舍五 入添加上去
占位符实战操练！
题目：变量: name = '小明' age = 18 money = 18.88
要求使用占位符 %s %d %f 并且写出两种方法 其余print文字自行想象添加
解答1：
name = '小明' age = 18 money = 18.88 print('我的名字是%s \n我的年龄是%d \n我有%.2f零花钱' %(name,age,money)) 解答2:
name = '小明' age = 18 money = 18.88 message = ''' 我的名字是 : %s 我的年龄是 : %d 我有%.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/534b525a062045d541063c342ef70dc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b65b80381ccf958a3ee211b94217b6/" rel="bookmark">
			不登录mysql，查看sql执行结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FILE=a.txt DATABASE=test PD=123456 echo "" &gt; $FILE RKYHL="select count(*) from t_profile" JMCC="select count(*) from t_profile where status=2" 60SWJM="select count(*) from t_profile where speech_len&gt;60 and status&lt;2 " echo "数 量: `mysql -u root -P 3307 -p$PD -D $DATABASE -e "$RKYHL"` " &gt;&gt; $FILE echo "建模成功: `mysql -u root -P 3307 -p$PD -D $DATABASE -e "$JMCC"` " &gt;&gt; $FILE echo "60s未建模: `mysql -u root -P 3307 -p$PD -D $DATABASE -e "$JMCC"` "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8b65b80381ccf958a3ee211b94217b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50fc130d65e3e16ca25f23e8dc68ba62/" rel="bookmark">
			Video.js的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Video.js是一款优秀的HTML5视频播放器库，与另一个主流的视频播放器库Shaka Player相比，它在PC端更加流行，也更适用于高度定制化的场景。不过Shaka Player更适合移动端和低带宽场景，小伙伴们在选择库的时候可以根据自己的场景。这里分享一些Video.js使用的经验。
背景：Nuxt 3.3.3，video.js@8.0.4
入门 安装
npm i video.js 写一个公共组件
&lt;template&gt; &lt;video ref="videoPlayer" class="video-js" :id="playerId"&gt;&lt;/video&gt; &lt;/template&gt; &lt;script setup&gt; import videojs from 'video.js'; import { getCurrentInstance, } from 'vue'; const { proxy } = getCurrentInstance(); const props = defineProps({ sources: { type: Array, default () { return []; } }, autoplay: { type: [Boolean, String], default: true, }, playerId: { type: String, required: true, // 必须提供id }, muted: { type: Boolean, default: false, } }) let videoOptions = { 'autoplay': props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50fc130d65e3e16ca25f23e8dc68ba62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b72660a1bee5da5ce62c398c9f056a8b/" rel="bookmark">
			详解正则表达式匹配方法 match()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端开发中，正则表达式是一大利器。所以我们这次就来讨论下match()方法。
match本身是JavaScript语言中字符串对象的一个方法，该方法的签名是
match([string] | [RegExp])
它的参数既可以是一个字符串，也可以是一个正则表达式。该方法绝大多数都是要使用正则表达式的，所以参数为string的情况不在本文讨论范围之内。其实参数即使是一个简单的string，其返回值也跟使用正则表达式的结果无异，而且使用正则表达式的变化比较多，用法复杂，所以我们只讨论正则的用法。
一、返回值问题。
我们必须明确的是，这个方法跟其他语言是不同的。JavaScript中的match()方法的返回值是数组或者是null。如果原字符串中匹配到了正则表达式指代的子串，则返回一个数组，否则返回null。
二、不使用全局匹配　var str = 'Today is the 186th day of 2018,I must finish these 2 projects within 21 days.'; var results = str.match(/\d+/); //只能匹配字符串中出现的首个数字，未使用全局匹配符g console.log(results); 输出的结果是：
再强调一次，这个例子的结果是没有使用全局匹配的正则表达式的匹配结果。说白了，就是正则表达式的末尾没跟g。由于不适用全局匹配，所以match()方法只找到源字符串中首次匹配的子串后，就立刻得到返回结果，不再比较之后剩余的部分是否还有能匹配上的内容。　我们可以看到，match()的结果是一个数组，该数组一共有4项。各项代表的意思如下：
第0项：匹配到字符串
第1项：groups：undefined，这表示当前的正则表达式没使用分组
第2项：index表示首次匹配上的子串的起始下标。
第3项：input，表示源字符串
第4项：length，表示匹配到的结果个数，由于这里不使用全局匹配，只找到首次匹配项就结束了，所以匹配结果只有1个，length也就是1。
再次强调下，如果在正则表达式末尾不使用全局匹配符g，在本例中是无法匹配到所有的数字。反过来说就是，如果想匹配所有的符合条件的子串，就必须在正则的末尾添加全局匹配符g
age: "{{integer(20, 40)}}", reginteger = /{{integer\((\d+),\s*(\d+)\)}}/ matchs = age.match(reginteger); console.log(matchs) 三、使用全局匹配　var str = 'Today is the 186th day of 2018,I must finish these 2 projects within 21 days.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b72660a1bee5da5ce62c398c9f056a8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89947a2983ee2a0f83ff3a0f87079936/" rel="bookmark">
			[STL]priority_queue多种方式自定义排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 在做leetcode题目时很多题都需要使用优先队列（堆），并需要使用自定义数据类型、自定义有限队列的排序方式。本文对priority_queue的自定义排序方式做了总结。本文可能并不能覆盖所有自定义方式，若读者有建议或本文存在纰漏，请在本文下留言，不胜感激。
二、priority_queue概述 Priority queues are a type of container adaptors, specifically designed such that its first element is always the greatest of the elements it contains, according to some strict weak ordering criterion.
优先队列是一类容器适配器，该容器满足：按照某种严格弱序排列，该容器的第一个元素总是所有元素中最大（最小）的。
priority_queue 的模板参数:
template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue; T：元素类型。
Container：低层存储容器类型，默认为vector&lt; T &gt;类型。
Compare：两个参数且返回值为bool类型的双参判断式，默认为less&lt; T &gt;判断式。
三、priority_queue自定数据类型和自定义排序方式 假设使用priority_queue存储自定义类型Node，Node数据结构如下：
struct Node{ int size; int price; } 不同的自定义排序方式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89947a2983ee2a0f83ff3a0f87079936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/decd509e472add4586d2668d9bd9cff9/" rel="bookmark">
			springboot&#43;vue&#43;elementsUI 实现分角色注册登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目简介
一共分为三个角色：管理员、用户、设计师
登录功能：账号+密码+身份选择，登录成功后跳转到各身份对应的页面
注册功能：只允许用户和设计师注册，用户可以直接注册成功，设计师提交材料后注册需要管理员审核成功后方可注册成功。
注册页面要求必填：
账号：用户自定义，注册成功后不可修改，同一个角色下账号不重复，不同角色账号可以重复。
二、注册
1.前端
先上目录文件：
（1）register.vue文件
template部分：
&lt;template&gt; &lt;div class="register-container"&gt; &lt;!-- 根标签 --&gt; &lt;el-form :model="form" status-icon :rules="rules" ref="form" label-width="100px" class="register-form"&gt; &lt;h1 class="title"&gt;注 册&lt;/h1&gt; &lt;el-form-item label="账号" prop="useraccount"&gt; &lt;el-input v-model="form.useraccount" placeholder="账号作为登陆的唯一方式，一旦注册成功不可更改！" maxlength="20"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="密码" prop="userpsd"&gt; &lt;el-input type="password" v-model="form.userpsd" placeholder="请输入密码" autocomplete="off" maxlength="16" &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="确认密码" prop="checkPass"&gt; &lt;el-input type="password" v-model="form.checkPass" placeholder="请再次输入密码" autocomplete="off" maxlength="16" &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="姓名" prop="username"&gt; &lt;el-input v-model="form.username" maxlength="20"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="性别" prop="sex" style="text-align:left"&gt; &lt;el-radio-group v-model="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/decd509e472add4586d2668d9bd9cff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b94eb55f220e48dfef53292a5315e289/" rel="bookmark">
			在VMware中安装ArchLinux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VMware中安装ArchLinux 1、安装VMware 2、下载ArchLinux镜像文件 前往https://www.archlinux.org/download/下载自己需要的版本的镜像文件，建议下载最新版。
3、新建虚拟机 这一步没有太多坑，下面是简要步骤：
新建虚拟机 --&gt; 版本选择为其他Linux 5.x 64位 --&gt; 硬盘大小根据实际情况给定，我这里给的是50G --&gt; 其他配置根据自己的情况设置即可 --&gt; 点击“编辑虚拟机的设置” --&gt; 点击“选项” --&gt; 选择点击“高级” --&gt; 在固件类型中选择UEFI并确定 --&gt; 网络设置中选择NAT模式，这样只要主机能上网，虚拟机将自动配置上网 --&gt; 光驱选择下载好的镜像文件 --&gt; 保存设置后开启虚拟机
4、硬盘分区 1）这里给出我的分区方案，仅供参考： 分区名称大小作用后面分区盘标/mnt43G安装系统和软件/dev/sda1/boot1G存储启动信息/dev/sda2/swap6G交换分区/dev/sda3 上面的单个分区是必须的。还可以再添加/home、/efi等分区，但是没有也可以，所以我这里就只分了上面的三个。
2）分区 # 先查看硬盘的初始分区状态 lsblk # 如果/dev/sda没有子分区。就在/dev/sda下分区，/dev/sda是在新建虚拟机的时候创建的虚拟硬盘 # 分区命令 cfdisk /dev/sda # 之后会有提示，根据提示把/dev/sda依次分成43G、1G、6G大小三部分，选择write选项，再选择quit选项退出 # 注意，在退出之前，一定要先选择write选项并回车，确保前面的分区操作生效 # 格式化分区 mkfs.ext4 /dev/sda1 mkfs.vfat -F32 /dev/sda2 mkswap /dev/sda3 # 挂载分区 ## 挂载mnt分区(这里的mnt目录, 就是Arch的根目录) mount /dev/sda1 /mnt ## 创建boot文件夹,挂载boot分区 mkdir /mnt/boot mount /dev/sda2 /mnt/boot ## swap分区无需挂载, 但需要启用 swapon /dev/sda3 # 展示挂载后的四个分区 lsblk 5、修改镜像源文件 # 在修改镜像源文件之前，确保虚拟机有网络，ArchLinux的安装必须要有网络，最好使用有线网 # ping一下百度，检查网络 ping -c 5 www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b94eb55f220e48dfef53292a5315e289/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/67/">«</a>
	<span class="pagination__item pagination__item--current">68/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/69/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>