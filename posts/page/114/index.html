<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7a4d2f135d951f2f1a562fe860f04b/" rel="bookmark">
			vue3的自定义指令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3的自定义指令详解 一、认识自定义指令二、指令的生命周期三、指令的参数和修饰符四、自定义指令练习 一、认识自定义指令 在Vue的模板语法中我们学习过各种各样的指令：v-show、v-for、v-model等等，除了使用这些指令之外，Vue也允许我们来自定义自己的指令 注意：在Vue中，代码的复用和抽象主要还是通过组件通常在某些情况下，你需要对DOM元素进行底层操作，这个时候就会用到自定义指令 自定义指令分为两种
自定义局部指令：组件中通过directives 选项，只能在当前组件中使用自定义全局指令：app的 directive 方法，可以在任意组件中被使用 比如我们来做一个非常简单的案例：当某个元素挂载完成后可以自定获取焦点
实现方式一：如果我们使用默认的实现方式 &lt;template&gt; &lt;div&gt; &lt;input type="text" ref="input" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref, onMounted } from "vue"; export default { setup () { const input = ref(null); onMounted(() =&gt; { input.value.focus(); }) return { input } } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 实现方式二：自定义一个 v-focus 的局部指令 &lt;template&gt; &lt;div&gt; &lt;input type="text" v-focus&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { // 局部指令 directives: { focus: { mounted(el, bindings, vnode, preVnode) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd7a4d2f135d951f2f1a562fe860f04b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475d8a6c45a9c0b1f6b1b85a6b87874a/" rel="bookmark">
			C&#43;&#43;之结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 6 结构体6.1 结构体基本概念6.2 结构体定义与使用6.3 结构体数组6.4 结构体指针6.5 结构体嵌套结构体6.6 结构体做函数参数6.7 结构体中const使用场景6.8 结构体案例16.9 结构体案例2 6 结构体 6.1 结构体基本概念 结构体属于用户自定义的数据类型，允许用户存储不同的数据类型。
6.2 结构体定义与使用 语法：
struct 结构体名{ 结构体成员列表 }; 通过结构体创建变量的方式有三种：
struct 结构体名 变量名struct 结构体名 变量名={成员1值，成员2值…}定义结构体时顺便创建变量 代码示例：
#include &lt;iostream&gt; using namespace std; #include &lt;string&gt; //1、创建学生数据类型（姓名，年龄，分数） struct Stu { string name; int age; double score; }s3; int main() { //2、通过学生类型创建具体学生（三种方式） struct Stu s1;//创建结构体变量，struct可省略 //给s1赋值，通过.访问结构体变量中的属性 s1.name = "张三"; s1.age = 25; s1.score = 87.5; cout &lt;&lt; "姓名：" &lt;&lt; s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/475d8a6c45a9c0b1f6b1b85a6b87874a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720c8d47defbe2f3c9339213193cac56/" rel="bookmark">
			cmake libtorch opencv vs cmakelists
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# CMakeList.txt: CMakeProject1 的 CMake 项目，在此处包括源代码并定义 # 项目特定的逻辑。 # cmake_minimum_required (VERSION 3.8) project ("CMakeProject1") # 将源代码添加到此项目的可执行文件。 set(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH} "D:\\Project\\video-matting\\libtorch") set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${TORCH_CXX_FLAGS}") find_package(Torch REQUIRED) include_directories("D:/Program Files/opencv/build/include") include_directories("D:/Program Files/opencv/build/include/opencv2") link_directories("D:/Program Files/opencv/build/x64/vc15/lib") add_executable (CMakeProject1 "CMakeProject1.cpp" "CMakeProject1.h") target_link_libraries(CMakeProject1 "${TORCH_LIBRARIES}") target_link_libraries(CMakeProject1 opencv_world455d) set_property(TARGET CMakeProject1 PROPERTY CXX_STANDARD 14) # The following code block is suggested to be used on Windows. # According to https://github.com/pytorch/pytorch/issues/25457, # the DLLs need to be copied to avoid memory errors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/720c8d47defbe2f3c9339213193cac56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f189b8b55d445aae5b3b78efda2d87/" rel="bookmark">
			如何提取Excel中部分内容？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、提取Excel中的内容1.函数法2.利用查找替换 二、补0操作 一、提取Excel中的内容 提取Excel中的内容太难？那是因为你不会这2种方法。
如下图所示，如何提取每位客户电话中的手机区号呢？
1.函数法 在单元格中输入公式=LEFT(B2,FIND("-",B2)-1)。
说明：
FIND函数表示返回一个字符串在另一个字符串中出现的起始位置
语法结构=FIND(查找值，查找区域，开始查找的位置)
LEFT函数表示从单元格左侧开始提取指定的内容
语法结构=LEFT(所选单元格，从左算起截取的字符的数量)
利用FIND函数查找“-”在电话号码中的位置，然后利用LEFT函数将其左侧的数字提取出来。
2.利用查找替换 选中区域按Ctrl+H打开查找和替换对话框，在查找中输入代码：-*，在替换为中不输入任何内容，点击全部替换即可。
二、补0操作 这时你会发现以0开头的区域会消失了，那要如何批量添加呢？
新建一个辅助列，之后在单元格中输入公式=0&amp;C2。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/843ce680cc74510f7efd40501fbd95d7/" rel="bookmark">
			echarts柱状图优化（柱状图渐变色实现的两种方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现方式一：
option = { xAxis: { type: 'category', data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [ { data: [120, 200, 150, 80, 70, 110, 130], type: 'bar', color: new echarts.graphic.LinearGradient(0, 1, 0, 0, [ { offset: 0, color: '#11d56d' }, { offset: 1, color: '#83bff6' } ]) } ] }; 实现方式二：
option = { xAxis: { type: 'category', data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [ { data: [120, 200, 150, 80, 70, 110, 130], type: 'bar', color: { type: 'linear', x: 0, //右 y: 0, //下 x2: 0, //左 y2: 1, //上 colorStops: [ { offset: 0, color: '#11d56d' // 0% 处的颜色 }, { offset: 1, color: '#83bff6' // 100% 处的颜色 } ] } } ] }; 两种方式实现的效果是一样的，效果图如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc5734c6aba02ffeba69546caa47660/" rel="bookmark">
			报错：安装vuex报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 报错分析原因解决办法 报错 vuex安装失败npm ERR! code ERESOLVE npm ERR! ERESOLVE unable to resolve dependency ...... 分析原因 安装的包与已经存在的包有冲突
解决办法 npm install xxx -- force 或者
npm install xxx --legacy-peer-deps 两个办法中如果第一个没好，第二个好了，
原因可能是： --legacy-peer-deps标志是在v7中引入的，目的是绕过peerDependency自动安装；它告诉 NPM 忽略项目中引入的各个modules之间的相同modules但不同版本的问题并继续安装，保证各个引入的依赖之间对自身所使用的不同版本modules共存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be5d5dcf2d99de3312986710a1c2e6f/" rel="bookmark">
			intellij idea关闭代码检查提高性能解决卡顿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		intellij idea是我们常用的java ide编辑器，虽然好用，但是确实不少，占据电脑性能也不少，我们有时需要进行一些优化提高使用速度，可以避免一些卡顿的问题
工具/原料 intellij idea电脑 方法/步骤 如果电脑上还没有安装intellij idea软件，我们需要先使用浏览器百度搜索下intellij idea进入到官网下载软件
安装好后，我们可以从启动界面处进入到项目开发界面，intellij idea的软件界面中选择功能栏的file
然后在file弹出来的子菜单中选择settings设置项，intellij idea的软件详细设置内容可以在里面进行设置
进入到设置界面后，有许多的设置内容，我们点击左侧的editor项，然后在其子菜单中选择Inspections项
进入到Inspections项后，我们可以看到右侧有很多检查项，我们只需要保留我们常用需要的语言的检查项就可以了，其他的去掉，这样就会减少很多资源消耗
设置好以后，我们点击设置界面的右下角的apply生效保存我们之前的设置，然后点击确定退出设置，就完成设置了
转载：intellij idea关闭代码检查提高性能解决卡顿-百度经验
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e18aa577cf6d6449f2611de6183c0fcb/" rel="bookmark">
			图机器学习（Graph Machine Learning）- 第三章 无监督图学习3 （Unsupervised Graph Learning）- 图神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章 无监督图学习3 - 图神经网络 Graph neural networks 文章目录 第三章 无监督图学习3 - 图神经网络 Graph neural networks前言3.4 图神经网络 Graph neural networks3.4.1 GNNs的其他形式3.4.2 谱卷积 Spectral graph convolution 3.4.3 空间图卷积 Spectral graph convolution3.4.4 图卷积实战 总结 前言 Graph neural network，GNN 是处理图形结构数据的深度学习方法。这类方法也被称为几何深度学习 geometric deep learning ，并在各种应用中引起了广泛的兴趣，包括社会网络分析和计算机图形学。
根据第二章图机器学习中定义的分类，编码器部分以图结构和节点特征作为输入。这些算法可以在有或没有监督的情况下进行训练。在本章中，我们将专注于无监督训练，而监督设置将在第四章，监督图学习中探讨。
3.4 图神经网络 Graph neural networks 如果您熟悉卷积神经网络(CNN)的概念，您可能已经知道它们能够在处理常规欧几里德空间(如文本(一维)、图像(二维)和视频(三维))时获得令人印象深刻的结果。经典的CNN由层序列组成，每一层提取多尺度的局部空间特征。这些特征被更深层的层利用来构造更复杂和高度表达的表示。
近年来，人们发现诸如多层和局部性等概念对于处理图结构数据也很有用。然而，图是在一个非欧几里德空间上定义的，要为图找到一个CNN的泛化并不简单，如图3.20所示:
GNN的最初的构想是由Scarselli等人在2009年提出的。它依赖于一个事实，即每个节点都可以用它的特征和它的邻域来描述。来自邻域(表示图域中的局部性概念)的信息可以聚合并用于计算更复杂和高级的特征。让我们更详细地了解它是如何实现的。
一开始，每个节点 v i v_i vi​都与一个状态相关联。让我们从一个随机嵌入 h i t ℎ_i^t hit​开始(为了简单起见，忽略节点属性)。在算法的每次迭代中，节点使用一个简单的神经网络层积累来自其邻居的输入:
h i t = ∑ v j ∈ N ( v i ) σ ( W h j t − 1 + b ) h_i^t = \sum_{v_j \in N(v_i)} \sigma(Wh_j^{t-1}+b) hit​=vj​∈N(vi​)∑​σ(Whjt−1​+b)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e18aa577cf6d6449f2611de6183c0fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c18445bbc0a72e6ff5dbd3c335823ed/" rel="bookmark">
			win10添加开机自启软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、win+r打开终端，输入“shell:startup”即可进入开机启动文件夹
2、把要开机自启的软件的快捷方式，放到这个文件夹下面就可以了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b85c4dc48149fdf9e09208b240f388b/" rel="bookmark">
			从零到一快速开发一套前端质量/错误监控系统，webpack打包时sourceMap收集及上传到后台，后台nodejs&#43;express反向解析线上报错代码，定位到源码中报错的位置然后给出提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 1.前端质量/报错监控系统整体思路实现逻辑
2.开发一个webpack plugin插件收集使用者的sourcemap到云端
3.使用者初始化报错系统的sdk，然后运行，报错时收集错误上报云端
4.云端根据收集到的报错信息及之前拿到的sourcemap进行解析，确认报错位置
下面是一个比较完整的流程图，我demo项目中还没有这么完善，但是有了一个整体的构架，主要目的是用于学习
代码仓库：https://github.com/adminadmin1234/deep-study-webpack/tree/master/plugin-uploadSourceMap
学习收获：
1.webpack的打包知识及plugin的开发
2.能学到nodejs+express相关的知识
3.整体理解错误监控系统的理论，及部分实战
4.项目简单易上手，但是包含的知识点很多，利用我提供的demo巩固实践操作，巩固理论
开发环境
1.window||mac
2.nodejs v14.17.6
安装依赖
npm install
运行项目
1.运行服务端：
// 在plugin-uploadSourceMap\serve目录下
node .\index.js
打印：服务器运行在3030
2.收集项目sourceMap
// 在根目录
npm run build
打印：source map 上传完成
3.开启服务运行线上项目
// 在根目录
npm run dev
然后在浏览器打开：http://localhost:8080/
再看看第一步运行的服务端会有错误打印：
回到源码看看是不是真的
确实没有错，麻雀虽小，五脏俱全！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac85f4eaeea276e3fa7e9a60467d979/" rel="bookmark">
			文件上传2-搭建uploads靶场
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载中间件和数据库，可以使用集成工具，phpstudy，wamp，linux系统可以使用docker,接下来我会使用phpstudy搭建靶场
进入\phpstudy\phpstudy_pro\WWW 目录下，将下载的uploads靶场文件解压后放在该目录下
启动apache与mysql
在网页中访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ff66b9e9c07960d41bfe68b0911204/" rel="bookmark">
			java中正则表达式替换字符串中的中括号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //替换成空字符串 String ss = "[a12,da,das]"; String replaceAll = ss.replaceAll("[\\[\\]]",""); System.out.println(replaceAll);// a12,da,das //替换小括号同样原理 String ss = "(a12,da,das)"; String replaceAll = ss.replaceAll("[\\(\\)]",""); System.out.println(replaceAll);// a12,da,das 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e732a389d4a4bcc9cb267706ff2c6234/" rel="bookmark">
			volatile关键字详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		volatile关键字 1.volatile简介：2.三大特性1&gt;.保证可见性：代码验证： 2&gt;.保证有序性(禁止指令重排序)有序性的实现原理： 3&gt;.不保证原子性：解决方式： 1.volatile简介： volatile 是 JVM 提供的轻量级的同步机制。volatile 关键字可以保证并发编程三大特征（原子性、可见性、有序性）中的可见性和有序性，不能保证原子性。
2.三大特性 1&gt;.保证可见性： 加了volatile关键字修饰的变量，只要有一个线程将主内存中的变量值做了修改，其他线程都将马上收到通知，立即获得最新值。当写线程写一个volatile变量时，JMM会把该线程对应的本地工作内存中的共享变量值刷新到主内存。当读线程读一个volatile变量时，JMM会把该线程对应的本地工作内存置为无效，线程将到主内存中重新读取共享变量。
volatile语义实现原理：
先来看两个与CPU相关的专业术语：
内存屏障（memory barriers）：一组处理器指令，用于实现对内存操作的顺序限制。缓存行（cache line）：CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行。 volatile可见性的实现是借助了CPU的lock指令，lock指令在多核处理器下，可以将当前处理器的缓存行的数据写回到系统内存，同时使其他CPU里缓存了该内存地址的数据置为无效。通过在写volatile的机器指令前加上lock前缀，使写volatile具有以下两个原则：
写volatile时处理器会将缓存写回到主内存。一个处理器的缓存写回到内存，会导致其他处理器的缓存失效。 代码验证： 例如:
int number = 0；此时number变量是没有可见性的。
volatile int number = 0；前面添加了volatile关键字之后，可以解决可见性问题。
没加volatile关键字之前：
/** * 普通类： * 为了验证volatile的可见性 */ public class Test1 { int number = 0; public void add(){ this.number = 10; } public static void main(String[] args) { Test1 test1 = new Test1(); //创建第一个线程 new Thread(() -&gt; { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e732a389d4a4bcc9cb267706ff2c6234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cfc470a80a90d4986f4bf2c0e572c63/" rel="bookmark">
			【前端 | React 】React Hook 中 useState 异步回调获取不到最新值及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预先了解 setState 的两种传参方式 1、直接传入新值 setState(options); 列如：
const [state, setState] = useState(0); setState(state + 1); 2、传入回调函数 setState(callBack); 例如：
const [state, setState] = useState(0); setState((prevState) =&gt; prevState + 1); // prevState 是改变之前的 state 值，return 返回的值会作为新状态覆盖 state 值 useState 异步回调获取不到最新值及解决方案 通常情况下 setState 直接使用上述第一种方式传参即可，但在一些特殊情况下第一种方式会出现异常；
例如希望在异步回调或闭包中获取最新状态并设置状态，此时第一种方式获取的状态不是实时的，React 官方文档提到：组件内部的任何函数，包括事件处理函数和 Effect，都是从它被创建的那次渲染中被「看到」的，所以引用的值任然是旧的，最后导致 setState 出现异常：
import React, { useState, useEffect } from 'react'; const App = () =&gt; { const [arr, setArr] = useState([0]); useEffect(() =&gt; { console.log(arr); }, [arr]); const handleClick = () =&gt; { Promise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cfc470a80a90d4986f4bf2c0e572c63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a929f8bcc7cdfe6cd07b85bc03cdd9c/" rel="bookmark">
			【Linux】排查进程、挖矿病毒查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排查某进程占用CPU较高 一、常用指令二、排查记录2.1 问题2.2 排查`xmrig`进程2.2.1 查看进程信息2.2.2 查看定时启动任务2.2.3 查看自启动服务2.2.4 解决 2.3 排查`-bash`进程2.3.1查看期父子进程以及命令2.3.2 排查2.3.2 解决 2.4 排查`zed`进程2.5 安装杀毒软件排查 一、常用指令 top 发现
sudo pstree -asp pid
sudo netstat -anp | grep pid
sudo lsof -p pid 查看用了哪些文件
which zed
ls -lh /usr/sbin/zed 查得文件较大，有问题
sudo crontab -l 查看root的定时任务
systemctl status zed.service
sudo systemctl stop zed.service
sudo systemctl disable zed.service
二、排查记录 2.1 问题 实验室中有两台服务器，top指令发现有进程占用极高CPU，使用了20个核心，占用高达50%，使用kill指令停止进程后又会重新启动，两台服务器启动的进程不一样，一个是名为xmrig（挖矿程序），一个名为-bash，接下来分分别记录这两台服务器的两个进程来解决
2.2 排查xmrig进程 2.2.1 查看进程信息 top指令查看占用
ps -aux |grep pid查看进程信息
pstree -asp pid 查看父子进程及命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a929f8bcc7cdfe6cd07b85bc03cdd9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a74847c8bd97db145f64658f7545f70/" rel="bookmark">
			delphi中pos的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.含义 pos(a,b)函数用法，取出子串a，在父串b中第一次出现的位置。
2.举例 pos（‘A’，‘DDDAD’）,则返回结果是4.
3.应用 nicez在strX字符串中是否存在的判断
if (Pos(‘nice’,strX)&gt;0)then
begin
…
end
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be443e3860c5a9a65bd18824ee44f85/" rel="bookmark">
			JavaScript 每日一题---LeetCode 977. 有序数组的平方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
解题思路：
给定的数组为整数数组，也就是说会存在负数。最简单的方法就是先将每个数的平方 push 到一个新数组中，再 sort 一下。
另一个思路是，既然是非递减排序，那么边界的数的平方一定大于中间的数（不一定是哪边）。所以我们可以首尾双指针遍历数组，比较哪个数的平方较大，最后将较大的数的平方 unshift 到一个新数组中即可。
完整代码：
/** * @param {number[]} nums * @return {number[]} */ var sortedSquares = function(nums) { var ans=[]; var left=0; var right=nums.length-1; while(left&lt;=right){ if(Math.pow(nums[left],2)&gt;=Math.pow(nums[right],2)){ ans.unshift(Math.pow(nums[left],2)); left++; } else{ ans.unshift(Math.pow(nums[right],2)); right--; } } return ans; }; 欢迎指正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c84679625005c90c2375f98e53f6f8c/" rel="bookmark">
			Vue2生命周期详细讲解——周期图示、代码演示变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue生命周期 生命周期1.创建数据代理、数据检测beforeCreate()created（） 2. 挂载beforeMount()mounted() 3. 更新beforeUpdate（）Updated（） 4. 销毁beforeDestroy()destroyed() 5. activated 和 deactivatedactivated（）deactivated（） 6. errorCaptured 完整生命周期图注意事项 生命周期 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子（生命周期回调函数、生命周期函数）的函数，这给了用户在不同阶段添加自己的代码的机会。
生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。
生命周期函数中的this指向是vm 或 组件实例对象。
1.创建数据代理、数据检测 beforeCreate() 在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。
此时还没有进行数据代理，数据监测，所有vm身上并没有_data的属性。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;分析生命周期&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id="root"&gt; &lt;h2&gt;当前的n值是：{{n}}&lt;/h2&gt; &lt;button @click="add"&gt;点我n+1&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script &gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el:'#root', data:{ n:1 }, methods: { add(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c84679625005c90c2375f98e53f6f8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/456a213ec4ab3e379b799fcbd80cbdef/" rel="bookmark">
			Allegro 17.x design outline的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Allegro 17.x design outline的使用 Cadence 绘制板边框Outline与绘制禁止布线区（Route Keepout）Allegro禁布区打过孔或走线消除DRC错误 原文链接：https://blog.csdn.net/shjhuang/article/details/72852702
在cadence allegro 17.2 之前，电路板的外观、内部开窗、开孔等均可以通过Board Outline层定义得到。但是到了17.2之后，在输出Artwork的时候，会提示错误对话框，如下：
提示使用DESIGNED_OUTLINE和CUTOUT层来定义你的电路板外观。
当然，你不理会它这个提示，照样使用Board Outlinel来定义电路板外观也是可以的，毕竟输出Gerber文件后，电路板厂家才不管你的软件是怎么定义的呢。
但是你要面临两个问题（我目前发现的）。
每次输出Gerber文件都会跳出上述对话框，很烦人。
输出3D图形的时候，看不到电路板哦。
解决的办法就是老老实实使用Designe Outline层定义电路板尺寸、内部开窗等。如何使用？
2. 放置电路板外观，及Design Outline，这个和17.2之前的版本不一样，不能使用画线的方式添加Designe Outline，因为画线时在Board Geometry类中并未能找到Design Outline或Cutout子类。只能通过添加shape的方式添加。
3. 与Board Outline不同的是，电路板内开窗不能使用Design Outline，而是使用Cutout来定义，操作方式参考上面第二点。
以上，就是使用Design Outline和Cutout定义电路板外观的操作方式。
最后你需要去掉刚才收到的那个烦人的对话框，做法就是：打开Artwork Control Form将每层的BOARD GEMOETRY/OUTLINE去掉，替换成DESIGN OUTLINE和CUTOUT即可。
Cadence 绘制板边框Outline与绘制禁止布线区（Route Keepout） 原文链接：https://blog.csdn.net/qq_36075612/article/details/111028704
概述
本人使用Cadence 17.4版本，在这做下笔录，绘制板边Outline与绘制禁止布线区（Route Keepout）方法。
一、绘制板边
1）首先在窗口右侧，选择Board Geometry Class(父类)中Outline Subclass（子类）
2）、在工具栏中选择Add-&gt;Rectangle，画矩形边框，当然也可以使用Line，通过下面命令窗口输入坐标点来，绘制板框，还有可以根据结构给出的CAD图.DXF文件来定板型。
在这只要介绍Cadence 自带的画线来绘制板框。
（注：Outline是画任何草图的图层，真正板框层是Design_Outline层，所以要复制到这个层才行。）
注：由于直接使用Add-&gt;Line或者Add 下的绘制工具都是不能绘制成功，Allegro不认它是封闭图形，需要通过用Compose shape把外框做成封闭图形才行。
3）在菜单栏中Shape-&gt;Compose shape
Allegro禁布区打过孔或走线消除DRC错误 原文链接：https://blog.csdn.net/adubyron/article/details/106123046
在一些特殊的地方，我们不允许铺铜，但是可以走线和打孔。这时我们想到的是在Allegro区域中画一个Route Keepout区域，来禁止所有的铜与线走进来。如果我们的线走进来，会报DRC错误。那我们怎么反这个错误消灭呢？
第一种：执行Wavie DRC，把允许错误的DRC隐藏起来。
执行Display 》status可以查看隐藏的DRC个数。
第二种：允许在此区域内打孔走线，但不允许铺铜。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/456a213ec4ab3e379b799fcbd80cbdef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f347cd24c850fbaf9f5ddfcaab111a/" rel="bookmark">
			phpstudy下载安装简明教程（图文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小皮面板官方群：2805531；836334183 很多朋友在学习php的过程中会看到phpstudy这个东西，那么phpstudy是做什么的呢？有什么用？接下来的这篇文章将个大家来详细的介绍一下phpstudy的内容。 首先在百度百科上对于phpstudy的定义是一个PHP调试环境的程序集成包。
该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer,一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境，该程序不仅包括PHP调试环境，还包括了开发工具、开发手册等。
在知道了phpstudy是做什么的之后，我们就来看一看关于phpstudy的使用：
第一步：下载phpstudy
我们先从官网https://www.xp.cn中下载phpstudy安装包
第二步：解压phpstudy安装包
进行解压，解压后进入目录，如下图所示
选择应用程序点击，出现一个对话框点击ok即可。
第三步：安装成功后会出现如下界面
可以在界面启动或者停止mysql和Apache的服务。
第四步：点击其他选项菜单选择网站根目录；即可打开网站根目录，php项目或者文件需要放到此根目录下才能运行。
第五步：在地址栏输入php项目路径或者php文件路径，使用回车键即可运行。
最后：
如果要运行一个.php程序其实并不是一定要将该程序放在WWW文件夹下面，放在其他目录下面的.php文件也是可以运行的，为什么呢？因为这个目录可以改的。你只需要选择其他选项菜单–&gt;phpStudy设置–&gt;端口常规设置，然后会看到如下窗口：
其中的网站目录就是你放代码的地方，默认的是Apache下的WWW文件。你要是想放在其他目录下，更改这个网站目录就可以了，需要注意的是：如果你的目录改了，那么原来WWW文件夹下面的东西都要复制过去。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/113/">«</a>
	<span class="pagination__item pagination__item--current">114/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/115/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>