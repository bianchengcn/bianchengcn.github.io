<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dfb5253d230e934506ac7988c4940e1/" rel="bookmark">
			[算法思考记录]力扣1094.拼车 Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Problem: 1094. 拼车
相当于在一条路上开车，乘客在某个时间点上车，他们会影响在下车之前的路程的车载人数。
很明显这是差分的做法，只要把行车的路程抽象成一个差分数组，把上下车抽象成区间更改，一切都变得简单
Code class Solution { public boolean carPooling(int[][] trips, int capacity) { int[] road = new int[1010]; for (int[] t : trips) { int num = t[0], from = t[1], to = t[2]; road[from] += num; road[to] -= num; } int s = 0; for (int v : road) { s += v; if (s &gt; capacity) return false; } return true; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e388b494c30e4da66fec62ae7a37b85/" rel="bookmark">
			kkFileView 从源码编译最新安装包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言二、拉取 kkFileView 最新代码三、kkFileView 打包 一、前言 kkFileView 是一个开源的附件在线预览项目，可以让你的项目方便的在线预览附件，包括比如：doc、docx、pdf、xml、xls、xlsx、ppt、pptx、zip、png、jpg、txt、mp4等常见附件格式预览。
在上一篇博客 kkFileView安装及使用——文件预览解决方案 里讲了如何下载 kkFileView 安装包及安装使用，该教程使用的是 v4.0.0 版本的 kkFileView 。
那如何自己从代码构建最新版本的 kkFileView 呢？
本文介绍如何从源码构建最新的 kkFileView 安装 ，截止本博客发文， 最新的 kkFileView 是 v4.4.0 版本。
二、拉取 kkFileView 最新代码 1.gitee 或 github 上拉取最新的代码
由于 github 下载项目太慢，我这里使用的是 gitee ，打开 kkFileView在Gitee上的地址 ，点击克隆按钮，然后复制项目地址。
2.使用如下 git 命令拉取项目代码到本地
git clone git@gitee.com:kekingcn/file-online-preview.git 3.使用 idea 打开项目
使用 idea 打开项目，等待依赖项加载完毕
三、kkFileView 打包 1.先点击右侧 Maven 面板里，Lifcycle 下的 clean 清理项目，再点击 install 开始打包
打包成功后，打印的信息提示 在项目的 server/target 目录下生成了两个安装包，一个是 zip 格式的 windows 安装包，一个是 tar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e388b494c30e4da66fec62ae7a37b85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c78dd7bc65d2b4190af0171ad58d3bb9/" rel="bookmark">
			用于药物发现的知识图谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在GitHub上搜索了一下，发现有一些项目涉及到知识图谱在药物发现领域的应用。
一个项目是 **KDD2023_KaGML_DrugDiscovery_Tutorial**，它是一个关于药物发现的教程，介绍了如何使用知识增强的图机器学习（KaGML）来进行药物发现¹。
另一个项目是 **integrating_knowledge_data**，它是一个将基因表达和生物知识整合到药物发现和再利用中的项目²。
还有一个名为 **DeepPurpose** 的项目，它是一个深度学习工具包，可用于药物靶点识别、药物属性预测、蛋白质-蛋白质相互作用预测等³。
1.KaGML
图机器学习 (GML) 因其对图结构生物医学数据建模并研究其属性和功能关系的卓越能力而受到广泛关注。 尽管付出了巨大的努力，GML 方法仍然存在一些缺陷，例如处理监督稀疏性以及在学习和推理过程中提供可解释性的能力有限，以及在利用相关领域知识方面的效率低下。 为此，最近的研究提出将外部生物医学知识整合到 GML 管道中，以通过有限的训练实例实现更精确和可解释的药物发现。 本教程全面概述了长期存在的药物发现原理，提供了图结构数据和知识数据库的基本概念和前沿技术，并正式总结了用于药物发现的知识增强图机器学习 (KaGML)。 我们最近完成了一项对 KaGML 作品的调查，按照新颖定义的分类法将优秀的方法分为四个类别。 2.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8012ca20b6758e434fae4a20aefe7385/" rel="bookmark">
			华为认证 | 华为HCIE笔试一共多少道题？HCIE证书怎么查？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HCIE证书的含金量非常高。
然而，要想获得这张宝贵的证书，考生需要先通过HCIE笔试。
那么，华为HCIE笔试到底有多少道题？如何查询HCIE证书呢？下面将为您一一解答。
01 华为HCIE笔试一共多少道题 华为HCIE笔试题目数量并不是固定的，而是根据不同的考试级别和考试内容有所差异。
对于HCIE-Datacom方向的笔试，总共有120道题目。
其中，选择题有90道，每道题目1分；场景题有30道，每道题目2分。
考试时间为140分钟，总分为130分，及格分数线为90分。
需要注意的是，不同考试级别的题目数量和难度也会有所不同。
因此，在参加考试前，建议仔细阅读考试大纲和了解考试要求，以便更好地备考。
02 HCIE证书怎么查 ★ 访问华为官方网站
首先，你可以访问华为官方网站，在首页导航中找到“支持与解决方案”或“培训与认证”等选项，然后选择相应的HCIE认证科目和级别进行查询。
在查询时，你需要输入你的姓名、身份证号码或考试编号等信息进行身份验证。
★ 访问第三方认证机构网站
除了华为官方网站外，你还可以访问一些第三方认证机构网站进行查询。
这些机构通常会提供华为认证考试的报名、培训和查询等服务。
在查询时，你需要提供相应的个人信息和考试信息进行验证。
★ 拨打认证机构客服电话
如果你无法通过以上两种方式查询到你的HCIE证书，你可以尝试拨打华为认证机构的客服电话进行咨询。
在拨打电话时，你需要提供自己的姓名、身份证号码或考试编号等信息以便客服人员帮助你查询。
03 华为HCIE数通考试时间 华为HCIE-Datacom认证考试采用预约随考的形式，考试时间不固定，考生需提前预约考试时间。
笔试环节成绩考后即出，实验环节成绩考后5个工作日公布。
考生需同时通过笔试和实验两个环节方可获得认证。
要想获得华为HCIE证书，考生需要先通过HCIE笔试。
在准备笔试时，考生需要了解考试大纲、制定复习计划、注重实践操作和多做真题。
在查询证书时，考生需要访问华为官方网站并输入证书编号和身份证号码来查询到自己的证书信息。
想获取更多『 思科 | 华为 | 红帽 认证真题 』、『 网工软考真题 』、『 大厂岗位内推 』，请关注公众号：HCIE考证研究所
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/512737fe191d6865788c90c4b7b821e8/" rel="bookmark">
			使用 Vue3 实现一个穿梭框效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 当选中数据，并且点击相对应的方向箭头时，选中的数据会发送到对面，并且数据会保持正确的顺序进行排列。
在线预览：https://chenyajun.fun/#/transfer
实现 左右两边逻辑一致，这里只对左侧的进行分析
先看一下 html 结构 方便理解
&lt;div class="module-wrapper"&gt; &lt;div class="module-head"&gt; &lt;span&gt;list1&lt;/span&gt; &lt;span&gt;{{ currentSelectLeft }}&lt;/span&gt; &lt;/div&gt; &lt;div class="module-content"&gt; &lt;div v-if="!listLeft.length" style="text-align: center"&gt;No data&lt;/div&gt; &lt;div class="module-item" v-for="(item, index) in listLeft" @click="handleTransferLeft(index)"&gt; &lt;input style="width: 20px; height: 20px" type="checkbox" :checked="item.checked" /&gt; &lt;span :style="{ color: item.checked ? '#68b2ff' : '#000', }" &gt;{{ item.label }}&lt;/span &gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 数据处理 首先初始化 10 条穿梭框数据，key 属性用于排序，label 用于展示数据，最后为数据添加 checked 属性（主要用于标记是否被选中），然后将数据赋值给左边的列表 listLeft。
function getListData() { let data = [] for (let index = 1; index &lt;= 10; index++) { data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/512737fe191d6865788c90c4b7b821e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138e5246b2ebd75fed8c79ef0681f865/" rel="bookmark">
			在windows7安装高版本Nodejs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在windows7系统安装node.js，最高版本只支持13.14，要安装14以上node.js，可以使用zip版来手动安装。
到 nodejs.org 下载 zip 版本，下面以 node-v20.10.0-win-x64 为例：
访问https://nodejs.org/dist/latest-v20.x/，下载node-v20.10.0-win-x64.zip 文件，解压到D:\nodejs目录下，
优先设置系统环境变量，将 node-v20.10.0-win-x64 解压缩到 D:\nodejs
在系统变量中新建环境变量NODE_HOME，值是node.js解压包根目录D:\nodejs
新建变量NODE_SKIP_PLATFORM_CHECK, 值为1，目的是让 nodejs 跳过系统兼容性检查。
编辑path变量，在尾部追加%NODE_HOME%
此时在命令行输入node -v，应该可以正常显示版本号
配置npm：
npm config set registry http://registry.npmjs.orgnpm config set registry http://registry.npm.taobao.org重置组件安装目录：npm config set prefix "D:\nodejs\node_global"重置缓存目录：npm config set cache "D:\nodejs\node_cache" 系统变量中新建 NODE_GLOBAL_HOME，值是node_global路径D:\nodejs\node_global
编辑 path变量，在尾部追加%NODE_GLOBAL_HOME%
打完收工。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/985768c393b9e0301e7ee03532d9c98a/" rel="bookmark">
			okhttp导致的内存溢出(OOM)sun.security.ssl.SSLSocketImpl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用分析工具：MAT(Memory Analyzer Tool)、JvisualVM占用内存：sun.security.ssl.SSLSocketImpl 一、 项目场景： 功能：一个定时任务(xxl-job)采用线程池的方式多线程请求第三方拉取数据，网络框架使用okhttp3。
问题：执行job时，内存短时间内暴增，导致OOM
二、问题描述 定时任务执行时，突然内存激增，OOM导致项目重启。下面这张图是重启后再次执行定时任务的内存监控
三、原因分析： 3.1 查看堆栈信息 使用MAT查看堆栈信息，sun.security.ssl.SSLSocketImpl这个东西占了62%
点击Details ，可以看到有9k多个对象
使用OQL查询sun.security.ssl.SSLSocketImpl，发现其中的host都是请求第三方的地址
select * from sun.security.ssl.SSLSocketImpl
到这里，基本可以定位到是由于请求第三方资源没有释放，导致内存暴增。接下来查看请求第三方的代码
3.2 查看代码 看到底层工具类OkHttpClientUtil工具类中获取OkHttpClient对象的代码是这样的，每次请求都是new一个OkhttpClient对象，可能是每次都是new一个OkhttpClient的问题，于是在本地复现。
private static OkHttpClient getHttpClient() { return new OkHttpClient.Builder() .connectTimeout(obtainConnectTimeOut(), TimeUnit.MILLISECONDS) .writeTimeout(obtainWriteTimeOut(), TimeUnit.MILLISECONDS) .readTimeout(obtainReadTimeOut(), TimeUnit.MILLISECONDS) .build(); } 四、场景复现： 模拟生产，采用线程池方式多线程请求，请求地址改为百度，数据随便塞一点只要正常相应就行。
4.1代码 OkHttpClientUtil 工具类,getHttpClient()是之前的，getHttpClientSingleton()是我新写的
@Slf4j public class OkHttpClientUtil { private static final MediaType TYPE_JSON = MediaType.parse("application/json; charset=utf-8"); private volatile static OkHttpClient okHttpClient; public static OkHttpClient getHttpClient() { return new OkHttpClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/985768c393b9e0301e7ee03532d9c98a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbf5d655d7e2e1e8645d368d504d61eb/" rel="bookmark">
			Godot根据屏幕朝向和窗口大小适配显示布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目设置 在项目设置（project.godot）中，将显示-&gt;窗口-&gt;手持设备-&gt;朝向，即属性display/window/handheld/orientation，设置为Sensor。
GDScript 代码 func set_camera(half_width: float, half_height: float): var v = DisplayServer.window_get_size() if half_width &gt;= half_height * v.aspect(): $Camera3D.set_keep_aspect_mode(Camera3D.KEEP_WIDTH) $Camera3D.set_size(ceil(half_width) * 2) else: $Camera3D.set_keep_aspect_mode(Camera3D.KEEP_HEIGHT) $Camera3D.set_size(ceil(half_height) * 2) func reorient_landscape(): # set landscape layout here var half_w = ... var half_h = ... set_camera(half_w, half_h) func reorient_portrait(): # set portrait layout here var half_w = ... var half_h = ... set_camera(half_w, half_h) func on_viewport_size_changed(): var size = DisplayServer.window_get_size() if size.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbf5d655d7e2e1e8645d368d504d61eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50bea90e3f79e4dbbfe58ac3371f9522/" rel="bookmark">
			如何获取阿里巴巴中国站按图搜索1688商品（拍立淘） API接口（item_search_img-按图搜索1688商品（拍立淘））
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景介绍
阿里巴巴中国站作为中国领先的B2B电子商务平台，提供了大量的商品信息和交易服务。其中，按图搜索1688商品（拍立淘）是阿里巴巴中国站特有的功能之一，它可以通过上传图片来搜索与图片相似的商品，为消费者提供了更加便捷的购物方式。为了方便开发者快速获取按图搜索1688商品（拍立淘） API接口，本文将详细介绍该接口的使用方法、参数设置、返回值处理等内容。
二、问题建模
了解拍立淘功能和API接口 首先，我们需要了解拍立淘功能和API接口的基本概念和作用。拍立淘是一种通过上传图片来搜索相似商品的购物方式，而API接口则是实现该功能的程序接口。通过API接口，开发者可以调用拍立淘功能，获取与上传图片相似的商品信息。
了解API接口文档 在使用按图搜索1688商品（拍立淘） API接口之前，我们需要仔细阅读相关的API接口文档。文档中包含了接口的使用方式、参数说明、返回值示例等内容。开发者需要根据文档中的说明进行开发。
参数设置 在使用按图搜索1688商品（拍立淘） API接口时，需要传递相关参数来调用该功能。其中，最重要的参数是上传的图片。开发者需要将图片转换为二进制格式，并将其作为请求参数传递给API接口。此外，还可以传递其他相关参数如搜索关键字、分类ID等来过滤搜索结果。
返回值处理 API接口返回的商品信息一般包括商品的名称、价格、描述、图片等信息。开发者需要根据实际需求选择需要的信息进行处理和使用。同时，需要对返回的数据进行校验和处理，避免出现异常情况。
三、解决方案
使用合适的编程语言和工具进行开发 由于按图搜索1688商品（拍立淘） API是HTTP协议的，因此可以使用各种编程语言和工具进行开发。常见的编程语言如Python、Java、PHP等都可以使用。同时，可以使用一些第三方库或工具如requests、HttpClient等来简化HTTP请求的处理。
仔细阅读API接口文档并进行测试 在使用按图搜索1688商品（拍立淘） API接口之前，需要仔细阅读API接口文档并进行测试。测试过程中可以尝试不同的参数组合和返回值示例，以便更好地了解API接口的使用方式和返回值格式。同时，测试过程中也需要对异常情况进行处理和记录，以便更好地排查问题。
3. 根据实际需求选择需要的信息进行处理和使用
获取到的商品信息可能比较繁多，开发者需要根据实际需求选择需要的信息进行处理和使用。例如，如果只需要获取商品的名称和价格信息，那么可以只处理返回数据中的相关字段。同时，需要对返回的数据进行校验和处理，避免出现异常情况。
4. 定期维护和更新API接口文档和代码库
随着业务的发展和变化，按图搜索1688商品（拍立淘） API的参数和使用方式也可能发生变化。因此，开发者需要定期维护和更新API接口文档和代码库，以便更好地适应业务的变化和发展。同时，也需要对API接口的使用情况进行监控和维护，确保其稳定性和可用性。
四.响应示例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9962ad0a1daf28e3d1e50ae8b244b9/" rel="bookmark">
			vue2后台系统需要接入文件预览项目，使用kkFileView预览组件达到对docx、excel、ppt、jpg等文件的预览效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大概记录一下多文件文件批量上传后 然后再进行各种文件类型的预览功能的实现吧 当文件上传时 需要我们引入token 携带请求头
这里的url上传地址 是上传到服务器的地址，然后后端再去服务器里进行相应上传文件的匹配 &lt;div v-for="(item, index) in listData" :key="index" style="display: inline-block" &gt; &lt;div style=" background-color: rgba(243, 243, 243, 0.955); width: 1134px; height: 150px; padding: 8px; margin-top: 10px; " v-loading="loading" &gt; &lt;div style="margin-bottom: 15px; font-weight: 800"&gt; {{ item.name }} &lt;/div&gt; &lt;div style=" display: flex; justify-content: space-between; margin-bottom: 15px; " &gt; &lt;div&gt; &lt;span&gt;分类:&lt;/span&gt;&lt;span&gt;{{ item.category }}&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;创建人:&lt;/span&gt;&lt;span&gt;{{ item.createBy }}&lt;/span&gt; &lt;/div&gt; &lt;div style="margin-right: 60px"&gt; &lt;span&gt;创建时间:&lt;/span&gt;&lt;span&gt;{{ item.createTime }}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9962ad0a1daf28e3d1e50ae8b244b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8d5a7644ec14abc99b7eed779fa85a7/" rel="bookmark">
			Hive数据倾斜之：数据类型不一致导致的笛卡尔积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive数据倾斜之：数据类型不一致导致的笛卡尔积 目录 Hive数据倾斜之：数据类型不一致导致的笛卡尔积一、问题描述二、原因分析三、精度损失四、问题解决 一、问题描述 如果两张表的jion，关联键分布较均匀，没有明显的热点问题，在执行的过程中出现了数据倾斜的情况，是什么原因
二、原因分析 数据倾斜通常会出现在关联操作或者聚合操作相关的位置，所以出现数据倾斜后，可以先排查一下是否出现了某个key的数量过多，对于上述的问题，排查之后发现并没有明显的热点key的问题。接下里就考虑是不是数据本身分布的原因，想想也不合理，最后查看了数据，发现关联键的长度很长，有19位，就开始怀疑是不是两张表的关联键类型不一致，导致了隐式转换，查询了数据类型，果真不一样，一个是bigint类型，一个是string类型
那么为什么类型不一致会出现隐式转换呢，把执行的sql的单独拿出来看下执行计划，发现了如下的一段神奇东东
在hive2.7中，当类型不一致时，会自动将关联键转换为double类型，而double类型对于过大值的存储是有精度存储的
所以问题定位了，因为存在精度损失，所以那么多的key虽然不一样，但是被当作了一样，然后被无情的join在了一起，如果有2个key，就join4次，4个key，就join16次，那可不就倾斜了吗。
三、精度损失 所谓精度损失，就是在表示过大数值的时候会存在一定的误差。而double类型能准确的表示15-17位的数值，超过则会存在精度损失。
之所以double能精确表示15-17位数据，因为double类型是使用64位（8字节）来表示的。这意味着double类型的精度有53位。其中，52位用于表示有效数字（尾数），1位用于表示符号位。另外，double类型还有11位用于表示指数部分。由于双精度浮点数采用了IEEE 754标准，它可以表示非常大或非常小的数值，并且具有相对较高的精度。然而，由于浮点数的特性，它们可能会存在舍入误差和精度损失的问题。
比如：数值：171555543206125977 和 171555543206125979，在hive中就是想等的
输入： select cast(171555543206125977 as double) = cast(171555543206125979 as double) 输出： true 在双精度浮点数（double）中，无法精确地存储整数值1715555432061259777。由于双精度浮点数使用64位（8字节）来表示，其中一部分用于表示有效数字（尾数），一部分用于表示指数部分，还有一位用于表示符号位。
双精度浮点数的尾数部分有52位，可以精确地表示15到17位的十进制数值。而整数值1715555432061259777有19位，超过了双精度浮点数的精度范围。
当我们尝试将整数值1715555432061259777存储为双精度浮点数时，可能会出现舍入误差或精度损失。双精度浮点数会尽可能地接近给定的数值，但无法保证完全精确。
四、问题解决 解铃还需系铃人，既然是因为类型不一致导致的隐式转换从而导致的精度存储，那么就避免类型不一致的问题，在使用关联时候要确保关联键的类型一致，或者切换Spark引擎，因为Spark中不会出现这种问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e8367d093045c13b0c581bd91424d8/" rel="bookmark">
			JDBC概述（什么是JDBC？JDBC的原理、Mysql和Sql Server入门JDBC操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi i,m JinXiang
⭐ 前言 ⭐
本篇文章主要介绍JDBC概述（什么是JDBC？JDBC的原理、Mysql和Sql Server入门JDBC操作）简单知识以及部分理论知识
🍉欢迎点赞 👍 收藏 ⭐留言评论 📝私信必回哟😁
🍉博主收将持续更新学习记录获，友友们有任何问题可以在评论区留言
目录
⭐什么是JDBC？
⭐为什么要使用JDBC
🍧使用JDBC有以下几个主要原因：
🍧使用JDBC的好处：
⭐JDBC的原理？
⭐Mysql和sql server入门JDBC操作
🍧1、Mysql的JDBC操作
🍧2、Sql Server的JDBC操作
⭐什么是JDBC？ JDBC是Java Database Connectivity的缩写
是一种用于Java程序访问关系型数据库的API（应用程序接口）。
它允许Java程序员使用标准的SQL语句来访问和操作关系型数据库。JDBC提供了一种标准的方式来连接到不同数据库的驱动程序，并且是Java EE平台上进行数据访问的基础。它提供了许多接口和类，使Java应用程序可以通过它们来访问和管理关系型数据库。
⭐为什么要使用JDBC 🍧使用JDBC有以下几个主要原因： 1. Java语言的跨平台性：JDBC可以在各种操作系统和计算机体系结构上运行，这使得使用Java开发的应用程序可以方便地与不同类型的数据库进行交互。
2. 标准化：JDBC是一个标准化的API，提供了一致的访问关系数据库的方法，使得不同的JDBC驱动程序可以实现相同的接口。这方便了Java开发人员在不同的关系型数据库之间切换。
3. 安全性：使用JDBC可以使数据访问更加安全。通过JDBC API访问数据库，可以避免直接在代码中包含SQL语句，从而防止SQL注入攻击。
4. 性能：JDBC可以提供高效的数据访问，因为它允许Java程序员使用原生SQL语言来访问数据库，而且JDBC驱动程序可以优化SQL语句的执行。
综上所述，JDBC是Java开发人员进行关系型数据库操作的重要工具，它提供了一种标准化的方式来连接到不同数据库的驱动程序，并且可以保证安全、跨平台和高效的数据访问。
🍧使用JDBC的好处： 1. 简化了Java应用程序与各种数据库之间的连接和数据交互，使Java应用程序可以与不同类型的数据库通信。
2. 通过JDBC，开发人员能够使用标准SQL语句来执行数据库查询，修改和更新等操作，而无需了解特定数据库的API。
3. 可以使用JDBC提供的API来保证数据的完整性和安全性，并提高数据访问的效率。
4. JDBC允许开发人员使用Java语言来编写数据库驱动程序，从而提供了一个灵活的方式来访问数据库。
5. JDBC提供了一种标准的方式来访问和管理关系型数据库，这使得Java EE平台上对数据进行管理更加容易和可靠。
⭐JDBC的原理？ JDBC（Java Database Connectivity）是Java语言访问关系型数据库的标准API。它的原理如下：
1. 加载数据库驱动：在Java应用程序中，首先需要加载适当的数据库驱动程序。
2. 连接数据库：使用Java程序中的getConnection（）方法与数据库建立连接。
3. 创建操作对象：使用Java程序中的Statement对象或者PreparedStatement对象来执行SQL语句。
4. 执行SQL语句：使用Statement对象或者PreparedStatement对象来执行SQL语句，在执行SQL语句之前，需要对SQL语句进行预编译。
5. 处理查询结果：使用ResultSet对象来处理从数据库返回的查询结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e8367d093045c13b0c581bd91424d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23fa59d1dd7c4b63e57e69c9a7d169e/" rel="bookmark">
			大模型训练为什么用A100不用4090
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个好问题。先说结论，大模型的训练用 4090 是不行的，但推理（inference/serving）用 4090 不仅可行，在性价比上还能比 H100 稍高。4090 如果极致优化，性价比甚至可以达到 H100 的 2 倍。
事实上，H100/A100 和 4090 最大的区别就在通信和内存上，算力差距不大。
H100A1004090Tensor FP16 算力989 Tflops312 Tflops330 TflopsTensor FP32 算力495 Tflops156 Tflops83 Tflops内存容量80 GB80 GB24 GB内存带宽3.35 TB/s2 TB/s1 TB/s通信带宽900 GB/s900 GB/s64 GB/s通信时延~1 us~1 us~10 us售价40000$15000$1600 NVIDIA 的算力表里面油水很多，比如 H100 TF16 算力写的是 1979 Tflops，但那是加了 sparsity（稀疏）的，稠密的算力只有一半；4090 官方宣传 Tensor Core 算力高达 1321 Tflops，但那是 int8 的，FP16 直只有 330 Tflops。这篇文章的第一版就是用了错的数据，H100 和 4090 的数据都用错了，得到的结论非常离谱。
H100 这个售价其实是有 10 倍以上油水的。
2016 年我在 MSRA 的时候，见证了微软给每块服务器部署了 FPGA，把 FPGA 打到了沙子的价格，甚至成为了供应商 Altera 被 Intel 收购的重要推手。2017 年我还自己挖过矿，知道什么显卡最划算。后来在华为，我也是鲲鹏、昇腾生态软件研发的核心参与者。因此，一个芯片成本多少，我心里大概是有数的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a23fa59d1dd7c4b63e57e69c9a7d169e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c9ff39bccb42e826d7205c9be8a21c2/" rel="bookmark">
			Hive进阶函数：inline() 和 struct() ,一列转多行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用场景 如果存在一张表，记录的是每位学生的各科成绩，现在想把表转换为纵向存储
比如：
name｜english｜math｜history
tom ｜80 ｜90 ｜100
转换为：
name｜subject｜score
tom ｜english｜80
tom ｜math ｜90
tom ｜history ｜100
二、问题分析 可以把这个问题分为两部分
第一部分：将一行转为三行
第二部分：将每行数据的分数和科目填上
三、问题解决 方法一：space() 所以可以使用space把每行数据都炸裂为三行，然后根据name开窗排序，依次写入成绩和科目即可
with base as ( select 'tom' as name, 80 as english, 90 as math, 100 as history union all select 'jery' as name, 30 as english, 60 as math, 70 as history ) select name ,case when rn = 1 then 'english' when rn = 2 then 'math' when rn = 3 then 'history' end as subject ,case when rn = 1 then english when rn = 2 then math when rn = 3 then history end as score from ( select name ,english ,math ,history ,row_number() over(partition by name) rn from base lateral view explode(split(space(2), ' ')) tmp as s ) t 这样写纵然可以，但是很麻烦，消耗资源，并且不健壮，如果再来几个字段，是不是得一直添加下去，所以需要一个函数的出现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c9ff39bccb42e826d7205c9be8a21c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e27bcf2bd1f2dec4290f4b46cb50a7/" rel="bookmark">
			Hive进阶函数：SPACE() 一行炸裂指定行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据一行如何转多行 假如有一张表，字段有两个，分别是name 和 number，代表含义为名字 和 名字出现的次数，现在需要把一行数据转为number行
举例： 输入：
tom｜3 jery｜4 输出：
tom tom tom jery jery jery jery 思路分析： 把一行数据炸成对应的number行，类似于列传行，列传行常用的函数为explode，但是要传入一个数组，函数会根据数组把列变为行，所以现在如果有一个数组，里面分别有number元素就可以实现上述的例子
引入函数 space函数：space函数需要传入一个数值n，则会生成n个数组
输入： space(3) 输出 ' ' -- 三个空格 那么生成number个空格，再按照空格切割
输入： split(space(3), ' ') 输出： '"","","",""' 注意 ：因为切割时候一个空格会切割为左右两个空串，所以在生成空格时，仅需要number-1个即可
实现： 在理清思路和了解方法后，就可以实现了，按照上面的例子
select name from tbl lateral view exploed(split(space(number-1), ' ') tmp as num 全部代码
with base as ( select 'tom' as name, 3 as number union all select 'jery' as name, 4 as number ) select name from base lateral view explode(split(space(number - 1), ' ')) tmp as num 结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06e27bcf2bd1f2dec4290f4b46cb50a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12bbf96e119ad16c8f2e050eb477a93/" rel="bookmark">
			python获取C文件中枚举值的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用于检测文件夹中头文件中枚举值：
#!/usr/bin/env python # -*- coding: utf-8 -*- import os,sys import re if __name__ == '__main__': try: os.remove("_AllEnum") except: pass enumValue = [] for dirroot, dirs, files in os.walk(os.path.abspath(".")): for filename in files: if filename.endswith(".hh") or filename.endswith(".h"): print("----------------"+ filename) content = "" with open(os.path.join(dirroot, filename),"r", encoding="utf-8") as file: content = file.read() # 匹配正常格式 enum Struname {} pattern = re.compile(r'\benum\s+(\w+)\s*{([^}]*)}', re.DOTALL) enum_matches = pattern.finditer(content) # 遍历匹配的枚举类型 for enum_match in enum_matches: enum_name = enum_match.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e12bbf96e119ad16c8f2e050eb477a93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd02a0bd8f0f12bdba7579b63319071/" rel="bookmark">
			Chrome 拓展开发系列：数据存储之 chrome.storage 和 localStorage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言localStoragesessionStoragelocalStoragelocalStorage 使用示例 chrome.storagechrome.storage 使用示例chrome.storage vs localStorage 总结个人简介 前言 chrome.storage 和 localStorage 都是在浏览器中用于存储数据的机制，下面我们一起聊聊它们是什么，区别以及使用示例。 localStorage HTML5标准中，Web Storage API 提供了可以存储键值对的机制，包含 sessionStorage 和 localStorage 分别对应临时存储和永久存储。 sessionStorage 为每一个给定的源（origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。仅为页面会话存储数据（同一个页面内有效），意味着数据将一直存储到浏览器（或选项卡）关闭。数据永远不会被传输到服务器。存储限额大于 cookie（最大 5MB）。 localStorage 和 sessionStorage 做同样的事情，但即使浏览器关闭并重新打开也仍然存在。（同一个 origin 下有效）存储的数据没有过期日期，只能通过 JavaScript、清除浏览器缓存或本地存储的数据来清除。存储限额是两者之间的最大值。 localStorage 使用示例 // 存储数据到 localStorage localStorage.setItem('username', 'JohnDoe'); console.log('Data has been set.'); // 从 localStorage 获取数据 var username = localStorage.getItem('username'); console.log('Value for username is ' + username); chrome.storage chrome.storage 是 Chrome 扩展中用于存储扩展数据的 API。可以看作是 localStorage 的改进版本。支持异步方式存储键值对，并提供不同的存储区域，包括 local（本地存储）和 sync（同步存储）。即使使用分离式隐身行为，用户的扩展程序设置也会保留。可以读取管理员为扩展程序配置的企业策略（使用 storage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cd02a0bd8f0f12bdba7579b63319071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0274e0b6cac6fedaceac670ace818b0d/" rel="bookmark">
			前置任务之安装jdk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已经安装过很多次了，但是每次安装都要搜好几次才能找到正确的，离大谱。
1.打开 oracle官网
https://www.oracle.com
然后切换到Java archive
下载192版本的，页面搜索ctrl+F，【Java SE Development Kit】或者【jdk-8u192-windows-x64】，
找到要下载的文件，登录oracle账号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b1064e88d224e159fd99fa8d9425ee8/" rel="bookmark">
			Addressable（7）Packed Assets打包资源数据配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Packed Assets打包资源数据配置知识点一：Packed Assets介绍知识点二：Packed Assets参数介绍Content Packing &amp; Loading重点：Advanced OptionsContent Update RestrictionAdd Schema（添加模式） 知识点三：创建自定义的配置总结 Packed Assets打包资源数据配置 知识点一：Packed Assets介绍 基本介绍
打包资源
作用
确定如何处理组中的资源
比如：可以指定一个组生成AB包的位置和包压缩相关的等等设置
知识点二：Packed Assets参数介绍 Content Packing &amp; Loading build * Load Paths
Build &amp; Load Paths
当前组从哪里加载和打AB包的位置
设置
重点：Advanced Options Asset Bundle Compression
AB包的压缩格式
Uncompressed：不压缩，包体大LZ4：压缩，用什么解压什么，内存占用低LZMA：压缩最小，解压慢，用一个资源要解压所有 Include in Build（一般勾选）
构建时，当前分组是否打包到AB包里
Use Asset bundle cache
是否缓存远程分发的包
Asset Bundle CRC
验证包的完整性
不验证验证，包括缓存的包验证，不包括缓存的包 Include Address in Catalog（一般勾选）
当前组的资源Addressable的地址字符串是否包括在目录中
如果不使用地址加载资产，可以不包括他们，以减少catalog目录的大小（红框框中的地址）
Include GUIDs in Catalog
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b1064e88d224e159fd99fa8d9425ee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ed557ab4299c74e89609e8203595efd/" rel="bookmark">
			操作系统——解决了我的一些困惑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、电脑开机做了什么事情
2、真正实现并行的计算机
3、计算机中的淘汰算法 &amp; 分配算法 &amp; 调度算法 &amp; 空间管理
4、什么是虚拟内存？为什么需要虚拟内存？最多可分配多少？
5、TLB（快表）、分页存储（慢表）【二级、多级、分段、分页、段页】、虚拟内存
6、高级语言程序——转换为可执行目标程序
1、电脑开机做了什么事情 爆肝一晚上，希望用动画带你理解操作系统的启动_哔哩哔哩_bilibili
首先，我们已经通过BIOS引导，安装了一个操作系统，并且划分了分区，还安装了软件
现在开始开机： （自检-BIOS-MBR-PBR-初始化）
CPU读取磁盘信息（执行BIOS引导程序——硬件自检）通过主引导记录MBR——找到磁盘分区 &amp; 操作系统的分区通过分区引导记录PBR——根据根目录找到启动管理程序执行操作系统的初始化程序——完成操作系统的初始化 补一下：（408小白，刚刚才开始复习操作系统，还搞不定那些分区什么的，虽然王道有讲，但是忘记了差不多了）
电源开启后，计算机进行电源自检，确保各硬件设备正常。主板上的BIOS芯片被访问，执行Basic Input/Output System (BIOS)程序。BIOS负责初始化各硬件设备，并进行一系列自检，包括检查RAM、显示适配器等。BIOS通过读取硬盘驱动器的引导区（Master Boot Record，MBR）来加载引导程序。MBR位于分区表的第一个扇区，其中存储了引导程序的位置和大小信息。主要分为：【磁盘引导程序 和 分区表】（扫描分区表：分区表记录了D盘的位置，还有系统分区C盘等等，【普通盘】就是记录的数据，【系统盘】就是操作系统的程序）通过【MBR的引导程序】找到【系统分区】，读取【分区引导记录 - Partition Boot Record - PBR】，然后根据【根目录】找到【启动管理程序】，加载【操作系统的引导加载程序】（如果是Linux，就加载Linux，如果是Windows，就加载Windows）。完成后把【控制权】转交给【操作系统】。【操作系统内核】被加载入内存，并开始执行【初始化程序】。【初始化程序】负责配置系统环境、加载设备驱动程序和初始化各种子系统。【初始化过程】通常涉及加载一些核心组件、建立内存管理和进程管理结构，以及准备其他必要的系统资源。一旦初始化完成，操作系统进入【可用状态】，用户可以进行交互，并且其他应用程序可以在操作系 需要注意的是，不同的操作系统和计算机架构可能会有所不同，但基本过程大致相似。此外，硬盘分区和软件安装的细节通常在操作系统初始化之后完成。
大佬补充：
目前大多BIOS 都是FLASH存储，可烧写擦除，ROM只是针对用户使用而言的，防止固件程序被随意改动，按下开机键后首先执行上电，上电后权限移交给CPU和BIOS，而后bios再调用mbr表，同样S5-S0根据ACPI会同步执行掉电以达到低功耗。值得一提的是在计算机设计中固件不一定只有BIOS code，有部分挂载需要借助UEFI系统进行升级，同样针对用户来说也是ROM。同样BIOS FLASH内部不一定只有BIOS code，这部分是ODM针对需求定制来决定的。针对硬件层来说，第一层是上电，也就是会执行上电复位/使能/软复位的操作，第二层则是BIOS，第三层是mbr，第四层是fs（eg:NTFS，mbr需要根据fs的类型再进行find os boot），第五层是OS kernel（这之前可能也还有个OS boot），而后才是OS以及OS GUI。当然实际上都是由设计决定的。例如fs其实可以不止一层，kernel可以有kernel的fs，mbr可以有mbr的fs，OS由OS的fs，而磁盘也可能有自己的文件系统（即为固件管路或者存储矩阵管理）。过程还挺复杂的，我这边接触的也只是一个角度的（ACPI上的）
注意：【uefi启动】
现在已经是uefi启动了（原理都是差不多的，不过是uefi统一了框架）
【针对UEFI启动+单系统】在开机的10s内，你的电脑都干了什么？_哔哩哔哩_bilibili
2、真正实现并行的计算机 并行处理计算机系统（parallel computer system）是指同时执行多个任务或多条指令或同时对多个数据项进行处理的计算机系统。
早期的计算机是串行逐位处理的，称为串行计算机。
并行处理计算机主要指以下两种类型的计算机：
1、能同时执行多条指令或同时处理多个数据项的单中央处理器计算机；（超流水技术）
2、多核处理机（可以有一个CPU多个核心）
3、计算机中的淘汰算法 &amp; 分配算法 &amp; 调度算法 &amp; 空间管理 淘汰算法：
1、进程调度（进程五状态的切换）
2、页面调度（内存页面的置换）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ed557ab4299c74e89609e8203595efd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/33/">«</a>
	<span class="pagination__item pagination__item--current">34/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/35/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>