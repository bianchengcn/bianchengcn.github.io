<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec273321c5e30f3665cda24beca18ab/" rel="bookmark">
			ArcMap创建拓扑、添加拓扑规则、检查并修改拓扑错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、 准备工作
2、 在要素数据集中新建拓扑
添加规则
验证拓扑
3、 修改拓扑错误
举例子
1、 准备工作 在自定义工具条中勾选“捕捉”和“拓扑”
新建文件地理数据库gdb/个人地理数据库mdb，
在数据库中新建要素数据集：
从原始数据库gdb中选取任意要素类，导入其坐标系
默认下一页，完成
向要素数据集中导入数据：
导入需要进行拓扑检查的要素类
导入成功：
2、 在要素数据集中新建拓扑 下一页
名称自便：
选择需要进行拓扑检查的要素类：
我默认了：
添加规则 添加规则步骤：
下一页：
确认完成：
验证拓扑 创建拓扑成功：
将拓扑拖入arcmap工作空间中：
可以看到拓扑错误很多
3、 修改拓扑错误 开始编辑：
打开错误检查器：
选择要检查的规则类型，搜索：
可以使用z键和x键配合鼠标画矩形 快速放大缩小。
从拓扑检查器缩放至错误处
举例子 1、某点要素类 - 必须被其他要素的端点覆盖 - 某线要素类：
先缩放至错误处（错误要素以黑色正方形显示）：
根据需求编辑 线 或者点，使 点 落在 线的端点：
仍然是黑色正方形，这需要重新验证一下：
验证之后就不再报错啦：
2、线 - 不能重叠
两线压盖，根据情况修改其中一条线段的端点
修改后 验证当前范围中的拓扑
不再报错：
最后修改完后记得保存！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c8f26e1387392338ae6971bdc7ae2d/" rel="bookmark">
			ArcGIS Server发布地理处理(GP)服务并调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1、执行模型
2、发布为地理处理服务（GP服务）
3、查看服务
测试执行
4、调用服务
1、执行模型 新建工具箱
新建模型
根据情况修改模型
执行模型
2、发布为地理处理服务（GP服务） 打开结果选项卡
将模型共享为地理处理服务
3、查看服务 测试执行 成功：
4、调用服务 核心代码：
可参考官方范例：
Geoprocessing - hotspot analysis | Sample Code | ArcGIS API for JavaScript 4.23 | ArcGIS Developer
​ var params = { in_1: "", in_2: "" }; geoprocessor.submitJob( "http://localhost:6080/arcgis/rest/services/test/model/GPServer/%E6%A8%A1%E5%9E%8B", params ).then((jobInfo) =&gt; { jobInfo.waitForJobCompletion().then(drawResults); } ); function drawResults(result_gp) { console.log("result_gp", result_gp); if (result_gp.jobStatus == "job-succeeded") {//成功 result_gp.fetchResultData("out").then(function (result) {//根据参数名取到输出参数 console.log("out", result); }); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f0a79f37cd2629069643792adbd50c2/" rel="bookmark">
			Supermap iServer安装、发布地图服务、编写简单程序在浏览器显示地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、 安装SuperMapiServer软件并进行配置
2、 发布地图服务
3、 写一个简单程序，在浏览器中显示地图
1、 安装SuperMapiServer软件并进行配置 SuperMap技术资源中心|为您提供全面的在线技术服务
先在官网下载supermap-iserver-10i版本的压缩包
申请许可：
SuperMap Online-全面的在线GIS数据与应用平台
① 登录注册
② 申请许可
解压后打开bin目录下的startup.bat
等待弹出的黑窗口准备完毕后，在浏览器中输入：http://localhost:8090/iserver/setup 进行初始化向导：
创建管理员账户：
检查系统环境：
配置许可：
以管理员身份打开许可中心！！！
激活更新选项卡下选择前面申请的许可文件，要在菜单栏中修改文件类型！！！（不然找不到文件）
配置成功：
配置示范服务：
完成！
2、 发布地图服务 进入服务管理页面：
快速发布一个服务：
选择工作空间（我此处从范例中选择）：
发布一个地图服务：
发布完成！
查看发布的服务：
服务地址：
浏览地图：
3、 写一个简单程序，在浏览器中显示地图 建立程序目录，复制SuperMapiClient for JavaScript脚本库（样例代码中有）
在webapps文件夹下建立文件夹：
将脚本库文件：
所有控件和基础类的文件：
supermap-iserver-10.1.1-win64-zip\iClient\forJavaScript\web\libs\iclient8c\libs
控件资源以及样式文件：
supermap-iserver-10.1.1-win64-zip\iClient\forJavaScript\web\libs\iclient8c\theme
两个文件夹复制粘贴到上述文件夹中：
在webapps/work目录下创建html文件
打开帮助文档：
将上述两段代码拼接粘贴至html中保存，启动 SuperMap iServer 并运行 mymap.html 文件，浏览地图数据：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6c2b047a672b6b0cbffd50813a52750/" rel="bookmark">
			Makefile 编写教程（由简至难）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、测试代码二、.c 文件与Makefile同级三、.c文件与Makefile不同级四、链接静态库 一、测试代码 本文以将main.c add.c common.h三个文件编译成一个可执行文件为例，来讲解Makefile的编写。以下是每个文件的代码（很简单，测试用）
1.main.c
#include &lt;stdio.h&gt; #include "common.h" int main() { int a = 1; int b = 2; printf("add(%d, %d) = %d\n",a, b, add(a,b)); return 0; } 2.add.c
int add(int a, int b) { return a+b; } 3.common.h
#ifndef __COMMON_H__ #define __COMMON_H__ extern int add(int a, int b); #endif 二、.c 文件与Makefile同级 将.c 文件放在Makefile同级目录，然后单独建一个目录.h头文件，如图。
以下是 Makefile 原文：
CC = gcc TARGET = prog OBJS = main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6c2b047a672b6b0cbffd50813a52750/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dde91705878cbce8a9f5b3ebe9a5855e/" rel="bookmark">
			前端之HTML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一份HTML代码 HTML的编译器使用
HTML基本语法
♦​注释:
♦​标题:
♦​段落:
​♦换行:
​♦转义字符:
​♦格式化标签:
​♦图片:
​♦超链接标签:
​♦列表标签:
​♦表格标签:
​♦表单标签:
​♦无语义标签:
本篇内容主要还是一些比较基础的内容,了解就好了, 当前最主流的实现前端的方案就是我们平常所见到前端三剑客(HTML,CSS,JS)(其实我们的Java刚开始也是做前端的),那么今天我们就来聊一聊HTML!!
首先介绍一下HTML本身HTML本身的语法是比较简单的,其并不能表达一些逻辑,而只是能表达"有什么东西"这样一种信息
第一份HTML代码 简单写一个HTML代码:可以直接在一个记事本里面写一行hello,然后将这个文件后缀改成.html就是可以执行的(而且执行也不需要什么额外的运行环境,只要有浏览器就是可以运行的)
这就算执行结束了,但是这个并不是一个正确的html代码,而一个合法的html是使用标签结构(开始标签和结束标签都是成对出现的,标签之间是可以嵌套的,整体这些标签就构成了一个树形结构,称为DOM树)来写的类似于这样的,就算是一个合法的html代码效果是和上面一样的,上面错误的代码之所以能运行就是因为浏览器的鲁棒性(更准确的就是容错能力)很强!!
HTML的编译器使用 上面是使用记事本写的,显然记事本本就不是写代码的地方,那么我们可以在其他地方写html代码吗?当然是可以的,一个是可以直接使用IDEA来写这个代码,但是我们通常所用的社区版IDEA是只支持HTML的,不支持其他代码的,不会有高亮和提示等一系列快捷方式,这也就和记事本差不多了,因此我更推荐使用另一个编译器来写前端代码就是VSCode,这个就是专门来写前端代码的而且不需要任何额外的插件,就可以很好的执行前端代码了,而具体的操作就是在VSCode里面写好代码之后进行保存,然后直接打开保存好的文件就可以直接运行了
HTML基本语法 注释: HTML的标签是和其他语言的注释不一样的,这是标签类的,因此也是使用标签来进行注释的&lt;!--注释内容--&gt;,另外需要注意的是这个注释是不可以嵌套使用的
标题: 有六种标题,从h1-h6字体会逐渐变小
&lt;h1&gt;标题&lt;/h1&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;h4&gt;标题&lt;/h4&gt; &lt;h5&gt;标题&lt;/h5&gt; &lt;h6&gt;标题&lt;/h6&gt; 这样写就会出现这样的效果,一般比较常用的标题是h3或者h4!!
段落: p就是段落标签,两个段落之间是段间距的
&lt;p&gt;这是一个段落:Lorem ipsum dolor sit amet consectetur adipisicing elit. Perferendis aut quasi aspernatur nulla tenetur et, consectetur deleniti esse, illum in minus? Et explicabo numquam minima quaerat, quis quam vitae dolorem!&lt;/p&gt; &lt;p&gt;这是二个段落:Lorem ipsum dolor sit amet consectetur adipisicing elit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dde91705878cbce8a9f5b3ebe9a5855e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/375fe795f44c3807f009e10e4c41ee0a/" rel="bookmark">
			PriorityQueue用法与介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：PriorityQueue用法与介绍 - 简书 一、PriorityQueue介绍 队列是遵循先进先出（First-In-First-Out）模式的，PriorityQueue类在Java1.5中引入并作为 Java Collections Framework 的一部分。
优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。
优先队列不允许空值，而且不支持non-comparable（不可比较）的对象，比如用户自定义的类。优先队列要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。
优先队列的头是基于自然排序或者Comparator排序的最小元素。如果有多个对象拥有同样的排序，那么就可能随机地取其中任意一个。当我们获取队列时，返回队列的头对象。
优先队列的大小是不受限制的，但在创建时可以指定初始大小。当我们向优先队列增加元素的时候，队列大小会自动增加。
PriorityQueue是非线程安全的，所以Java提供了PriorityBlockingQueue（实现BlockingQueue接口）用于Java多线程环境。
二、实现原理 Java中PriorityQueue通过二叉小顶堆实现，可以用一棵完全二叉树表示（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为PriorityQueue的底层实现。
上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：
leftNo = parentNo*2+1
rightNo = parentNo*2+2
parentNo = (nodeNo-1)/2
通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。
PriorityQueue的peek()和element操作是常数时间，add(),offer(), 无参数的remove()以及poll()方法的时间复杂度都是log(N)。
1.add()&amp;offer() add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。
新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。
上述代码中，扩容函数grow()类似于ArrayList里的grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。
需要注意的是siftUp(int k, E x)方法，该方法用于插入元素x并维持堆的特性。
新加入的元素x可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;= queue[parent]为止。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。
2.element()和peek() element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。
3.remove()和poll() remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。
上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用siftDown()方法对堆进行调整，最后返回原来0下标处的那个元素（也就是最小的那个元素）。重点是siftDown(int k, E x)方法，该方法的作用是从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止。
4.remove(Object o) remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果有多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。
三、PriorityQueue实现大顶堆 参考文献：https://blog.csdn.net/u010623927/article/details/87179364
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7663479a9791ddc640d9bfa8ed94adb9/" rel="bookmark">
			java全栈知识体系（pdai入口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		希望所有人能够更好的学习Java知识
Java全栈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be4172700b0ca0fa44c6ef43bcdb8e5/" rel="bookmark">
			xray了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xray了解 文章目录 xray了解一、xray是什么？二、xray的特性三、xray能检测的漏洞类型四、设计理念五、简易架构1、来源处理2、漏洞检测3、结果输出 六、下载运行下载地址运行 一、xray是什么？ xray 是一款功能强大的安全评估工具，由多名经验丰富的一线安全从业者呕心打造而成。
二、xray的特性 检测速度快。发包速度快; 漏洞检测算法高效。支持范围广。大至 OWASP Top 10 通用漏洞检测，小至各种 CMS 框架 POC，均可以支持。代码质量高。编写代码的人员素质高, 通过 Code Review、单元测试、集成测试等多层验证来提高代码可靠性。高级可定制。通过配置文件暴露了引擎的各种参数，通过修改配置文件可以极大的客制化功能。安全无威胁。xray 定位为一款安全辅助评估工具，而不是攻击工具，内置的所有 payload 和 poc 均为无害化检查。 三、xray能检测的漏洞类型 XSS漏洞检测 (key: xss)SQL 注入检测 (key: sqldet)命令/代码注入检测 (key: cmd-injection)目录枚举 (key: dirscan)路径穿越检测 (key: path-traversal)XML 实体注入检测 (key: xxe)文件上传检测 (key: upload)弱口令检测 (key: brute-force)jsonp 检测 (key: jsonp)ssrf 检测 (key: ssrf)基线检查 (key: baseline)任意跳转检测 (key: redirect)CRLF 注入 (key: crlf-injection)Struts2 系列漏洞检测 (高级版，key: struts)Thinkphp系列漏洞检测 (高级版，key: thinkphp)POC 框架 (key: phantasm) 四、设计理念 发最少的包做效果最好的探测。
如果一个请求可以确信漏洞存在，那就发一个请求。如果两种漏洞环境可以用同一个 payload 探测出来，那就 不要拆成两个。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3be4172700b0ca0fa44c6ef43bcdb8e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/477270553b3d75a6ddb1f0452fe35172/" rel="bookmark">
			【RL】强化学习小例子 Q table 表单 Q learning 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. 任务描述1. 伪代码2. Python 代码实现2.1 初始化一些参数2.2 新建一个空的 Q 表2.3 行为选择2.4 环境反馈2.5 更新环境2.6 主循环 Ref: 看了两天书本《深入浅出强化学习》，感觉对概念理解的还是太笼统。鉴于做中学的思想，准备找个小例子跑一跑程序，加深下理解。
找了很多，要么太难，要么太笼统。只找到了莫烦Python老师的这个小例子，不仅有代码，还有视频讲解，感觉很多，跟着大佬学一学。
0. 任务描述 使用的任务是一个1维世界，在世界的右边有宝藏，智能体只要得到宝藏尝到了甜头，以后就记住了得到宝藏的方法，这就是智能体用强化学习所学习到的行为。
-o---T	# T is the position of treasure, o is the position of agent Q - learning 是一种记录行为值（Q value）的方法，每种在一定状态的行为都会有一个值 Q ( s , a ) Q(s,a) Q(s,a)，就是说行为 a a a 在状态 s s s 状态的值是 Q ( s , a ) Q(s,a) Q(s,a)。
而在探索宝藏的任务中，状态 s s s 就是 agent 的位置。而在每一个位置都能做出两个行为 a = left/right a = \text{left/right} a=left/right。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/477270553b3d75a6ddb1f0452fe35172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e84dbecc1f282193615940ecc2f8256/" rel="bookmark">
			Vue学习总结——Vue2生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue2生命周期 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。
vue中每一个组件都会创建一个vue实例，这个实例从出生到死亡，经历的过程如下（官网给出）
生命周期函数（也叫生命周期勾子），用于在Vue实例 创建的生命周期的不同阶段，执行业务逻辑 。Vue2有8个生命周期钩子，都是成对出现：
分别是：
beforeCreatecreatedbeforeMountmountedbeforeUpdateupdatedbeforeDestorydestroyed 接下来我们逐一讲解每个生命周期前后做的事，以及每个生命周期中经常执行的业务。
这是一整个生命周期，接下来我们来拆分讲解
首先，当一个vue对象被创建时
初始化默认事件，生命周期，这样我们的生命周期就被创建了，可以执行接下来的操作了
随后，我们遇到了第一个生命周期函数beforeCreated():
此时，由于data，methods等属性还未被创建，因此我们一般不会再这个生命周期执行业务，可执行安装插件操作，例如vue.use(vuex)
初始化注入,响应式数据（此时我们data，methods已经初始化完成了）
此时进入created函数，此时虽然data，methods中未操作dom的方法可以正常使用，，但是模板还未解析，也就是DOM结点还未渲染，对于DOM的操作都无法执行，在created钩子执行的业务为:发送axios请求。
接下来就是根据是否存在el，是否存在template标签渲染虚拟dom结点
进入beforeMount，此时虚拟DOM已经生成，但还未挂载到真实DOM上，也就是页面还未渲染，因此我们仍然无法获取DOM结点，此钩子一般没有业务逻辑。
beforeMount过后，虚拟DOM被挂在到真实DOM树上。
进入mounted，DOM树上已经存在结点，页面渲染成功，我们也可以执行操作DOM操作了，也可以执行发送请求等业务。
mounted过后，当响应式数据(data)发生变化时，页面重新渲染数据之前，beforeCreated执行了，页面渲染完过后，updated执行了，具体执行业务根据需求执行。
当vm.$destory()被调用时，在组件销毁之前，执行beforeDestroy函数，通常在此时解除一些全局或自定义事件（举例:一个父组件中有一个子组件为路由，子组件在全局添加了监听器，当路由切换的时候，子组件被销毁，如果不在beforeDestroy()中解除，监听器将会工作于父组件。）。
在生命周期销毁之后，执行destoryed函数。
两个隐藏的生命周期钩子
由于创建和销毁组件十分消耗浏览器性能，有时我们希望当组件进行路由切换的时候，不被销毁，缓存起来。
为了解决这个问题，我们可以用一个 &lt;keep-alive&gt; 元素将其动态组件包裹起来。被&lt;keep-alive&gt;包裹的组件将不会被销毁。
当路由组件被&lt;keep-alive&gt; 包裹当路由切换，Vue为我们提供了两个生命周期钩子，actived和deactived。
当一个组件从显示到隐藏的时候，触发deactived()钩子，当路由组件从隐藏到显示的时候，触发actived钩子，由于&lt;keep-alive&gt; 包裹的组件不会被销毁和重复创建,这两个钩子可以做到代替mounted()和destoryed()钩子执行业务的效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb18d545c9746d77bdcbdc26d1156770/" rel="bookmark">
			A记录、CNAME
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		域名解析 域名解析就是国际域名或者国内域名以及中文域名等域名申请后做的到IP地址的转换过程。IP地址是网路上标识您站点的数字地址，为了简单好记，采用域名来代替ip地址标识站点地址。域名的解析工作由DNS服务器完成。
A记录 A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。
CNAME记录 CNAME记录就是把域名解析到另外一个域名。但这个域名也要做一个A记录。
服务商提供CNAME给客户，客户的域名指向服务商提供的CNAME,这样服务商就可以自由变换CNAME指向的IP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06dddb4a89748d59e9036362821d89bb/" rel="bookmark">
			Spring Boot依赖注入之Lookup注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Autowired等注解 Spring依赖注入之@Autowired、@Qualifier、@Primary、@Priority注解用法Spring依赖注入之@Autowired、@Qualifier、@Primary、@Priority注解原理（上）Spring依赖注入之@Autowired、@Qualifier、@Primary、@Priority注解原理（下） Value注解 依赖注入之@Value原理（整体流程）依赖注入之@Value原理（获取value值）依赖注入之@Value原理（placeholder解析）依赖注入之@Value原理（SpEL表达式解析） Lookup注解 Spring Boot依赖注入之Lookup注解 当采用@Autowired注解对单例bean注依赖的原型bean时，会由于单例bean只会创建一次，导致依赖的原型bean也只会注入一次，@Lookup注解可以较为优雅的解决此类问题
1、Lookup注解的使用 假如有个原型bean定义如下
@Component @Scope(DefaultListableBeanFactory.SCOPE_PROTOTYPE) public class ProtoTypeBean { } 另一个单例bean的func方法需要使用这个原型bean，如下
@Component public class SingletonBean { public void func() { // ProtoTypeBean bean = ... // System.out.println(bean); } } 要如何获取bean？肯定不能使用@Autowired注解，因为只会注入一次。SingletonBean可以拿到BeanFactory，直接从BeanFactory中获取，如下
@Component public class SingletonBean implements BeanFactoryAware { private BeanFactory beanFactory; public void func() { ProtoTypeBean bean = beanFactory.getBean(ProtoTypeBean.class); System.out.println(bean); } @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException { this.beanFactory = beanFactory; } } 这种从BeanFactory获取bean的公共逻辑，也可以放到工具类中去，通过静态方法getBean获取Bean，如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06dddb4a89748d59e9036362821d89bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47564107f6c8f970dab1205f0d4e43e0/" rel="bookmark">
			全网最全HTML基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.HTML结构
2.HTML 文件基本结构
3.HTML常见标签
3.1注释标签
3.2标题标签：h1-h6
3.3 段落标签：p
3.4 换行标签：br
3.5格式化标签
3.6图片标签：img
3.8表格标签
3.9 合并单元格
3.10 列表标签
3.11表单标签
3.12无语义标签: div &amp; span
4.简单列表窗口实现：
​
5.简单个人简历的实现：
1.HTML结构 认识 HTML 标签 ，HTML 代码是由 "标签" 构成的。
形如:
&lt;body&gt;hello&lt;/body&gt; (1).标签名(body)放到&lt;&gt;中.
(2).大部分标签成对出现,&lt;body&gt;为开始标签,&lt;/body&gt;为结束标签.
(3).少数标签只有开始标签, 称为 "单标签".
(4).开始标签和结束标签之间, 写的是标签的内容.(hello everyone)
(5).开始标签中可能会带有 "属性". id 属性相当于给这个标签设置了一个唯一的标识符(身份证号码).
&lt;body id="myId"&gt;hello everyone&lt;/body&gt; 2.HTML 文件基本结构 &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;第一个HTML页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 你好,浏览者。 &lt;/body&gt; &lt;/html&gt; (1)html 标签是整个 html 文件的根标签(最顶层标签).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47564107f6c8f970dab1205f0d4e43e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b218e0d2680aade36ee6a5cb27d5e56c/" rel="bookmark">
			String.format()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录 一、占位符类型二、字符串和整数格式化三、日期格式化 从 Java 5.0 开始，String 类新增了一个强大的字符串格式化方法 format()。这个方法到现在用的人还是不多，实在是一种浪费。本文带你快速过一遍这个方法的功能，将来你要用到格式化文本的时候，可能就不需要再借用第三方类库或自己去实现了。 首先看一个简单例子：
String formatted = String.format("%s今年%d岁。", "小李", 30); // "小李今年30岁。" 这个方法第一个参数是格式串，后面的参数都是格式串的参数，用于替换格式串中的占位符。占位符以 “%x” 的形式表示，不同的参数类型要用不同的字母。后面会具体介绍。String.format() 返回值类型为字符串，也就是格式化的结果。 一、占位符类型 占位符 “%” 后面的字母决定了其接受的实际参数的类型。占位符类型有下面几种：
大写字母表示输出的字母都为大写。
我们平常用的最多的就是 %s、%d 和 %f，偶尔会用到 %t。本文篇幅有限，仅介绍这四种，剩下的请自行阅读 API 文档。
二、字符串和整数格式化 这里直接给出例子来说明：
// 补齐空格并右对齐： String.format("%10s, world", "Hello"); // 输出 " Hello, world" String.format("%8d", 123); // 输出 " 123" // 补齐空格并左对齐： String.format("%-10s, world", "Hello"); // 输出 "Hello , world" String.format("%-8d", 123); // 输出 "123 " // 补齐 0 并对齐（仅对数字有效） String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b218e0d2680aade36ee6a5cb27d5e56c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f120133b2fa1e4dc2bd19b3dbaa8c66e/" rel="bookmark">
			java 获取系统环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、设置所需要的环境变量。
2、Java代码获取
System.err.println(System.getenv("START_DATE")); 这样就可以取到了。但刚配置完有可能取不到 需要重启电脑 方可取到！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f755d01123c7691be8de048b18b45a/" rel="bookmark">
			Java8新特性：函数式接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 定义自定义函数式接口@FunctionalInterface注解 jdk自带函数式接口JDK 1.8 之前已有的函数式接口:JDK 1.8 新增加的函数接口： 使用实例 定义 函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。
函数式接口可以被隐式转换为 lambda 表达式。
Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。
自定义函数式接口 只要确保接口中有且仅有一个抽象方法即可。
@FunctionalInterface注解 与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注 解可用于一个接口的定义上。
接口当中抽象方法的 public abstract 是可以省略的，所以定义一个函数式接口很简单：
@FunctionalInterface interface GreetingService { void sayMessage(String message); } 那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：
GreetingService greetService1 = message -&gt; System.out.println("Hello " + message); jdk自带函数式接口 函数式接口可以对现有的函数友好地支持 lambda。
JDK 1.8 之前已有的函数式接口: java.lang.Runnablejava.util.concurrent.Callablejava.security.PrivilegedActionjava.util.Comparatorjava.io.FileFilterjava.nio.file.PathMatcherjava.lang.reflect.InvocationHandlerjava.beans.PropertyChangeListenerjava.awt.event.ActionListenerjavax.swing.event.ChangeListener JDK 1.8 新增加的函数接口： java.util.function java.util.function 它包含了很多类，用来支持 Java的 函数式编程，该包中的函数式接口有：
序号	接口 &amp; 描述 1	BiConsumer&lt;T,U&gt; 代表了一个接受两个输入参数的操作，并且不返回任何结果 2	BiFunction&lt;T,U,R&gt; 代表了一个接受两个输入参数的方法，并且返回一个结果 3	BinaryOperator&lt;T&gt; 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果 4	BiPredicate&lt;T,U&gt; 代表了一个两个参数的boolean值方法 5	BooleanSupplier 代表了boolean值结果的提供方 6	Consumer&lt;T&gt; 代表了接受一个输入参数并且无返回的操作 7	DoubleBinaryOperator 代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。 8	DoubleConsumer 代表一个接受double值参数的操作，并且不返回结果。 9	DoubleFunction&lt;R&gt; 代表接受一个double值参数的方法，并且返回结果 10	DoublePredicate 代表一个拥有double值参数的boolean值方法 11	DoubleSupplier 代表一个double值结构的提供方 12	DoubleToIntFunction 接受一个double类型输入，返回一个int类型结果。 13	DoubleToLongFunction 接受一个double类型输入，返回一个long类型结果 14	DoubleUnaryOperator 接受一个参数同为类型double,返回值类型也为double 。 15	Function&lt;T,R&gt; 接受一个输入参数，返回一个结果。 16	IntBinaryOperator 接受两个参数同为类型int,返回值类型也为int 。 17	IntConsumer 接受一个int类型的输入参数，无返回值 。 18	IntFunction&lt;R&gt; 接受一个int类型输入参数，返回一个结果 。 19	IntPredicate ：接受一个int输入参数，返回一个布尔值的结果。 20	IntSupplier 无参数，返回一个int类型结果。 21	IntToDoubleFunction 接受一个int类型输入，返回一个double类型结果 。 22	IntToLongFunction 接受一个int类型输入，返回一个long类型结果。 23	IntUnaryOperator 接受一个参数同为类型int,返回值类型也为int 。 24	LongBinaryOperator 接受两个参数同为类型long,返回值类型也为long。 25	LongConsumer 接受一个long类型的输入参数，无返回值。 26	LongFunction&lt;R&gt; 接受一个long类型输入参数，返回一个结果。 27	LongPredicate R接受一个long输入参数，返回一个布尔值类型结果。 28	LongSupplier 无参数，返回一个结果long类型的值。 29	LongToDoubleFunction 接受一个long类型输入，返回一个double类型结果。 30	LongToIntFunction 接受一个long类型输入，返回一个int类型结果。 31	LongUnaryOperator 接受一个参数同为类型long,返回值类型也为long。 32	ObjDoubleConsumer&lt;T&gt; 接受一个object类型和一个double类型的输入参数，无返回值。 33	ObjIntConsumer&lt;T&gt; 接受一个object类型和一个int类型的输入参数，无返回值。 34	ObjLongConsumer&lt;T&gt; 接受一个object类型和一个long类型的输入参数，无返回值。 35	Predicate&lt;T&gt; 接受一个输入参数，返回一个布尔值结果。 36	Supplier&lt;T&gt; 无参数，返回一个结果。 37	ToDoubleBiFunction&lt;T,U&gt; 接受两个输入参数，返回一个double类型结果 38	ToDoubleFunction&lt;T&gt; 接受一个输入参数，返回一个double类型结果 39	ToIntBiFunction&lt;T,U&gt; 接受两个输入参数，返回一个int类型结果。 40	ToIntFunction&lt;T&gt; 接受一个输入参数，返回一个int类型结果。 41	ToLongBiFunction&lt;T,U&gt; 接受两个输入参数，返回一个long类型结果。 42	ToLongFunction&lt;T&gt; 接受一个输入参数，返回一个long类型结果。 43	UnaryOperator&lt;T&gt; 接受一个参数为类型T,返回值类型也为T。 使用实例 Predicate 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4f755d01123c7691be8de048b18b45a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c36a6814ec7a5dfcc6a1ac6cd628489/" rel="bookmark">
			Vue 自定义指令 directives选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		directives选项中定义 指令
使用时添加v-前缀
全局注册
app.directive('xxx',{}) // vue2: Vue.directive('xxx',{}) 支持动态指令参数
v-xx:[abc]='xxx'
指令函数能够接受所有合法的 JavaScript 表达式。
如果方法只需要在 mounted 和 updated 的时间钩子触发
可以简写为单纯的回调函数
参数说明
第一个参数 为绑定的元素
第二个参数 为传递的对象
.arg 绑定的参数.value 等号后对应的值 在应用到组件上时，和非 prop 的 attribute不同，指令不会通过 v-bind=“$attrs” 被传入另一个元素。
当被应用在一个多根节点的组件上时，指令会被忽略，并且会抛出一个警告。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92beb28da0e714d652929318731822be/" rel="bookmark">
			百度地图API添加海量图标解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		采用百度地理信息可视化开源库mapv.js实现
以canvas形式绘画渲染海量图标，允许自定义图标点击事件及附加数据
参考文档：https://github.com/huiyan-fe/mapv/#readme
主要代码：
function run() { map.clearOverlays(); let count = document.getElementById("txtNum").value * 1; img.src = 'station.png'; //图标图片 data = []; let points = []; img.onload = function () { while (count--) { let fanNum = parseInt(Math.random() * 100); let lng = mapCenter.lng - 10 + Math.random() * 20; let lat = mapCenter.lat - 6 + Math.random() * 12; data.push({ geometry: { type: 'Point', coordinates: [lng, lat] }, deg: 0, icon: img, text: fanNum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92beb28da0e714d652929318731822be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c93e45668dae297231fb642c84dfe5/" rel="bookmark">
			华为交换机设备运行检查的常用命令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看子卡的运行状态，可以用命令display device。此命令可以查看子卡在位信息及状态信息是否正常。
2、查看设备复位情况，可以用命令display reboot-info。
3、查看设备温度，可以用命令display temperature all。各模块当前的温度应该在上下限之间，即“Current”的值在“Lower”和“Upper”之间。
4、查看设备的告警信息，可以用命令display alarm urgent。如果没有告警就会显示无。
5、查看cpu状态，可以用命令display cpu-usage。各模块的CPU占用率正常。如果出现CPU占用率长时间超过80%或者频繁出现超过80%的情况，建议重点关注。
6、查看内存占用情况，可以使用display memory-usage。
7、查看日志信息，可以用display logbuffer或者display trapbuffer。这两个命令为会经常用到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7759adceabe4048b5605c5eb8003847/" rel="bookmark">
			poi读取excel报错Your InputStream was neither an OLE2 stream, nor an OOXML stream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当 java 使用 poi 读取后缀是 xls 的 excel 类型文件时报错： Your InputStream was neither an OLE2 stream, nor an OOXML stream 报错的代码： Workbook wb = WorkbookFactory.create(is); 点进 create 方法里看下poi的源码：
public static Workbook create(InputStream inp) throws IOException, InvalidFormatException { if (!((InputStream)inp).markSupported()) { inp = new PushbackInputStream((InputStream)inp, 8); } if (POIFSFileSystem.hasPOIFSHeader((InputStream)inp)) { return new HSSFWorkbook((InputStream)inp); } else if (POIXMLDocument.hasOOXMLHeader((InputStream)inp)) { return new XSSFWorkbook(OPCPackage.open((InputStream)inp)); } else { throw new IllegalArgumentException("Your InputStream was neither an OLE2 stream, nor an OOXML stream"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7759adceabe4048b5605c5eb8003847/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/111/">«</a>
	<span class="pagination__item pagination__item--current">112/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/113/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>