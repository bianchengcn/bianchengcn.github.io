<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47f98ab8a8f714b13f3a332862c083a6/" rel="bookmark">
			OpenAI、斯坦福大学提出Meta-Prompting，有效提升语言模型的性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了研究如何提高语言模型的性能，使其更充分有效地输出对于提问的回答，来自斯坦福和 OpenAI 的学者强强联手，通过提出一种名为元提示（meta-prompting）的方法来深入探索。元提示通过让单个语言模型（如 GPT-4）充当中央控制器和多种专家角色，以实现对各种任务的准确和可靠回复。该方法结合了多个独立专家模型的优势和多样性，以便更好地解决复杂的任务和问题。
元提示的显著特点之一是其将复杂任务巧妙地分解为各个组件，然后汲取不同专业知识为每个组件提供支持，最终将各个专业领域的输出巧妙地整合在一起。让我们一起来看看究竟什么是元提示，而该方法又有着怎样的表现~
论文题目:
Meta-Prompting: Enhancing Language Models with Task-Agnostic Scaffolding
论文链接:
https://arxiv.org/abs/2401.12954
元提示（meta-prompting）的核心思想在于使用一个模型来协调和执行多个独立的提问，然后综合它们的回复以生成最终的答案。
从本质上讲，这种机制支持借助独立专业模型的能力和多样性，共同解决复杂任务或问题的集成方法。结合多个领域专业模型（即专家）的观点和结论，可能会产生更全面、强大和准确的解决方案。
▲图1 通过元提示增强 GPT-4 的有效性
举例来说，如果想通过应用元提示使 GPT-4 解决一个数学难题的话，通常可以采用三阶段的策略：
Meta Model 的输入指令：首先请教专业的“高级数学家”将难题分解为简单步骤；
Meta Model 输出：其次，将各步骤分配给专业领域的专家（比如让“程序员”来写代码）；
专家输出：最后，协调专家之间的交流并综合他们的输出。
因此，通过一个高层次的提示，GPT-4 可以同时充当两种角色：
Meta：管控过程的指挥者，扮演着任务的中枢，引导整个问题解决过程，提供指导和整体协调。
Expert：解决子任务的专家小组，通过多角度思考，为任务的提供各个专业领域的贡献。
在作者的设置下，专家只能由元模型调用。尽管在与新专家互动时，元模型可以选择综合各个专家的见解或共享一些文本给他们，但他们不能直接交互或沟通。这种限制是为了简化专家之间的交流，并将元模型置于操作的中心。
图 2 是元提示对话的可视化示例。元提示的独特之处在于，它将决定使用哪些提示和执行哪些代码片段交由 LLM 自身判断。
▲图2 元提示历史的示例
元提示 元提示（Meta-Prompting）是一种提高语言模型性能的方法，通过使用模型来协调和执行多个独立提问，待合成回复后生成最终的答案。这种方法原则上采用了集成方法，借鉴了多个专门模型（称为专家）的优势和多样性，以协同解决和处理具有多面性的任务或问题。
元提示的主要特点有：
使用模型协调和执行多个独立提问，然后合成它们的回复以生成最终答案。
元模型在整个过程中保持对整个历史和协调的全局视图。
动态选择上下文为专家提供新颖视角，同时元模型保留对整个过程的鸟瞰。
元提示可以启用单个黑盒模型充当中央控制器和各种专家小组，以生成更准确、可靠和连贯的回复。
▲算法1 元提示
如算法 1 所示，元提示主要包括以下步骤：
转换输入：使用转换函数 将原始提问放在合适的模板中，然后在 Meta Model 的初始指令中添加。
循环迭代：a) 提示 Meta Model：当前消息列表 指导 Meta Model 的下一个操作，要么直接回复提问，要么咨询特定领域的专家。b) 与领域专家模型互动：如果 Meta Model 没有返回结果，它可以调用任何专家并给予相应的指令，这些指令通过 从其输出中提取。此过程是隔离的，即每个专家只看到 Meta Model 选择与他们共享的内容，并根据这些内容作出回复。例如，如果问题涉及数学和历史，Meta Model 可能会咨询数学专家进行计算，并咨询历史专家提供历史背景。使用 模板提取专家的输出并附加上额外的指令。c) 返回最终回复：如果 Meta Model 的回复包含最终答案（通过特殊 token 突出显示），则使用 提取解决方案并返回。d) 错误处理：如果模型的回复 没有包含最终答案或没调用专家模型，则在消息列表 中附加错误消息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47f98ab8a8f714b13f3a332862c083a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe4c7e59352f7757b792c20064f046b5/" rel="bookmark">
			更新PerformanceDataCenter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System.Collections; using System.Collections.Generic; using UIFramework; using UnityEngine; using static PerformanceAdjusting; class PerformanceDataCenter { /// /// 将下发信号映射出来 id param /// public static Dictionary&lt;SignalEnum, Dictionary&lt;ToggleID, int&gt;&gt; toggleMapping = new Dictionary&lt;SignalEnum, Dictionary&lt;ToggleID, int&gt;&gt; { { SignalEnum.performanceadjusting_frontrearaxleoutputpower, new Dictionary&lt;ToggleID, int&gt; { { ToggleID.Toggle_0, 100 }, { ToggleID.Toggle_1, 90 }, { ToggleID.Toggle_2, 80 }, { ToggleID.Toggle_3, 70 }, { ToggleID.Toggle_4, 60 }, { ToggleID.Toggle_5, 50 }, { ToggleID.Toggle_6, 40 }, { ToggleID.Toggle_7, 30 }, { ToggleID.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe4c7e59352f7757b792c20064f046b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8c015342895cb549f323120206007fd/" rel="bookmark">
			更新ToggleController
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System; using System.Collections; using System.Collections.Generic; using TMPro; using UIFramework; using UnityEngine; using UnityEngine.UI; using DG.Tweening; using static PerformanceAdjusting; using System.Linq; public class ToggleController { private SignalEnum _functionId = 0; private List&lt;Toggle&gt; _toggles; private List&lt;Text&gt; _texts; Action&lt;int, List&lt;Text&gt;&gt; _handle; private int _lastIndex = 0; private bool _rebound = false; public ToggleController(SignalEnum funcid, List&lt;Toggle&gt; toggles, List&lt;Text&gt; texts, Action&lt;int, List&lt;Text&gt;&gt; handle) { _functionId = funcid; _toggles = toggles; _texts = texts; _handle = handle; for (int i = 0; i &lt; _toggles.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8c015342895cb549f323120206007fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bb6ab78ba55eaecaccf4e186674b8f6/" rel="bookmark">
			更新PerformanceAdjusting
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using TMPro; using UIFramework; using System; //using DG.Tweening; //using UniRx; using OpenCover.Framework.Model; using System.Linq; public class PerformanceAdjusting : MonoBehaviour { /// /// 性能调节 前后轴输出功率Toggle /// [SerializeField] private List&lt;Toggle&gt; _FrontRearAxleOutputPowerToggles; /// /// 性能调节 前后轴输出功率TextMeshProUGUI /// [SerializeField] private List&lt;Text&gt; _FrontRearAxleOutputPowerTxts; /// &lt;summary&gt; /// 性能调节 动力响应Toggle /// &lt;/summary&gt; [SerializeField] private List&lt;Toggle&gt; _DynamicResponseToggles; /// &lt;summary&gt; /// 性能调节 动力响应TextMeshProUGUI /// &lt;/summary&gt; [SerializeField] private List&lt;Text&gt; _DynamicResponseTxts; /// &lt;summary&gt; /// 性能调节 制动反馈Toggle /// &lt;/summary&gt; [SerializeField] private List&lt;Toggle&gt; _BrakeFeedbackToggles; /// &lt;summary&gt; /// 性能调节 制动反馈TextMeshProUGUI /// &lt;/summary&gt; [SerializeField] private List&lt;Text&gt; _BrakeFeedbackTxts; / &lt;summary&gt; / 性能调节 转向手感Toggle / &lt;/summary&gt; //[SerializeField] private List&lt;Toggle&gt; _SteeringFeelToggles; / &lt;summary&gt; / 性能调节 转向手感TextMeshProUGUI / &lt;/summary&gt; //[SerializeField] //private List&lt;TextMeshProUGUI&gt; _SteeringFeelTxts; / &lt;summary&gt; / 性能调节 悬架阻尼Toggle / &lt;/summary&gt; //[SerializeField] private List&lt;Toggle&gt; _SuspensionDampingToggles; / &lt;summary&gt; / 性能调节 悬架阻尼TextMeshProUGUI / &lt;/summary&gt; //[SerializeField] //private List&lt;TextMeshProUGUI&gt; _SuspensionDampingTxts; / &lt;summary&gt; / 性能调节 车身稳定系统Toggle / &lt;/summary&gt; //[SerializeField] private List&lt;Toggle&gt; _BodyStabilizationSystemToggles; / &lt;summary&gt; / 性能调节 车身稳定系统TextMeshProUGUI / &lt;/summary&gt; //[SerializeField] //private List&lt;TextMeshProUGUI&gt; _BodyStabilizationSystemTxts; / &lt;summary&gt; / 性能调节 能量回收系统Toggle / &lt;/summary&gt; //[SerializeField] private List&lt;Toggle&gt; _EnergyRecoverySystemsToggles; / &lt;summary&gt; / 性能调节 能量回收系统TextMeshProUGUI / &lt;/summary&gt; //[SerializeField] //private List&lt;TextMeshProUGUI&gt; _EnergyRecoverySystemsTxts; / &lt;summary&gt; / 性能调节 超强冷却系统Toggle / &lt;/summary&gt; //[SerializeField] private List&lt;Toggle&gt; _SuperCoolingSystemToggles; / &lt;summary&gt; / 性能调节 超强冷却系统TextMeshProUGUI / &lt;/summary&gt; //[SerializeField] //private List&lt;TextMeshProUGUI&gt; _SuperCoolingSystemTxts; private ToggleController _FrontRearAxleOutputPowerController; private ToggleController _DynamicResponseController; //private ToggleController _BrakeFeedbackController; //private ToggleController _SteeringFeelController; //private ToggleController _SuspensionDampingController; //private ToggleController _BodyStabilizationSystemController; //private ToggleController _EnergyRecoverySystemsController; //private ToggleController _SuperCoolingSystemController; //private TextMeshProUGUI _FrontRearAxleOutputPowerTxt; //private TextMeshProUGUI _DynamicResponseTxts; //private TextMeshProUGUI _BrakeFeedbackTxts; //private TextMeshProUGUI _SteeringFeelTxts; //private TextMeshProUGUI _SuspensionDampingTxts; //private TextMeshProUGUI _BodyStabilizationSystemTxts; //private TextMeshProUGUI _EnergyRecoverySystemsTxts; //private TextMeshProUGUI _SuperCoolingSystemTxts; public enum ToggleID { Toggle_0, Toggle_1, Toggle_2, Toggle_3, Toggle_4, Toggle_5, Toggle_6, Toggle_7, Toggle_8, Toggle_9, Toggle_10 } public Dictionary&lt;SignalEnum, Dictionary&lt;ToggleID, int&gt;&gt; toggleMapping; public class SuperSportNative { public static void SetInt(int id, int param) { Debug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bb6ab78ba55eaecaccf4e186674b8f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6719c484797b1de0e23b21d0d216d794/" rel="bookmark">
			在 python 中调用 C/C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 是一种很好用的胶水语言，利用Python的简洁和C++的高效，基本可以解决99%的问题了，剩下那 1% 的问题也就不是问题了，毕竟不是所有问题都可解。
一般的，Python和C++的交互分为这两种情况：
用C++扩展Python：当一个Python项目中出现了性能瓶颈时，将瓶颈部分抽离出来，用C++封装成一个Python可以调用的模块（so库）；将Python内嵌入C++：当一个C++项目中有部分功能预期将会经常变更需求，期望获得更高的灵活性时，将这部分功能用Python实现，在C++中进行调用。 这里讨论前者，在 python 中调用 C/C++ 代码的方法很多，这里记录三种方法的使用。
1 C/C++ 编译成可执行文件，python 通过 subprocess 调用 C/C++ 代码正常编写，然后编译成 exe/elf 格式的可执行文件，Python 利用 subprocess 调用该可执行文件即可。好处是改动小，不好是至少需要两个进程跑代码，而且 C/C++ 和 Python 通讯比较麻烦。
这种方法简单粗暴，不太好用，没什么好说的。
2 ctypes C/C++ 在编写代码的时候略微改动，然后编译成 dll/so 格式的动态库文件，Python 利用 ctypes 调用该库文件即可。好处一个进程内运行，C/C++ 侧改动小，坏处是 Python 侧需适配代码比较多。
ctypes 是 python 自带的一个库，可以用来调用 c/cpp 的动态链接库。使用 ctypes 调用 c++ 代码步骤如下：
编写 cpp 代码，将其编译成动态链接库（.so 或者 .dll 文件）。在 python 代码文件中导入 ctypes 库，并使用 ctypes.cdll.LoadLibrary() 方法加载动态链接库。使用 ctypes 定义 c++ 函数的参数类型和返回值类型，并调用 c++ 函数。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6719c484797b1de0e23b21d0d216d794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/426e2a0b361440e30b65216a8193255f/" rel="bookmark">
			【数据分析】numpy基础第五天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Z-Score标准化Z-Score应用示例 Min-Max归一化Min-Max应用示例 总结 前言 第五天是我们的numpy学习计划中的最后一天。
在数据处理和数据分析中，数据预处理是非常重要的一步。我们不可能完全靠肉眼来分析数据，总会有用到各种算法模型的时候，例如使用聚类、回归分析。
如果原来的数据非常“肮脏”，不规整，我们将会得到一个不可靠的糟糕结果，此时我们需要用两种十分常用的数据预处理手段来清洗我们的数据。
今天仅仅包括如下两个内容：
Z-Score标准化Min-Max归一化 Z-Score标准化 Z-Score标准化是一种常见的数据标准化方法，它通过对原始数据进行均值和标准差的线性变换，将数据变换为均值为0、标准差为1的分布。
Z-Score标准化后的数据，通常在机器学习模型上表现更好，并且，我们可以根据Z-Score标准化后的数据来去除异常值。
具体的标准化公式如下：
X standardized = X − X ˉ σ X_{\text{standardized}} = \frac{{X - \bar{X}}}{{\sigma}} Xstandardized​=σX−Xˉ​
其中， X s t a n d a r d i z e d X_{standardized} Xstandardized​表示标准化后的数据， X X X表示原始数据， X m e a n X_{mean} Xmean​表示原始数据的均值， X s t d X_{std} Xstd​表示原始数据的标准差。
关于Z分数（Z-Score）：
其实Z-Score标准化，就是数据计算成对应的Z分数，我们可以利用Z分数进行异常值处理，如果Z分数大于某一个阈值(通常 ± 2)，则认为它是异常值，进行丢弃。
使用Z分数处理异常值需要满足正态分布的假设。Z分数越大，就代表它越接近正态分布的右侧，Z分数越小，就代表它越接近正态分布的左侧，对于那些及其右侧或者及其左侧的数据，因为很可能是错误的数据，所以视为异常值。
Z = X − X ˉ σ Z = \frac{{X - \bar{X}}}{{\sigma}} Z=σX−Xˉ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/426e2a0b361440e30b65216a8193255f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d66130f255e7f2f398483fc047ba49c7/" rel="bookmark">
			Android Automotive：在路上释放 Android 操作系统的力量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Automotive：在路上释放 Android 操作系统的力量 Android 在汽车行业的历程车载信息娱乐系统 (IVI) 的演变汽车中的 Android：演变和进步Android 汽车操作系统的崛起Polestar 2：开创 Android 汽车体验Android 开源项目 (AOSP) 及其他项目 Google 汽车服务 (GAS)：提升车内体验使用 GAS 运营：许可证要求和质量标准每单位许可证质量标准和测试满足质量标准的好处 Android汽车架构应用框架Android 汽车系统服务硬件抽象层 (HAL)板级支持包 (BSP)AIDL 和 HIDL Project Treble 和 Android 汽车操作系统Android 开源项目 (AOSP) 架构高音组件 Android Automotive 中的模块化与 TrebleTreble 之前的 HAL直通 HAL粘合剂化的 HAL理想的 HAL详细架构 Android汽车操作系统在汽车中的架构Android 汽车操作系统 (AAOS) 详细架构视图 车辆HAL系统属性标识符扩展车辆财产VHAL 接口（IVehicle）VHAL回调接口 属性监控和通知`IVehicle::subscribe``IVehicleCallback::onChange``ChangeMode`枚举 汽车服务车管家 汽车管理器界面：简要概述属性_服务：权限和安全代码和实现 信息服务：权限和安全代码和实现 CAR_UX_RESTRICTION_SERVICE：实现和代码：CarUxRestrictionsManager.java CarService的设计结构汽车属性和权限了解汽车属性汽车权限 汽车应用程序第三方汽车应用程序Android 汽车开发适用于 Android 汽车服务开发的汽车 AVDSDK和系统镜像AVD配置 外视系统（EVS）问题挑战解决方案那么，什么是外视系统（EVS） 建筑学电动车应用电动车管理器EVS HIDL 接口内核驱动程序 典型控制流程显示共享 — EVS 优先级和机制EVS 优先于主显示器抓住显示器示例场景 — 倒档没有同时显示内容 汽车音响车辆音频有何特别之处？许多具有特殊行为的音频通道关键提示音和警告声音频通道之间的交互很多扬声器噪音振动温度 汽车声音和流媒体逻辑流物理流Android 应用程序声音外部声音上下文巴士音频投掷器 音频上下文音频使用音频上下文 鸣响和警告Android 在汽车音响中的作用早期音频路径的缺失Android 之外的监管声音安全关键考虑因素未来之路：安全与技术整合 结论 https://medium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d66130f255e7f2f398483fc047ba49c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f0097f55a2361a3c0886935fdbfa91c/" rel="bookmark">
			obsidian阅读pdf和文献——与zotero连用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
【基于Obsidian的pdf阅读、标注，构建笔记思维导图，实现笔记标签化、碎片化，便于检索和跳转】
工作流：如何在Obsidian中阅读PDF - Eleven的文章 - 知乎
https://zhuanlan.zhihu.com/p/409627700
操作步骤 基于Obsidian的pdf阅读、标注，构建笔记思维导图，实现笔记标签化、碎片化，便于检索和跳转 - Jason Liang的文章 - 知乎
https://zhuanlan.zhihu.com/p/438755703
弃坑，采用联动zotero解决
联动zotero解决 Obsidian+Zotero打造最强科研工具链 - 深度学习可好玩了的文章 - 知乎
https://zhuanlan.zhihu.com/p/639325772
b站
【科研生产力：Obsidian&amp;Zotero高效阅读文献】 https://www.bilibili.com/video/BV1HY411t7tB/?share_source=copy_web&amp;vd_source=dab83d5b330f632d6bccec4d78fd0119
zotero如何做内部笔记 Zotero Better Notes - 罗小罗同学的文章 - 知乎
https://zhuanlan.zhihu.com/p/663491418
Zotero 与 Obsidian excalidraw 【【从零开始学OB】—— Zotero 与 Obsidian excalidraw 梦幻联动，让读文献也可以更“好看”】 https://www.bilibili.com/video/BV1Pc411b74G/?share_source=copy_web&amp;vd_source=dab83d5b330f632d6bccec4d78fd0119
重点！——综上 自己最后选择的方案 【科研生产力：一个比Mdnotes更丰富的Zotero&amp;Obsidian协同插件| Zotero integration |支持图片与跳转链接】 https://www.bilibili.com/video/BV1jF411A7d6/?share_source=copy_web&amp;vd_source=dab83d5b330f632d6bccec4d78fd0119
【科研生产力：Obsidian&amp;Zotero高效阅读文献】 https://www.bilibili.com/video/BV1HY411t7tB/?share_source=copy_web&amp;vd_source=dab83d5b330f632d6bccec4d78fd0119
这俩同一个up：
第一个
流程可以简化为Zotero管理文献并阅读——提取笔记到Obsidian——Obsidian
dataview对文献进行总结；提取笔记可以用自带的导出到markdown、mdnotes插件（zotero)、zotero
integration插件(obsidian)
详细步骤： 1 安装zotero integration插件
此处假如遇到bug：
2 下载zotero插件：better-bibtex
retorquere/zotero-better-bibtex：让Zotero对我们LaTeX坚持有效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f0097f55a2361a3c0886935fdbfa91c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/164c11bd7a4523dd083ec1a2a311944b/" rel="bookmark">
			WordPress块编辑器（Gutenberg古腾堡）中如何添加脚注？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WordPress默认自带的块编辑器​（Gutenberg古腾堡编辑器）本身就自带添加脚注功能，不过经典编辑器不行。如果想要在WordPress中添加更加专业的脚注，建议使用Modern Footnotes插件，具体介绍及使用请参考『WordPress站点如何添加专业的脚注？推荐使用Modern Footnotes插件&lt;』文章：
今天boke112百科就跟大家介绍一下WordPress块编辑器（Gutenberg古腾堡）中如何添加脚注，具体操作步骤如下：
1、进入WordPress后台，在文章编辑页面，将光标定位在需要插入脚注的地方，然后点击下拉箭头并点击“脚注”。
2、此时，文章底部已自动添加了一个脚注块，并自动定位到该位置，接着我们只需要输入脚注的内容即可。
比如我们输入脚注的说明，具体如下图红线所示：
3、完成文章的编辑和该文章的脚注添加后，点击右上角的【发布】或【更新】按钮。
此时，我们访问该篇文章就可以看到在我们插入脚注的地方多了一个上标数字1，表示该文第一个脚注，点击该数字1就会自动跳转到文末对应的脚注内容。
在文末的脚注内容最后可以看到有一个返回箭头，点击该箭头就会自动跳转到对应脚注序号的地方，非常方便。
一般的WordPress站点很少用到脚注，不过如果你的站点发布的都是专业的内容，那么对于一些名词，或缩写，或内容来源等，那么通过添加相应的脚注来进一步说明，会为你的文章加分不少哦！
来源：https://boke112.com/post/11826.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4397bc1742191c4dab524f9ebd16328c/" rel="bookmark">
			【前端web入门第二天】02 表单-input标签-单选框-多选框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表单 文章目录:
1.input标签基本使用 1.1 input标签占位文本1.2 单选框 radio 1.3 多选框 checkbox 作用:收集用户信息。
使用场景:
登录页面注册页面搜索区域
1.input标签基本使用 input标签type属性值不同，则功能不同。
&lt;input type="..."&gt; type属性值说明text文本框,用于输入单行文本password密码框radio单选框checkbox多选框file上传文件 样例代码如下:
&lt;!-- 特点：输入什么就显示什么 --&gt; 文本框：&lt;input type="text"&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 特点：输入什么都是以 点 的形式显示 --&gt; 密码框：&lt;input type="password"&gt; &lt;br&gt;&lt;br&gt; 单选框：&lt;input type="radio"&gt; &lt;br&gt;&lt;br&gt; 多选框：&lt;input type="checkbox"&gt; &lt;br&gt;&lt;br&gt; 上传文件：&lt;input type="file"&gt; 效果如下:
1.1 input标签占位文本 登入界面文本框中的提示信息
文本框：&lt;input type="text" placeholder="请输入用户名"&gt; &lt;br&gt;&lt;br&gt; 密码框：&lt;input type="password" placeholder="请输入密码"&gt; &lt;br&gt;&lt;br&gt; 1.2 单选框 radio 常用属性:
属性名作用特殊说明name控件名称控件分组,同组只能选中一个checked默认选中属性名和属性值相同,简写为一个单词 举例代码:
&lt;input type="radio" name="gender" checked&gt;男 &lt;input type="radio" name="gender" &gt;女 效果如下:
1.3 多选框 checkbox 多选框也叫复选框。默认选中: checked。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4397bc1742191c4dab524f9ebd16328c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad3212ed7a08c0ba6caa91b564a9b501/" rel="bookmark">
			汽车网络安全管理体系框架与评价-汽车网络安全管理体系评价
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前 ， 随若汽车联网产品渗透率、 智能传感设备搭载率的提升， 以及汽车与通信、互联网等行业的融合创新发展， 汽车行业面临愈发严峻的网络安全风险， 对消费者人身财产安全、 社会安全乃至国家安全产生威胁， 是产业发展亟须解决的关键问题。 伴随若R155、 ISO/SAE 21434等国际法规标准的相继出台 ， 汽车网络安全管理体系的评价已成为行业焦点。
（一） VDA汽车网络安全管理体系审核红皮书 2020年11月 ， VOA针对R155法规制定审核红皮书 ， 可供行业进行参考。 其中 ， 审 核评价的方式包括单一检查项评价、 总体评价 ， 其中单一检查项评价的结果作为总体评价的依据。
单一检查项评价
审核员会针对每个单一检查项进行风险等级评估， 通过该评估对每个检查项的符合程度进行判断 ， 包括符合、 一般不符合、 严重不符合三类 ， 主要评价准则如下表3所示。
同时 ， VOA红皮书中对网络安全管理、 风险识别与风险评估更新、 风险管理、 产品全生命周期网络安全管理及外部供应商网络安全管理审核关注项进行了说明 ， 如图14所示。
总体评价
据单一检查项的评价结果 ， 输出总体的评价结果， 包括以下三种状态， 具体评价标准如表4所示：
审核通过：指通过审核；
审核失败：指需采取相应措施整改 ， 重新审核范围可以为在审核员定义的时间范国内实施的整改措施；
审核失败：指未通过审核 ， 必须重新开展完整审核。
重新审核必须考虑上一次审核的结果。 若存在上次审核通过但本次审核 中未执行或执行不充分的措施将对当前审核的结果产生负面影晌。
（二） ISO PAS 5112道路车辆－网络安全工程审核指南 2022年3月31日正式发布的国际标准ISO PAS 5112道路车辆－网络安全工程审核指南在附录A中给出了针对ISO/SAE 21434标准要求的审核问卷的示例， 从网络安全管理 ， 持续的网络安全活动， 风险评估与方法， 概念与产品研发阶段 ， 后开发阶段 ， 分布式网络 安全活动等多个方面进行审核与评价。 下表为ISO PAS 5112道路车辆 － 网络安全工程审核指南附录A的部分内容：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b4f53e11b85d78c0d2b4d4e9a5c0dc9/" rel="bookmark">
			【misc | CTF】攻防世界 2017_Dating_in_Singapore
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天命：这次终于碰到了算是真正的misc题目了
下载附件，打开是PDF，我一开始以为是flag隐写在PDF里面了
虽然也不奇怪，应该是可以的，毕竟PDF有xss漏洞也是可以的
言归正传，打开PDF
看着新加坡的日历，我陷入了沉思，一脸懵逼
开始分析题目给的提示，一开始我还以为是密码学进来了
后来才发现是我想太多了
01081522291516170310172431-050607132027262728-0102030209162330-02091623020310090910172423-02010814222930-0605041118252627-0203040310172431-0102030108152229151617-04050604111825181920-0108152229303124171003-261912052028211407-04051213192625
按照 - 分割，能分割成12个月，切开两位数就会发现有规律可循
说实话，这题我愿称为misc的正宗题目，有脑洞有逻辑，贼好玩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec243f17195742a536de47654270121/" rel="bookmark">
			常量和C预处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考C Primer Plus第四章
文章目录 符号常量printf()函数和scanf()函数 printf()函数使用printf()printf()的转换说明修饰符 1.符号常量 C头文件limits.h和float.h分别提供了与整数类型和浮点类型大小限制相关的详细信息。头文件都定义了一系列供实现使用的符号常量。例如，limits.h头文件包含以下类型的代码：
#define IN_MAX +32767
#define IN_MIN -32768
这些符号常量代表int类型可表示的最大值和最小值。如果系统使用32位的int，该头文件会为这些符号常量提供不同的值。如果在程序中包含limits.h头文件，就可编写下面的代码：
printf("Maxmum int value on this system=%d\n", INT_MAX);
如果使用4字节的int，limits.h头文件会提供符合4字节int的INT_MAX和INT_MIN。
limits.h文件中的一些明示常量 符号常量含义CHAR_BITchar类型的位数CHAR_MAXchar类型的最大值CHAR_MINchar类型的最小值SCHAR_MAXsigned char类型的最大值SCHAR_MINsigned char类型的最小值UCHAR_MAXunsigned char类型的最大值SHAR_MAXshort类型的最大值SHAR_MINshort类型的最小值USHAR_MAXunsigned short类型的最大值INT_MAXint类型的最大值INT_MINint类型的最小值UINT_MAXunsigned int类型的最大值LONG_MAXlong类型的最大值LONG_MINlong类型的最小值ULONG_MAXunsigned long类型的最大值LLONG_MAXlong long类型的最大值LLONG_MINlong long类型的最小值ULLONG_MAXunsigned long long类型的最大值 类似的，float.h头文件中也定义一些明示常量，如FLT_DIG和DBL_DIG，分别表示float类型和double类型的有效数字位数。
float.h文件中的一些明示常量 符号常量含义FLT_MANT_DIGfloat类型的尾数位数FLT_DIGfloat类型的最少有效数字位数FLT_MIN_10_EXP带全部有效数字的float类型的最小负指数（以10为底）FLT_MAX_10_EXPfloat类型的最大负指数（以10为底）FLT_MIN保留全部精度的float类型最小正数FLT_MAXfloat类型的最大正数FLT_EPSILON1.00和比1.00大的最小float类型值之间的差值 2.printf()函数和scanf()函数 1.printf()函数 请求printf()函数打印数据的指令要与待打印数据的类型相匹配。例如，打印数据时使用%d，打印字符时使用%c。这些符号被称为转换声明，它们指定了如何把数据转换为可显示的形式。
转换说明及其打印的输出结果 转换说明输出%a浮点数、十六进制和p计数法（C99/C11）%A浮点数、十六进制和p计数法（C99/C11）%c单个字符%d有符号十进制整数%e浮点数，e计数法%E浮点数，e计数法%f浮点数，十进制计数法%g根据值的不同，自动选择%e或%f。%e格式用于指数小于-4或者大于或等于精度时%G根据值的不同，自动选择%E或%f。%E格式用于指数小于-4或者大于或等于精度时%i有符号十进制整数（与%d相同）%o无符号八进制整数%p指针%s字符串%u无符号十进制整数%x无符号十六进制整数，使用十六进制数0f%X无符号十六进制整数，使用十六进制数0F%%打印一个百分号 2.使用printf() #include&lt;stdio.h&gt; #define PI 3.14159 int main(void) { int number=7; float pies=12.75; int cost=7800; printf("The %d contestants ate %f berry pies.\n",number,pies); printf("The value of pi is %f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aec243f17195742a536de47654270121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d56f115f02c0a88fb7d2f6effd086b/" rel="bookmark">
			【机器学习】正则化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则化是防止模型过拟合的方法，它通过对模型的权重进行约束来控制模型的复杂度。
正则化在损失函数中引入模型复杂度指标，利用给W加权值，弱化了数据的噪声，一般不正则化b。
loss(y^,y)：模型中所有参数的损失函数，如交叉熵Regularizer：用超参数Regularizer给出w在总loss中的比例，即正则化的权重。w：需要正则化的参数 正则化分为L1正则化和L2正则化： L1正则化大概率会使很多参数变为0，因此该方法可通过稀疏参数，即减少参数的数量，降低复杂度。
L2正则化会使参数很接近但不为零，因此该方法可通过减小参数值的大小降低复杂度。
来源推导 对于模型权重系数 w 求解是通过最小化目标函数实现的，即求解：
使用 假如我们有非常多的特征，我们并不知道其中哪些特征我们要惩罚，我们将对所有的特征进行惩罚，并且让代价函数最优化的程序来选择这些惩罚的程度。记：
对线性回归：
对逻辑回归：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa1262f6b788f09210a0625596c0782/" rel="bookmark">
			如何使用YOLOv8训练自己的模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍如何用YOLO8训练自己的模型，我们开门见山，直接步入正题。
前言：用yolo8在自己的数据集上训练模型首先需要配置好YOLO8的环境，如果不会配置YOLO8环境可以参考本人主页的另一篇文章
提醒：使用GPU训练会大幅度加快训练，有英伟达GPU的一定要配置GPU训练环境，没有英伟达显卡的只能采用CPU训练，但是一般不建议。 （GPU、CPU训练环境的配置具体见上面的文章链接）
第一章节：准备好数据集 配置好YOLO8环境之后，需要准备好YOLO格式的数据集（也称txt格式），该数据集可以通过数据集标注软件 labelme、labelimg对图片进行拉框标注得到。经过标注软件标注好的yolo数据集的格式通常为:
class_id x y w h
class_id: 类别的id编号
x: 目标的中心点x坐标(横向) /图片总宽度
y: 目标的中心的y坐标(纵向) /图片总高度
w:目标框的宽度/图片总宽度
h: 目标框的高度/图片总高度
下图为一张图片按照yolo格式进行标注的txt标注文件 在进行训练之前，还需要对数据集进行划分，一般是按照7：2：1的比例划分训练集（train）、验证集（val）、测试集（test） 或者按照8：2的比例划分训练集与验证集。
提醒：用YOLO8训练自己的模型必须至少要把数据集划分出训练集与验证集，可以不划分测试集，训练集与验证集不可或缺，否则不能数据集进行模型训练。我这里只划分训练集与验证集，并且训练集与验证集应该是下面的目录结构
train
├── images
└── labels
val
├── images
└── labels
下面以葡萄叶片病虫害数据集为例，给出训练集、验证集目录结构的参考示例
在训练之前，我们不仅要把数据集划分成训练集、验证集，还需要给出类别标签yaml文件，该文件是YOLO8在训练过程中所必须的。也就是说，一个完整的，可以直接用于模型训练的数据集应该具有以下目录结构：
data.yaml的内容如下图所示： 其中train、val指定训练集与验证集的路径地址（最好写成绝对路径） nc代表该数据集有几个类别，我这里的葡萄叶片病虫害数据集有四个类别
names代表具体的类别名称。可以以数组的形式给出，但请注意类别名称需要以英文或数字呈现，不能含有任何特殊字符或者中文字符。
提醒：yaml文件是必须的，如果你拿到的数据集不含这个文件，那么你要按照上面的格式自己手动写了，书写时需要严格按照yaml文件的格式（冒号后面是有一个空格的）
第二章节：开始训练 搞深度学习，绝大部分都是在linux系统上进行炼丹的。考虑到有的读者可能对Linux不熟悉,本章节首先给出win系统训练教程，然后再给出linux系统训练步骤。
注意：在训练的过程中，有英伟达显卡的一定要用GPU训练，用CPU训练是特别缓慢的。
2.1 训练参数 训练方式有多种，可以通过py程序训练，也可以在命令行训练，我们这里以py程序训练为例：
无论是在win系统还是linux系统，训练的代码基本都是一致的，只有极个别参数会因为系统的不同出现差异。
from ultralytics import YOLO # 这里有三种训练方式，三种任选其一 #第一种：根据yaml文件构建一个新模型进行训练,若对YOLO8网络进行了修改（比如添加了注意力机制）适合选用此种训练方式。但请注意这种训练方式是重头训练(一切参数都要自己训练),训练时间、资源消耗都是十分巨大的 model = YOLO('yolov8n.yaml') # build a new model from YAML #第二种：加载一个预训练模型，在此基础之前上对参数进行调整。这种方式是深度学习界最最主流的方式。由于大部分参数已经训练好，我们仅需根据数据集对模型的部分参数进行微调，因此训练时间最短，计算资源消耗最小。 model = YOLO('yolov8n.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aa1262f6b788f09210a0625596c0782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062eb965036ca2bafc7ced5515b4a724/" rel="bookmark">
			三维重建（8）--SLAM系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、ORB-SLAM系统概述
1、概述
2、数据库
3、算法流程
二、跟踪 三、建图 四、回环修正 一、ORB-SLAM系统概述 1、概述 SLAM（Simultaneous Localization and Mapping）同步定位与建图，应用于机器人和自主车辆等自主系统的技术，能够在未知环境中同时定位自身位置并构建地图。SLAM在机器人、自动驾驶汽车、无人机等领域都有广泛应用。
ORB-SLAM作为常见的单目摄像机SLAM方案，由三个线程组成，分别是跟踪、建图、回环修正。
跟踪：确定当前帧位姿
建图：完成局部地图构建
回环修正：回环检测以及基于回环信息修正系统漂移
2、数据库 （1）快速图像匹配数据库
快速图像匹配数据库分为视觉词典和关键帧的词袋模型检索数据库。
视觉词典就是将一张图片中的若干特征部分拆解，获得一个包含有若干特征的视觉词典。
词袋模型检索数据库：利用TF-IDF算法，根据相似度，对于不同图片查询出与数据库中最相似的特征。
（2）三维重建的核心数据库
三维重建的核心数据库分为地图点、关键帧、共视图、本质树四类。
地图点：包含世界坐标系下3D坐标，观测方向即所有可以观测到该特征点的视图所产生的的观测方向的均值，ORB特征描述子（相对比之前SfM的sift算子），该点能被观测到的最大距离和最小距离。
关键帧：摄像机位姿，内参数，该帧被提取到的全部ORB特征描述子以及与地图点之间的对应关系。
共视图：一种无向有权图，节点是关键帧，两个节点共享的地图点数大于阈值则存在一条边，边的权重为共享地图点个数
本质图：共视图的子图，保留所有结点，边数量较共视图更少，目的是加速回环校正的计算。
3、算法流程 二、跟踪 跟踪：通过给定当前帧，从图像中提取ORB特征，根据上一帧估计当前帧姿态，估计失败时尝试全局重定位初始化位姿，并构建局部地图进一步优化位姿，并确定是否设置为关键帧。
ORB特征提取：参见ORB特征提取详解-CSDN博客
地图初始化：
初始位姿估计：
局部位姿优化：
关键帧获取：
三、建图 建图：完成局部地图构建，包括对关键帧的插入，验证最近生成的地图点并进行筛选，然后生成新的地图点，使用局部捆绑调整（只调整世界坐标系下三维点，不改变摄像机位姿），最后对插入的关键帧进行筛选，去除多余的关键帧。
关键帧插入： （1）更新共视图，增加新的结点，更新共视图连接关系
（2）更新生成树的节点关系
（3）计算该新增关键帧的词袋表示，为新建地图点做准备
地图点剔除：
若实际观测比例大于理论值的25%，且地图点创建后，连续的三个关键帧都可以观测到，则保留该新增地图点。
若任何时间连续观测的关键帧数均小于3，则剔除该点。
新地图点生成：
对于当前帧没有被匹配的特征点做如下处理：
（1）在共视图中选取20帧共视程度最高且基线宽度大于某阈值的关键帧进行特征点匹配与三角化，对重构结果进行尺度、重投影误差、视差不宜过小正向深度的检验。
（2）通过检验的点投影到其他视图中，若匹配成功则建立地图和关键帧特征点的对应关系。
局部地图优化：
当前帧及共视关键帧，及其所看到的的所有世界坐标系下的地图点，参与局部BA优化。
局部BA优化只优化地图点的位置，但摄像机位姿在优化过程中固定不变。
局部BA优化方法：
局部关键帧剔除：
保证场景不发生变化的情况下，如果当前帧的90%的地图点都可以被至少其他三个关键帧在相同或更精细的尺度观测到，那么该关键帧被剔除。
通过局部关键帧剔除，可以有效的控制关键帧数量，以此来减少参数数量，提高运算效率。
四、回环修正 回环修正：包含闭环检测和闭环校正两步，闭环检测使用词袋模型找到闭环图片，然后通过Sim3算法去计算相似变换。闭环校正主要是闭环融合和Essential Graph的图优化。
回环候选帧检测： 计算Sim3变换：
回环融合：
位姿优化： Reference：https://www.bilibili.com/video/BV1fa411r7hr/?spm_id_from=333.999.0.0&amp;vd_source=2152dec20715e478285cc87cc31201ed 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e2ac523d3b16e01488885b4691b447/" rel="bookmark">
			网络编程套接字(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UDP数据报套接字编程 API介绍 DatagramSocket DatagramSocket是UDP的Socket,用于发送和接收数据报.
操作系统中有一类文件,就叫做socket文件(普通文件/目录文件:在硬盘上的)
socket文件:抽象的表示了网卡这样的硬件设备
DatagramSocket就是对socket文件进行读写,也就是借助网卡发送数据.
通过网卡发送数据,就是写socket文件;通过网卡读取数据,就是读socket文件.
DatagramSocket构造方法:
方法签名方法说明DatagramSocket() 创建一个UDP数据报套接字的Socket,绑定到本机
任意一个随机端口(一般用于客户端)
DatagramSocket(int port) 创建一个UDP数据报套接字的Socket,绑定到本机
指定的端口(一般用于服务端)
DatagramSocket方法:
方法签名方法说明void receive(DatagramPacket p) 从此套接字接收数据报(如果没有收到数据报,该
方法会阻塞等待)
void send(DatagramPacket p)从此套接字发送数据包(不会阻塞等待,直接发送)void close()关闭此数据报套接字 DatagramPacket UDP数据报,每次接收数据的基本单位,就是一个UDP数据报
DatagramPacket是UDP Socket发送和接收的数据报.
DatagramPacket构造方法:
方法签名方法说明DatagramPacket(byte[] buf, int length) 构造一个DatagramPacket以用来接收数据报,接收的
数据保存在字节数组(第一个参数buf)中,接收指定
长度(第二个参数length)
DatagramPacket(byte[] buf, int offset, int length,
SocketAddress address)
构造一个DatagramPacket以用来发送数据包,发送的
数据为字节数组(第一个参数buf)中,从0到指定长度
(第二个参数length).address指定目的主机IP和端口号
DatagramPacket方法:
方法签名方法说明InetAddress getAddress() 从接收的数据报中,获取发送端主机IP地址;
或从发送的数据报中,获取接收端主机IP地址
int getPort() 从接收的数据报中,获取发送端主机的端口号;
或从发送的数据报中,获取接收端主机的端口号
byte[] getData()获取数据报中的数据 构造UDP发送的数据报时,需要传入SocketAddress,该对象可以使用InetSocketAddress来创建.
InetSocketAddress InetSocketAddress (SocketAddress的子类) 构造方法:
方法签名方法说明InetSocketAddress(InetAddress addr, int port)创建一个Socket地址,包含IP地址和端口号 代码示例 UDP Echo Server 下面以一个简单的回显服务器作为代码示例的程序(回显服务器:客户端发啥请求返回啥响应)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91e2ac523d3b16e01488885b4691b447/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b7cd7b9c972dca2acd9fdd6e221f21/" rel="bookmark">
			阿里云发送短信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.阿里云文档地址
可以设置测试手机号
1.引入依赖
&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; 2.controller层代码
// 发送短信，访问接口就向手机号发送短信，不处理任何业务 @GetMapping("/send/{phone}") public R sendMail(@PathVariable("phone") String phoneId) { String code = RandomUtil.getFourBitRandom(); Map&lt;String, Object&gt; param = new HashMap&lt;&gt;(); param.put("code", code); boolean ifSuccess = msmService.sendMail(code, phoneId); if (ifSuccess) { return R.ok(); } else { return R.error(); } } 3.service层代码
@Override public boolean sendMail(String code, String phoneId) { String securityCode; try { // 查询redis中是否已经有这个手机号对应的验证码了，避免重复发送验证码 if (StringUtils.isNotEmpty(redisTemplate.opsForValue().get(phoneId))) { return true; } // 发送短信 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09b7cd7b9c972dca2acd9fdd6e221f21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd659540c0eb94591be3712c25aa3ca/" rel="bookmark">
			UE5在VisualStudio升级后产生C&#43;&#43;无法编译的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		往期的虚幻引擎项目在VS更新后，编译时会报错，这一般出现在VS升级之后，UE对于VC++的编译器定位没有更新导致；
有出现如下问题：
问题1：
Running I:/EPCI/Epic Games/UE_5.3/Engine/Build/BatchFiles/Build.bat -projectfiles -project=“I:/GAME/PJ/我的项目2/我的项目2.uproject” -game -rocket -progress
Using bundled DotNet SDK version: 6.0.302
Running UnrealBuildTool: dotnet “…..\Engine\Binaries\DotNET\UnrealBuildTool\UnrealBuildTool.dll” -projectfiles -project=“I:/GAME/PJ/???2/???2.uproject” -game -rocket -progress
Log file: C:\Users\Fox\AppData\Local\UnrealBuildTool\Log_GPF.txt
Some Platforms were skipped due to invalid SDK setup: IOS, Android, Linux, LinuxArm64.
See the log file for detailed information
Generating VisualStudio project files:
Discovering modules, targets and source code for project…
Microsoft platform targets must be compiled with Visual Studio 2022 17.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfd659540c0eb94591be3712c25aa3ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a1f979e662b5dbf5a557052059531e/" rel="bookmark">
			VGGNet的结构和复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 结构以及模型退化问题 上述为VGGNet的结构图，左边是VGG16D的步骤 16代表16层，有参数的层，其他结构也是如此
对于这6个机构来说，D中的VGG16是最优的，而VGG19相比较而言，没有VGG16优，VGG16有16层（包括13个卷积层和3个全连接层），而VGG19有19层（包括16个卷积层和3个全连接层），对于出现了的模型退化问题，有几个原因：
1 网络层次越深，提取的特征越是高度抽象，这可以帮助模型理解复杂的、高级的模式。然而，如果网络过深，最后几层可能会从数据中提取过于抽象的特征，与具体的输入图像的关联性减弱，导致模型性能降低
2 在非常深的网络中，梯度在反向传播过程中可能会因为多层传递而变得非常小（梯度消失）或非常大（梯度爆炸），这会使得网络难以训练
3 更深的网络通常有更多的参数，这可能会使模型更容易发生过拟合，特别是当训练数据有限时
等等一些原因
2 代码复现（6种结构的复现） 只是简单的复现
import torch.nn as nn import torch class VggBlock(nn.Module): def __init__(self, in_channel, out_channel, n, use_11 = False, LRN = False) -&gt; None: super().__init__() layers = [] for i in range(n): if use_11 and (i == n-1): kernel_size = (1, 1) padding = 0 else: kernel_size = (3, 3) padding = 1 conv = nn.Sequential( nn.Conv2d(in_channel, out_channel, kernel_size=kernel_size, stride=1, padding=padding), nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46a1f979e662b5dbf5a557052059531e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/11/">«</a>
	<span class="pagination__item pagination__item--current">12/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/13/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>