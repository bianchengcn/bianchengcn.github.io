<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433e764b68ea716af3567c7d7c478398/" rel="bookmark">
			微信小程序跳转外链web-view用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序已经开放了，跳转外链的功能，意思是，在小程序里面可以直接跳转到一个h5页面中。 注意上图中的两个信息： 1.个人类型与海外。。。。不支持。 2.配置域名白名单。 基本的配置结束之后，我们就来开始用web-view这个插件了。 &lt;web-view src="https://hx.qq.com/zlkdatasys/mct/proj_1/download.shtml?media=20180320wx&amp;back=cururl"&gt; &lt;/web-view&gt; 由于这样写在页面上，这个链接会自动跳转。所以我另建了一个outurl文件夹，新建一个index.wxml页面将这个代码放在这个页面里面，然后在本页面点击‘下载手游’的时候通过路由跳转来达到目的。
&lt;navigator url="/pages/outurl/index"&gt; &lt;image src='../../images/btn-download.jpg' class='btn-download'&gt;&lt;/image&gt; &lt;/navigator&gt; 谢谢阅读，谢谢点赞！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e86f0f1213b2aba563149c259d4435/" rel="bookmark">
			C/S和B/S两种架构的区别和优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/S和B/S两种架构的区别和优缺点
一、C/S
1、 概念：典型的两层架构，全称Client/Server，客户端服务器端架构，，其客户端包含一个欧多个用户电脑上运行的程序，二服务器有两种：一种是数据库服务器，可短短通过数据库连接访问服务器端数据，另一种是Socket服务器端，服务器端的程序通过Socket与客户端的程序通信。
C/S架构可以看做是胖客户端架构，因为客户端需要实现大多数的业务逻辑和界面展示，这种架构的客户端需要承受很大的压力，因为显示逻辑和事务处理都包含在其中，通过与数据库的交互来达到持久化数据。
2、 优缺点：
优点：
2.1、C/S架构的界面和操作可以很丰富
2.2、安全性能容易保证，实现多层认证
2.3、因为一层交互，因此响应速度较快
缺点：
2.4、适用面窄，通常用在局域网中
2.4、用户群固定。由于程序安装需要安装才能使用，因此不适合面向不可知的用户
2.5、维护成本高，发生一次升级，在所有客户端程序都需要改变
二、B/S
1、概念
全称Browser/Server,即浏览器、服务器界都Browser指的是Web浏览器，极少数事务逻辑在前端实现，但主要事务逻辑在服务器端实现，Browser客户端，WebApp服务器端和DB端构成所谓的三层架构。B/S架构的系统无须特别安装，只有Web浏览器即可。
B/S架构中，显示逻辑交给了Web浏览器，事务处理逻辑在放在了WebApp上，这样就避免了庞大的胖客户端，减少了客户端的压力。因为客户端包含的逻辑很少，因此也被成为瘦客户端。
2 、优点和缺点
优点：
1）客户端无需安装，有Web浏览器即可。
2）BS架构可以直接放在广域网上，通过一定的权限控制实现多客户访问的目的，交互性较强。
3）BS架构无需升级多个客户端，升级服务器即可。
缺点：
1）在跨浏览器上，BS架构不尽如人意。
2）表现要达到CS程序的程度需要花费不少精力。
3）在速度和安全性上需要花费巨大的设计成本，这是BS架构的最大问题。
4）客户端服务器端的交互是请求-响应模式，通常需要刷新页面，这并不是客户乐意看到的。（在Ajax风行后此问题得到了一定程度的缓解）
三、B/S对C/S的改进和扩展
正如前文所说，C/S和B/S都可以进行同样的业务处理，但是B/S随着Internet技术的兴起，是对C/S结构的一种改进或者扩展的结构。相对于C/S，B/S具有如下优势：
1、分布性：可以随时进行查询、浏览等业务
2、业务扩展方便：增加网页即可增加服务器功能
3、维护简单方便：改变网页，即可实现所有用户同步更新
4、开发简单，共享性强，成本低，数据可以持久存储在云端而不必担心数据的丢失。
四、两者区别
二、C/S和B/S的不同点
1）比较大的差别
1、结构
C/S是两层架构，由客户端和服务器组成，而B/S是三层架构，由浏览器，WEB服务器和数据库服务器组成。
2、逻辑事务处理
C/S架构合理地让客户端和服务器承担一部分逻辑事务处理，使得服务器的负担减轻了，而且客户端也能进行一些数据处理和存储的功能。B/S架构的浏览器就是它的客户端，可是这个客户端只能进行一些简单的输入输出和信息发布共享的功能，主要的逻辑事务处理还是要靠服务器，所以服务器的负担很重。
3、工作原理
C/S架构是客户端和服务器直接相连，实现点对点的通信，B/S是浏览器通过WEB服务器向数据库服务器发送数据请求，实现多对多的通信。
4、响应速度
C/S架构的客户端和服务器直接相连，中间没有任何阻隔，所以相应速度快，尤其是在用户增多时更加明显。B/S架构相应速度慢，主要的重任在数据库服务器身上，由于B/S架构的无限扩展性，当用户激增，访问量庞大时，服务器相应速度慢，服务器存在瘫痪的危险。
5、成本
C/S架构开发时，硬件需要一次性购买，费用较高，且需要训练有素的技术人员，培训费用高，而且软件后期也需要不断投入大量资金。B/S架构只需要一次性投入几乎可以一劳永逸，有利于软件项目控制和IT黑洞。
6、维护、升级以及扩展
C/S架构一旦有业务的变更或要升级，客户端界面就要重新设计，需要投入大量的人力物力。软件维护也比较麻烦，需要专业人士进行维护。用户扩展也比较麻烦，需要安装客户端，对软硬件要求高。B/S架构的维护和升级都非常容易，只要更改页面内容或者增减页面即可，客户端几乎是零维护，只需要维护好服务器。所以相对来说更简易，方便。由于B/S可以随时随地的访问，所以极易扩展。
7、信息共享
C/S架构是建立在局域网之上的，面向的是可知的有限用户，信息共享只在小范围内。B/S架构建立在广域网之上，用户随时随地都可以访问，外部用户也可以访问，尤其是WEB技术的不断发展，B/S面对的是几乎无限的用户群体，所以信息共享性很强。
8、客户端界面
C/S架构可以针对不同的功能设计出不同的很有特色的用户界面，实现个性化。但是一旦业务改变就需要重新设计，很麻烦。B/S架构的用户界面很通用，不能针对用户突出个性，但是业务改变时只需要改变界面内容或者增减页面，很轻松就能实现。
2）小的差别
1、适用的网络
C/S架构是建立在局域网的基础之上的，局域网之间通过专用服务器提供连接提供服务。B/S架构是建立在广域网的基础之上，有更大的使用范围。
2、访问
C/S架构下，用户需要安装客户端才能够访问服务器，而B/S架构下，用户可以随时随地访问，只要有网有浏览器，方便快捷。 3、数据库连接类型
C/S采用的是ODBC连接，所以只要用户连接了数据库就一直保持连接不会断开，所以限制了用户数，而B/S采用的是JDBC连接，用户并不保持对数据库的连接，所以用户数几乎是无限的。
4、功能
C/S架构能够实现单一的复杂功能，如财政管理等，所以现在大多数比较大型的ERP系统仍是C/S架构，B/S架构的界面比较通用，所能处理的逻辑事务较少，所以功能较弱。
5、安全性
C/S架构建立在局域网之上，面向比较固定的用户，对安全的要求较高。B/S架构建立在广域网上，面对不可知人群，安全性差。
6、信息流向不同
C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低B/S信息 流向可变化, B-B B-C B-G等信息、流向的变化, 更像个交易中心。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6e86f0f1213b2aba563149c259d4435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed074df32cfc38cf3dc898d8827f87c5/" rel="bookmark">
			小程序image宽高自适应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.了解image组件
由于image有默认的固定的宽度和高度，这样我们在做图片自适应的时候，就不好做了。下面就来一起解决下
二.方法
(一).使用mode：widthFix
widthFix：宽度不变，高度自动变化，保持原图宽高比不变。
首先我们先设置image的mode为widthFix，然后给图片加一个固定rpx的宽度，比如：730rpx。
这样图片也可以自适应了。。因为小程序的rpx本身就是一个自适应显示的单位
(二).使用bindload绑定函数动态自适应。
我们可以给image绑定一个函数，这个函数，如上面的bindload说明一样，我们可以获取到原图的宽度和高度。
然后计算他们的宽高比率。。然后设置一个宽度大小（rpx），最后通过style动态设置image的宽高。代码如下：
1..编写页面结构index.wxml：
[html] view plain copy &lt;span style="font-family:'Comic Sans MS';font-size:18px;color:#333333;"&gt;&lt;image src="../uploads/2.jpg" bindload="imageLoad" style="width:{{imgwidth}}rpx; height:{{imgheight }}rpx;"&gt;&lt;/image&gt;&lt;/span&gt; 2.设置数据index.js
[html] view plain copy &lt;span style="font-family:'Comic Sans MS';font-size:18px;color:#333333;"&gt;//获取应用实例 var app = getApp() Page({ data: { screenWidth: 0, screenHeight:0, imgwidth:0, imgheight:0, }, onLoad: function() { var _this = this; wx.getSystemInfo({ success: function(res) { _this.setData({ screenHeight: res.windowHeight, screenWidth: res.windowWidth, }); } }); }, imageLoad: function(e) { var _this=this; var $width=e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed074df32cfc38cf3dc898d8827f87c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1189478c0df3b27da2c71c7dba4514/" rel="bookmark">
			使用sublime批量替换字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.批量替换当前文件字符
Find--Replace
2.批量替换文件夹下所有文件的某个字符
第一步：Find--Find in Files
第二步：File--Save All（此步骤要谨记）
OK,大功告成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/003cf984c013cccbfb75aa4c5010ac1e/" rel="bookmark">
			C&#43;&#43;标准库：bitset 用法整理  std::bitset是STL的一部分，准确地说，std::bitset是一个模板类，它的模板参数不是类型，而整形的数值（这一特性是ISO C&#43;&#43;2003的新特
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::bitset是STL的一部分，准确地说，std::bitset是一个模板类，它的模板参数不是类型，而整形的数值（这一特性是ISO C++2003的新特性），有了它我们可以像使用数组一样使用位。下面看一个例子： #include&lt;bitset&gt; std::bitset&lt;8&gt; bs;//它是一个模板，传递的参数告诉编译器bs有8个位。 我们接着看上面的代码，通过上面两行的代码我们得到一个bitset的对象bs，bs可以装入8个位，我们可以通过数组的下标运算符来存取： bs[0]=1;//把第0位设置为1 bs[3]=true;//把第3位设置为1,因为true可以转换为1 bs[7]=0;//这个大家都明白了 bitset被设计为开放的，也就是说一个bitset对象可以转换为其它类型的值，典型的，我们想把一个整数设置成具有特定的位模式，我们可以简单地把一个bitset转换为一个整数： unsigned long value=bs.to_ulong(); std::bitset&lt;32&gt; bs32(value); bs32[15]=1; value=bs32.to_ulong(); 此外bitset还可以也字符串互换，这样我们就可以更直观对bitset进行操作了，我只是简单地把我们想要的”01“字符串就可以了： std::bitset&lt;32&gt; bs("011010101001"); std::string str=bs.to_string(); //======================================= bitset&lt;n&gt; b; b有n位，每位都为0.参数n可以为一个表达式. 如bitset&lt;5&gt; b0;则"b0"为"00000"; bitset&lt;n&gt; b(unsigned long u); b有n位,并用u赋值;如果u超过n位,则顶端被截除 如:bitset&lt;5&gt;b0(5);则"b0"为"00101"; bitset&lt;n&gt; b(string s); b是string对象s中含有的位串的副本 string bitval("10011"); bitset&lt;5&gt; b0(bitval4); 则"b0"为"10011"; bitset&lt;n&gt; b(s, pos); b是s中从位置pos开始位的副本,前面的多余位自动填充0; string bitval("01011010"); bitset&lt;10&gt; b0(bitval5, 3); 则"b0" 为 "0000011010"; bitset&lt;n&gt; b(s, pos, num); b是s中从位置pos开始的num个位的副本,如果num&lt;n,则前面的空位自动填充0; string bitval("11110011011"); bitset&lt;6&gt; b0(bitval5, 3, 6); 则"b0" 为 "100110"; // 流 os &lt;&lt; b 把b中的位集输出到os流 os &gt;&gt;b 输入到b中,如"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/003cf984c013cccbfb75aa4c5010ac1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/532bbac002797a64345702a0b37cfbf2/" rel="bookmark">
			微信小程序一秒学会制作table表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家都知道微信小程序自身没有提供表格这个组件，但是今天的项目需求又出现了，所以只能模仿一个了。 效果图： 代码挺简单方便的： wxml:
&lt;view class='history-table-wrap'&gt; &lt;view class="table"&gt; &lt;view class="tr"&gt; &lt;view class="th th1"&gt;日期&lt;/view&gt; &lt;view class="th th2"&gt;时间&lt;/view&gt; &lt;view class="th th3"&gt;伤害&lt;/view&gt; &lt;/view&gt; &lt;view class="tr" wx:for="{{15}}"&gt; &lt;view class="td td1"&gt;2018/02/12&lt;/view&gt; &lt;view class="td td2"&gt;11:30&lt;/view&gt; &lt;view class="td td3"&gt;本次对海煞造成了100000点伤害&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; wxss:
.history-table-wrap{ position: absolute; width: 668rpx; height: 578rpx; left: 50%; margin-left: -334rpx; top: 70rpx; overflow-y: scroll; overflow-x: hidden; } /* 表格代码 */ .table{ border:1px solid #dadada; border-right:0; border-bottom: 0; width: 98%; margin-left: 1%; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/532bbac002797a64345702a0b37cfbf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f7e30606c614c9c07eaf97b013c401b/" rel="bookmark">
			构建风控评分卡模型介绍（WOE/KS/ROC)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整代码请关注公众号回复“评分卡”获得。
有酒有风 什么是评分卡（信贷场景中）
以分数的形式来衡量风险几率的一种手段对未来一段时间内违约/逾期/失联概率的预测通常评分越高越安全根据使用场景分为反欺诈评分卡、申请评分卡、行为评分卡、催收评分卡 为什么要开发评分卡
风险控制的一个环节，根据已有数据提供逾期概率指标参考 评分卡的特性
稳定性预测能力等价于逾期概率 评分卡开发的常用模型
逻辑回归决策树 基于逻辑回归的评分卡理论依据
一个事件发生的几率（Odds），是指该事件发生的概率与该事件不发生概率的比值。若一个客户违约概率为p，则其正常的概率为1-p，由此可得：
此时，客户违约的概率p可以表示为: 评分卡表达式为： 其中A、B为常数。由于log函数在(0→+∞)单调递增，所以当用户违约几率Odds越大时，Score评分越低。
通过给定 （1）某特定Odds时的Score值S0； （2）该特定Odds值翻倍时Score增加值PD0; 通过给定值S0与PD0带入评分卡表达式，可求得A、B。 通过以上分析，求该用户评分Score的问题则转化为求用户违约对数几率log(Odds)的问题。 依照二元逻辑回归构造预测函数 其中hθ(x)表示结果取1的概率。 推倒可得该事件的对数几率log(Odds)如下： 可以发现：在逻辑斯蒂回归模型中，输出Y=1的对数几率是输入条件x的线性函数。 回到信贷业务中 目标：寻找最理想的参数估计θ使得模型预测的概率相对已有样本最准确。 方法：损失函数最小化求得θ 逻辑回归的损失函数为对数损失函数（具体可由极大似然估计推倒）： 1.检验异常样本
根据对具体业务的理解和认识去除一些异常极端的数据。例如在对网页浏览量的分析，可能需要去除爬虫用户的浏览数据。
2.缺省字段的处理
数据样本的某些特征字段可能有缺省值，需根据缺省值多少与特征类型区分处理
缺省值很多时直接舍弃。作为特征加入的话，可能反倒带入噪声，影响最后的结果。非连续特征缺省量适中时，将Nan作为一个新类别加入至特征中连续特征缺省量适中时，考虑给定一个step(比如age，我们可以考虑每隔2/3岁为一个步长)，然后把它离散化，之后把NaN作为一个type加到属性类目中缺省值很少时利用填充的办法进行处理。例如用均值、中位数、众数填充，模型填充等变量筛选 单变量:归一化，离散化，缺失值处理
多变量：降维，相关系数，卡方检验，信息增益。决策树等。
这里讲一种行业经常用的基于IV值进行筛选的方式。
首先引入概念和公式。
IV的全称是Information Value，中文意思是信息价值，或者信息量。
求IV值得先求woe值，这里又引入woe的概念。
WOE的全称是“Weight of Evidence”，即证据权重。
首先把变量分组，然后对于每个组i，对于第i组有：
其中 是第i组坏客户数量（bad）， 是整体坏客户数量。同理，G就是good，好客户的意思。
woe反映的是在自变量每个分组下违约用户对正常用户占比和总体中违约用户对正常用户占比之间的差异；从而可以直观的认为woe蕴含了自变量取值对于目标变量（违约概率）的影响
而IV值得公式如下：
我们可以看到IV值其实是woe值加权求和。这个加权主要是消除掉各分组中数量差异带来的误差。
比如如果只用woe的绝对值求和，如果一些分组中，A组数量很小，B组数量很大（显然这样的分组不合理），这是B的woe值就很小，A组很大，求和的woe也不会小，显然这样不合理。比如：
最后我们可以根据每个变量VI值的大小排序去筛选变量。VI越大的越要保留。
变量处理 变量离散化：
评分卡模型用的是logistics，基本上都需要变量离散化后，效果才比较好。
离散化一般有几种方式：合并和切割。
合并：先把变量分为N份，然后两两合并，看是否满足停止合并条件。
切割：先把变量一分为二，看切割前后是否满足某个条件，满足则再切割。
而所谓的条件，一般有两种，卡方检验，信息增益。
关于这两种方法已经有很多介绍，不在赘述，大家可自行查阅相关资料。 模型优化 KS检验
KS检验主要是验证模型对违约对象的区分能力，通常是在模型预测全体信用样本的信用评分后，将样本按违约率与非违约率分成两部分，然后用KS统计量来检验两组样本信用评分是否具有显著性差异。
横轴是总体累积率，纵轴是各样本累积率
蓝色是坏客户的占比，红色是好客户的占比，两者都会随着横轴总体累积率的变化而变。但两者差距最大时，为KS值。
如在60%的时候KS值取得最大，此时将模型里面算出的P值（odds）排序,往下取60%时的P值，将60时的P值作为新的阈值，效果往往会有所提升。
模型检验
1.KS值图
上面说过，此处不再叙述。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f7e30606c614c9c07eaf97b013c401b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72eb5b411a18d0e0a853cfbadc919287/" rel="bookmark">
			《坦克世界》7周年活动，自动准点秒坦克
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var xhr = new XMLHttpRequest();
if(!xhr){
xhr = new ActiveXObject("Microsoft.XMLHTTP");
}
var aaa = "";
var t1 = window.setInterval(function(){
xhr.open("HEAD",location.href,true);
xhr.onreadystatechange = function(){
if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){
aaa = xhr.getResponseHeader("Date");
if(aaa == "Tue, 27 Mar 2018 10:59:35 GMT"){
window.clearInterval(t1);
for(var i = 0;i &lt; 120; i++){
setTimeout(limitExchange("3"),500);
}
}
}
}
xhr.send(null);
},500);
实在是手比脚笨，手脚很慢，只能写串代码来秒杀。
可以在谷歌浏览器的Console里运行，
每500毫秒利用响应头的时间与服务器对时，在指定的时间启动。
启动后首先关闭定时器，然后在接下来的1分钟内每隔500毫秒利用limitExchange()方法进行一次抢车。
参数为1是7201，参数为2是S81，参数为3是S1，参数为4是波兰车。
因为服务器强制性在开抢前掉线，然后就登不上去了，各大论坛里也没有谁说自己抢到过车。
所以我一辆车都没抢到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/139b73e4f47d05714426e3c682855757/" rel="bookmark">
			写一个python定时发送消息的脚本——每天跟你女盆友说晚安
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先 你要有个女朋友
效果
需要安装几个包
pip install wxpy
pip install wechat_sender
pip install requests
代码如下
from __future__ import unicode_literals from threading import Timer from wxpy import * from wechat_sender import Sender import time,requests bot = Bot(console_qr=2,cache_path='botoo.pk1') # 把consol_qr=2去掉，二维码是当做图片弹出来，否则则是以像素的方式打印出来，后面的参数是热登录， def get_news(): # 这里是把今日糍粑每日一句中拿过来的信息发送给你朋友 url = "http://open.iciba.com/dsapi/" r = requests.get(url) contents = r.json()['content'] translation = r.json()['translation'] return contents,translation def send_news(): try: ufriend = bot.friends().search(u'Mr-Lee')[0] # 朋友微信昵称（不是备注，不是微信账号） ufriend.send(get_news()[0]) ufriend.send(get_news()[1][5:]) ufriend.send(u'晚安') t = Timer(86400,send_news) # 86400是间隔时间（一天） t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/139b73e4f47d05714426e3c682855757/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6150a024fafbbd1dbcbb571d51c718a/" rel="bookmark">
			Mybatis select返回多个list，但为啥只有一条记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 本人做一个SSM项目，发现查询数据库数据，sql没有错，在Navicat中查询也是没有问题，但 返回数据只有一条，很奇怪，看网上教程，也都是差不多的教程，按理说我的mapper文件是没错的，因为其他一样的查询却可以查询出多条数据，同样的mapper写法。
解决方法 我对比了一下两者之间的sql差异，发现可能是在mapper中返回的字段比sql中多，再想是不是这个原因造成的，也有可能是主键id索引造成，结果就返回一条数据，本着动手的能力，本人就采取以下两种方案：
方案一在之前的select后面加上主键id &lt;resultMap id="orderResultMap" type="com.bean.PurchaseRecord"&gt; &lt;id column="id" jdbcType="SMALLINT" property="id" /&gt; &lt;result column="user_id" jdbcType="SMALLINT" property="userId" /&gt; &lt;result column="commodity_id" jdbcType="SMALLINT" property="commodityId" /&gt; &lt;result column="commodity_num" jdbcType="SMALLINT" property="commodityNum" /&gt; &lt;result column="create_time" jdbcType="TIMESTAMP" property="createTime" /&gt; &lt;result column="update_time" jdbcType="TIMESTAMP" property="updateTime" /&gt; &lt;association property="commodity" column="commodityId" javaType="com.bean.Commodity" jdbcType="SMALLINT" resultMap="GoodResultMap"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectForAll" resultMap="orderResultMap"&gt; SELECT purchase_record.id,purchase_record.commodity_id,commodity.url,commodity.title, commodity.price,purchase_record.commodity_num,purchase_record.create_time from commodity,purchase_record WHERE commodity.id=purchase_record.commodity_id &lt;/select&gt; 注意SELECT单词后面 添加了 id，查询结果正确。
方案二 去掉不返回的字段定义
在resultMap中定义了很多不返回的字段，比如 id，user_id等，于是去掉这些字段，测试也是正确的。 &lt;resultMap id="orderResultMap" type="com.bean.PurchaseRecord"&gt; &lt;result column="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6150a024fafbbd1dbcbb571d51c718a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf9398ebfe4c79463becb7ef492eda2/" rel="bookmark">
			java WebService接口调用，传JSON参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://zheyiw.iteye.com/blog/1571222
import java.io.IOException; import java.io.InputStream; import java.io.OutputStreamWriter; import java.net.HttpURLConnection; import java.net.URL; public class Copy_2_of_PostDemo { final static String url = ""; final static String params = "{\"id\":\"12345\"}"; /** * 发送HttpPost请求 * * @param strURL * 服务地址 * @param params * json字符串,例如: "{ \"id\":\"12345\" }" ;其中属性名必须带双引号&lt;br/&gt; * @return 成功:返回json字符串&lt;br/&gt; */ public static String post(String strURL, String params) { System.out.println(strURL); System.out.println(params); try { URL url = new URL(strURL);// 创建连接 HttpURLConnection connection = (HttpURLConnection) url .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caf9398ebfe4c79463becb7ef492eda2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b887076ffc482917689bee58e5fbce/" rel="bookmark">
			结构体变量的输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int main(void) { struct student { char *name; int num; int age; char sex; float score; }s1,s2; s1.name="Zhang ping"; s1.num=102; s1.age=23; printf("input sex and score\n"); scanf("%c %f",&amp;s1.sex,&amp;s1.score); s2=s1; printf("Name=%s\nNumber=%d\nAge=%d\n",s2.name,s2.num,s2.age); printf("Sex=%c\nScore=%f\n",s2.sex,s2.score); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b75d18ad4da6ecec83c45321c24f8fe/" rel="bookmark">
			网易游戏研发工程师笔试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
小Q最近被邀请去参加了网易最牛大脑的节目，挑战数字魔方的项目。
数字魔方为一个3x3的矩阵，矩阵中的每个数字都是（1…9）中的数字，且数字魔方中的数字可能重复。每4个相邻的数字我们称为1个子魔方，整个数字魔方共有4个子魔方（如下图所示）。每一次操作可以选择对某个子魔方顺时针旋转90度，180度或者270度。每个子魔方可以进行多次操作。
对子魔方1进行一次操作，顺时针旋转90度，180度，270度后的状态：
项目的挑战任务是，给定数字魔方的一个初始状态，以及一个目标状态，问最少操作多少次可以使得魔方从初始状态改变为目标状态。
小Q求助于你，希望你能告诉他完成任务的最少操作次数是多少，或者任务不可能完成。
输入描述:
输入的第一行为一个正整数T（T&lt;=20），表示测试数据组数。
接下来有T组数据。每组数据有6行。其中前3行为数字魔方的初始状态，后3行为目标状态。每个数据之后有一个空行。保证魔方中的数字为(1…9)中的数字。
输出描述:
对于每一组数据，输出一行，包含一个整数，为最少操作次数。如果不能完成目标，则输出-1。
示例1
输入
2
1 2 3
4 5 6
7 8 9
5 4 1
6 2 3
7 8 9
1 2 3
4 5 6
7 8 9
2 5 3
1 4 6
7 8 9
输出
3
1
说明
第一个样例为对子魔方1旋转90度，然后对子魔方2旋转90度，再对子魔方1旋转90度。
第二个样例为对子魔方1旋转270度。
1.思路：
将魔方状态转换成一组字符串，由于字符串长度为9，其可能出现的状态的总数一定（不会超过9的阶乘），因此采用BFS广度优先搜索，并使用哈希表来存储状态（若使用数组来存储状态，则需要自己实现“改进的康拓展开式”）；res初始化为-1，若得到答案，则break并返回res，若得不到答案，则返回-1.
2.代码：
#include &lt;iostream&gt; #include &lt;map&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;cstring&gt; #include &lt;unordered_map&gt; using namespace std; int movx[4]={0,1,3,4}; int fac[9]={1,1,2,6,24,120,720,5040,40320}; bool vis[362890]; //数组索引直接查找，时间复杂度O(1)，但需要用康拓展开，自己实现映射过程 //哈希表由红黑树实现，其查找时间复杂度为O(logN) //C++find函数查找，时间复杂度为O(N); struct node { string str; int step; }; int str2int(string str) { int cnt[9]={0}; int res=0; int i,j; for(i=0;i&lt;9;i++) cnt[str[i]-'1']++; for(i=0;i&lt;9;i++) { int x=str[i]-'1'; int y=0; for(j=0;j&lt;x;j++) y+=cnt[j]; res+=y*fac[8-i]; cnt[x]--; } return res; } string rorate_str_90(string str,int x) { char ch; int dx=movx[x]; ch=str[dx]; str[dx]=str[dx+3]; str[dx+3]=str[dx+4]; str[dx+4]=str[dx+1]; str[dx+1]=ch; return str; } string rorate_str_180(string str,int x) { char ch; int dx=movx[x]; ch=str[dx]; str[dx]=str[dx+4]; str[dx+4]=ch; ch=str[dx+1]; str[dx+1]=str[dx+3]; str[dx+3]=ch; return str; } string rorate_str_270(string str,int x) { char ch; int dx=movx[x]; ch=str[dx]; str[dx]=str[dx+1]; str[dx+1]=str[dx+4]; str[dx+4]=str[dx+3]; str[dx+3]=ch; return str; } string calc_str(const vector&lt;int&gt; num) { string str="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b75d18ad4da6ecec83c45321c24f8fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2844027995001d1c888fbded151535/" rel="bookmark">
			小程序画圆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建立两个canvas标签，先绘制底层的浅灰色圆圈背景，再绘制上层的红色进度条。
.wxml的代码如下：
1 2 3 4 5 6 7 8 9 &lt; view class = "wrap" &gt; &lt; view class = "circle-box" &gt; &lt; canvas class = "circle" style = "width:200px; height:200px;" canvas-id = "canvasArcCir" &gt; &lt;/ canvas &gt; &lt; canvas class = "circle" style = "z-index: -5; width:200px; height:200px;" canvas-id = "canvasCircle" &gt; &lt;/ canvas &gt; &lt; view class = "draw_btn" bindtap = "drawCircle" &gt;开始动态绘制&lt;/ view &gt; &lt;/ view &gt; &lt;/ view &gt; WXSS代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed2844027995001d1c888fbded151535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adf9ce740be7cfeb6da37e485472f896/" rel="bookmark">
			树中的叶子结点的个数 计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树中的叶子结点的个数 计算方法 在学习树的时候经常会遇到计算树中叶子结点的个数的题，比如现在有这样一道题
已知在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶子结点的个数为？ 解决这道题的思路是列出一个关于各个度的结点的等式，从而根据已知条件算出度为0的结点的个数，下面具体说一下解题方法：
设树T中的结点个数为n，度为0的结点的个数为n0，度为1的结点的个数为n1，度为2的结点的个数为n2，度为3的结点的个数为n3，度为4的结点的个数为n4，则有：
n = n0 + n1 + n2 + n3 + n4
设树T中的总边数为e，因为除了根节点的入度为0，其余各节点的入度都为1，则有：
e = n - 1 = n0 + n1 + n2 + n3 + n4 - 1
又因为，n0的出度为0，n1的出度为1，n2的出度为2，n3的出度为3，n4的出度为4，所以：
e = n0 * 0 + n1 * 1+ n2 * 2 + n3 * 3 + n4 * 4
综上所述:
e = n0 * 0 + n1 * 1+ n2 * 2 + n3 * 3 + n4 * 4 = n0 + n1 + n2 + n3 + n4 - 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adf9ce740be7cfeb6da37e485472f896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a1efca5d8ca8cb75d7de837578a705f/" rel="bookmark">
			linux 下setsockopt()，connect()相关错误代码的值及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		setsockopt()函数功能介绍 功能描述：
获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时，
选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选
项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。用法：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;
3.在send(),recv()过程中有时由于网络状况等原因，发收不能预期进行,而设置收发时限： int nNetTimeout=1000;//1秒 //发送时限 setsockopt(socket，SOL_S0CKET, SO_SNDTIMEO, (char *)&amp;nNetTimeout,sizeof(int)); //接收时限 setsockopt(socket，SOL_S0CKET, SO_RCVTIMEO, (char *)&amp;nNetTimeout,sizeof(int));
这样做在Linux环境下是不会产生效果的，须如下定义：struct timeval timeout = {3,0}; //设置发送超时
setsockopt(socket，SOL_SOCKET,SO_SNDTIMEO，(char *)&amp;timeout,sizeof(struct timeval)); //设置接收超时
setsockopt(socket，SOL_SOCKET,SO_RCVTIMEO，(char *)&amp;timeout,sizeof(struct timeval)); 参数： sock：将要被设置或者获取选项的套接字。 level：选项所在的协议层。 optname：需要访问的选项名。 optval：对于getsockopt()，指向返回选项值的缓冲。对于setsockopt()，指向包含新选项值的缓冲。 optlen：对于getsockopt()，作为入口参数时，选项值的最大长度。作为出口参数时，选项值的实际长度。对于setsockopt()，现选项的长度。 返回说明： 成功执行时，返回0。失败返回-1，errno被设为以下的某个值 EBADF：sock不是有效的文件描述词 EFAULT：optval指向的内存并非有效的进程空间 EINVAL：在调用setsockopt()时，optlen无效 ENOPROTOOPT：指定的协议层不能识别选项 ENOTSOCK：sock描述的不是套接字 参数详细说明： level指定控制套接字的层次.可以取三种值: 1)SOL_SOCKET:通用套接字选项. 2)IPPROTO_IP:IP选项. 3)IPPROTO_TCP:TCP选项.　optname指定控制的方式(选项的名称),我们下面详细解释　optval获得或者是设置套接字选项.根据选项名称的数据类型进行转换　选项名称　说明　数据类型 ======================================================================== SOL_SOCKET ------------------------------------------------------------------------ SO_BROADCAST　允许发送广播数据　int SO_DEBUG　允许调试　int SO_DONTROUTE　不查找路由　int SO_ERROR　获得套接字错误　int SO_KEEPALIVE　保持连接　int SO_LINGER　延迟关闭连接　struct linger SO_OOBINLINE　带外数据放入正常数据流　int SO_RCVBUF　接收缓冲区大小　int SO_SNDBUF　发送缓冲区大小　int SO_RCVLOWAT　接收缓冲区下限　int SO_SNDLOWAT　发送缓冲区下限　int SO_RCVTIMEO　接收超时　struct timeval SO_SNDTIMEO　发送超时　struct timeval SO_REUSERADDR　允许重用本地地址和端口　int SO_TYPE　获得套接字类型　int SO_BSDCOMPAT　与BSD系统兼容　int ======================================================================== IPPROTO_IP ------------------------------------------------------------------------ IP_HDRINCL　在数据包中包含IP首部　int IP_OPTINOS　IP首部选项　int IP_TOS　服务类型 IP_TTL　生存时间　int ======================================================================== IPPRO_TCP ------------------------------------------------------------------------ TCP_MAXSEG　TCP最大数据段的大小　int TCP_NODELAY　不使用Nagle算法　int ======================================================================== 返回说明： 成功执行时，返回0。失败返回-1，errno被设为以下的某个值 数值 EBADF：sock不是有效的文件描述词 9 EFAULT：optval指向的内存并非有效的进程空间 14 EINVAL：在调用setsockopt()时，optlen无效 22 ENOPROTOOPT：指定的协议层不能识别选项 92 ENOTSOCK：sock描述的不是套接字 88 connect() connect()用于建立与指定socket的连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a1efca5d8ca8cb75d7de837578a705f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec734b50f57386a6ee799d20b0f8d1f0/" rel="bookmark">
			窗口特征（Window Features）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 窗口特征（Window Features） channelmode=yes|no|1|0是否使用剧院模式显示窗口。默认为 no。directories=yes|no|1|0是否添加目录按钮。默认为 yes。fullscreen=yes|no|1|0是否使用全屏模式显示浏览器。默认是 no。处于全屏模式的窗口必须同时处于剧院模式。height=pixels窗口文档显示区的高度。以像素计。left=pixels窗口的 x 坐标。以像素计。location=yes|no|1|0是否显示地址字段。默认是 yes。menubar=yes|no|1|0是否显示菜单栏。默认是 yes。resizable=yes|no|1|0窗口是否可调节尺寸。默认是 yes。scrollbars=yes|no|1|0是否显示滚动条。默认是 yes。status=yes|no|1|0是否添加状态栏。默认是 yes。titlebar=yes|no|1|0是否显示标题栏。默认是 yes。toolbar=yes|no|1|0是否显示浏览器的工具栏。默认是 yes。top=pixels窗口的 y 坐标。width=pixels窗口的文档显示区的宽度。以像素计。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4f57bfd3a446ab0488113d4de8ee9c/" rel="bookmark">
			H5创建webApp保存到桌面。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		苹果端保存到桌面代码：（注意尺寸是57x57）
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"/&gt; &lt;meta content="telephone=yes" name="format-detection"/&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="white"/&gt; &lt;meta name="x5-fullscreen" content="true"/&gt; &lt;meta name="apple-touch-fullscreen" content="yes"/&gt; &lt;link href="css/pc/index.css" type="text/css" rel="stylesheet"/&gt; &lt;link rel="apple-touch-icon" sizes="57x57" href="img/logo-k.png"/&gt; &lt;link href="img/page-icon.png" rel="shortcut icon"/&gt; 试了一下发现安卓端用浏览器打开保存到桌面后图标显示不了，(chrome和UC）都不行。但是看了哔哩哔哩网站上的可以。
安卓端于是多了一行代码：
&lt;link rel="manifest" href="manifest.json"&gt; manifest.json文件内容如下（直接复制哔哩哔哩的）：
{ "name": "哔哩哔哩web版", "short_name" :"bilibili", "start_url": "index.html", "display": "standalone", "orientation": "portrait", "theme_color": "#de698c", "background_color": "#fff", "icons": [{ "src": "//s1.hdslb.com/bfs/static/mult/images/app_logo.png@36w_36h.png", "sizes": "36x36", "type": "image/png" }, { "src": "//s1.hdslb.com/bfs/static/mult/images/app_logo.png@48w_48h.png", "sizes": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c4f57bfd3a446ab0488113d4de8ee9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd4b123b0f9ced34fc159c4a79e96f5/" rel="bookmark">
			用关键字new创建对象 new都做了什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function Person () { this.name = name; this.age = age; this.job = job; this.sayName = function () { return this.name; };}var person = new Person(“tom”, 21, “WEB”);console.log(person.name); 使用关键字new创建新实例对象经过了以下几步：
1、创建一个新对象，如：var person = {};
2、新对象的_proto_属性指向构造函数的原型对象。
3、将构造函数的作用域赋值给新对象。（也所以this对象指向新对象）
4、执行构造函数内部的代码，将属性添加给person中的this对象。
5、返回新对象person。
var person = {};person._proto_ = Person.prototype; //引用构造函数的原型对象Person.call(person); //将构造函数的作用域给person,即：this值指向person 当采用构造器调用模式时，即使用new关键字去调用一个函数时，函数执行的方式会被修改。如果new是一个方法而不是一个运算符时，它可能会这样执行：
Function.methos(“new”, function () { //新创建一个对象，它继承了构造器的原型对象。 var that = Object.create(this.prototype); //此时，this是指向Function构造器的。 //调用构造器，绑定this对象到新对象that上 var other = this.apply(that, argument); //此时，this对象指向that对象。 //如果它的返回值不是一个对象，就返回新的对象。 return (typeof other === “object” &amp;&amp; other) || that;}); 以上代码，也可以说明在调用new关键字时，发生了什么事，或者说是调用new关键字创建的新对象经历了哪些步骤后拥有了函数的特性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bd4b123b0f9ced34fc159c4a79e96f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446df734c60ae4e859bd47e881b3eef8/" rel="bookmark">
			Android 实现添加Icon到桌面功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开发了一款游戏,内容主要是以WebView加载H5.最近增加了一个添加游戏到桌面的功能.
public void addShortcut(final Activity cx, final String name) { final Intent intent = new Intent("com.android.launcher.action.INSTALL_SHORTCUT"); ImageUtil.getImageBitmap(mContext, mImageUrl, new SampleProgressObserver&lt;Bitmap&gt;(null) { @Override public void onNext(Bitmap bitmap) { if (bitmap != null) { intent.putExtra(Intent.EXTRA_SHORTCUT_ICON, bitmap); } else { Intent.ShortcutIconResource iconRes = Intent.ShortcutIconResource.fromContext(cx, R.mipmap.ic_launcher); intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, iconRes); } intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); intent.putExtra("duplicate", false); Intent carryIntent = new Intent("android.intent.action.FullScreenWebActivity"); carryIntent.putExtra("name", name); carryIntent.setClassName(cx.getPackageName(), cx.getClass().getName()); carryIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, carryIntent); cx.sendBroadcast(intent); Toast.makeText(mContext, "添加成功", Toast.LENGTH_SHORT).show(); } }); } 这里的桌面图标是使用自定义的ImageUtil类从网络下载的,如果下载到失败的图片,则使用app的Icon作为桌面图标.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/446df734c60ae4e859bd47e881b3eef8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/199/">«</a>
	<span class="pagination__item pagination__item--current">200/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/201/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>