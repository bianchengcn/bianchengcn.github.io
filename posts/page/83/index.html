<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771712f0acaf73202cad717c288079a2/" rel="bookmark">
			第五届字节跳动青训营编程题样题的6种以上解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述
输入一个表示整数的字符串，判断这个字符串是否是4的幂。
输入
一个正整数字符串
输出
返回true或false
https://oj.juejin.cn/problem/04
如果我下面写的不清楚，可以直接参考力扣官方题解 https://leetcode.cn/problems/power-of-four/solution/4de-mi-by-leetcode-solution-b3ya/
方法一：4的幂 如果是4的幂，
首先，n%4 == 0
其次，n一直/4最后会==1，否则就是false
function isPowerOfFour(n) { if (n &gt; 0 &amp;&amp; n % 4 == 0) { while (n &gt; 0) { n = n / 4 if (n == 1) return true if (n == 0) return false } } else { return false } } 方法二：2的幂 是4的幂首先是2的幂
首先，n&amp;(n-1) == 0且n&gt;0
其次，如果在这个基础上还是4的幂的话，满足n%3==1
function isPowerOfFour(n) { return (n &amp; (n - 1)) == 0 &amp;&amp; n &gt; 0 &amp;&amp; n % 3 == 1 } 方法三：利用二进制标识数 因为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/771712f0acaf73202cad717c288079a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52ab10924adf8df44a00dd1bf3e59e69/" rel="bookmark">
			python中 cv2如何裁剪图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 python 中，使用 OpenCV 库中的 cv2.imread() 函数读取图像，cv2.imshow() 函数显示图像，cv2.imwrite() 函数保存图像，然后使用 numpy 库中的索引和切片功能来裁剪图像。
下面是一个示例：
import cv2#读取图片 img = cv2.imread("example.jpg") #裁剪的位置和大小 x = 100 y = 200 w = 300 h = 400 #裁剪图片 img_cropped = img[y:y+h, x:x+w] #显示图片 cv2.imshow("Original Imag 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a70c321b2b7b6e619bf7e5b5ed013c2f/" rel="bookmark">
			vue3 vue-seamless-scroll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开发过程中做大屏的页面，需求用到无缝滚动列表，发现一个特别好用的插件，分享给大家，欢迎评论区讨论话题。
针对于vue3版本
npm install vue-seamless-scroll@1.1.23 安装无缝滚动插件
如果报错则添加--legacy-peer-deps指令，进行强制安装
在main.js中引用vue-seamless-scroll/src一定要添加/src，vue3版本引用插件不同处
import vueSeamless from "vue-seamless-scroll/src"; createApp(App).use(store).use(router).use(vueSeamless).mount("#app"); 完整实例代码
&lt;template&gt; &lt;div class="" style="padding: 50px"&gt; &lt;div class="page-example3" style=""&gt; &lt;vue-seamless-scroll :data="listData" :class-option="defaultOption"&gt; &lt;ul class="ul-scoll"&gt; &lt;li v-for="(item, index) in listData" :key="index"&gt; &lt;span class="title"&gt;{{ item.title }}：&lt;/span &gt;&lt;span class="date"&gt;{{ item.time }}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/vue-seamless-scroll&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "scroll", data() { return { listData: [], }; }, // 监听属性 类似于data概念 computed: { defaultOption() { return { step: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a70c321b2b7b6e619bf7e5b5ed013c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166150ffa9f804b831c2cacd7697a032/" rel="bookmark">
			vue动态添加/删除dom元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue的思想是通过数据操作dom，所以我们根据data中的数据进行对dom的遍历，从而操作数据就可以对vue进行一个动态的添加或者删除啦！
&lt;template&gt; &lt;div&gt; &lt;input v-model="inpValue" type="text" placeholder="请输入添加文字" @blur="addList" /&gt; &lt;ul v-if="list.length &gt; 0"&gt; &lt;li v-for="(item, index) in list" :key="index"&gt; {{ item }} &lt;span @click="removeList(index)"&gt;X&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { list: [], inpValue: "", }; }, methods: { // 向list数组内添加 addList() { // 判断输入框不为空 if (this.inpValue) { // 查重 const isIncludes = this.list.includes(this.inpValue); if (!isIncludes) { this.list.push(this.inpValue); this.inpValue = ""; } else { alert("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/166150ffa9f804b831c2cacd7697a032/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6684b0056634e715697fda6cc453b3c/" rel="bookmark">
			Spring Boot全局异常处理器（原理及使用详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 什么是全局异常处理器
2 为什么需要全局异常
3 原理和目标
4 @ControllerAdvice注解
4.1 Advice（通知）
4.2 @ControllerAdvice结合方法型注解@ExceptionHandler,用于捕获Controller中抛出的指定类型的异常，从而达到全局不同类型的异常区别处理的目的。
4.3 结合方法型注解@InitBinder,用于request中自定义参数解析方式进行注册，从而达到自定义指定格式参数的目的
4.4 结合方法型注解@ModelAttribute，表示其注解的方法将会在目标Controller方法执行之前执行
4.5 @ControllerAdvice注解作用原理
4.6 @RestControllerAdvice
5 编码实现全局异常处理器
1 什么是全局异常处理器 软件开发springboot项目过程中，不可避免的需要处理各种异常，spring mvc架构中各层会出现大量的try{...} catch{...} finally{...}代码块，不仅有大量的冗余代码，而且还影响代码的可读性。这样就需要定义个全局统一异常处理器，以便业务层再也不必处理异常。
Spring在3.2版本增加了一个注解@ControllerAdvice，可以与@ExceptionHandler、@InitBinder、@ModelAtribute等注解配套使用。不过跟异常处理相关的只有注解@ExceptionHandler,从字面上看，就是异常处理器的意思。
2 为什么需要全局异常 不用强制写try-catch，由全局异常处理器统一捕获处理。自定义异常，只能用全局异常来捕获。不能直接返回给客户端，客户端是看不懂的，需要接入全局异常处理器JSR303规范的Validator参数校验器，参数校验不通过会抛异常，是无法使用try-catch语句直接捕获，只能使用全局异常处理器。 3 原理和目标 简单的说，@ControllerAdvice注解可以把异常处理器应用到所有控制器，而不是单个控制器。借助该注解，我们可以实现：在独立的某个地方，比如单独的一个类，定义一套对各章异常的处理机制，然后在类的签名加上注解@ControllerAdvice，统一对不同阶段的，不同异常进行处理。这就是统一异常处理的原理。
对异常按阶段进行分类，大体可以分成：进入Controller前的异常和Service层异常
目标就是消灭95%以上的try catch代码块，并以优雅的Assert（断言）方式来校验业务的异常情况，只关注业务逻辑，而不用花费大量精力写冗余的try catch代码块。
4 @ControllerAdvice注解 @ControllerAdvice注解是Spring3.2中新增的注解，学名是Controller增强器，作用是给Controller控制器添加统一的操作或处理，对于@ControllerAdvice，我们比较熟悉的用法是结合@ExceptionHandler用于全局异常的处理，但其作用不止于此。ControllerAdvice拆开来就是Controller Advice，关于Advice，在Spring的AOP中，是用来封装一个切面所有属性的，包括切入点和需要织入的切面逻辑。这里ControllerAdvice也可以这么理解。
4.1 Advice（通知） Spring AOP通过PointCut来指定在哪些类的哪写方法上织入横切逻辑，通过Advice来指定在切点上具体做什么事情。如方法前做什么，方法后做什么，抛出异常做什么。再来看一下图
主要可分为5类增强：
MethodBeforeAdvice：目标方法实施前增强AfterReturningAdvice：目标方法实施后增强ThrowsAdvice：异常抛出增强IntroductionAdvice：引介增强，为目标类添加新的属性和方法。可以构建组合对象来实现多继承MethodInterceptor：方法拦截器，环绕增强，在方法的前后实施操作 前置增强：主要匹配到的切点运行之前执行，在XML配置中使用&lt;aop:before&gt;，相应的接口为MethodBeforeAdvice。当一个Bean对象实现了MethodBeforeAdvice，在XML配置文件中指定这个bean为advice，Spring会自动在切点方法执行前执行MethodBeforeAdvice的接口。
&lt;bean id="helloworld" class="me.aihe.exam.controller.HelloWorld" /&gt; &lt;!-- timelog实现了MethodBeforeAdvice接口 --&gt; &lt;bean id="timeLog" class="me.aihe.exam.controller.TimeLoggingAop" /&gt; &lt;aop:config&gt; &lt;aop:pointcut id="hello" expression="execution(public * * (..))"&gt;&lt;/aop:pointcut&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6684b0056634e715697fda6cc453b3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5baaf06567acd0210e8662229d5bf1a/" rel="bookmark">
			CocosCreator2.x 开发笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记目录 一. 组件相关1. Canvas 组件1.1 画布透明 2. Label 组件2.1 截屏时字体有黑边2.2 动态改变字体颜色2.3 动态获取文字高度2.4 通过脚本添加 Label 3. Widget (对齐挂件)3.1 使用方法 4. BlockInputEvents 防止事件穿透4.1 使用方法 5. ScrollView 组件5.1 滚动到顶部5.2 规定时间内滚动指定百分比位置上 6. WebView 组件6.1 url改变后的适配问题 7. Sprite 组件7.1 图片置灰7.1.1 置灰显示7.1.2 代码控制参考链接 二. 常用方法1. 加载微信头像2. 开发环境判断3. 游戏全局变量4. 从父节点中删除该节点5. 转化局部坐标系、获取包围盒、判断某个区域是否包含指定坐标点6. 克隆clone节点7. 获取屏幕尺寸8. 打开网址9. 上传base64数据到oss参考链接 三. 使用技巧1. 自定义loading样式2. 字体制作的公共字符集3. 获取地址参数函数4. 上下滑动事件5. 随机函数6. 像素间隔Bug7. 远程打包8. 接口请求超时处理9. CNZZ事件统计10. 创建一个连续数字的数组 一. 组件相关 1. Canvas 组件 1.1 画布透明 场景描述
设置画布透明。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5baaf06567acd0210e8662229d5bf1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4db0d434166606caa33828727549c3b/" rel="bookmark">
			vim跳转到某行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 vim 中，你可以使用以下命令来跳转到某一行：
:&lt;行号&gt;，例如跳转到第 50 行可以输入 :50G，例如跳转到第 50 行可以输入 50G 你还可以使用 gg 命令跳转到文件的第一行，使用 G 命令跳转到文件的最后一行。
例如：
跳转到第一行：gg跳转到最后一行：G 你还可以使用 / 命令来搜索文本，然后使用 n 和 N 命令在搜索结果之间跳转。
例如：
在文件中搜索字符串 search_string：/search_string跳转到下一个搜索结果：n跳转到上一个搜索结果：`N 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bc68d686ca8f43a3ed788405f157a0b/" rel="bookmark">
			夸克网盘的文件怎么保存到百度网盘？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们经常将自己的文件、视频等等都传到网盘上储存，大大减少电脑和手机的占用，其中百度网盘和夸克网盘是非常受欢迎的两款软件，拥有超大的云储存空间，用户想存什么就存什么。那夸克网盘的文件能存到百度网盘吗？当然可以的，下面就来看看具体的方法。
方法一、电脑端 1、想要知道怎么把夸克网盘的文件转到百度网盘，首先在夸克网盘上下载需要保存的文件，然后打开百度网盘客户端后，选择压缩文件要保存的文件夹，双击打开该文件夹。
2、打开该文件夹后，点击窗口左上角区域的“上传”。
3、在电脑中找到需要上传的压缩文件，点击选中该文件后，点击“存入百度网盘”。
4、等待文件上传完毕后，该文件就保存到百度网盘内了。
方法二、手机端 1、首先打开夸克浏览器，然后进入下面的“网盘”。
2、然后选择并点击“云文件”选项。
3、在其中长按选中想要保存的文件。
4、选中后点击左下角“下载”选项。
5、下载完成后再去上传到百度网盘移动端即可，更多内容尽在系统部落。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5458b1af8e8dd574a3485a5fee4865c/" rel="bookmark">
			ffmpeg的一些初级语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ffmpeg命令格式：
ffmpeg [全局选项][输入文件选项] -i [输入文件]...[输出文件选项][输出文件]
主要选项 ：
-f 指定输入或者输出文件格式，不指定的话会根据文件扩展名进行推测。
-i 输入文件
-y 默认覆盖同名文件
-n 不覆盖同名文件，如果输出文件存在立即退出
-codec 指定编码格式，也可以仅指定音频或视频，如-codec:v指定视频编码格式，-codec:a指定音频编码格式
-t 限制输入或者输出时间, 一般配合-ss使用，用来截取时间段的音视频。
-to 指定结束时间点，一般配合-ss使用，用来截取某时间段的内容。
-ss 设置开始时间，单位是秒
-fiiter_complex 复合滤镜
-vf 单一滤镜
视频：
-r 设置帧数
-s 设置输出尺寸（只能是偶数）
-vn 禁止输出视频
-va 禁止输出音频
-codec:v 设置视频编码格式，等同-c:v
-codec:a 设置音频编码格式，等同-c:a
音频：
-ar 设置采样频率
-ac 设置音频通道数
-an 禁止输出音频
-sn 禁止输出字幕
-ab 设置比特率
//将管道里的图片制作成视频
ffmpeg -f image2pipe -framerate 24 -i pipe:.png -s 1600x900 -y -vcodec libopenh264 out.mp4
//从视频里提取音频
ffmpeg -i input.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5458b1af8e8dd574a3485a5fee4865c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995bb4b5c84e2b5338336116fa897a95/" rel="bookmark">
			vue基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。
介绍 — Vue.js
创建vue的简单步骤
导入开发版本的Vue.js创建Vue实例对象,设置el属性和data属性使用简洁的模板语法把数据渲染到页面上 &lt;!--开发环境版本，包含了有帮助的命令行警告--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; 声明式渲染 el：挂载点 el是用来设置Vue实例挂载(管理)的元素
Q1：Vue实例的作用范围是什么呢?
Vue会管理el选项命中的元素及其内部的后代元素
Q2：是否可以使用其他的选择器?
可以使用其他的选择器,但是建议使用ID选择器
Q3：是否可以设置其他的dom元素呢?
可以使用其他的双标签,不能使用HTML和BODY
&lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;vue基础&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- ---------------------------------------------------------------- --&gt; &lt;div id="app"&gt; {{message}} &lt;span&gt;{{message}}&lt;/span&gt; &lt;/div&gt; &lt;!-- ---------------------------------------------------------------- --&gt; &lt;!--开发环境版本，包含了有帮助的命令行警告--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;!-- ---------------------------------------------------------------- --&gt; &lt;script&gt; //vue实例 var app = new Vue({ el: "#app", //el是挂载点 data: { //data是数据对象 message: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995bb4b5c84e2b5338336116fa897a95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e140eb53f71ec5407ed913521d4033d8/" rel="bookmark">
			自动备份交换机的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动备份交换机的配置是指将交换机的配置信息自动备份到另一台设备上的过程。
要实现自动备份交换机的配置，通常可以使用以下方法之一：
将交换机的配置信息备份到一台远程服务器上。这样，即使交换机发生故障或遭到攻击，也可以使用备份的配置信息恢复交换机的运行。
在交换机上配置定时备份。可以设置每天、每周或每月在固定时间自动备份交换机的配置信息。
在交换机上配置自动备份。当交换机的配置发生改变时，会自动备份配置信息。
通常，要自动备份交换机的配置，需要在交换机的管理界面中进行相应的配置。具体的步骤因交换机型号和厂商而异。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e231357001fb2e79fcb6a1fda5f8addd/" rel="bookmark">
			godot 导出的apk安装报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 godot 导出安卓apk安装包之后，安装到手机时报错，出现错误码-103。
原因 可能是导出的apk没有签名。
解决办法 godot的Android导出选项勾选签名即可。如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40edd31c6f1c9f40ce66bb91b2f1a04e/" rel="bookmark">
			FPGA与CPLD的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可编程逻辑器件（Programmable Logic Device，PLD）起源于20世纪70年代，是在专用集成电路（ASIC）的基础上发展起来的一种新型逻辑器件，是当今数字系统设计的主要硬件平台，其主要特点就是完全由用户通过软件进行配置和编程，从而完成某种特定的功能，且可以反复擦写。在修改和升级PLD时，不需额外地改变PCB电路板，只是在计算机上修改和更新程序，使硬件设计工作成为软件开发工作，缩短了系统设计的周期，提高了实现的灵活性并降低了成本，因此获得了广大硬件工程师的青睐，形成了巨大的PLD产业规模。
目前常见的PLD产品有：编程只读存储器（Programmable Read Only Memory，PROM），现场可编程逻辑阵列（Field Programmable Logic Array，FPLA），可编程阵列逻辑（Programmable Array Logic，PAL），通用阵列逻辑（Generic Array Logic，GAL），可擦除的可编程逻辑器件（Erasable Programmable Logic Array，EPLA），复杂可编程逻辑器件（Complex Programmable Logic Device，CPLD）和现场可编程门阵列（Field Programmable Gate Array，FPGA）等类型。PLD器件从规模上又可以细分为简单PLD（SPLD）、复杂PLD（CPLD）以及FPGA。它们内部结构的实现方法各不相同。
可编程逻辑器件按照基本单元颗粒度可以分为3类：
①小颗粒度（如：“门海（sea of gates）”架构），
②中等颗粒度（如：FPGA），
③大颗粒度（如：CPLD）。
按照编程工艺可以分为四类：
①熔丝（Fuse）和反熔丝（Antifuse）编程器件，
②可擦除的可编程只读存储器（UEPROM）编程器件，
③电信号可擦除的可编程只读存储器（EEPROM）编程器件（如：CPLD），④SRAM编程器件（如：FPGA）。
在工艺分类中，前3类为非易失性器件，编程后，配置数据保留在器件上；第4类为易失性器件，掉电后配置数据会丢失，因此在每次上电后需要重新进行数据配置。
可编程逻辑器件的发展历史
可编程逻辑器件的发展可以划分为4个阶段，即从20世纪70年代初到70年代中为第1阶段，20世纪70年代中到80年代中为第2阶段，20世纪80年代到90年代末为第3阶段，20世纪90年代末到目前为第4阶段。
第1阶段的可编程器件只有简单的可编程只读存储器（PROM）、紫外线可擦除只读存储器（EPROM）和电可擦只读存储器（EEPROM）3种，由于结构的限制，它们只能完成简单的数字逻辑功能。
第2阶段出现了结构上稍微复杂的可编程阵列逻辑（PAL）和通用阵列逻辑（GAL）器件，正式被称为PLD，能够完成各种逻辑运算功能。典型的PLD由“与”、“非”阵列组成，用“与或”表达式来实现任意组合逻辑，所以PLD能以乘积和形式完成大量的逻辑组合。
第3阶段Xilinx和Altera分别推出了与标准门阵列类似的FPGA和类似于PAL结构的扩展性CPLD，提高了逻辑运算的速度，具有体系结构和逻辑单元灵活、集成度高以及适用范围宽等特点，兼容了PLD和通用门阵列的优点，能够实现超大规模的电路，编程方式也很灵活，成为产品原型设计和中小规模（一般小于10000）产品生产的首选。这一阶段，CPLD、FPGA器件在制造工艺和产品性能都获得长足的发展，达到了0.18 工艺和系数门数百万门的规模。
第4阶段出现了SOPC和SOC技术，是PLD和ASIC技术融合的结果，涵盖了实时化数字信号处理技术、高速数据收发器、复杂计算以及嵌入式系统设计技术的全部内容。Xilinx和Altera也推出了相应SOCFPGA产品，制造工艺达到65 ，系统门数也超过百万门。并且，这一阶段的逻辑器件内嵌了硬核高速乘法器、Gbits差分串行接口、时钟频率高达500MHz的PowerPC微处理器、软核MicroBlaze、Picoblaze、Nios以及NiosII，不仅实现了软件需求和硬件设计的完美结合，还实现了高速与灵活性的完美结合，使其已超越了ASIC器件的性能和规模，也超越了传统意义上FPGA的概念，使PLD的应用范围从单片扩展到系统级。目前，基于PLD片上可编程的概念仍在进一步向前发展。
开发工具
基于高复杂度PLD器件的开发，在很大程度上要依靠电子设计自动化（EDA）来完成。PLD的EDA工具以计算机软件为主，将典型的单元电路封装起来形成固定模块并形成标准的硬件开发语言（如HDL语言）供设计人员使用。设计人员考虑如何将可组装的软件库和软件包搭建出满足需求的功能模块甚至完整的系统。PLD开发软件需要自动地完成逻辑编译、化简、分割、综合及优化、布局布线、仿真以及对于特定目标芯片的适配编译和编程下载等工作。典型的EDA工具中必须包含两个特殊的软件包，即综合器和适配器。综合器的功能就是将设计者在EDA平台上完成的针对某个系统项目的HDL、原理图或状态图形描述，针对给定的硬件系统组件，进行编译、优化、转换和综合。
随着开发规模的级数性增长，就必须减短PLD开发软件的编译时间、并提高其编译性能以及提供丰富的知识产权（IP）核资源供设计人员调用。此外，PLD开发界面的友好性以及操作的复杂程度也是评价其性能的重要因素。目前在PLD产业领域中，各个芯片提供商的PLD开发工具已成为影响其成败的核心成分。只有全面做到芯片技术领先、文档完整和PLD开发软件优秀，芯片提供商才能获得客户的认可。一个完美的PLD开发软件应当具备下面5点：
准确地将用户设计转换为电路模块
能够高效地利用器件资源
能够快速地完成编译和综合
提供丰富的IP资源
用户界面友好、操作简单
CPLD工作原理与简介 基于乘积项（Product-Term)的PLD结构
采用这种结构的PLD芯片有：Altera的MAX7000，MAX3000系列（EEPROM工艺）,Xilinx的XC9500系列（Flash工艺）和Lattice,Cypress的大部分产品（EEPROM工艺）
我们先看一下这种PLD的总体结构（以MAX7000为例，其他型号的结构与此都非常相似）：
图1 基于乘积项的PLD内部结构
这种PLD可分为三块结构：宏单元（Marocell)，可编程连线 （PIA)和I/O控制块。宏单元是PLD的基本结构，由它来实现基本的逻辑功能。图1中兰色部分是多个宏单元的集合（因为宏单元较多，没有一一画出）。可编程连线负责信号传递，连 接所有的宏单元。I/O控制块负责输入输出的电气特性控制，比如可以设定集电极开路输出，摆率控制，三态输出等。图1 左上的INPUT/GCLK1，INPUT/GCLRn,INPUT/OE1,INPUT/OE2 是全局时钟，清零和输出使能信号，这几个信号有专用连线与PLD中每个宏单元相连，信号到每个宏单元的延时相同并且延时最短。
宏单元的具体结构见下图：
图2 宏单元结构
左侧是乘积项阵列，实际就是一个与或阵列，每一个交叉点都是一个可编程 熔丝，如果导通就是实现“与”逻辑。后面的乘积项选择矩阵是一个“或”阵列。两者一起完成组合逻辑。图右侧是一个可编程D触发器，它的时钟，清零输入都可 以编程选择，可以使用专用的全局清零和全局时钟，也可以使用内部逻辑（乘积项阵列）产生的时钟和清零。如果不需要触发器，也可以将此触发器旁路，信号直接 输给PIA或输出到I/O脚。
乘积项结构PLD的逻辑实现原理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40edd31c6f1c9f40ce66bb91b2f1a04e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4940c46161652496bbf075386ba493b/" rel="bookmark">
			【Proteus仿真】【STM32单片机】电子密码锁设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用Proteus8仿真STM32单片机控制器，使用LCD1602液晶、矩阵按键、蜂鸣器、EEPROM模块、继电器模块等。
系统运行后，LCD1602显示密码输入提示界面，系统存储在EEPROM的初始密码为123456，
用户可通过矩阵按键S1-S10输入数值0-9，当在密码输入过程中有误，可按S11键回删并重新输入。当密码输入完成后，可按S12键确认，校验密码是否正确，如密码输入正确，电磁阀工作开门，对应D3指示灯点亮；如密码输入错误，LCD显示错误信息，可重新输入密码，最多可输入3次，如还输入错误，系统锁死，需等待10S钟解锁系统方可再次输入。当管理员需要更换密码时，可按下S13键，LCD显示更换密码界面，此时可通过S1-S10输入修改密码，修改过程中如需更改可按S11键回删并重新输入。修改密码完成后可按下S12键保存新密码至EEPROM中，更新的密码可断电不丢失。
二、软件设计 /* 作者：嗨小易（QQ：3443792007） */ /******************************************************************************* * 函 数 名 : TIM2_IRQHandler * 函数功能	: TIM2中断函数 * 输 入 : 无 * 输 出 : 无 *******************************************************************************/ void TIM2_IRQHandler(void) { static u32 i=0; if(TIM_GetITStatus(TIM2,TIM_IT_Update)) { i++; if(i&gt;=(100*AFRESH_TIME))//时间到 { i=0; TIM_Cmd(TIM2,DISABLE);//关闭定时器 sys_ctrl.time_flag=1;	} } TIM_ClearITPendingBit(TIM2,TIM_IT_Update);	} //主界面，输入密码提示 void main_display(void) { memset(sys_ctrl.password,0,6);//密码数据清零 sys_ctrl.time_flag=0; sys_ctrl.resive_flag=0; delay_ms(500); lcd1602_clear(); lcd1602_show_string(0,0,"Password Input:");	} //密码输入错误次数超过规定值，等待指定时间后可重新输入 void password_error_wait_afreah_input(void) { TIM_Cmd(TIM2,ENABLE);//开启定时器 lcd1602_clear(); lcd1602_show_string(0,0,"Error Too much!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4940c46161652496bbf075386ba493b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b43086528214d33518370720ce34c2f4/" rel="bookmark">
			用迭代器遍历map 集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package demo3; import java.util.HashMap; import java.util.Iterator; import java.util.Map.Entry; public class TestIterator { public static void main(String[] args) { //创建对象 Student stu1=new Student(); Student stu2=new Student(); Student stu3=new Student(); //创建集合 HashMap&lt;Integer,Student&gt; Map=new HashMap&lt;Integer,Student&gt;(); //把对象放入集合 Map.put(1, stu1); Map.put(2, stu2); Map.put(3, stu3); System.out.println("******** 第一种迭代keyset ********"); Iterator&lt;Integer&gt; it=Map.keySet().iterator(); while(it.hasNext()) { Integer key=it.next(); Student value=Map.get(key); System.out.println("键值对是--"+key+"---"+value); } System.out.println("******** 第二种迭代values ********"); Iterator&lt;Student&gt; it1=Map.values().iterator(); while(it1.hasNext()) { Student value=it1.next(); System.out.println("键值对是--"+"---"+value); } System.out.println("******** 第三种迭代entrySet ********"); Iterator&lt;Entry&lt;Integer,Student&gt;&gt; it2=Map.entrySet().iterator(); while(it2.hasNext()) { Entry&lt;Integer,Student&gt; entry=it2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b43086528214d33518370720ce34c2f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4599acbcc6e443ecfde7c564786c7826/" rel="bookmark">
			element描述列表溢出隐藏不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 不生效写法 .el-descriptions .el-descriptions-item__content { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } // 生效写法 .el-descriptions .el-descriptions-item__content { overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6bc9f0fd24dc217f9a74a4dede20fcf/" rel="bookmark">
			CSS绘制向右箭头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般在列表中会经常用到末尾处右箭头，出了写元素定位外还有一个方法特别简单，利用css中的伪元素进行列表每个li的一个向右箭头的显示。 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul { list-style: none; color: #666; margin: 100px auto; padding: 0; } li { width: 400px; font-size: 30px; height: 50px; border-bottom: 1px solid #999; line-height: 50px; margin: 0 auto; position: relative; } li::after { width: 10px; height: 10px; border-top: 2px solid; border-right: 2px solid; border-color: #ccc; content: ''; position: absolute; right: 11px; top: 20px; transform: rotate(45deg); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;我是第1个内容content&lt;/li&gt; &lt;li&gt;我是第2个内容content&lt;/li&gt; &lt;li&gt;我是第3个内容content&lt;/li&gt; &lt;li&gt;我是第4个内容content&lt;/li&gt; &lt;li&gt;我是第5个内容content&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 特殊情况 如果设置向上、向左、向下箭头控制li的transform的rotate属性的角度即可，切记rotate的单位为deg 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a74dadeaf1f4c6c5e9a3f4f1ac68940/" rel="bookmark">
			Wireshark抓Telnet包及报文分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Wireshark抓Telnet包及报文分析 Telnet作为应用层第二大协议，用途很多滴。
Telnet到底是个啥子 TELNET协议一种简单的基于文本的协议，它可以用来实现远程终端，让用户可以远程对服务器进行操作。尽管现在的远程终端基本上是基于 ssh 的了，但它的思想还是值得我们进行学习。
TELNET协议的架构一种 C/S 架构，一般 TELNET 服务器会运行在 23 端口。
Telnet是一种应用层协议，使用于互联网及局域网中，使用虚拟终端的形式，提供双向、以文字字符串为主的命令行接口交互功能。属于TCP/IP协议族的其中之一，是互联网远程登录服务的标准协议和主要方式，常用于服务器的远程控制，可供用户在本地主机执行远程主机上的工作。
优点 运维不管是新人还是老手，都会用到一个方法，就是Telnet +地址+端口，测试端口是否连通。但是，telnet是否真的这么简单。
telnet [OPTIONS] [host] [port] [host]远程主机 #指定要登录进行管理的远程主机； [port]端口 #指定TELNET协议使用的端口号。 一、远程登录：telnet命令通常用来远程登录。telnet程序是基于TELNET协议的远程登录客户端程序。Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的 能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。
二、确定远程服务的状态：比如确定远程服务器的某个端口是否能访问。
缺点 但是，telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。
抓Telnet进行观察 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c63820c6a8c36e3e139aa6ee4e2dad/" rel="bookmark">
			VirtualBox 共享文件夹设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ubuntu中执行
mkdir share_dir 新建文件夹，然后挂载
sudo mount -t vboxsf share share_dir 就可以把windows中的E:\share文件夹挂在为ubuntu中的share_dir文件夹，两个文件夹可以互通文件了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f0293e126db9facab69e729e98432da/" rel="bookmark">
			4款宝藏国产软件，装了就舍不得卸载，白嫖必备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提到国产软件，许多人想到“流氓、捆绑、广告多”，事实上国产良心软件非常多，如下面几款，每一个都功能强大，最重要还免费使用。
1、原本（图片处理神器） 日常生活与工作中，经常需要拍摄或扫描文字类的图片，如孩子作业、客户合同照片、部门文档等，可由于照片技术、光照等因素，文字类图片可能出现灰底，严重影响阅读体验，
原本这款国产专业级图片去灰底与增强软件，界面简洁，免费且完全无广告，解压即用，大小不到1M，堪称图片优化神器。
原本操作极其简单，“打开-见证神奇”，一键实现图片去灰底，完全不需要任何复杂操作，尤其适合不会图片处理技术的小白，“原本”处理后图片，底部纯白，文字清晰，阅读体验极佳。
“原本”极其厚道，无论是自用还是商用，都不收取任何费用，无需联网注册，没有任何使用时间与次数限制，更不会添加产品水印，简直用爱发电，实属国产良心。
2、PPT超级市场（年终总结PPT神器） 这是打工人年末刚需工具，年终总结PPT免费下载与使用，免费、优质、高效、安全是PPT超级市场的设定原则，支持搜索功能，简直是PPT资源的天堂。
搜索框输入内容，即可实现快速查找，年终总结、答辩、学生、商业、教育、图表等分门别类整理好，随需随用，PPT质量极高，使用方便。
PPT超级市场除了提供海量免费模板，还提供了许多实用的免费PPT文案，涵盖各行各业，从需求到制作灵感，全方位提供，助你快速完成PPT制作。
3、eversheet（效率管理神器） 这是一款无代码开发工具，顾名思义，完全不需要编写一行代码，普通人即可完成各式各样管理软件的搭建，如进销存、人事管理、财务管理、项目管理、合同管理等系统。
eversheet功能极其强大，看似国外软件，其实它是纯国产软件，由前WPS团队成员，耗时3年研发而成，纯中文操作界面，与WPS一样操作简单，拖拉拽即可完成业务流程的搭建。
eversheet带有强大业务执行引擎，支持直接发起流程，内嵌Oracle数据库，一键完成计划任务、简易工作流、业务流程、数据报表、组织架构、权限管理等功能，支持与金蝶、钉钉、企业微信等第三方系统数据对接，实现数据互联互通。
eversheet并非“玩具”，超过30万家企业使用它实现无代码搭建系统，如ERP、WMS、MES等大型系统，让人人都是开发者成为可能。
4、oCam（免费录屏神器） 这是一款超实用的录屏软件，操作简单，完全免费，完全满足日常需求。
支持录制框自定义大小设置，无录制时间限制，不同编码方式, 各种声音控制等, 还有专业游戏录制,与音频录制。
有意思的是，它还支持GIF动画与声音录制，制作动图、添加水印、摄像头设置等功能一应俱全，实属普通人，免费白嫖的最佳录制工具。
小结 上述4款软件，每一款都是良心满满，足以颠覆你对国产良心软件的认识，功能强大的它们，值得点赞与收藏！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/82/">«</a>
	<span class="pagination__item pagination__item--current">83/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/84/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>