<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5aadc29f3ef098a012f3a2d159c7f20/" rel="bookmark">
			ConnectionRefused报错总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主机连接拒绝通常有以下几种情况：
1. 主机名称的问题，机器因为某种原因，hostname发生了变更。
2. 免密通信失效 由master ssh到其他主机监测是否能够连接
3. 确认目标ip是否有效，该机器配置了真实的地址
4. 检验你要访问的地址端口是否开启并可访问 使用telnet命令检测
5. 试试换其他的机器访问你要访问的地址。
6. 检查机器的防火墙有没有关闭
Call From master/192.168.1.110 to standby:8020 failedon connection exception: java.net.ConnectException: Connection refused
yarn.ApplicationMaster: Final app status: FAILED,exitCode: 15, (reason: User class threw exception: java.net.ConnectException:Call From master/192.168.1.110 to standby:8020 failed on connection exception:java.net.ConnectException: Connection refused; For more details see: http://wiki.apache.org/hadoop/ConnectionRefused)
18/06/13 13:30:28 ERROR yarn.ApplicationMaster:Uncaught exception:
我所遇到的问题如上,一开始是以为主机防火墙的问题端口不能访问，最后才发现，这个调用时代码里面写死的，开发人员之前使用节点加端口号来访问hdfs，因为我后来启用了hdfs的高可用属性,hdfs改成了nameservice访问,才导致了以上的问题。
所以说查错还是要结合代码看。
详见httpwiki.apache.orghadoopConnectionRefused
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeabc1a65e4b98d39db8ea1b056a91af/" rel="bookmark">
			编译原理第六、七章总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第六章属性文法和语法制导翻译
属性文法是在上下文无关文法的基础上为每个文法符号（终结符或非终结符）配备若干个相关的“值”（称为属性）。
属性代表与文法符号相关的信息，和变量一样，可以进行计算和传递。(例:类型、值、代码序列、符号表内容等)属性通常分为两类：综合属性（自下而上传递信息）和继承属性（自上而下传递信息）。注意，终结符只有综合属性，非终结符既有综合也有继承。
语义规则：属性计算的过程即是语义处理的过程，对于文法的每一个产生式配备一组属性的计算规则，则称为语义规则。包括属性计算、静态语义检查、符号操作、代码生成等。
考虑非终结符A，B和C，其中，A有一个继承属性a和一个综合属性e，B有综合属性b，C有继承属性c。
产生式 A → BC 应该有计算c和e的规则
C.c := B.b + 1
A.e := A.a + B.b 其中属性A.a和B.b在其他地方计算。
从概念上讲，基于属性文法的处理过程通常如下：
输入串®语法树®依赖图®语义规则计算次序®计算结果 这种由源程序的语法结构所驱动的处理办法就是语法制导翻译法。
在一棵语法树中的节点的继承属性和综合属性之间的相互依赖关系可以由称作依赖图的有向图来表示。注：b依赖于c表示为 c→b。
良义文法是指属性文法不存在属性之间的循环依赖关系。
假设语法树已经建立起了，并且树中已带有开始符号的继承属性和终结符的综合属性。然后以某种次序遍历语法树，直至计算出所有的属性。最常用的遍历方法是深度优先，从左到右的遍历方法，如果需要，可使用多次遍历。
与树遍历的属性计算方法不同，一遍扫描的处理方法是在语法分析的同时计算属性值，而不是语法分析构造语法树之后进行属性的计算，而且无需构造实际的语法树。
从语法树中去掉对翻译不必要的信息，而获得更有效的源程序中间表示。这种经变换后的语法树称之为抽象语法树。在抽象语法树中，操作符和关键字都不作为叶结点出现，而是把它们作为内部结点，即这些叶结点的父结点。
建立表达式的语法树使用的函数
1. mknode(op,left,right) 建立一个运算符号结点，标号是op,两个域left和right指向运算分量结点的指针。
2. mkleaf(id,entry) 建立一个标识符结点,由标号id标识，一个域entry指向标识符符号表中相应的项。
3. mkleaf(num,val)
建立一个数结点，标号为num ，域val用于存放数的值.返回新建立结点的指针。 例：
S属性文法只含有综合属性。
L属性文法的定义
如果每个产生式A ®X1 X2 …Xn 的每条语义规则计算的属性是A的综合属性；或者是Xj 的继承属性，1 £ j £ n, 但它仅依赖：
该产生式中Xj左边符号X1, X2,…, Xj-1的属性；
A的继承属性
S属性文法包含于L属性文法
翻译模式是语法制导定义的一种便于翻译的书写形式。其中属性与文法符号相对应，语义规则或语义动作用花括号｛｝括起来，可被插入到产生式右部的任何合适的位置上。
这是一种语法分析和语义动作交错的表示法，他表达在按深度优先遍历分析树的过程中何时执行语义动作。翻译模式给出了使用语义规则进行计算的顺序。可看成是分析过程中翻译的注释。
用翻译模式构造自顶向下翻译。
1.从翻译模式中消除左递归 2.关于左递归翻译模式更一般化的讨论
第七章语义分析和中间代码产生
“中间代码生成”程序的任务是把经过语法分析和语义分析而获得的源程序中间表示翻译为中间代码表示。方法：语法制导翻译。
语义分析的任务是：
1.审查每一个语法结构的静态语义，即验证语法正确的结构是否有意义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeabc1a65e4b98d39db8ea1b056a91af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2b1b8775dadf6a2008967e2df1826d3/" rel="bookmark">
			基于opencv对图片进行base64格式的编解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先base64，了解一下：Base64就是一种基于64个可打印字符来表示二进制数据的方法。 表示二进制数，所以我得先让图片转化为二进制数据，然后对二进制数据进行base64编码； 或者先对base64字符串进行解码，然后再把二进制数据转化为图片保存或展示。
流程 编码 cv::Mat图片 -&gt; 二进制数据 bool imencode(const string&amp; ext, InputArray img, vector&amp; buf, const vector&amp; params=vector()) //ext： 图片后缀名，如".jpg"或".png" //img： 需要进行相关操作的图片 //buf： 输出二进制数据到该缓存。 //params：格式相关的参数 //params中的每个参数成对出现，即paramId_1, paramValue_1, paramId_2, paramValue_2, … ，当前支持如下参数： //JPEG：压缩质量 ( CV_IMWRITE_JPEG_QUALITY )，从0到100（数值越高质量越好），默认值为95。 //PNG： compression level ( CV_IMWRITE_PNG_COMPRESSION ) 从0到9。 数值越高，文件大小越小，压缩时间越长。默认值为3。 //PPM, PGM, or PBM：二进制标志 ( CV_IMWRITE_PXM_BINARY )，0 或 1。默认值为1。 2.二进制数据 -&gt; base64字符串 网上有很多的 base64编解码 源码，本文末会添加我使用的源码供参考。
附：
/*****test.cpp*****/ #include &lt;iostream&gt; #include &lt;opencv.hpp&gt; #include &lt;vector&gt; #include &lt;fstream&gt; #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2b1b8775dadf6a2008967e2df1826d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c38b7081d6e24575053c1af45951fa5/" rel="bookmark">
			log4j:WARN No appenders could be found for logger 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用log4j时不起作用，每次执行完出现以下提示：
log4j:WARN No appenders could be found for logger (org.apache.ibatis.logging.LogFactory).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
解决办法如下：
在配置文件log4j.properties（文件名必须这个，放在resources目录） 全选粘贴如下代码：
# Global logging configuration 开发时候建议使用 debug log4j.rootLogger=DEBUG, stdout # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39cb71d128848f911ec202077d4ab0b2/" rel="bookmark">
			让人抓狂的 URL 重定向的 Cookie 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想象下面两行伪代码：
1. setCookie(...);
2. redirect(new_web_url);
首先设置一个Cookie，然后重定向到另外一个网址，这个网址跟当前网站的域名不同
在多数情况下这两行代码执行毫无问题，cookie 正确保存到浏览器，页面也跳转到了新的url上。
但是有很多firefox浏览器下可能出现的问题是cookie无法写入，而 url 跳转成功。还不一定能重现出来这种问题，但发生的概率非常高。
解决的办法：
不要直接 redirect 到另外的网址，而改用：
String new_url = "http://www.oschina.net/"; String html = "&lt;script type='text/javascript'&gt;location.href='"+new_url+"';&lt;/script&gt;"; response.getWriter().print(html); 如此 cookie 就可以保证正确写到浏览器，然后执行页面跳转。
备注：往session保存数据也是一样的，因为 session 就是通过 cookie 实现的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4457b10665f7e4e6b7c3eeba507687f/" rel="bookmark">
			netty4handler的执行顺序三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上篇，有人说不使用super，不就行了，但是netty是需要你super的
public class WangNetty45Server {
private static final Logger LOGGER = LoggerFactory.getLogger(WangNetty45Server.class);
public void start(int port){
EventLoopGroup boss = new NioEventLoopGroup();
EventLoopGroup work = new NioEventLoopGroup();
ServerBootstrap bootstrap = new ServerBootstrap();
try {
bootstrap.group(boss, work)
.channel(NioServerSocketChannel.class)
.option(ChannelOption.SO_BACKLOG, 1024)
// .option(ChannelOption.SO_TIMEOUT, 5 * 1000)
.childOption(ChannelOption.SO_KEEPALIVE, true)
.childOption(ChannelOption.SO_RCVBUF, 10 * 1024)
.childOption(ChannelOption.SO_SNDBUF, 10 * 1024)
.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
@Override
protected void initChannel(SocketChannel sc) throws Exception {
sc.pipeline().addLast(new WangInHandler1());
sc.pipeline().addLast(new WangInHandler2());
sc.pipeline().addLast(new WangInHandler3());
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4457b10665f7e4e6b7c3eeba507687f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a3943826281d267905b26b7ebebe2d/" rel="bookmark">
			.NET学习-using的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种用法：引用命名空间 using System.Data.SqlClient;
第二种用法： using(...){ }
using (FileStream fs = File.Open("", FileMode.Open, FileAccess.Read)) { using (StreamWriter sw = new StreamWriter(fs, Encoding.GetEncoding("gb2312"))) { sw.WriteLine("要写入的一行字符串".Replace("\n", "\r\n")); } } 和
FileStream fs = File.Open("", FileMode.Open, FileAccess.Read); StreamWriter sw = new StreamWriter(fs, Encoding.GetEncoding("gb2312")); sw.WriteLine("要写入的一行字符串".Replace("\n", "\r\n")); sw.Close(); fs.Close(); 效果是一样的，只不过
用了using后，那么该默认实现了IDisposable接口的对象会自动调用Dispose()方法，即自动释放资源，进而达到优化内存的效果。
而不写using，则需要主动关闭这两个对象来释放资源。
所以说效果是一样的，随便你怎么写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e99a8d1a23fac2dec968059a7c768367/" rel="bookmark">
			西门子plc  s7-200的表用法中填表fill_n和查表详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、填表（或者清空表）
fill_n相信大家都用的比较多，主要是用来清空表的内容的，网上查到的内容多不够白话，特写一下教程，方便初学者理解，
fill_n指令包含两个个输入和一个输出。下面这个例子就是讲8个0填充到vw202开始的8个位置，相当于清空表。
2、查表
如果建立表的时候，给表命名叫vw10，那么表大小为5，那么这5个值将保存在vw12、vw14、vw16、vw18、vw20里，很简单方便吧，就不上图了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d677bf6f67e687425c42cf232d786958/" rel="bookmark">
			异步，有一个从丑小鸭变成白天鹅的故事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS中异步存在的必要性 丑小鸭在孤独和凌乱的时候常常在想：“我是从哪里来？为什么我和别鸭（同步任务）不一样？”
从童话世界跳出来，我们也需要知道，为什么会有异步，为什么会有那么多的异步方法需要我们去学习？ 首先我们都知道JS是单线程的，这就意味着同一时刻只能做一件事。所有的任务都要排队依次等待执行。在JS中有很多比较耗时的任务，最为典型的就是ajax请求。同步就意味着不管当前的任务要执行多久，后面的任务都只能等待它有响应，执行完成。这样的机制很浪费时间和性能。 为了解决上述的问题，JS的设计者改变了下方案。我们可以先让这些执行时间漫长，需要等待的任务在主线程中挂起，由任务对应的线程（事件触发线程、定时触发器线程、异步http请求线程等）先处理着，主线程先去执行后面的任务，等到这些被挂起的任务，有了结果后，所属的线程再回过头来通知主线程这些任务可以执行了。
这也正是异步的起初与概念的根本。那么处理异步任务的线程，怎么与主线程之间建立连接，告诉主线程可以开始执行这个异步任务了呢？
这件事情只有一等公民函数可以完成，处理异步任务的线程将异步任务的回调函数放入任务队列中去排队，等待主线程去获取并执行。
回调函数就是实现异步编程起初与根本。它解决了同步的阻塞问题，但同时也带来了很多其他的问题。
下面我们详尽的讲述一下由回调函数衍生而来的异步发展史。
异步发展历程概述 异步发展的历程好比丑小鸭变白天鹅的故事。它的几个阶段想必你已经滚瓜烂熟：回调函数、promise、生成器函数（generator）&amp; co、async/await。
为了避免俗套，我们不去赘述上述四个历程的使用。而是去分别比对一下每一个阶段究竟比上一个阶段美在哪里，为什么说是一种进步，又有哪些要注意的坑。
回调函数
首先什么是回调函数，他又为什么会被嫌弃？
回调本质上是一种设计模式，一个函数A当做参数传递给函数B，在B的内部去执行函数A。这时候函数A就被称作回调函数。
从概念我们可以看出，回调函数实现的方式实际就是函数嵌套函数，那么当代码逻辑相对复杂的时候，难免会出现多层嵌套的问题。
下面我们用一个小球碰撞的例子来说明一下回调函数的问题，为了方便各个历程的对比，这个例子也将贯穿全文。
假设我们的页面上现在有三个小球，均处于页面的最左端，我们依次将他们移动到页面的指定位置。
html代码片段：
&lt;div id="box"&gt; &lt;div id="ball-1"&gt;&lt;/div&gt; &lt;div id="ball-2"&gt;&lt;/div&gt; &lt;div id="ball-3"&gt;&lt;/div&gt; &lt;/div&gt; 复制代码css 代码片段：
#box div{ width: 100px; height: 100px; background: red; border-radius: 50%; position: relative; margin-top: 10px; left: 0; } 复制代码callback方式实现交互的代码：
// 小球运动的基本方法 function move(ele, position) { return new Promise((resolve, reject) =&gt; { let left = 0; let timer = setInterval(() =&gt; { left += 5; if (left &gt;= position) { clearInterval(timer); ele.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d677bf6f67e687425c42cf232d786958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b188232f76fcc9f793ff84491cb22ae1/" rel="bookmark">
			Qt之去除JSON数据中两边的中括号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用JSON的过程中难免会出现：数据形式与json数据不一致的情况，我最近遇到的就是json数据两侧多了中括号。
我想到了几个办法：第一分割字符串，第二正则表达式，第三字符串替换
我最后综合了一下决定使用字符串替换，将“【”“】”替换成空格“ ”；
QString data = QString::fromLocal8Bit(res.c_str(), res.length()); data = data.replace("["," ");//QString字符串分割函数 data = data.replace("]"," ");//QString字符串分割函数 qDebug()&lt;&lt;"字符串分割后数据为："&lt;&lt;data;问题虽小，但是却影响重大！将每天的点点滴滴，记录一下 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c4d52417027966124b9f480e29e5d89/" rel="bookmark">
			vue  axios 数据（data）赋值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 总结一下我遇到的一个纠结很久的问题。
在项目中需要用到后台的数据对前端渲染，使用到了vue整合的axios，使用vue中的钩子函数在页面组件挂载完成之后向后台发送一个get请求然后将返回后的数据赋值data（）中定义的属性：
执行后前端报错：
原因：
在请求执行成功后执行回调函数中的内容，回调函数处于其它函数的内部this不会与任何对象绑定，为undefined。
解决方案：
一）将指向vue对象的this赋值给外部方法定义的属性，然后在内部方法中使用该属性
二）使用箭头函数
转载自https://blog.csdn.net/bryant953/article/details/79411688 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba70d5fa973427ef187317347974ef3c/" rel="bookmark">
			idea maven 有jar包，就是报错整个项目找不到jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用idea新检的maven项目，找不到jar，折腾了好久，
解决：
在网上找到解决方法：删除.iml文件，让他重新生成，试了几次之后就成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9137e00aa91e15ef750be68b907951d/" rel="bookmark">
			SQL学习-向一张表中插入数据来源于另一张表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如：从另一个数据库的表中查询出数据插入到这张表
INSERT INTO dbo.userInfo
(ID,UserName,Age)
SELECT ID,UserName,Age
FROM anotherDatabase.user
比如：自动生成10个GUID插入到这张表
INSERT INTO dbo.userInfo
(ID)
SELECT TOP(10)NEWID() AS ID
FROM dbo.course(随便一张表)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ab57260ee41ae6e8482e227959d910a/" rel="bookmark">
			前端学习-URL带参数的时候不能有空格！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用
错误示范：window.location.href = '@Url.Action("GetLanguageTestList", "UserOrgManager")?id ='+id; 正确示范：window.location.href = '@Url.Action("GetLanguageTestList", "UserOrgManager")?id='+id; 后面带参数的时候，参数值总是传不过去。
发现，是因为自己习惯性的敲空格导致加参数的时候有空格，所以才传不过去。
标准的URL中不能使用空格，如果需要加空格，用20%来写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/161f7103d508b578078336c637a32f0a/" rel="bookmark">
			前端学习-MVC中View之间的跳转或者跳转到特定方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$("#languageTest").click(function () { window.location.href = '@Url.Action("GetLanguageTestList", "UserOrgManager")'; }); 如果页面之间跳转，无参数（有的需要）：window.location.href='@Url.Action("方法名","controller名")';。
如果跳到方法，带参数（有的不需要）：window.location.href='@Url.Action("方法名","controller名")?id='+id;
场景：
假如有几个tab需要实现跳转，即页面间跳转，则用到第一种方式。
假如要导出Excel，需要跳转到导出的方法，则可能需要带sql作为参数，则用到第二种方式。
补充：
window.location.href='@URL.Action("方法名","controller名")'和
window.location.href='/AdminManager/GetUserInfo'的效果是一样的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/389447fa35f7472bd58e54a87b98f3ee/" rel="bookmark">
			android studio 执行run app 时出现waiting for debugger的解决方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android studio 启动（run）项目时，有时会卡在waiting for debugger。
不说别人的解决方法了，一个个都试过了，都是扯淡。
自己的方法是，重启手机，就ok了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61452ae632193490f41c7551228670a/" rel="bookmark">
			Qtable 相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、创建表单
self.table = QTableWidget(5,2) #或者 self.table = QTableWidget() self.table.setColumnCount(5) self.table.setRowCount(2) 2、表头 表头分 水平表头horizontal header 和 垂直表头vertical header两种。
添加水平表头：setHorizontalHeaderLabels()
添加垂直表头：setVerticalHeaderLabels()
#添加水平表头 horizontalHeader = ["工号","姓名","性别","年龄","职称"] self.table = QTableWidget() self.table.setHorizontalHeaderLabels(horizontalHeader) 影藏表头：self.table.verticalHeader().setVisible(False)
3、行列数
表格的行数：self.table.rowCount()
表格的列数：self.table.columnCount()
4、插入列表项
x = '我不会啊啊啊' item = QTableWidgetItem(x) #设置列表项颜色 item .setTextColor(QColor(250,0,0)) item .setBackgroundColor(QColor(255,255,1)) row_count = self.table.rowCount() #获取列表的行数 self.table.insertRow(row_count) #在列表末尾插入一行 self.table.setItem(row_count , indexY, item ) # 在row_count 、indexY位置插入item 5、动态删除行、列
self.table.removeRow(index) #删除第index行 及其内容 self.table.removeColumn(index) #删除第index列 及其内容 6、clear()
clear函数只清空table的内容， 不删除列表的行列。
使用clear函数清空列表内容后，可以用 self.table.setRowCount() / self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f61452ae632193490f41c7551228670a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e199e94350414083ef75a79d57be662/" rel="bookmark">
			哈佛架构与冯诺依曼架构的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CISC与RISC的区别：
CISC（复杂指令集）:复杂指令集就是CPU在工作的时候需要有很多的汇编指令来完成，它可以用一个汇编指令来完成一件复杂的工作。例如：乘法，加法，乘加，乘减等处理的时候，他会每个处理方式用一条指令来完成。因此这种设计实际上是很强大的，因为同样处理一个运算，它可以用一个机器周期就可以完成了。但是其内部的硬件设计就相对而言的比较复杂了一些。而且，这样的设计势必就会遭成功耗的增加。例如现在的大部分PC机的处理器都是这种的。51单片机也是这种方式的。
RISC（精简指令集）：相对于复杂指令集而言，精简指令集所需要的汇编指令就会少很多了。例如：在完成（1+1）×（2-1）这样的运算的时候，第一次先算1+1等于2然后再算2-1等于1，最后在算2×1等于2。这样他就要经历好几个机器周期才能完成一次运算。而如果用复杂指令集的话可能一次就可以算出来结果了。由于现在的CPU主频基本上在原料不变的情况下是很难再提高他的（主频）运算速度了。所以，精简指令集的CPU在单核的效率上是远不如复杂指令集的CPU的。因此，为了达到与复杂指令集的CPU同样的运算效率，现在的手机经常会增加内核的数量来提升自身的处理效率。
地址总线、数据总线和控制总线的区别（这里的总线主要指外部总线，不包括内核的总线）：
地址总线（Address Bus）：当CPU要处理数据的时候首先地址总线会根据要处理的数据的地址在内存中找到要处理的数据，然后再对其进行相应的处理。也就是说，地址总线的宽度决定了CPU能够处理的数据地址的总量的大小。由于地址总线总是由CPU发起的寻址要求，因此数据总线只能由CPU主动向外部寻找它所需要的地址，而不能被外部的IO主动使用。因此，地址总线是单向（只能由CPU主动去读而不会对其进行写）三态（高电平、低电平、高阻态）的。
数据总线（Data Bus）：当CPU需要读取或写入数据的时候由地址总线先去寻址，然后再由数据总线对所读到的地址进行读或写操作（CPU一次读写的数据总量由数据总线的宽度决定）。最终实现CPU所要实现的相应功能。由于CPU会通过数据总线对所要处理的地址进行读和写两种方式的操作。因此，数据总线是双向三态的。
控制总线（Control Bus）：当CPU要对外部的外设（IO设备或内存）进行操作的时候，控制总线会对相应的外设发出相应的控制指令，然后再由数据总线对其进行操作。由于控制总线要对所有的外设进行控制，因此，他是双向的且十分的灵活，而其总线的宽度也是不确定的，主要有外设的数量决定其宽度。
统一编址和独立编址的区别：
要明白统一编址和独立编址的区别首先要知道CPU在处理数据的时候其实是要先由控制总线发送控制指令，然后再对外设（这里的外设包括IO设备和内存）进行寻址的操作，只有找到了要操作的硬件或内存的地址之后才能对其进行相应的操作。而这个寻址的方式是由CPU对地址的编址方式决定的。而编址方式就分为统一编址和独立编址。
统一编址：统一编址就是当CPU要对IO设备进行操作的时候，就直接由地址总线进行寻址，因为地址总线的宽度是一定的，也就是所寻址的范围是一定的。而如果由它直接对IO设备进行寻址，那势必会占用有限的地址，进而会导致对其能够操作的内存大小就会有所限制。这也就导致了地址总线所能寻到的内存地址并不和自己的总线宽度对应上。（假如一个32位宽度的地址总线本来可以寻址4GB的内存地址，但是由于它一般分外设占用了他的地址，因此，他所能使用的内存就会小于4GB。）
独立编址：独立编址的CPU在对IO设备进行操作的时候会有专门的操作指令，而不会用内存操作指令，这样就会使地址总线仅服务于内存，而不会被其他IO外设占用。也因此会使内存的大小等于地址总线的宽度。
哈佛结构和冯诺依曼结构的区别：
要理解哈弗结构和冯诺依曼结构的区别，首先要知道我们在编写程序的时候其实可以对程序的代码划分为两个部分，一部分是程序编写完成后就不再需要对其进行修改了的（也就是逻辑代码部分）另一部分就是在程序编写完毕后其内容会随着程序的运行而不断变化的部分（也就是定义变量）。而哈佛结构和冯诺依曼结构就是对于这个两部分代码的存储方式的区别。
哈佛结构：哈佛结构就是将程序的逻辑代码和变量分开存放的一种结构，而他们存放的位置可以是形同的也可以是不同的，总是只要是分成两个部分单独访问的结构都可以叫哈佛结构。（例如：51的程序的逻辑代码段放在ROM中，而变量部分则放在ROM中；而ARM的逻辑代码和变量都是存放在RAM（内存）中的，但是，它在内存中划分了两部分的空间，其中一部分放逻辑代码，另一部分方变量。之间不会相互干扰）哈佛结构的优点就是逻辑代码和变量单独存放，使之不会相互干扰，进而当程序出BUG的时候，最多只会修改变量的值，而不会修改程序的执行顺序（逻辑关系）。因此，这种结构大量应用在嵌入式编程当中。
冯诺依曼结构：冯诺依曼结构则是将逻辑代码段和变量统一都存储在内存当中，他们之间一般是按照代码的执行顺序依次存储。这样就会导致一个问题，如果当程序出现BUG的时候，由于程序没有对逻辑代码段的读写限定，因此，他将拥有和普通变量一样的读写操作权限。于是就会很容易的死机，一旦他的逻辑执行出现一点该变就会出现非常严重的错误。但是，冯诺依曼结构的好处是可以充分利用有限的内存空间，并且会使CPU对程序的执行十分的方便，不用来回跑。
原文链接：https://blog.csdn.net/qq_25827755/article/details/52297383
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08aac4a66327aecc2f1f81d31149ebe8/" rel="bookmark">
			【mysql】如何在MySQL中导入超大的SQL文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法 1.在navicat中导入（速度慢） 2.使用source命令导入（速度快） 第一种很简单，本文只介绍第二种。
步骤 1.查询mysql的安装位置
执行命令：
which mysql 当然也可以在系统的环境变量中查找mysql的安装位置，或者用whereis命令查找。
2.修改该目录下my.ini文件中max_allowed_packet 因为默认max_allowed_packet为1k，如果导入的文件过大。可能会报错。 我们将该值改大一点，我这里设为1G。 设置好了之后可以通过以下命令来查看:show VARIABLES like '%max_allowed_packet%';注意别忘了写分号。
3.重启mysql服务 window快捷键win+r进入运行工具——&gt;输入services.msc——&gt;找到mysql的服务，右键点击重启。 4.重新登录mysql并执行source
C:\Users\111&gt;mysql -u root -p mysql&gt;use mydb; mysql&gt;set names utf8;#根据情况，要保证编码一致 mysql&gt;source D:/dataFile/back.sql;#注意这是左斜杠 我导入11G的数据大概用了半个多小时。
5.去navicat中查看是否成功导入了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a20dbebab40a79377b3bbaec80fabe/" rel="bookmark">
			JS中如何查看object对象内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 假设_obj是需要查看的对象(object对象)，那么...
var property = ""; for (var item in _obj) {
property += "属性：" + item + "数值：" + _obj[item] + "\n";
}
alert(property);
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/197/">«</a>
	<span class="pagination__item pagination__item--current">198/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/199/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>