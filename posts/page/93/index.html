<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f44e7bdb688975bb50e5755ac91e30/" rel="bookmark">
			几种查询局域网内在线弱电设备IP地址的方法，总有一款你会用的到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：通过电脑cmd命令查询局域网内设备IP
在电脑开始菜单[运行]，输入cmd回车，在弹出的命令提示窗口输入ipconfig/all回车，能够查看本机的IP、网关、mac地址信息。
然后在命令提示窗口输入arp -a，进行回车，等待返回结果。
从返回结果可以查询看本地局域网中的所有与本机通信的监控设备IP地址、mac地址等。
方法二、使用局域网IP扫描工具查询IP
1.扫描工具NetBScanner
可以在网上下载局域网IP扫描工具，电脑安装后即可查询扫描，我知道的一款扫描工具NetBScanner，它是一款适用于局域网中搜索各个主机ip地址的搜索分析软件，NetBScanner采用了NetBIOS协议，可以扫描指定的ip段内的主机，查看对应主机的详细信息，如：计算机名、IP域名，MAC、网卡属性等，并且可以将信息进行导出，非常方便。
如果使用cmd命令和扫描工具扫描局域网IP，是主动查询访问的方式，需要终端对命令进行回复，如果有些终端为了系统安全，关闭了ping响应，那么查询的IP信息可能与实际情况不符，这里的方法仅供参考，可以查询部分IP。当然如果家庭使用也可进入路由器直接查看局域网所有IP信息，非常方便。
2.使用nmap等扫描工具
nmap是一个非常有名的网络安全审计工具，在黑客帝国里有它的镜头，扫描局域网网段只是其中很小的一部分功能，有兴趣的网友可以深入研究一下；
扫描局域网某IP网段的，可以使用nmap的三层网络设备发现选项”-sP"，终端需要支持“ping"操作；如果需要扫描特定的服务，判断是否在线，可以使用四层扫描选项，‘-sT’是全连接，'-sS'是半连接；
相关命令“nmap -sP 172.17.148.0/24",操作命令和扫描结果如下图所示。
方法三、登陆交换机查看
登陆网关交换机查看arp信息，这里需要注意的是接入交换机是不记录IP信息的，需要登陆网关交换；
每台终端上网必须要设置一个网关地址，是数据转发的第一跳，在这台网络设备上记录了终端的相关arp信息，即mac地址和ip地址的对应表；
这里以华为交换机为例子，telnent登陆交换机，输入命令“display arp”，即可查看局域网相关网段的IP地址，如下图所示。
方法四、用ping命令
最简单最容易操作的方式就是在这个网路中的任何一台电脑上ping全部的IP地址！当然很慢！有很多软件可以帮你实现！
也可以点击开始按钮，点击运行 输入CMD，运行，然后再打开的运行窗口中一个一个的ping从1到254的地址！或者写一个命令吧！for /L ％％x in (1,1,254) do ping 192.168.1.%%1&gt;&gt;ip.txt 运行后自己喝喝茶，然后完毕后入C盘里看那个TXT文件就行！
当然你如果可能登录路由器或是交换机最好了！普通路由器可以在DHCP服务器中看到，或是在无线中也可以看到当然连接的手机登陆无线终端！如果是了管理的交换机，那就是display arp
也可以在手机安装fing来扫描相当方便
总结
判断某个网段的在线监控设备IP，最简单的方式就是登陆网关交换机查看，是被动获取信息的方式，获取的数据比较准确；
使用ping等工具扫描局域网网段，是主动获取信息的方式，需要终端对ping命令回复，有些终端可能由于安全问题，关闭了ping的响应，那么获取的信息可能与实际情况有误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8c0c14e91a9d6705aa64063f014e01/" rel="bookmark">
			C&#43;&#43;中你可能会忽略掉或者搞错的重要知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、顶层const和底层const 修饰的是带有指针类型的变量。
这里我们先区分下要讲的概念：
int a = 10; int *p = &amp;a; 指针本身是指p（值为&amp;a），指针指向的对象是指*p（值为a）
你可以这样理解顶层：就是最顶端，最原始的东西，一个变量有一个值和地址，值是通过地址得到的，所以，地址在顶层，而const是说常量，那么合起来，顶层const就是地址是一个常量，那么底层const就是说值是一个常量
顶层const： int a = 10; int * const p = &amp;a; 修饰的是指针本身（也就是p），表示地址不可以修改。也就是说不能修改p的指向（p的值始终只能是&amp;a），但是可以修改p指向对象的值，也就是修改*p（也就是a）的值。 // 接上 int b = 15; p = &amp;b; // 这里是错误的，p是顶层const，不能修改 *p = b; // 这里是正确的，修改的是*p的值，也就是指针指向的对象的值。 底层const： int a = 10; const int* p = &amp;a; // int const* p = &amp;a; 都是正确的。 修饰的是值，表示指针指向的对象的值不可以修改。*p（也就是a）的值不能修改。
区分方法： 最简单的区分方法是看const关键字的位置：
①int * const p
放在*右边就是修饰p，修饰的是地址，就是顶层const
②int const *p 或 const int *p
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c8c0c14e91a9d6705aa64063f014e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca15cb565d0bf318c890cc0f1d3b24b/" rel="bookmark">
			LaTeX 脚注
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LaTeX 脚注 原 文：Footnotes
译 者：Xovee
翻译时间：2022年10月27日
文章目录 LaTeX 脚注介绍`\footnote`命令例子 LaTeX Counter：保存脚注标号值`\footnotemark`和`\footnotetext`命令例子 其他LaTeX脚注命令 脚注的例子和应用拥有多个参考（Reference）的脚注改变标号的样式`minipage`环境中的脚注改变`minipage`脚注标号表格中的脚注要不要在表格中使用脚注呢？例子：`\footnote`在`tabular`环境中不起作用例子：来自LaTeX2e非正式参考手册例子：使用`tablefootnote`包 表格注释 Table Notes例子tex.stackexchange上的讨论 介绍 根据Wikipedia的介绍，脚注是由一个英国印刷工Richard Jugge（1514年到1577年）发明的。本文将会介绍脚注这一古老的文本修饰工具是如何在LaTeX中使用的。
\footnote命令 \footnote命令是LaTeX中创建脚注的主要命令，它主要由两种使用形式：
\footnote{text for footnote}：这一命令会自动在文本中插入一个上标数字，被称为脚注的标号（mark），同时在页面的底部插入脚注的标记和内容。\footnote[number]{text for footnote}：这一命令接受一个额外的参数number来指定脚注的标号。 例子 \footnote{Automatically generated footnote markers work fine!}将会创建标号为1的脚注\footnote[42]{...is that the answer to everything?}创建了标号为42的脚注，并且不会自动增加之前脚注的标号大小。如我们在下面所见，第三个脚注的标号为2。 I'm writing to demonstrate use of automatically-generated footnote markers\footnote{Automatically generated footnote markers work fine!} and footnotes which use a marker value provided to the command\footnote[42]{...is that the answer to everything?}. Now, I will use another automatically-generated footnote marker\footnote{Now, footnote markers are 1, 42, but then back to 2?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bca15cb565d0bf318c890cc0f1d3b24b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e61f8d359114986352d3cb96a784f175/" rel="bookmark">
			Linux下安装Python2.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下安装Python2.7 执行如下命令下载安装python2.7.10：
wget https://www.python.org/ftp/python/2.7.10/Python-2.7.10.tgz tar -xvf Python-2.7.10.tgz cd Python-2.7.10 ./configure --prefix=/usr/local/python2.7.10 make sudo make install # 此处可能需要输入密码 ln -s /usr/local/python2.7.10/bin/python /bin/python 执行如下命令下载安装setuptools：
wget https://files.pythonhosted.org/packages/c5/41/247814d8b7a044717164c74080725a6c8f3d2b5fc82b34bd825b617df663/setuptools-65.5.0.tar.gz tar -xf setuptools-65.5.0.tar.gz cd setup-tools-65.5.0 python setup.py install 执行如下命令下载安装pip：
https://pypi.python.org/packages/11/b6/abcb525026a4be042b486df43905d6893fb04f05aac21c32c638e939e447/pip-9.0.1.tar.gz#md5=35f01da33009719497f01a4ba69d63c9 tar -xvf pip-9.0.1.tar.gz cd pip-9.0.1 python setup.py install ln -s /usr/local/python2.7.10/bin/pip /bin/pip 总结 以上步骤只是理论步骤，我用的Win10的Ubuntu子系统并不能完全支持，故而采用Anaconda的python2.7虚拟环境。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76213203341b05da0cbcee221803bdfa/" rel="bookmark">
			SpringBoot中Server层以及Mapper层常用注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看了一下SpringBoot2的课程，发现好多的注解并不是很了解，只是简单的会用，但是真是发生的作用却不知道，最近花了一些时间把这些注解进行了一下整理，针对不同的层级进行了细致的划分，最近几天会依次给大家更新关于注解的内容，对大家有帮助的话点赞支持一下哦！
4. Service层注解 @Service注解一般写在业务层的接口实现类上，而不是接口上。
4.1 @Service @Service : @Service注解用于类上，标记当前类是一个service类，加上该注解会将当前类自动注入到spring容中。
@Service public class CourseDAOImpl extends HibernateDaoSupport implements CourseDAO{ ... } 复制代码 @Service("courseDAOImpl") ：这个表示给类命名一个别名，方便注入到其他类中。不加这个参数值的话，默认别名就是当前类名，但是首字母小写。
在实际开发中，我们一般都直接使用 @Sevice
4.2 @Scope @Scope ：Spring IOC 容器中的一个作用域，在 Spring IOC容器中，他用来配置Bean实例的作用域对象。
@Scope的几种作用域：
singleton 单实例的(单例)(默认) ----全局有且仅有一个实例。prototype 多实例的(多例) ---- 每次获取Bean的时候会有一个新的实例。reqeust 同一次请求 ----request：每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效。session 同一个会话级别 ---- session：每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效。 默认的作用域是：singleton(单实例)
5. Mapper层注解 5.1 @Reponsitory @Reponsitory ：@Reponsitory的作用与@Controller，@Service的作用都是把对象交给Spring管理。@Reponsitory是标注在Dao层接口上，作用是将接口的一个实现类交给Spring管理。
注意：
使用这个注解的前提是必须在启动类上添加 @MapperScan("Mapper接口层路径") 注解。 这个 @Repository 完全可以省略不写，也完全可以实现自动注入，但是在IDEA中会存在一个红色的波浪线。原因如下：
Spring配置文件中配置了MapperScannerConfiguer这个Bean，它会扫描持久层接口创建实现类并交给Spring管理。SpringBoot的启动类上标注了@MapperScanner，它的作用和上面的MapperScannerConfiguer作用一样。 5.2 @Mapper @Mapper : 这个注解一般使用在Dao层接口上，相当于一个mapper.xml文件，它的作用就是将接口生成一个动态代理类。加入了@Mapper注解，目的就是为了不再写mapper映射文件。这个注解就是用来映射mapper.xml文件的。
@Mapper使用的原理：
Mybatis 会有一个拦截器，会自动的把 @Mapper 注解的接口生成动态代理类。前提是，映射器(Mapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76213203341b05da0cbcee221803bdfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1d9e53d77fb940265768e6d4bf324f/" rel="bookmark">
			Eclipse的下载与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、软件介绍
二、前置条件
三、下载地址
1.官方网站
2.百度网盘
3.移动云盘
三、解压文件
四、运行程序
1.双击打开工具
2.选择项目路径
3.创建新的工程
4.完善项目信息
5.创建项目包名
6.创建项目类名
7.编写实例程序
8.程序运行结果
五、侵权事宜
六、其他问题
一、软件介绍 Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。
最重要的一点，Eclipse是免费的，任何个人和企业都有免费版本可以用。
如果您想看之前的教程，可以移步：Eclipse的下载与配置详细教程_水坚石青的博客
二、前置条件 安装Eclipse之前需要安装JDK，用来运行Java程序。
JDK下载与配置的详细教程：JDK的下载与配置详细教程
注意：需要修改环境变量并且测试成功。
三、下载地址 1.官方网站 注意：选择Eclipse IDE for Enterprise Java and Web Developers的工具，然后下载zip的包，下载zip的包不用安装，直接解压之后就可以用。
链接：https://www.eclipse.org/downloads/packages/
2.百度网盘 链接：https://pan.baidu.com/s/1hPtWcTuhohNHTN7rSLB3Ig
提取码：vmzi
3.移动云盘 链接: https://caiyun.139.com/m/i?1D5C37zuWrUVP
提取码:gm2C
三、解压文件 需要解压压缩文件，然后你可以看到以下的目录。其中eclipse图标，我们可以直接点击然后运行此工具。
四、运行程序 1.双击打开工具 直接双击eclipse图标打开此工具。
2.选择项目路径 3.创建新的工程 路径：File-&gt;New-&gt;Project...-&gt;Java Project-&gt;New Java Project
4.完善项目信息 填写您的项目名称，选择您的JRE环境。
5.创建项目包名 右键项目-&gt;New-&gt;Package
6.创建项目类名 右键包名-&gt;New-&gt;Class
7.编写实例程序 编写主函数，编写输出语句。
package com.sjsq; public class Main { public static void main(String[] args) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b1d9e53d77fb940265768e6d4bf324f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ffd0a138ce59a3e9efd74f02f8c9045/" rel="bookmark">
			宿主机无法访问docker内flask服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景 在Linux系统中利用docker容器部署一个web小应用，项目目录如下：
其中Dockerfile内容是：
其中start.sh内容是：
docker build创建镜像也没问题 ↓
接着运行镜像，run出一个容器，容器名命名为df2，并以交互式模式在后台运行，容器端口和宿主机端口均映射为5000，如下：
查看容器信息并进入容器，访问web应用的网址：127.0.0.1:5000。prefect！完美！！
你以为这样就结束了吗？ 天真 -_-
容器内可以成功运行，但是映射到主机上呢？
在主机上访问就变成这熊样儿了。。。。。。，浏览器也访问不了。。。。。。
经过长达半世纪的探索和同事的点拨，终于找到了问题所在：因为本人所用的是flask项目，项目启动默认用的host是127.0.0.1，port端口是5000，而我们docker端口默认映射的host是0.0.0.0，所以需要把flask监听地址改为0.0.0.0，就好比这样：
然后就是删除容器，删除镜像，改地址，重建build镜像，运行容器…最终问题得以解决↓
在此感谢大佬的指点，原文链接：docker容器部署web应用宿主机无法访问-KuangStudy-文章 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6a8f3bacdc1fe2248986bfe01c6500/" rel="bookmark">
			【强化学习】深度Q网络(DQN)求解倒立摆问题 &#43; Pytorch代码实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、倒立摆问题介绍二、深度Q网络简介三、详细资料四、Python代码实战4.1 运行前配置4.2 主要代码4.3 运行结果展示4.4 关于可视化的设置 一、倒立摆问题介绍 Agent 必须在两个动作之间做出决定 - 向左或向右移动推车 - 以使连接到它的杆保持直立。
二、深度Q网络简介 上图所示为一般的深度 Q \mathrm{Q} Q 网络算法。
深度 Q \mathrm{Q} Q 网络算法是这样的，我们初始化两个网络 ：估计网络 Q Q Q 和 目标网络 Q ^ ， Q ^ \hat{Q} ， \hat{Q} Q^​，Q^​ 就等于 Q Q Q ，一开始 目标网络 Q ^ \hat{Q} Q^​ 与原来的 Q Q Q 网络是一样的。
在每一个回合中，我们用演员与环境交互，在每一次交互的过程中，都会得到一个 状态 s t s_t st​ ，会采取某一个动作 a t 。 a_{t 。} at。​ 怎么知道采取哪一个动作 a t a_t at​ 呢?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e6a8f3bacdc1fe2248986bfe01c6500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abab942072e157a42748aae3934e89c4/" rel="bookmark">
			【Mybatis-Plus】Mybatis-Plus的入门运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Mybatis-Plus】Mapper CRUD 接口 文章目录 【Mybatis-Plus】Mapper CRUD 接口:hamster: 案例环境搭建:rabbit: 如何使用:baby_chick: Insert:duck: Delete:chicken: Update:cactus: Select:santa: 小结 实习快一个月了，老板给我的任务大多都是crud(哈哈哈，我也现在也只会这些），而且用的大都是MP，但有时候一些难的sql语句我也忘的差不多了，所以特来复习一遍。
写的不对的地方希望大佬指出，感谢
学习MP我特别推荐大家去官网学习，那个官网的内容看着非常舒适。
MyBatisPlus（简称MP）是基于MyBatis框架基础上开发的增强型工具，旨在简化开发、提高效率
从这张图中我们可以看出MP旨在成为MyBatis的最好搭档，而不是替换MyBatis,所以可以理解为MP是MyBatis的一套增强工具，它是在MyBatis的基础上进行开发的，我们虽然使用MP但是底层依然是MyBatis的东西，也就是说我们也可以在MP中写MyBatis的内容。
对于MP的学习，大家可以参考着官方文档来进行学习，里面都有详细的代码案例。
MP的特性:
无侵入：只做增强不做改变，不会对现有工程产生影响强大的 CRUD 操作：内置通用 Mapper，少量配置即可实现单表CRUD 操作支持 Lambda：编写查询条件无需担心字段写错支持主键自动生成内置分页插件…… 🐹 案例环境搭建 我们这里直接用SpringBoot搭建环境
步骤1：创建数据库和表
create database if not exists mp_db character set utf8; use mp_db; CREATE TABLE user ( id bigint(20) primary key auto_increment, name varchar(32) not null, password varchar(32) not null, age int(3) not null, tel varchar(32) not null ); insert into user values (1, 'Tom', 'tom', 3, '18866668888'); insert into user values (2, 'Jerry', 'jerry', 4, '16688886666'); insert into user values (3, 'Jock', '123456', 41, '18812345678'); 步骤2：创建SpringBoot工程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abab942072e157a42748aae3934e89c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678c44195a0319301ed380e5cc2a9597/" rel="bookmark">
			如何判断 Linux 服务器是否被入侵及排查病毒方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何判断 Linux 服务器是否被入侵及排查病毒方法？ 啊，天啊，对于一个做前端开发的人来说，对服务器端的知识只略懂一二啊，黑客就知道欺负小白，入侵我的服务器。
一开始我是束手无策的，根本无从所知病毒在哪，黑客怎么入侵我的服务器。接下来，让我们一步步来排查吧，先看看如何判断 Linux 服务器是否被入侵？
2. 判断Linux 服务器是否被入侵 所谓的服务器被入侵或者说被黑了的意思，是指未经授权的人或程序为了自己的目的登录到服务器上去并使用其计算资源，通常会产生不好的影响。
免责声明：若你的服务器被类似 NSA 这样的国家机关或者某个犯罪集团入侵，那么你并不会注意到有任何问题，这些技术也无法发觉他们的存在。
然而，大多数被攻破的服务器都是被类似自动攻击程序这样的程序或者类似“脚本小子”这样的廉价攻击者，以及蠢蛋罪犯所入侵的。
这类攻击者会在访问服务器的同时滥用服务器资源，并且不怎么会采取措施来隐藏他们正在做的事情。
被入侵服务器的症状
当服务器被没有经验攻击者或者自动攻击程序入侵了的话，他们往往会消耗 100% 的资源。他们可能消耗 CPU 资源来进行数字货币的采矿或者发送垃圾邮件，也可能消耗带宽来发动 DoS 攻击。
因此出现问题的第一个表现就是服务器 “变慢了”。这可能表现在网站的页面打开的很慢，或者电子邮件要花很长时间才能发送出去。
那么你应该查看那些东西呢?
2.1 当前都有谁在登录?
你首先要查看当前都有谁登录在服务器上。发现攻击者登录到服务器上进行操作并不复杂。
其对应的命令是 w。运行 w 会输出如下结果：
10:43:09 up 214 days, 1:20, 1 user, load average: 0.00, 0.00, 0.00 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root pts/1 183.15.179.82 09:49 0.00s 0.02s 0.00s w 查了一下ip地址，是自己登陆了，没有其他人登陆，如果查到ip地址不是自己的ip地址就要注意了，这个不是个好兆头。
停下来做个深呼吸, 不要恐慌之下只是干掉他们的 SSH 连接。除非你能够防止他们再次进入服务器，否则他们会很快进来并踢掉你，以防你再次回去。
请参阅本文最后的“被入侵之后怎么办”这一章节来看找到了被入侵的证据后应该怎么办。
whois 命令可以接一个 IP 地址然后告诉你该 IP 所注册的组织的所有信息，当然就包括所在国家的信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/678c44195a0319301ed380e5cc2a9597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51986320805789adce28ef54548997a4/" rel="bookmark">
			图形化IPC端口连接工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：提示：注意：网络安全环境需要大家共同维护，请大家共同遵守网络安全规章制度，仅供大家参考，造成的法律后果，不由本人承担
文章目录 一、IPC服务二、工具原理三、图形化工具1. 工具介绍2. 工具测试 一、IPC服务 IPC$(Internet Process Connection)是共享"命名管道"的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。
IPC 共享端口号 139 和 445
139 是局域网内共享端口号
445 是远程共享端口号
二、工具原理 工具主要采用的是Windows系统中DOS命令net的语法,本文具体介绍的是net use 的用法,
net use语法如下图
net：网络
use：使用
devicename：设备名称
volume：卷
username：用户名
dotted：有点的
SMARTCARD：智能卡
SAVECRED：用用户以前保存的凭据
PERSISTENT：持久的
最主要的命令语法如下：
net use \\IP\IPC$ "password" /user:"username" password是对方主机的密码，username是对方主机的用户名
首先我们每个人的电脑都有可能开启了共享文件夹，这样我们自己的电脑的内容在局域网中就很不安全
在电脑中可以通过如下命令语法进行查看
net share 如果我们知道与自己能够通信的电脑已经开启了共享文件夹内容，并且IPC服务端口也开启，那么我们可以在命令行中，通过如下语法进行连接对方电脑
net use \\IP\IPC$ "PASSWORD" /user:"USERNAME" 例如：net use \\192.168.72.138\IPC$ "123456" /user:"administrator" 运行结果如下
这里的192.168.72.138，是我的本机电脑可以直接访问的，才可以用这个命令进行连接，否则就会报错，报错内容如下
我们运行之后，我们可以通过如下命令语法，查看我们是否已经连接对方电脑
net use 连上之后，我们需要可以将对方共享的文件或文件夹映射到本地，使用的命令语法如下
net use z: \\IP\共享磁盘名$ 例如：net use z: \\192.168.72.138\E$ 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51986320805789adce28ef54548997a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f65c9e0031b4f5ca45c1fe13fa0ad61c/" rel="bookmark">
			Unity开发_滑动Toggle按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using UnityEngine; using UnityEngine.UI; public class TAGButton : MonoBehaviour { public Color IsLaft; public Color IsRight; Toggle _rootToggle; Transform _handle; Image _backGround; float _distance; float _moveTime; private void Awake() { _rootToggle = this.GetComponent&lt;Toggle&gt;(); _backGround = this.GetComponent&lt;Image&gt;(); _handle = this.transform.GetChild(0); _distance = this.GetComponent&lt;RectTransform&gt;().rect.width / 4; _rootToggle.isOn = false; _moveTime = 0.06f; } // Update is called once per frame void Update() { if (Mathf.Abs(_handle.localPosition.x) - _distance &lt; 0.1f) { MoveIng(); } else { MoveEnd(); } } void MoveIng() { _backGround.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f65c9e0031b4f5ca45c1fe13fa0ad61c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da18da0a1ef0b2b7bb19f27d7fbe2b48/" rel="bookmark">
			C#截取串口字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private void SerialPort1_DataReceived(object sender, SerialDataReceivedEventArgs e)
{
if (SerialPort1.IsOpen) //判断是否打开串口
{
//输出当前时间
// DateTime dt = DateTime.Now;
// txtReceived.Text += dt.GetDateTimeFormats(‘f’)[0].ToString() + “\r\n”;
try
{
Byte[] receivedData = new Byte[SerialPort1.BytesToRead]; //创建接收字节数组
SerialPort1.Read(receivedData, 0, receivedData.Length); //读取数据
//string result = new UTF8Encoding().GetString(receivedData);//用万能的UTF8可以传输中文不会乱码
SerialPort1.DiscardInBuffer();
string strRcv = null;
for (int i = 0; i &lt; receivedData.Length; i++ )
{
strRcv += ((char)Convert.ToInt32(receivedData[i])) ;
}
richTextBox1.Text += strRcv+“\r\n”;
int start = 1, length = 3;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da18da0a1ef0b2b7bb19f27d7fbe2b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c609b8c0f5ccd635f07fac1e8bc8152c/" rel="bookmark">
			Vue 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识铺垫 VScode 中 Vue 插件 Vue 3 Snippets
Vetur axios axios 是一个专注于网络请求的库！
axios 的基本使用（前提npm了axios或者导入了axios的js文件）：
发起 GET 请求：
axios({ // 请求方式 method: 'GET', // 请求的地址 url: 'http://www.example.xyz/xxx', // URL 中的查询参数 params: { id: 1 } }).then(function (result) { console.log(result) }) 发起 POST 请求：
document.querySelector('#btnPost').addEventListener('click', async function () { // 如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await！ // await 只能用在被 async “修饰”的方法中 const { data: res } = await axios({ method: 'POST', url: 'http://www.example.xyz/xxx', data: { name: 'zs', age: 20 } }) console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c609b8c0f5ccd635f07fac1e8bc8152c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d57e229c11282ed0daca35f2e04f1a/" rel="bookmark">
			【Android】【移动应用开发】基础案列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跑马灯效果 ⚪页面布局代码如下：
&lt;TextView android:layout_width="fill_parent" android:layout_height="wrap_content" android:background="#55333333" android:ellipsize="marquee" android:focusable="true" android:focusableInTouchMode="true" android:marqueeRepeatLimit="marquee_forever" android:paddingLeft="10dp" android:paddingRight="10dp" android:singleLine="true" android:text="欢迎注册卡特曼大学计算机学院智慧校园平台，注册成功后，你可以方便获得校内咨询！" android:textColor="#FFFF00" android:textSize="20dp"/&gt; 动态向左移动
计算器的实现 ⚪页面布局代码如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical" android:background="#ffc0cb" tools:ignore="MissingConstraints"&gt; &lt;!--第一行--&gt; &lt;TextView android:id="@+id/txtresult" android:background="#79BFB9" android:layout_margin="4dp" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center_vertical|right" android:hint="显示结果" android:textSize="32sp" android:lines="5" /&gt; &lt;!--第二行--&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:id="@+id/btn_clear" android:onClick="calClick" android:layout_width="0dp" android:layout_height="80sp" android:layout_weight="1" android:textColor="#CF7E07" android:textSize="25sp" android:text="C"/&gt; &lt;Button android:id="@+id/btn_del" android:onClick="calClick" android:layout_width="0dp" android:layout_height="80sp" android:textSize="25sp" android:textColor="#B68B4C" android:layout_weight="2" android:text="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96d57e229c11282ed0daca35f2e04f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ef4522cffe49f6c81651bbe63c9abb/" rel="bookmark">
			Java如何从字符串中提取数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在使用java编程处理字符串时，常常需要获取字符串中的数字，来进行进一步的计算。接下来介绍几种从字符串中提取数字的方法。
1.正则表达式 String str = "love234csdn3423java"; String regEx = "[^0-9]"; Pattern p = Pattern.compile(regEx); Matcher m = p.matcher(str); String result = m.replaceAll("").trim(); 这里正则表达式表示匹配除数字以外的字符，然后replaceAll方法使用空字符代替匹配的字符，这样剩下的字符串就只包括数字。最后只需要将result转换为int类型就结束了
2.用字符串方法处理 String str = "love234csdn3423java"; str = str.trim(); String str2 = ""; if(str != null &amp;&amp; !"".equals(str)){ for(int i = 0; i &lt; str.length(); i++){ if(str.charAt(i) &gt;= 48 &amp;&amp; str.charAt(i) &lt;= 57){ str2 += str.charAt(i); } } } 这里通过一个for循环，对字符串的每个字符进行处理，如果在0-9之间就追加到str2上，最后返回的str2只包含数字
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f52ae32a13f1bf95fc78385db96823/" rel="bookmark">
			Git 修改用户名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开Gitbash
在gitbash中输入
第一步：git config user.name
查看现在的名字
第二步：git config user.email
查看邮箱
第三步：git config --global user.name “你要修改的名字”
要修改的名字写在“ ” 中
第四步：git config user.name
再次看下现在的名字，看是否修改成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/906f71cef2e15a58d1badb33a0bf643a/" rel="bookmark">
			10 分钟教会你如何看懂 MySQL 执行计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常查询慢查询SQL语句时会使用EXPLAIN命令来查看SQL语句的执行计划，通过返回的信息，可以了解到Mysql优化器是如何执行SQL语句，通过分析可以帮助我们提供优化的思路。
1. Explain 作用 explain 命令主要用于查看 SQL 语句的执行计划，该命令可以模拟优化器执行 SQL 查询语句，可以帮助我们编写和优化 SQL。那么 explain 具体可以提供哪些信息，帮助我们如何去优化 SQl 的呢？
表的读取顺序数据读取操作的操作类型哪些索引可以使用哪些索引被实际使用表之间的引用每张表有多少行被优化器查询 2. Explain 如何使用 使用方式： explain + 待执行的sql
explain 会返回一个待执行 SQL 的执行计划列表，列表包含了 12 个字段，字段共同描述了 SQL 在执行计划中将会采取何种方式执行。以下列表详细描述了执行计划表的字段含义：
字段名称描述id执行 select 语句查询的序列号，决定表的读取顺序select_type查询的类型，也就是数据读取操作的操作类型table查询的表名partitions表分区type访问类型possible_keys可使用的索引。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用到。如果这个字段为 null 但是字段 key 不为 null，这种情况就是在查找时没有可以使用的二级索引树，但是二级索引中包含了需要查询的字段，于是就不再查找聚簇索引（聚簇索引比较大），转而扫描这个二级索引树（二级索引树比较小），并且此时一般访问类型 type 为 index，及扫描整棵索引树。key实际扫描使用的索引。如果为 null，则没有使用索引；查询中若使用了覆盖索引，则该索引仅出现在key列表中；key_len索引中使用的字节数。可通过该列计算查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好；key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的；ref显示索引的哪一列被使用了。如果可能的话，是一个常数，哪些列或常量别用于查找索引列上的值；rows根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数；filtered搜索条件过滤后剩余数据的百分比。Extra包含不适合在其它列中显示但十分重要的额外信息 3. 关键字段分析 （1）id 执行 select 语句查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序，它有三种情况：
类型名称描述id相同执行顺序由上至下id不同如果是子查询，id 的序号会递增，id 值越大优先级越高,越先被执行id相同不同，同时存在如果 id 相同，可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行 （2）select_type 就是数据读取操作的操作类型，他一共有以下几种：
类型名称描述simple简单的 select 查询，查询中不包含子查询或者 union；primary查询中若包含任何复杂的子查询，最外层查询则被标记；subquery在 select 或者 where 列表中包含了子查询；dependent subquery子查询中的第一个 SELECT， 取决于外面的查询。 即子查询依赖于外层查询的结果。derived在 from 列表中包含的子查询被标记为 DERIVED（衍生表），mysql 会递归执行这些子查询，把结果放临时表中；union若第二个 select 出现在 union 之后，则被标记为 union，若 union 包含在 from 子句的子查询中，外层 select 将被标记为 DERIVED；union result从 union 表（即 union 合并的结果集）中获取 select 查询的结果；meterialized物化表，子查询关联查询时，子查询结果存储在物化临时表，然后根据临时表中的数据去主表匹配。dependent unionUNION 中的第二个或后面的查询语句，取决于外面的查询 （3）table 显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为 null，也可以是以下之一：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/906f71cef2e15a58d1badb33a0bf643a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd80e5ed568f9ce33768292779a0de6/" rel="bookmark">
			vue使用h5puls做APP自动更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们先来理清思路在来一步步的做 确保当前有h5puls的第三方库 或者使用HBuilder X 或者HBuilder 来打包webapp APK中就自动集成了h5puls（或者可以写道其他事件里面触发检查更新下载版本）
这里APP自动更新全部都在App.vue 页面完成
h5puls官方文档
先检查安装的apk的版本号，
文档链接Runtime
使用 plus.runtime.getProperty API	官方文档代码 // 获取应用信息 function getAppInfo() { plus.runtime.getProperty( plus.runtime.appid, function ( wgtinfo ) { //appid属性 var wgtStr = "appid:"+wgtinfo.appid; //version属性 wgtStr += "&lt;br/&gt;version:"+wgtinfo.version; //name属性 wgtStr += "&lt;br/&gt;name:"+wgtinfo.name; //description属性 wgtStr += "&lt;br/&gt;description:"+wgtinfo.description; //author属性 wgtStr += "&lt;br/&gt;author:"+wgtinfo.author; //email属性 wgtStr += "&lt;br/&gt;email:"+wgtinfo.email; //features 属性 wgtStr += "&lt;br/&gt;features:"+wgtinfo.features; console.log( wgtStr ); } ); } 这里我们也使用这个API 来获取APPID window.plus.runtime.getProperty(window.plus.runtime.appid,(inf)=&gt;{ console.log(inf) //当前APP的数据包含了APP的版本号 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbd80e5ed568f9ce33768292779a0de6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc88fa8985c9e2b04ede80adb319761d/" rel="bookmark">
			C语言volatile 关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是volatile关键字 volatile用于声明一个变量，告诉编译器该变量值容易发生改变，在编译、读取、存储该变量的时候都不要做任何优化，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取存储数据，不做优化，在做嵌入式开发的时候，因为有时变量地址有可能是系统的一个外设地址，他的值的变化并不在程序控制范围内，随时有可能变化，因此需要对他进行声明，每次读取或者存储直接对地址进行操作。
变量如果加了 volatile 修饰，则会从内存重新装载内容，而不是直接从寄存器拷贝内容。
为什么使用volatile关键字 const 和 volatile 关键字是一种类型修饰符，两个是绝对对立的。volatile 的作用 是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。
什么时候使用volatile关键字 1、并行设备的寄存器（例如状态寄存器），存储器映射的硬件寄存器通常加volatile。
设备寄存器会在你的程序不知道或者不介入的时候发生改变，那是因为设备寄存器可以被外设硬件修改，相反，变量中的不会变。设备寄存器的内容是易失的，或者在不注意的时候被修改，当声明指向设备寄存器的指针时一定要用volatile，它会告诉编译器不要对存储在这个地址的数据进行假设，编译器在优化这个变量时应该把它看作编译时未知的。
2、一个中断服务程序中修改的供其它程序检测的变量。
由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化，例如：
static int i=0; //i 为非自动变量 int main(void) { ... while (1){ if (i) dosomething(); } } /* Interrupt service routine. */ void ISR_2(void) { i=1; } 程序的本意是希望 ISR_2 中断产生时，在main函数中调用 dosomething 函数，但是，由于编译器判断在 main 函数里面没有修改过 i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致 dosomething 永远也不会被调用。如果将变量加上 volatile 修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。
3、多线程应用中被几个任务共享的变量（防止编译器对代码进行优化）。
当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile 声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值，
上面说到volatile关键字主要是防止被编译器优化或改变，那么上面是编译器优化呢？
GCC优化 通常C语言的编译器使用的是GCC编译器，他有个以下几个等级的优化
-O0 ：(默认)：没有优化。-O或-O1 ：优化，但不要花费太多的时间。-O2 ：更积极地优化-O3 ：最积极地优化-Ofast ：最高级的优化-Os ： 优化代码大小-Og ：在尽量不干扰调试的情况下优化 开启不同的优化等级，程序编译后的结果就会发生一定的变化，而volatile就是在开启优化的情况下使用，保护变量不被优化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc88fa8985c9e2b04ede80adb319761d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/92/">«</a>
	<span class="pagination__item pagination__item--current">93/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/94/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>