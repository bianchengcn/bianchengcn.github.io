<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bb5836a6b4e3788081232baa061286f/" rel="bookmark">
			JAVA面向对象36道练习题代码总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 // 创建一个动物类 姓名 年龄 性别 会介绍自己 // 思考 如果在类中声明成员变量 没有给初值 那么有初值吗? // 有 因为对象创建在堆内存(堆内存有默认的初始值) // 睡觉方法 吃饭方法 public class Demo01 { public static void main(String[] args) { Animal animal = new Animal(); animal.name = "猪"; animal.age = 3; animal.kind = "公"; animal.sayHi(); animal.eat(); animal.sleep(); } } class Animal{ String name; String kind; int age; public void eat() { System.out.println("动物会吃饭"); } public void sleep() { System.out.println("动物喜欢睡觉"); } public void sayHi() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bb5836a6b4e3788081232baa061286f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5020a8be2e7622fe4277afd4453b55ee/" rel="bookmark">
			VB语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重新回头看VB课本，在看过C#的视频之后，老师们经常说计算机的语言有很大的相似性，只要你学会精通一门计算机高级语言其他的高级语言就很容易的学会了，就像经历过的人学VB学一年，,NET学习一个月，C# 学习两个月，C++学习两个月，JAVA学习两个月基本的理论知识就了解了，通过项目练习积累经验你就完美的学会了编程。说说我的VB的学习，通过积累自己对VB有了现在的理解，虽然还有很多的东西不是知道。但是再去接触也很轻松。
学习是一个知识积累思考的过程。大家学习VB从一开始的看书，理解，慢慢的看着课本的目录去对自己学习的东西有序，整理自己的VB语言的框架，实际也是按照目录出现的。第一版的整理没有了，看第二，第三，第四版。看完这些图我意义的说我的思考角度。个人认为每个角度都可以，没有对错，只有自己的理解。
上面这张图就没有自己思考什么都不想就是看书有几个章节就有几个二级的分支，而后二级分支的后面又写了几个标题，就在它的后面加几个分支，由此你可以看到这样个思维方式的宏伟蓝图，很详细可以和笔记媲美了，你这样认为吗？但是这样的一张图对我们的的记忆不是很清晰，没有重要突出，但是细节很多，没有自己的思考联系，你理解这张图也是有问题的，就不要说几个月后你都不知道这图是不是你画的了。
下面这张图
这张图就有了自己的思考了，把很多的东西有联系的知识联系起来，如何有这些联系就是联想。例如，我画这张图的时候我会想VB学习时自己咋学习的。首先会有理论知识，和实践知识，理论知识就是一些代码中的应用例如规则， 声明，变量，常量，函数，过程，文件，VB 6.0，数据库 ，工程，面向对象 。这就是自己的考虑，通过他门之间的联系分类整理。就是现在的图片。 上面的是C#的一个学习最后版的东西，也是自己的考虑的东西思维。自己的考虑就是语言吗！代码层次，工具层次。工具的应用，基础知识的学习，通过这些东西我们就学会了一门计算机语言。简单而有效果。第一次的C#的图片，你对比看思维改变的巨大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0150336905a404e250c0df4c4ec7b14c/" rel="bookmark">
			Linux和Windows中换行的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考自这里！ 对于内容看起来一样的两个C文件，一个是Linux下的文件，一个是Windows下的文件。 在nodepad++中可以从状态栏中看出文件的是Linux下的还是Windows下的。如下面两个图：
他们看起来文件的内容是一样的，将它们转成二进制文件后，则可以看出不同： 在windows下：\r\n代表换行，拆分两个代码是：回到行首+换到下一行 但是在linux下的区别是：只用\n即可以代表换行。
\r 的十六进制的ASCII值为： 0d \n 的十六进制的ASCII值为： 0a \t 的十六进制的ASCII值为： 09
od命令参考自这里！ 在Linux下和Windows下新建的文件的区别 在Linux下和Windows下新建一个文本文件，注意只是新建，并不向文件中写入数据，此时两个文件是一样的。此时的文件(不管是何处新建的)放在Windows下和Linux下都是一样的。
但是一旦修改则不一样。在Linux下修改并保存，则换行是 \n ，在Windows下修改并保存，则换行是 \r \n 。
并且，一旦修改并保存，则该文件的换行是 \n 还是 \r \n 都是不会变了，除非人为的修改，只是修改保存其中的内容，换行的内容是不会变的。例如：换行是 \n 的文件放在Windows下增加一个换行(使用的编辑工具是Nodepad++)，Windows下增加的换行还是 \n ；换行是 \r \n 的文件放在Linux下增加一个换行(使用的工具是vim)，Linux下增加的换行还是 \r \n 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b25416641073da40e92642f9a35ecf5/" rel="bookmark">
			多光谱影像分类（双通道CNN实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍
2017年IEE IGRASS多光谱影像分类比赛，选用两个卫星landsat_8和sentinel_2所拍摄的多光谱图像作为输入，输出像素级分类图像。其中landsat_8有4个时段的影像数据，sentinel_2只有一个时段的影像数据。拍摄城市有巴黎/柏林/罗马/香港/圣保罗 五个地区，模型选用前4个地区的数据作为训练样本，圣保罗地区数据作为测试样本。依次选取landsat_8的每个时段数据与sentinel_2的数据组合，作为输入数据，输出为所属种类。开始采用分割图的方法，将训练影像分割为若干个28*28*channel 的小图，每个小图的label对应为中心像素点坐标在groundtruth上划分的种类。训练模型选用双通道2层CNN架构，即（conv+relu+pool)*2，最后一层将双通道的稀疏特征进行级联，作为最终的特征向量，再通过2层全连接层，并送入softmax层输出最终分类结果。训练时采用dropout和全连接层权值正则化的方式防止过拟合，在训练样本的采集方面也先进行了边缘填充，并将各个种类的样本都选择1000个，不够1000的则全部选用，以保证样本的多样性和平衡性，并对数据进行归一化。在最后的测试时，将landsat_8的4个时段的预测结果进行投票打分，最后选择得分最高的类作为最终label。在对数据进行划分时，可以采用稀疏采样，用5*5像素块对原始图进行滑窗操作，若块内像素类全部相同且不是背景类，则间隔一个像素进行稀疏采样，只选取一半的像素点作为训练数据，以保证训练样本的多样性，最后测试结果显示，稀疏采样可提高模型预测的准确率。
2.代码：
# This Python file uses the following encoding: utf-8 import tensorflow as tf # 深度学习框架 import matplotlib.pyplot as plt # 画图包 import numpy as np # 矩阵运算包 import scipy.io # 保存图片 from PIL import Image # 图像处理 from tqdm import tqdm # 进度条 import os # 读取文件 import time # 获取时钟时间 import h5py # 读取文件 import sys # 系统输出格式 # 定义输入图像的大小 28*28 IMAGE_SIZE = 28 # 两个卫星的通道数，分别为9和10 NUM_CHANNELS_1 = 9 NUM_CHANNELS_2 = 10 # 像素值0~255 PIXEL_DEPTH = 255 # 分类个数为17 NUM_LABELS = 17 # 验证集共有1000个样本 VALIDATION_SIZE = 1000 # 设置随机种子大小 # SEED = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b25416641073da40e92642f9a35ecf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c084544c07fc588dcd00d5852263597/" rel="bookmark">
			VARCHAR 和 TEXT 长度问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于varchar、text字段类型的长度问题探究结果 VARCHAR ：varchar在mysql中满足最大行限制，也就是 65535(16k)字节，在mysql中使用 uft-8（mysql中的 utf-8 和我们正 常的编码utf-8不同）字符集一个字符占用三个字节， ①使用 utf-8 字符编码集 varchar 最大长度是 (65535-1)/3=21844 个字符（由于会有1字节的额外占用空间开销， 所以减1）。 ②使用 utf-8mb4 字符集（mysql中 utf-8mb4 字符集也就是我们通常使用的 utf-8 字符集），mysql中使用 utf- 8mb4 字符集一个字符占用4个字节，所以 varchar 最大长度是 （65535-1)/4=16383 个字符（由于1字节额外占用空间开销，所以减1）。 TEXT :最大限制是64k， 采用 utf-8 字符集,(262144-1)/3=87381 个字符。 采用 utf-8mb4字符集，(262144-1)/4=65535 个字符。 MEDIUMTEXT :最大长度限制16M (16M-1)/3 = 5,592,405 个字符 LONGTEXT :最大长度限制4G VARCHAR测试 通过上面测试案例可以知道，当 VARCHAR 长度超过 21844 时就会报 1118 错误（因为超过 VARCHAR 长度）。所以在 mysql 中使用 utf-8 编码集 VARCAHAR 最大字符容量为21844个字符。同时也可以得出 ( 65535-(21845*3)=0 ) &lt; 占用额外空间 &lt; ( 65535-(21844*3)=3 ) INT测试 通过上面测试案例可以知道int类型占用额外空间 TEXT测试 通过上面测试案例可以知道 TEXT 类型占用额外空间， 如有不足，请大家指出。我只是编程小菜鸡，仅供采纳。 路漫漫其修远兮 吾将上下而求索 ~_~。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b40af2abc355685fdcea2c6c9dfc495/" rel="bookmark">
			Windows引导修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天偶遇一个问题，电脑系统引导启动不了！
不怕，分享一下我们PE系统里面的引导修复工具来修复引导
1. 插入启动盘[我的是老毛桃]，重启，进入bios界面设置从USB启动，进入老毛桃的主菜单界面，选择【02】运行老毛桃Win8PE防蓝屏版(新电脑)
2. 进入Win8PE系统后，双击运行桌面上的"修复系统引导"程序，点击选择引导分区盘符(一般是c盘)
3. 确定引导分区后，点击【1.开始修复】
4. 修复完成，修复成功后面显示修复磁盘盘符及备份
[由于我的电脑引导正常，所以修复成功后面显示无]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1df7063f937251566877828626b0aba2/" rel="bookmark">
			[游戏数据表]七日杀 7DAYS TO DIE全物品合成表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		七日杀 7DAYS TO DIE全物品合成表 相关资料：
1.
七日杀 v6合成表查询工具 2.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6509296fb721ab128a9f859cc8bcc2a6/" rel="bookmark">
			[游戏数据表]泰拉瑞亚Terraria 全物品属性表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部分浏览：
网盘分流
相关文章：
1.
《泰拉瑞亚》全物品表 2.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a57c5e0355100240cc1fee67e8acb98/" rel="bookmark">
			你所不知道的 Typescript 与 Redux 类型优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原发于知乎专栏，欢迎关注：zhuanlan.zhihu.com/p/32112508
自从 Redux 诞生后，函数式编程在前端一直很热；去年7月，Typescript 发布 2.0，OOP 数据流框架也开始火热，社区更倾向于类型友好、没有 Redux 那么冗长烦琐的 Mobx 和 dob。
然而静态类型并没有绑定 OOP。随着 Redux 社区对 TS 的拥抱以及 TS 自身的发展，TS 对 FP 的表达能力势必也会越来越强。Redux 社区也需要群策群力，为 TS 和 FP 的伟大结合做贡献。
本文主要介绍 Typescript 一些有意思的高级特性；并用这些特性对 Redux 做了类型优化，例如：推导全局的 Redux State 类型、Reducer 每个 case 下拿到不同的 payload 类型；Redux 去形式化与 Typescript 的结合；最后介绍了一些 React 中常用的 Typescript 技巧。
理论基础 Mapped Types 在 Javascript 中，字面量对象和数组是非常强大灵活。引进类型后，如何避免因为类型的约束而使字面量对象和数组死气沉沉，Typescript 灵活的 interface 是一个伟大的发明。
下面介绍的 Mapped Types 让 interface 更加强大。大家在 js 中都用过 map 运算。在 TS 中，interface 也能做 map 运算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a57c5e0355100240cc1fee67e8acb98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cb781d79dfc83210ee6b93612118c33/" rel="bookmark">
			车牌号校验正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 匹配武警车牌
^WJ[京津冀晋蒙辽吉黑沪苏浙皖闽赣鲁豫鄂湘粤桂琼川贵云渝藏陕甘青宁新]?[0-9a-zA-Z]{5}$ 匹配军牌
/[A-Z]{2}[0-9]{5}$/ 1、现在大多数车牌
匹配民用车牌和使馆车牌
判断标准：
第一位为汉字省份缩写项目第二位为大写字母城市编码后面是5位仅含字母和数字的组合 ^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$ 2、新增新能源车牌号，具体编码规则是：
省份简称（1位汉字）+发牌机关代号（1位字母）+序号（6位）。小型新能源汽车号牌的第一位必须使用字母D、F（D代表纯电动新能源汽车，F代表非纯电动新能源汽车），第二位可以使用字母或者数字，后四位必须使用数字。大型新能源汽车号牌的前五位必须使用数字，第六位必须使用字母D、F（D代表纯电动新能源汽车，F代表非纯电动新能源汽车）。序号中英文字母I和O不能使用。 ^([\u4e00-\u9fa5][a-zA-Z](([DF](?![IO])[A-Z0-9][0-9]{4})|([0-9]{5}[DF])))$ 因此调整正则表达式为：
new Regex(@"^(([\u4e00-\u9fa5]{1}[A-Z]{1})[-]?|([wW][Jj][\u4e00-\u9fa5]{1}[-]?)|([a-zA-Z]{2}))([A-Za-z0-9]{5}|[DdFf][A-HJ-NP-Za-hj-np-z0-9][0-9]{4}|[0-9]{5}[DdFf])$", RegexOptions.Compiled); 3、新添加农用车辆及拖拉机车牌号验证：
农用车车牌号示例：山东01-54321, 山东A54321
手扶拖拉机：示例：鲁1961378
new Regex(@"^(([\u4e00-\u9fa5][a-zA-Z]|[\u4e00-\u9fa5]{2}\d{2}|[\u4e00-\u9fa5]{2}[a-zA-Z])[-]?|([wW][Jj][\u4e00-\u9fa5]{1}[-]?)|([a-zA-Z]{2}))([A-Za-z0-9]{5}|[DdFf][A-HJ-NP-Za-hj-np-z0-9][0-9]{4}|[0-9]{5}[DdFf])$", RegexOptions.Compiled); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b5b8ff9b727ba851c3e4f5e29e01ca/" rel="bookmark">
			单链表（结构体与类实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.单链表数据结构，自带sort函数按照从小到大排列，插入数据时，从链表头往后扫，将插入数据放在遇到的第一个比插入data小的数的前一位。
2.代码
#include&lt;iostream&gt; using namespace std; struct LinkNode { public: LinkNode(int value = 0) { nValue = value; pNext = NULL; } ~LinkNode() {pNext = NULL;} private: friend class LinkList; int nValue; LinkNode *pNext; }; class LinkList { public: LinkList(); ~LinkList(); void Insert(int nData); void Delete(int nData); void Sort(); bool IsEmpty(); void Reverse(); void Destroy(); int Length(); LinkNode* Find(int nData); bool IsLoop(); void Print(); private: LinkNode *pHead; }; LinkList::LinkList() { pHead = new LinkNode(); // new可以在申请空间的同时调用构造函数 } LinkList::~LinkList() { Destroy(); } //从大到小插入 void LinkList::Insert(int nData) { if(pHead == NULL) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b5b8ff9b727ba851c3e4f5e29e01ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15f266735ddd8e93c5316baacde7c1e3/" rel="bookmark">
			【操作系统】页式储存方式，页，页表，页表项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// //操作系统和计算机组成原理里都讲到内存管理的页式管理，但是本人以及很多初次学习分页的时候，都会迷茫页表大小和页表项大小之间的关系，本人仔细分析了后写了这篇blog，仅当学习交流，个人理解之用，如果有错或者分析不够严谨，欢迎指正。 //按字、图结合起来分析，相信还是比较容易看懂。
//一、首先明确几个概念 逻辑地址：是程序编译后，生成的目标模块进行编址时都是从0号单元开始编址，称之为目标模块的相对地址，即为逻辑地址。
页：将进程划分的块，对应的大小就叫页面大小。
页框：将内存划分的块。
页和页框二者一一对应，一个页放入一个页框，（理论上）页的大小和页框的大小相等。
页表：就是一个页和页框一一对应的关系表。【存放在内存中】 关系表只是起到一个索引的作用，说白了就是能根据关系表能查到某一个页面和哪一个页框所对应。
//
//
//二、用例子说话【例子出现在：《王道考研操作系统》的内存管理部分】 已知条件：逻辑地址32位、页面大小4KB、页表项大小4B，按字节编址。
分析： 1. ​ ​ 首先
32
位的虚拟地址可表示的进程大小应该是2^32B = 4GB（暂时别去想页号P占多少位，W占多少位）
​ 2.（根据页的定义和页面大小的定义）将进程进行分页： 3.我们已经知道了页面的数目为：2^20页。现在的迷茫点就在于页表项的问题上。 上图在页表上已经给出了几个数据：20位，12位，32位，2^20项。一一解释如下【请结合上图一个一个数据分析】： ​ 2^20项：因为页表的作用是要将页面的页框一一对应起来，所以，每一个页面在页表中都应该有一个页表项：用来表示一个页号对应一页页框号（内存中的块号），故应 ​ 该有2^20项。【不应该有问题吧，就好像一个班有50个同学，每个人都应该有一个地址一样】
20位：已经很显然了，需要表示出2^20个页表项，就至少需要20位的地址。为什么只取20位而不是21位，22位呢，本人现在还没想这个问题，就暂时定为恰好取20位即可。
32位：已知条件里告诉了页表项大小为4B，那么自然就应该是32位了。
12位：32位-20位 = 12位。为什么页框号地址为12位，只能表示2^12个页框，要小于2^20个页面呢，因为并不是进程的每一个页面都要调入内存。其实32位、12位、20位这三个数据还是有一定依据的，在二级分页的时候就会发现“哦，原来刚刚好”。此处暂不讨论二级分页。
4.通过上面的分析我们得出了哪些数据： 逻辑地址32位，进程大小：4GB。
页面：大小4KB，数量：2^20页。
页表项：4B，数量：2^20项。所以页表就需要4B*2^20 = 4MB的空间存储（这就是书中说：页表项大小为4MB的由来）进一步，主存的页框大小和页面大小是相等的，也为4KB，所以将页表存在主存就需要占用4MB/4KB = 1024页（因为页表也是存在主存中的，而主存也是按页框划分的。这的确是一种资源浪费，所以就需要建立二级页面，将其大小控制在1页之内，将二级页面存入主存即可）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec487ccb237b0faff0a65f6f15da88b/" rel="bookmark">
			堆排序实现优先队列（Priority queue）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.大体思路 队列内使用最大堆排序，将最大值放在根节点，出队操即每次取出堆顶值，并将队列长度减1；入队操作则是在队列末尾加入待入队的数字，并使用之前函数BuildMaxHeap(Arr, Len)重新建立最大堆；获得队首值则直接返回Arr[0]即可，每次操作前检查队列是否为空。 2.代码如下
#include &lt;iostream&gt; #include &lt;ctime&gt; #include &lt;windows.h&gt; using namespace std; int Len; int Arr[100]; //struct HeapStruct { // int Capacity; // int Size; // int *Element; //}; //HeapStruct* Initialize(int MaxNum) { //} void Swape(int *p, int *q) { int tmp = *p; *p = *q; *q = tmp; } void RandomSort(int *nArr, int nLen) { srand(time(NULL)); for(int i = 0; i &lt; nLen; ++i) { int nIndex = rand() % nLen; Swape(&amp;nArr[i], &amp;nArr[nIndex]); //Sleep(2000); //等待2s，更新随机种子 } } void InitArr(int *nArr, int nLen) { //初始化数组 srand(time(NULL)); for(int i = 0; i &lt; nLen; ++i) { //nArr[i] = rand() % 100; nArr[i] = i; } } void PrintArr(int *nArr, int nLen) { //打印数组 for(int i = 0; i &lt; nLen; ++i) { cout &lt;&lt; nArr[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ec487ccb237b0faff0a65f6f15da88b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d94d06aa6c12d91a1b5057aabefdc5e/" rel="bookmark">
			西门子plc s7-200 读取plc内部时间的方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读取以及设置plc内部时钟的方法，用read_rtc和set_rtc的方法
，一下以读取为例，读取我的plc内部时间，设置同理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cbd5d0f2a4145052ffdbd68175ef4c9/" rel="bookmark">
			图像连通域分析（Two-Pass &amp; DFS ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客：http://blog.csdn.net/icvpr/article/details/10259577#reply two-pass法原文中的代码有错误，添加了并查集数据结构后得以解决。 DFS方法无误。 本文代码的作用是，寻找图片中的所以连通域，并保留面积最大的连通域，其他区域删除。
#include &lt;iostream&gt; #include &lt;opencv2\highgui\highgui.hpp&gt; #include &lt;opencv2\core\core.hpp&gt; #include &lt;opencv2\imgproc\imgproc.hpp&gt; #include &lt;map&gt; #include &lt;stack&gt; #include &lt;string&gt; #include &lt;list&gt; #include &lt;stdio.h&gt; #include &lt;time.h&gt; using namespace std; using namespace cv; void myFillSeedFill(const Mat&amp; _binImg, Mat&amp; _labelImg) { if(_binImg.empty() || _binImg.type() != CV_8UC1) { return; } _labelImg.release(); _binImg.convertTo(_labelImg, CV_32SC1); int label = 1; int rows = _binImg.rows; int cols = _binImg.cols; vector&lt;pair&lt;int, int&gt;&gt; area; int maxLabel = 0; int maxLabelNum = 0; for(int i = 0; i &lt; rows; ++i) { int * p = _labelImg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cbd5d0f2a4145052ffdbd68175ef4c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ece4b597c8ac2e50d414817338594133/" rel="bookmark">
			结构体指针作函数的参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以结构体指针作为参数，在函数中对age成员执行了加1操作。由于使用了指针作为参数，因此在函数内部对age值做的修改，使得数组的实际值也改变了。
#include&lt;stdio.h&gt; struct student { int number; char name[20]; char sex; int age; char addr[30]; }; //以结构体指针作为参数 void print_struct(struct student *p) { //对age成员执行加1操作 p-&gt;age ++; printf("%d,%s,%c,%d,%s\n",p-&gt;number,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;addr); } int main() { struct student s[3] = { {10000,"Zhang",'m',21,"Shang Hai"}, {10001,"Li",'f',20,"Bei Jing"}, {10002,"Liu",'m',22,"Guang Dong"} }; printf("%d,%d,%d\n",s[0].age,s[1].age,s[2].age); struct student *p; for(p=s; p&lt;s+3; p++) print_struct(p); printf("%d,%d,%d\n",s[0].age,s[1].age,s[2].age); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a57229f22dc7e5a49c7baff7dcfa86d/" rel="bookmark">
			笔记 rgba属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明： RGBA(R,G,B,A)
取值： R： 红色值。正整数 | 百分数 G： 绿色值。正整数 | 百分数 B： 蓝色值。正整数 | 百分数 A： Alpha透明度。取值0~1之间。 说明： RGBA记法。 此色彩模式与RGB相同，只是在RGB模式上新增了Alpha透明度。IE6.0-8.0不支持使用 rgba 模式实现透明度，可使用 IE 滤镜处理，如： 示例代码：
&lt;span style="font-family:Times New Roman;font-size:14px;"&gt;filter: progid:DXImageTransform.Microsoft.Gradient(startColorstr=#88000000, endColorstr=#88000000);&lt;/span&gt; #88000000 的前两位数字控制透明度，取值16进制从00 -&gt; FF（越小越透明），00表示完全透明，FF就是全不透明，后面六位是色值。
扩展知识： progid:DXImageTransform.Microsoft.Gradient()滤镜里的 startColorstr 参数值是 #AARRGGBB 形式的， 其中的AA是代表不透明度的十六进制，00表示完全透明，FF就是全不透明，化成十进制的范围就是0~255，剩下的 RRGGBB 就是颜色的十六进制代码。
举例如：background: rgba(125, 0, 0, .3); 表示的是30%不透明度的红色背景。把30%的不透明度转换成十六制呢的方法如下：先计算#AA的的十进制x，x/255 = 3/10，解得x=3*255/10，然后再把x换算成十六进制，约等于4C。
常用透明度对应16进制关系： .0（00） .1（19） .05（0C） .15（26） .2（33） .3（4C） .25（3F） .35（59） .4（66） .5（7F） .45（72） .55（8C） .6（99） .7（B2） .65（A5） .75（BF） .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a57229f22dc7e5a49c7baff7dcfa86d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18eae61b307a1d44c8484e852e16b9e3/" rel="bookmark">
			mysql insert插入时实现如果数据表中主键重复则更新，没有重复则插入的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql insert插入时实现如果数据表中主键重复则更新，没有重复则插入的四种方法 1、replace语句：替换已有的行 replace语句是insert语句的一个变种 当添加新行时 1）如果主键值重复，那么覆盖表中已有的行 2）如果没有主键值重复，则插入该行 2、ignore insert语句可以使用ignore选项来当insert语句出现错误时，不显示错误信息，但是insert语句不执行。 insert ignore into 。。。。。 3、可以采用异常抓捕的方式来实现handler，相当于sqlserver中的try catch 4、如果在INSERT语句末尾指定了ON DUPLICATE KEY UPDATE，并且插入行后会导致在一个UNIQUE索引或PRIMARY KEY中出现重复值， 则在出现重复值的行执行UPDATE；如果不会导致唯一值列重复的问题，则插入新行。 四个方法分步解析： 操作表test表结构如下 1、replace语法 select * from test; 现在插入(1,’xiaohong’)数据，发现出现错误，错误提示（主键重复输入’1’），证明当insert插入相同主键时是会报错的。 现在我们来replace语句测试一下会不会不报错，执行成功 查询一下我们的表信息，发现之前的记录(1,’xiaozhang’)已经被替换成(1,’xiaohong’), 证明我们插入相同的主键信息，replace会替换原有信息。 replace语法执行和数据库中主键重复的数据会替换原有信息，那么执行不同的信息会有怎么样的操作呢？（发现执行和数据库中没有主键重复的数据，则执行插入操作） 2、ignore 这里我们应用insert ignore执行插入(1,’xiaoplan’),运行成功，但是数据没有插入到test表中。 insert ignore 和update联合使用（发现主键为’1’的’xiaohong’被更新为’xiaolan’） 运行结果图 3、可以采用异常抓捕的方式来实现handler，相当于sqlserver中的try catch handler是mysql的自定义异常处理。
定义异常处理语法 DECLARE handler_type HANDLER FOR condition_value sp_statement 语法解析 handler_type：为异常的处理方式，也就是当发生异常时怎么处理，有三个参数 1）exit ，表示遇到异常马上退出 2）continue ，表示遇到异常不处理，继续执行sql代码 3）undo ，mysql不支持，是一个回滚操作 condition_value:表示错误类型 1)SQLSTATE [VALUE] sqlstate_value 为包含5个字符的字符串错误值 2）SQLWARNING 匹配所有以01开头的SQLSTATE错误代码 3）NOT FOUND 匹配所有以02开头的SQLSTATE错误代码 4）SQLEXCEPTION 匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码 5）mysql_error_code 匹配数值类型错误代码 condition_name：标志定义错误的名称 异常定义引用：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18eae61b307a1d44c8484e852e16b9e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d5d3c0babbca9c79358ac8d0f3cdbc/" rel="bookmark">
			EasyTouch物体的旋转缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class ArMonoDevelop : MonoBehaviour { // Use this for initialization //需要放大缩小旋转的物体 public GameObject rotateAndEnlargeObj; public bool isRotate = true; public bool isEnlarge = true; void Start() { } void OnEnable() { if (isRotate) { EasyTouch.On_Drag += OnDrag; } if (isEnlarge) { EasyTouch.On_PinchIn += OnPinchIn; EasyTouch.On_PinchOut += OnPinchOut; } EasyTouch.On_SimpleTap += OnSimpleTap; EasyTouch.On_DoubleTap += OnDoubleTap; } void OnDisable() { if (isRotate) { EasyTouch.On_Drag -= OnDrag; } if (isEnlarge) { EasyTouch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5d5d3c0babbca9c79358ac8d0f3cdbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c912657cbc1d29e3c0e76eff9e07f680/" rel="bookmark">
			vue面试题总汇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue的底层原理? vue组件之间的通信？ JS中判断数据类型的方法有几种? 最常见的判断方法：typeof
判断已知对象类型的方法： instanceof
根据对象的constructor判断： constructor
无敌万能的方法：jquery.type()
vue与angular的区别? 1.vue仅仅是mvvm中的view层，只是一个如jquery般的工具库，而不是框架，而angular而是mvvm框架。
2.vue的双向邦定是基于ES5 中的 3.getter/setter来实现的，而angular而是由自己实现一套模版编译规则，需要进行所谓的“脏”检查，vue则不需要。因此，vue在性能上更高效，但是代价是对于ie9以下的浏览器无法支持。
4.vue需要提供一个el对象进行实例化，后续的所有作用范围也是在el对象之下，而angular而是整个html页面。一个页面，可以有多个vue实例，而angular好像不是这么玩的。
5.vue真的很容易上手，学习成本相对低，不过可以参考的资料不是很丰富，官方文档比较简单，缺少全面的使用案例。高级的用法，需要自己去研究源码，至少目前是这样。
说说你对angular脏检查理解？ 在angular中你无法判断你的数据是否做了更改，所以它设置了一些条件，当你触发这些条件之后,它就执行一个检测来遍历所有的数据，对比你更改的地方，然后执行变化。
这个检查很不科学。而且效率不高，有很多多余的地方，所以官方称为 脏检查。
active-class是哪个组件的属性？ vue-router模块的router-link组件。
嵌套路由怎么定义？ 在实际项目中我们会碰到多层嵌套的组件组合而成，但是我们如何实现嵌套路由呢？因此我们需要在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。
index.html，只有一个路由出口
&lt;div id="app"&gt; &lt;!-- router-view 路由出口, 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;复制代码 main.js，路由的重定向，就会在页面一加载的时候，就会将home组件显示出来，因为重定向指向了home组件，redirect的指向与path的必须一致。children里面是子路由，当然子路由里面还可以继续嵌套子路由。
import Vue from 'vue' import VueRouter from 'vue-router' Vue.use(VueRouter) //引入两个组件 import home from "./home.vue" import game from "./game.vue" //定义路由 const routes = [ { path: "/", redirect: "/home" },//重定向,指向了home组件 { path: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c912657cbc1d29e3c0e76eff9e07f680/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/201/">«</a>
	<span class="pagination__item pagination__item--current">202/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/203/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>