<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a806b4e5fcac780f3dce79c49466f32/" rel="bookmark">
			table-layout属性fixed和auto的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义： &lt;!DOCTYPE html&gt; &lt;html lang="zh-cmn-Hans"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;table-layout属性fixed和auto的区别&lt;/title&gt; &lt;meta name="author" content="" /&gt; &lt;style&gt; h1{font-size:16px;font-family:Arial;} .auto{table-layout:auto;width:350px;} .fixed{table-layout:auto;width:350px;} .fixed td{width:300px;} .auto td{width:200px;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;auto: 表格自动算法&lt;/h1&gt; &lt;table border="1" class="auto"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格自动算法，宽度将基于单元格的内容自动拉伸&lt;/td&gt; &lt;td&gt;表格自动算法&lt;/td&gt; &lt;td&gt;表格自动算法&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格自动算法&lt;/td&gt; &lt;td&gt;表格自动算法&lt;/td&gt; &lt;td&gt;表格自动算法&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;h1&gt;fixed: 表格固定算法&lt;/h1&gt; &lt;table border="1" class="fixed"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格固定算法布局&lt;/td&gt; &lt;td&gt;表格固定算法&lt;/td&gt; &lt;td&gt;表格固定算法&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格固定算法&lt;/td&gt; &lt;td&gt;表格固定算法&lt;/td&gt; &lt;td&gt;表格固定算法&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 结果： 从结果上看，
相同点：
如果表格都没有设定宽高属性，那么不管是auto或者fixed属性、表格宽度高度则为单元格宽高（包括一些padding、border属性等）累积的总和。
不同点：
auto属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a806b4e5fcac780f3dce79c49466f32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292aa522f581a7a2df63e857a770444b/" rel="bookmark">
			hive内置UDTF函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		explode函数：hive内置的表生成函数，主要用于将一行输入拆分成多行输出。 官网解释：explode() takes in an array (or a map) as an input and outputs the elements of the array (map) as separate rows. UDTFs can be used in the SELECT expression list and as a part of LATERAL VIEW. ①创建array数据类型表 hive&gt; create table student_array( &gt; name string, &gt; course_score array&lt;string&gt; &gt; ) &gt; row format delimited fields terminated by '\t' &gt; collection items terminated by ',' &gt; stored as textfile; ②准备数据student_array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/292aa522f581a7a2df63e857a770444b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92fd9d6eae01156c3c09f39f63af4bd7/" rel="bookmark">
			javascript调用java方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文中所有的代码使用 JavaScript 编写，但你也可以用其他兼容 JSR 223 的脚本语言。这些例子可作为脚本文件也可以在交互式 Shell 中一次运行一个语句的方式来运行。在 JavaScript 中访问对象的属性和方法的语法与 Java 语言相同。
本文包含如下几部分：
1、访问 Java 类
为了在 JavaScript 中访问原生类型或者引用 Java 类型，可以调用 Java.type() 函数，该函数根据传入的完整类名返回对应对象的类型。下面代码显示如何获取不同的对象类型：
? 1 2 3 4 var ArrayList = Java.type("java.util.ArrayList"); var intType = Java.type("int"); var StringArrayType = Java.type("java.lang.String[]"); var int2DArrayType = Java.type("int[][]"); 在 JavaScript 中使用 Java.type() 函数返回的类型对象的方法跟在 Java 的类似。
例如你可以使用如下方法来实例化一个类：
? 1 var anArrayList = new Java.type("java.util.ArrayList"); Java 类型对象可用来实例化 Java 对象。下面的代码显示如何使用默认的构造函数实例化一个新对象以及调用包含参数的构造函数：
? 1 2 3 var ArrayList = Java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92fd9d6eae01156c3c09f39f63af4bd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7c23c26628a836eeb4103419e4b3f4e/" rel="bookmark">
			webpack 如何优雅的使用tree-shaking（摇树优化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webpack 如何优雅的使用tree-shaking 1.什么是tree-shaking webpack 2 的到来带来的最棒的新特性之一就是tree-shaking 。tree-shaking源自于rollup.js，先如今，webpack 2也有类似的做法。
webpack 里的tree-shaking的到来不得不归功于es6规范的模块。为什么这么说，如今的前端模块规范很多，比较出流行的比如commonJS , AMD , es6 ，我简单的说一下commonJS和es6模块的区别。
commonJS 模块 commonJS的模块规范在Node中发扬光大，总的来说，它的特性有这几个：
1.动态加载模块 commonJS和es6的最大区别大概就在于此了吧，commonJS模块的动态加载能够很轻松的实现懒加载，优化用户体验。
2.加载整个模块 commonJS模块中，导出的是整个模块。
3.每个模块皆为对象 commonJS模块都被视作一个对象。
4.值拷贝 commonJS的模块输出和 函数的值传递相似，都是值的拷贝
es6 模块 1.静态解析 即在解析阶段就确定输出的模块，所以es6模块的import一般写在被引入文件的开头。
2.模块不是对象 在es6里，每个模块并不会当做一个对象看待
3.加载的不是整个模块 在es6模块中经常会看见一个模块中有好几个export 导出
4.模块的引用 es6模块中，导出的并不是模块的值拷贝，而是这个模块的引用
在结合es6模块和commonJS模块的区别之后，我们知道es6的特点是静态解析，而commonJS模块的特点是动态解析的，因此，借于es6模块的静态解析，tree-shaking的实现才能成为可能。 在webpack中，tree-shaking指的就是按需加载，即没有被引用的模块不会被打包进来，减少我们的包大小，缩小应用的加载时间，呈现给用户更佳的体验。
2.怎么使用tree-shaking 说了这么多那到底如何使用tree-shaking呢？ webpack默认es6规范编写的模块都能使用tree-shaking。这是什么意思呢？下面来看个例子。 首先奉上我的demo目录如下：
├─dist └─index.html ├─node_modules └─... ├─src ├─scripts ├─assets ├─webpack.config.js └─package.json dist用来存放打包好的代码 src相反的用来存放源文件 src里的scripts目录用来存放js脚本文件，assets用来存放静态资源文件
以下几条命令过后开始我们的tree-shaking之旅
npm install --save-dev webpack webpack-dev-server webpack.config.js
const webpack = require('webpack') const path = require('path') module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7c23c26628a836eeb4103419e4b3f4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86eab56554f99794c96d3369523230d8/" rel="bookmark">
			MVC&#43;jQuery.Ajax异步实现增删改查和分页的实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文实例为大家分享了MVC+jQuery.Ajax异步实现增删改查和分页的具体代码，供大家参考，具体内容如下
1、Model层代码
using System; using System.Data; using System.Configuration; using System.Linq; using System.Web; using System.Web.Security; using System.Web.UI; using System.Web.UI.HtmlControls; using System.Web.UI.WebControls; using System.Web.UI.WebControls.WebParts; using System.Xml.Linq; using System.Collections.Generic; using MvcExamples; using System.Web.Mvc; namespace MvcExamples.Web.Models { public class StudentModels { /// &lt;summary&gt; /// 获取学生信息列表 /// &lt;/summary&gt; public List&lt;MvcExamples.Model.Student&gt; StudentList { get; set; } /// &lt;summary&gt; /// 获取教工信息列表 /// &lt;/summary&gt; public List&lt;MvcExamples.Model.Teacher&gt; TeacherList { get; set; } /// &lt;summary&gt; /// 获取学生信息列表(分页) /// &lt;/summary&gt; public PagedList&lt;MvcExamples.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86eab56554f99794c96d3369523230d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d57a5e03d7b10e8de61ed018e96f7bf/" rel="bookmark">
			Rundll32.exe 调用Dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rundll32.exe dll 路径 , 函数名 参数
rundll32.exe dll 路径 , #序号 参数
转载于:https://www.cnblogs.com/DeeLMind/p/7356937.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4242e082f7a050df561f8ba5f1c487ae/" rel="bookmark">
			IP数据包转发过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [TOC] 1. IP数据包到达网络层之后，首先根据目的IP地址得到目的网络号，然后决定是直接交付还是转发数据包。如果网络号不匹配，需要转发数据包，则跳到3）； 2. 将数据包转发给目的主机； 3. 首先根据目的IP地址在路由表（转发表）中查找下一跳IP地址； 4. 然后在路由器的ARP高速缓存表中查找下一跳IP地址对应的MAC地址，如果找到下一跳路由器的MAC地址，则将查到的MAC地址填入数据帧的首部6字节（即更新链路层的数据帧）；如果ARP高速缓存表中不存在此IP地址，则通过向当前局域网内广播一个ARP分组来请求下一跳路由器的MAC地址。 ARP请求分组广播出去后，只有下一跳路由器会对此请求分组做出响应，所有其它的主机和路由器都将忽略此ARP广播分组。 5. 根据得到的下一跳路由器MAC地址来更新数据链路层的数据帧，即帧头的目的MAC地址字段； 6. 转发数据包； &gt; 步骤2中数据包的直接交付时，如果当前路由器的ARP高速缓存表中找不到相应的匹配项，则也需要向当前局域网广播ARP请求分组来获取相应主机的MAC地址。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a250feb726d305ee602ec19f0b24a8fb/" rel="bookmark">
			opencv 将Mat转为图片数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先记录下来，以后有空在整理
Mat img = imread("002.png", CV_LOAD_IMAGE_COLOR); std::vector&lt;uchar&gt; data_encode; try { std::vector&lt;int&gt; param = std::vector&lt;int&gt;(2); param[0] = CV_IMWRITE_PNG_COMPRESSION; param[1] = 3; imencode(".png", img, data_encode, param); } catch (Exception&amp; e) { const char * s_ERROR = e.what(); std::string a(s_ERROR); int c = 0; c++; } int g =data_encode.size(); //获取图片数据指针 unsigned char* tem = &amp;*data_encode.begin(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebce54c432d73824a92eb8aafef9d1a0/" rel="bookmark">
			url 中提取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理一个你知道的url的参数，可以这样；
需求：跳转到新页面，判断url是什么类型（type），参数str是什么（name）；
网上有很多处理url参数的方法；推荐正则；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c48c59e930da738231dfbfe66f268d57/" rel="bookmark">
			工具 svn 介绍和简单用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是svn
svn 是 版本（软件每次发布称为一个版本）管理工具
分为
客户端安装包 （一般还有语言包 在设置切换语言）
服务器安装包
安装完桌面右键 出现svn选项为成功 没有请重启 1.连接服务器地址
桌面右键点击检出
选择 输出检出地址- 服务器地址 账号 （服务器设置） 2.简单用法（连接服务器以后） svn提交：将自己文件提交到服务器 svn更新：更新本地的文件与服务器内容一致 软件测试用到的地方
上传 测试用例 测试计划 测试报告 下载 程序员的安装包 需求文档 用户手册 产品有关的文档 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1481fc96a87f6952303541bc17df783/" rel="bookmark">
			X264 codec参数相关讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		X264 codec相关讲解：可能有人注意到了我使用的是x264的tmod..何为mod版...就是民间菊苣在官方x264的基础上又自行进行了一些编译修改..提升强化了一部分功能..本帖提供的是taro大编译的x264..故为tmod版本..前面说到码率是重中之重...那么通常会见到的码率控制模式有ABR [ Average Bitrate ]（平均目标码率模式）CBR [ Constant Bitrate ]（固定码率模式）2pass..3pass..npass（二次..三次..n次编码模式..严格来说也属于平均目标码率模式.但其码率浮动较ABR高出不少.）CRF [ Constant Ratefactor ] （固定码率系数模式）QP [ Constant Quantizer ] （固定量化值模式）但x264只提供三种码率控制模式..至于其他怎么搞出来后面再写..三种模式为：qp模式...bitrate模式..crf模式下面挨个解释一下..需要注意的是三种码率控制方法不能共存，有其一不能有另外两个！qp模式即为固定量化值（Constant Quantizer）模式来编码视频..需要注意的是这里的量化参值为P帧的量化值..I 帧（IDR帧）和B帧的量化值又由ipratio和bpratio参数来确定..不过通常这两个参数无需手动设置..简单点说qp模式就是：相对于压缩前的原视频来说..每一个 P 帧 ..I 帧 .. B帧都会固定的损失一部分质量..损失判定是固定的.但由于I P B帧的插入是不确定的..所以最终文件的大小是无法确定的.设置为qp0时将产生无损的画面输出（输出文件一般会比源文件大出数倍以上）..并且相同视觉质量时..qp模式压出的视频文件比crf模式大..bitrate模式即为固定目标码率模式..（固定目标比特率模式）..x264会试图让最终文件的整体码率与给定的码率相等..这会使最终文件的大小是确定的..适用于精确控制体积..但由于这是一次编码..所以画质上不如同等体积的crf..故一般配合pass参数使用.crf模式即固定Ratefactor模式..如果说QP是固定量化器，bitrate是固定文件最终大小..那么crf则是则是固定“肉眼质量”..crf可以提供跟QP一样的视觉的质量..但是文件更小..crf是通过降低那些“不那么重要”的帧的质量做到这一切的~..“不那么重要”意思是过于耗费码率又难以用肉眼察觉的帧....省下来的码率会用在其它更有效的帧里..其实crf就是一个浮动qp模式..其按照特定的标准..根据人眼的需求..给予每帧不同的qp值 .但玩好crf模式..和aq..psy..qcomp等参数都脱不开关系..后面会讲到~需要注意的是crf模式无法预测最终文件体积..
-------------------------另一种解释----------------------------------------------------
码率控制
qp
默认值: 未设置
三种可用的码率控制方法之一。以恒定量化值（Constant Quantizer）方式编码。此选项的参数用于指定 P 帧量化值。I 和 B 帧的量化值由 --ipratio 和 --pbratio 控制。CQ 模式的目标是恒定的量化值，这就意味着最终文件大小不可知（尽管能用一些方法预测）。参数 0 表示无损输出。同等的视觉质量下， qp 比 --crf 产生的文件要大。由于固定量化值的缘故，qp 模式会关闭自适应量化。
本选项与 --bitrate 和 --crf 是互相排斥的，就是三选一的意思。欲详细了解码率控制，参见http://git.videolan.org/?p=x264.git;a=blob_plain;f=doc/ratecontrol.txt;hb=HEAD。
可以使用 --crf 代替 qp，不过 qp 模式不需要预分析会更快一些。
参照: --bitrate, --crf, --ipratio, --pbratio
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1481fc96a87f6952303541bc17df783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/801a460b1c484035be8a03c7b4b1cb48/" rel="bookmark">
			常见工具总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见工具总结 日志类 CocoaLumberjack 支持OC &amp; Swift, 分级别的一个日志系统,最主要的是支持写入文件，然后导出文件就可以查看日志信息。
DebugWindow 支持OC，一个轻量级的基于Window的调试工具
HCDeviceConsole 支持OC, 这也是一个很轻量级的Log工具，就引入两个文件，然后一句话开启服务，就可以把所有的NSLog日志都输出到Window上。
网络类 AFNetworking 这个是OC版本的，其Swift版本叫Alamofire
Alamofire 这个是AFNetworking的Swift版本，很好用
数据解析 SwiftyJSON The better way to deal with JSON data in Swift. 承接解析Alamofire返回来的JSON数据，好用的不得了。算是绝配。
ObjectMapper 模型数据转换工具 JSON –&gt; Model, Model –&gt; JSON, ObjectMapper + Alamofire
布局 SnapKit A Swift Autolayout DSL for iOS &amp; OS X (http://snapkit.io) Masonry OC版本的， 也是由SnapKit人马维护的的。 LayoutKit LayoutKit is a fast view layout library for iOS, macOS, and tvOS. http://layoutkit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/801a460b1c484035be8a03c7b4b1cb48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71b79f0a1785b02d7b8c45cc4edca0b8/" rel="bookmark">
			Windows下利用win32clipboard实现Python的剪切板(Clipboard)操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近翻译论文的时候发现复制过来的文字经常带有很多的换行符，为了方便的去除这些换行符，写了一个python小方法。
代码如下(适用于Python3)：
import win32clipboard as wc import win32con import sys def stripClipboard(): # 开始剪切板操作 wc.OpenClipboard() # 尝试将剪切板内容读取为Unicode文本 # 如果复制的内容是文件而非文本，读取为Unicode文本会报错，所以需要错误处理。 try: txt = wc.GetClipboardData(win32con.CF_UNICODETEXT) except Exception as e: print("剪切板内容非文本，无法去除换行符。") wc.EmptyClipboard() sys.exit("已清空剪切板并退出。") txt = wc.GetClipboardData(win32con.CF_UNICODETEXT) txt = str(txt).strip() # 字符串按行分割 txt = txt.splitlines() n = len(txt) # 用空格拼接每行 txt = ' '.join(txt) # 将所有长度大于1的空白符转为1个空格 txt = ' '.join(txt.split()) # 清空剪切板 wc.EmptyClipboard() # 尝试将处理完的字符放入剪切板，注意这里用的是win32con.CF_UNICODETEXT， # 如果使用win32con.CF_TEXT则需要对txt进行编码，否则会出现乱码。 wc.SetClipboardData(win32con.CF_UNICODETEXT, txt) # 关闭剪切板 wc.CloseClipboard() print('删除了{}个换行符\n'.format(n-1)) print(txt+'\n') if __name__ == '__main__': stripClipboard() 保存并命名为“stripClipboard.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71b79f0a1785b02d7b8c45cc4edca0b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3310b5ed6b3cd984db250df2e4e485/" rel="bookmark">
			guacamole谷歌浏览器全屏时白屏问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目需要使用web通过vnc连接虚拟机，简单调研一番后决定用apache guacamole。
开发过程中需要实现全屏功能，但F11被guacamole拦截了，无法全屏，唯有使用js来做，一开始用以下方法：
function fullScreen() { var docElm = document.documentElement; //W3C if (docElm.requestFullscreen) { docElm.requestFullscreen(); } //FireFox else if (docElm.mozRequestFullScreen) { docElm.mozRequestFullScreen(); } //Chrome等 else if (docElm.webkitRequestFullScreen) { docElm.webkitRequestFullScreen(); } //IE11 else if (docElm.msRequestFullscreen) { docElm.msRequestFullscreen(); } }使用chrome测试发现全屏时候白屏了，firefox则没有这个问题。 后来使用chrome，先访问左边的页面，按下F11，全屏了，然后Ctrl+PageDown切回到虚拟机页面，没有白屏。
开始意识到应该是js问题，于是继续在网上找解决方法，后来找到个帖子，https://stackoverflow.com/questions/3900701/onclick-go-full-screen，里面有个外国人讲得停详细的，试了一下他的代码，问题解决了。
function requestFullScreen() { var el = document.body; // Supports most browsers and their versions. var requestMethod = el.requestFullScreen || el.webkitRequestFullScreen || el.mozRequestFullScreen || el.msRequestFullScreen; if (requestMethod) { // Native full screen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa3310b5ed6b3cd984db250df2e4e485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56aca8e95a5dde3a65517e69fd1fd744/" rel="bookmark">
			Vue - 路由传递参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 2.0 路由传递参数
Vue 路由传递参数 有两种方式：
一、用name传递参数 两步完成用name传值并显示在模板里：
在路由文件src/router/index.js里配置name属性。
1 2 3 4 5 6 7 routes: [ { path: '/', name: 'Hello', component: Hello } ] 模板里(src/App.vue)用$router.name的形势接收，比如直接在模板中显示：
1 &lt;p&gt;{{ $route.name}}&lt;/p&gt; 二、通过&lt;router-link&gt; 标签中的to传参 上边的传参或许很不正规，也不方便，其实工作中多数传参是不用name进行传参的，我们用&lt;router-link&gt;标签中的to属性进行传参，需要注意的是这里的to要进行一个绑定，写成:to。先来看一下这种传参方法的基本语法：
1 &lt;router-link :to="{name:xxx,params:{key:value}}"&gt;valueString&lt;/router-link&gt; 这里的to前边是带冒号的，然后后边跟的是一个对象形势的字符串.
name：就是我们在路由配置文件中起的name值。params：就是我们要传的参数，它也是对象形势，在对象里可以传递多个值。 了解基本的语法后，我们改造一下我们的src/App.vue里的&lt;router-link&gt;标签,我们把hi1页面的&lt;router-link&gt;进行修改。
1 &lt;router-link :to="{name:'hi1',params:{username:'jspang'}}"&gt;Hi页面1&lt;/router-link&gt; 把src/reouter/index.js文件里给hi1配置的路由起个name,就叫hi1.
1 {path:'/hi1',name:'hi1',component:Hi1}, 最后在模板里(src/components/Hi1.vue)用$route.params.username进行接收.
1 {{$route.params.username}} vue-router 利用url传递参数　:冒号的形式传递参数 在路由配置文件里以:冒号的形式传递参数，这就是对参数的绑定。
在配置文件里以冒号的形式设置参数。我们在/src/router/index.js文件里配置路由。
1 2 3 4 { path:'/params/:newsId/:newsTitle', component:Params } 我们需要传递参数是新闻ID（newsId）和新闻标题（newsTitle）.所以我们在路由配置文件里制定了这两个值。在src/components目录下建立我们params.vue组件，也可以说是页面。我们在页面里输出了url传递的的新闻ID和新闻标题。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 &lt;template&gt; &lt;div&gt; &lt;h2&gt;{{ msg }}&lt;/h2&gt; &lt;p&gt;新闻ID：{{ $route.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56aca8e95a5dde3a65517e69fd1fd744/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f62b993990d77d77f6c8c45866ef34e/" rel="bookmark">
			怎么成为大公司的前端（例如：阿里巴巴）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（此文章所涉及内容大多来自网络，本人整理收集，便于勉励自强，非商业使用，如有冒犯，请评论告知删除）
1，招聘信息 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
发布时间： 2016-03-15 工作地点： 杭州市 工作年限： 三年以上 所属部门： 天猫事业部 学 历： 大专 招聘人数： 5 岗位描述： 1、依据产品需求完成高质量的跨终端Web（PC+Mobile）/Node.js/Native App的前端开发和维护； 2、对具体的产品进行性能优化，实现极致的页面加载、执行和渲染时间； 3、在理解前端开发流程的基础上，结合前端实际建立或优化提升工作效率的工具； 4、在理解产品业务的基础上，提升产品的用户体验，技术驱动业务的发展； 5、关注前端前沿技术研究，通过新技术服务团队和业务。
岗位要求： 1、精通各种前端技术，包括HTML/CSS/JavaScript/Node.JS等； 2、具备跨终端的前端开发能力，在Web（PC+Mobile）/Node.js/Native App三个方向上至少精通一个方向，具备多个的更佳，鼓励在Native和Web技术融合上的探索； 3、对前端工程化与模块化开发有一定了解，并有实践经验（如RequireJS/SeaJS/KISSY等）； 4、至少熟悉一门非前端的语言（如Java/PHP/C/C++/Python/Ruby），并有实践经验； 5、具备良好的团队协作精神，能利用自身技术能力提升团队整体研发效率，提高团队影响力； 6、对前端技术有持续的热情，个性乐观开朗，逻辑性强，善于和各种背景的人合作。
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
发布时间： 2017-07-11 工作地点： 杭州市 工作年限： 三年以上 所属部门： 新零售技术事业群 学 历： 本科 招聘人数： 30 岗位描述： 1.业务领域 —— 建设天猫从消费者导购到品牌商家系统全链路各类产品，体验每年全球瞩目双11狂欢节，加入尽情施展才华的舞台； 2.技术驱动 —— 从极致的Mobile体验、前端工程化开发、企业级中台应用、可视化编程、3D/AR创新交互，到大规模NodeJS应用等等，拥有足够的挑战及机遇；
岗位要求： 1.精通各种前端技术（包括HTML/CSS/JavaScript等），熟悉ES6语法，具备跨终端（Mobile+PC）的前端开发能力，熟悉网络协议（HTTP/SSL），熟悉常见安全问题和对策； 2.熟悉前端工程化与模块化开发，并有实践经验（如gulp/webpack、VueJS/React等）； 3.至少熟悉一门非前端的语言（如NodeJS/Java/PHP/C/C++/Python/Ruby等），并有实践经验； 4.对前端技术有持续的热情，良好的团队协作能力，提升团队研发效率，实现极致性能，通过创新交互优化产品体验； 5.加分项（满足其一即可）：具备客户端能力或者Native&amp;Web技术融合经验；熟悉Canvas动效&amp;WebGL3D以及各种传感器技术；复杂企业后台应用开发经验；数据可视化产品设计开发经验；大规模/高负载场景下NodeJS应用开发、运维经验；良好的算法背景，对机器学习有研究和项目实施经验；有独立的开源项目或者参与知名开源项目经验；团队管理能力；英语沟通能力；
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
发布时间： 2017-05-18 工作地点： 北京市 工作年限： 五年以上 所属部门： 优酷 学 历： 本科 招聘人数： 1 岗位描述： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f62b993990d77d77f6c8c45866ef34e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbff1a22dfcaf02e679c9ea0b3da0ecd/" rel="bookmark">
			低功耗蓝牙cc2541学习笔记之LED-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章转自：http://blog.csdn.net/anobodykey/article/details/8486578
InitBoard()看注释上说是初始化板子上的I/O资源，进入到该函数实现体中，
void InitBoard( byte level ) { if ( level == OB_COLD ) { // Interrupts off osal_int_disable( INTS_ALL ); // Turn all LEDs off HalLedSet( HAL_LED_ALL, HAL_LED_MODE_OFF ); // Check for Brown-Out reset ChkReset(); } else // !OB_COLD { #ifdef ZTOOL_PORT MT_SysResetInd(); #endif /* Initialize Key stuff */ OnboardKeyIntEnable = HAL_KEY_INTERRUPT_DISABLE; HalKeyConfig( OnboardKeyIntEnable, OnBoard_KeyCallback); } } 从主函数中传递进来的是OB_COLD，该值为0，进来之后又是关闭中断，（貌似前面也没有打开过），之后进入HalLedSet()函数中，关闭所有LEDs，进入该函数中，
uint8 HalLedSet (uint8 leds, uint8 mode) { #if (defined (BLINK_LEDS)) &amp;&amp; (HAL_LED == TRUE) uint8 led; HalLedControl_t *sts; switch (mode) { case HAL_LED_MODE_BLINK: /* Default blink, 1 time, D% duty cycle */ HalLedBlink (leds, 1, HAL_LED_DEFAULT_DUTY_CYCLE, HAL_LED_DEFAULT_FLASH_TIME); break; case HAL_LED_MODE_FLASH: /* Default flash, N times, D% duty cycle */ HalLedBlink (leds, HAL_LED_DEFAULT_FLASH_COUNT, HAL_LED_DEFAULT_DUTY_CYCLE, HAL_LED_DEFAULT_FLASH_TIME); break; case HAL_LED_MODE_ON: case HAL_LED_MODE_OFF: case HAL_LED_MODE_TOGGLE: led = HAL_LED_1; leds &amp;= HAL_LED_ALL; sts = HalLedStatusControl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbff1a22dfcaf02e679c9ea0b3da0ecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab20bcec6bcc01ac68142caf5c6846aa/" rel="bookmark">
			乐观锁和悲观锁介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乐观锁和悲观锁定义
乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。 悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 乐观锁的实现
使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据 例如，task数据库表有三个字段，分别是id，value，version （1）先读task表的数据（实际上这个表只有一条记录），得到version的值为versionValue （2）每次更新task表中的value字段时，为了防止发生冲突，需要这样操作：**update task set value = newValue,version = versionValue + 1 where version = versionValue;** 只有这条语句执行了，才表明本次更新value字段的值成功。 如假设有两个节点A和B都要更新task表中的value字段值，差不多在同一时刻，A节点和B节点从task表中读到的version值为2，那么A节点和B节点在更新value字段值的时候，都操作 update task set value = newValue,version = 3 where version = 2; 实际上只有1个节点执行该SQL语句成功，假设A节点执行成功，那么此时task表的version字段的值是3，B节点再操作update task set value = newValue, version = 3 where version = 2; 这条SQL语句是不执行的，这样就保证了更新task表时不发生冲突 使用场景
两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe396090591bf20a6c81f113207813e/" rel="bookmark">
			react-native 遇到的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ReferenceError: Can't find variable: __fbBatchedBridge... react-native启动用来做JavaScript的代码的服务，是本地的服务，App默认访问的host地址是localhost,运行到真实的设备上面的时候无法访问react-native服务,因此会出现上面的错误。
Android解决方案: 对adb的server设置反向代理
adb reverse tcp:8081 tcp:8081
更改App内的服务地址 * 摇晃手机
* 点击菜单键 * 在电脑上面运行命令 &gt;adb shell input keyevent 82
在dev setting里面即可设置。 ios解决方案: 在AppDelegate.m中修改jsCodeLocation： ` ..... jsCodeLocation = [NSURL URLWithString:@"http://192.168.31.191:8081/index.ios.bundle?platform=ios&amp;dev=true"]; .... `
react-native start 错误 错误信息：
ERROR: Unknown option --no-pretty ERROR: Unknown option --no-pretty Watchman: watchman--no-pretty get-sockname returned with exit code 1 ERROR: Unknown option --no-pretty ERROR watchman--no-pretty get-sockname returned with exit code 1 ERROR: Unknown option --no-pretty Error: watchman--no-pretty get-sockname returned with exit code 1 ERROR: Unknown option --no-pretty at ChildProcess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fe396090591bf20a6c81f113207813e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88738f71fd63f927448512b4f433fff6/" rel="bookmark">
			ffmpeg查看视频信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原来这么简单
ffmpeg -i xxx.mp4 说明视频是2015-8-11日生成的。 然后看到源视频是8月7日那一期的。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/203/">«</a>
	<span class="pagination__item pagination__item--current">204/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/205/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>