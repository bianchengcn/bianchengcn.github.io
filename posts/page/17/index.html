<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f5b7af8bdfc6773e3b633c7a1bab703/" rel="bookmark">
			禁用windows update服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近windows更新总是失败，在网上找到一个相对完整的方案。收藏一下
通过运行（Run）对话框。按下“Win+R”键，输入“services.msc”后回车，打开服务窗口。找到“Windows Update”或“Windows更新”，双击打开。点击“停止”，将启动类型选为“禁用”，点击应用，切换到“恢复”选项，将默认的“重新启动服务”改为“无操作”，点击确定。12 使用组策略。按下“Win+R”键，输入“gpedit.msc”后回车，打开本地组策略编辑器。依次展开“计算机配置”→“管理模板”→“Windows组件”→“Windows更新”。在右侧“配置自动更新”设置中，将其设置为“已禁用”。再找到“删除使用所有Windows更新功能的访问权限”，选择“已启用”。23 使用任务计划。按下“Win+R”键，输入“taskschd.msc”后回车，打开任务计划程序库。从任务计划程序库中依次展开任务计划程序库→Microsoft→Windows→WindowsUpdate，把里面的项目都设置为“禁用”。使用注册表编辑器。按下“Win+R”键，输入“regedit”后回车，打开注册表编辑器窗口。定位到HKEY_LOCAL_MACHINESYSTEMCurrentControlSetServicesUsoSvc，在右侧找到“Start”键，点击修改，把start值改成16进制，值改为“4”。2 使用系统设置。按下左下角的开始菜单进入设置，在设置中点击进入“windows更新”，在“windows更新”页面中找到“高级选项”，然后关闭这个页面中更新选项下属的所有开关。3 以上就是禁用Windows Update服务的常见方法，你可以根据自己的实际情况来选择合适的方法进行操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d58beec756754ab436156bb3addc2ef5/" rel="bookmark">
			RUST笔记：candle使用基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		candle介绍 candle是huggingface开源的Rust的极简 ML 框架。 candle-矩阵乘法示例 cargo new myapp cd myapp cargo add --git https://github.com/huggingface/candle.git candle-core cargo build # 测试，或执行 cargo ckeck main.rs use candle_core::{Device, Tensor}; fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let device = Device::Cpu; let a = Tensor::randn(0f32, 1., (2, 3), &amp;device)?; let b = Tensor::randn(0f32, 1., (3, 4), &amp;device)?; let c = a.matmul(&amp;b)?; println!("{c}"); Ok(()) } 项目输出 ~/myrust$ cargo new myapp Created binary (application) `myapp` package ~/myrust$ cd myapp ~/myrust/myapp$ cargo add --git https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d58beec756754ab436156bb3addc2ef5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a85bd68d419c48575a6244af525acc/" rel="bookmark">
			【Proteus仿真】【STM32单片机】自动抽奖器系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用Proteus8仿真STM32单片机控制器，使用数码管显示模块、74HC595 IO扩展模块、按键等。
主要功能：
系统运行后，数码管显示随机数，K1和K2控制随机数的启停；
二、软件设计 /* 作者：嗨小易（QQ技术交流群：570487280） */ //系统数据设置 void sys_data_set(void) { u8 key=0; key=key_scan(0); //开始 if(key==KEY1_PRESS) { TR0=1; } //停止 else if(key==KEY2_PRESS) { TR0=0;	} } //应用控制系统 void appdemo_show(void) { sys_parm_init();//系统参数初始化 time0_init();//初始化定时器0 hc595_write_data(0x00,0x00,0x00,0x00,0x00); while(1) {	sys_data_show();//系统数据显示 sys_data_set();//系统数据设置 } } //定时器0中断函数 void time0() interrupt 1 { static u8 i=0; u8 j=0; TH0=0XDC;	//给定时器赋初值，定时10ms TL0=0X00; i++; if(i&gt;=20) { i=0; for(j=0;j&lt;5;j++) sys_ctrl.num[j]=rand()%10;//产生0-9随机数 } } 三、实验现象 B站演示视频：https://space.bilibili.com/444388619
联系作者 专注于51单片机、STM32、国产32、DSP、Proteus、arduino、ESP32、物联网软件开发，PCB设计，视频分享，技术交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce9222aa44d85360c612709571aff0c6/" rel="bookmark">
			【Proteus仿真】【Arduino单片机】自动抽奖器系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用Proteus8仿真Arduino单片机控制器，使用数码管显示模块、74HC595 IO扩展模块、按键等。
主要功能：
系统运行后，数码管显示随机数，K1和K2控制随机数的启停；
二、软件设计 /* 作者：嗨小易（QQ技术交流群：570487280） */ //系统数据设置 void sys_data_set(void) { u8 key=0; key=key_scan(0); //开始 if(key==KEY1_PRESS) { MsTimer2::start(); } //停止 else if(key==KEY2_PRESS) { MsTimer2::stop();	} } //应用控制程序 void app_ctrl_demo(void) { sys_parm_init();//系统参数初始化 key_init(); hc595_init(); hc595_write_data(0x00,0x00,0x00,0x00,0x00); time2_init(10);//定时10ms while(1) { sys_data_show();//系统数据显示 sys_data_set();//系统数据设置 } } //定时器2中断函数 void timer2Isr(void) {	static u8 i=0; u8 j=0; i++; if(i&gt;=20) { i=0; for(j=0;j&lt;5;j++) sys_ctrl.num[j]=rand()%10;//产生0-9随机数 } } 三、实验现象 B站演示视频：https://space.bilibili.com/444388619
联系作者 视频地址：https://space.bilibili.com/444388619/video
专注于51单片机、STM32、国产32、DSP、Proteus、arduino、ESP32、物联网软件开发，PCB设计，视频分享，技术交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f8765c4e4a74e6cea58a158f5c90d7/" rel="bookmark">
			【Proteus仿真】【51单片机】自动抽奖器系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用Proteus8仿真51单片机控制器，使用数码管显示模块、74HC595 IO扩展模块、按键等。
主要功能：
系统运行后，数码管显示随机数，K1和K2控制随机数的启停；
二、软件设计 /* 作者：嗨小易（QQ技术交流群：570487280） */ //系统数据设置 void sys_data_set(void) { u8 key=0; key=key_scan(0); //开始 if(key==KEY1_PRESS) { TR0=1; } //停止 else if(key==KEY2_PRESS) { TR0=0;	} } //应用控制系统 void appdemo_show(void) { sys_parm_init();//系统参数初始化 time0_init();//初始化定时器0 hc595_write_data(0x00,0x00,0x00,0x00,0x00); while(1) {	sys_data_show();//系统数据显示 sys_data_set();//系统数据设置 } } //定时器0中断函数 void time0() interrupt 1 { static u8 i=0; u8 j=0; TH0=0XDC;	//给定时器赋初值，定时10ms TL0=0X00; i++; if(i&gt;=20) { i=0; for(j=0;j&lt;5;j++) sys_ctrl.num[j]=rand()%10;//产生0-9随机数 } } 三、实验现象 B站演示视频：https://space.bilibili.com/444388619
联系作者 视频地址：https://space.bilibili.com/444388619/video
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44f8765c4e4a74e6cea58a158f5c90d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e63861fd7cc37427bc36f3de17a670a/" rel="bookmark">
			idea结合git回到某个提交点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：在IntelliJ IDEA中，你可以使用Git工具来回到某个提交点。
第一步：打开idea，打开git的管理面 可以看到，由于我的大改动，导致现在出问题了，所以我准备回退到某一版本。
点击左下角的git
点击log
右键你想退回的版本。
选择Reset Current Branch to Here，然后选择适当的重置选项。这些选项通常包括：
Soft: 保留你的更改，但标记为未提交。Mixed: 保留你的更改，但标记为未暂存。Hard: 丢弃你的更改，重置为选定的提交点。 点击Reset即可。过了一会，就恢复原貌了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c431e95bef3214a1299f30aed67187/" rel="bookmark">
			vue处理后端返回的文件数据流，并提供下载接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 返回的数据流 前端对其进行处理并下载 downloadFile(res, fileName) { // 使用后台返回的数据创建一个新的Blob对象 let blob = new Blob([res]); // 如果fileName参数未定义或为空，则从res的headers中获取'content-disposition'字段，并从中提取文件名 if (!fileName) { fileName = res.headers['content-disposition'].split('filename=').pop(); } // 检查当前浏览器是否支持msSaveOrOpenBlob方法（这是旧版IE浏览器特有的API） if ('msSaveOrOpenBlob' in navigator) { // 如果支持，使用该方法下载文件，参数为Blob对象和文件名 window.navigator.msSaveOrOpenBlob(blob, fileName); } else { // 如果不支持，则创建一个新的a元素并隐藏它 const elink = document.createElement('a'); // 设置a元素的download属性为文件名，这使得点击a元素时开始下载文件 elink.download = fileName; // 隐藏a元素，使其在页面上不可见 elink.style.display = 'block'; // 创建一个指向Blob对象的URL，并设置为a元素的href属性，这样a元素就可以下载该Blob对象表示的文件了 elink.href = URL.createObjectURL(blob); // 将a元素添加到文档的body中，使其可见并可以被点击 document.body.appendChild(elink); // 模拟点击a元素，开始下载文件 elink.click(); // 释放之前为Blob对象创建的URL，以释放内存 URL.revokeObjectURL(elink.href); // 从文档的body中移除a元素，清理内存 document.body.removeChild(elink); } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386f42a9c717a87fe0c67005925b2815/" rel="bookmark">
			el-tree基础的树形节点设置节点不能选中高亮出来，对已经选中的节点设置disabled，对当前节点刚选中后设置禁用disabled
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 el-tree基础的树形节点设置节点不能选中高亮出来 需求 我们使用element-ui或者element-plus的时候会遇到树形控件的使用，我们使用树形控件会限制有的节点不让选中和高亮出来，这个时候需要我们做限制。在实现中我们发现了element-ui和element-plus的时候他们实现的方式还是有点区别的，我们就简单来实现一下。
实现效果如下： vue2+element-ui 发现element-ui中更改current-node-key值无效，最后用this.$refs.tree.setCurrentKey方法实现了
实现的思路：
el-tree加上highlight-current属性，高亮当前选中节点ref="tree"绑定组件el-tree的点击事件@node-click中判断是有子元素的节点，则找到上次高亮的节点，让它继续选中高亮，思路是通过node-key="id"和this.$refs.tree.setCurrentKey方法 &lt;el-tree :data="treeData" :props="defaultProps" @node-click="handleNodeClick" highlight-current ref="tree" node-key="id" &gt; handleNodeClick(data, node) { //设置不能选中的节点 if (data.disabled) { this.$nextTick(() =&gt; { this.$refs.tree.setCurrentKey(this.currentNodeKey); }); return; } this.currentNodeKey = data.id; } vue3+element-plus 发现element-plus中更改current-node-key值是有效的，通过这个属性实现
思路：
el-tree加上highlight-current属性，高亮当前选中节点el-tree的点击事件@node-click中判断有子元素的节点不能选中高亮，核心代码node.isCurrent = false，让当前节点取消选中这时需要找到上次高亮的节点，让它继续选中高亮，思路是通过node-key与current-node-key属性 &lt;template&gt; &lt;el-tree :data="data" :props="defaultProps" @node-click="handleNodeClick" highlight-current node-key="id" :current-node-key="currentNodeKey" default-expand-all :expand-on-click-node="false"/&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import type Node from 'element-plus/es/components/tree/src/model/node' import { ref, nextTick } from "vue" interface Tree { label: string children?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/386f42a9c717a87fe0c67005925b2815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79b60a400c1fbbb5b874cf1a4826b87/" rel="bookmark">
			EventSource 长链接执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EventSource 说明文档MDN
其他参考文档
一、利用node启服务 import fs from 'fs' import express from 'express' const app = express() // eventSource 仅支持 get 方法 // 服务器端发送的数据必须是纯文本格式，不能是二进制数据。 app.get('/api', (req, res) =&gt; { res.writeHead(200, { 'Content-Type': 'text/event-stream', 'Connection': 'close', 'Access-Control-Allow-Origin': 'http://127.0.0.1:5172', // vue 项目启的服务，允许跨域ip 'Access-Control-Allow-Credentials': 'true', }) const data = fs.readFileSync('./src/service/index.text', 'utf8') console.log('=data===', data) const total = data.length let current = 0 // 定时器模拟持续发送消息，如果消息流一但断开就不会重新链接 let time = setInterval(() =&gt; { console.log(current, total) if (current &gt;= total) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e79b60a400c1fbbb5b874cf1a4826b87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/042d4ec9c3d8d0f14d83f1b3731f5cb2/" rel="bookmark">
			【Git】Git配置 — 首次clone失败，出现报错：authenticity can‘t be established
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 在新安装的Ubuntu系统里使用git clone 项目
问题描述 安装完git，且已生成ssh秘钥，使用git clone 命令下载项目，出现了报错：
AAA@pc-63:~/workspace/test$ git clone -b develop ssh://git@192.168.4.11/simulator/project.git Cloning into 'project'... The authenticity of host '[192.168.4.11]:2200 ([192.168.4.11]:2200)' can't be established. ED25519 key fingerprint is SHA256:Mk3FECUgTt4dCOPbSieB1i6/yrWzk1HNflQYju8NF0M. This key is not known by any other names Are you sure you want to continue connecting (yes/no/[fingerprint])? Host key verification failed. fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/042d4ec9c3d8d0f14d83f1b3731f5cb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256bbe398685071bb6119c13d40c070c/" rel="bookmark">
			Tortoise-tts Better speech synthesis through scaling——TTS论文阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记地址：https://flowus.cn/share/a79f6286-b48f-42be-8425-2b5d0880c648
【FlowUs 息流】tortoise
论文地址：
Better speech synthesis through scaling
Abstract: 自回归变换器和DDPM：自回归变换器（autoregressive transformers）是一种基于变换器架构的模型，能够处理序列数据，例如图像的像素。DDPM（深度概率模型，Deep Diffusion Probabilistic Models）是一种基于深度学习的概率模型，用于生成高质量的图像。 自回归变换器和DDPM被广泛应用于图像生成，它们利用大量的计算资源和数据来学习图像的分布，这意味着模型通过分析和学习大量图像数据来理解和复现图像的概率分布。
技术迁移：该方法论不仅限于图像生成，还可以应用于其他领域，如语音合成。
TorToise系统：这篇论文描述了一种将图像生成领域的进步应用于语音合成的方法。其结果是TorToise，这是一个富有表现力的多声音文本到语音合成系统。
所有的模型代码和训练好的权重都已在GitHub上开源，网址为：
GitHub - neonbjb/tortoise-tts: A multi-voice TTS system trained with an emphasis on quality
1.Background 1.1Text-to-speech 文本到语音研究领域主要集中于开发高效的模型，这些模型通常基于相对较小的数据集进行训练。这种选择主要受以下因素的驱动：
高效模型的需求：为了能够大规模部署，需要构建高效的语音生成模型，这些模型必须具有高采样率。
大型转录语音数据集的缺乏：很难获得大型、经过转录的语音数据集。
扩展传统TTS中使用的编解码器模型架构的挑战：传统的TTS技术在扩展时面临许多挑战。
1.1.1Neural MEL Invertes 神经MEL反转器，就是vocoder，声码器
MEL频谱编码：大多数现代文本到语音系统操作的是编码为MEL频谱的语音数据。MEL编码的一个主要优点是它高度空间压缩，意味着它可以在保留大部分信息的同时大幅度减小数据大小。例如，Tacotron使用的MEL配置相对于以22kHz采样的原始音频波形数据实现了256倍的压缩。
MEL频谱解码研究：由于MEL频谱的这些特性，一个专门的研究领域致力于找到高质量的方法，将MEL频谱再转换回音频波形。执行这一任务的合成器通常称为“声码器”，但在这篇论文中，作者更普遍地将其称为“MEL反转器”。
基于神经网络的MEL反转器：现代基于神经网络的MEL反转器非常复杂，它们产生的波形几乎与人类耳朵听到的录音波形无法区分，并且在训练集之外具有很高的泛化能力。作者利用这些研究成果，使用了Univnet(Kim, 2021)的实现作为其文本到语音系统的最终阶段。
1.2Image generation 与TTS系统主要关注延迟不同，图像生成领域更多地关注于训练能生成高质量结果的模型，而不太关心采样时间的长短。
1.2.1DALL-E 自回归解码器在图像生成中的应用：DALL-E（Ramesh等人，2021年）展示了如何将自回归解码器应用于文本到图像的生成。这一点特别吸引人，因为在NLP领域，已经有大量研究专注于扩展仅解码器模型。
DALL-E的问题：首先，DALL-E依赖于全序列自注意力，这带来了O(N²)的计算和存储成本，其中N是序列长度。其次，传统的自回归方法需要在离散域中操作。DALL-E使用量化自编码器将图像编码成离散的标记序列，然后使用自回归先验模型来模拟这些标记序列。这在表现力方面是DALL-E的一个优势，但它需要一个解码器将这些图像标记转换回实际组成图像的像素值。
1.2.2DDPMs 解决模糊性和模式崩溃问题：DDPM（Ho等人，2020年）最近作为一种能够产生清晰、连贯和多样化图像的生成模型而出现。这些模型非常有效地使用低质量的引导信号来重建这些信号来源的高维空间。换句话说，它们在超分辨率方面表现出色。
DDPM的局限性：传统的DDPM方法依赖于在采样开始前已知的固定输出形状。此外，DDPM的采样过程需要多次迭代，并且消耗大量计算资源，意味着总是会有显著的延迟成本。
1.2.3Re-ranking 自回归模型的输出过程：DALL-E引入了“重新排序”自回归模型输出的过程。这一过程从自回归模型中随机采样，并从k个输出中挑选最高质量的输出用于下游应用。
强大的鉴别器的需求：这种方法需要一个强大的鉴别器，即能够区分好的和不好的文本/图像配对的模型。DALL-E使用了CLIP（Radford等人，2021年），这是一个以对比文本和图像配对目标进行训练的模型。
2.Method 2.1Joining Autoregressive Decoders and DDPMs 将自回归解码器和DDPM结合起来
首先回顾一下二者的优势：
自回归模型的优势：
自回归模型擅长在视觉、文本和语音等未对齐的领域之间进行转换。它们通过将输入数据（如文本）转换成一系列的输出标记（如图像或语音的代表性标记）来工作。 DDPM的优势：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/256bbe398685071bb6119c13d40c070c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90082fcbf9d721477194be16ce2a540c/" rel="bookmark">
			解决el-steps切换时el-form的动态表单报错Error: please transfer a valid prop path to form item
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：在el-steps进行上一部下一步的切换的时候，不同步骤的表单内容不同，但是我发现在切换时动态表单校验的prop就会报错，网上看了很多方法依然还在报错，解决办法如下
原因是我之前切换判断用的是v-if,只需要把v-if换成v-show即可解决该问题
&lt;div class="rsStep"&gt; &lt;el-steps :active="menuIndex" align-center finish-status="success"&gt; &lt;el-step title="新增RS485类传感器"&gt;&lt;/el-step&gt; &lt;el-step title="解析模式设置"&gt;&lt;/el-step&gt; &lt;el-step title="解析模式测试"&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;/div&gt; &lt;div v-show="menuIndex === 0" class="sensor-detail menuindex-zero"&gt; 动态表单内容。。。。 &lt;/div&gt; 文章到此结束，希望对你有所帮助~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/501c0bafd6bf807ad04a40dd2bb97547/" rel="bookmark">
			一文读懂vue&#43;scss实现主题换肤功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、实现原理分析二、scss实现1.theme.scss2.handle.scssscss语法回顾1. @each遍历2. Maps值获取3. 混合指令@mixin scss实现换肤核心逻辑 应用于UI库样式修改 三、设置主题相关scss为全局变量 前言 web实现主题换肤方案有很多种，例如css变量、动态加载样式文件、js变量。目前流行工程化开发自然少不了css预处理（less/scss）方案，这也是目前在脚手架项目中比较流行实现方案。less/scss实现主题换肤本质就是动态切换节点某个变量，这个变量可以是HTML标签属性值也可以是类名，这个变量位置既可以是最顶层也可以是需要换肤地方（子节点）。变量如果是类名的话需要设置一个独一无二的名称，这个我们无法保证后面开发一不小心类名被重复了特别是团队协同开发，所以更好的选择变量是属性值。
看如下代码：
//顶层方案 [data-theme="red"] .title{ color:red } [data-theme="blue"] .title{ color:blue } //子节点方案 .title[data-theme="red"]{ color:red } .title[data-theme="blue"]{ color:blue } 两种方式我们通过改变data-theme值都能使title对应节点加载不同样式，区别地方在于顶层方案data-theme是设置在title上级标签上，子节点方案是设置在title本身上，这意味着每个title（子节点）都要设置data-theme，而顶层方案只要在页面最顶级父元素设置一次就可以，比如在html标签或者body标签设置，显而易见顶层方案更好。网上关于less/scss属性选择器实现主题换肤教程很多，大部分讲的不够细特别对sass语法不熟的人理解起来比较困难，本文将以顶层属性方案代码实现结合sass语法讲解，一步步讲解实现过程，通俗易懂。
一、实现原理分析 所有的主题切换方案的本质都是动态改变css样式，区别就在于变量的绑定形式。属性选择器实现方法是在页面顶层标签（比如html或者body）上设置一个data-theme属性，子节点样式类名前面加上属性选择器,通过改变属性值就能切换子节点样式达到换肤效果。具体分析往下看.
假设我们在html标签上定义了一个red红色主题属性，页面有个标题文字
&lt;!DOCTYPE html&gt; &lt;html data-theme="red"&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="title"&gt;标题&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 接下来我们设置title颜色，通过属性选择器让它跟data-theme关联
&lt;style&gt; [data-theme="red"] .title{ color:red } &lt;/style&gt; 此时标题字体颜色就变成红色
假设还有绿色、蓝色主题，这时候我们继续定义，增加title样式
&lt;style&gt; /**红色主题*/ [data-theme="red"] .title { color: red; } /**绿色主题*/ [data-theme="green"] .title { color: green; } /**蓝色主题*/ [data-theme="blue"] .title { color: blue; } &lt;/style&gt; 这时候我们只要改变html标签上 data-theme值就能切换其他主题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/501c0bafd6bf807ad04a40dd2bb97547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50c8245ffd90fb13afc37ce74eecd07b/" rel="bookmark">
			java stream简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）Stream
Stream（流）是一个来自数据源的元素队列并支持聚合操作。
forEach方法用来迭代流中的每个数据，没有返回值。map方法用于映射每个元素到对应的结果，有返回值，返回的是一个新流，可以对这个流进一步操作。
filter方法用于通过设置的条件过滤出元素。limit返回前n个元素。skip则是返回除前n个元素的元素。distinct方法用于去重。
sorted方法用于对流进行排序，例如，sorted()用于升序，sorted(Comparator.reverseOrder())用于降序。
max用于获取最大值。min用于获取最小值。count用于计算元素数量。sum用于求和。
anyMatch满足一个条件则返回true。allMatch满足所有条件则返回true。noneMatch不满足所有条件则返回true。findFirst返回第一个元素。findAny返回任意一个元素。
collect，收集流。Collectors类实现了很多归约操作，例如，toList、toMap、toSet、counting、summingInt、averagingInt、maxBy、minBy、joining、groupingBy等等。
reduce，聚合，将流中全部的数据聚合成一个值。
（2）测试
User tom = new User(1, "tom", 2, new Date()); User jerry = new User(3, "jerry", 1, new Date()); User diana = new User(2, "diana", 3, new Date()); List&lt;User&gt; userList = Arrays.asList(tom, jerry, diana); log.info("list:{}", userList); userList.stream().forEach(u -&gt; { if (u.getAge() &gt; 1) { log.info("{}", u); } }); List&lt;Integer&gt; list = userList.stream().map(u -&gt; u.getAge() + 1).limit(10).sorted(Comparator.reverseOrder()).collect(Collectors.toList()); log.info("list:{}", list); Map&lt;Integer, Object&gt; map = userList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50c8245ffd90fb13afc37ce74eecd07b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f06751604104f28e3bbc876b544f285/" rel="bookmark">
			Postgresql中的jsonb数据类型学习使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pgsql是在9.2版本中引入了对于json的支持
一般情况下使用到json数据格式的时候，99%都是查询，所以接下来看一下项目中对于json类型的数据是如何查询的
定义表 CREATE TABLE tv_sup_sl_dw_query ( id varchar(200) NOT NULL, sup_record_id varchar(100) default NULL, create_org_id varchar(100) default NULL, create_org_name varchar(100) default NULL, create_time timestamp(6), party_id varchar(100) default NULL, party_name varchar(100) default NULL, party_sup_from varchar(100) default NULL, party_sup_from_key varchar(100) default NULL, //表中的数据类型就是jsonb party_sup_other_json jsonb ); 对应的实体模型 @TableDefine(name = "tv_sup_sl_dw_query", abstractCol = "_abstract_col") public class TV_SUP_DW_QUERY_DS { @ColumnDefine(length=200,pk=true) protected String id; @ColumnDefine(length=100) protected String sup_record_id; protected Date create_time; @ColumnDefine(length=100) protected String create_org_id; @ColumnDefine(length=100) protected String create_org_name; @ColumnDefine(length = 100) protected String sp_type; @ColumnDefine(length=100) protected String party_id; @ColumnDefine(length=100) protected String party_name; @ColumnDefine(length=100) protected String party_org_type; @ColumnDefine(length=100) protected String party_sup_from; @ColumnDefine(length=100) protected String party_sup_from_key; @ColumnDefine(sqlType=DataSetDefine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f06751604104f28e3bbc876b544f285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fd78fafab2ed742ecd3173e5e64c5b7/" rel="bookmark">
			苹果提审被拒反馈崩溃日志.text | iOS 审核被拒crashLog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 iOS审核人员拒绝后每个截图，只给了几个text文件，这种情况就是审核的时候运行你的代码，崩溃了。
仅仅看text文件，是看不出所以然来的，所以我们要将日志转换成.crash格式
1.将.text文件下载下来，将 .text手动改成 .crash即可 2.右键 .crash文件，--&gt; 打开方式 --&gt; Xcdoe，这时候代码就会自动定位到崩溃代码处 （PS：进行第二步之前，你得预先打开你的Xcode项目，否则无法跳转） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605c5975ee2eb786fc2a845ce197cf5c/" rel="bookmark">
			thinphp 调用 \think\Log::write 写入回调日志信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //接口回调地址 public function back_content(){ \think\Log::record('进来了', 'info'); $data = file_get_contents('php://input'); $ret = json_decode($data,true); \think\Log::write('调用第一张图片返回结果'.$data,'log',true); }
Think\Log::record('测试日志信息，这是警告级别','WARN',true); 采用record方法记录的日志信息不是实时保存的，如果需要实时记录的话，可以采用write方法，例如：
Think\Log::write('测试日志信息，这是警告级别，并且实时写入','WARN'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f151472f70998a09e1d73e7ffd66c90b/" rel="bookmark">
			qt的main函数（程序启动入口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数入口的参数 这就是Qt中最简单的一个main函数：
int main(int argc, char *argv[]) { QApplication a(argc, argv); Widget w; w.show(); return a.exec(); } 其中int argc, char *argv[]参数是很有用的。
使用.\release\程序名.exe 模型名.model 模型文件所在的地址 这种方式是在商业软件开发过程中常用的方式。最大的一个好处就是可以用脚本来启动qt程序。
关于声明对象： 经常可以看到这样的代码：
Widget w; w.show(); 这样的代码其实表明了不用去new一个新对象，就用栈上的那种声明方法就行，不用管声明或调用完之后的各种释放操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f00a1c7b983c60bb013ed064d5058c/" rel="bookmark">
			PHP 图片转Base64的方法分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //图片转base64 function image_to_base(){ $imagePath = 'https://image.jewelryhunt.net/zhaowu/20240126/3fa44222f4ac2fa59b55116dc32493131.png'; $img_type = substr($imagePath, -3); // 读取图片文件内容 $imageData = file_get_contents($imagePath); $file_content = base64_encode($imageData); // base64编码 $img_base64 = 'data:image/' . $img_type . ';base64,' . $file_content;//合成图片base64编码 return $img_base64; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e52057d5ea343e30fe86cf0a2b9b08d/" rel="bookmark">
			Vite&#43;Electron快速构建一个VUE3桌面应用（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 简介 首先，介绍下vite和Electron。
Vite是一种新型前端构建工具，能够显著提升前端开发体验。Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入Chromium和Node.js到二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux——不需要本地开发 经验。 当开始想用vue去开发一个桌面应用时，首先去搜索下，了解到当前如下两种现成方案：
electron-vue： 该项目集成度较好，封装较为完整，中文搜索下来文章较多也是该方案，可以直接上手去使用。但是，问题在于其内置electron的版本太低，写文章时看到的版本是2.0.4，而最新的electron版本是15.1.2。Vue CLI Plugin Electron Builder： 该方案是集成到到vue-cli中使用，使用vue add electron-builder后可直接上手，免去了基础配置的步骤。但是其只能在vue-cli下使用，无法配合vite来使用。 因此，若要使用vite和electron，还需要自己来配置。
二. 创建一个Vite项目 1. 安装 vite yarn create vite 2. 创建项目 创建命令如下：
yarn create vite &lt;your-vue-app-name&gt; --template vue 此处创建一个项目，名为kuari。
yarn create vite kuari --template vue 3. 进入且运行 进入项目，在运行前需要先安装下依赖。
cd kuari yarn install yarn dev 在运行命令敲下的一瞬间，几乎是已经在运行了，不愧是vite。此时按照输出，打开地址预览，即可看到初始化页面。
至此一个基础的vite项目创建完成。
三. 配置Electron 1. 官方文档 在Electron官网的快速入门文档中，有官方给出的利用html、javascript、css来创建一个electron应用的案例，vite+electron的方案也借鉴其中。
2. 安装 首先安装electron至vite应用。目前electron的版本为^15.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e52057d5ea343e30fe86cf0a2b9b08d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/16/">«</a>
	<span class="pagination__item pagination__item--current">17/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/18/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>