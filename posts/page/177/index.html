<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5ef5781eb1fcb9140b9c50098dce8a1/" rel="bookmark">
			Python学习-安装Anaconda及print&#34;我爱王晓静&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		到anaconda官网下载python3.7版本（随时间推移）
安装过程中的勾选选择，only you ,Add python...
启动栏找到Anaconda，lunch jupyter
然后会出现上面的画面，选择右边的下拉栏，选择Python3，会弹出新的选项卡，如下图
可以开始你的python之旅了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1b75dfdeede859b82a6ae93fb2bf0c/" rel="bookmark">
			二叉树：广义表搭建二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用广义表搭建二叉树（及层序遍历） 问题概要 二叉树是非常常见的数据结构，那么，如何从无到有构建一棵二叉树呢？比较主流的方法就是输入一个广义表，例如A(B(D),C)，这种形式。那么，如何把这种字符串转变为对应的，用指针相连的二叉树，这个问题很常见，故记录如下。（这里假定树的节点内容均为大写英文字符。）
算法思路 首先，为了建立树，必须建一个根节点。
为了在这棵树上运动，建立一个指针，指向当前操作的节点，命名为curr，初始时指向根节点。
下面开始逐字符读入广义表。
当读入的字符为大写英文字符时，显然，此时对当前节点进行赋值操作；
当读入的字符为左括号时，应当建立当前节点的左孩子，同时，为统一赋值操作，应当把当前的curr指针指向新建的左孩子；
当读入的字符为逗号时，应当建立当前节点的兄弟节点（右兄弟）。也就是说，先把当前的curr指针指向它的父亲，然后对于这个父亲，建立右孩子，在把curr指针指向这个右孩子；
当读入的字符为右括号时，说明右孩子已经操作完毕（可能赋值，也可能没有赋值），令curr指针指向其父即可；
当读入的字符为/n时，结束输入，二叉树建立完毕。
代码 #include&lt;stdio.h&gt; #include&lt;malloc.h&gt; #include&lt;stdlib.h&gt; struct treenode { struct treenode* parent ; struct treenode* lchild ; struct treenode* rchild ; char data; }; int main() { struct treenode* root = (struct treenode*)malloc(sizeof(struct treenode)); struct treenode* curr = root; int node_num = 0; while (1) { char tmp; scanf_s("%c", &amp;tmp); if (tmp != '\n') { if (tmp == '(') { curr-&gt;lchild = (struct treenode*)malloc(sizeof(struct treenode)); curr-&gt;lchild-&gt;parent = curr; curr = curr-&gt;lchild; curr-&gt;lchild = NULL; curr-&gt;rchild = NULL; curr-&gt;data = 'a'; } else if (tmp == ',') { curr = curr-&gt;parent; curr-&gt;rchild = (struct treenode*)malloc(sizeof(struct treenode)); curr-&gt;rchild-&gt;parent = curr; curr = curr-&gt;rchild; curr-&gt;lchild = NULL; curr-&gt;rchild = NULL; curr-&gt;data = 'a'; } else if (tmp == ')') { curr = curr-&gt;parent; } else { curr-&gt;data = tmp; node_num++; } } else break; } struct treenode** q = (struct treenode**)calloc(node_num + 5, sizeof(struct treenode*)); int head = 0; int tail = 1; q[0] = root; while (head&lt;tail) { struct treenode* now = q[head]; head++; if (now-&gt;data !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a1b75dfdeede859b82a6ae93fb2bf0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad8ae757a1f63877fb404fcb3eeb3469/" rel="bookmark">
			Python爬虫requests模块中如何设置代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代理 （一）代理基本原理
代理实际上指的就是代理服务器， 英文叫作proxy server ，它的功能是代理网络用户去取得网络信息。形象地说， 它是网络信息的中转站。在我们正常请求一个网站时， 是发送了请求给web 服务器，web 服务器把响应传回给我们。如果设置了代理服务器， 实际上就是在本机和服务器之间搭建了一个桥， 此时本机不是直接向web 服务器发起请求， 而是向代理服务器发出请求， 请求会发送给代理服务器， 然后由代理服务器再发送给web 服务器， 接着由代理服务器再把web 服务器返回的响应转发给本机。这样我们同样可以正常访问网页， 但这个过程中web 服务器识别出的真实IP 就不再是我们本机的IP 了， 就成功实现了IP 伪装， 这就是代理的基本原理。
（二）代理的作用
1、突破自身IP 访问限制， 访问一些平时不能访问的站点。
2、访问一些单位或团体内部资源： 比如使用教育网内地址段免费代理服务器， 就可以用于对教育网开放的各类FTP 下载上传， 以及各类资料查询共享等服务。
3、提高访问速度： 通常代理服务器都设置一个较大的硬盘缓冲区， 当有外界的信息通过时， 同时也将其保存到缓冲区中， 当其他用户再访问相同的信息时， 则直接由缓冲区中取屮信息传给用户， 以提高访问速度。
4、隐藏真实IP ： 上网者也可以通过这种方法隐藏自己的IP ， 免受攻击。对于爬虫来说， 我们用代理就是为了隐藏自身IP ， 防止自身的被封锁。
（三）代理的分类
1、根据协议区分
根据代理的协议， 代理可以分为如下类别。
FTP 代理服务器：主要用于访问FTP 服务器， 一般有上传、下载以及缓存功能， 端口一般为21 、2121 等。
HTTP 代理服务器：主要用于访问网页， 一般有内容过滤和缓存功能， 端口一般为80 、8080 、3128 等。
SSL/TLS 代理：主要用于访问加密网站， 一般有SSL 或TLS加密功能（ 最高支持128 位加密强度） ， 端口一般为443 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad8ae757a1f63877fb404fcb3eeb3469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b29ae5e29cd5e93b9004be055c0d21d/" rel="bookmark">
			leetcode - 1223. 掷骰子模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1223. 掷骰子模拟 有一个骰子模拟器会每次投掷的时候生成一个 1 1 1 到 6 6 6 的随机数。
不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i i i 的次数不能超过 r o l l M a x [ i ] rollMax[i] rollMax[i]（ i i i 从 1 1 1 开始编号）。
现在，给你一个整数数组 r o l l M a x rollMax rollMax 和一个整数 n n n，请你来计算掷 n n n 次骰子可得到的不同点数序列的数量。
假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 1 0 9 + 7 10^9 + 7 109+7 之后的结果。
示例 1：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b29ae5e29cd5e93b9004be055c0d21d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab109e6b7d0bdb3bff8b12292e2fd7dd/" rel="bookmark">
			小程序怎么处理2x，3x图？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.wxss的解决办法（推荐） @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2){ .imgTest{ background: url(../images/2x.png) no-repeat; } } @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel-ratio: 3){ .imgTest{ background: url(../images/3x.png) no-repeat; } } 2 js方法 获取设备的设备像素比，在wxml上src动态用变量引用图片
//获取设备像素比 const getPixelRatio = () =&gt; { let pixelRatio = 0 wx.getSystemInfo({ success: function (res) { pixelRatio = res.pixelRatio }, fail: function () { pixelRatio = 0 } }) return pixelRatio } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb0784cdced9cd5b03fd1f068c9af1e8/" rel="bookmark">
			计算机中三大总线：地址总线、数据总线、控制总线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机中三大总线：地址总线、数据总线、控制总线 数据总线地址总线控制总线 今天在做软考的题目时发现一道题目，做过很多遍了，却始终会做错，刚开始我以为这只是一道记忆性的题目，只要把这个简单的知识点记住了就行了。然而，我发现，每一次做这种题目，我每一次都没做错来，根本记不住，理解才是王道。 题目如下： 例题：若内存容量为4GB，字长为32，则______。
A．地址总线和数据总线的宽度都为32
B．地址总线的宽度为30，数据总线的宽度为32
C．地址总线的宽度为30，数据总线的宽度为8
D．地址总线的宽度为32，数据总线的宽度为8
答案:A 内存容量为4GB，即内存单元的地址宽度为32位。字长为32位即要求数据总线的宽度为32位，因此地址总线和数据总线的宽度都为32。 由此题目引发如下思考：何为位？位宽？字？字长？字节？ 字长，是CPU一次能处理的二进制数的位数，*字长与之关联的是数据总线的位数，字长为32，则数据总线的宽度为32位。*比如CPU一次可以处理8个1（或者0），那么我们称这个CPU是8位的CPU，也就是说这个CPU的字长是8位。如果CPU一次可以处理16个二进制数，这个CPU的字长就是16位。
现在最新的CPU已经到了64位了，它们的字长就是64位。字长越大，CPU的处理能力越强，计算机运行也越快。
位宽就是内存或显存一次能传输的数据量。(这里我对位宽的理解也仅限于此）简单地讲就是一次能传递的数据宽度。字长指的是计算能力，位宽指的是传输能力。
在计算机中传送信息的基本单位是（ ）
A) 字
B) 字节
C．位
D) 字长
正确答案
A
答案解析
[解析] 位是计算机存储的最小单位；1个字节是8个相邻二进制位组成的，是计算机存储中的基本单位，也是数据处理的基本单位。字是CPU通过数据总线一次存取、加工和传送时作为一个单位的一组二进制数。字长是每个字包含的位数。
字：
定义:
计算机在进行数据处理，一次存取、加工、传送的数据长度称为字(word)。
一个字一般由多个(整数倍)字节构成。
性质:
1word=2Byte=16bit
一个字由两个字节组成，16位组成
通常称16位是一个字，32位是一个双字，64位是两个双字
计算机的字长决定CPU一次处理实际位数的多少，字长越大，性能越优。
数据总线 （1） 是CPU与内存或其他器件之间的数据传送的通道。
（2）数据总线的宽度决定了CPU和外界的数据传送速度。
（3）每条传输线一次只能传输1位二进制数据。eg: 8根数据线一次可传送一个8位二进制数据(即一个字节)。
（4）数据总线是数据线数量之和。
地址总线 （1）CPU是通过地址总线来指定存储单元的。
（2）地址总线决定了cpu所能访问的最大内存空间的大小。eg: 10根地址线能访问的最大的内存为1024位二进制数据（1024个内存单元）(1B)
（3）地址总线是地址线数量之和。
控制总线 （1）CPU通过控制总线对外部器件进行控制。
（2）控制总线的宽度决定了CPU对外部器件的控制能力。
（3）控制总线是控制线数量之和。
最后总结如下：
地址总线的宽度决定CPU的寻址能力；
数据总线的宽度决定CPU与其他元器件一次最大传送的数据量；
控制总线决定CPU对其他元器件的控制能力。
下面结合一些题目来加以理解：
1.地址总线：一个cpu的N根地址总线，则可以说这个CPU的地址总线宽度为N。这样cpu最多可以寻址2的N次方个内存单元。
2.8根数据总线传送一个8位二进制，数据线数量相当于每单元的位数
3.存储容量=单元数*每单元的位数，一般每单元位数都是8
例1.若256KB的SRAM具有8条数据线，则他具有多少条地址线
分析：256KB为他的存储容量，则一般表达为单元数*每单元位数，8条数据总线代表8位，也就是一个单元
256KB=32KB*8 32KB为单元数，也就是2的N次方等于32KB 为了计算方便，可记2的10次方=1K 则32KB=2的5次方*2的10次方 例2.写出下列的RAM芯片片内的地址线和数据线的条数：（1）4K8位；（2）512K4位；（3）1M1位；（4）2K8位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb0784cdced9cd5b03fd1f068c9af1e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d27733ef020628828f53a8b10e009917/" rel="bookmark">
			收敛数列有界的通俗理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来引用原课本里的理论证明吧
看似云里雾里,定义的那么多符号,似乎一遍真的还不怎么能看懂它说的什么。
唉，没办法，数学的证明都是这样。谁让数学是世界上最严谨的语言呢。
那么我们就来看看这段到底怎么理解才好。当你理解了文字背后的意思的时候，也就不用再花费那么多的时间来研究它的语言逻辑了。除非你想当数学家。
首先这里有一个数列{Xn},这里不能把它错当成函数认为n可以取负数。数列n下标的最小值只能是1。那么一个数列它收敛也就是 说 limXn-&gt;A(n-&gt;无穷大)。随着n的越来越大它会越来越接近一个但是永远不会达到或者超过的数A。我们称A是数列的极限。
接着来看，第一种情况。当数列是递增数列的时候。那么数列就有一个最小值X1,当随着n的增大数列会一直接近A但不会超过A。这时候数列的取值范围就是[X1,A)。这时候数列有界
同理当数列为递减数列时数列的取值范围就是（A,X1]。也能得到数列有界。
接下来看最后一种情况就是当数列没有单调性时收敛的情况。
你想，一个数列收敛且没有单调性会是怎样的呢？
不管它是怎样的一个图像，它随着n的增大肯定是会往A那边缩的。我们用一个抽象的图来理解一下。
像这种收敛但不单调的数列它的值只能在x轴上下振动并向A慢慢靠近一直靠到一个极限。
那么问题来了它是有界的吧？我们知道L1,L2是数列上下值最大所到的距离,因为是收敛数列那么它的值都是振动地向A那边收缩。所以也是有界的为[-L2,L1]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8bbefb13860554721e22b24cef70f56/" rel="bookmark">
			MyBatis 中使用 Collection 嵌套查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载https://blog.csdn.net/u013360850/article/details/78704701
当使用 MyBatis 进行查询的时候如果一个 JavaBean 中包含另一个 JavaBean 或者 Collection 时，可以通过 MyBatis 的嵌套查询来获取需要的结果;
以下以用户登录时的角色和菜单直接的关系为例使用嵌套查询
JavaBean
RoleModel
public class RoleModel {
private Integer id;
private String name;
private Boolean isActive;
private String description;
private Date lastUpdateTime;
private List&lt;MenuModel&gt; menus;
···
} MenuModel
public class MenuModel {
private Integer id;
private String value;
private String displayValue;
private String url;
private Integer category;
private String description;
private Boolean isActive;
private Date lastUpdateTime;
···
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8bbefb13860554721e22b24cef70f56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86824206413e659c14eba96d7349538f/" rel="bookmark">
			NX二次开发 CreateDialog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景描述：
NX二次开发中创建UI时，会使用UI::GetUI()-&gt;CreateDialog(theDlxFileName);
如果项目添加Windows库，会将CreateDialog替换成CreateDialogW或CreateDialogA
报错内容：
class "NXOpen::UI" 没有成员 "CreateDialogParamW" .... 解决办法：
查看NXOpen中CreateDialog函数说明：
在.cpp文件中添加下面代码即可
#ifdef CreateDialog #undef CreateDialog #endif 注意添加位置：一定在Windows库之后，NX库之前位置添加
按照上面方法改了之后，当前代码的CreateDialog是不会报错了。
以下情况也能导致该报错：
#include &lt;stdafx.h&gt; #include &lt;NXOpen\UI.hxx&gt; 更改如下即可。
#include &lt;stdafx.h&gt; #undef CreateDialog #include &lt;NXOpen\UI.hxx&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409d0d9865cfa0d1e101e78c3bcce517/" rel="bookmark">
			computeIfAbsent and putIfAbsent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现了这两个有趣的map内置方法，发现还是有很多不同的
1. garbage usage:
putIfAbsent 运行情况就像是：
V v = map.get(key); if (v == null) v = map.put(key, value); return v; computeIfAbsent 运行就像是：
if (map.get(key) == null) { V newValue = mappingFunction.apply(key); if (newValue != null) map.put(key, newValue); } 对于很占内存的值，比如说是 new ArrayList&lt;&gt;(), putIfAbsent 都会先创建一个值，然后如果map中存在这个key， 再忽略掉这个新n创建的值，会浪费很多空间，调用没有必要的垃圾回收
2. return value
computeIfAbsent: 返回当前或者是新存入的，与key相关的值，或者是NULL（只有在compute value是NULL的情况下）putIfAbsent: 返回上一个与key对应的值，或者是NULL（如果当前key没有对应的值）
如果key已经存在，二者没有太大区别，如果key不存在，computeIfAbsent 返回 compute value，putIfAbsent 返回NULL
3. input value
对于Absent的定义：key不存在，或者key所对应的值是NULL
computeIfAbsent: 不会放入NULL value 如果key不存在
putIfAbsent: 会放入NULL值
这个对于getOrDefault and containsKey有不同的影响
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d495ac8c8b84701ddccff603e5c8bc/" rel="bookmark">
			ElasticSearch 7.4集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2台机器，系统均为Centos 7.2,主节点IP为10.45.154.236,第二节点的IP为10.45.154.70，均为内网IP。
1.下载相关软件包
到官网上下载最新版本ElasticSearch 7.4,https://www.elastic.co/cn/downloads/elasticsearch
我选择的是RPM包
下载最新的JDK 13 https://www.oracle.com/technetwork/java/javase/downloads/index.html
2.修复系统配置
vi /etc/security/limits.conf
新增内容如下：
* hard nofile 65536
* soft nproc 2048
* hard nproc 4096
* soft memlock unlimited
* hard memlock unlimited
vi /etc/sysctl.conf
新增内容如下：
vm.max_map_count=655360
fs.file-max=655360
执行 sysctl -p 让其生效
3.安装软件
直接rpm安装软件包，再执行如下命令，让其开机自启
sudo systemctl daemon-reload
sudo systemctl enable elasticsearch.service
查看一下java环境是否正常
4.修改配置文件
做个备份: cp -rf /etc/elasticsearch/elasticsearch.yml /etc/elasticsearch/elasticsearch.yml.bak
/etc/elasticsearch/elasticsearch.yml
主节点配置信息：
#集群名称
cluster.name: ES-Cluster
#节点名称
node.name: ES-node1
#是否是master节点
node.master: true
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2d495ac8c8b84701ddccff603e5c8bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d21c9a648542fd4d580a16724bcf26/" rel="bookmark">
			Makefile中export的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际的项目中，总不会是只有一个 Makefile 文件，我们会在 Makefile 中调用另外的 Makefile 文件，呈现出 Makefile 的层级结构。
上层 make 过程要将所执行的 Makefile 中的变量传递给子 make 过程，需要明确地指出。
在 GNU make 中，实现此功能的指示符是 export。当一个变量使用 export 进行声明后，变量和它的值将被加入到当前工作的环境变量中，以后在 make 执行的所有规则的命令都可以使用这个变量。
而当没有使用指示符 export 对任何变量进行声明的情况下，上层 make 只将那些已经初始化的环境变量（在执行 make 之前已经存在的环境变量）和使用命令行指定的变量（如命令make CFLAGS +=-g 或者 make –e CFLAGS +=-g）传递给子 make 过程。
例子：对比下面的两个示例的输出结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/397aee389a752f11579c48f902656189/" rel="bookmark">
			python pycharm OpenCV cv.filter2D函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dst=cv.filter2D(src, ddepth, kernel[, dst[, anchor[, delta[, borderType]]]])
参数 描述
src 原图像
dst 目标图像，与原图像尺寸和通过数相同
ddepth 目标图像的所需深度
kernel 卷积核（或相当于相关核），单通道浮点矩阵;如果要将不同的内核应用于不同的通道，请使用拆分将图像拆分为单独的颜色平面，然后单独处理它们。
anchor 内核的锚点，指示内核中过滤点的相对位置;锚应位于内核中;默认值（-1，-1）表示锚位于内核中心。
detal 在将它们存储在dst中之前，将可选值添加到已过滤的像素中。类似于偏置。
borderType 像素外推法，参见BorderType
cv.filter2D，dst与src大小相同，卷积核采用的 边缘复制
比如，某一图像像素为
卷积核（均值滤波）
计算过程：
卷积核与像素矩阵元素相乘在求和，其结果覆盖卷积核中心的像素值（标红的位置）。
而问号“？”则是需要考虑的填充方法。
当ddepth=-1时，表示输出图像与原图像有相同的深度。
图像深度是指存储每个像素所用的位数，他也是用来度量图像的色彩分辨率的。
例如，一幅彩色图像的每个像素用R，G，B三个分量表示，若每个分量用8位，那么一个像素共用24位表示，就说像素的深度为24，每个像素可以是16 777 216(2的24次方)种颜色中的一种。
其他的滤波器及卷积核：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd00cf9f1a78d751ef91c1e7a1540d5a/" rel="bookmark">
			django之markdown使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.初次使用误区2.两种方法实现2.1 通过python的markdown实现2.1.1通过pip下载markdown2.1.2.在cmd中测试下markdown是否可以用，下图经测试可以转换成功2.1.3.正式使用2.1.4解决没有目录以及代码高亮：2.1.5 解决高亮问题2.1.5.1 大体流程：2.1.5.2.做法:注：在极少数版本里，html经过pygments处理后加的外层样式不是 .codehilite而是.highlight，这是在cmd里对应生成的css语句应如下： 2.2 django-markdown-deux实现(我没有成功，据评论区说将INSTALLED_APPS = ['markdown_deux',]可以成功，但没有亲自实验) 1.初次使用误区 初次在django工程中使用markdown时，不知怎么样将markdown嵌入django工程中；
经过查阅博客了解大概思路是自己随便在页面中定义一个框进行书写markdown语法，然后写完后将markdown语法经过处理变成html语句传到页面中执行就可以；总体来说就是为模板渲染加入markdown支持
2.两种方法实现 1.Python模块 markdown
2.Django 的django-markdown-deux模块
2.1 通过python的markdown实现 这个可以将markdown转化成html语句的工具，然后传入html界面用 {{html字符串|safe}}处理下就行
2.1.1通过pip下载markdown pip install markdown 2.1.2.在cmd中测试下markdown是否可以用，下图经测试可以转换成功 2.1.3.正式使用 Django出于安全的考虑，会将输出的HTML代码进行转义，这使得article.body中渲染的HTML文本无法正常显示。管道符 | 是Django中过滤器的写法，而 | safe就类似给article.body贴了一个标签，表示这一段字符不需要进行转义了。
views: import markdown def main(request): [TOC] #markdown2 ##second list ###markdown is ok? **关关雎鸠，在河之洲。窈窕淑女，君子好逑。** 参差荇菜，左右流之。窈窕淑女，寤寐求之。 --- + 列表一 + 列表二 + 列表二-1 + 列表二-2 ```python content=cursor.fetchall() conn.close() return content ```''' #注意上方markdown格式 html = markdown.markdown(text) print(html) return render(request,"main.html",{"html":html}) main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd00cf9f1a78d751ef91c1e7a1540d5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9789175ee54add890c4289d380967144/" rel="bookmark">
			五分钟快速过完Verilog HDL基本概念(5)数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型 数据类型是用来表示数字电路中的数据存储和传送单元。 Verilog HDL中共有19种数据类型；其中4个最基本的数据类型为：integer型 parameter型 reg型 wire型 其它数据类型：large型、medium型、 scalared型、 small型、time型、tri型、tri0型tri1型、triand型、trior型、trireg型、vectored型、wand型、wor型等 常量 在程序运行过程中，其值不能被改变的量，称为常量。 数字（包括整数，x和z值，负数） parameter常量（或称符号常量） 整数型常量（即整常数）的4种进制表示形式：二进制整数（b或B）； 十进制整数（d或D）； 十六进制整数（h或H）； 八进制整数（o或O）。 整常数的3种表达方式： 表 达 方 式说 明举 例&lt;位宽&gt; ’&lt;进制&gt; &lt;数字&gt;完整的表达方式8’b11000101或8’hc5&lt;进制&gt; &lt;数字&gt;缺省位宽，则位宽由机器系统决定，至少32位hc5&lt;数字&gt;缺省进制为十进制，位宽默认为32位197 这里位宽指对应二进制数的宽度。
parameter常量（符号常量） 用parameter来定义一个标识符，代表一个常量——称为符号常量。 parameter 参数名1 = 表达式,参数名2 = 表达式, ……； 参数型数据的确认符	赋值语句表 每个赋值语句的右边必须为常数表达式，即只能包含数字或先前定义过的符号常量！
parameter addrwidth = 16； //合法格式
parameter addrwidth = datawidth*2； //非法格式常用参数来定义延迟时间和变量宽度。可用字符串表示的任何地方,都可以用定义的参数来代替。参数是本地的，其定义只在本模块内有效。在模块或实例引用时，可通过参数传递改变在被引用模块或实例中已定义的参数！ 符号常量：标识符形式的常量
parameter datawidth =8,addrwidth = datawidth*2； //合法格式
为什么要使用parameter常量？——这样便于多处数字的一次性修改和书写的简洁、有意义。
变量 在程序运行过程中，其值可以改变的量，称为变量。 其数据类型有19种，常用的有3种：网络型（nets type） 寄存器型（register type ） 数组（memory type） nets型变量不能储存值！即不能存储输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9789175ee54add890c4289d380967144/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62baf9d4253a6aaad309a2a97402c16/" rel="bookmark">
			在 Windows 系统下常用的 bat 脚本分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以网络配置举例说明，网络连接默认情况下都是 DHCP（自动获取 IP 和 DNS 地址） 模式，但很多情况下，需要我们设置为指定的静态 IP 和 DNS 地址。在 Windows 系统中通常我们都是在系统托盘中右键网络图标，点击 打开网络和共享中心 → 更改适配器设置 → 右键 以太网（WLAN...） 属性 → IPv4 属性 这样一步一步的来修改，即繁琐又浪费时间，所以在这里将自己常用的 bat 脚本分享出来，使用后多多少少能节省一点时间，提高工作效率。
1. WLAN（以太网等）静态 IP / DHCP 快速配置脚本 因鄙人所在公司的网络是进行了监控和限制了的，每个人都分有一个连接互联网的 IP 地址，就连 QQ 也是限制登录了的，只要使用公司的网络就只有登记的工作 QQ 可以登录的上去。因为在公司用的是自己的电脑，在家的时候都是使用自动获取 IP 的模式，到公司就得改成静态 IP，所以使用 bat 脚本一键修改 IP 可以节约很多时间。废话有点多了...上图：
586 x 501
使用方法：
312 x 217
绿色框线部分设为自己常用的静态 IP 配置，使用时直接选择第 2 项回车即可。变量 Nic 对应网络连接中的 WLAN 或 以太网 （Win7 以前的应该叫 本地连接）：
702 x 186 798 x 212
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c62baf9d4253a6aaad309a2a97402c16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6120a0c4bb021b3206b5f70c8ab79b4e/" rel="bookmark">
			MUI混合开发——更新下载app时，系统状态栏显示下载进度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、最开始的想法 本来最开始公司使用mui制作的app，没有系统状态栏显示下载进度的，后来突发奇想想要实现像qq等app下载更新或消息提示等在系统状态栏显示的效果，特意去研究了下。
在H5+plus api中没有发现存在有设置系统通知栏的支持，于是采取android开发的方式，实现功能。
大致功能描述：
大致就是这种操作啦，下面像大家展示插件开发的方式实现上述功能。
二、系统通知栏插件开发 1、更新操作，下载安装包等依旧使用H5+plus的方式实现
function createDownload(url) { if(!url) { mui.toast("获取下载路径错误"); return; } //事件参数单位为s var downloadTask = plus.downloader.createDownload(url, { //timeout: 10, //retryInterval: 5, //retry: 3 }); plus.notification.setNotification("新版下载", "开始下载"); //插件调用 downloadTask.start(); console.log("$$$$$$"); downloadTask.addEventListener("statechanged", function(task, status) { //console.log("task---&gt;"+task); console.log("task.state---&gt;" + task.state); //var current = parseInt(100 * task.downloadedSize / task.totalSize); //console.log("current--&gt;" + current); //console.log("status---&gt;"+status); switch(task.state) { case 1: // 开始 console.log('开始'); break; case 2: //已连接到服务器 console.log('已连接到服务器'); break; case 3: // 已接收到数据 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6120a0c4bb021b3206b5f70c8ab79b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca1e461dc6bb5cf85c6a9dfc6bbd80af/" rel="bookmark">
			[转载]jdk1.8垃圾回收器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，什么是垃圾回收
首先，在了解G1之前，我们需要清楚的知道，垃圾回收是什么？简单的说垃圾回收就是回收内存中不再使用的对象。
垃圾回收的基本步骤
回收的步骤有2步：
查找内存中不再使用的对象
释放这些对象占用的内存
1,查找内存中不再使用的对象
那么问题来了，如何判断哪些对象不再被使用呢？我们也有2个方法：
引用计数法
引用计数法就是如果一个对象没有被任何引用指向，则可视之为垃圾。这种方法的缺点就是不能检测到环的存在。
2.根搜索算法
根搜索算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
现在我们已经知道如何找出垃圾对象了，如何把这些对象清理掉呢？
2. 释放这些对象占用的内存
常见方式有复制或者直接清理，但是直接清理会存在内存碎片，于是就会产生了清理再压缩的方式。
总得来说就产生了三种类型的回收算法。
1.标记-复制
它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次理掉。它的优点是实现简单，效率高，不会存在内存碎片。缺点就是需要2倍的内存来管理。
2.标记-清理
标记清除算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，标记完成之后统一清除对象。它的优点是效率高，缺点是容易产生内存碎片。
3.标记-整理
标记操作和“标记-清理”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有 存活的对象都向一端移动，并更新引用其对象的指针。因为要移动对象，所以它的效率要比“标记-清理”效率低，但是不会产生内存碎片。
基于分代的假设
由于对象的存活时间有长有短，所以对于存活时间长的对象，减少被gc的次数可以避免不必要的开销。这样我们就把内存分成新生代和老年代，新生代存放刚创建的和存活时间比较短的对象，老年代存放存活时间比较长的对象。这样每次仅仅清理年轻代，老年代仅在必要时时再做清理可以极大的提高GC效率，节省GC时间。
java垃圾收集器的历史
第一阶段，Serial（串行）收集器
在jdk1.3.1之前，java虚拟机仅仅能使用Serial收集器。 Serial收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
PS：开启Serial收集器的方式
-XX:+UseSerialGC
第二阶段，Parallel（并行）收集器
Parallel收集器也称吞吐量收集器，相比Serial收集器，Parallel最主要的优势在于使用多线程去完成垃圾清理工作，这样可以充分利用多核的特性，大幅降低gc时间。
PS:开启Parallel收集器的方式
-XX:+UseParallelGC -XX:+UseParallelOldGC
第三阶段，CMS（并发）收集器
CMS收集器在Minor GC时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。在Full GC时不再暂停应用线程，而是使用若干个后台线程定期的对老年代空间进行扫描，及时回收其中不再使用的对象。
PS:开启CMS收集器的方式
-XX:+UseParNewGC -XX:+UseConcMarkSweepGC
第四阶段，G1（并发）收集器
G1收集器（或者垃圾优先收集器）的设计初衷是为了尽量缩短处理超大堆（大于4GB）时产生的停顿。相对于CMS的优势而言是内存碎片的产生率大大降低。
PS:开启G1收集器的方式
-XX:+UseG1GC
二，了解G1
G1的第一篇paper（附录1）发表于2004年，在2012年才在jdk1.7u4中可用。oracle官方计划在jdk9中将G1变成默认的垃圾收集器，以替代CMS。为何oracle要极力推荐G1呢，G1有哪些优点？
首先，G1的设计原则就是简单可行的性能调优
开发人员仅仅需要声明以下参数即可：
-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200
其中-XX:+UseG1GC为开启G1垃圾收集器，-Xmx32g 设计堆内存的最大内存为32G，-XX:MaxGCPauseMillis=200设置GC的最大暂停时间为200ms。如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可。
其次，G1将新生代，老年代的物理空间划分取消了。
这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。
取而代之的是，G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。
在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。
PS：在java 8中，持久代也移动到了普通的堆内存空间中，改为元空间。
对象分配策略
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca1e461dc6bb5cf85c6a9dfc6bbd80af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdf9cc728ec11000b0a3bf84b71d9876/" rel="bookmark">
			[转载]java高分局之jstat命令使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/maosijunzi/article/details/46049117 java高分局之jstat命令使用 jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：
jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]
注意：使用的jdk版本是jdk8.
类加载统计： C:\Users\Administrator&gt;jstat -class 2060 Loaded Bytes Unloaded Bytes Time 15756 17355.6 0 0.0 11.29 Loaded:加载class的数量Bytes：所占用空间大小Unloaded：未加载数量Bytes:未加载占用空间Time：时间 编译统计 C:\Users\Administrator&gt;jstat -compiler 2060 Compiled Failed Invalid Time FailedType FailedMethod 9142 1 0 5.01 1 org/apache/felix/resolver/ResolverImpl mergeCandidatePackages Compiled：编译数量。Failed：失败数量Invalid：不可用数量Time：时间FailedType：失败类型FailedMethod：失败的方法 垃圾回收统计 C:\Users\Administrator&gt;jstat -gc 2060 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT 20480.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdf9cc728ec11000b0a3bf84b71d9876/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17e579fbeebb71ad1a5586d591b06ae7/" rel="bookmark">
			High Severity Error,Unhandled Exception Log file path must be defined before calling the WriteToLog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		High Severity Error Unhandled Exception Log file path must be defined before calling the WriteToLog 最近一准备打开MySQL客户端，就会弹出以下的页面，
然后进到MySQL客户端之后，又点击下面这个有进不去，
很是苦恼。因为在项目里面想在数据库里面查东西，每次都得去服务里面手动打开MySQL57服务，然后才能正常访问
然后试着在电脑管家APP里面找自动启动MySQL的方法，好几次在下面这个页面找，但就是没找到
无意间在电脑加速的下面找到了启动项的配置
点击进去就到了下面的页面
在服务项里面找MySQL57，这里显示已禁用，点击一下，启用MySQL57就解决了，就能顺利进入MySL的数据库了，也不用再每次手动启动M有SySQL57了
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/176/">«</a>
	<span class="pagination__item pagination__item--current">177/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/178/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>