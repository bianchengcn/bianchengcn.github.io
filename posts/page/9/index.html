<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea6ded9a68c460953bc5c5185aa58ad3/" rel="bookmark">
			HCIP---RIP综合实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求：R1-R2-R3-R4-R5 RIP 100运行版本2
R6-R7 RIP 200 运行版本1
1.使用合理IP地址规划网络，各自创建环回接口
2.R1创建环回 172.16.1.1/24 172.16.2.1/24 172.16.3.1/24
3.要求R3使用R2访问R1环回
4.减少路由条目数量，R1-R2之间增加路由传递安全性
5.R5创建一个环回模拟运营商，不能通告
6.R1 telnet R2环回实际telnet 到R7上
7.R6-R7路由器不能学习到达R1环回路由
8.全网可达
1.创建环回接口
2.R3使用R2访问R1环回
3.减少路由条目数量，R1-R2之间增加路由传递安全性
4.R5创建一个环回模拟运营商，不能通告
在r4路由器上做一条缺省路由指向运营商
5.R6-R7路由器不能学习到达R1环回路由
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82305295fa50f8b750f6a19909378448/" rel="bookmark">
			糊涂工具包使用 记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hutool 工具包 配置 引入依赖
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.16&lt;/version&gt; &lt;/dependency&gt; BeanUtil bean复制
Orders orders = BeanUtil.copyProperties(ordersSubmitDTO, Orders.class); String相关操作 判断是否为空,如果为空,设置为自定义str StrUtil.blankToDefault(addressBook.getConsignee(),"") 我这里逻辑就是,如果第一个参数为空,这里的空代表着为null,或者为""这样的空串,如果是的化,就设置为第二个参数,我这里是空串
以逗号为分割符,生成str String date = StrUtil.join(",", dateList); 使用join方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7761bb0530bf17b9575831267d9e484c/" rel="bookmark">
			数据结构与算法——队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 计算机科学中，queue 是以顺序的方式维护的一组数据集合，在一端添加数据，从另一端移除数据。添加的一端称为尾，移除的一端称为头。
功能 插入offer(value : E) : boolean　取值并移除poll() : E　取值peek() : E　判断是否为空isEmpty() : boolean　判断队列是否满isfull() : boolean 接口代码 public interface Queue&lt;E&gt; { /** * 向队列尾插入值 * @param value 待插入值 * @return 插入成功返回 true, 插入失败返回 false */ boolean offer(E value); /** * 从对列头获取值, 并移除 * @return 如果队列非空返回对头值, 否则返回 null */ E poll(); /** * 从对列头获取值, 不移除 * @return 如果队列非空返回对头值, 否则返回 null */ E peek(); /** * 检查队列是否为空 * @return 空返回 true, 否则返回 false */ boolean isEmpty(); /** * 检查队列是否已满 * @return 满返回 true, 否则返回 false */ boolean isFull(); } 链表实现 利用单向环形带哨兵链表实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7761bb0530bf17b9575831267d9e484c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c363bbe41caf957bdb9a4a8a65e51edb/" rel="bookmark">
			黑客技术（网络安全）自学2024
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、自学网络安全学习的误区和陷阱 1.不要试图先以编程为基础的学习再开始学习 我在之前的回答中，我都一再强调不要以编程为基础再开始学习网络安全，一般来说，学习编程不但学习周期长，而且实际向安全过渡后可用到的关键知识并不多
一般人如果想要把编程学好再开始学习网络安全往往需要花费很长时间，容易半途而废。而且学习编程只是工具不是目的，我们的目标不是成为程序员。建议在学习网络安全的过程中，哪里不会补哪里，这样更有目的性且耗时更少
2.不要把深度学习作为入门第一课 很多人都是冲着要把网络安全学好学扎实来的，于是就很容易用力过猛，陷入一个误区：就是把所有的内容都要进行深度学习，但是把深度学习作为网络安全第一课不是个好主意。原因如下：
【1】深度学习的黑箱性更加明显，很容易学的囫囵吞枣
【2】深度学习对自身要求高，不适合自学，很容易走进死胡同
3.不要收集过多的资料 网上有很多关于网络安全的学习资料，动辄就有几个G的材料可以下载或者观看。而很多朋友都有“收集癖”，一下子购买十几本书，或者收藏几十个视频
网上的学习资料很多重复性都极高而且大多数的内容都还是几年前没有更新。在入门期间建议“小而精”的选择材料，下面我会推荐一些自认为对小白还不错的学习资源，耐心往下看
二、学习网络安全的一些前期准备 1.硬件选择 经常会问我“学习网络安全需要配置很高的电脑吗？”答案是否定的，黑客用的电脑,不需要什么高的配置,只要稳定就行.因为黑客所使用的一些程序,低端CPU也可以很好的运行,而且不占什么内存.还有一个,黑客是在DOS命令下对进行的,所以电脑能使用到最佳状态!所以，不要打着学习的名义重新购买机器...
2.软件选择 很多人会纠结学习黑客到底是用Linux还是Windows或者是Mac系统，Linux虽然看着很酷炫，但是对于新人入门并不友好。Windows系统一样可以用虚拟机装靶机来进行学习
至于编程语言，首推Python，因为其良好的拓展支持性。当然现在市面上很多网站都是PHP的开发的，所以选择PHP也是可以的。其他语言还包括C++、Java...
很多朋友会问是不是要学习所有的语言呢？答案是否定的！引用我上面的一句话：学习编程只是工具不是目的，我们的目标不是成为程序员
（这里额外提一句，学习编程虽然不能带你入门，但是却能决定你能在网络安全这条路上到底能走多远，所以推荐大家自学一些基础编程的知识）
3.语言能力 我们知道计算机最早是在西方发明出来的，很多名词或者代码都是英文的，甚至现有的一些教程最初也是英文原版翻译过来的，而且一个漏洞被发现到翻译成中文一般需要一个星期的时间，在这个时间差上漏洞可能都修补了。而且如果不理解一些专业名词，在与其他黑客交流技术或者经验时也会有障碍，所以需要一定量的英文和黑客专业名词（不需要特别精通，但是要能看懂基础的）
比如说：肉鸡、挂马、shell、WebShell等等
三、网络安全学习路线 第一阶段：基础操作入门，学习基础知识 入门的第一步是学习一些当下主流的安全工具课程并配套基础原理的书籍，一般来说这个过程在1个月左右比较合适。
在这个阶段，你已经对网络安全有了基本的了解。如果你学完了第一步，相信你已经在理论上明白了上面是sql注入，什么是xss攻击，对burp、msf、cs等安全工具也掌握了基础操作。这个时候最重要的就是开始打地基！
所谓的“打地基”其实就是系统化的学习计算机基础知识。而想要学习好网络安全，首先要具备5个基础知识模块：
1.操作系统
2.协议/网络
3.数据库
4.开发语言
5.常见漏洞原理
学习这些基础知识有什么用呢？ 计算机各领域的知识水平决定你渗透水平的上限。
【1】比如：你编程水平高，那你在代码审计的时候就会比别人强，写出的漏洞利用工具就会比别人的好用；
【2】比如：你数据库知识水平高，那你在进行SQL注入攻击的时候，你就可以写出更多更好的SQL注入语句，能绕过别人绕不过的WAF；
【3】比如：你网络水平高，那你在内网渗透的时候就可以比别人更容易了解目标的网络架构，拿到一张网络拓扑就能自己在哪个部位，拿到以一个路由器的配置文件，就知道人家做了哪些路由；
【4】再比如你操作系统玩的好，你提权就更加强，你的信息收集效率就会更加高，你就可以高效筛选出想要得到的信息
第二阶段：实战操作 1.挖SRC 挖SRC的目的主要是讲技能落在实处，学习网络安全最大的幻觉就是觉得自己什么都懂了，但是到了真的挖漏洞的时候却一筹莫展，而SRC是一个非常好的技能应用机会。
2.从技术分享帖（漏洞挖掘类型）学习 观看学习近十年所有0day挖掘的帖，然后搭建环境，去复现漏洞，去思考学习笔者的挖洞思维，培养自己的渗透思维​​​​​​
3.靶场练习 自己搭建靶场或者去免费的靶场网站练习，有条件的话可以去购买或者报靠谱的培训机构，一般就有配套的靶场练习
第三阶段：参加CTF比赛或者HVV行动 推荐：CTF比赛 CTF有三点： 【1】接近实战的机会。现在网络安全法很严格，不像之前大家能瞎搞
【2】题目紧跟技术前沿，而书籍很多落后了
【3】如果是大学生的话，以后对找工作也很有帮助
如果你想打CTF比赛，直接去看赛题，赛题看不懂，根据不懂的地方接着去看资料
推荐：HVV（护网） HVV有四点： 【1】也能极大的锻炼你，提高自身的技术，最好是参加每年举行的HVV行动
【2】能认识许多圈内的大佬，扩大你的人脉
【3】HVV的工资也很高，所以参加的话也能让你赚到不少钱
【4】和CTF比赛一样如果是大学生的话，以后对找工作也很有帮助
四、学习资料的推荐 书单推荐： 计算机操作系统： 【1】编码：隐藏在计算机软硬件背后的语言
【2】深入理解操作系统
【3】深入理解windows操作系统
【4】Linux内核与实现
编程开发类： 【1】 windows程序设计
【2】windwos核心变成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c363bbe41caf957bdb9a4a8a65e51edb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f91de8a4e89b455c75e6470afb7b9d1/" rel="bookmark">
			Android 中的动态应用程序图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 中的动态应用程序图标 一、需求二、解决方案三、方案实现四、结论 一、需求 您可能遇到过那些可以实现巧妙技巧的应用程序 - 更改应用程序图标（也许是在您的生日那天），然后无缝切换回常规图标。这种功能会激起你的好奇心，让你想知道，他们到底是怎么做到的？好吧，你并不是唯一一个有好奇心的人。许多开发人员，包括我自己，都思考过这个问题。这似乎是看似不可能的任务之一，但你猜怎么着？它不是！在本文中，我们将揭开运行时更改 Android 应用程序图标背后的谜团。我们将一步步为您分解，并向您展示它不仅可行，而且非常易于管理。
二、解决方案 首先，应用程序图标是从清单文件设置的，就像任何其他应用程序组件一样。Android系统读取manifest文件并相应地设置应用程序图标。目前无法在运行时更改应用程序图标。但有一个解决方法。也就是使用一个activity-alias（如果你对activity-alias不熟悉，可以查看这里的官方文档）。
三、方案实现 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;application ... android:icon="YOUR_ICON" android:roundIcon="YOUR_ICON"&gt; &lt;activity ... android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity-alias ... android:icon="YOUR_ICON_2" android:roundIcon="YOUR_ICON_2" android:targetActivity=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity-alias&gt; &lt;/application&gt; &lt;/manifest&gt; 如您所见，我们有两项活动。一个是主要活动，另一个是活动别名。默认情况下禁用活动别名。它的图标与主要活动不同。因此，当安装应用程序时，将设置主要活动的图标。activity-alias当我们启用活动别名时，将设置活动的图标。因此，我们可以通过启用和禁用活动别名来在运行时更改应用程序图标。现在让我们看看如何在运行时启用和禁用活动别名。我们可以通过使用PackageManager类来做到这一点。
fun Activity.changeIcon() { packageManager.setComponentEnabledSetting( ComponentName( this, "$packageName.MainActivityAlias" ), PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP ) packageManager.setComponentEnabledSetting( ComponentName( this, "$packageName.MainActivity" ), PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP ) } 正如您所看到的，我们正在使用PackageManager类的setComponentEnabledSetting方法。我们正在传递活动别名和主要活动的组件名称。我们将活动别名设置为启用，将主要活动设置为禁用。因此，当我们调用此方法时，活动别名将被启用，而主活动将被禁用。所以应用程序图标将会改变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f91de8a4e89b455c75e6470afb7b9d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b0be0d87a05596f8a730df1473f999f/" rel="bookmark">
			Apache Paimon 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从 Flink Table Store 演进而来
Flink table store 架构如下图：
（和今天 Paimon 的架构相比，Log System 不再被推荐使用，Lake Store 的能力大幅强于 Log System，除了延时）
2021 年 9 月，发布了 0.2 版本，陆续有在生产使用。
Flink Table Store 是一个数据湖存储，用于实时流式 Changelog 写入 (比如来自 Flink CDC 的数据) 和高性能查询。它创新性的结合湖存储和 LSM 结构，深度对接 Flink，提供实时更新的系统设计，支撑大吞吐量的更新数据摄取，同时提供良好的查询性能。
0.3 形成了一个 Streaming Lakehouse 的基本雏形，我们可以比较自信的说出，0.3 可以推荐生产可用了。
基于 Flink Table Store 不仅可以支持数据实时入湖，而且支持 Partial Update 等功能，帮助用户更灵活的在延迟和成本之间做均衡。
Apache Paimon 在发布了三个版本后，虽然 Flink Table Store 具备了一定的成熟度，但作为 Flink 社区的一个子项目，在生态发展（比如 Spark 用户选择和使用）方面存在比较明显的局限性。为了让 Flink Table Store 能够有更大的发展空间和生态体系， Flink PMC 经过讨论决定将其捐赠 ASF 进行独立孵化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b0be0d87a05596f8a730df1473f999f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ec7be9531a8474258f49ff45fc0d8cd/" rel="bookmark">
			单调栈第二天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
503.下一个更大元素II
看到题目的第一想法
看到代码随想录的想法
自己实现时出现的困难
42. 接雨水
看到题目的第一想法
看到代码随想录的第一想法
自己实现时遇到的困难
503.下一个更大元素II 力扣题目链接(opens new window)
给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。
示例 1:
输入: [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 看到题目的第一想法 利用昨天的单调栈的思路来写
但是它是循环数组该怎么解决？
遍历完一次后再遍历一次，将栈中剩余的弹出
最后剩余的赋值为-1
成功做出来
看到代码随想录的想法 没有我这么麻烦，for循环范围放大为2*length，nums[i%length]取模，逻辑和之前相同
若当前比栈里的小则直接存入
若当前比栈里的大，则弹出，栈顶下标对应的第一个最大值为栈里的值
自己实现时出现的困难 把result全部赋值为-1 自己就不用处理-1了
class Solution { public int[] nextGreaterElements(int[] nums) { //也是用单调栈来写？ //for循环两次到末尾 Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); //需要遍历到当前下标的前一个位置？ stack.push(0); int[] result = new int[nums.length]; for(int i=1;i&lt;nums.length;i++){ if(nums[stack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ec7be9531a8474258f49ff45fc0d8cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43fe7edd9c9dbfb7ae796f41667c8a1c/" rel="bookmark">
			VUE3安装vite-plugin-vue-setup-extend 直接script写name
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以script直接写name
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d81e1375e891898d8f271ef3e609a0d/" rel="bookmark">
			dockerfile报错：failed to solve: process
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		failed to solve: process “/bin/sh -c apt-get update &amp;&amp; apt-get install -y libcurl4-openssl-dev libssl-dev supervisor unzip zlib1g-dev --no-install-recommends &amp;&amp; docker-php-ext-install pdo_mysql &amp;&amp; pecl channel-update pecl.php.net &amp;&amp; pecl install --configureoptions ‘enable-redis-igbinary=“no” enable-redis-lzf=“no” enable-redis-zstd=“no”’ redis-5.3.7 &amp;&amp; docker-php-ext-enable redis &amp;&amp; install-swoole.sh 4.8.13 --enable-http2 --enable-mysqlnd --enable-openssl --enable-sockets --enable-swoole-curl --enable-swoole-json” did not complete successfully: exit code: 100
替换ubuntu源
# RUN sed -i "s/archive.ubuntu.com/mirrors.aliyun.com/g" /etc/apt/sources.list; # RUN sed -i "s/deb.debian.org/mirrors.aliyun.com/g" /etc/apt/sources.list; # RUN sed -i "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d81e1375e891898d8f271ef3e609a0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66139d50526ecd28bdbe71e52fb0d980/" rel="bookmark">
			C&#43;&#43; 数论相关题目 求组合数IV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入 a,b
，求 Cba
的值。
注意结果可能很大，需要使用高精度计算。
输入格式
共一行，包含两个整数 a
和 b
。
输出格式
共一行，输出 Cba
的值。
数据范围
1≤b≤a≤5000
输入样例：
5 3
输出样例：
10
#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 5010; int primes[N], cnt; int sum[N]; bool st[N]; void get_primes(int a) //模版，求质数 { for(int i = 2; i &lt;= a; i ++ ) { if(!st[i]) primes[cnt ++ ] = i; for(int j = 0; primes[j] &lt;= a / i; j ++ ) { st[primes[j] * i] = true; if(i % primes[j] == 0) break; } } } int get(int a, int p) //辅助函数，求a！的p的次数 { int res = 0; while(a) { res += a / p; //通过不断地将a除以质数 p，将商再除以p //以此类推，累加每一步的商，即可得到a!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66139d50526ecd28bdbe71e52fb0d980/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0194b9ed4190f3bbb6d3807ae77f672a/" rel="bookmark">
			[GN] 设计模式——面向对象设计原则概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 面向对象设计原则概述单一职责原则开闭原则里氏代换原则依赖倒转原则接口隔离原则合成复用原则迪米特法则 总结 提示：以下是本篇文章正文内容，下面案例可供参考
面向对象设计原则概述 单一职责原则 一个类只负责一个功能领域中的相应职责
类承担的职责越多，它被复用的可能性就越小
而且一个类承担的职责过多，就相当于将这些职责耦合在一起
开闭原则 一个软件实体应当对扩展开放，对修改关闭。即实体应尽量在不修改原有代码的情况下进行扩展。 里氏代换原则 所有引用基类(父类）的地方必须能透明地使用其子类的对象。 运用里氏代换原则时
应该将父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法。程序运行时，子类实例替换父类实例，可以很方便地扩展系统的功能，无须修改原有子类的代码增加新的功能可以通过增加一个新的子类来实现。 依赖倒转原则 要针对接口编程，而不是针对实现编程。
在实现依赖倒转原则时
需要针对抽象层编程具体类的对象通过依赖注入的方式 注入其他对象 其中接口注入是指通过实现在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。
例：
CustomerDAO 内调用TXT 和 Excel。需要手动更改代码
引入抽象层 只需要在CustomerDAO调用抽象类 并在配置文件xml定义调用TXT还是Excel
接口隔离原则 使用多个专门的接扣，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
即明确角色的业务 该接口方法仅服务该角色，不可多不必要的方法。
合成复用原则 尽量使用对象组合,而不是继承来达到复用的目的。
复用已有的设计
首先应该考虑使用组合 / 聚合，组合 / 聚合可以使系统更加灵活，降低类与类之间的耦合度其次才考虑继承，在使用谜承时，需要严格遵循里氏代换原则，滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 因为继承时候，基类会暴露在子类下。
如上 CustomerDAO 继承了 DBUtil.
现需要更换数据库连接方式为 Oracle数据库
这样需要修改CustomerDAO 或者 DBUtil 违反了开闭原则
如上CustomerDAO 与 DBUtil是关联关系
采用依赖注入方式将DBUtil注入CustomerDAO
Oracle采用继承扩展DBUtil类。 根据里氏替换原则 DBUtil子类对象可以覆盖DBUtil对象
迪米特法则 软件实体应当尽可能少地与其他实体发生相互作用。 总结 本篇知识设计模式开篇基础知识。后面将会补充我学习过程中的设计模式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f930e14e3dd2788358bf560150d420c1/" rel="bookmark">
			Top100 数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.53. 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：
输入：nums = [1] 输出：1 示例 3：
输入：nums = [5,4,-1,7,8] 输出：23 提示：
1 &lt;= nums.length &lt;= 10^5-10^4 &lt;= nums[i] &lt;= 10^4 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
思路： 1)按照前缀和，进行遍历，代码如下，超时，不可以了，而且时间复杂度有点高，需要优化！
2)
代码： class Solution(object): def maxSubArray(self, nums): sum_s=[nums[0]] max_s=nums[0] for i in range(1,len(nums)): sum_s.append(sum_s[i-1]+nums[i])#前缀和 max_s=max(max_s,sum_s[i-1]+nums[i]) for j in range(0,i): max_s=max(sum_s[i]-sum_s[j],max_s) return max_s 超时！没必要保存，也没必要内存循环去计算，因为只需要求值，改进如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f930e14e3dd2788358bf560150d420c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aabf107a642def7923106171dcdcfcbb/" rel="bookmark">
			力扣（leetcode）第118题杨辉三角（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		118.杨辉三角 题目链接：118.杨辉三角
给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
示例 1:
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
示例 2:
输入: numRows = 1
输出: [[1]]
提示:
1 &lt;= numRows &lt;= 30
解答 class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: if numRows == 0: return [] res = [[1]] while len(res) &lt; numRows: newRow = [a+b for a, b in zip([0]+res[-1], res[-1]+[0])] res.append(newRow) return res 最后，我写了一篇MySQL教程，里面详细的介绍了MySQL的基本概念以及操作指令等内容，欢迎阅读！
MySQL数据库万字保姆级教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192e1e2ce47f90d2efc5e373826ad35d/" rel="bookmark">
			【论文阅读|半监督小苹果检测方法S3AD】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文题目 ： : Semi-supervised Small Apple Detection in Orchard Environments
项目链接：https://www.inf.uni-hamburg.de/en/inst/ab/cv/people/wilms/mad.html
摘要（Abstract） 农作物检测是自动估产或水果采摘等精准农业应用不可或缺的一部分。然而，由于缺乏大规模数据集以及图像中农作物的相对尺寸较小，农作物检测（如果园环境中的苹果检测）仍面临挑战。在这项工作中，以半监督的方式重新制定了苹果检测任务，从而应对了这些挑战。为此，提供了大型高分辨率数据集 MAD，其中包括 105 张标注了苹果实例的图像和 4440 张未标注的图像。利用该数据集，还提出了一种基于上下文关注和选择性窗口的新型半监督小苹果检测方法 ，以提高小苹果检测的挑战性，同时限制计算开销。在 MAD 和 MSU 数据集上进行了全面的评估，结果表明 的性能大大优于强大的全监督基线方法，包括几个小物体检测方法，最高可达 14.9%。此外，利用数据集关于苹果特性的详细注释，分析了相对大小或闭塞程度对各种方法结果的影响，量化了当前面临的挑战。
1 引言（Introduction） 收获前产量估算是农业有效规划作物收获、销售、运输和储存的重要组成部分[1,7,34,38]。产量估计通常依赖于劳动密集型的人工在样本位置进行计数[1,7,34,38]，以及天气信息和历史数据[1,7,38]。然而，由于果实负荷、土壤、光照等因素的自然差异，这样的估计是不准确的[12,34]。最近，精准农业受到了极大的关注，出现了基于视觉的自动产量估计方法[1,7]、质量控制方法[37]或水果采摘方法[9]。 开发此类方法的一项重要任务是可靠地检测作物[8]。尽管最近取得了一些进展[1,7,8,34,37]，但这项任务仍然具有挑战性。例如，果园中苹果的检测仍然很困难，原因是多种因素造成的复杂环境:(1)苹果分布密集，(2)其他作物或树叶造成的遮挡和阴影，(3)苹果与树木相比体积较小。这些影响也可以从图1中的例子中看到，图1描绘了果园环境中的一棵典型的苹果树。尤其具有挑战性的是小苹果大小，因为物体检测器的性能在小物体上显著下降[4]，这是由于cnn固有的下采样和有限的GPU资源阻碍了整个高分辨率图像的处理。此外，有限的数据可用性[3,8]是苹果检测的另一个挑战。
为了解决上述挑战，在一般目标检测中提出了几种方法。为了处理有限的数据量，采用迁移学习（transfer learning）[35]利用在任务中学习到的特征，而标注的工作量更少。此外，还提出了半监督方法，通过一致性[10,36]和伪标签方法[33,41]将无标签的数据纳入目标检测。为了改进具有挑战性的小目标检测，研究人员探索了几个方向[5]，包括多尺度特征提取[18,19,32,42]，通过学习特定尺度的特征来改善小目标的特征表示，基于注意力的方法[20,44,45]旨在选择网络中的相关区域或特征，而窗口策略(tiling strategies)[25,39,43]则在输入层面上提高目标的相对大小。
在本文中，作者通过以半监督的方式重新制定问题来解决果园环境中苹果的挑战性检测。为了解决这个问题，提出了一种新的半监督小苹果检测方法 和一个新的用于半监督学习的大规模苹果检测数据集MAD。MAD由来自苹果园的4545张高分辨率图像组成，105张图像中有14667个手动标注的苹果，其余的图像支持半监督学习。为了以半监督的方式解决苹果检测问题，并改进小苹果的挑战性检测，提出了 。它由三个主要模块组成:(i)用半监督伪标签框架Soft Teacher[41]训练的目标检测器，允许利用数据集中大量无标签的数据，(ii)利用苹果和树冠之间的上下文关系来定位感兴趣区域的TreeAttention模块，以及(iii)从感兴趣区域中裁剪窗口的选择性窗口(selective tiling)模块，使目标检测器能够利用完整图像的分辨率，提高对小苹果的检测性能。在对两个数据集的全面评估中，利用上下文注意和选择性窗口，在小苹果和所有尺寸的苹果上显示了 的强大结果。
综上所述，本文的贡献有三个方面:
•将苹果检测重新制定为一个半监督任务，限制了标注工作量，并发布了一个数据集MAD，其中包含105个有标签的和4,440个无标签的高分辨率图像，其中有14,667个手动标注的苹果，这有助于新的表达方法。
•提出了一种新的苹果检测方法 ，它利用半监督学习、上下文注意力和选择性窗口来解决有限数量的有标签数据和小苹果大小。
•通过在MAD和MSU数据集上对 进行全面评估来验证，将其与强大的全监督小物体检测方法进行比较，并评估三个苹果属性的影响。
2 相关工作（Related Work） 本节简要回顾农作物检测、农作物检测数据集和小目标检测的相关工作。
农作物检测（Crop Detection） 在精准农业中，农作物的检测主要是基于标准目标检测器的变化。例如，文献[14]修改了YOLOv3来检测番茄，而文献[46]采用了SSD。文献[22]利用更快的R-CNN，并增加图像拼接和窗口窗口步骤来处理成排的植物。对于芒果的检测，文献[12]修改了YOLOv2，文献[29]提出了修改后的YOLOv4。
对于苹果检测，文献[3]和文献[6]分别采用了带有标准窗口（standard tiling）和闭塞感知检测模块的Faster R-CNN。转向YOLO，文献[37]提出了带有DenseNet主干的YOLOv3变种，以检测不同生长阶段的苹果。在文献[13]中，YOLOv3的性能通过预处理和后处理步骤得到增强。最近，文献[11]的作者使用非局部特征级注意力增强了YOLOv4，并使用卷积块注意力模块来检测低分辨率图像中的苹果。
相比之下，作者以半监督的方式解决苹果检测问题，并通过引入上下文注意和选择性窗口（selective tiling）来专注于检测小苹果。
**农作物检测数据集（Crop Detection Datasets） ** 农作物检测数据集适用于各种农作物[21]。然而，大多数农作物检测数据集在大小上是有限的。根据文献[8]，最大的苹果检测数据集包含1404个有标签的图像[34]，在低分辨率图像上有7065个标注实例。文献[3]也适用于苹果检测数据集，包含841张图像和5,765个标注实例。MiniApple数据集[8]包含更多的标注实例，在1001张中等分辨率(1280 × 720)的图像中有41325个标注实例。最近，MSU苹果数据集V2[6]被提出，该数据集包含900张苹果树冠特写图像中的14,518个带注释的苹果。
与这些数据集相比，作者提出的数据集MAD非常适合于包含有标签和无标签图像的半监督苹果检测。此外，该数据集比现有的数据集更大，有4545张高分辨率图像。
小目标检测（Small Object Detection） 小目标检测问题已经用不同的策略解决。参见文献[5]进行广泛的调查。一种主流的策略是使用多尺度或特定尺度的特征来改善小目标的表示。虽然文献[18]以自下而上和自上而下的方式学习特定尺度的特征，文献[19]重新组合这些特征以改进多尺度表示。文献[31]和文献[32]改进了目标检测器的训练策略，通过降低尺度内噪声，从特征金字塔转向图像金字塔。文献[23]通过由粗到细检测提高了该方法的效率。为提高特定尺度特征的表达能力，文献[17]调整不同尺度目标的感受野。最近，文献[42]采用了一种基于由粗到细查询的检测机制对连续更高分辨率的特征图进行检测。
除了改进特征表示外，一些工作还利用窗口(tiling)[25,39,43]或超分辨率[2,16,24]来提高特征的空间分辨率。另一种工作是利用注意力机制来突出小目标的特征或位置[20,44,45]。作者的苹果检测方法 与多尺度和窗口方法最为相关。然而，它被明确设计为在半监督框架中解决苹果的检测问题，例如，利用领域知识来学习上下文注意力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/192e1e2ce47f90d2efc5e373826ad35d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7bcfaa57cabc1556f080f4df561cb38/" rel="bookmark">
			element-ui el-table中根据按钮的多少来计算操作栏的宽度以及根据显示按钮的数量动态计算是否需要展示更多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为当前行的某些状态或者操作权限，每一行的操作按钮可能展示的数量不同。
所以我们需要找出当前table页,按钮最多的那一行row，并计算出这个row中操作栏的所需宽度，用这个宽度来设置最后一列操作栏的宽度
columnWidth.js
export default { data() { return { minWidth: 100 } }, watch: { minWidth() { this.setWidth() } }, methods: { setWidth() { if (this.headerData) { this.$set(this.headerData[this.headerData.length - 1], 'width', this.minWidth) } }, // 获取列表数据后，调用此方法 getTextWidth(ref) { const trArr = [] const operateTd = [] const buttonNumArr = [] let isContainMore = false // 是否含有'更多'按钮，因为‘更多’后面有个尖括号 this.$nextTick(() =&gt; { // 获取当前table的所有tr let tr = [] if (ref &amp;&amp; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7bcfaa57cabc1556f080f4df561cb38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac54e3cc191a7b0f9f4f89bf9a62c196/" rel="bookmark">
			微信小程序 全局变量键值对map对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信小程序中，键值对的map对象通常用于存储和操作键值对的集合。以下是一些常见的操作：
创建map对象
在JavaScript中，可以通过对象字面量语法或者使用new Map()来创建map对象
// 使用对象字面量 var map = { key1: 'value1', key2: 'value2' }; // 使用Map对象 var map = new Map([ ['key1', 'value1'], ['key2', 'value2'] ]); 添加键值对
可以使用set方法向map对象添加键值对。
var map = new Map(); map.set('key1', 'value1'); map.set('key2', 'value2'); 获取键值
可以使用get方法获取map对象中的值。
var value = map.get('key1'); // 'value1' 删除键值对
可以使用delete方法删除map对象中的键值对。
map.delete('key1'); // true 检查键是否存在
可以使用has方法检查map对象中是否存在某个键。
var exists = map.has('key1'); // true 获取所有键
可以使用keys方法获取map对象中所有的键。
for (var key of map.keys()) { console.log(key); } 获取所有值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac54e3cc191a7b0f9f4f89bf9a62c196/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a376a5a6a881df899168d2eae90d62/" rel="bookmark">
			王道_数据结构 1.1_1数据结构的基本概念&amp;1.1_2数据结构的三要素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.1_1数据结构的基本概念 &amp; 1.1_2数据结构的三要素 1.1_1 数据结构的基本概念一、数据二、数据元素、数据项1、数据元素、数据项概念2、三个实例（1）一个人的财富信息（2）海底捞一个顾客信息（3）微博一个账号信息 三、数据对象、数据结构四、数据类型、抽象数据类型（ADT） 1.1_2 数据结构的三要素一、逻辑结构（1）集合（2）线性结构（3）树形结构（4）图结构 二·、数据的运算三、物理结构（存储结构）（1）顺序存储（2）链式存储（3）索引存储（4）散列存储（哈希存储）（5）不同物理存储结构带来的影响 四、数据结构三要素总结 本节主要介绍数据结构的基本概念与三要素 笔记来源： B站 王道 数据结构 1.1_1 数据结构的基本概念 一、数据 数据是信息的载体，是描述客观事物属性的数、字符串所有能输入到计算机中并被计算机程序识别和处理的符号的集合。
二、数据元素、数据项 1、数据元素、数据项概念 数据元素：是数据的基本单位，通常作为一个整体进行考虑和处理一个数据元素可以由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位 2、三个实例 （1）一个人的财富信息 （2）海底捞一个顾客信息 （3）微博一个账号信息 三、数据对象、数据结构 数据对象：具有相同性质的数据元素的集合，是一个数据的子集
（如这个富豪的信息、那个富豪的信息；
微博这个账户的信息、那个账户的信息）
数据结构：相互之间存在一种或多种特定关系的数据元素的集合
线性数据结构、网状数据结构…
四、数据类型、抽象数据类型（ADT） 1.1_2 数据结构的三要素 一、逻辑结构 （1）集合 各个元素同属一个集合，别无其他关系
（2）线性结构 数据元素之间是一对一关系。除第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继
（3）树形结构 数据元素之间是一对多的关系。
eg：思维导图、文件存储结构
（4）图结构 数据元素之间是多对多的关系
eg：道路信息
二·、数据的运算 一、逻辑结构 和 二、数据的运算讲的是定义一个“数据结构”；
而如何用计算机实现这个“数据结构”，则看三、物理结构（存储结构）
三、物理结构（存储结构） 以线性结构为例：
（1）顺序存储 把逻辑上相邻的元素在物理位置上也相邻的存储单元中。
元素之间的关系由存储单元的邻接关系来体现。
（2）链式存储 逻辑上相邻的元素在物理位置上可以不相邻。
借助指示元素存储地址的指针来表示元素之间的逻辑关系。
（3）索引存储 在存储元素信息的同时、还建立附加的索引表。
索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）
（4）散列存储（哈希存储） （5）不同物理存储结构带来的影响 四、数据结构三要素总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4f94fcb4aae43a08fc1d1bb16e31c78/" rel="bookmark">
			(c语言版)滑动窗口 给定一个字符串，只包含字母和数字，按要求找出字符串中的最长（连续）子串的长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用情况：
①题目中出现最短，最长
②出现子串、子数组、子数列
给定一个字符串，只包含字母和数字，按要求找出字符串中的最长（连续）子串的长度，字符串本身是其最长的子串，子串要求：
1、 只包含1个字母(a~z, A~Z)，其余必须是数字；
2、 字母可以在子串中的任意位置；
如果找不到满足要求的子串，如果全是数字，则返回-1。
//套用模板 #include&lt;stdio.h&gt; #define MAXN 10000 int isNumber(char c) { return (c&gt;='0'&amp;&amp;c&lt;='9'); } int main(){ char str[MAXN]={0}; scanf("%s",str); char *left=str; char *right=str; int bestresult=0; int tag=0; while(*right!='\0'){ //只要右指针没有到字符串尾部 while(tag==1&amp;&amp;!isNumber(*right)&amp;&amp;left&lt;right){ //子串不满足要求时（有两个字母）,不满足时才缩小为求最长子串 left++; //一直向右移动直到子串满足条件 if(!isNumber(*(left-1))){ //左指针略过最左边字母后子串满足条件，跳出循环 break; } } tag= isNumber((*right))?tag:1; if(tag==1){ bestresult=bestresult&gt;(right-left+1)?bestresult:(right-left+1); } right++; } printf("%d",bestresult); return 0; } 滑动窗口的最长子串模板
初始化 left，right，result，bestResult while("右指针没有到结尾"){ 窗口扩大，加入right对应元素，更新当前result while("result不满足要求"){ 窗口缩小，移除left对应元素，left右移 } 更新最优结果bestResult right++; } 返回bestResult 滑动窗口的最短子串模板
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4f94fcb4aae43a08fc1d1bb16e31c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86b4ecd4d461924eac8a392450864031/" rel="bookmark">
			4核16G10M幻兽帕鲁服务器只需26元/月？！阿里云挑战全网最低价
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1月29日，阿里云又发大招！将原先4核16G3M的套餐直接升级至10M，价格从32元直降至26元！
目前已是全网幻兽帕鲁4-8人游玩配置的服务器性价比极高的套餐！
》》阿里云4核16G10M 26元/月
整理至1月29日，各家幻兽帕鲁适配的服务器价格，阿里云目前适配度极高，而且还提供一键部署功能，存档转移功能，小白也能轻松上手！
》》4-8人游玩云服务器 阿里云26元/月
4-8个玩家游玩　规格硬盘流量时长价格备注腾讯4核16G12M120GB2048GB流量1个月32　120GB2048GB流量3个月96　阿里4核16G10M100GB不限流量1个月26推荐100GB不限流量3个月79推荐华为4核16G3M40GB不限流量1个月32　40GB不限流量3个月96　
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d83c1ce9ec9e7e3feb9d2c33e7716d7/" rel="bookmark">
			网络安全（黑客）——2024自学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、自学网络安全学习的误区和陷阱 1.不要试图先以编程为基础的学习再开始学习 我在之前的回答中，我都一再强调不要以编程为基础再开始学习网络安全，一般来说，学习编程不但学习周期长，而且实际向安全过渡后可用到的关键知识并不多
一般人如果想要把编程学好再开始学习网络安全往往需要花费很长时间，容易半途而废。而且学习编程只是工具不是目的，我们的目标不是成为程序员。建议在学习网络安全的过程中，哪里不会补哪里，这样更有目的性且耗时更少
2.不要把深度学习作为入门第一课 很多人都是冲着要把网络安全学好学扎实来的，于是就很容易用力过猛，陷入一个误区：就是把所有的内容都要进行深度学习，但是把深度学习作为网络安全第一课不是个好主意。原因如下：
【1】深度学习的黑箱性更加明显，很容易学的囫囵吞枣
【2】深度学习对自身要求高，不适合自学，很容易走进死胡同
3.不要收集过多的资料 网上有很多关于网络安全的学习资料，动辄就有几个G的材料可以下载或者观看。而很多朋友都有“收集癖”，一下子购买十几本书，或者收藏几十个视频
网上的学习资料很多重复性都极高而且大多数的内容都还是几年前没有更新。在入门期间建议“小而精”的选择材料，下面我会推荐一些自认为对小白还不错的学习资源，耐心往下看
二、学习网络安全的一些前期准备 1.硬件选择 经常会问我“学习网络安全需要配置很高的电脑吗？”答案是否定的，黑客用的电脑,不需要什么高的配置,只要稳定就行.因为黑客所使用的一些程序,低端CPU也可以很好的运行,而且不占什么内存.还有一个,黑客是在DOS命令下对进行的,所以电脑能使用到最佳状态!所以，不要打着学习的名义重新购买机器...
2.软件选择 很多人会纠结学习黑客到底是用Linux还是Windows或者是Mac系统，Linux虽然看着很酷炫，但是对于新人入门并不友好。Windows系统一样可以用虚拟机装靶机来进行学习
至于编程语言，首推Python，因为其良好的拓展支持性。当然现在市面上很多网站都是PHP的开发的，所以选择PHP也是可以的。其他语言还包括C++、Java...
很多朋友会问是不是要学习所有的语言呢？答案是否定的！引用我上面的一句话：学习编程只是工具不是目的，我们的目标不是成为程序员
（这里额外提一句，学习编程虽然不能带你入门，但是却能决定你能在网络安全这条路上到底能走多远，所以推荐大家自学一些基础编程的知识）
3.语言能力 我们知道计算机最早是在西方发明出来的，很多名词或者代码都是英文的，甚至现有的一些教程最初也是英文原版翻译过来的，而且一个漏洞被发现到翻译成中文一般需要一个星期的时间，在这个时间差上漏洞可能都修补了。而且如果不理解一些专业名词，在与其他黑客交流技术或者经验时也会有障碍，所以需要一定量的英文和黑客专业名词（不需要特别精通，但是要能看懂基础的）
比如说：肉鸡、挂马、shell、WebShell等等
三、网络安全学习路线 第一阶段：基础操作入门，学习基础知识 入门的第一步是学习一些当下主流的安全工具课程并配套基础原理的书籍，一般来说这个过程在1个月左右比较合适。
在这个阶段，你已经对网络安全有了基本的了解。如果你学完了第一步，相信你已经在理论上明白了上面是sql注入，什么是xss攻击，对burp、msf、cs等安全工具也掌握了基础操作。这个时候最重要的就是开始打地基！
所谓的“打地基”其实就是系统化的学习计算机基础知识。而想要学习好网络安全，首先要具备5个基础知识模块：
1.操作系统
2.协议/网络
3.数据库
4.开发语言
5.常见漏洞原理
学习这些基础知识有什么用呢？ 计算机各领域的知识水平决定你渗透水平的上限。
【1】比如：你编程水平高，那你在代码审计的时候就会比别人强，写出的漏洞利用工具就会比别人的好用；
【2】比如：你数据库知识水平高，那你在进行SQL注入攻击的时候，你就可以写出更多更好的SQL注入语句，能绕过别人绕不过的WAF；
【3】比如：你网络水平高，那你在内网渗透的时候就可以比别人更容易了解目标的网络架构，拿到一张网络拓扑就能自己在哪个部位，拿到以一个路由器的配置文件，就知道人家做了哪些路由；
【4】再比如你操作系统玩的好，你提权就更加强，你的信息收集效率就会更加高，你就可以高效筛选出想要得到的信息
第二阶段：实战操作 1.挖SRC 挖SRC的目的主要是讲技能落在实处，学习网络安全最大的幻觉就是觉得自己什么都懂了，但是到了真的挖漏洞的时候却一筹莫展，而SRC是一个非常好的技能应用机会。
2.从技术分享帖（漏洞挖掘类型）学习 观看学习近十年所有0day挖掘的帖，然后搭建环境，去复现漏洞，去思考学习笔者的挖洞思维，培养自己的渗透思维​​​​​​
3.靶场练习 自己搭建靶场或者去免费的靶场网站练习，有条件的话可以去购买或者报靠谱的培训机构，一般就有配套的靶场练习
第三阶段：参加CTF比赛或者HVV行动 推荐：CTF比赛 CTF有三点： 【1】接近实战的机会。现在网络安全法很严格，不像之前大家能瞎搞
【2】题目紧跟技术前沿，而书籍很多落后了
【3】如果是大学生的话，以后对找工作也很有帮助
如果你想打CTF比赛，直接去看赛题，赛题看不懂，根据不懂的地方接着去看资料
推荐：HVV（护网） HVV有四点： 【1】也能极大的锻炼你，提高自身的技术，最好是参加每年举行的HVV行动
【2】能认识许多圈内的大佬，扩大你的人脉
【3】HVV的工资也很高，所以参加的话也能让你赚到不少钱
【4】和CTF比赛一样如果是大学生的话，以后对找工作也很有帮助
四、学习资料的推荐 书单推荐： 计算机操作系统： 【1】编码：隐藏在计算机软硬件背后的语言
【2】深入理解操作系统
【3】深入理解windows操作系统
【4】Linux内核与实现
编程开发类： 【1】 windows程序设计
【2】windwos核心变成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d83c1ce9ec9e7e3feb9d2c33e7716d7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/8/">«</a>
	<span class="pagination__item pagination__item--current">9/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/10/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>