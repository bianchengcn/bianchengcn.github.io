<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dcb8c2d80880743181e3274e07ba787/" rel="bookmark">
			【java】代码实现：二叉树的先序遍历、中序遍历、后序遍历、层序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、节点类二、创建对象三、先序遍历（递归）四、中序遍历（递归）五、后序遍历（递归）六、层序遍历（队列） 一、节点类 public class Node { public Node left = null; public Node right = null; public int i; public Node(int i) { this.i = i; } } 二、创建对象 public class NodeUtils { public static Node newNode(){ Node node = new Node(1); Node n2 = new Node(2); Node n3 = new Node(3); Node n4 = new Node(4); Node n5 = new Node(5); Node n6 = new Node(6); Node n7 = new Node(7); Node n8 = new Node(8); Node n9 = new Node(9); Node n10 = new Node(10); node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dcb8c2d80880743181e3274e07ba787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1784dd842288bb69cd295d7a469698a2/" rel="bookmark">
			【自用】vmware workstation建立主机window与虚拟机ubuntu之间的共享文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在windows中建立1个文件夹 在vmware中设置为共享文件夹
参考博文：
https://zhuanlan.zhihu.com/p/650638983
2.解决： （1）fuse: mountpoint is not empty
（2）普通用户也能使用共享目录
参考博文：
https://blog.csdn.net/zhanglingge/article/details/113916057
vmhgfs-fuse .host:/ /mnt/hgfs -o nonempty -o allow_other 3.设置ubuntu重启后自动挂载 参考博文：
https://blog.csdn.net/qq_45871852/article/details/123139862
（该博文的最后面讲的）
打开/etc/fstab：
sudo gedit /etc/fstab 在最后面添加代码：
.host:/share /mnt/hgfs fuse.vmhgfs-fuse allow_other 0 0 （我的共享文件夹名称是share，注意share后，/mnt前有一个空格。） 结果如下：
（ubuntu路径中看不到share文件夹了，直接是share内部的内容。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/861733b56c072f314634b71ae853ee6d/" rel="bookmark">
			ubunu 18.04 LTS安装Qt-5.14-2并一起安装Qt Creator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为初级qt用户，一定下载Qt的.run安装文件。
之前我安装5.15.10版本的源码，安装后一头雾水。
后来，我安装了低一点的版本5.14.2，它含有.run安装文件，比较顺利。
下面记录一下ubunu 18.04 LTS安装Qt-5.14-2并一起安装Qt Creator的过程。
一、下载qt的.run安装文件 https://download.qt.io/archive/qt/
qt-opensource-linux-x64-5.14.2.run
二、修改.run文件的属性，赋予它可执行权限 sudo chmod +x qt-opensource-linux-x64-5.14.2.run
三、执行.run文件 sudo ./qt-opensource-linux-x64-5.14.2.run
如果磁盘空间足够，建议全部选中，记得一定选择Qt Creator
最后，点击完成！
四、配置环境变量 默认安装，位置在/opt/下
我是设置用户环境变量：
gedit ~/.bashrc 添加后的内容：
# added by lyc export QTDIR=/opt/Qt5.14.2/5.14.2 export GCCARMDIR=/home/lyc/Exe/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf export PATH=$GCCARMDIR/bin:$QTDIR/gcc_64/bin:$PATH export LD_LIBRARY_PATH=$GCCARMDIR/lib:$QTDIR/gcc_64/lib:$LD_LIBRARY_PATH source ~/.bashrc 五、创建Qt Creator桌面快捷方式 下面的博文给出了三种方式：
https://codeleading.com/article/70904916121/
我采用了第2种方式，即：
通过文件夹系统进入/usr/share/applications/：
右键打开，界面会弹出错误：
打开qtcreator出现提示无法覆盖文件 /home/xxx/.config/Qtcreator/qtversion.xml : Permission denied
解决方法：https://blog.csdn.net/swandream/article/details/78382655
注意博文中的错误，丢了波浪线！
sudo chown -R lyc:lyc ~/.config/ 从左下角的桌面系统中可以看到qtcreator图标，但是没有logo图像。
右键发送到桌面，并右键为它添加logo
qt_logo.png在/opt/Qt5.14.2下可查询到，有多个选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb969e61d7b811b0b2b9143181b05dc/" rel="bookmark">
			js中函数的length属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前端面试题：函数的length长度了解 ` &lt;script&gt; // 函数的length属性 function a(a1, b2, c3) { }//length长度为形参的个数 console.log('函数a的length长度', a.length); function b(a1, b2 = 0, c3) { } // 当有默认值时，取默认值前的个数 console.log('函数b的length长度', b.length); function c(a1, b2, ...args) { } // 不统计剩余参数 console.log('函数c的length长度', c.length); &lt;/script&gt;` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd68c4afcdd8b1c0bfeb93810fbd258/" rel="bookmark">
			前端面试JS类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS类型转换 转化为false的值为 console.log(Boolean(0)); console.log(Boolean('')); console.log(Boolean(NaN)); console.log(Boolean(undefined)); console.log(Boolean(null)); 而像那些容易误导人的面试题目有
console.log(Boolean({})); console.log(Boolean([])); console.log(Boolean([0])); console.log(Boolean('0')); console.log(Boolean('false')); console.log(Boolean([0].toString())); 只要不是以下特殊值，其余的都是转化为真true。
0
‘’
null
undefined
NaN
当然如果你用布尔值 false 转布尔值的话那你是个狠人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bc62c5a11e1a6f11ef4a3396996ce5a/" rel="bookmark">
			动态表单生成Demo(Vue&#43;elment)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文将介绍如何使用vue和elment ui组件库实现一个简单的动态表单生成的Demo。主要涉及两个.vue文件的书写，一个是动态表单生成的组件文件，一个是使用该动态表单生成的组件。
1.动态表单生成组件 这里仅集成了输入框、选择框、日期框三种类型的表单项；
其他类型的表单元素，比如单选框、复选框等，也可以根据需要进行类似的处理。
可以动态计算每一行放置的表单数。
&lt;template&gt; &lt;div&gt; &lt;el-form :model="data" :rules="rules" :label-width="labelWidth" :disabled="formDisabled"&gt; &lt;el-row :gutter="10" style="display: flex; flex-wrap: wrap"&gt; &lt;template v-for="(field, index) in formFields"&gt; &lt;el-col :key="index" :span="calculateSpanSize(field)"&gt; &lt;el-form-item :prop="field.name" :label="field.label" :rules="field.rules" :require="field.require ? field.required() : false" v-bind="field.bind" &gt; &lt;el-input v-if="field.type === 'text'" :type="field.type" :id="field.name" :name="field.name" v-model="data[field.name]" :style="{ width: field.width || '100%' }" /&gt; &lt;el-select v-else-if="field.type === 'select'" :id="field.name" v-model="data[field.name]" :style="{ width: field.width || '100%' }" &gt; &lt;el-option v-for="(option, optionIndex) in field.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bc62c5a11e1a6f11ef4a3396996ce5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e386d34ca3bda93abde42193df67aa0/" rel="bookmark">
			SES_NRF_STARTUPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/***************************************************************************** * SEGGER Microcontroller GmbH &amp; Co. KG * * Solutions for real time microcontroller applications * ***************************************************************************** * * * (c) 2017 SEGGER Microcontroller GmbH &amp; Co. KG * * * * Internet: www.segger.com Support: support@segger.com * * * *****************************************************************************/ /***************************************************************************** * Preprocessor Definitions * * ------------------------ * * NO_FPU_ENABLE * * * * If defined, FPU will not be enabled. * * * * NO_STACK_INIT * * * * If defined, the stack pointer will not be initialised.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e386d34ca3bda93abde42193df67aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d119447b2d79cbd4fba03ce8c6db79b/" rel="bookmark">
			Java-对String进行排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意： 在Java中，String是一个不可变的类，不能直接对String进行排序。但是，可以将多个String对象构成一个数组或List集合，然后对数组或集合进行排序。
1.字符串-&gt;数组-&gt;字符串 char[] chars=oldString.toCharArray(); Arrays.sort(chars); String newString=new String(chars); 2.字符串-&gt;集合-&gt;字符串 要将一个String对象转换为List，然后对其进行排序，并最终将排序后的列表组成一个新的字符串，可以按照以下步骤进行：
将String对象转换为字符数组，可以使用String的toCharArray()方法。使用Arrays.asList()方法将字符数组转换为List。使用Collections.sort()方法对List进行排序。使用StringBuilder或StringBuffer来构建新的字符串，遍历排序后的List，并将每个元素添加到字符串中。最后，使用toString()方法获取最终的字符串。 示例代码如下：
String str = "example"; char[] charArray = str.toCharArray(); List&lt;Character&gt; charList = new ArrayList&lt;&gt;(Arrays.asList(charArray)); // 转换为List Collections.sort(charList); // 排序 StringBuilder sb = new StringBuilder(); for (Character ch : charList) { sb.append(ch); } String sortedStr = sb.toString(); System.out.println(sortedStr); 上述代码会输出排好序的字符串，例如：“aeelmpx”。请注意，使用StringBuilder来构建字符串比直接拼接字符串更高效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da9cb2c84ddbc987cf17b9a373f63a4/" rel="bookmark">
			Windows PC实时操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言：实时系统是如何与Windows一起工作的呢？ 任何熟悉实时概念的人都知道，如今当今众多IT领域它有多么重要。无论是在机械臂中并行运行的伺服电机，精确的测量应用，还是基于摄像机的辅助驾驶系统——在许多现代电子技术中，硬件和软件部件之间的反应时间都是一个至关重要的因素。以前通过特殊的独立实时操作系统（RTOS）或硬件（DSP和FPGA）实现的功能，现在也可以通过使用普通的Windows PC来实现。当然，现在的Windows它本身并不是一个实时系。因为它会任意的从运行的应用程序中转移资源来执行其他进程和任务，例如：用于维护。那么如何才能将这些对立的东西组合在一起呢？实时系统是如何与Windows一起工作的呢？ 一、实时和Windows——解决方案 Windows PC上实时的唯一要求是具有至少两个内核的处理器。基本操作原则是使Windows仅使用多核处理器的有限数量的CPU内核。在空闲的核心上启动了实时系统，从现在开始，它们的功能就像一个单独的RTOS，而Windows保留了其在剩余的CPU内核上全部的可操作性。这意味着，从现在开始，Windows和实时系统可以在同一台计算机上同时并行运行，彼此不受任何限制。通过使用配置程序msconfig，可以相对简单地执行Windows在有限数量的内核上引导的指令。可在此处找到相关指南： 设置专用CPU. 由于执行这个过程，实时系统获得了受保护区域。确保Windows进程不会在时序严格的操作上获得更高的优先级，从而防止了Windows对实时性能产生负面影响。最终目标是在Windows PC上实现特定的“硬”实时功能。但是在这种情况下，“硬”到底意味着什么呢？
二、“软”和“硬”实时有什么区别？ 当涉及到实时的问题时，我们需要区分不同的需求以及如何处理执行流程的时间框架。 “软”实时只接近反应时间的平均值，“硬”实时则是需要保证不超过设定的时间。由于这些更高的要求，实现“硬”实时功能变得更加复杂和具有挑战性。然而，这种确定性的时间行为在自动化工业领域是不可缺少的，特别是在测量、测试和控制技术方面。
三、如何将Windows环境和实时环境组合在一起呢？ 实时系统是作为设备驱动程序实现的，并提供了自己的API，允许用户将Windows应用程序的时间关键代码部分导出到一个DLL中。然后将这个DLL加载到RTOS的实时上下文中。为了让Windows和DLL能够在不同的上下文中彼此通信——除了使用管道或套接字之类的间接方法之外——还可以创建一个共享内存区域，它们都可以访问。尽管使用了实时操作系统，但Windows仍然作为编程接口和主机系统来执行。
四、为什么特别地使用Windows作为RTOS？ 比于纯粹的实时操作系统以及实时硬件的解决方案，在Windows PC上具有明显优势。Windows本身是一个熟悉的用户界面，具有广泛的驱动程序支持，经常更新，以及各种可执行程序。另一方面，纯RTOS是非常专业的，因此在功能范围或可操作性方面通常会受到更多限制。FPGA和DSP等硬件解决方案可根据不同规格进行调整。但是，他们的编程很复杂且耗时。而要在Windows下实现“硬”实时工作，只需要一台双核PC。
五、结论 由于以下特性，Windows最适合工业应用：
广泛，直观和熟悉的用户界面
访问最新的通信接口
高效的开发者工具
实施和培训成本低
持久由于较高的市场占有率和持续的进一步发展
Windows缺少的实时功能得到了Kithara实时套件等实时系统的补充，因此可以首先实现时序要求严格的应用程序，原因如下：
确定性的行为得益于高频实时计时器
极低的最大响应时间
熟悉的编程语言和工具
高效且易于应用的功能
培训时间短，开发成本低
广泛支持工业协议和标准
官网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8bd38c11a7a9895edaa6de17ef1d7b1/" rel="bookmark">
			基于Echarts&#43;Vue3的低代码可视化数据大屏拖拽设计器 vue拖拽设计大屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品概述 本产品是一款基于Vue3开发的可视化数据大屏拖拽设计器。提供一种简单易用的拖拽式数据可视化大屏设计方案，可帮助用户快速创建和定制自己的数据大屏，通过拖拽组件、调整布局和设置属性，实现数据展示的自由组合和个性化定制。
功能特点 可视化编辑：通过拖拽组件、调整布局和设置属性，实现数据展示的自由组合和个性化定制。多种组件：提供多种数据展示组件，如Echarts各类图表、表格、文本框、图片、轮播图表格、常见小组件等。灵活布局：绝对布局，支持px、%、vh/vw等单位布局。数据绑定：支持与后台数据接口对接，实现数据的动态展示和更新。编辑器页面基本功能，包括编辑、预览、导出、保存、生成json脚本图层功能：显示、隐藏、复制、锁定组件功能：缩放、旋转、拖动、复制、组合、拆分、对齐方式、删除、位置定位、支持键盘调整定位预览功能：用户可以实时预览大屏的效果，以便调整和优化设计。导出功能：用户可以将设计好的大屏导出为 Vue文件或保存于服务端。 技术 Vite+Vue3+Echarts
页面展示 演示地址 点击这里查看示例
github源码 github源码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f047490884ca2a24da357be2a26cf4e/" rel="bookmark">
			win11 右键菜单默认 显示更多选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10升级至win11后，一个很大的变化就是右键菜单，其不再显示所有的菜单项，而是默认只显示主要的几项，点击“显示更多选项”后，才会显示所有菜单项。
这对于经常需要用到右键其他菜单项的人来说明，非常的不方便，所以我们可以将其设置成，默认就显示所有菜单项，操作方法如下：
1. 以管理员身份打开CMD窗口
2. 执行菜单设置命令
reg.exe add "HKCU\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32" /f /ve 3. 重启资源管理器，使其生效
taskkill /f /im explorer.exe &amp; start explorer.exe 文章参考自：win11右键默认显示更多选项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5308019a9e0d3106fb2543ce9e26c024/" rel="bookmark">
			威胁建模的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.什么是威胁建模？ 四个维度理解
1.动词，威胁建模，强调了分析和发现产品自身缺陷的执行过程
2.名称，威胁建模，是一个已经固化的发现风险的框架体系，当我们的产品通过结合这个框架去执行时，能够发现潜在的风险
3.威胁建模师一种通过理想化攻击者发起一些列攻击行为，从中发现更多深入的安全风险
4.威胁建模有时是一种比较抽象的概述，例如篡改的风险，在应对不同的产品会做出不同的调整和变化
2.为什么要进行威胁建模？ 1.尽早发现风险
2.更好的理解安全需求
3.降低重新设计、重构或者面临不断安全漏洞可能性
4.弥补自动化安全扫描工具无法识别的风险
3.威胁建模框架需要思考的问题 1.正在开发的是什么产品？（产品架构？每一个环节如何实现？）
2.假想当产品按照预想开发完成时，每个架构、环境还有可能会出现什么安全风险？
注：六个威胁大类，欺骗，篡改，否认，信息泄露，拒接服务，越权
3.面对这些安全风险，我们应该分析如何处理？
4.处理威胁时的四个状态（消除威胁，减轻威胁，转移威胁，接受风险）
5.讲解验证回归，确保思路清晰
完整的四个阶段
构建产品框架---识别威胁----应对威胁------验证
4.威胁建模的特点？ 1.威胁建模的多样性
2.最好的威胁建模离不开产品线本身
3.威胁建模是版本控制的固有流程
4.威胁建模是一个强调实践的过程
5.学习需要技巧（需要具备开发的技术和查看一系列的威胁示例）
6.需要像一个攻击者思考危害性
威胁建模的步骤包括： 威胁识别:收集安全信息和事件响应数据，识别潜在的威胁。
威胁评估:对识别的威胁进行评估，确定其潜在影响和可能性。
威胁缓解:制定缓解威胁的策略，包括加强安全措施、升级软件、修复漏洞等。
威胁响应:在发生安全事件时，及时采取响应措施来减轻威胁的影响。
模型验证:验证威胁建模的过程和结果是否准确可靠。
模型更新:随着时间的推移，威胁可能会发生变化，因此需要定期更新威胁建模的模型。
威胁建模的步骤可以重复执行，以便不断更新和优化模型，提高网络安全性。
威胁建模的好处： 提高安全性：更早地发现系统的脆弱点和潜在的风险，及时采取措施避免安全事件的发生，提高系统的安全性。控制风险：有效地控制风险，降低安全事件对企业的影响。教育员工：作为企业内部培训的一部分，通过定期进行威胁建模，可以让员工了解到安全的重要性，提高他们的安全意识和技能。优化资源配置：明确地了解不同环节存在的风险和漏洞，从而合理分配资源，针对性地进行防护和修复。符合法规要求：很多国家和地区都有相关的网络安全法规，威胁建模可以帮助企业更好地符合这些法规的要求，降低违规的风险。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd95e0546dac62d88bd6b52467f961d/" rel="bookmark">
			入门级自动化(WebUi自动化)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于webui自动化适用场景
回归测试：当新增了功能或修复了bug后，需要对整个软件进行全面的测试。手动测试过于耗时跨浏览器测试：在不同的浏览器中进行测试通常是耗时且繁琐的任务。一次编写的脚本可以在多个不同浏览器中执行（依赖于webdriver）长期存在的项目：如果是短期内使用，就不需要做UI自动化。功能稳定的项目：如果是某个特定做的功能，一次性使用的功能，就不需要做UI自动化 误区
ui自动化不适用大部分测试，当前人力成本和维护成本很高，简单说不是什么项目都能玩的起的，更多的人会选择接口自动化
如何从0做ui自动化？
先说一下思路
1.明确做自动化的目标
2.找到关键的手工案例，然后把手工案例实现为自动化案例
3.确定实现的框架是什么，比如pytest+selenium，Framework+selenium
4.实现案例，需要考虑实现的案例是否能发现bug，是否保证了产品核心价值
5.跟随版本迭代，根据在自动化过程中发现、未发现的bug进行维护和优化
大致了解以后开始学习
学习路径
1.python基本语法，基本能看懂代码就行
2.python中request库使用，能发送各种请求即可
3.python中selenium库使用，能完成定位，复杂情况定位可以碰到再去研究
4.python中pytest测试框架使用，能完成用例执行，装饰器使用，前后置条件的执行
5.整体框架搭建，学习github上的开源项目，目录分层，实现3-10个demo执行
6.更新和维护
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b8032302cc983719fb7d7dab78bdfe/" rel="bookmark">
			【运筹优化】带时间窗约束的车辆路径规划问题（VRPTW）详解 &#43; Python 调用 Gurobi 建模求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概述1.1 VRP 问题1.2 CVRP 问题1.3 VRPTW 问题 二、VRPTW 的一般模型三、Python 调用 Gurobi 建模求解3.1 Solomn 数据集3.2 完整代码3.3 运行结果展示3.3.1 测试案例：c101.txt3.3.2 测试案例：r101.txt 一、概述 1.1 VRP 问题 车辆路径规划问题(Vehicle Routing Problem，VRP)一般指的是：对一系列发货点和收货点，组织调用一定的车辆，安排适当的行车路线，使车辆有序地通过它们，在满足指定的约束条件下（例如：货物的需求量与发货量，交发货时间，车辆容量限制，行驶里程限制，行驶时间限制等），力争实现一定的目标（如车辆空驶总里程最短，运输总费用最低，车辆按一定时间到达，使用的车辆数最小等）。
下图给出了一个简单的VRP的例子
1.2 CVRP 问题 最基本的VRP问题叫做带容量约束的车辆路径规划问题（Capacitated Vehicle Routing Problem，CVRP）。在CVRP中，需要考虑每辆车的容量约束、车辆的路径约束和装载量约束
1.3 VRPTW 问题 为了考虑配送时间要求，带时间窗的车辆路径规划问题（Vehicle Routing Problem with Time Window，VRPTW）应运而生。
VRPTW 不仅考虑CVRP的所有约束，还需要考虑时间窗约束，也就是每个顾客对应一个时间窗 [ e i , l i ] [e_i,l_i] [ei​,li​]，其中 e i e_i ei​ 和 l i l_i li​ 分别代表该点的最早到达时间和最晚到达时间。顾客点 i ∈ V i \in V i∈V 的需求必须要在其时间窗内被送达
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2b8032302cc983719fb7d7dab78bdfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/531b45d8b36066d4df271e0d47d066a6/" rel="bookmark">
			用foreach求数组之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用foreach循环来计算数组中元素的和时，你可以遵循以下更详细的步骤：
创建数组：首先，创建一个包含要计算和的元素的数组。这些元素可以是整数、浮点数或其他数值类型。
$numbers = [1, 2, 3, 4, 5];
初始化和变量：创建一个变量，用于存储计算后的和，并将其初始化为0。
$sum = 0;
使用foreach循环：使用foreach循环遍历数组中的每个元素。foreach循环语法通常如下：
foreach ($array as $element) {
// 在循环体内执行操作
}
在这里，$array 是你的数组，$element 是当前循环迭代中的数组元素。
foreach ($numbers as $number) {
// 在这里将每个元素加到和上
}
累加元素：在foreach循环的循环体内，将当前元素（$number）添加到和变量（$sum）中。这会不断累积和。
foreach ($numbers as $number) {
$sum += $number;
}
打印结果：最后，你可以打印计算出的和。
echo "数组的和为: " . $sum;
完整的PHP代码示例：
&lt;?php
// 创建一个包含整数的数组
$numbers = [1, 2, 3, 4, 5];
// 初始化一个变量来存储和
$sum = 0;
// 使用foreach循环遍历数组，并将每个元素加到$sum中
foreach ($numbers as $number) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/531b45d8b36066d4df271e0d47d066a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c56bbb0f470e08ee687724f92b079f0/" rel="bookmark">
			​在IDEA中​如何快速输入System.out.println()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先输入sout，然后按下Enter即可输出System.out.println()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4324e53b9f613af93f364339875dfe50/" rel="bookmark">
			STM32-HAL-UART-笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //HAL-STM32-UART //结束UART外围设备上正在进行的TX传输（在错误检测或传输完成之后） static void UART_EndTxTransfer(); //结束UART外围设备上正在进行的RX传输（在错误检测或涮菜完成之后） static void UART_EndRxTransfer(); //DMA UART传输过程完成回调 static void UART_DMATransmitCplt(); //DMA UART接收进程完成回调 static void UART_DMAReceiveCplt(); //DMA UART传输TX过程过半完成回调 static void UART_DMATxHalfCplt(); //DMA UART传输RX过程过半完成回调 static void UART_DMARxHalfCplt(); //DMA UART通讯错误回调 static void UART_DMAError(); //DMA UART通信中止回调，当HAL服务在错误时启用（在发送错误后DMA中止过程结束时调用） static void UART_DMAAbortOnError(); //DMA UART TX通讯中止回调，在用户中止请求后DMA TX中止过程结束时调用 static void UART_DMATxAbortCallback(); //DMA UART RX通讯中止回调，在用户中止请求后DMA TX中止过程结束时调用 static void UART_DMARxAbortCallback(); //DMA UART TX通讯中止回调，仅中止TX传输 static void UART_DMATxOnlyAbortCallback(); //DMA UART RX通讯中止回调，仅中止RX传输 static void UART_DMARxOnlyAbortCallback(); //以非阻塞模式发送大量数据 static HAL_StatusTypeDef UART_Transmit_IT(); //以非阻塞模式包裹传输 static HAL_StatusTypeDef UART_EndTransmit_IT(); //在非阻塞模式下接收大量数据 static HAL_StatusTypeDef UART_Receive_IT(); //此函数处理UART通讯超时，它一直等待，直到某个标志不再处于指定状态 static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(); //配置UART外围设备 static void UART_SetConfig(); //UART注册用户回调 HAL_UART_RegisterCallback(); TxHalfCpltCallback：Tx半完成回调 TxCpltCallback：Tx完整回调 RxHalfCpltCallback：Rx半完全回调 RxCpltCallback:Rx完整回调 ErrorCallback:错误回调 AbortCpltCallback：中止完整回调 AbortTransmitCpltCallback：中止传输完成回调 AbortReceiveCpltCallback：中止接收完整回调 HAL_UART_UnRegisterCallback()：将回调重置为默认值 在阻塞模式下接收一定数量的数据，直到接收到预期数量的数据或发生IDLE事件 HAL_UARTEx_ReceiveToIdle(): 在中断模式下接收一定数量的数据，直到接收到预期数量的数据或发生IDLE事件。 HAL_UARTEx_ReceiveToIdle_IT() 根据UART_InitTypeDef中指定的参数初始化UART模式，并创建关联的句柄。 HAL_StatusTypeDef HAL_UART_Init(); 根据UART_InitTypeDef中指定的参数初始化半双工模式，并创建关联的句柄。 HAL_StatusTypeDef HAL_HalfDuplex_Init(); 根据UART_InitTypeDef中指定的参数初始化LIN模式，并创建关联的句柄 HAL_StatusTypeDef HAL_LIN_Init(); 根据UART_InitTypeDef中指定的参数初始化多处理器模式，并创建关联的句柄 HAL_StatusTypeDef HAL_MultiProcessor_Init(); 取消初始化UART外围设备。 HAL_StatusTypeDef HAL_UART_DeInit(); void HAL_UART_MspInit(); void HAL_UART_MspDeInit(); 以阻塞模式发送大量数据 HAL_StatusTypeDef HAL_UART_Transmit(); 在阻塞模式下接收大量数据 HAL_StatusTypeDef HAL_UART_Receive(); 以非阻塞模式发送大量数据 HAL_StatusTypeDef HAL_UART_Transmit_IT(); 在非阻塞模式下接收大量数据 HAL_StatusTypeDef HAL_UART_Receive_IT(); 以DMA模式发送大量数据 HAL_StatusTypeDef HAL_UART_Transmit_DMA(); 在DMA模式下接收大量数据 HAL_StatusTypeDef HAL_UART_Receive_DMA(); 暂停DMA传输 HAL_StatusTypeDef HAL_UART_DMAPause(); 恢复DMA传输 HAL_StatusTypeDef HAL_UART_DMAResume(); 停止DMA传输 HAL_StatusTypeDef HAL_UART_DMAStop(); 在阻塞模式下接收一定数量的数据，直到接收到预期数量的数据或发生IDLE事件 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle(); 在中断模式下接收一定数量的数据，直到接收到预期数量的数据或发生IDLE事件 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(); 在DMA模式下接收一定数量的数据，直到接收到预期数量的数据或发生IDLE事件 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(); 中止正在进行的传输（阻塞模式） HAL_StatusTypeDef HAL_UART_Abort(); 中止正在进行的传输传输（阻塞模式）。 HAL_StatusTypeDef HAL_UART_AbortTransmit(); 中止正在进行的接收传输（阻塞模式） HAL_StatusTypeDef HAL_UART_AbortReceive(); 中止正在进行的传输（中断模式） HAL_StatusTypeDef HAL_UART_Abort_IT(); 中止正在进行的传输传输（中断模式） HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(); 中止正在进行的接收传输（中断模式） HAL_StatusTypeDef HAL_UART_AbortReceive_IT(); 此功能处理UART中断请求。 void HAL_UART_IRQHandler(); Tx传输完成回调 void HAL_UART_TxCpltCallback(); Tx半传输已完成回调 void HAL_UART_TxHalfCpltCallback(); Rx Transfer已完成回调 void HAL_UART_RxCpltCallback(); Rx半传输已完成回调 void HAL_UART_RxHalfCpltCallback(); UART错误回调 void HAL_UART_ErrorCallback(); UART中止完成回调 void HAL_UART_AbortCpltCallback(); UART中止完成回调。 void HAL_UART_AbortTransmitCpltCallback(); UART中止接收完成回调 void HAL_UART_AbortReceiveCpltCallback(); 接收事件回调（使用高级接收服务后调用的Rx事件通知） void HAL_UARTEx_RxEventCallback(); 传输中断字符。 HAL_StatusTypeDef HAL_LIN_SendBreak(); 在静音模式下进入UART。 HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(); 退出UART静音模式：唤醒软件。 HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(); 启用UART发射器并禁用UART接收器。 HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(); 启用UART接收器并禁用UART发射器。 HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver); 在中断模式下启动接收操作。 HAL_StatusTypeDef UART_Start_Receive_IT(); 在DMA模式下启动接收操作。 HAL_StatusTypeDef UART_Start_Receive_DMA(); 刷新UART DR寄存器 #define __HAL_UART_FLUSH_DRREGISTER(__HANDLE__) 检查是否设置了指定的UART标志。 #define __HAL_UART_GET_FLAG(__HANDLE__, __FLAG__) 清除指定的UART挂起标志。 #define __HAL_UART_CLEAR_FLAG(__HANDLE__, __FLAG__) 清除UART PE挂起标志。 #define __HAL_UART_CLEAR_PEFLAG(__HANDLE__) 清除UART FE挂起标志。 #define __HAL_UART_CLEAR_FEFLAG(__HANDLE__) 清除UART NE挂起标志 #define __HAL_UART_CLEAR_NEFLAG(__HANDLE__) 清除UART ORE挂起标志 #define __HAL_UART_CLEAR_OREFLAG(__HANDLE__) 清除UART IDLE挂起标志 #define __HAL_UART_CLEAR_IDLEFLAG(__HANDLE__) 启用指定的UART中断 #define __HAL_UART_ENABLE_IT(__HANDLE__, __INTERRUPT__) 禁用指定的UART中断。 #define __HAL_UART_DISABLE_IT(__HANDLE__, __INTERRUPT__) 检查指定的UART中断源是否已启用。 #define __HAL_UART_GET_IT_SOURCE(__HANDLE__, __IT__) 启用CTS流量控制 #define __HAL_UART_HWCONTROL_CTS_ENABLE(__HANDLE__) 禁用CTS流量控制 #define __HAL_UART_HWCONTROL_CTS_DISABLE(__HANDLE__) 启用RTS流量控制 #define __HAL_UART_HWCONTROL_RTS_ENABLE(__HANDLE__) 禁用RTS流量控制 #define __HAL_UART_HWCONTROL_RTS_DISABLE(__HANDLE__) 启用UART的一位采样方法的宏 #define __HAL_UART_ONE_BIT_SAMPLE_ENABLE(__HANDLE__) 宏禁用UART的一位采样方法 #define __HAL_UART_ONE_BIT_SAMPLE_DISABLE(__HANDLE__) 启用UART #define __HAL_UART_ENABLE(__HANDLE__) 禁用UART #define __HAL_UART_DISABLE(__HANDLE__) UART_FLAG_CTS：CTS更改标志（不适用于UART4和UART5） UART_FLAG_LBD:LIN中断检测标志 UART_FLAG_TXE：传输数据寄存器空标志 UART_FLAG_TC：传输完成标志 UART_FLAG_RXNE：接收数据寄存器非空标志 UART_FLAG_IDLE：空闲线路检测标志 UART_FLAG_ORE:溢出错误标志 UART_FLAG_NE：噪声错误标志 UART_FLAG_FE：帧错误标志 UART_FLAG_PE：奇偶校验错误标志 UART_FLAG_LBD:LIN中断检测标志 UART_FLAG_TC：传输完成标志 UART_FLAG_RXNE：接收数据寄存器非空标志 UART_IT_CTS:CTS更改中断 UART_IT_LBD:LIN中断检测中断 UART_IT_TXE：传输数据寄存器空中断 UART_IT_TC：传输完全中断 UART_IT_RXNE：接收数据寄存器非空中断 UART_IT_IDLE：空闲线路检测中断 UART_IT_PE：奇偶校验错误中断 UART_IT_ERR：错误中断（帧错误、噪声错误、溢出错误） #define UART_CLEAR_PEF 奇偶校验错误清除标志 #define UART_CLEAR_FEF 帧错误清除标志 #define UART_CLEAR_NEF 检测到噪声错误清除标志 #define UART_CLEAR_OREF 超限错误清除标志 #define UART_CLEAR_IDLEF 检测到IDLE行清除标志 #define UART_CLEAR_TCF 变速箱完成清除标志 #define UART_CLEAR_LBDF LIN中断检测清除标志 #define UART_CLEAR_CTSF CTS中断清除标志 #define UART_CLEAR_CMF 字符匹配清除标志 #define UART_CLEAR_WUF 从停止模式唤醒清除标志 #define UART_CLEAR_RTOF UART接收器超时清除标志 #define UART_FLAG_REACK UART接收启用确认标志 #define UART_FLAG_TEACK UART发送启用确认标志 #define UART_FLAG_WUF UART从停止模式唤醒标志 #define UART_FLAG_RWU UART接收器从静音模式唤醒标志 #define UART_FLAG_SBKF UART发送中断标志 #define UART_FLAG_CMF UART字符匹配标志 #define UART_FLAG_BUSY UART忙标志 #define UART_FLAG_ABRF UART自动波特率标志 #define UART_FLAG_ABRE UART自动波特率错误 #define UART_FLAG_RTOF UART接收器超时标志 #define UART_FLAG_CTS UART清除发送标志 #define UART_FLAG_CTSIF UART清除发送中断标志 #define UART_FLAG_LBDF UART LIN中断检测标志 #define UART_FLAG_TXE UART传输数据寄存器为空 #define UART_FLAG_TC UART传输完成 #define UART_FLAG_RXNE UART读取数据寄存器不为空 #define UART_FLAG_IDLE UART空闲标志 #define UART_FLAG_ORE UART超限错误 #define UART_FLAG_NE UART噪声错误 #define UART_FLAG_FE UART帧错误 #define UART_FLAG_PE UART奇偶校验错误 返回当前DMA通道传输中剩余的数据单元数。 #define __HAL_DMA_GET_COUNTER(__HANDLE__) 获取DMA通道挂起标志。 #define __HAL_DMA_GET_FLAG(__HANDLE__, __FLAG__) DMA_FLAG_TCIFx：传输完成标志 DMA_FLAG_HTIFx：半传输完成标志 DMA_FLAG_EIFx：传输错误标志 DMA_ISR_GIFx：全局中断标志 清除DMA通道挂起标志。 #define __HAL_DMA_CLEAR_FLAG(__HANDLE__, __FLAG__) 启用指定的DMA通道中断。 #define __HAL_DMA_ENABLE_IT(__HANDLE__, __INTERRUPT__) DMA_IT_TC：传输完成中断掩码 DMA_IT_HT：半传输完成中断掩码 DMA_IT_TE：传输错误中断掩码 定时器（TIM）外围设备的功能： TIM时基初始化 TIM时基开始 TIM时基启动中断 TIM时基启动DMA TIM输出比较/PWM初始化 TIM输出比较/PWM通道配置 TIM输出比较/PWM启动 TIM输出比较/PWM启动中断 TIM输出比较/PWM启动DMA TIM输入捕获初始化 TIM输入捕获通道配置 TIM输入捕获启动 TIM输入捕获启动中断 TIM输入捕获启动DMA TIM单脉冲初始化 TIM单脉冲通道配置 TIM单脉冲启动 TIM编码器接口初始化 TIM编码器接口启动 TIM编码器接口启动中断 TIM编码器接口启动DMA 带中断和DMA的换向事件配置 TIM OCRef清除配置 TIM外部时钟配置 检查指定的EXTI行标志是否已设置 #define __HAL_GPIO_EXTI_GET_FLAG(__EXTI_LINE__) (EXTI-&gt;PR &amp; (__EXTI_LINE__)) 清除EXTI的行挂起标志 #define __HAL_GPIO_EXTI_CLEAR_FLAG(__EXTI_LINE__) (EXTI-&gt;PR = (__EXTI_LINE__)) 检查指定的EXTI行是否被断言 #define __HAL_GPIO_EXTI_GET_IT(__EXTI_LINE__) (EXTI-&gt;PR &amp; (__EXTI_LINE__)) 清除EXTI的行挂起位 #define __HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__) (EXTI-&gt;PR = (__EXTI_LINE__)) 在选定的EXTI行上生成软件中断 #define __HAL_GPIO_EXTI_GENERATE_SWIT(__EXTI_LINE__) (EXTI-&gt;SWIER |= (__EXTI_LINE__)) 读取指定的输入端口引脚。 GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); 设置或清除选定的数据端口位。 void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState); 切换指定的GPIO引脚。 void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); 锁定GPIO引脚配置寄存器。 HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); 此功能处理EXTI中断请求。 void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin); EXTI线路检测回调。 void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0739d4d11ebcc17b17ad78bb5891a0/" rel="bookmark">
			SpringCloudGateway 入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 POM 依赖一、内容网关的作用Spring-Cloud-Gateway的核心概念 二、基于Ribbon的负载均衡三、核心概念详细3.1 断言 Predicate3.2 过滤器3.2.1 内置过滤器3.2.2 自定义过滤器构造器（原理）资源结构Route / Predicate 的构造器构造器的增强器整体协同关系 / 部分源代码分析 扩展自己的过滤器（实战） POM 依赖 我的Java版本是17
父模块
&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;alibaba-cloud.version&gt;2022.0.0.0&lt;/alibaba-cloud.version&gt; &lt;spring-cloud.version&gt;2022.0.4&lt;/spring-cloud.version&gt; &lt;spring-boot.version&gt;3.0.9&lt;/spring-boot.version&gt; &lt;circuit-breaker.version&gt;3.0.3&lt;/circuit-breaker.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;${alibaba-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 子模块
&lt;dependencies&gt; &lt;!-- 网关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 注册中心配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 注册中心客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d0739d4d11ebcc17b17ad78bb5891a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee0dadae0fe9c5efab53447774a25421/" rel="bookmark">
			小白教程： 谷歌安装 vue-devtools 拓展，无需编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先下载压缩包（百度网盘） 链接： 百度网盘 请输入提取码
提取码：3306
下载完如图：
解压这个zip，安装
2.谷歌里面安装拓展 解压下载的文件后按下面的步骤进行
3.勾选上开发者模式
4.选择解压文件中的chrom文件
然后如图：
5.点开这个方块点击这个标签固定在旁边
6.验证Vue-Devtools是否启动成功 重启谷歌浏览器，打开Vue页面，显示vue即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27fcbbff7bdc3832700d17ffa0767938/" rel="bookmark">
			【云上探索实验室-码上学堂】免费学习领好礼！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		走过路过，不要错过！上云AI三步走，学着课程奖品有！
亚马逊云科技又放福利了，为了让同学们更快入手Amazon CodeWhisperer，官方推出《云上探索实验室-码上学堂》活动，作为一名Amazon CodeWhisperer的学习者，咱们还可以成为【领学员】，在学习的同时，还能拿到奖品！
成为领学员 第一步-添加云助手微信，完成报名。云助手将邀请您进入云上探索实验室-码上学堂社群。 亚马逊云科技小助手微信号：super-assistant
第二步：邀请好友学课 邀请伙伴进入社群，免费学习
《Amazon CodeWhisperer 入门》课程（课长 30 分钟）。将开课截图发到社群中，完成打卡。
第三步：静候奖品敲门 云助手将统计每位领学员带来的完课学员数量，并以此进行排名，最终根据排名情况赠送领学员相应的奖品。
官方活动 关注亚马逊云师兄，不定时发好礼，咖啡券、奶茶券、咖啡杯等等，无限好礼，等您来拿！
微信搜索关注【亚马逊云师兄】,带你一路升级云计算大神！
奖品一览 学习课程 学课通道在这里：
CSDN平台：https://edu.csdn.net/course/detail/38969?utm_source=AWS-Paid-Builder-MKT-Social-YS-CW-CSDN
网易云课堂：
https://study.163.com/course/introduction/1213602804.htm?from=AWS-Paid-Builder-MKT-Social-YS-CW-NECC
Skill Builder 平台：
https://explore.skillbuilder.aws/learn/course/external/view/elearning/17168/amazon-codewhisperer-getting-started-simplified-chinese?trk=d15c46ed-1e4e-4e8b-82c0-63ba2feb26b9&amp;sc_channel=el
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/38/">«</a>
	<span class="pagination__item pagination__item--current">39/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/40/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>