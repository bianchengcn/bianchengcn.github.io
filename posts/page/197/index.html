<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ca0581f138cf1e4e9f5f5a4969cccd/" rel="bookmark">
			html设置透明度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在html中，设置元素的透明度
在css相应元素中添加下面代码即可。
opacity:0.5; opacity的取值范围为0~1，0表示全透明，1表示不透明
完整示例代码块
div{ opacity:0.5; } 结合示例项目贴出代码块
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;html透明度设置&lt;/title&gt; &lt;style&gt; /* 不透明 */ .div1{ width: 200px; height: 200px; background-color: red; } /* 透明 */ .div2{ width: 200px; height: 200px; background-color: red; opacity: 0.5; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 不透明 --&gt; &lt;div class="div1"&gt; 不透明 &lt;/div&gt; &lt;!-- 透明 --&gt; &lt;div class="div2"&gt; 透明 &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 示例结果图
觉得对您有用，记得点击小红心！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efc23cf83d6dc0fc9c6b82e95aca9b6f/" rel="bookmark">
			html中禁止网页另存为、查看源文件、屏蔽鼠标右键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在HTML网页中加入几行简单的代码可以禁止他人使用鼠标右键和“另存为”命令。 一、屏蔽鼠标右键 把网页的标签修改为下面的代码：
＜body oncontextmenu=self.event.returnValue=false onselectstart="return false"＞ &lt;/body&gt; 现在点击鼠标右键就不会有任何反应了。 二、禁止“另存为”命令 在目标网页末尾“&lt;/BODY&gt;&lt;/HTML&gt;”的标签前面加上加入如下代码，可以使“另存为”命令不能顺利执行。 &lt;noscript&gt; &lt;iframe scr="*.htm"&gt;&lt;/iframe＞ &lt;/noscript&gt; 加入上述代码后，当执行“另存为”命令时，会弹出“保存网页时出错”的对话框。 三、不用js也可以控制禁止右键!方法: &lt;body οncοntextmenu="return false"&gt;&lt;/body&gt; &lt;!-- 禁用右键: --&gt; &lt;script&gt; function stop(){ return false; } document.oncontextmenu=stop; &lt;/script&gt; &lt;body onselectstart="return false"&gt; 取消选取、防止复制 οncοpy="return false;" oncut="return false;" 防止复制 四：禁止查看源文件 &lt;script&gt; function clear(){ Source=document.body.firstChild.data; document.open(); document.close(); document.title="看不到源代码"; document.body.innerHTML=Source; } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce13fa83529a591c488141fac20a8ab6/" rel="bookmark">
			vue &#43; vuex &#43; element-ui 购物车
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个购物车功能相对简单，路由控制进入home页（商品列表页），添加商品后，cart页（购物车页）链接后会显示加入商品数量。进入cart页会列出添加的商品，可加减数量、删除单个商品、清空购物车。
项目目录
router.js 路由引入…/page/目录下页面
import App from '../App' import Home from '../page/home' import Cart from '../page/cart' export default [{ path: '/', component: App, children: [{ path: '/', component: Home }, { path: '/cart', component: Cart }] }] layout.vue
&lt;template&gt; &lt;div&gt; &lt;el-container&gt; &lt;el-aside width="200px"&gt; &lt;el-menu router :default-active="$route.path" class="el-menu-vertical-demo nav"&gt; &lt;el-menu-item index="/"&gt; &lt;i class="el-icon-menu"&gt;&lt;/i&gt; &lt;span slot="title"&gt;home&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index="/cart"&gt; &lt;i class="el-icon-goods"&gt;&lt;/i&gt; &lt;span slot="title"&gt; cart &lt;el-badge class="mark" v-if="totalNum" :value="totalNum" /&gt; &lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-main&gt; &lt;el-tag v-if="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce13fa83529a591c488141fac20a8ab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/013013b72ca2cb1d3abffa822a64fab1/" rel="bookmark">
			模型预测结果校准——Isotonic regression
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型预测结果校准——Isotonic regression 方法简介： Isotonic Regression: the method used by Zadrozny and Elkan (2002; 2001) to calibrate predictions from boosted naive bayes, SVM, and decision tree models.[1]
Zadrozny and Elkan (2002; 2001) successfully used a more general
method based on Isotonic Regression (Robertson et al.,1988) to calibrate predictions from SVMs, Naive Bayes, boosted Naive Bayes, and decision trees. This method is more general in that the only restriction is that the mapping function be isotonic (monotonically increasing).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/013013b72ca2cb1d3abffa822a64fab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6a6de59aaef4b86d6aadd931d0c57e0/" rel="bookmark">
			再看volatile关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		volatile关键字 在Java中, 允许多线程访问同一个共享变量(§17.1 shared variables), 为了保证共享变量在多线程间保持一致, 通常情况会通过锁来对共享变量的保护, 线程操作的时候需要获得锁才可以对共享变量的操作, 这样就保证了共享变量在多线程间保持一致.
Java还提供另外一种做法可以确保共享变量在多线程间保持一致的, 这个做法就是将变量声明为volatile变量, 对于一些场景, 这是一种比锁更方便的做法.
volatile的作用: 当一个变量被声明为volatile, 将确保所有线程看到变量一致结果, 也就是说声明为volatile的变量变更时对所有线程是可见的.
volatile重要的两个特性:
可见性禁止指令的重排序 还有需要注意的是: 被声明为final的变量不能同时被声明为volatilevolatile不能代替锁 对于volatile的详细介绍具体可以查阅:The Java ® Language Specification [Java SE 10 Edition] (8.3.1.4 volatile Fields)
可见性 可见性是指当多个线程访问同一个变量时, 一个线程修改了这个变量的值, 其他线程能够立即看得到修改的值.
这里通过一个简单的例子来说明可见性的问题. 但在说明这个例子之前, 首先需要知道:
在Java内存模型中规定了所有的变量都存储在主内存中, 每条线程还有自己的工作内存(可以与处理器的高速缓存类比), 线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝, 线程对变量的所有操作(读取,赋值)都必须在工作内存中进行, 而不能直接读写主内存中的变量. 不同线程之间无法直接访问对方工作内存中的变量, 线程间变量值的传递均需要在主内存来完成. 示例:
// 线程1操作 int i = 0; // (1) i = 1; // (2) // 线程2操作 int j = i; // (3) 线程1执行完操作(1)会将初始值0加载到主内存, 后执行操作(2)进行赋值, 将1赋值给i, 这样线程1工作内存中的i的值变为1, 如果线程1此时还没将i=1的值同步到主内存中, 线程2执行操作(3), 将主内存中i=0拷贝到线程2工作内存中, 然后赋值给j, 结果j=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6a6de59aaef4b86d6aadd931d0c57e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b0e265b2725f7eb20dbb2afda6d58fd/" rel="bookmark">
			CAN总线-位时序、波特率、采样点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAN总线通讯协议的每一帧可以看作一连串的电平信号，每一个电平信号代表一位（一个字节8位的位），所以一帧中包含了很多个位，由发送单元在非同步的情况下发送的每秒钟的位数称为位速率。
一位又分为4段，同步段（SS）、传播时间段（PTS）、相位缓冲段 1（PBS1）、相位缓冲段 2（PBS2）。
一位可以当作一条水平的时间轴，不同的段在整个时间轴的占比不一样，每一段又由若干个最小时间单元Time Quantum（以下称为 Tq）构成。
位由多少个 Tq 构成、每个段又由多少个 Tq 构成等，可以任意设定位时序。通过设定位时序，多个单元可同时采样，也可任意设定采样点。各段的作用和 Tq 数如表 11 所示。1 个位的构成如下图所示
在stm32的程序配置中，我们要通过位时序设置采样点和波特率。
CAN_InitStructure.CAN_SJW=CAN_SJW_1tq; CAN_InitStructure.CAN_BS1=CAN_BS1_9tq; CAN_InitStructure.CAN_BS2=CAN_BS2_6tq; CAN_InitStructure.CAN_Prescaler=5; 上面是一个设置的实例，在stm32程序设计中，初始化跟linux编程差不多，利用系统提供的结构体类型对其各个成员赋值，再调用系统的初始化函数。
CAN_Init(&amp;CAN_InitStructure); 该函数参数就是上面配置好参数的结构体。
CAN_SJW：上面的表格有解释。（一般为1） CAN_BS1：时间段1（跟表格划分有区别） CAN_BS2：时间段2 CAN_Prescaler：这个可以理解为系数，也叫波特率分频器 关于采样点和波特率的计算公式：
CAN波特率 = CAN时钟/( (1 + CAN_BS1 + CAN_BS2) * CAN_Prescaler） sample = ( 1 + CAN_BS1) / (1 + CAN_BS1 + CAN_BS2) 如果 CAN时钟为8M，CAN_BS1 = 9，CAN_BS2 = 6，CAN_Prescaler = 5
那么 波特率=8M/(1+9+6)/5=100K
采样点=（1+9）/（1+9+6）=62.5%
由上面可以看出来，同一波特率条件下，BS1、BS2可以有不同的组合，不同的组合采样点不同。
下面是刚才提到的两条公式的推导过程（可以不用理解，记公式即可）：
采样点：
所谓采样点是读取总线电平，并将读到的电平作为位值的点。位置如图所示处。所以从一个位的开始到采样点的时间占一个完整位的总时间的百分比就是所求的值：sample = ( 1 + CAN_BS1) / (1 + CAN_BS1 + CAN_BS2)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b0e265b2725f7eb20dbb2afda6d58fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82dac797f512369a413e470ad1f99624/" rel="bookmark">
			libcurl,c&#43;&#43;,CURLOPT_POSTFIELDS,post 内容变成乱码，或者长度发生变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结：
使用局部变量，空间被释放；导致curl 发送时，数据取不到了
详细说明:
在一个项目中，使用libcurl 发送http消息，用到了post方式；在测试的过程中，发现有的时候，会有消息发送异常，看打印出来的信息，发现，post后边跟着的信息会出错，缺少内容，或者乱码
研究了半天，通过查资料，才确定，设置CURLOPT_POSTFIELDS这个参数，只是传递了一个指针给curl实例。其内部调用的时候，会去拿这个指针来取具体的值；如果整个流程都在一个函数中，szField 就是我传进去的这个数组的指针，不会被释放掉，一切都是正常的。 但我在调用的时候，这里封装成了一个函数，返回给上层调用，这样这个局部变量szField的空间就被释放掉了，
等到curl内容发送的时候，取到的内容就发生变化了，就会导致内容错误，甚至会挂掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0caf95af98f8c52c7d8ebb3ac164eb4b/" rel="bookmark">
			VGGNet介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VGGNet介绍 1 简要概括 VGGNet由牛津大学计算机视觉组合和Google DeepMind公司研究员一起研发的深度卷积神经网络。它探索了卷积神经网络的深度和其性能之间的关系，通过反复的堆叠3*3的小型卷积核和2*2的最大池化层，成功的构建了16~19层深的卷积神经网络。VGGNet获得了ILSVRC 2014年比赛的亚军和定位项目的冠军，在top5上的错误率为7.5%。目前为止，VGGNet依然被用来提取图像的特征。
2 创新点 VGGNet全部使用3*3的卷积核和2*2的池化核，通过不断加深网络结构来提升性能。网络层数的增长并不会带来参数量上的爆炸，因为参数量主要集中在最后三个全连接层中。同时，两个3*3卷积层的串联相当于1个5*5的卷积层，3个3*3的卷积层串联相当于1个7*7的卷积层，即3个3*3卷积层的感受野大小相当于1个7*7的卷积层。但是3个3*3的卷积层参数量只有7*7的一半左右，同时前者可以有3个非线性操作，而后者只有1个非线性操作，这样使得前者对于特征的学习能力更强。
使用1*1的卷积层来增加线性变换，输出的通道数量上并没有发生改变。这里提一下1*1卷积层的其他用法，1*1的卷积层常被用来提炼特征，即多通道的特征组合在一起，凝练成较大通道或者较小通道的输出，而每张图片的大小不变。有时1*1的卷积神经网络还可以用来替代全连接层。
其他小技巧。VGGNet在训练的时候先训级别A的简单网络，再复用A网络的权重来初始化后面的几个复杂模型，这样收敛速度更快。VGGNet作者总结出LRN层作用不大，越深的网络效果越好，1*1的卷积也是很有效的，但是没有3*3的卷积效果好，因为3*3的网络可以学习到更大的空间特征。
3 网络结构 VGGNet的网络结构如下图所示。VGGNet包含很多级别的网络，深度从11层到19层不等，比较常用的是VGGNet-16和VGGNet-19。VGGNet把网络分成了5段，每段都把多个3*3的卷积网络串联在一起，每段卷积后面接一个最大池化层，最后面是3个全连接层和一个softmax层。
4 代码实现 代码实现参考自tensorflow的开源实现
#%% # Copyright 2016 The TensorFlow Authors. All Rights Reserved. # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0caf95af98f8c52c7d8ebb3ac164eb4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ef2b9506f13411c7465462764850b5/" rel="bookmark">
			angular directive 入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		angular directive 入门 “控制器应该尽可能保持短小精悍，而在控制器中进行DOM操作和数据操作则是一个不好的实践。”
“设计良好的应用会将复杂的逻辑放到指令和服务中。通过使用指令和服务，我们可以将控制器重构成一个轻量且更易维护的形式” 《AngularJs权威教程》
Hello Directive &lt;body ng-app="myApp"&gt; &lt;my-student&gt;&lt;/my-student&gt; &lt;script type="text/javascript"&gt; var app = angular.module('myApp',[]); app.directive("myStudent",function(){ return { restrict:"EA", template:"Hello Directive" } }) &lt;/script&gt; &lt;/body&gt; 是的，创建一个指令就是这么简单，但是仅仅如此可是不行的，比如：如何让指令的html更丰富呢，如何让指令也能进行数据绑定呢，如何向指令中传递参数、方法呢，是否可以指令嵌套指令呢…请继续往后看 Directive结构分析 restrict:属性名称，取”EACM”中的任意一个或多个字母，它是用来限制指令的声明格式 E element 元素名称 &lt;my-student&gt;&lt;/my-student&gt; A attribute 属性 &lt;div my-student&gt;&lt;/div&gt; C class 类名 &lt;div class="my-student"&gt;&lt;/div&gt; M 注释 &lt;!-- directive:my-student --&gt; template:’指令的内容(html代码)’ template:'&lt;div&gt;&lt;p&gt;{{name}}&lt;/p&gt;&lt;/div&gt;' app.directive("myStudent",function(){ return { restrict:"EA", template:"&lt;div&gt;&lt;p&gt;{{name}}&lt;/p&gt;&lt;/div&gt;", controller:function($scope){ $scope.name="CONST_Q" } } }) templateUrl:’指令的内容(引用html文件内容作为指令内容)’ &lt;!-- child1.html--&gt; &lt;div&gt; &lt;p&gt;您好 {{name}}&lt;/p&gt; &lt;/div&gt; app.directive("myStudent",function(){ return { restrict:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1ef2b9506f13411c7465462764850b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b87f92885cdc0b4f37c5583c4a5990/" rel="bookmark">
			区块链100讲：浅谈区块链的 Layer2 扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**前言：自区块链技术诞生以来，对其“性能”的诟病就从来没有停止过。虽然从技术上说，一个基于分布式对等网络架构的系统，与成熟的中心化技术相比，其“性能”方面有着天然的劣势，但业内人士对区块链“扩容”的研究和努力也从没有停止过。近两年，所谓的“区块链 Layer2 扩展”的提法已经逐渐在业内达成共识，并出现了一些有潜力的项目。本文就将为大家介绍一些与区块链“扩容”和“Layer2 扩展”**相关的基础概念。
本文可以看作是对区块链的 Layer2 扩展的扫盲性介绍，不会涉及过多的技术细节；但我会假设读者已经知道比特币、以太坊是什么，区块链大概是什么，我们会基于这些最基础的知识来讨论扩容的问题。 希望本文能给区块链开发者或爱好者一些有价值的参考。
1 如何评估区块链的“性能”？ 如果我们现在来问一个区块链爱好者或者从业者：你认为目前比较成熟的公链，比如比特币和以太坊在技术上面临的最大的问题是什么？我想大多数人的回答应该都是类似的：交易确认时间长（一个交易从发出到最终确认所经过的时间）、网络拥堵严重（如果同一个时间产生的交易太多，有些交易无法被马上处理）等等。这也就是通常意义上讲的所谓“性能”问题。
对于目前基于区块链架构的公链平台的所谓“性能”的评估，应该考虑两个方面。
被讨论最多的就是所谓的 TPS（Transactions Per Second），这个维度衡量的是区块链在单位时间内所能处理的交易数量；我们近几年最常提到的所谓“扩容”指的就是这个维度。
如果把以太坊比做“世界计算机”，那么目前，它只能用单核（单线程）来进行计算（同一时间只能有一个矿工来记账，或者说只有一个矿工记的账会被接受）；而所谓“扩容”可以想象为把这个“世界计算机”扩展为多核（多线程），使它在单位时间内可以同时运行多个任务（同时有多个矿工在记账，他们记的账都可以被接受），最终反映为 TPS 的提高。这也就是所谓的 Layer1 扩容。在以太坊里，指的就是现在已经合二为一的 Casper + Sharding（我之前曾发过一篇 技术翻译稿 来讲解 Sharding 的原理，有兴趣的读者可以自行参考，这里不再展开了）。
但是在实际应用中还有一个衡量性能的维度是不能忽视的，那就是“平均处理时间”。基于刚刚的比喻，在以太坊中，这个维度就相当于这台“世界计算机”的单核（单线程）处理能力。
2 什么是“区块链的 Layer2 扩展”？ 我们假设某个基于以太坊智能合约的业务流程需要 5 个步骤（交易）才能完成，也就是说，我大概有个智能合约，这个合约会有 6 个状态：初始状态，状态1，...，状态4，最终状态。那么要完成整个流程，就至少需要 5 个区块时间（从初始状态变为状态 1，需要交易 1 来完成，以次类推，则至少需要 5 个交易才能把状态变为最终状态）。
很显然，在这个例子里，区块链性能的瓶颈就变成了“区块时间”。（这是因为智能合约本质上就是一个可定制的状态机，如果它有 6 个单向变化的状态，那么必须经过 5 次变化才能达到最终状态，所以 5 个交易是必须的。）而区块时间是由公链协议所规定的，比如在比特币里是 10 分钟，在以太坊里现在大概是 16 秒，这是无法简单缩减的；整个流程的 5 个区块时间是最乐观的估计，也就是性能上限。那么我们如何缩短这个流程的执行时间、降低“平均处理时间”呢？
这就是所谓的区块链 Layer2 扩展要解决的问题。而答案就是—— off-chain（这个词的译法大概还没有共识，我这里姑且译为“脱链”，也就是不在主链上处理的意思）。
这种 off-chain 解决方案的思路是：我们可以把计算、交易等业务处理拿到主链之外来执行，只在主链上反映最终的结果，中间过程不在主链做记录。
这样，在上边例子里，我们要在主链上保存的状态就是初始状态和最终状态，中间过程的 4 个状态变动我们可以不关心，那对应的 4 个交易就可以拿到“链外”去执行；因为 off-chain 方案通常处理性能会非常高（后文中我会具体解释技术方案的原理），很有可能在主链的一个区块时间内就处理完这 4 个交易，并将结果发送回主链（即达到最终状态）；于是从结果来看，整个处理过程只经过了一个区块时间（也就是最终状态的确认交易）就完成了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1b87f92885cdc0b4f37c5583c4a5990/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a49ea62266150b69c76117f435b44de2/" rel="bookmark">
			Android中webview监控页面卡死
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址为： Android中webview监控页面卡死 由于webview在加载页面过程中或者加载完成后，页面可能会出现卡顿或崩溃的情况，此时程序后台是感知不到的，需要通过程序手段监测出来。
因此采取页面上定时发送心跳到webview后端，后端通过监测心跳来判断页面有没有死掉的情况。
一、先编写java相关文件HeartJavaScriptFunction.java，用于向js提供调用的接口函数：
public interface HeartJavaScriptFunction {
void onJsFunctionCalled(int tag);
} 二、编写CrashMonitor.java，用来判断页面心跳： import java.util.Date;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
public class CrashMonitor {
private ScheduledExecutorService executorService = null;
private long oldpos = 0;
private int pauseNum = 0;
private OnCrashedListener onCrashedListener;
public interface OnCrashedListener {
void onCrashed();
}
public void setOnCrashedListener(OnCrashedListener listener) {
onCrashedListener = listener;
}
public boolean isWorking(){
boolean res = false;
if(executorService != null){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a49ea62266150b69c76117f435b44de2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18321a421194a0defff5e1a335e7fc11/" rel="bookmark">
			MUI-APP开发之mui框架封装获取文件方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;link href="../css/mui.min.css" rel="stylesheet" /&gt; &lt;header class="mui-bar mui-bar-nav"&gt; &lt;a class="mui-action-back mui-icon mui-icon-left-nav mui-pull-left"&gt;&lt;/a&gt; &lt;h1 class="mui-title"&gt;文件查找&lt;/h1&gt; &lt;/header&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="mui-content"&gt; &lt;ul id="list" class="mui-table-view mui-table-view-chevron"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script src="../js/mui.min.js"&gt;&lt;/script&gt; &lt;script src="../js/njs-io.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var nowFileType; var subRoot = null; var lockOadWebview = null; mui.init({ /*preloadPages: [{ id: 'lock-oadUpdate.html', url: 'lock-oadUpdate.html' }]*/ }); mui.plusReady(function() { var self = plus.webview.currentWebview(); nowFileType = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18321a421194a0defff5e1a335e7fc11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25a4f9d1684276c935cb700cf53ec1fc/" rel="bookmark">
			pyqt5 学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(1) 无边框化设计
self.setWindowFlags(Qt.FramelessWindowHint)
这句话加在self.setupUi(self)下面 (2) 设置style 加在__init__（self）内
self.style = """ QPushButton{ color: #003300; border-top-right-radius: 4px; border-bottom-right-radius: 4px; background-color: #CCCC99; font-size: 15px; font-family: ''; } QPushButton#pushButton{; background-color: blue; } QPushButton:Hover{ background-color: #009966; color: white; } QTextEdit{ border-top-left-radius: 4px; border-bottom-left-radius: 4px; background-color: #CCCCCC; selection-color: #CCCCCC; selection-background-color: #222222; color: black; } QPushButton:pressed {background-color: ;border-style: inset;} """ self.setStyleSheet(self.style) (3) 长按按钮触发
setAutoRepeat()设置button是否在用户长按按钮的时候可以自动重复执行。
self.pushButton.setIcon(QIcon("C://alolf_train//icons//delete.gif")) self.pushButton.setAutoRepeat(True) (4) 图片填满button
self.pushButton.setFixedSize(QPixmap("C://alolf_train//icons//GantryKeyUp128.png").size()); self.pushButton.setStyleSheet("border-image:url(C://alolf_train//icons//GantryKeyUp128.png)"); (5) 按钮图片状态变化
self.pushButton.setStyleSheet("QPushButton{border-image:url(C://alolf_train//icons//GantryKeyUp128.png);}" "QPushButton:hover{border-image: url(C://alolf_train//icons//GantryKeyUp128_Lit.png);}" "QPushButton:pressed{border-image: url(C://alolf_train//icons//GantryKeyUp128_Pod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25a4f9d1684276c935cb700cf53ec1fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe1e8ff97b63dde3660c929da8f5a7f/" rel="bookmark">
			Calendar类计算两个日期相差多少天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package bly; import java.util.Calendar; public class TestCalendar { public static void main(String[] args) { // TODO Auto-generated method stub Calendar a = Calendar.getInstance(), b = Calendar.getInstance(); a.set(2000, Calendar.SEPTEMBER, 13); b.set(2018, Calendar.JUNE, 28); long diffDays = (b.getTimeInMillis() - a.getTimeInMillis()) / (1000 * 60 * 60 * 24); System.out.println("您已经活了：" + diffDays + " 天"); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c480b96dab3b3de370afcdc0576cf45/" rel="bookmark">
			修复windows系统引导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具：安装好winPE的启动u盘
1.使用winPE中带的bootice扇区引导管理
2.点击“目标磁盘”进行磁盘选择，选择“主引导记录”。
3.在弹跳出的窗口中，我们选择“windows NT5.x/6.x MBR”，并点击下方的“安装/配置”。
4.在“主引导记录”页面中，若使用的是windows xp系统就选择NT 5.x ，使用Win7系统便选择NT 6.x，工具会提示是否成功。
5.返回bootice工具的主菜单，目标磁盘不用改变，点击“分区引导记录”。
6.在弹跳的窗口中，如果是win7用户点击选择“bootmgr引导程序”，如果是xp用户则点击NTLDR引导程序，最后点击“安装/配置”。
7.出现窗口后，我们不需要做修改，直接点击“确定”就可以，成功了，就会再次弹跳出窗口。
8.以上便是pe系统使用bootice工具进行系统引导修复
转自：https://m.upandashi.com/pejc/2959.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d80f85aa72a33c67a4f070718d753b/" rel="bookmark">
			java8 stream流操作的flatMap（流的扁平化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flatMap的用法和含义住要通过一个案例来讲解，
案例：对给定单词列表 ["Hello","World"],你想返回列表["H","e","l","o","W","r","d"]
第一种方式
String[] words = new String[]{"Hello","World"}; List&lt;String[]&gt; a = Arrays.stream(words) .map(word -&gt; word.split("")) .distinct() .collect(toList()); a.forEach(System.out::print); 代码输出为：[Ljava.lang.String;@12edcd21[Ljava.lang.String;@34c45dca （返回一个包含两个String[]的list）
这个实现方式是由问题的，传递给map方法的lambda为每个单词生成了一个String[](String列表)。因此，map返回的流实际上是Stream&lt;String[]&gt; 类型的。你真正想要的是用Stream&lt;String&gt;来表示一个字符串。
下方图是上方代码stream的运行流程
第二种方式：flatMap（对流扁平化处理）
String[] words = new String[]{"Hello","World"}; List&lt;String&gt; a = Arrays.stream(words) .map(word -&gt; word.split("")) .flatMap(Arrays::stream) .distinct() .collect(toList()); a.forEach(System.out::print); 结果输出：HeloWrd
使用flatMap方法的效果是，各个数组并不是分别映射一个流，而是映射成流的内容，所有使用map(Array::stream)时生成的单个流被合并起来，即扁平化为一个流。
下图是运用flatMap的stream运行流程，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/394b7a84353653d54c7dd891deb51856/" rel="bookmark">
			C&#43;&#43;中结构体与类到底有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt; using namespace std; typedef struct DemoS{ private: char c; char x; int y; public: DemoS(){} DemoS(char c,char x,int y):c(c),x(x),y(y) { //cout&lt;&lt;this&lt;&lt;"有参构造"&lt;&lt;endl; } inline void setX(char x) { this-&gt;x=x; } inline void printX(){ cout&lt;&lt;this-&gt;x&lt;&lt;endl; } ~DemoS() { //cout&lt;&lt;this&lt;&lt;"析构函数"&lt;&lt;endl; } }DemoS; class DemoC{ private : char c; char x; int y; public: DemoC(){} DemoC(char c,char x,int y):c(c),x(x),y(y) { //cout&lt;&lt;this&lt;&lt;"有参构造"&lt;&lt;endl; } inline void setX(char x){ this-&gt;x=x; } inline void printX() { cout&lt;&lt;this-&gt;x&lt;&lt;endl; } ~DemoC(){ // cout&lt;&lt;this&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/394b7a84353653d54c7dd891deb51856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9acd5801af0731a012f09b1d5578c361/" rel="bookmark">
			jQuery的$(document).ready() 与$(window).load 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般情况下一个页面响应加载的基本顺序是：域名解析 -&gt; 加载html -&gt; 加载js和css -&gt; 加载图片等其他信息。
一、$(document).ready() 从字面的意思上理解，就是文档准备好了。也就是浏览器已经加载并解析完整个html文档，dom树已经建立起来了,然后执行此函数 $(document).ready(function(){ alert("ready"); });或 $(function(){ alert("ready"); }); 二、$(window).load 在网页中所有元素(包括页面中图片,css文件等所有关联文件)完全加载到浏览器后才执行 $(window).load(function(){ alert("onload"); }); 链接 https://www.jb51.net/article/107111.htm 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d6edc73f8d71b2e3e3fdb554a1f826a/" rel="bookmark">
			关于Findbugs的一些常见报错的翻译和处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Lab5中要求使用 CheckStyle 和 FindBugs 工具对经过人工走查的 Lab4 代码进行自动的静态代码分析。在使用FindBugs的过程中，出现了一些难以理解的报错，经查阅资料，了解了错误的原因以及一些大致的解决办法。
下面是关于FindBugs的一些常见报错的翻译和处理方法：
一、Security 关于代码安全性防护
1.Dm: Hardcoded constant database password(DMI_CONSTANT_DB_PASSWORD)
代码中创建DB的密码时采用了写死的密码。
2.Dm: Empty database password(DMI_EMPTY_DB_PASSWORD)
创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。
3.HRS: HTTP cookie formed from untrustedinput (HRS_REQUEST_PARAMETER_TO_COOKIE)
此代码使用不受信任的HTTP参数构造一个HTTP Cookie。
4.HRS: HTTP Response splittingvulnerability (HRS_REQUEST_PARAMETER_TO_HTTP_HEADER)
在代码中直接把一个HTTP的参数写入一个HTTP头文件中，HTTP的响应因此暴露了漏洞。
5.SQL: Nonconstant string passed toexecute method on an SQL statement (SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE)
该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。
6.XSS: JSP reflected cross site scriptingvulnerability (XSS_REQUEST_PARAMETER_TO_JSP_WRITER)
在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。
二、Experimental
1.LG: Potential lost logger changes due toweak reference in OpenJDK (LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE)
OpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。–logger配置改变，它就会丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d6edc73f8d71b2e3e3fdb554a1f826a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f985bab0b85c8e800bc7593ad603105/" rel="bookmark">
			nRF51822：在 macOS 下使用 SEGGER Embedded Studio（SES）搭建开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统环境
系统：macOS 10.13.6（Windows 和 Linux 同样适用）网络：联网 软件环境（只能保证这个版本环境好用）
编译器环境：SEGGER Embedded Studio v3.40（SES）仿真器驱动：J-Link Software and Documentation Pack v6.32i软件开发包：nRF5 SDK v12.3.0（最后一个支持 nRF51 系列芯片的版本） 硬件环境
开发板：nRF51 DK v1.2.0开发板：青风 nRF51822 开发板仿真器：J-Link v9.2（淘宝版）（实测第三方 J-Link for ARM OB v7 不能长时间仿真） 导入 Keil µVersion 工程
尽管 SES（SEGGER Embedded Studio）已经成为 Nordic 官方推荐的免费跨平台开发环境，但是首个获得官方支持带有 SES 工程的 SDK 版本是 v14.1.0，并不包括 nRF51 系列代码。因此对于 nRF51 系列来说，需要通过简单的操作将 Keil 工程转换为 SES 工程。打开 SES，在菜单栏选择“Tool -&gt; Package Manager”，然后安装“CMSIS-CORE Support Package”和“nRF CPU Support Package”。 在菜单栏，选择“File -&gt; Import Project -&gt; Import Keil MDK Project…”；导航到 nRF5 SDK 的位置，在路径“examples/ble_peripheral/ble_app_hrs/”中选择一个工程，例如：“pca10028/s130/arm5_no_packs/ble_app_hrs_pca10028_s130.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f985bab0b85c8e800bc7593ad603105/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/196/">«</a>
	<span class="pagination__item pagination__item--current">197/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/198/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>