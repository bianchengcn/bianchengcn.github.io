<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494b2807a244b926c5cc457ebca81376/" rel="bookmark">
			腾讯云SSL证书在阿里云添加域名DNS解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景说明 在阿里云申请并备案了域名，这个域名理论上可以在任何服务器上进行绑定。应用服务器部署到腾讯云，并在腾讯云申请了SSL证书，从而完成HTTPS转化。那么问题来了，腾讯提供的免费版SSL证书是一年有效期，到期后就需要进行以下操作，记录下来方便后期查询。
操作步骤 在腾讯云SSL证书管理中心，申请免费的SSL证书（提供20个免费证书） 申请后进行验证 查看详情，进入提示页面，我们进行域名验证，发现失败，原因就是该域名目前没有DNS解析，而添加DNS解析需要去域名注册服务商去操作。
由于域名申请是在阿里云备案的，因此DNS解析需要去阿里云进行操作。若你的域名本身就是腾讯云备案申请的，则无需更换。
阿里云添加DNS解析记录 添加记录注意选择：CNAME方式，这几个参数在腾讯云页面有提示
添加成功后，再次返回腾讯云进行操作，验证DNS。
验证后，可以发现，状态变成已签发。
部署证书 在SSL证书状态未已签发时，可进行部署，部署后才会生效。
未生效时，浏览器提示不安全，如图
点击“部署”，进入部署操作页面
等待几分钟，刷新状态。
部署成功后，再次访问域名，浏览器不会提示不安全，如图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f35b2bd507d4944fe4590da63636ec2/" rel="bookmark">
			机器学习4-多元线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多元线性回归(Multiple Linear Regression)是线性回归的一种扩展形式，用于建立因变量与多个自变量之间的关系。在简单线性回归中，我们考虑一个因变量和一个自变量之间的线性关系，而多元线性回归允许我们考虑多个自变量对因变量的影响。
一般的多元线性回归模型的数学表达式如下：
其中：
Y 是因变量（要预测的目标）。X1​,X2​,…,Xn​ 是自变量（特征）。β0​ 是截距（模型在X1​,X2​,…,Xn​ 都为0时的预测值）。β1​,β2​,…,βn​ 是各自变量的回归系数，表示自变量对因变量的影响。ε 是误差项，表示模型无法捕捉到的影响因素和随机误差。 多元线性回归的目标是找到合适的回归系数 β0​,β1​,…,βn​ 来最小化实际观测值 Y 与模型预测值之间的误差，通常使用最小二乘法进行优化。
模型训练后，可以使用这个模型进行预测。当有新的自变量值 X1​,X2​,…,Xn​ 时，通过带入这些值，就可以预测相应的因变量值 Y。
多元线性回归在实际应用中非常常见，例如在经济学中预测商品销售额，医学中预测疾病发生率，工程学中预测产品性能等。
需求：
根据现有数据预测公司的利润
数据示例：
R&amp;D SpendAdministrationMarketing SpendStateProfit165349.2136897.8471784.1New York192261.83162597.7151377.59443898.53California191792.06 程序：
## Step 1: Data Preprocessing ### Importing the libraries import pandas as pd import matplotlib.pyplot as plt import numpy as np ### Importing the dataset dataset = pd.read_csv('50_Startups.csv') X = dataset.iloc[:, :-1].values Y = dataset.iloc[:, 4].values ### Encoding Categorical data from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f35b2bd507d4944fe4590da63636ec2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a6ad86adecc341e4e2d0e078242f960/" rel="bookmark">
			指剑邀请你参与【腾讯2024技术答人挑战赛】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		保持技术好奇心是程序员构建护城河的重要一环，快来测测你现在的技术知识面在中国程序员中排第几？
参与答题更有iPad、Pico VR游戏机、Switch等、腾讯云官方认证证书好礼（ps：另有躺平玩法，邀人答题也有奖）。
扫码海报预约：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c5427399be5eb68df7979faf74864a/" rel="bookmark">
			实现可编辑excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要花钱买的插件有这个 SpreadJS
要在Vue项目中创建可编辑的Excel页面，你可以使用一些Vue插件和库帮助你实现此功能。以下是一个简单的步骤指导：
安装所需的依赖项：
在你的Vue项目目录下，使用以下命令安装xlsx和vue-xlsx库：
npm install xlsx vue-xlsx --save 创建可编辑的Excel页面组件：
在你的Vue项目中创建一个新的组件，例如ExcelPage.vue。在该组件的模板中，你可以使用xlsx和vue-xlsx库提供的组件来实现可编辑的Excel页面。
&lt;template&gt; &lt;div&gt; &lt;h2&gt;Editable Excel Page&lt;/h2&gt; &lt;input type="file" @change="handleFileUpload"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th v-for="(header, index) in tableHeaders" :key="index"&gt; {{ header }} &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="(row, rowIndex) in tableData" :key="rowIndex"&gt; &lt;td v-for="(cell, cellIndex) in row" :key="cellIndex"&gt; &lt;input v-model="tableData[rowIndex][cellIndex]"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;button @click="exportExcel"&gt;Export Excel&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import XLSX from 'xlsx'; import VueXlsx from 'vue-xlsx'; export default { data() { return { tableData: [], // 存储Excel表格数据 tableHeaders: [] // 存储Excel表格的列头 }; }, methods: { handleFileUpload(event) { const file = event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60c5427399be5eb68df7979faf74864a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe3e24b25c1b39b3d56905fdb12a60c/" rel="bookmark">
			【二叉树搜索树/二叉排序树】BST树的创建，插入，找最小结点的下一个节点/找最大结点的前驱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基本概念：创建一棵二叉排序树二叉搜索树结构设计：插入思想：找到二叉排序树的最左边结点，则是最小的**找最小结点的下一个节点。**找最后一个结点找前驱 基本概念： 二叉树搜索树：【二叉排序树】
每个结点都有一个作为搜索一句的关键码,所有的结点的关键码给互不相同左子树（如果存在）所有结点的关键码都小于根结点的关键码右子树（如果存在）所有结点的关键码都大于根节点的关键码左子树和右子树也都是二叉搜索树。 特点：说人话，大的放右边，小的放左边。
如果对一颗二叉排序树进行中序遍历，就可以按照从小到大的顺序，将各个结点的关键码排列。
创建一棵二叉排序树 有三个指向： parent ，leftchild，rightchild
二叉搜索树结构设计： typedef int KeyType; typedef struct { struct BstNode* parent; struct BstNode* leftchild; struct BstNode* rightchild; KeyType* key; }BstNode; typedef struct { BstNode*root; int cursize; }BSTree; 查询函数：
BstNode FindValue(BSTree *tree,int kx) { BStree *ptr = tree-&gt;root; while( ptr!= nullptr || ptr-&gt;key != kx) { ptr = ptr-&gt;key &lt; kx ? ptr-&gt;leftchild:ptr-&gt;rightchild; } return ptr; } BstNode *Search(BstNode*ptr,KeyType kx) { if(ptr == nullptr || ptr-&gt;key == kx) return ptr; else if(kx &gt; ptr-&gt;key) { return Search(ptr-&gt;rightchild,kx);} else {return Search(ptr -&gt;leftchild,kx);} } BstNode *SearchValue(BSTree *ptree,KeyType kx) { return Search(ptree-&gt;root ,KeyType kx) } 插入思想： 先插入根结点。插入后，开始判断根节点是否为空以及待插入的数是否等于当前结点的数，如果不等于空，则保存根节点，并判断kx的值小于还是大于key如果大于，走右边，小于走左边，再次判断如果满足当前结点不为空，是否和当前结点的key值相等，相同返回false否则为空，申请结点，存入kx，并将双亲结点指向它的根结点判断，小于根的左孩子指向它，大于右孩子指向它。 **加个引用就可以改变root int p = &amp;a; int &amp;s = p; 作为s指针p的别名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe3e24b25c1b39b3d56905fdb12a60c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3fa0e436ae2cc6e9348ee821b9fba1/" rel="bookmark">
			【数据结构】（分治策略）中位数的查询和最接近点对问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中位数查询： 寻找一组字符串中第k小的数，返回其值和下标。
不可以有重复值（在缩小规模的时候，会导致程序死循环）
相对位置的转换体现了分治策略的思想。&gt;
划分函数 int partition(int *nums,int left, int right) { int i = left , j = right; int tmp = nums[i]; while (i &lt; j) { while (i&lt;j &amp;&amp; tmp &lt; nums[j]) j--; if (i &lt; j) nums[i] = nums[j]; while (i&lt;j &amp;&amp; tmp &gt;= nums[j]) i++; if (i &lt; j) nums[i] = nums[j]; } nums[i] = tmp; return i; } 1.将待查询数组进行划分，得到num[left] 此时的下标 i（该值的下标将不会在变化）
2.i-left+1计算出i的相对位置j；
3.如果待查的k小于等于j，则从i的左边查，如果大于，从i的右边查。（说明i之前的下标都没有，则待查的k也减去相应j）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3fa0e436ae2cc6e9348ee821b9fba1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc52911f433c7f05224da86f0adcbb3/" rel="bookmark">
			【数据结构】分治策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现场保护和现场恢复
文章目录 分治策略分治法解决问题有以下四个特征：分治法步骤: 递归：解决以下问题：倒序输出整数求最大公约数（递归和非递归）菲波那切数列 不要尝试间接 要使用直接递归（自己调用自己） 分治策略 分治法解决问题有以下四个特征： 该问题的规模小到一定程度就容易解决。把大问题分解成小问题，是将问题的规模变小，而不是将问题变小使用小规模的解，可以合并，该问题原规模的解该问题所分解的各个子模块是相互独立的。 分治法步骤: 在分治策略中递归地求解一个问题，在每层递归中有如下解决步骤：
分解：递归地求解子问题，子问题地形式与原问题一样，只是规模更小。
解决：递归地求解子问题，如果子问题地规模足够小，则停止递归，直接求解
合并：将小规模地解组合成原规模地解
递归函数分为 递推和递归两个过程
每当调用发生：就要分配新的栈帧（形参数据，现场保护，局部变量）；而与普通函数调用不同，由于递推是一个逐层调用的过程，因此存在一个连续的分配栈帧的过程，直至遇到递归终止条件时，才开始回归，这时才会释放栈帧空间，返回到上一层，直到返回到主调函数。
简单的函数调用过程：
递归： 空间复杂程度位S（n）,每次都要开辟栈帧
必要的情况才使用递归（如树形）
不存在死递归的概念（因为栈帧基本就1M,不断开辟栈帧，资源就损耗完了）
循环占用的cpu资源。因此存在死循环。
解决以下问题： 下面程序：
倒序输出整数 Print(int n ) { if(n != 0) { -----&gt; printf("%d ",n%10); 5，4，3，2，1 Print(n/10); 1235 123 12 1 0 开始回归 printf("%d ",n%10); Print(n/10); printf("%d ",n%10);1，2，3，4，5 &lt;---- } return; } 求最大公约数（递归和非递归） int fun(int a, int b) { //求最大公约数 if (b != 0) //退出递归的条件 { return fun(b,a%b); } return a; } int fun1(int a, int b) { //求最大公约数 while (b !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc52911f433c7f05224da86f0adcbb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b6b7ee725c2ab9366ded7d5f4d2fce2/" rel="bookmark">
			【数据结构】快速排序，基数排序/桶排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基数排列 ：
桶排序：低位优先，所有数据从（个位）开始
依次放入10个桶内（入队，再从桶里取出，直到完全有序）。
基数（桶）排序：低位优先，所有数据从低（个）位开始，依次放到对应的桶内（入队），再接着从桶内取出（出队），直到完全有序 时间复杂度O（dn） 空间复杂度O(n) 稳定吗
如下图：
循环的次数和最大值的位数有关
《二维数组实现桶排序》 Get_figure(arr, len); :获取最大值的位数，来作为循环遍历位数的条件
Radix(arr, len, i);：进行将所有数据，按照位数放入桶中，放完之后，再取出来放到arr数组中
Get_Num(arr[i], fin)：获取当前位数所在桶的序号。index获取
static int Get_figure(int* arr, int len) { //assert //获取最大值是多少 int tmp = 0; for (int i = 0; i &lt; len; i++) { if (tmp &lt; arr[i]) { tmp = arr[i]; } } //获取tmp的位数 int count = 0; while (tmp != 0) { count++; tmp = tmp/10; //每次丢掉一个位，直到商变为0 } //while结束，得到的是最大值的位数count return count; } 以fin的规则取n对应的值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b6b7ee725c2ab9366ded7d5f4d2fce2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774bb5a466c49d2aca150ce785510edc/" rel="bookmark">
			【论文阅读|小目标分割算法ASF-YOLO】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文阅读|小目标分割算法ASF-YOLO 摘要（Abstract）1 引言（Introduction）2 相关工作（Related work）2.1 细胞实例分割（Cell instance segmentation）2.2 改进的YOLO用于实例分割（Improved YOLO for instance segmentation） 3 提出的ASF-YOLO（The proposed ASF-YOLO model）3.1 总体框架（Overall architecture）3.2 尺度序列特征融合模块（Scale sequence feature fusion module）3.3 三重特征编码模块（Triple feature encoding module）3.4 通道和位置注意力机制（Channel and position attention mechanism）3.5 锚框优化（Anchor box optimization） 4 实验（Experiments）4.1 数据集（Datasets）4.2 实现细节（Implementation details）4.3 定量结果（Quantitative results）4.4 定性结果（Qualitative results）4.5 消融研究（Ablation study）4.5.1 提出方法的影响（Effect of the proposed methods）4.5.2 注意力机制的影响（Effect of attention mechanisms）4.5.3 骨干网络中卷积模块的影响（Effect of convolution module in the backbone） 5 总结 论文题目：ASF-YOLO: A novel YOLO model with attentional scale sequence fusion for cell instance segmentation
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/774bb5a466c49d2aca150ce785510edc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/306a09c9cb9930060a8afbdbdcdc8fe3/" rel="bookmark">
			Github 2024-01-31 开源项目日报 Top10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据Github Trendings的统计，今日(2024-01-31统计)共有10个项目上榜。根据开发语言中项目的数量，汇总情况如下：
开发语言项目数量Python项目5非开发语言项目3TypeScript项目1Jupyter Notebook项目1C项目1 基于项目的学习 创建周期：2485 天协议类型：MIT LicenseStar数量：153941 个Fork数量：20746 次关注人数：153941 人贡献人数：100 人Open Issues数量：99 个Github地址：https://github.com/practical-tutorials/project-based-learning.git 基于项目的学习是一个由程序员编写的编程教程列表，旨在帮助有志成为软件开发人员的人学习如何从零开始构建应用程序。这些教程涵盖了各种主要的编程语言，并可能涉及多种技术和语言。
现代C++编程课程(C++11/14/17/20) 创建周期：2151 天Star数量：8968 个Fork数量：643 次关注人数：8968 人贡献人数：2 人Open Issues数量：3 个Github地址：https://github.com/federico-busato/Modern-CPP-Programming.git 现代C ++编程课程涵盖C ++11/14/17/20，并全面介绍了现代C ++编程。
从零开始构建大型语言模型 创建周期：190 天开发语言：Jupyter Notebook协议类型：OtherStar数量：3073 个Fork数量：149 次关注人数：3073 人贡献人数：6 人Open Issues数量：0 个Github地址：https://github.com/rasbt/LLMs-from-scratch.git项目首页: https://www.manning.com/books/build-a-large-language-model-from-scratch 《从零开始构建大型语言模型》一书指导读者逐步创建自己的LLM，用清晰的文字、图表和示例解释每个阶段。用于教育目的训练和开发小型功能模型的方法，与创建ChatGPT等大规模基础模型的方法相似。
Yi: 从头开始训练的大型语言模型 创建周期：89 天开发语言：Python协议类型：Apache License 2.0Star数量：5835 个Fork数量：360 次关注人数：5835 人贡献人数：33 人Open Issues数量：36 个Github地址：https://github.com/01-ai/Yi.git项目首页: https://01.ai Yi是由01-ai开发的开源项目，由一系列从头开始训练的大型语言模型组成。
90天网络安全学习计划 创建周期：374 天协议类型：MIT LicenseStar数量：4142 个Fork数量：435 次关注人数：4142 人贡献人数：2 人Open Issues数量：22 个Github地址：https://github.com/farhanashrafdev/90DaysOfCyberSecurity.git 该存储库提供了一个为期90天的网络安全学习计划，提供了学习各种网络安全概念和技术的资源，安排了涵盖Network+、Security+、Linux、Python、Traffic Analysis、Git、ELK、AWS、Azure和Hacking等主题的每日任务。
Lepton AI对话搜索演示 创建周期：6 天开发语言：TypeScript, Python协议类型：Apache License 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/306a09c9cb9930060a8afbdbdcdc8fe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0217b20c3e2fe565a59979388e0f5c1f/" rel="bookmark">
			基于PHP网站登录验证漏洞攻击及修复办法演示系统-计算机毕业源码设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发软件：Dreamweaver + Mysql
开发技术：PHP,HTML,DIV+CSS
在功能上要求可以进行SQL语句的实现，从而可以进行SQL注入漏洞测试，开发人员编写修复程序来对漏洞进行修复。本文首先利用PHP语言开发实现了具有登录功能和注册功能的网站。登录功能，用户在网站的登录界面输入用户名和密码进行身份的验证，进而登录网站，在数据库中的功能表现为SQL语句的查询功能；注册功能，用户输入用户名和密码进行用户身份注册，进而才可以在登录界面上进行登录，在数据库中的功能表现为SQL语句的添加功能。
基于PHP语言进行网络安全防护，将测试数据存储到MySQL数据库中，从网站的登录和注册业务来进行安全性测试，我学习了burpsuite平台的相关知识点，利用burpsuite进行攻击测试，通过一系列的攻击测试，为了使得PHP网站具有冗余性、可靠性和安全性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb808fa34f1f1952da5b2dfcd18fc6e8/" rel="bookmark">
			算法训练营day18, 二叉树7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import "math"
type TreeNode struct {
Val int
Left *TreeNode
Right *TreeNode
}
530. 二叉搜索树的最小绝对差
func getMinimumDifference(root *TreeNode) int {
//初始一个最大值
result := math.MaxInt64
var prev *TreeNode
//同样也要内部封装一个递归函数
var treeTraversal func(tree *TreeNode)
treeTraversal = func(tree *TreeNode) {
if tree == nil {
return
}
treeTraversal(tree.Left)
//如果前一个节点不为空，且当前节点值与上一个节点值差小于result，则把这个差值赋给result
if prev != nil &amp;&amp; tree.Val-prev.Val &lt; result {
result = tree.Val - prev.Val
}
prev = tree
treeTraversal(tree.Right)
}
treeTraversal(root)
return result
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb808fa34f1f1952da5b2dfcd18fc6e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a2d2ce9406ab8176d139f6d99aa554/" rel="bookmark">
			【LLM多模态】Cogview3、DALL-E3、CogVLM、CogVideo模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		note 文章目录 noteVisualGLM-6B模型图生文：CogVLM-17B模型1. 模型架构2. 模型效果 文生图：CogView3模型DALL-E3模型CogVideo模型网易伏羲-丹青模型Reference VisualGLM-6B模型 VisualGLM 是一个依赖于具体语言模型的多模态模型，而CogVLM则是一个更广阔的系列，不仅有基于GLM的双语模型，也有基于Llama2系列的英文模型。这次开源的 17B 模型就是基于Vicuna-7B 的英文模型。
图生文：CogVLM-17B模型 多模态模型CogVLM-17B（开源）：
Github：https://github.com/THUDM/CogVLM
Huggingface：https://huggingface.co/THUDM/CogVLM
魔搭社区：https://www.modelscope.cn/models/ZhipuAI/CogVLM
Paper：https://github.com/THUDM/CogVLM/blob/main/assets/cogvlm-paper.pdf
1. 模型架构 思想：视觉优先
之前的多模态模型：通常都是将图像特征直接对齐到文本特征的输入空间去，并且图像特征的编码器通常规模较小，这种情况下图像可以看成是文本的“附庸”，效果自然有限。
模型共包含四个基本组件：ViT 编码器，MLP 适配器，预训练大语言模型（GPT-style）和视觉专家模块。
ViT编码器：在 CogVLM-17B 中，采用预训练的 EVA2-CLIP-E。MLP 适配器：MLP 适配器是一个两层的 MLP（SwiGLU），用于将 ViT 的输出映射到与词嵌入的文本特征相同的空间。预训练大语言模型：CogVLM 的模型设计与任何现有的 GPT-style的预训练大语言模型兼容。具体来说，CogVLM-17B 采用 Vicuna-7B-v1.5 进行进一步训练；也选择了 GLM 系列模型和 Llama 系列模型做了相应的训练。视觉专家模块：在每层添加一个视觉专家模块，以实现深度的视觉 - 语言特征对齐。具体来说，每层视觉专家模块由一个 QKV 矩阵和一个 MLP 组成。 训练方式：
模型在15亿张图文对上预训练了4096个A100*days，并在构造的视觉定位（visual grounding）数据集上进行二阶段预训练。在对齐阶段，CogVLM使用了各类公开的问答对和私有数据集进行监督微调，使得模型能回答各种不同类型的提问。 2. 模型效果 CogVLM 可以在不牺牲任何 NLP 任务性能的情况下，实现视觉语言特征的深度融合。训练的 CogVLM-17B 是目前多模态权威学术榜单上综合成绩第一的模型，在14个数据集上取得了state-of-the-art或者第二名的成绩。这些基准大致分为三类（共 14 个），包括图像字幕（Image Captioning）、视觉问答（Visual QA）、视觉定位（Visual Grounding）。
文生图：CogView3模型 链接：https://github.com/THUDM/CogView
DALL-E3模型 论文：https://cdn.openai.com/papers/dall-e-3.pdf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53a2d2ce9406ab8176d139f6d99aa554/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e9958ee8ace51642cd028e8d2dbd263/" rel="bookmark">
			在 Android 中使用 C/C&#43;&#43;：初学者综合指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Android 中使用 C/C++：初学者综合指南 一、为什么有人在他们的 Android 项目中需要 C/C++ 支持？二、了解 C++ 如何集成到 Android 应用程序中三、C++和Java程序的编译3.1 Java3.2 Android ART 和 DEX 字节码 四、使用 JNI 包装 C++ 源代码五、CMake和Android NDK5.1 Android NDK 和工具链5.2 什么是 CMake？ 六、共享库和 ABI Java 作为一种编程语言，具有许多良好的功能，使其成为应用程序开发的首选语言。它独立于平台（因为虚拟机执行）、JIT 编译、多线程支持以及为程序员提供的富有表现力的简单语法。由于其与平台无关的特性，Java 包可以跨 CPU 架构移植，这使得库开发变得更加容易，从而增强了插件、构建工具和实用程序包的整体生态系统。
功能数量与性能之间恰好存在权衡。像汇编这样的语言具有最少的内存和执行开销，但从程序员的角度来看，其功能数量也最少。在层次结构中向上移动，C 和 C++ 等语言提供了一组良好的功能，同时保持更接近底层硬件。在它们之上的是Java和Python等语言，它们选择通过使用虚拟机来完全消除平台依赖。用这些语言编写的程序有巨大的开销，但却是开发人员的天堂。
JVM 现在可以访问共享库中公开的函数，并且操作系统根据需要执行它们。
一、为什么有人在他们的 Android 项目中需要 C/C++ 支持？ 正如我们上面的讨论，在我们的系统中，性能比开发人员友好性更重要，这将我们的重点从 Java/Kotlin 转移到了“原生语言”(C/C++)。让我们通过一些示例来了解本机代码的作用及其性能改进，
图形、渲染和交互：在 Jetpack Compose 等高级框架中，开发用户界面并使其看起来有吸引力似乎是小菜一碟。在像素级别，需要进行数千次计算来计算阴影的强度、闪电模式和物体的纹理。这些计算涉及大量使用线性代数结构，例如向量和矩阵及其各自的运算。处理触摸交互，包括处理移动屏幕上触摸传感器的原始坐标，以及区分单击、双击、拖动或滑动手势，也需要大量计算。这些计算可以用更接近硬件的语言更好地执行，从而可以执行额外的优化。机器学习：C/C++ 的作用很容易理解，因为 PyTorch 和 TensorFlow 等流行框架的代码库的主要部分是用 C/C++ 编写的。TensorFlow 使用用 C++ 编写的操作，并提供包装器（接口）来使用 Python 代码中的这些操作。C++ 的采用是显而易见的，作为线性代数运算的代码库，CUDA（用于并行处理）是多年前编写的，并且已经经过多年的考验。使用Python作为TensorFlow的接口之一，只是为了让C/C++的东西看起来整洁，并且对于非编程用户来说也很容易。 图：TensorFlow 源代码片段，显示了 arg_max 操作的实现。图片参考：作者截图自GitHub上TensorFlow官方源代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e9958ee8ace51642cd028e8d2dbd263/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f87d16042fabce9fec7d635a047b2e8/" rel="bookmark">
			Windows驱动开发之环境搭建，长期Waiting for connecting...思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows驱动开发之环境搭建 1、前期准备 Vmware虚拟机软件
Windows10 iso安装包
Visual Studio2022 IDE软件
SDK安装（一定要勾选上debug选项，windbg在里面）
WDK（Windows驱动程序工具包）
WDK安装请参考官方文档：下载 Windows 驱动程序工具包 (WDK) - Windows drivers | Microsoft Learn
第一步：开发环境搭建 注意事项：在安装完WDK后，VisualStudio2022还不能开发驱动程序，因为还未向VisualStudio2022安装WDK的扩展包；需要在WDK安装目录下或使用everything全局搜索“WDK.vsix”文件，安装即可。
打开VisualStudio IDE “新建项目” 后出现上图“Driver”字样说明我们的开发环境搭建完成啦！恭喜完成第一步。
第二步：调试环境搭建 配置虚拟机； 为虚拟机添加一个串行端口
注：添加串口后需要修改串口配置；”使用命名的管道“，配置管道名，修改”另一端是应用程序“（另一端是windbg，故而是应用程序）
配置windbg； 创建一个windbg的桌面快捷方式，设置目标为：“xxx/xxx/windbg.exe” -b -k com:port=\\.\pipe\com_1,baud=115200,pipe
上面的xxx/xxx/windbg.exe替换为自己的windbg.exe路径即可
配置虚拟机中Windows10系统； 需要开启Vmware中的Windows10系统（前期准备里面应该已经安装完成啦!!!）
Windows键，输入“msconfig”，会出现“系统配置”应用，打开即可
打开“引导”标签页，点击“高级选项”按钮，勾选“调试”复选框，选择“COM1”调试端口，调整波特率为“115200”。
后续按下面顺序进行执行即可（内容同其他博客）
以管理身份打开"cmd"
输入”bcdedit“
设置端口1，命令如下：
bcdedit /dbgsettings serial baudrate:115200 debugport:1 复制一个开机选项，命名为“DebugEntry”(可任意命名)。命令如下：
bcdedit /copy {current} /d DebugEntry 增加一个开机引导项
bcdedit /displayorder {current} {ID} 注：这个ID要填写上一条命令生成的一串数字或字母。
激活Debug
bcdedit /debug {ID} ON 注：ID以生成的数字或字母串代替。
重启虚拟机，选择“DebugEntry[debug]”作为启动项
选择好启动项后，立即回到主机，启动windbg。只有在虚拟器系统启动过程中，才能连接上！！！（真的！真的！真的！）否则windbg会一直在下面这个界面上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f87d16042fabce9fec7d635a047b2e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ad57874fcc016295f60f6ef9b26d429/" rel="bookmark">
			Elasticsearch：入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 介绍Elasticsearch 1.1 什么是Elasticsearch Elasticsearch是一款基于开源的分布式搜索和分析引擎，构建在Apache Lucene之上。它旨在提供一个强大且灵活的工具，使用户能够以高效、实时的方式存储、检索和分析大量数据。
1.2 Elasticsearch的主要特点和优势 Elasticsearch的独特之处在于其分布式、实时、多租户的特性。其能够轻松处理海量数据，支持全文搜索、结构化查询等多种灵活的检索方式。同时，具备高可用性和可扩展性，使其成为处理大规模数据的理想选择。
1.3 Elasticsearch在搜索和分析中的应用场景 Elasticsearch在各个行业都有着广泛的应用。在搜索领域，它能够提供快速而准确的搜索结果，适用于网站搜索引擎、电子商务平台等。在数据分析方面，Elasticsearch可以帮助企业实时监控业务指标、分析日志数据，为决策提供有力支持。其多功能性使其成为解决大规模数据管理和分析难题的首选工具。
这仅仅是对Elasticsearch的初步介绍，接下来我们将深入了解安装、配置以及核心概念，以更好地掌握这一强大工具。
2. Elasticsearch的安装和启动 2.1 下载和安装Elasticsearch Elasticsearch的安装是使用该引擎的第一步，确保您选择适用于您操作系统的正确版本。您可以从Elasticsearch官方网站下载相应的安装包，或者通过包管理工具进行安装。详细的安装步骤可以在官方文档中找到，务必按照指导进行操作。
2.2 启动和停止Elasticsearch服务 一旦安装完成，您可以启动Elasticsearch服务。这通常涉及到在命令行中运行相应的命令。同时，确保了解如何停止服务，以便在需要时能够有效地维护和管理系统。
2.3 Elasticsearch的基本配置 在启动之前，了解如何配置Elasticsearch是至关重要的。通过编辑配置文件，您可以调整集群的行为，指定数据存储位置，配置网络绑定等。理解这些配置选项对于根据您的需求定制Elasticsearch至关重要。
通过正确的配置，您可以确保Elasticsearch能够适应您特定的使用场景，提供最佳性能和稳定性。深入了解配置选项，可以使您更好地利用Elasticsearch的强大功能，让其更好地适应您的工作流程。
3. Elasticsearch的基本概念 3.1 Index（索引）的概念 在Elasticsearch中，索引是数据的逻辑容器，类似于关系数据库中的数据库。每个索引包含一组相关的文档，而这些文档则是实际存储数据的基本单元。索引的创建和管理是为了更有效地组织和检索数据，同时提供快速的搜索性能。
3.2 Type（类型）的概念 尽管在Elasticsearch 7.x版本以及更新版本中已经逐渐被废弃，但了解类型仍然有助于理解文档的结构。在早期版本中，索引可以包含多个类型，每个类型定义了不同种类的文档。然而，现代Elasticsearch更推崇使用单一索引中的多字段来代替多类型，以提高性能和简化管理。
3.3 Document（文档）的概念 文档是Elasticsearch中的基本信息单元。它们以JSON格式表示，可以包含各种数据类型，例如文本、数字、日期等。每个文档都有一个唯一的ID，通过ID进行检索和更新。文档是构建索引的核心，它们被组织在索引中，以便进行快速、实时的搜索和分析。
3.4 Shard和Replica的作用 分片（Shard）是Elasticsearch中水平拆分数据的方式，每个分片是独立的索引单元，可以存储在集群的不同节点上。这种分片机制使得Elasticsearch能够处理大规模数据，并实现分布式的存储和计算。同时，副本（Replica）是每个分片的复制，用于提高系统的可用性和容错性。
深刻理解这些基本概念，将有助于您更好地设计和管理Elasticsearch索引，优化搜索性能，并确保数据的可靠性。
4. Elasticsearch的REST API 4.1 Elasticsearch的HTTP RESTful API Elasticsearch提供了丰富而强大的HTTP RESTful API，允许用户以简单而灵活的方式与集群进行交互。这些API覆盖了从索引管理到搜索和聚合的各个方面。通过RESTful API，用户可以通过HTTP请求执行索引创建、文档更新、搜索查询等操作，使得与Elasticsearch的交互变得直观而可扩展。
4.2 使用curl进行基本操作 curl是一个命令行工具，用于通过HTTP协议与Elasticsearch集群通信。通过curl，您可以执行各种操作，如创建索引、添加文档、执行搜索等。了解如何使用curl进行基本操作是掌握Elasticsearch的关键一步，它使您能够直接在终端中与集群进行交互，方便快捷。
4.3 使用Kibana进行可视化操作 Kibana是Elasticsearch官方提供的开源数据可视化工具。它提供了直观且强大的用户界面，使用户能够通过图表、仪表盘等形式轻松地可视化和分析数据。通过Kibana，您可以深入了解集群的运行状况、执行高级搜索、创建仪表盘等，为数据分析提供直观的界面和工具。
深入了解Elasticsearch的REST API，以及如何使用curl和Kibana进行交互，将使您能够更灵活地操作数据、执行高级查询，并通过可视化工具更好地理解和展示数据。
5. 索引的管理和操作 5.1 创建、删除索引 索引的创建和删除是使用Elasticsearch的基本操作之一。通过HTTP RESTful API或者Kibana界面，您可以轻松创建新的索引，定义其设置和映射。创建索引时，考虑到数据的特性和使用场景，选择合适的分片和副本配置是至关重要的。同时，索引的删除也是管理数据的一部分，但请确保在删除索引之前，您已充分了解其对数据的影响。
5.2 映射（Mapping）的定义 映射是Elasticsearch中非常重要的概念，它定义了索引中的字段类型和属性。通过映射，您可以告诉Elasticsearch如何处理每个字段，包括文本分析、日期解析、数字处理等。合理定义映射有助于提高搜索性能和数据的准确性。在创建索引时，您可以显式定义映射，也可以让Elasticsearch根据数据自动推断映射。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ad57874fcc016295f60f6ef9b26d429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f673cba0981d91bc91270c36da5a4c9a/" rel="bookmark">
			c语言 ceil（） 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ceil()是C语言中的一个数学函数，用于向上取整。它的函数原型定义在math.h头文件中。
ceil()函数的作用是返回一个大于或等于给定参数的最小整数值，即将参数向上取整到最接近的整数。返回值的数据类型为double。
以下是ceil()函数的函数原型：
double ceil(double x); 参数x可以是任意实数，包括正数、负数和零。ceil()函数会将x向上取整到最接近的整数，并返回结果。
例如，ceil(2.4)的结果是3.0，ceil(-3.7)的结果是-3.0。
需要注意的是，使用ceil()函数之前需要包含math.h头文件，并且需要链接数学库（在编译时加上-lm选项）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0445a25f349fec5c3638dfe85bb5b800/" rel="bookmark">
			MySQL--表数据的添加和查询操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 1. 基于当前的四张表 完成数据的添加操作(每张表添加两条数据)
2. 完成查询操作(课堂内所有Demo)
1-2. 根据生日降序（DESC）[升序ASC]排序查看各学生信息： SELECT * FROM student ORDER BY BORNDate DESC; #LIMIT 初始行数 容量数 SELECT * FROM student ORDER BY BORNDate DESC.LIMIT 9,5 查询学生姓名、生日、性别，所在班级名称： SELECT student.StudentName,student.BornDate,student.Sex,grade.GradeName FORM student INNER JOIN grade ON student.GradeId = grade.GradeId; 查询学生姓名，参考科目名，考试成绩： SELECT student.StudentName,'subject'.SubjectName,result.StudentResult FROM result,student,subject WHERE result.StudentNo = student.StudentNo AND result.SubjectNo ='subject'.SubjectNo; #或 SELECT student.StudentName,'subject'.StudentName,result.StudentResult FROM result INNER JOIN student ON result .StudentNo = student.StudentNo INNER JOIN student ON result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0445a25f349fec5c3638dfe85bb5b800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d238f3325ccc44fa10637672a7acca3/" rel="bookmark">
			【算法】【环形数组处理技巧、枚举】力扣2808. 使循环数组所有元素相等的最少秒数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2808. 使循环数组所有元素相等的最少秒数
文章目录 【算法】力扣2808. 使循环数组所有元素相等的最少秒数题目描述输入输出示例 解题思路算法步骤Python3代码实现C++代码实现GO实现复杂度分析 总结 【算法】力扣2808. 使循环数组所有元素相等的最少秒数 题目描述 在这道题目中，我们得到了一个循环数组nums，其长度为n。我们的目标是通过每秒钟进行一次数组变换，最终使得所有元素相等。数组变换的规则是，对于数组中的任意元素nums[i]，可以将其替换为其左侧或右侧元素（考虑数组为循环数组）。题目要求我们找到实现数组所有元素相等的最少秒数。
输入输出示例 示例 1：
输入：nums = [1,2,1,2]输出：1解释： 按照题目描述的替换规则，1秒内我们可以将数组中的所有元素变为2。 示例 2：
输入：nums = [2,1,3,3,2]输出：2解释： 通过两次替换操作，我们可以将数组变成[3,3,3,3,3]。 示例 3：
输入：nums = [5,5,5,5]输出：0解释： 数组已经是所有元素相等的状态，无需进行操作。 解题思路 本题的关键在于理解变换操作对数组元素的影响。考虑到可替换的元素为nums[(i - 1 + n) % n] 或者 nums[(i + 1) % n]，即数组是循环的，我们可以将原数组复制并连接到其自身的末尾，从而形成一个方便处理的扩展数组。这样，原本循环的边界条件就变成了顺序数组的处理问题。
算法步骤 利用哈希表存储每个元素及其所有出现的位置。枚举原数组中所有不同的元素，计算如果以该元素作为最终相等元素所需的时间。对于每个元素，找到其在数组中每最近一对之间的距离所对应的最大修改秒数。记录使元素相等的最少秒数，即所有最大距离中的最小值。 Python3代码实现 from collections import defaultdict from itertools import pairwise class Solution: def minimumSeconds(self, nums: List[int]) -&gt; int: # 哈希表存储每个元素及其在数组中的位置 ele_idxes = defaultdict(list) # 遍历数组，填充哈希表 for i, x in enumerate(nums): ele_idxes[x].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d238f3325ccc44fa10637672a7acca3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c27eca28379a77046ec58b750fee8a81/" rel="bookmark">
			【蓝桥备赛】数字王国之军训排队——DFS深度优先搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接 数字王国之军训排队
个人思路 一般最坏情况，就是这几个数都存在倍数关系，那么就是 n 个数分成 n 个队。然后本题 n 的范围不大，可以枚举 1 ~ n 得到，如果数字范围大可以考虑进行二分。从 1 ~ n ,第一次满足条件的队伍数，即答案，输出即可。
对于每一种队伍情况，使用dfs遍历每个数可以存放的队列，如果当前队列存在能被整除的数，则换下一个队；如果能放入当前队，则继续看下一个数。
先放入大的数，再放入小的数，肯定较小的数除以较大的数无法整除，所以需要先对数组排序。
for(int i = 1; i &lt;= team; ++i) { int flag = 1; for(const auto j : record[i]) { if(arr[x] % j == 0) { flag = 0; break; } } if(flag) { record[i].push_back(arr[x]); if(dfs(x + 1, team)) return true; record[i].pop_back(); } } 参考代码 Java import java.io.*; import java.util.*; public class Main { static int n; static int[] arr; static List&lt;Integer&gt;[] record; static boolean dfs(int now, int team) { if (now == n) return true; for (int i = 0; i &lt; team; i++) { List&lt;Integer&gt; list = record[i]; boolean flag = true; for (int j : list) { if (arr[now] % j == 0) { flag = false; break; } } if (flag) { list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c27eca28379a77046ec58b750fee8a81/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/4/">«</a>
	<span class="pagination__item pagination__item--current">5/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/6/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>