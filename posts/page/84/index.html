<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0664d051ccd08236963daf94c32ec08/" rel="bookmark">
			JAVA复习【13】Map的三种遍历方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一.Iterator迭代器遍历Map集合。
01 KeySet遍历
使用Iterator迭代器遍历Map集合，需要先将Map集合转换为Iterator接口对象，然后进行遍历，由于Map集合中元素是由键值对组成的，所以使用Iterator接口遍历Map集合，会有2中将Map集合转换为Iterator接口对象再进行遍历的方法，即KeySet()方法和entrySet()方法。
KeySet方法需要先将Map集合中所有键对象转换为Set单列集合，接着将包含键对象的Set集合转换为Iterator接口对象，然后遍历Map集合中所有的键，然后获取相应的值。
import java.util.*; public class Iterator1{ public static void main(string[]args]){ Map map=new HashMap(); map.put("1","Jack"); map.put("2","Rose"); map.put("3","Lucy"); System.out.println(map);//{1=Jack,2=Rose,3=Lucy} Set keySet=map.keySet();//获取键的集合 Iterator it=keySet.iterator();//获取Iterator对象 while(it.hasNext()){//判断是否结束，没结束就继续读 Object key=it.next(); Object value=map.get(key);//获取每个键所对于的值 System.out.println(key+":"+value);//1:jack 2:Rose 3:Lucy } } } 02 EntrySet遍历
Iterator迭代器遍历集合的另一种方式是使用entrySet()方法，该方法将原有Map集合中的键值对作为一个整体返回为Set集合，接着将包含键值对对象的Set集合转换为Iterator接口对象，然后获取集合中所有的键值对映关系，再从映射关系中取值。Map类提供了一个称为entrySet()的方法，这个方法返回一个Map.Entry实例化后的对象集。 接着，Map.Entry类提供了一个getKey()方法和一个getValue()方法.
import java.util.*; public class Iterator2{ public static void main(string[]args]){ Map map=new HashMap(); map.put("1","Jack"); map.put("2","Rose"); map.put("3","Lucy"); System.out.println(map);//{1=Jack,2=Rose,3=Lucy} Set entrySet=map.entrySet(); Iterator it=entrySet.iterator();//获取Iterator对象 while(it.hasNext()){ Map.Entry entry=(Map.Entry)(it.next());//返回一个Map.Entry实例化后的对象集 Object key=entry.getKey();//获取entry中的键 Object value=entry.getValue();//获取entry中的值 System.out.println(key+":"+value);//1:jack 2:Rose 3:Lucy } } } 首先调用Map对象的entrySet()方法获得存储Map中所有键值映射的Set集合，这个集合中存放了Map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0664d051ccd08236963daf94c32ec08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86402efd3c2fe18e9995e8f5e34d6d7c/" rel="bookmark">
			【fastadmin】利用后台清除缓存按钮，来清除自定义的缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 业务处后台 业务处 if (!function_exists('get_shopro_config')) { function get_shopro_config($name, $field) { $cache_key = 'shopro_config_' . $name . '_' . $field; $cache_data = cache($cache_key); if (!empty($cache_data)) return $cache_data; $value = \think\Db::name('shopro_config')-&gt;where(['name' =&gt; $name])-&gt;value('value'); if (empty($value)) { $config_value = ''; } else { $value_arr = json_decode($value, true); if (!empty($value_arr[$field])) { $config_value = $value_arr[$field]; } else { $config_value = ''; } } \think\Cache::tag('shopro_config')-&gt;set($cache_key, $config_value, 3600); return $config_value; } } 代码 \think\Cache::tag('shopro_config')-&gt;set($cache_key, $config_value, 3600);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86402efd3c2fe18e9995e8f5e34d6d7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e978e3da07e07345fae9cd6f9df5506/" rel="bookmark">
			C语言学习第二天：解决中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天成功配置了Vscode的编译环境，但是并未注意编译时的中文运行出现乱码的问题，所以今天查阅资料解决了这个问题。
1.解决中文乱码问题
我们可以看到，源代码上的中文当我们运行时，终端里出现了乱码
解决这一问题首先点击“文件”，找到“首选项”里的“设置”并打开它
然后点击“文本编辑器”里的“文件”，找到“Encoding”,可以看到默认选项是“UTF-8”
将其改为“Simplifide Chinese”
重启Vscode，我们会发现源代码中的“解决中文乱码问题”变成了之前运行发出的一串乱码
把它删除，再次输入“解决中文乱码问题”
此时运行，我们就会发现输出的结果为已经不是乱码了，这样中文乱码的问题就解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bafb1a4a6e0d324926cfabb175ade48/" rel="bookmark">
			使用fromelf把axf文件转换成elf格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FROMELF用法
命令格式：
fromelf [options] input_file fromelf -h即可打印出帮助信息。
Product: MDK Plus 5.29 Component: ARM Compiler 5.06 update 6 (build 750) Tool: fromelf [4d35e3] For support see http://www.arm.com/support Software supplied by: ARM Limited ARM image conversion utility fromelf [options] input_file Options: --help display this help screen --vsn display version information --output file the output file. (defaults to stdout for -text format) --nodebug do not put debug areas in the output image --nolinkview do not put sections in the output image Binary Output Formats: --bin Plain Binary --m32 Motorola 32 bit Hex --i32 Intel 32 bit Hex --vhx Byte Oriented Hex format --base addr Optionally set base address for m32,i32 Output Formats Requiring Debug Information --fieldoffsets Assembly Language Description of Structures/Classes --expandarrays Arrays inside and outside structures are expanded Other Output Formats: --elf ELF --text Text Information Flags for Text Information -v verbose -a print data addresses (For images built with debug) -c disassemble code -d print contents of data section -e print exception tables -g print debug tables -r print relocation information -s print symbol table -t print string table -y print dynamic segment contents -z print code and data size information 中文：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bafb1a4a6e0d324926cfabb175ade48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7471ee533faa7d80bda0e21fe5ec9d0/" rel="bookmark">
			怎么上传上传图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上传图片的方法可能会因为使用的软件或网站的不同而有所差异，但通常来说，都可以按照以下步骤来上传图片：
打开你要使用的软件或网站，例如图床、社交媒体平台、在线文档编辑器等。
查找并点击上传图片的按钮，通常情况下会有一个“浏览”或“选择文件”的按钮。
在弹出的对话框中，找到你要上传的图片文件，并选择它。
点击“打开”或“选择”按钮，开始上传图片。
等待上传完成，完成后通常会有一个确认信息或预览图片的界面。
点击确认或完成按钮，上传图片完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9970bf0b4995b9dc1626724c2c76a263/" rel="bookmark">
			Mac Neo4j的安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载地址
选择Community Serve，选择对应的系统下的压缩包下载
这里我直接使用的是Neo4j Desktop绿色安装。
1：打开Neo4j Desktop
2：窗口左上角Projects的右边，点击New-&gt;新建项目，然后在右边的点击Add添加一个数据库，并命名text123，密码123。
3：点击Start，启动，过程还真是有点漫长呀！
4：启动后，就可以点击Open，在网页中浏览了。
这时候界面是没有任何节点的，这里我们就使用python来创建节点和关系。
怎么创建？需要用到中间件：py2neo
至于怎么安装python就不在这里细说，自己百度。
py2neo安装命令:pip install py2neo
安装成功后，输入命令行:pip list就能看到py2neo和对应的版本了
这里我踩了个坑就是：电脑有两个pip，一个是全局的pip，一个是conda里面的pip。为了让conda里面的pip生效，我直接配置了环境变量：alias pip=/opt/anaconda3/envs/pytorch/bin/pip3
现在开始敲代码：
坑一：http://localhost:7474这个要改成bolt://localhost:7687
from py2neo import Graph, Node graph = Graph("bolt://localhost:7687", auth=("neo4j", "123")) Person2 = Node('Person', name='于一博') graph.create(Person2) # 创建结点 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/825835f17b6e2029d4bae28056f300a3/" rel="bookmark">
			【latex】表格添加注脚；对表格的内容进行注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法：调用threeparttable包 在文档的最前面加入以下命令： \usepackage{threeparttable} 在表格处插入命令
\begin{table*} \label{table:number} \centering \caption{....} \begin{threeparttable} \begin{tabular}{lc} \hline A &amp; B \\ \hline A &amp; B\tnote{*} \\ A\tnote{**} &amp; B \\ % 添加表格信息 \hline \end{tabular} \begin{tablenotes} \footnotesize \item[*] this is the .... %此处加入注释*信息 \item[**] my website is ... %此处加入注释**信息 \end{tablenotes} \end{threeparttable} \end{table*} 注意：星号可以换成数字或是其他的字符。
完整例子测试
\documentclass[12pt]{amsart} \usepackage{geometry} % see geometry.pdf on how to lay out the page. There's lots. \geometry{a4paper} % or letter or a5paper or ... etc \usepackage{threeparttable} \title{test} \author{tsta} \date{} % delete this line to display the current date %%% BEGIN DOCUMENT \begin{document} \maketitle \tableofcontents \section{Test1} \subsection{Table} \begin{table*} \label{table:number} \centering \caption{.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/825835f17b6e2029d4bae28056f300a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2af922d27cf47905dd9207590282c68/" rel="bookmark">
			使用 jQuery 滚动到一个元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问： 我有这个 input 元素：
然后我有一些其他元素，比如其他标签的 &amp; 个标签等…
当用户点击 时，页面应该滚动到页面的最后一个元素，并且应该使用漂亮的动画来做到这一点（应该是滚动到底部而不是顶部）。
页面的最后一项是带有 #submit 的 submit 按钮：
动画不应该太快，应该是流畅的。
我正在运行最新的 jQuery 版本。我宁愿不安装任何插件，而是使用默认的 jQuery 功能来实现这一点。
答1: huntsbot.com提供全网独家一站式外包任务、远程工作、创意产品分享与订阅服务!
假设您有一个 ID 为 button 的按钮，请尝试以下示例：
$("#button").click(function() { $([document.documentElement, document.body]).animate({ scrollTop: $("#elementtoScrollToID").offset().top }, 2000); }); 我从文章 Smoothly scroll to an element without a jQuery plugin 中获得了代码。我已经在下面的示例中对其进行了测试。
$(document).ready(function (){ $("#click").click(function (){ $('html, body').animate({ scrollTop: $("#div1").offset().top }, 2000); } ); }); 测试 测试2 点我 这并非在所有情况下都有效。请参阅stackoverflow.com/questions/2905867/…
如果您不想要动画，而是想立即跳转到元素，请使用 .scrollTop(…) 而不是 .animate({scrollTop: …}, …)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2af922d27cf47905dd9207590282c68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efcf8d080b4732cd2608351abe73f39b/" rel="bookmark">
			【AndroidStudio】Android文件存储保存登录用户名和密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MainActivity.java package com.example.filesystem; import androidx.appcompat.app.AppCompatActivity; import android.content.Intent; import android.content.SharedPreferences; import android.os.Bundle; import android.view.View; import android.widget.EditText; import android.widget.TextView; import android.widget.Toast; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); SharedPreferences sp = getSharedPreferences("data",MODE_PRIVATE); String phone= sp.getString("phone_number",""); String password = sp.getString("password_number", ""); if(phone.equals("158")&amp;&amp;password.equals("123456")){ Toast.makeText(MainActivity.this,"已自动填充账号和密码",Toast.LENGTH_SHORT).show(); EditText phone_text = (EditText) findViewById(R.id.phone); EditText pass_text = (EditText) findViewById(R.id.pass); phone_text.setText(phone); pass_text.setText(password); } } public void lgoin(View view){ EditText phone_text = (EditText) findViewById(R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efcf8d080b4732cd2608351abe73f39b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d10da99aa53f547859a5609e24975e/" rel="bookmark">
			Python学习：同步异步阻塞与非阻塞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、状态介绍 在了解其他概念之前，我们首先要了解进程的几个状态。在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。
就绪(Ready)状态：当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。执行/运行（Running）状态当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。阻塞(Blocked)状态正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。 二、同步和异步 所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。
例子
第一种 ：选择排队等候；第二种 ：选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了； 第一种：前者(排队等候)就是同步等待消息通知，也就是我要一直在等待银行办理业务情况；
第二种：后者(等待别人通知)就是异步等待消息通知。在异步消息处理中，等待消息通知者(在这个例子中就是等待办理业务的人)往往注册一个回调机制，在所等待的事件被触发时由触发机制(在这里是柜台的人)通过某种机制(在这里是写在小纸条上的号码，喊号)找到等待该事件的人。
三、阻塞和非阻塞 例子
继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。
相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。
注意：同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。
四、同步/异步和阻塞/非阻塞 1.异步阻塞形式
如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发（通知），也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面。
异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。
2.同步非阻塞形式
想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。
3.异步非阻塞形式
因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。
比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。
总结 很多人会把同步和阻塞混淆，是因为很多时候同步操作会以阻塞的形式表现出来，同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a87f7dbb542bf1d46ec636b1f8488d1/" rel="bookmark">
			内网安全-横向移动-IPC&amp;AT&amp;atexec
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基础配置
环境
实验目标 实验 域横向移动-IPC-命令版-at&amp;schtasks
域横向移动-IPC-代理版-Socks&amp;Py&amp;atexec
基础配置 环境 Server2008系统：192.168.52.132
Server2016系统：192.168.52.128
win7系统： 192.168.52.130（无法出网），192.168.36.130（可以出网)
Server2008系统，域控制器的DC，ip地址为192.168.52.132，无法出网
Server2016系统，域成员，ip地址为192.168.52.128，无法出网
Win7系统，域成员，ip地址为192.168.52.130（无法出网），192.168.36.130（可以出网)
实验目标 win7、server2008和server2016在同一个域内，利用win可以上网的优势获取win7的webshell，以win7利用点横向移动使其他服务器上线cs。
实验 域横向移动-IPC-命令版-at&amp;schtasks 实验过程：获取出网主机shell------复制后门脚本到目标路径-----利用at命令执行脚本-----利用cs链接
先利用cs的后门脚本上传到win7，使win7上线cs。
实战场景获取win7的webshell，利用web漏洞、数据库、中间件和插件都可以。（并非本篇文章重点，所以直接用虚拟机操作）
通过time和user命令分别判断win7系统是否在域内和域内的用户
shell net time /domain 获取域内的时间，判断系统是否存在域
shell net user /domain 获取域内的用户
利用cs的端口扫描功能对会话进行扫描，因为通过36网段上线的cs，所以可以判断域在52网段，实战场景中可以都扫一下。
可以发现分别存在130、132和128三个地址，证明该网段的域存在三个主机
注意：1、端口扫描如要管理权限，非管理权限提权后进行
2、因为目标时扫描网段存在的ip，所以不需要扫描全部端口，只需要扫描常开端口即可 在目标列表中也发现了三台主机，利用会话在凭证提权里抓取明文密码和hash值，可以发现能简单的获取win7的账号密码和一些信息。
现在已经获取了win7的信息，并且知道了域中的ip地址，那么实现让其他主机上线，
测试地址：192.168.52.132地址
创建监听器，本地采用正向连接，所以使用tcp进行链接 基于监听器创建后门脚本
接下来就是将后门脚本放入到目标地址中即可。先利用win7的shell与132网段建立api链接
通过命令查看当前win7所在的目录并在对应的目录下上传后门脚本，方便一会利用绝对路径下载。
Windows：chdir
Linux：pwd 在利用命令把win7目录下的脚本复制到目标目录，利用at的计时命令去执行脚本实现其上线。
复制命令：shell copy DC.exe \\192.168.52.132\$c
将后门的DC文件复制到目标的C盘
执行命令：shell at \\192.168.52.132 11:26 c:\DC.exe
利用at命令让132地址的DC文件在11：26执行
时间到之后会自动自行DC文件，直接connect连接目标地址，即可通过130地址上线132地址
连接命令：connect IP地址 端口
注意：
at命令适用于版本 &lt; windows2012
schtasks适用于 &gt;=Windows2012，原理与at命令相似，命令如下，不在演示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a87f7dbb542bf1d46ec636b1f8488d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6095c35105267afdaecfd385e7397eda/" rel="bookmark">
			循环展开的方法--国科大体系结构 期末必考题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何进行循环展开，是胡老师体系结构课的一个重点，也是必考点。根据20年的经验，在助教汪老师的精心准备下，成功让很多小伙伴没有拿到分数，希望接下来的同学们加油。
听说 LoongArch 出了，我是不是白写了。。。
循环展开的意义 写在前面，我会在指令前加序号，同时在分析时直接用序号来描述指令。
进行循环展开，是为了尽量避免指令相关造成的流水线等待。
直奔题目而言，是通过将多次（大于等于两次）的循环指令展开为一次的循环指令，从而将数据相关消除。不考虑结构相关。
如
// 注： L.D S.D有时候写成 LDC1 SDC1 1 L.D F2, 0(R1) 2 MUL.D F4, F2, F0 // 第二条指令使用了第一条LD指令取数寄存器F2 3 L.D F6, 0(R2)	4 ADD.D F6, F4, F6 // 第四条指令使用了第三条LD指令取数寄存器F6，以及第二条指令的运算结果寄存器F4 5 S.D 0(R2), F6	// 第五条指令使用了第四条LD指令的运算结果寄存器F6 可以看到存在四组数据相关
1 和 2
2 和 4
3 和 4
4 和 5
按照课本中的延迟
延迟为n，两条相关指令中需要间隔n-1条不相关的指令才算达到循环展开的目的：消除数据相关。
即：
1 和 2 延迟为2，之间需要加上 1 条不相关指令
2 和 4 延迟为4，之间需要加上 2 条不相关指令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6095c35105267afdaecfd385e7397eda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72adf6cf9904c2e028b6e87cc6a57daf/" rel="bookmark">
			通过指针消除字符串重复项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思路：定义两个指针，一个指针p在前固定一个值，一个指针q在后从后往前与*p的值相比较，若相同则把后一项值赋值给前一项。
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main(int argc, const char *argv[]) { char s[32]={0},i,j; char *p = s; char *q = s; printf("请输入字符串："); gets(s); for(i=0;i&lt;strlen(s);i++) { for(j=strlen(s);j&gt;i;j--) { if(*(p+i)==*(q+j)) { *(q+j)=*(q+j+1); } } } printf("去重结果为：%s\n",p); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69295150aff1459cc1d5f15dc3517006/" rel="bookmark">
			Java安全之SnakeYaml反序列化分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java安全之SnakeYaml反序列化分析 0x00 前言 偶然间看到SnakeYaml的资料感觉挺有意思，发现SnakeYaml也存在反序列化利用的问题。借此来分析一波。
0x01 SnakeYaml 使用 SnakeYaml 简介 SnakeYaml是用来解析yaml的格式，可用于Java对象的序列化、反序列化。
SnakeYaml 使用 导入依赖jar包
&lt;dependency&gt; &lt;groupId&gt;org.yaml&lt;/groupId&gt; &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt; &lt;version&gt;1.27&lt;/version&gt; &lt;/dependency&gt; 常用方法 String	dump(Object data) 将Java对象序列化为YAML字符串。 void	dump(Object data, Writer output) 将Java对象序列化为YAML流。 String	dumpAll(Iterator&lt;? extends Object&gt; data) 将一系列Java对象序列化为YAML字符串。 void	dumpAll(Iterator&lt;? extends Object&gt; data, Writer output) 将一系列Java对象序列化为YAML流。 String	dumpAs(Object data, Tag rootTag, DumperOptions.FlowStyle flowStyle) 将Java对象序列化为YAML字符串。 String	dumpAsMap(Object data) 将Java对象序列化为YAML字符串。 &lt;T&gt; T	load(InputStream io) 解析流中唯一的YAML文档，并生成相应的Java对象。 &lt;T&gt; T	load(Reader io) 解析流中唯一的YAML文档，并生成相应的Java对象。 &lt;T&gt; T	load(String yaml) 解析字符串中唯一的YAML文档，并生成相应的Java对象。 Iterable&lt;Object&gt;	loadAll(InputStream yaml) 解析流中的所有YAML文档，并生成相应的Java对象。 Iterable&lt;Object&gt;	loadAll(Reader yaml) 解析字符串中的所有YAML文档，并生成相应的Java对象。 Iterable&lt;Object&gt;	loadAll(String yaml) 解析字符串中的所有YAML文档，并生成相应的Java对象。 序列化 Myclass类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69295150aff1459cc1d5f15dc3517006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/102db70384fed4c1a87c00dc96f636a7/" rel="bookmark">
			el-menu刷新回到默认
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般在写后台管理系统，使用menu组件，每个都是一条路由，然而，有时候我们在某个路由上刷新一下，路由还保留着，但是menu-item的高亮效果却到了默认的那一项上，就很无语,下面是我改良过的，
思路嘛，就是把el-menu的default-active这个属性不给它常量，给它一个变量，这个变量在onmouted生命周期中拿到路由对象的path即可在刷新后保持高亮状态
&lt;el-menu :default-active="defaultRoute" active-text-color="#fb9337" class="el-menu-vertical-demo" @select="handleSelect" &gt; &lt;el-menu-item index="/index/business"&gt; &lt;el-icon&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt; &lt;span&gt;出差申请&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index="/index/outside"&gt; &lt;el-icon&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt; &lt;span&gt;外勤打卡&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index="/index/leave"&gt; &lt;el-icon&gt;&lt;document /&gt;&lt;/el-icon&gt; &lt;span&gt;请假申请&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index="/index/work"&gt; &lt;el-icon&gt;&lt;setting /&gt;&lt;/el-icon&gt; &lt;span&gt;加班申请&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;script setup&gt; import { onMounted,ref } from 'vue' import {useRouter,useRoute} from 'vue-router' var $router=useRouter() var $route=useRoute() var defaultRoute = ref('') var handleSelect=(index)=&gt;{ console.log(index) $router.push(index) } onMounted(()=&gt;{ defaultRoute.value=$route.path console.log($route.path) }) &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e732f64f2b712c0d37a44f37a008db7b/" rel="bookmark">
			Anaconda 彻底删除虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Anaconda 彻底删除虚拟环境 当我们要彻底删除在anaconda下创建的某个虚拟环境时，大部分博客提供的方法是：
conda remove -n env_name --all 但是使用这种办法删除某个虚拟环境时，某些情况使用conda env list发现仍可以看见该虚拟环境。
通过查找资料发现使用以下命令可以彻底删除虚拟环境。
conda env remove -n env_name 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb648ee7831cbacbd079b4cd11d5c985/" rel="bookmark">
			【Pycharm教程】PyCharm 配置 Python 项目运行和调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyCharm 使用运行/调试配置来运行、调试和测试您的代码。每个配置都是一组命名的启动属性，它们定义要执行的内容以及应该使用的参数和环境。
使用不同的启动属性，您可以定义 PyCharm 用来执行脚本的不同方式。例如，您可以使用不同的 Python 解释器执行相同的代码，提供各种环境变量集，并从替代文件中获取输入值。
有两种类型的运行/调试配置：
临时的——每次运行或调试函数或测试时创建。
永久- 从模板显式创建或通过保存临时配置创建。永久配置保留为项目的一部分，直到您将其删除。
因此，每当您运行/调试或测试代码时，PyCharm 要么使用现有的永久运行/调试配置，要么创建一个新的临时配置。
永久配置的图标是不透明的，而临时配置的图标是半透明的。
临时配置的最大数量为5个。添加新配置时，旧配置会自动删除。如有必要，您可以在Settings/Preferences |中增加此限制。高级设置 | IDE | 临时配置限制。
创建永久运行/调试配置 PyCharm 提供以下方法来创建永久运行/调试配置：
将临时运行/调试配置保存为永久。
从模板创建或复制现有配置。
将临时配置另存为永久 在运行/调试配置切换器中选择一个临时配置，然后单击保存配置。
保存临时配置后，它将成为永久配置，并记录在 /.idea/目录中的单独 XML 文件中。例如，MyProject /.idea /Car.xml。
或者，在运行/调试配置对话框中选择一个临时配置，然后单击
工具栏上的 。
PyCharm为不同的语言、工具和框架提供运行/调试配置模板。可用模板列表因已安装和启用的插件而异。
从模板创建运行/调试配置 1. 从主菜单中，选择运行 | 编辑配置。或者，按Alt+Shift+F10，然后按0。
2. 在“运行/调试配置”对话框中，单击
工具栏上的 或按Alt+Insert。该列表显示运行/调试配置模板。
3. 在名称字段中指定运行/调试配置名称。此名称将显示在可用的运行/调试配置列表中。
4. 如果您希望允许配置的多个实例同时运行，请选择允许并行运行。如果禁用此选项，尝试重新运行配置将终止活动会话。
5. 设置运行/调试配置参数。
6. 在启动前部分，定义是否要在启动应用程序之前执行任何特定操作，例如，在启动运行/调试配置之前执行一些工具或脚本。
7. 应用更改并关闭对话框。
共享运行/调试配置 如果您在团队中工作，您可能希望共享您的运行/调试配置，以便您的队友可以使用相同的配置运行应用程序，或者使他们能够远程附加到您正在运行的进程。
出于这些目的，PyCharm 提供了一种将运行/调试配置存储为项目文件并通过 VCS 共享它们的机制。当您想将配置作为文件发送给其他人时，也可以使用相同的机制。这可以节省大量时间，因为运行/调试配置有时会变得复杂，并且手动保持它们同步会很乏味且容易出错。
基于.ipr的旧项目不支持单独的运行/调试配置。对于遗留项目，您只能通过将.ipr文件添加到 VCS 来一次共享所有配置。
1. 从主菜单中，选择运行 | 编辑配置。或者，按Alt+Shift+F10，然后按0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb648ee7831cbacbd079b4cd11d5c985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0218fc49f1b68fc962bb4dc37c0e9af0/" rel="bookmark">
			[Vue warn]: Error in render: “TypeError: Cannot read property ‘name‘ of undefined“，报错，已解决。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		含义：
渲染时发生错误：类型错误：不能读取undefined的name属性
原因：
出现上述报错其实是因为，你访问了undefined.name,但是 undefined 没有 name，所以报错。
原因有两种，
1，你的数据是异步加载，页面渲染的时候，还没有加载成功
2，数据是本地数据，压根没有name数据、
解决方案:
无论是哪一种方案都是因为访问的对象不存在
办法一：ES6可选链操作符号
const adventurer = { name: 'Alice', cat: { name: 'Dinah' } }; const dogName = adventurer.dog?.name; console.log(dogName); // expected output: undefined 办法二：
const adventurer = { name: 'Alice', cat: { name: 'Dinah' } }; const dagName = adventurer.dog &amp;&amp; adventurer.dog.name console.log(dogName); // expected output: undefined 个人参考的第一种方案，亲测好用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/791b4f9d8129ddb52cad745c7acc2120/" rel="bookmark">
			B.合并数列(SB题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B.合并数列 Time Limit: 1000 MSMemory Limit: 32768 K Total Submit: 153 (77 users)Total Accepted: 14 (13 users)Special Judge: NoDescription 给定两个长度分别为n和m（n和m的长度不大于10000）的非递减整数数列a（a0,a1,a2,...,an-1）和b（b0,b1,b2,...,bm-1），数列中各个整数的取值范围[0,100)。
现在对这两个数列进行合并得到新数列c（c0,c1,c2,...,cn+m-1），并保证数列c仍然是非递减的。
输出合并后数列c的各项，并把该数列c中出现次数最多的最小整数及其出现的次数输出。
Input 有一组测试数据。
第一行输入的是两个数列的长度n和m，数据之间由空格分隔。
第二行输入的是长度为n的数列的各项，数据之间由空格分隔。
第三行输入的是长度为m的数列的各项，数据之间由空格分隔。
Output 第一行输出合并后的数列的各项，数据之间由空格分隔。
第二行按照样例的格式输出合并后数列中出现次数最多的最小整数及其出现的次数。
Sample Input 10 5
0 3 5 7 9 11 11 98 98 99
0 0 4 6 11 99
Sample Output 0 0 0 3 4 5 6 7 9 11 11 11 98 98 99
0 appears 3 times.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/791b4f9d8129ddb52cad745c7acc2120/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d450c42034a16a4024014c696aa1b4/" rel="bookmark">
			springboot的异常处理机制源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 springboot默认的异常处理机制 默认异常处理规则定制异常处理的逻辑异常处理的自动配置原理 异常处理的步骤流程总结及源码解析 1.springboot默认的异常处理机制 默认异常处理规则 ● 默认情况下，Spring Boot提供/error处理所有错误的映射。
● 对于机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据。
定制异常处理的逻辑（白点为黑点的子项） ● 自定义错误页
○ error/404.html error/5xx.html；有精确的错误状态码页面就匹配精确，没有就找 4xx.html；如果都没有就触发白页
● @ControllerAdvice+@ExceptionHandler处理全局异常；底层是 ExceptionHandlerExceptionResolver 支持的
● @ResponseStatus+自定义异常 ；底层是 ResponseStatusExceptionResolver ，把responsestatus注解的信息底层调用 response.sendError(statusCode, resolvedReason)；tomcat发送的/error
● Spring底层的异常，如 参数类型转换异常；DefaultHandlerExceptionResolver 处理框架底层的异常。
○ response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage());
异常处理的自动配置原理 1.问题描述 为什么要剖析自动配置原理：因为上面的一些默认的异常处理行为得益于springboot已经帮助我们配置好的一些东西。
● ErrorMvcAutoConfiguration 自动配置异常处理规则
○ 容器中的组件：类型：DefaultErrorAttributes -&gt; id：errorAttributes
■ public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver
■ DefaultErrorAttributes：定义错误页面中可以包含哪些数据。
○ 容器中的组件：类型：BasicErrorController --&gt; id：basicErrorController（json+白页 适配响应）
■ 处理默认 /error 路径的请求；页面响应 new ModelAndView(“error”, model)；
■ 容器中有组件 View-&gt;id是error；（响应默认错误页）注解：页面响应的ModelAndView(“error”, model)；视图名称刚好为error，此处又注入了一个名称为error的view，相当于给页面响应这个视图。（注意只有给浏览器响应时才会找error这个视图）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77d450c42034a16a4024014c696aa1b4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/83/">«</a>
	<span class="pagination__item pagination__item--current">84/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/85/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>