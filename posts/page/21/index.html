<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a74b512aa7923380b3026c1eddadc843/" rel="bookmark">
			使用Python PIL库和UUID自动命名实现图片批量缩放与重命名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看功能能达到的效果 测试案例 1、处理前的图片 2、处理后的图片 在计算机视觉、机器学习以及日常的图像处理任务中，常常需要对大量图片进行统一尺寸调整，并确保生成的新图片文件名具有唯一性。下面的文章将介绍如何通过Python编程语言中的PIL（Python Imaging Library）库配合uuid模块，实现图片的批量缩放及自动采用UUID作为新文件名的独特命名方式。
首先，我们导入必要的库：
Python import os from PIL import Image import uuid os库用于操作系统相关的功能，如读取目录内容、创建目录等；PIL库则提供了强大的图像处理能力，可以打开、转换和保存各种格式的图片；而uuid库则负责生成全局唯一的通用唯一标识符（UUID），它将用于为每个缩放后的图片生成一个独特的文件名。
接下来，定义原始图片目录和目标保存目录：
Python original_dir = './yuan_img/' new_dir = './new_img/' 如果目标目录尚不存在，则创建之：
Python if not os.path.exists(new_dir): os.makedirs(new_dir) 然后设定目标图片尺寸，这里以224x224为例：
Python target_size = (224, 224) 现在进入核心循环部分，遍历原始图片目录中的所有文件：
Python for filename in os.listdir(original_dir): # 检查文件是否为图片（此处仅处理.jpg和.png格式） if filename.endswith('.jpg') or filename.endswith('.png'): # 构建原始图片路径 img_path = os.path.join(original_dir, filename) try: # 使用PIL打开并转换图片到RGB模式 with Image.open(img_path) as im: im_rgb = im.convert("RGB") # 调整图片尺寸至目标大小，同时应用LANCZOS算法进行高质量抗锯齿处理 im_resized = im_rgb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a74b512aa7923380b3026c1eddadc843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b00e4074ec62fd04b5307c8fd463f54e/" rel="bookmark">
			2024如何入局云计算？亚麻云助力您成为云专家！一次不过，免费再考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		福利派送 2024年伊始，一波又一波的裁员潮又开始啦！还在做传统行业？还在做传统程序员？亦或是对未来依旧迷茫？赶紧趁着行业东风，开始了解入门云计算吧！亚马逊云科技，认证福利免费送！
2024 年亚马逊云科技云从业者加速训练营第一场已经开放报名！报名成功即可取得“一次不过，免费再考” 的限期优惠码！
想要提升云技能，却因“试错成本”而犹豫不前？亚马逊云科技认证考取福利来啦！为助力云计算人才的职业信心建立，亚马逊云科技推出 “一次不过，免费再考” 的限时活动。活动期间您可在第一次未通过的情况下，获得一次免费的 “补考”机会。首次认证考试必须在 2024 年 4 月 15 日之前完成，免费再考必须于 2024 年 6 月 30 日前完成，以确保优惠码可以有效使用。
一键直达亚马逊云科技-云从业者加速训练营:点我直达！
一键直达亚马逊云科技-云从业者加速训练营:点我直达！
一键直达亚马逊云科技-云从业者加速训练营:点我直达！
福利享不停！ 对于入门亚马逊云科技的新人们，亚马逊云科技很贴心的为大家准备了免费的中文定制课程—《亚马逊云科技-云从业者中文定制课程》
https://study.163.com/course/courseMain.htm?courseId=1212973812&amp;trace_c_p_k2=de92ceecb5f64cf0bdca9ebceb698f1b?from=AWS-social-FY24-KOC-FL
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0445cb424ba36451153344bcfccc41/" rel="bookmark">
			proxy 代理的接口报错301问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目系统里仅仅这个接口报错，反向代理错误导致。
默认情况下，不接受运行在HTTPS上，且使用了无效证书的后端服务器。如果你想要接受，修改配置：secure: false（简单意思：如果本地没有进行过https相关的配置，要反代到https，就要false）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad7a01aab096c2fd06c58e03408f6bd2/" rel="bookmark">
			php的性能要比node.js高很多吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今的编程世界中，PHP和Node.js是两种广泛使用的服务器端编程语言。虽然它们都用于构建高效的网络应用程序，但关于它们性能的争论一直存在。有些人认为PHP的性能要比Node.js高很多，而另一些人则持相反意见。
性能通常指的是计算机程序或系统在特定任务上执行的速度或效率。对于Web应用程序来说，性能包括处理请求的速度、内存使用量、并发处理能力等方面。
对于PHP和Node.js的比较，需要考虑以下几个方面：
语言设计：PHP是一种解释型语言，它在服务器上执行并生成动态网页。Node.js使用JavaScript语言，它基于V8引擎并运行在服务器端。运行环境：PHP通常在Apache服务器上运行，而Node.js可以运行在任何支持V8引擎的服务器上。I/O性能：对于Web应用程序来说，输入/输出（I/O）操作是非常常见的。PHP和Node.js在这方面的性能有所不同。PHP使用阻塞I/O模型，这意味着在等待I/O操作完成时，线程会停止执行。而Node.js使用非阻塞I/O模型，它允许线程在等待I/O操作时执行其他任务。因此，Node.js在处理高并发请求方面更具优势。内存管理：PHP和Node.js在内存管理方面也有所不同。PHP使用自动垃圾回收机制来释放不再使用的内存。而Node.js使用V8引擎的垃圾回收机制，这使得它在内存管理方面更具效率。生态系统：PHP和Node.js的生态系统也有所不同。PHP拥有庞大的开源库和框架，如Laravel、Symfony等，这些框架可以提高开发效率和应用程序性能。而Node.js也有许多优秀的开源库和框架，如Express、Koa等，它们提供了强大的路由和中间件功能。 关于PHP是否比Node.js具有更高的性能的问题并没有一个简单的答案。在实际应用中，选择哪种技术取决于具体需求和场景。如果需要快速构建一个简单的Web应用程序，并且对性能要求不高，那么PHP可能是一个不错的选择。然而，对于需要处理大量并发请求、进行实时通信或需要高效内存管理的应用程序来说，Node.js可能更适合。
因此，我们应该根据具体需求来选择使用哪种技术，而不是仅仅基于语言本身的性能来做出决策。在开发过程中，我们还可以通过优化代码、使用适当的数据库技术、实施缓存策略等手段来提高应用程序的性能。同时我们也需要关注技术的发展趋势，以便更好地适应未来的需求和变化。
​
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3883fc72343d595a27673f31ca8a671e/" rel="bookmark">
			electron-egg&#43;react启动、打包问题（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景： 第一次使用electron框架创建桌面端项目，朋友推荐了electron-egg框架，确实很方便，它自带的vue写法，个人用着不是很舒服，所以改用的react去创建的项目...记录一下在此期间遇到几个问题：
1、启动报错exit code 127 2、打包后的程序启动报错 Failed to load resource: net::ERR_FILE_NOT_FOUND
问题描述 &amp; 解决 1 . 项目初始化后，启动报错 code 127
解决方案：细看electron-egg的官方文档，作者有说不推荐使用yarn、cnpm等安装，可能会有问题... 所以，最好在安装依赖时不要使用出npm以外的...
2 . 项目打包后，在out文件中找到了打包后的程序，然后打开页面白屏，显示：Failed to load resource: net::ERR_FILE_NOT_FOUND
如图可以看到显示一个js和css文件没有找到，最后发现其实就是打包的文件没找到，这个文件就是我打包的react的文件，只需要在dist文件夹中，找到这个index.html，然后将引用的文件的地方中的 ‘/’ 改为 ‘./’，之后再在electron项目的终端重新打包就好了（记得react项目打包后，要将dist文件放入根目录下的public文件夹中后 再打包）
未改之前
&lt;!doctype html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;link rel="icon" type="image/svg+xml" href="/vite.svg" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Vite + React&lt;/title&gt; &lt;script type="module" crossorigin src="/assets/index-kmI4KZpc.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" crossorigin href="/assets/index-V1Wetb5I.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 改之后
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3883fc72343d595a27673f31ca8a671e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba6a878fbf07c205cd482c2c7d10396/" rel="bookmark">
			YOLOv8加入AIFI模块，附带项目源码链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv8" 是一个新一代的对象检测框架，属于YOLO（You Only Look Once）系列的最新版本。YOLOv8中提及的AIFI（Attention-based Intrascale Feature Interaction）模块是一种用于增强对象检测性能的机制，它是对YOLO架构中的SPPF（Spatial Pyramid Pooling-Fast）模块的替代或改进。
为了详细解释AIFI模块，让我们首先理解YOLOv8中的一些关键组件以及SPPF模块：
YOLOv8: 这是一种快速且准确的对象检测方法，它只需单次查看（"You Only Look Once"）即可检测图像中的对象。YOLO将对象检测问题作为一个回归问题来解决，直接在图像中预测边界框和类别概率。
SPPF模块: 空间金字塔池化快速（Spatial Pyramid Pooling-Fast）模块是YOLO系列中用于提高特征提取效率和性能的组件。SPPF通过在不同尺度上池化特征来捕获上下文信息，从而提高模型的空间不变性。
现在，引入AIFI模块：
AIFI（Attention-based Intrascale Feature Interaction）: 这个模块的主要目的是通过引入基于注意力机制的内部尺度特征交互来提高特征提取的效率和有效性。其核心思想是在相同尺度的特征之间使用注意力机制来促进更丰富的特征融合。
注意力机制: 注意力机制在深度学习中用于增强网络的聚焦能力，通过赋予不同部分的数据不同的重要性来提高模型的性能。在AIFI中，这意味着模型可以更有效地聚焦于那些对当前任务最重要的特征。
内部尺度特征交互: 这涉及到在同一尺度内的特征之间进行交互。传统的特征融合通常涉及到不同尺度的特征，但在AIFI中，重点放在同一尺度内部的特征融合上，这有助于捕获更细粒度的信息。
通过替换SPPF模块为AIFI，YOLOv8旨在提高模型在处理复杂场景时的灵活性和精确度，尤其是在对象大小和形状多样的情况下。这种基于注意力的特征交互机制使得模型能够更有效地处理和融合重要的特征信息，从而提高整体的检测性能。
废话少说，上源码： YOLOv8中引入AIFI（Attention-based Intrascale Feature Interaction）源码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09daa5c33acdf6a44086184bb533c8c0/" rel="bookmark">
			C语言常见面试题：什么是宏，宏的作用是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		宏在计算机科学中是一种批量处理程序命令，它是一种抽象的规则或模式，用于说明某一特定输入（通常是字符串）如何根据预定义的规则转换成对应的输出（通常也是字符串）。在编译时，预处理器会对宏进行展开，即将宏的内容替换到宏所在的位置。
宏的作用主要有以下几点：
提高效率：通过宏，可以将常用的命令或代码块组织在一起，作为一个单独的命令来使用。这样可以在需要时重复使用，避免重复编写相同的代码，从而提高编程效率。方便复用：在制作过程中，有些命令可能会被反复使用。将这些命令写在宏里，通过调用宏来使用宏内的全部命令，可以方便地复用这些命令，减少代码量。参数传递：宏支持参数传递。在调用宏时，可以传递参数。通过传参修改宏内的某些命令的属性值，可以实现更加灵活的功能。条件编译：宏可以和条件编译指令配合使用，进行条件编译。例如，头文件的防止多重包含机制、根据不同编译器选择不同代码段等。控制常量：对需要变动的常量进行控制，例如控制定义数组的长度等。模板作用：带参数宏通常在模板中使用，通过宏可以间接对应到被宏定义的东西所对应的东西。简化复杂操作：对于一些复杂的操作，使用宏可以简化代码，提高可读性。 以上是宏的一些主要作用，但并不是全部。在实际编程中，根据需要选择是否使用宏以及如何使用宏，以实现更好的代码组织和可读性。
当然可以。以下是一个简单的C语言宏的例子：
c复制代码
#include &lt;stdio.h&gt; // 定义一个宏，用于计算两个数的和 #define ADD(x, y) ((x) + (y)) int main() { int a = 5; int b = 10; int sum = ADD(a, b); // 使用宏计算a和b的和 printf("The sum of %d and %d is %d\n", a, b, sum); return 0; } 在这个例子中，我们定义了一个宏ADD，用于计算两个数的和。当我们在main函数中调用ADD(a, b)时，预处理器会将其展开为((a) + (b))，这样就可以计算出a和b的和。这个例子展示了宏的基本用法和作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52d32e1fb7f13510f36dfcdd291bcac7/" rel="bookmark">
			温故而知新：直方图均衡、直方图匹配的再次理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		☞ ░ 前往老猿Python博客 ░ https://blog.csdn.net/LaoYuanPython 引言 数字图像处理的知识在2年前学过一阵子，但没学完，后来基于各种原因就停滞了整整2年没有学习了，现在准备重新开始，为此把以前学习写的总结博文翻出来重新进行温习。
在温习直方图均衡的内容时，发现自己对直方图均衡和直方图匹配的原理以前并没有真正理解，这次仔细思考了下直方图均衡解决的问题及原理，以及直方图匹配的原理，并发现了原文的一处BUG(该BUG已经修订，在此就不介绍了)。
下面就一些思考在此介绍一下。
直方图均衡的意义 直方图均衡具有扩展输入图像直方图（spread the histogram of the input image）的趋势，均衡后的图像的灰度级（intensity levels）跨越更宽灰度级（intensity scale）范围，最终结果（The net result）是增强了对比度（contrast enhancement）。
为什么直方图均衡会有这样的结果或意义呢？这是由直方图均衡的变换公式决定的，以数字图像的直方图均衡变换为例，其对应公式为：
上述公式中：
rk表示原图像灰度值为k灰度值变量sk表示原图像中灰度值为k的灰度经过公式变换后其新的灰度值，在计算过程中可能出现小数，要进行四舍五入处理M、N为图像的宽度与高度，其乘积就是总像素数L为灰度的取值最大值+1，如8bit表示的灰度值中，L=256，即2的8次方nj为灰度值为j的像素个数，nj的值为非负整数，一幅图像的所有nj的和应该等于M、N的乘积。 从上述公式可以得到如下信息：
上述变换函数是递增函数，rk值越大，sk的值也越大；SK的范围为[0，L-1]；灰度值为rk的像素越少，则rk与rk-1映射到的sk与sk-1就越接近甚至相等，这样就导致原图像中灰度值对应像素少的灰度值就会与小于该灰度值的部分灰度值在变换后灰度值趋同，这样就对原图像中少数类似噪点的像素进行降噪处理，比如图像灰度值大于0，且为1-10的像素少于MN/(2*（L-1))时，其灰度值1-10就会被变换映射为0，这样会将图像的灰度范围向下延伸对于某灰度值大于0的rk对应的像素个数比较多时，则大于等于rk的所有灰度值可能就通过均衡方式得到增大，当原图像的最高灰度值低于L-1时，其最高灰度值就会放大到L-1，这样就向上延伸了灰度值范围，和上面一点相结合，就会提高图像灰度值的范围和对比度 直方图匹配的理解 直方图匹配（Histogram Matching ），又称为直方图规定化（Histogram Specification），旨在调整源图像的直方图以使其匹配指定的直方图。
具体实现是通过源图像的直方图均衡的结果图像A的灰度值，和指定的结果图像直方图的均衡化结果图像B的灰度值进行映射，通过两个均衡化后的直方图找到原图像的灰度值和指定的结果图像的灰度值的映射关系。
为什么通过两次直方图均衡后的图像映射就能找到原图像需要满足指定直方图的映射呢？
这是因为直方图匹配的本质就是重新映射源图像的灰度级别，使得原图像的像素值通过映射调整后对应的分布被调整为与目标直方图要求的分布相同或相近，经过匹配后的图像将具有与目标图像或指定直方图要求的对比度和亮度特性。
小结 本文针对笔者复习直方图均衡和匹配的知识的一些思考进行了说明，直方图均衡扩展可图像的灰度级（intensity scale）范围、增强了图像的对比度，而直方图匹配则使得图像具有与目标图像或指定直方图要求的对比度和亮度特性。
更多图像处理请参考专栏《OpenCV-Python图形图像处理》及《图像处理基础知识》的介绍。
对于缺乏Python基础的同仁，可以通过老猿的免费专栏《 专栏：Python基础教程目录》从零开始学习Python。
如对文章内容存在疑问或需要相关资料，可在博客评论区留言，或关注：老猿Python 微信公号发消息咨询，可通过扫二维码加微信公众号。
写博不易，敬请支持： 如果阅读本文于您有所获，敬请点赞、评论、收藏，谢谢大家的支持！
更多关于统信操作系统及opencv的介绍的内容请参考专栏《国产信创之光》的其他文章。
关于老猿的付费专栏 付费专栏《https://blog.csdn.net/laoyuanpython/category_9607725.html 使用PyQt开发图形界面Python应用》专门介绍基于Python的PyQt图形界面开发基础教程，对应文章目录为《 https://blog.csdn.net/LaoYuanPython/article/details/107580932 使用PyQt开发图形界面Python应用专栏目录》；付费专栏《https://blog.csdn.net/laoyuanpython/category_10232926.html moviepy音视频开发专栏 )详细介绍moviepy音视频剪辑合成处理的类相关方法及使用相关方法进行相关剪辑合成场景的处理，对应文章目录为《https://blog.csdn.net/LaoYuanPython/article/details/107574583 moviepy音视频开发专栏文章目录》；付费专栏《https://blog.csdn.net/laoyuanpython/category_10581071.html OpenCV-Python初学者疑难问题集》为《https://blog.csdn.net/laoyuanpython/category_9979286.html OpenCV-Python图形图像处理 》的伴生专栏，是笔者对OpenCV-Python图形图像处理学习中遇到的一些问题个人感悟的整合，相关资料基本上都是老猿反复研究的成果，有助于OpenCV-Python初学者比较深入地理解OpenCV，对应文章目录为《https://blog.csdn.net/LaoYuanPython/article/details/109713407 OpenCV-Python初学者疑难问题集专栏目录 》付费专栏《https://blog.csdn.net/laoyuanpython/category_10762553.html Python爬虫入门 》站在一个互联网前端开发小白的角度介绍爬虫开发应知应会内容，包括爬虫入门的基础知识，以及爬取CSDN文章信息、博主信息、给文章点赞、评论等实战内容。 前两个专栏都适合有一定Python基础但无相关知识的小白读者学习，第三个专栏请大家结合《https://blog.csdn.net/laoyuanpython/category_9979286.html OpenCV-Python图形图像处理 》的学习使用。
对于缺乏Python基础的同仁，可以通过老猿的免费专栏《https://blog.csdn.net/laoyuanpython/category_9831699.html 专栏：Python基础教程目录）从零开始学习Python。
如果有兴趣也愿意支持老猿的读者，欢迎购买付费专栏。
老猿Python，跟老猿学Python！ ☞ ░ 前往老猿Python博文目录 https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52d32e1fb7f13510f36dfcdd291bcac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7fbb7ffcb2700fc2025e6fb21d40793/" rel="bookmark">
			SpringCloud之OpenFeign的学习、快速上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是OpenFeign OpenFeign简化了Http的开发。在RestTemplate的基础上做了封装，在微服务中的服务调用发送网络请求起到了重要的作用，简化了开发，可以让我们跟写接口一样调其他服务。
并且OpenFeign内置了Ribbon实现负载均衡。
官方文档：Spring Cloud OpenFeign 中文文档 (springdoc.cn)
2、OpenFeign的使用 2.1准备 我们准备了两个微服务，一个商品微服务一个订单微服务。
商品微服务为根据id查询商品详细信息，订单微服务则传入商品id、用户id对商品服务进行调用生成订单。
使用OpenFegin是需要通过注册中心来访问服务的，消费者想通过服务名称调用提供者，就需要注册中心的服务发现功能。
这里我们使用Nacos，Nacos可以参考SpringCloud之Nacos的学习、快速上手-CSDN博客
2.2使用步骤 2.2.1引入依赖 &lt;!--nacos--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--feign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 在order-service和product-service都引入上面两个依赖
在maven管理中我们可以看到OpenFeign已经集成了负载均衡ribbon
启动Nacos服务
2.2.2application.yml 订单微服务
server: port: 8091 #端口 spring: application: name: order-service #服务名称 cloud: nacos: #配置nacos服务地址 discovery: server-addr: localhost:8848 商品微服务
2.2.3开启OpenFeign 我们需要在消费者的启动类上加上注解@EnableFeignClients
因为我们是在订单服务中调用商品服务，所以我们在订单服务的启动类上加上该注解
@SpringBootApplication @EnableFeignClients public class OrderServer { public static void main(String[] args) { SpringApplication.run(OrderServer.class,args); } } 2.2.4业务逻辑 在商品微服务中有个根据商品id查询商品详细信息接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7fbb7ffcb2700fc2025e6fb21d40793/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33282987e1ee7cfe034d5697d090c404/" rel="bookmark">
			评分卡实例：一步一步实现评分卡(详细长文)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老饼讲解-机器学习https://www.bbbdata.com/ml/scorecard
目录
(前言一) 数据说明
(前言二) 评分卡建模步骤概述
一.变量分析、选择与分箱处理
(一) 使用badRate法(或iv法)分析变量
(二) 原始数据转为分箱数据
二.模型数据预处理
(一) 转WOE
(二) 归一化
(三) 总结
三.模型变量筛选与建立逻辑回归模型
(一)逐步回归选择尽量少的变量建模
(二)用选出的变量建立逻辑回归
四.模型评估
(一) 用AUC评估
(二) 检验系数是否为正数
五.模型输出(转评分)
(一) 模型输出与应用(概率预测)
(二) 模型输出与应用(转为客户评分)
六、模型阈值表与投产阈值
(一) 模型阈值效果表
(二) 通过阈值表确定阈值
(三) 分数分布图
本文以kaggle上的借贷数据：https://www.kaggle.com/c/GiveMeSomeCredit/data 为例，讲解《建立评分卡模型的全过程》。
本文只讲解流程，完整代码见《评分卡实例：完整建模代码》
备注：1、因为详细，代码略长，可只参考自己仅需要的部分。
2、数据需要墙，如无法获取，请留邮箱
本文的流程是完整的，详细的，具体的，可以一步步跟着执行。由于文字上比较浓缩， 需要花些耐心。
特别告知：《评分卡系列》文章在本人网站作了更完善更全面的更新，由于改动过大，本文不再更新。一切以老饼的知识网站为主。
(前一) 数据说明 数据共包含10个变量与客户好坏标签：
变量名变量描述数据类型SeriousDlqin2yrs是否有超过90天或更长时间逾期未还的不良行为二分类(0为好，1为坏)RevolvingUtilizationOfUnsecuredLines信用卡和个人信用额度的总余额（除房地产以及分期付款债务(如汽车贷款)）除以总信贷限额。定量age借贷者的年龄定量NumberOfTime30-59DaysPastDueNotWorse借款者逾期30至59天的次数（过去两年中没有恶化）定量DebtRatio月债务支出、赡养费、生活费除以总收入（负债比率）定量MonthlyIncome月收入定量NumberOfOpenCreditLinesAndLoans公开贷款（如汽车和抵押的分期）和信用上线（比如信用卡）数量定量NumberOfTimes90DaysLate90天逾期次数：借款者有90天或更高逾期的次数定量NumberRealEstateLoansOrLines抵押和房地产数量（包括房屋净值信用额度）定量NumberOfTime60-89DaysPastDueNotWorse借款者逾期30至59天的次数（过去两年中没有恶化）定量NumberOfDependents家庭受抚养人数（不含自己）定量 数据共15万条，如下
(前言二) 评分卡建模步骤概述 评分卡的目标模型是，依据客户数据(10个变量)，预测客户是否坏客户(数据中的SeriousDlqin2yrs变量).
整个建模过程共5步：
1.变量分析与分箱：筛选与标签SeriousDlqin2yrs有相关性的变量，并把变量进行分箱，作为建模的输入特征。
2.建模
(1)数据预处理：转woe,归一化
(2)用逐步回归选出尽量少的特征(同时保持建模效果)
(3)训练逻辑回归模型
3.模型评估：检验AUC是否达标，并检查系数是否都为正。
4.将逻辑回归模型预测结果转为评分
5.确定生产上的判定为坏客户的分数阈值
一.变量分析、选择与分箱处理 (一) 使用badRate法(或iv法)分析变量
本阶段分析和挑选变量，一般使用badRate法(或iv法)分析哪些变量与客户的质量相关，作为入模变量。
完整分析流程与变量初探结果见：
《评分卡实例：变量分析-整体流程》
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33282987e1ee7cfe034d5697d090c404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a5a011a6012944999f17fdfb533860/" rel="bookmark">
			决策树建模完整流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《老饼讲解机器学习》https://www.bbbdata.com/ml/text/40
目录
一.数据处理
(一) 数据预处理
(二)训练、测试数据分割
二.试探建模极限
三.参数调优(预剪枝)
1.参数网络扫描
2.参数评估
3.待调优参数列表
四.后剪枝调优
(一) 打印决策树相关信息
(二) 剪枝
五.模型提取
决策树建模完整流程主要有五个：
1.数据处理
2.试探建模极限
3.参数调优
4.后剪枝
5.模型提取
本文只作流程介绍，完整代码见《决策树建模完整代码》
一.数据处理 (一) 数据预处理 1.缺失值填充：我们知道，决策树（CART）是不支持缺失值的，我们要把缺失数据按业务逻辑处理成非缺失值。
备注：也有人说决策树支持缺失值，其实说的是C4.5算法，sklearn用的是CART,不要搞混乱了
2.枚举变量转成数值变量：CART树的每个节点都是判断 变量在阈值的 左边还是右边，因此，它是不支持枚举变量的，需要处理成数值变量，处理方法不在此展开。
(二)训练、测试数据分割 决策树是一个易于过拟合的模型，因此，需要数据分割为两份：训练数据集(80%)、测试数据集(20%)。
train_X, test_X, train_y, test_y = train_test_split(all_X, all_y, test_size=0.2, random_state=0) 二.试探建模极限 我们建模结果并不总是一直顺利如意，模型的结果可能不理想，可能是数据问题，也可能是模型参数问题，
所以，我们要先试探一下用这批数据建模的极限在哪里。如果很差，那就没必要在模型参数上太纠结了，应往数据上找问题。
参数的调整，仅是让我们往这个极限上靠拢。所以，我们先试探一下最优模型，能让我们心里更有底。
决策树试探极限，只需要把参数调到极致（即用默认参数）就可以。
#--------模型极限试探----------------------------------- clf = tree.DecisionTreeClassifier(max_depth=3,min_samples_leaf=8,random_state=20) clf = clf.fit(all_X, all_y) total_socre = clf.score(all_X,all_y) clf = clf.fit(train_X, train_y) train_socre = clf.score(train_X,train_y) print("\n========模型试探============") print("全量数据建模准确率：",total_socre) print("训练数据建模准确率：",train_socre) 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23a5a011a6012944999f17fdfb533860/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e9c7adb03204711aca5e53674c189ba/" rel="bookmark">
			细讲sklearn决策树后剪枝(带例子)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《老饼讲解机器学习》https://www.bbbdata.com/ml/text/38
目录
一.CCP后剪枝简介
二.剪枝操作过程
(1) 查看CCP路径
(2)根据CCP路径剪树
为预防模型过拟合，我们可以采用预剪枝和后剪枝方法
1. 预剪枝:树构建过程，达到一定条件就停止生长
2. 后剪枝是等树完全构建后，再剪掉一些节点。
本文讲述后剪枝，预剪枝请参考《sklearn决策树预剪枝》
一.CCP后剪枝简介 后剪枝一般指的是CCP代价复杂度剪枝法（Cost Complexity Pruning），
即在树构建完成后，对树进行剪枝简化，使以下损失函数最小化:
：叶子节点个数
：所有样本个数
：第 i 个叶子节点上的样本数 ：第i个叶子节点的损失函数
α ：待定系数，用于惩罚节点个数，引导模型用更少的节点。
损失函数既考虑了代价，又考虑了树的复杂度，所以叫代价复杂度剪枝法，实质就是在树的复杂度与准确性之间取得一个平衡点。
备注：在sklearn中，如果criterion设为GINI,则是​﻿每个叶子节点的GINI系数，如果设为entropy，则是熵。
二.剪枝操作过程 具体操作过程如下：
(1) 查看CCP路径 ﻿计算CCP路径，查看alpha与树质量的关系：
构建好树后，我们可以通过clf.cost_complexity_pruning_path(X, y) 查看树的CCP路径：
# -*- coding: utf-8 -*- from sklearn.datasets import load_iris from sklearn import tree import numpy as np #----------------数据准备---------------------------- iris = load_iris() # 加载数据 X = iris.data y = iris.target #---------------模型训练--------------------------------- clf = tree.DecisionTreeClassifier(min_samples_split=10,ccp_alpha=0) clf = clf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e9c7adb03204711aca5e53674c189ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2f0b071fb3f4bb6bf480d980a5e05f5/" rel="bookmark">
			一文讲清神经网络、BP神经网络、深度学习的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创文章，转载请说明来自《老饼讲解神经网络》:bp.bbbdata.com
关于《老饼讲解神经网络》：
本网结构化讲解神经网络的知识，原理和代码。
重现matlab神经网络工具箱的算法，是学习神经网络的好助手。 凡是模仿人的神经网络构建出来的数学模型，都叫神经网络。
神经网络是人工智能的一个主力算法。
神经网络可以归为三块：
(1) BP神经网络
(2) 深度学习。
(3) 其它神经网络
一. 一般神经网络： 一句话概括： 除BP神经网络，深度学习外的人工神经网络。
介绍：
出现得最早，起源于1940+年，该类神经网络非常多，
今天你根据生物神经网络构建一个模型，明天我根据生物神经网络构建一个，可以说是百舸争流。
经典代表：感知机、Hopfield神经网络、径向基神经网络....等等。
二.BP神经网络 一句话概括：人工神经网络中的顶级代表。往往说《神经网络》就是指《BP神经网络》。
介绍：
大家研究着各种神经网络，研究得不亦乐乎，
突然，
1986年，
来了两个家伙Romelhart 和Mcclelland，
提出了一个特殊的结构，并命名：BP神经网络，
BP神经网络提出后，瞬间崛起后当了主力军。
以致于几乎成为了《神经网络》的代名词，
为什么拎出来特别划为一类？
因为它实在太出名了，在不特指时，往往说神经网络都是指BP神经网络（这一种结构的神经网络）。
它的结构以下：
大家印象中的神经网络是不是都是这种结构？
但其实它只是BP神经网络的特有的结构，
神经网络有千万种结构，只是BP神经网络太普及了，现在大家几乎把BP神经网络结构=神经网络结构，
实际BP神经网络结构仅是神经网络结构的一种。
三. 深度学习 一句话概括：深度学习可以看作是BP神经网络的一种加强版。解决输入极极多的问题。
介绍：
（1）BP在解决多输入时受挫
BP神经网络虽然很牛X，但当要处理图象，音频，文字等问题时，却SB了，
因为这类问题的输入极多（例如一个50*50像素的图象，就有2500个输入 ），
而BP神经网络的参数会随着输入个数指数增长（假设有100个隐节点，则2500个输入在第一层的权重参数就有2500*100个），
参数个数量级太爆炸，导致BP在求解时，很难找到优秀解，就挂B了。
（2）根据业务特性去冗解决问题
这本来是个没办法的事，但偏偏图象，音频这些问题，它的输入存在很严重的相关性（例如相邻像素的值总是相近的），
因此，可以根据这个业务特性，进行输入个数压缩，或者在求解时根据这个业务特性进行特殊讨巧（例如相邻输入对应的权重参数共享），
使BP神经网络又可以解决这类问题了。
（3）颁发新名
问题解决了，BP还是BP，但毕竟，有少许变种了！
不管怎么样，解决了新问题了，得显示牛B，挂个名： 深度学习！
就这样，2006年，开启了全民深度学习年代！不懂点深度学习都不好意思说自己做人工智能。
（4）再掀高潮： 2016年，alpha go的出现，深度学习秀足了风头，开启了全民超级深度学习模式~！
（5）总 结：总的来说，深度学习底层还是BP，你可以把深度学习当成 《专用于解决输入极极多，且输入变量之间有极强相关性的问题》的BP神经网络。
四、总结 （1）神经网络：凡是模仿人的神经网络构建出来的数学模型，都叫神经网络
（2）BP神经网络：神经网络最经典的代表就是BP神经网络，能解决很多问题。
（3）深度学习：深度学习可以看作《加强版BP神经网络》，专用于解决输入极极多，且输入变量之间有极强相关性的问题。
（4）其它神经网络：除了BP神经网络外，还有很多杂七杂八的神经网络，经典的有感知机、Hopfield神经网络、径向基神经网络等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2f0b071fb3f4bb6bf480d980a5e05f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c8c6d007c14accabf2d930a71d1029b/" rel="bookmark">
			三、需求规格说明书（软件工程示例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．引言 1.1编写目的 1.2项目背景 1.3定义 1.4参考资料 2．任务概述 2.1目标 2.2运行环境 2.3条件与限制 3．数据描述 3.1静态数据 3.2动态数据 3.3数据库介绍 3.4数据词典 3.5数据采集 4．功能需求 4.1功能划分 4.2功能描述 5．性能需求 5.1数据精确度 5.2时间特性 5.3适应性 6．运行需求 6.1用户界面 6.2硬件接口 6.3软件接口 6.4故障处理 7．其它需求 1．引言 1.1编写目的 【阐明编写需求说明书的目的，指明读者对象。】
为明确软件需求、安排项目规划与进度、组织软件开发与测试，撰写本文档。
本文档供项目经理、设计人员、开发人员参考。
1.2项目背景 项目的委托单位、开发单位和主管部门该软件系统与其他 1.3定义 【列出文当中所用到的专门术语的定义和缩写词的原文。】
1.4参考资料 项目经核准的计划任务书、合同或上级机关的批文项目开发计划文档所引用的资料、标准和规范。列出这些资料的作者、标题、编号、发表日期、出版单位或资料来源 2．任务概述 2.1目标 2.2运行环境 操作系统：Microsoft Windows 2000 Advanced Server
支持环境：IIS 5.0
数 据 库：Microsoft SQL Server 2000
2.3条件与限制 3．数据描述 3.1静态数据 3.2动态数据 【包括输入数据和输出数据。】
3.3数据库介绍 【给出使用数据库的名称和类型。】
3.4数据词典 3.5数据采集 4．功能需求 4.1功能划分 4.2功能描述 5．性能需求 5.1数据精确度 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c8c6d007c14accabf2d930a71d1029b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65febc35c9895144b8aa13e2c58493c3/" rel="bookmark">
			「优选算法刷题」:在排序数组中查找元素的第一个和最后个位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。
示例 1：
输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2：
输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3：
输入：nums = [], target = 0 输出：[-1,-1] 二、思路解析 二分查找，它很简单，但也很容易写出死循环。不过，不必过多恐惧，只要多做练习，他就会是最简单的查找算法！
我们来看这道题，主要分为 2 部分：查找区间的左端点 和 右端点。
1）查找区间左端点 左边界划分的两个区间的特点：
▪ 左边区间 [left, resLeft - 1] 都是⼩于 x 的；
▪ 右边区间（包括左边界） [resLeft, right] 都是⼤于等于 x 的；
因此，关于 mid 的落点，我们可以分为下⾯两种情况：
◦ 当我们的 mid 落在 [left, resLeft - 1] 区间的时候，也就是 arr[mid] &lt;target 。说明 [left, mid] 都是可以舍去的，此时更新 left 到 mid + 1 的位置，继续在 [mid + 1, right] 上寻找左边界；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65febc35c9895144b8aa13e2c58493c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dbff88d9f6069050e91eaa6dbdb0ce2/" rel="bookmark">
			解决Windows下Goland的Terminal设置为Git Bash失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路径不要选错了：
如果还是不行：
把bash路径加进去试试
goland设置Terminal
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ee9923229d67e9dc46aaadff00dd05c/" rel="bookmark">
			ABC337(A-C)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; cin&gt;&gt;n; int suma=0; int sumb=0; int a,b; while(n--){ cin&gt;&gt;a&gt;&gt;b; suma+=a; sumb+=b; } if(suma&gt;sumb)cout&lt;&lt;"Takahashi"&lt;&lt;endl; else if(suma&lt;sumb)cout&lt;&lt;"Aoki"&lt;&lt;endl; else if(suma==sumb)cout&lt;&lt;"Draw"&lt;&lt;endl; return 0; } B #include&lt;bits/stdc++.h&gt; using namespace std; int main() { string s; cin&gt;&gt;s; string s0=s; for(auto i:s){ if(i!='A'&amp;&amp;i!='B'&amp;&amp;i!='C'){ cout&lt;&lt;"No"&lt;&lt;endl; return 0; } } sort(s.begin(),s.end()); if(s0==s)cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; } C #include&lt;bits/stdc++.h&gt; using namespace std; struct people{ int id; int num; }; bool cmp(people a,people b){ return a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ee9923229d67e9dc46aaadff00dd05c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24c7e94c556e02f56a440f4639e31d16/" rel="bookmark">
			std::atomic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 std::atomic 是C++11引入的一个模板类，用于提供原子操作的类型。在多线程编程中，当多个线程同时访问同一块数据时，可能会导致数据竞争和不确定的行为。std::atomic 可以用来创建原子类型的变量，保证对该变量的操作是原子的，不会被中断，从而避免了数据竞争。
std::atomic 适用于以下场景：
在多线程环境下对共享数据进行原子操作；需要保证特定操作的原子性，如递增、递减、交换等操作；需要避免使用锁的情况下进行线程同步。 举个具体的例子：
#include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;mutex&gt; int counter = 0; void incrementCounter() { for (int i = 0; i &lt; 100000; ++i) { counter++; } } int main(int argc, char *argv[]) { std::thread t1(incrementCounter); std::thread t2(incrementCounter); t1.join(); t2.join(); qDebug() &lt;&lt; counter; return 0; } 这段代码存在一个线程安全的问题。多个线程同时访问和修改同一个全局变量 counter ，而没有进行同步操作会导致竞态条件。
竞态条件指的是多个线程并发执行时，由于执行顺序不确定导致程序出现意料之外的结果的情况。
就上面的代码来说，在 incrementCounter() 函数中，多个线程同时对 counter 进行递增操作，而递增操作不是一个原子操作，它包括读取 counter 的当前值、对该值加一、然后写回到 counter。由于线程间的执行顺序是不确定的，就可能出现以下情况：
线程 A 读取 counter 的值为 0，然后执行加一操作得到 1；此时线程 B 也读取 counter 的值为 0，执行加一操作得到 1；然后线程 A 和线程 B 都把值 1 写回到 counter，导致实际的递增次数少于预期。 因此，竞态条件可能会导致 counter 的最终结果少于预期的值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24c7e94c556e02f56a440f4639e31d16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6e584464ad0635d7ddcc7b780b70ea7/" rel="bookmark">
			RabbitMQ系列之入门级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉🎉欢迎来到我的CSDN主页！🎉🎉
🏅我是君易--鑨，一个在CSDN分享笔记的博主。📚📚
🌟推荐给大家我的博客专栏《RabbitMQ系列之入门级》。🎯🎯
🎁如果感觉还不错的话请给我关注加三连吧！🎁🎁
一、MQ的简介 1. 什么是MQ（概念简述） MQ通常指的是消息队列（Message Queue），是一种用于在应用程序之间传递消息的通信方式。消息队列系统允许不同组件之间异步通信，通过在发送者和接收者之间引入队列，实现解耦和提高系统的可伸缩性。
在消息队列中，消息生产者将消息发送到队列，而消息消费者从队列中接收消息。这种异步通信的方式可以使系统中的各个组件独立运作，不需要直接依赖对方的状态，提高了系统的可维护性和可扩展性。
2. MQ的主要应用场景 MQ的应用场景包括但不限于，下面是几个典型的几个应用场景：
MQ典型的应用场景 应用场景说明解耦系统组件允许不同组件之间解耦，降低了组件之间的依赖性。提高系统可靠性如果某个组件暂时不可用，消息队列可以存储消息，待组件恢复正常后再处理这些消息。异步通信允许系统中的组件进行异步通信，提高了系统的响应性。削峰填谷在流量波动较大的场景中，消息队列可以用来平滑流量，防止系统峰值负载。分布式系统协调在分布式系统中，消息队列可以用来协调各个节点的工作。 3. MQ的常见实现方式 3.1 RabbitMQ 1. 特点 RabbitMQ 是一个开源的消息队列系统，它遵循AMQP（Advanced Message Queuing Protocol）协议。它支持多种消息传递模式，包括点对点、发布/订阅和请求/响应。
2. 适用场景 RabbitMQ适用于需要高度灵活性和多样性消息传递模式的场景，同时它的性能和可靠性也是其特点之一。
3.2 Apache Kafka 1. 特点 Kafka 是一个分布式的、高吞吐量的消息系统，主要用于处理实时数据流。它的设计目标是具有高可用性和持久性，同时能够处理大规模的数据流。
2. 适用场景 Kafka 适用于大规模的数据流处理，如日志收集、事件溯源、流式处理等场景。
3.3 ActiveMQ 1. 特点 ActiveMQ 是一个基于Java的开源消息中间件，支持多种协议，包括OpenWire、STOMP、AMQP等。它提供了丰富的功能，如持久化、事务、集群等。 2. 适用场景 ActiveMQ适用于需要与多种协议兼容，并且对消息传递的可靠性和事务有要求的场景。
3.4 Apache RocketMQ接口 1. 特点 RocketMQ 是由阿里巴巴开发的分布式消息中间件，具有高吞吐、低延迟、高可用性的特点。它支持丰富的消息传递模式，如顺序消息、事务消息等。
2. 适用场景 RocketMQ适用于高吞吐、低延迟要求的场景，尤其在电商、金融等领域有广泛应用。
3.5 Amazon Simple Queue Service （SQS） 1. 特点 SQS是亚马逊提供的托管消息队列服务，具有高可用性和弹性。它支持分布式架构，并提供了简单的API用于发送和接收消息。 2. 适用场景 SQS适用于在AWS云上构建可扩展的、分布式的应用程序，无需担心消息队列的基础设施管理。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6e584464ad0635d7ddcc7b780b70ea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f290822c2142c8869bd9c7b343750d2/" rel="bookmark">
			【flutter】完全自定义样式模态对话框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例完成结果展示：
示例组件代码：
context：上下文
title：提示标题，null时不显示
content：提示内容，null时不显示
cancelText：取消按钮文字，null时不显示取消按钮
confirmText：确认按钮文字
//lib\widgets\my.dart class My { static Future&lt;bool&gt; dialog( BuildContext context, { String? title = "提示", String? content, String? cancelText = "Cancel", String confirmText = "Confirm", }) async { final bool? isConfirm = await showDialog&lt;bool&gt;( context: context, //点击背景灰色区域是否关闭对话框 barrierDismissble: false, builder: (BuildContext context) =&gt; Dialog( //这部分是对话框样式，可以完全自定义 child: Container( width: 560.w, padding: EdgeInsets.only(top: 40.w), clipBehavior: Clip.hardEdge, decoration: BoxDecoration( color: Colors.white, borderRadius: BorderRadius.circular(16.w), ), child: Column( mainAxisSize: MainAxisSize.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f290822c2142c8869bd9c7b343750d2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/20/">«</a>
	<span class="pagination__item pagination__item--current">21/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/22/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>