<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701d8bba1f9179a8859eedce075145b1/" rel="bookmark">
			时间复杂度分为几种
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照快到慢排序 O(1)O(logN)O(N)O(NlogN)O(N^2) 例子 O(1) hashsethashmap数组下标 O(logN) 折半查找树形遍历 O(N) list 查询值数组查询值 O(NlogN) 进阶排序 快排堆排归并 O(N^2) 简单排序 冒泡插入选择 ChatGPT 时间复杂度是衡量算法执行时间随输入规模增长而变化的度量。它用大O符号表示，表示算法执行时间的增长率。
在算法分析中，常见的时间复杂度有以下几种：
常数时间复杂度（O(1)）：算法的执行时间不随输入规模的增长而变化。无论输入数据量多少，算法都需要固定的时间完成。
对数时间复杂度（O(logN)）：算法的执行时间随着输入规模的增长而增加，但是增长速率较慢。典型的例子是二分查找算法。
线性时间复杂度（O(N)）：算法的执行时间与输入规模呈线性关系。如果输入规模增加一倍，算法的执行时间也会增加一倍。
线性对数时间复杂度（O(NlogN)）：算法的执行时间介于线性时间复杂度和平方时间复杂度之间。常见的例子是快速排序和归并排序等排序算法。
平方时间复杂度（O(N^2)）：算法的执行时间随输入规模的增长而呈二次方增长。例如，嵌套循环的算法通常具有平方时间复杂度。
指数时间复杂度（O(2^N)）：算法的执行时间随输入规模的增长而呈指数级增长。通常与暴力解法或穷举法相关。
除了以上常见的时间复杂度，还有更高阶的复杂度，如多项式时间复杂度（O(Nk)）、指数多项式时间复杂度（O(kN)）等。这些复杂度通常表示算法的效率较低，应尽量避免使用。
需要注意的是，时间复杂度只考虑算法执行时间与输入规模的关系，并不考虑具体的执行时间。因此，两个具有相同时间复杂度的算法，在实际执行中可能有较大的性能差异。时间复杂度仅提供了一种用于比较算法执行效率的指标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d223ffe4a94b68b4ab334845c4d4d6f/" rel="bookmark">
			算法数据结构——优先队列（Priority Queue）精讲及python应用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 优先队列简介 优先队列（Priority Queue）：一种特殊的队列。在优先队列中，元素被赋予优先级，当访问队列元素时，具有最高优先级的元素最先删除。
优先队列与普通队列最大的不同点在于 出队顺序。
普通队列的出队顺序跟入队顺序相关，符合「先进先出（First in, First out）」的规则。
优先队列的出队顺序跟入队顺序无关，优先队列是按照元素的优先级来决定出队顺序的。优先级高的元素优先出队，优先级低的元素后出队。优先队列符合 「最高级先出（First in, Largest out）」 的规则。
优先队列的示例图如下所示。
2. 优先队列的适用场景 优先队列的应用场景非常多，比如：
数据压缩：赫夫曼编码算法；
最短路径算法：Dijkstra 算法；
最小生成树算法：Prim 算法；
任务调度器：根据优先级执行系统任务；
事件驱动仿真：顾客排队算法；
排序问题：查找第 k 个最小元素。
很多语言都提供了优先级队列的实现。比如，Java 的 PriorityQueue，C++ 的 priority_queue 等。Python 中也可以通过 heapq 来实现优先队列。下面我们来讲解一下优先队列的实现。
3. 优先队列的实现方式 优先队列所涉及的基本操作跟普通队列差不多，主要是 「入队操作」 和 「出队操作」。
而优先队列的实现方式也有很多种，除了使用「数组（顺序存储）实现」与「链表（链式存储）实现」之外，我们最常用的是使用 「二叉堆结构实现」优先队列。以下是三种方案的介绍和总结。
数组（顺序存储）实现优先队列：入队操作直接插入到数组队尾，时间复杂度为 $O(1)$。出队操作需要遍历整个数组，找到优先级最高的元素，返回并删除该元素，时间复杂度为 $O(n)$。
链表（链式存储）实现优先队列：链表中的元素按照优先级排序，入队操作需要为待插入元素创建节点，并在链表中找到合适的插入位置，时间复杂度为 $O(n)$。出队操作直接返回链表队头元素，并删除队头元素，时间复杂度为 $O(1)$。
二叉堆结构实现优先队列：构建一个二叉堆结构，二叉堆按照优先级进行排序。入队操作就是将元素插入到二叉堆中合适位置，时间复杂度为 $O(\log_2n)$。吹对操作则返回二叉堆中优先级最大节点并删除，时间复杂度也是 $O(\log_2n)$。
下面是三种结构实现的优先队列入队操作和出队操作的时间复杂度总结。
入队操作时间复杂度出队操作（取出优先级最高的元素）时间复杂度堆$O(\log_2n)$$O(\log_2n)$数组$O(1)$$O(n)$链表$O(n)$$O(1)$ 从上面的表格可以看出，使用「二叉堆」这种数据结构来实现优先队列是比较高效的。下面我们来讲解一下二叉堆实现的优先队列。
4. 二叉堆实现的优先队列 我们曾经在「01. 数组 - 02. 数组排序 - 07. 堆排序」中介绍过二叉堆，这里再简单介绍一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d223ffe4a94b68b4ab334845c4d4d6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbfc5cf3412f2139336d130b6b945aa6/" rel="bookmark">
			java 中的compute的接口及其实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.问题的描述 （1） 定义接口Compute。
接口方法有：int sum( )，求两个整数的和；int max( )，求两个整数中较大的数。
（2） 定义ComputeClass类。
要求ComputeClass类实现Compute接口；具有int类型的两个私有属性a和b提供有参构造方法ComputeClass (int a, int b)。sum()方法返回属性a与b的和，max返回属性a和b中较大者。
import java.util.Scanner; public class ComputeTester { public static void main(String[] args){ Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); ComputeClass cc = new ComputeClass(a,b); System.out.println("两数之和为：" + cc.sum()); System.out.println("较大值为：" + cc.max()); } } /* 定义接口Compute */ interface Compute{ int sum(); int max(); } /* 定义Compute接口的实现类ComputeClass */ class ComputeClass implements Compute { private int a; private int b; public ComputeClass(int a, int b) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbfc5cf3412f2139336d130b6b945aa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cfd9e2636fd92972647833c1fbe61a5/" rel="bookmark">
			python爬虫基础（五）代理的基本原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于爬虫来说，由于爬虫的爬取速度过快，在爬取过程中可能遇到同一个IP访问过于频繁的问题，此时网站就会让我们输入验证码登录或直接封锁IP，所以我们就需要代理来防止发生。
一、基本原理 代理实际上指的是代理服务器，它的功能是代理网络用户去取得网络信息。换句话说，它是信息的中转站。
二、代理的作用 突破自身IP访问限制，访问一些平时不能访问的站点。
访问一些单位或团体内部资源：比如使用教育网内地址免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务，以及各类资料查询共享等服务。
提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。
隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，就是为了防止自身的IP被封锁。
三、爬虫代理 使用代理隐藏真实的IP，让服务器误以为代理服务器在请求自己。这样在爬取过程中通过不断更换代理，就不会被封锁，可以达到很好的爬取效果。
四、代理分类 1.根据协议区分 FTP代理服务器：主要用于访问FTP服务器，一般有上传、下载以及缓存功能，端口一般为21、2121等。
HTTP代理服务器：主要用于访问加密网站，一般有内容过滤和缓存功能，端口一般80、8080、3128等。
SSL/TLS代理：主要用于访问加密网站，一般有SSL或TLS加密功能（最高128位加密强度），端口一般为443。
RTSP代理：主要用于Real流媒体服务器，一般有缓存功能，端口一般为80、8080、3128等。
Talnet代理：主要用于talent远程控制（黑客入侵计算机时常用于隐藏身份），端口一般为23。
POP3/SMPT代理：主要用于POP3/SMPT方式收发邮件，一般有缓存功能，端口一般为110/25。
SOCK3代理：只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为1080。SOCKS代理协议又分为SOCKS4和SOCKS5，前者只支持TCP，而后者支持TCP和UDP，还支持各种身份验证机制、服务器端域名解析等。
2.根据匿名程度区分 高度匿名代理：会将数据原封不动地转发，在服务端看来就好像真的是一个普通客户端在访问，而记录的IP则是代理服务器的IP。
普通匿名代理：：会在数据包上做一些改动，服务端上有可能发现这是个代理服务器。也有一定几率追查到客户端的真实IP。代理服务器通常会加入的HTTP头有HTTP_VIA和HTTP_X_FORWARDED_FOR。
透明代理：不但改动了数据包，还会告诉服务器客户端的真实IP。这种代理除了能用缓存技术提高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。
间谍代理：指组织或个人创建的用于记录用户传输的数据，然后进行研究、监控等目的的代理服务器。
五、常见代理设置 使用网上的免费代理：最好使用高匿代理。
使用付费代理服务
ADSL拨号：拨一次号换一次IP。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b5be94e6fb2ea3ba93b669db9a4d6e/" rel="bookmark">
			我的梦想指引前行与追寻梦想之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在毕业季来临之际，我想向即将踏入职场的各位同学们致以真诚的祝福和鼓励。在这个毕业季的到来，让我们满怀梦想和热情，准备好迈出职场的第一步，追逐成功的道路，不断成长和拓展自己的辉煌人生！
在大学期间，我有幸参与了一项关于人工智能领域的研究项目。这个项目让我深入了解了学术研究的方法和过程，同时也提高了我的问题解决和团队合作能力。通过与导师和团队成员的合作，我学会了提出合理的研究问题、进行实验和数据分析。这个经历让我深刻认识到科研的艰辛和挑战，同时也激发了我对知识的渴望和追求。我收获了专业知识和科研技能，并培养了批判性思维和创新能力。
大学时光转瞬即逝，我有时感觉自己没有充分利用这段宝贵的时间。有时候，我在追求成绩和学术成就的过程中忽略了与同学们的交流和合作。我后悔没有更多地参与学生组织、社团和志愿者活动，错过了与不同背景的人交流和合作的机会。我意识到，大学不仅仅是为了获取知识，更是一个多元化的社交和成长平台。这个遗憾让我更加珍惜在职场中的人际关系和合作机会，努力与不同领域的人进行交流和合作。
一、接下来，我想给即将毕业的同学们分享六条建议：
探索自己的兴趣和热情。毕业后的职业生涯需要你长期从事，所以找到你热爱的工作至关重要。尝试不同的领域和行业，找到让你充满激情的工作方向。
学会与人沟通和合作。在职场中，与他人的良好沟通和合作是成功的关键。发展你的人际关系和团队合作能力，与同事和上级建立良好的工作关系。
持续学习和自我提升。职场变化快速，不断学习和适应新技术和趋势是必要的。利用各种资源，包括书籍、课程和培训，持续提升自己的技能和知识。
建立职业规划。设定短期和长期职业目标，并制定相应的计划。了解行业和职业的发展趋势，努力发展与之匹配的技能和经验。
坚持追求卓越。在工作中，不断追求卓越是取得成功的关键。努力提高工作质量，保持积极的工作态度，并持续寻求自我突破和成长的机会。
平衡工作与生活。工作重要，但健康和幸福也同样重要。学会管理时间，确保有足够的休息和娱乐，保持身心健康。
二、职业规划的建立：
自我评估：了解自己的兴趣、价值观、优势和弱点。考虑您擅长的领域、喜欢的工作类型以及希望实现的职业目标。通过自我评估，明确自己的职业兴趣和倾向。
设定目标：制定明确、可行的职业目标是关键。根据自我评估的结果，设定长期目标和短期目标。确保目标具体、可衡量，并与您的价值观和职业兴趣相一致。
市场调研：研究您感兴趣的行业和职业领域。了解该行业的发展前景、技能需求、薪资水平和就业市场的情况。掌握行业趋势和变化，以便更好地规划自己的职业道路。
职业发展计划：根据目标和市场调研的结果，制定职业发展计划。确定所需的技能和知识，以及如何获得它们。考虑接受培训、参加课程、获取证书或追求更高学位等途径来提升自己的能力。
寻求指导：与导师、职业顾问或行业专家寻求指导和建议。他们可以提供有关行业内部情况、职业发展路径和成功的实际经验。借鉴他们的经验和建议，对自己的职业规划进行修正和优化。
学习和成长：持续学习和发展是职业规划的关键。通过阅读专业书籍、参加培训课程、参与行业活动和网络研讨会等方式，不断提升自己的技能和知识。保持对新技术、行业趋势和市场变化的关注。
调整和适应：职业规划是一个动态的过程。随着时间的推移，您的目标和兴趣可能会发生变化。要灵活调整和适应新的机会和挑战。定期回顾和评估职业规划，确保它与您的长期目标和个人发展一致。
三、在我职场经历中，也遇到了一些挫折。例如，刚开始从研发做起还要做DBA到系统架构师时，我遇到了困难和挑战。这个转变需要我学习和掌握新的技术和概念，同时需要我调整思维方式和工作方法。我面临了许多新的问题和挑战，但我没有放弃。我通过自学、参加培训课程和与同事的讨论，逐渐克服了这些困难。我学会了持续学习和适应变化的重要性，也培养了解决问题的能力。
在校期间的学习经验和方法分享，我发现以下几点对于学习非常有效：
制定学习计划和目标。明确你想要学习的内容，并制定一个合理的学习计划。将学习目标分解成小步骤，并逐步实现。
积极参与课堂。认真听讲，积极参与讨论和提问。与教授和同学进行交流和互动，加深对知识的理解和记忆。
多样化的学习方法。采用多种学习方法，如阅读教材、参加讨论、做笔记、做练习和项目等。通过不同的方式学习和应用知识，加深理解和记忆。
寻找学习资源和支持。利用图书馆、学术论文、在线课程等资源，扩大学习的广度和深度。寻求教授和同学的帮助和支持，共同学习和解决问题。
对于未来职业发展的规划和期望，我认为以下几点是重要的：
持续学习和成长。职业发展是一个持续的过程，我希望能够不断学习和提升自己的技能和知识。通过参加培训、学习新技术和关注行业动态，保持与时俱进。
拓展领域和角色。我希望能够在职业生涯中拓展自己的领域和角色。不局限于一种职位或角色，而是积极尝试不同的岗位和项目，丰富自己的经验和视野。
建立良好的人际关系。人际关系在职业发展中起着重要的作用。我将努力与同事、合作伙伴和行业专家建立良好的关系，通过合作和交流共同成长。
追求有意义的工作。我期望能够从事对社会有意义的工作，能够对他人产生积极影响。我希望能够将自己的技能和知识应用于解决现实问题，推动社会的发展和进步。
四、在上学期间，和同学一起参与一个创业项目是一件很好的事情，我们决定开发一款线上学习平台。组建了一个小团队，每个人负责不同的角色和任务。两位同学负责市场调研和竞争分析，我和另外 一位同学负责技术开发和设计。我们每周定期开会讨论进展和解决问题。
在努力的过程中，我们也遇到了一些挑战和困难。有时候，我们在技术开发上遇到问题，需要花费很多时间来解决。有时候，我们在市场推广上遇到困难，需要不断调整和改进我们的策略。然而，我们没有放弃，坚持努力，并从中学到了许多宝贵的经验和教训。我们的创业项目最终受到了投资者的关注，并获得了一定的资金支持。虽然最终我们没有将项目推向市场，但这个经历让我们深刻体会到创业的艰辛和乐趣。
总而言之大学时光是一个宝贵的成长和探索时期。通过参与学术研究、拓展自己的兴趣、建立人际关系和积极参与学习，我们可以为职场生涯奠定坚实的基础。在职场中，持续学习、与人沟通和合作、追求卓越以及保持工作与生活的平衡是成功的关键。同时，通过挑战和失败，我们能够不断成长和进步。希望以上的经验和建议对即将毕业的同学们有所帮助，祝愿大家在职场中取得辉煌的成就！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed325511d03b363d106e0a9719a1dfa/" rel="bookmark">
			安装vuex报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年2月7日，vue3成为了默认版本，执行npm i vue 安装的直接就是vue3，vue2更新到vue的同时，vuex3对应更新到vuex4版本
如果直接执行npm i vuex，那么安装的是vuex4，该版本只能在vue3中使用，硬要在vue2 中使用vuex4，报错如图。
现在用的vue2，就要对应安装vuex3，执行命令行npm i vuex@3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16eaf916e1a458d50898bce2daa04034/" rel="bookmark">
			内网安全：代理技术详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
代理技术实验所用网络拓扑图及说明
代理技术
SOCK协议
使用代理技术的原因
正向代理与反向代理
实战一：MSF代理通讯
实验原理说明
一. Meterpreter建立路由
二. MSF建立节点
三. 建立代理到MSF上
实战二：CS代理通讯
实验原理说明
一. CS建立SOCKS代理
二. 使用proxifier 设置代理 ​编辑
实战三：CS正向连接上线
实验原理说明
一. 配置监听器，让win10把自己的流量转发到本地的2222端口上
二. CS执行命令上线
实战四：MSF正向连接上线
实验原理说明
一. 生成后门，流量转发到自己的端口上
二. MSF主动访问
关于反向连接
思路总结
本篇将介绍在内网攻防中经常用到的代理技术，正向连接，反向连接。
内网攻防中阶段有三：
1. 建立通讯 使用代理技术，建立攻击机与目标的联系
2. 横向移动
3. 后渗透 获得主机权限后，使用隧道技术，把权限移交给攻击机
本篇中的所有实现均是获得了系统权限，因为不涉及内网横向移动，只是为了研究第一，第三阶段。
代理技术实验所用网络拓扑图及说明 网段情况：Vmware配置网络
攻击机：47.94.236.117 靶机：
win 7：内网唯一可出网主机 也可对内网192.168.11.* 网段主机进行通讯
192.168.1.119 （外网的出口）192.168.11.128（内网Vmware2）
win 10：内网主机 流量不出网
192.168.11.129（内网Vmware2）192.168.22.130（内网Vmware3）
win 2008：内网主机 流量不出网
192.168.22.131（内网Vmware3）192.168.33.129（内网Vmware4）
win 2012：内网主机 流量不出网
192.168.33.130（内网Vmware4）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16eaf916e1a458d50898bce2daa04034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e508e650fe53671f593d1936f3b544e1/" rel="bookmark">
			Unity Addressables学习笔记(3)---加载远程场景Scenes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Unity Addressables学习笔记—汇总 正文 1.创建一个新场景 我是创建在Resources/Scenes目录下，如图：
2.为场景创建一个Addressables的Group Game1Group就是我新创建的一个Group用来存放场景1的所有资源，分组的配置跟Remote一样，都是远程的，加载地址是我本地启动的web服务器地址，URL里WebGL那个目录也不是必须的，根据自己实际的来。
3.把新场景和场景里用到的资源全部拖入到Game1Group里 上边的图就是拖完的状态。
4.在初始化的场景里添加代码，用Addressables的方式加载新的场景Game1. 我是在最开始的场景里图片1那个开始按钮上加了个点击事件去触发加载Game1这个场景的
using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.AddressableAssets; using UnityEngine.ResourceManagement.AsyncOperations; using UnityEngine.UI; public class GameController : MonoBehaviour { private Sprite sprite; public Button btn; public List&lt;string&gt; list; void Start() { //Addressables.Instantiate("Play Button").Result.transform.position = new Vector3(2f, 2f); foreach (string name in list) { Addressables.LoadAssetAsync&lt;GameObject&gt;(name).Completed += SpriteLoadedObj; } //PlayerPrefs.DeleteKey(Addressables.kAddressablesRuntimeDataPath); Addressables.LoadAssetAsync&lt;Sprite&gt;("Play Button Img").Completed += SpriteLoaded; } private void SpriteLoaded(AsyncOperationHandle&lt;Sprite&gt; obj) { switch (obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e508e650fe53671f593d1936f3b544e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5236ae7f2f60d17950f2e47dc2bee357/" rel="bookmark">
			使用rundll32.exe运行dll函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows操作系统下,exe文件双击即可执行,而dll文件则不可以。这样的话在调试dll中函数的时候就会很不方便,所以可以借助于额外的启动器。当然这个启动器可以自己实现,但是使用操作系统自带的rundll32.exe就能满足要求。日常使用的控制面板中的一些功能都是通过rundll32.exe来启动的
下面通过一个DEMO来介绍rundll32.exe的使用方法
首先我们使用vs创建一个动态链接库的项目,然后在主cpp文件中添加一个导出函数Main,
Main函数作为DLL的入口函数
函数的签名形如 extern "C" _declspec(dllexport) void _stdcall Main(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow) 代码中加入了AttachConsole附加到了命令行的控制台窗口,也可以使用AllocConsole创建一个新的控制台窗口
在命令行窗口中调用结果如下
可以看到控制台输出的信息
可以使用批处理简化操作,实现一个通用的启动器,在DLL文件同目录下创建一个rundll.bat文件,文件内容如下
该脚本会自动查找同目录下的第一个DLL文件,这样的话,就可以双击rundll.bat文件来运行dll中的入口函数了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/761cf09052b32de8cdb4972d2a964a1b/" rel="bookmark">
			文件上传至公有云Nos及对接CDN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目开发中，需要将图片文件上传至网易公有云的Nos,并且结合CDN做加速服务，记录一下开发过程。 流程图：
1. 文件上传到公有云Nos 网易对象存储服务（Netease Object Storage，简称NOS）是网易数帆提供的高可用、高可靠、高性能的云端存储服务。
本次项目由于是和外部企业合作，上传文件是上传到公有云Nos，但和部门之前上传到私有云Nos的方式一样。都是采用计算token的方式，前端直传。(私有云和公有云签名计算方式一样)
需要注意的点有：
而公有云的上传请求地址是：https://nosup-eastchina1.126.net，与私有云上传地址不同。如果请求地址不对的话，则会一直返回"AccessDenied"。
配置桶名及ak_sk的时候，一定要仔细检查，是否有错误，例如多个空格啥的。这种也会返回错误信息"AccessDenied"。
2. 认识CDN 内容分发网络（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。一般应用场景在于：网页、小文件加速；大文件下载加速；视频点播加速等。
可以这样理解，cdn的作用就是将源站内容发布到不同区域的边缘节点，这样在不同地方的用户请求都能被分配最适合他的节点，就近获取节点上缓存的资源。
一方面防止每个用户请求都访问源站，避免造成网络拥塞、缓解源站压力。
另一方面，使用户可以以最快的速度取得他所需的内容，解决网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问的响应速度。
3. 接入CDN 关于对接网易cdn，基本参考官方文档：https://sf.163.com/help/documents/68827624361873408。
首先是在控制台配置好加速域名，回源地址等信息；
其次由于此次项目中不仅是想完成回源访问，更想着主动预热到cdn各节点，所以需要在代码里，调用CDN提供的接口。
CDN接口功能介绍：
刷新：把CDN所有节点上对应的缓存资源标记为失效，当用户再次请求时，CDN会直接回源站获取对应的资源并返回给用户，同时将资源重新缓存到CDN节点。刷新功能会降低缓存命中率。预热：源站主动将对应的资源缓存到CDN节点，当您首次请求资源时，即可直接从CDN节点获取到最新的资源，无需再回源站获取。预热功能会提高缓存命中率。调用接口肯定需要鉴权， 这次开发中，在签名认证上花了较多时间，官方文档上没有示例，所以在格式上耽误了许久，下面给出签名格式代码：
import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Service; import javax.annotation.Resource; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.io.UnsupportedEncodingException; import java.nio.charset.StandardCharsets; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.text.SimpleDateFormat; import java.util.*; @Service @Slf4j public class CdnAuthorizationServiceImpl implements CdnAuthorizationService { @Value("${cdn.config.accessId}") private String accessId; @Value("${cdn.config.secretKey}") private String secretKey; @Value("${cdn.config.domainName}") private String domainName; @Resource private CdnAuthorizationService cdnAuthorizationService; @Override public String getAuthorization(String signature) { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/761cf09052b32de8cdb4972d2a964a1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bb78f9ad1534a2c26321c746c0f894e/" rel="bookmark">
			wpf 往richtextbox里追加不同颜色的文本，并滚动到最底部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 做上位机或者需要在页面里展示推送内容或者日志的，一般都会使用richtextbox，不但可以显示不同颜色，还可以实现滚动效果
FlowDocument Doc = new FlowDocument(); private void addLog(Color _color, string txt) { var p = new Paragraph(); // Paragraph 类似于 html 的 P 标签 var r = new Run(txt); // Run 是一个 Inline 的标签 p.Inlines.Add(r); p.Foreground = new SolidColorBrush(_color); ;//设置字体颜色 Doc.Blocks.Add(p); rtbLog.Document = Doc; rtbLog.ScrollToEnd(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da4a2f0a73f2b459a2935e597906a037/" rel="bookmark">
			Unity制作 小球吃金币 游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工程源文件下载地址-百度网盘
1. 新建一个项目 2. 新建一个平面对象 3. 新建一个材质球 为材质球设置颜色
5. 将材质球拖拽赋值给平面 6. 创建立方体对象，拉伸至平面宽度 7. 再复制三个立方体、调整位置、添加材质，用四个调整过的立方体将平面围起来 8. 创建一个球体（游戏的主角） 9. 创建一个圆柱体并调整为金币形状、竖着摆放在桌面上 10. 创建一个材质球，取金色，并赋值给金币 Ctrl D复制多个金币（共10个），调整位置，围绕小球布局。
11. 创建一个空对象，将所有金币放到空对象中，以便统一管理（立方体也是） 12. 为金币添加脚本，实现自动旋转 金币的自转脚本 rorate.cs（将脚本手动拖拽挂载到每一个金币上）
using System.Collections; using System.Collections.Generic; using UnityEngine; public class rorate : MonoBehaviour { void Start() { } void Update() { this.transform.Rotate(Vector3.right, Space.Self);//自转 } } 13. 为小球添加刚体组件（检查器：添加组件→Physics→Rigidbody） 14. 为小球添加脚本，实现通过键盘WSAD、↑↓←→控制小球移动 此时小球碰到金币会弹开
小球的移动脚本 move.cs
using System.Collections; using System.Collections.Generic; using UnityEngine; public class move : MonoBehaviour { Vector3 mPrevPos = Vector3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da4a2f0a73f2b459a2935e597906a037/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bbe6686e8f0c412a67a07e3b7921e1c/" rel="bookmark">
			用java实现简单的学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、构造学生类二、系统界面三、查找信息四、删除信息五、修改信息五、添加信息总结 前言 之前有用C语言写过一个学生信息管理系统，今天尝试用java写这信息管理系统，功能依旧是包含增删改查几大模块，但对录入的信息进行了检查功能，以此保证数据的准确性。让我们来看看他的具体实现功能吧！
提示：以下是本篇文章正文内容，下面案例可供参考
一、构造学生类 我们新建一个包用来存储学生的基本信息（姓名，年龄，生日），并且生成对应的空参构造，带参构造。以及get and set 方法。
package com.zlh.min; public class Student { private String name; private String id; private int age; private String birthday; public Student() { } public Student(String name, String id, int age, String birthday) { this.name = name; this.id = id; this.age = age; this.birthday = birthday; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getId() { return id; } public void setId(String id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bbe6686e8f0c412a67a07e3b7921e1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/045993684cc43046dc0877e19aa08917/" rel="bookmark">
			来自6种编程语言的祝福：欢乐六一儿童节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		六一儿童节的由来是为了纪念在法西斯侵略战争中死难的儿童，反对帝国主义的虐杀和毒害儿童，保障儿童权利。1949年11月，国际民主妇女联合会在莫斯科召开大会，决定每年的6月1日为全世界少年儿童的节日，即国际儿童节。
六一儿童节是一个关爱和保护儿童的节日，也是一个展示儿童天真和快乐的节日。在这一天，世界各地的儿童都可以享受到各种庆祝活动，如游园会、文艺演出、礼物赠送等。这些活动既能增进儿童之间的友谊，又能培养他们的创造力和想象力。同时，六一儿童节也是一个提醒我们关注和改善儿童生活状况的节日，让我们不忘记那些在贫困、战乱、灾难中受苦的儿童，为他们提供必要的帮助和支持。
六一儿童节是一个感人的节日，它让我们回忆起自己曾经的童年时光，也让我们珍惜眼前的幸福生活。感受到儿童是人类最宝贵的财富，他们是未来社会的主人。应该尊重和爱护每一个孩子，给他们一个健康、快乐、美好的成长环境。
在童年时的六一儿童节，总是期待学校举办的庆祝活动。学校为我们准备了一系列精彩的节目，其中最受欢迎的是文艺演出。老师和同学们准备了精彩的舞蹈、小品和歌曲表演，每个班级都能展示自己的才艺。在演出结束后，放假那一刻真的感受到了对孩子们的关爱和鼓励。
除了文艺演出，学校还举办了各种游戏竞赛。参加过踢毽子比赛、跳绳比赛和扔沙包等小游戏。那些比赛充满了欢声笑语和竞争的氛围，每个人都为了取得好成绩而努力拼搏。尽管结果并不重要，但参与其中的快乐和团结精神永远留在我的记忆中。
而在家庭中度过的六一儿童节同样充满了快乐和温馨。父母一起做手工的时光，会用彩纸、剪刀和胶水制作五彩斑斓的风车、小动物等手工作品。这是一次展示我们想象力和创造力的机会，同时也增强了我们的亲子关系。
另外家人也会安排一些外出游玩的活动。经常选择户外郊游，到公园或乡村去感受大自然的美丽。在郊游中，可以和父母一起欣赏风景、呼吸新鲜空气，还可以尝试各种户外运动，如踢球、放风筝等。这些活动让自己与家人更加亲近，也增加了我们的互动和交流。
六一儿童节也是一个关注儿童健康和成长的重要时刻。在这一天，家人和社会都会思考儿童的权益、教育和保护。可能会一起讨论一些相关的话题，如儿童的心理健康、良好的饮食习惯和安全意识等。这些讨论和关注，让人感受到成长的重要性和被爱的温暖。
回忆起六一儿童节的欢乐时光，感到幸福和感激。那些美好的回忆和经历，不仅度过了一个快乐的童年，也塑造了今天的价值观和人生态度。六一儿童节，是一个属于孩子们的特殊节日，享受游戏和礼物的乐趣，更重要的是，它提醒着我们保护儿童权益、关注他们的成长，让每个孩子都能快乐、健康地成长。
以下是来自6种开发语言的祝福，以及1段来自主机的小曲子：
C# using System; class Program { static void Main() { Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine("祝愿所有可爱的孩子们六一儿童节快乐！"); Console.WriteLine("愿你们天天开心，笑容灿烂如阳光！"); Console.WriteLine("在这特殊的日子里，收获无限的快乐和美好！"); } } Python class TextColor: RED = '\033[91m' RESET = '\033[0m' print(TextColor.RED + "祝愿所有可爱的孩子们六一儿童节快乐！") print("愿你们天天开心，笑容灿烂如阳光！") print("在这特殊的日子里，收获无限的快乐和美好！" + TextColor.RESET) JavaScript console.log("%c祝愿所有可爱的孩子们六一儿童节快乐！", "color: red; font-size: 18px;"); console.log("愿你们天天开心，笑容灿烂如阳光！"); console.log("在这特殊的日子里，收获无限的快乐和美好！"); Java public class Main { public static final String ANSI_RED = "\u001B[31m"; public static final String ANSI_RESET = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/045993684cc43046dc0877e19aa08917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9403e440ea1f7c5c9d7e76fd075c0f62/" rel="bookmark">
			基于Q-learning的强化学习案例（附python代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Q-learning的强化学习案例 如图所示的一个表格，初始位置伟黄色的0，目标终点为绿色的6，想要通过策略学习找到从0到6的最短路径，其中红色的7和8是禁止通过的位置，Agent经过这两个位置会game over。
以下通过强化学习的Q-Learning方法来学习策略，找到最优的路径方案。
状态空间S 即为0~8
动作空间A 可以向左、向下和向右运动，设置为0 1 2
根据状态和动作，预先给定的奖励值在不同动作和状态下如下图
利用Q-learning算法，编写python代码如下
# 强化学习走Q表 import numpy as np R = [[-1000, -100, 0],[-5, 0, -100],[-100, 0, 0],[-1000, -1000, 0],[-5, -1000, 100],[-5, 100, -1000],[0, -1000, -1000],[-1000, 0, 0],[0, 0, -1000]] S = [[0, 7, 1], [0, 2, 8], [7, 4, 5], [3, 3, 4], [3, 4, 6], [2, 6, 5], [4, 6, 6], [7, 3, 2], [1, 5, 8]] Q = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9403e440ea1f7c5c9d7e76fd075c0f62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4037f32802805a2fe75cfd158583a3/" rel="bookmark">
			MyBatis - Spring Boot 集成 MyBatis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.版本要求2.导入依赖3.自动配置2.可配置项 MyBatis-Spring-Boot-Starter 可以帮助你更快地在 Spring Boot 之上构建 MyBatis 应用。通过使用该模块我们能够快速实现以下目的：
构建单体应用程序将几乎不需要样板配置使用更少的 XML 配置 1.版本要求 MyBatis-Spring-Boot-Starter 要求以下版本：
MyBatis-Spring-Boot-StarterMyBatis-SpringSpring BootJava3.03.03.0 - 3.117 或更高2.32.12.5 - 2.78 或更高 从上面的版本要求，我们们也不难发现，在 Spring Boot 3.x 发布后，MyBatis Starter 也进行了兼容性适配，在 Spring Boot 3.x 项目中我们可以使用 mybatis-spring-boot-starter 3.x 的版本。
2.导入依赖 Spring Boot 官方没有提供 MyBatis Starter，但是 MyBatis 官方提供了 mybatis-spring-boot-starter 一站式启动器。如果你使用 Maven，要使用 MyBatis-Spring-Boot-Starter 模块，你只需要在你的 pom.xml 添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${mybatis-starter.version}&lt;/version&gt; &lt;/dependency&gt; 具体使用哪个版本的 MyBatis 依赖需要根据实际情况进行选择，然后对应替换上例中的 ${mybatis-starter.version} 部分。对应的你可以到 Maven 中央仓库进行查阅：Maven Repository:mybatis-spring-boot-starter。
3.自动配置 当我们导入 mybatis-spring-boot-starter，它就同时导入了使用 MyBatis 所需的所有依赖：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a4037f32802805a2fe75cfd158583a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04df94c2e39d00f8fc75c9543da46fb1/" rel="bookmark">
			vue：日期的相关方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目里用到挺多与日期相关的逻辑，现在记录一下我用到过的方法。
目录
1、获取当天日期，格式：yyyy-MM-dd
2、将系统默认时间（例如Wed Jun 19 2019 15:33:53 GMT+0800 (新加坡标准时间)）转为格式为yyyy-MM-dd的日期
3.获取某一天的前几天或后几天
4.判断提供的日期是工作日还是双休日
5. 判断指定日期是否超出当天
6. 获取指定日期的前（后）几日、几月、几年
7. 获取当天为星期几
8. 时间戳 转 yyyy-mm-dd hh-mm-ss
9. yyyy-mm-dd hh-mm-ss 转 时间戳
1、获取当天日期，格式：yyyy-MM-dd getCurrentDate(n) { var dd = new Date(); if (n) { dd.setDate(dd.getDate() - n); } var year = dd.getFullYear(); var month = dd.getMonth() + 1 &lt; 10 ? "0" + (dd.getMonth() + 1) : dd.getMonth() + 1; var day = dd.getDate() &lt; 10 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04df94c2e39d00f8fc75c9543da46fb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62fa8280094e973177a4353bc44eaa80/" rel="bookmark">
			秘密共享之算术共享、布尔共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PS：一直以来都没有写东西的习惯，每次看完的东西想起来时总是手忙脚乱找不到依据，甚至很多看过很多遍的东西也一直遗忘。趁着2020年年末之际，尝试将一些有用的、会用的等知识进行整理，培养一下自觉性，也培养下思路逻辑啥啥啥的。
以下是对近些日子了解安全多方计算（Multi Party Computation，MPC）时碰到的相关概念的总结。
文章目录 1 秘密共享（Secret Sharing，SS）2 算术共享（Arithmetic Sharing，AS）3 布尔共享（Boolean Sharing，BS）4 （补充）混淆电路（Garbled Circuits，GC） 1 秘密共享（Secret Sharing，SS） 秘密共享机制是在一组参与者中共享秘密的技术，它主要用于保护重要信息，防止信息被丢失、被破坏、被篡改[1]。（个人认为SS是MPC的基础）
以下转载自：知乎
秘密共享通过把秘密进行分割，并把秘密在n个参与者中分享，使得只有多于特定 t t t个参与者合作才可以计算出或是恢复秘密，而少于t个参与者则不可以得到有关秘密。如下图所示，特征A的值x，分割成 x 1 , x 2 , . . . , x n x_1,x_2,...,x_n x1​,x2​,...,xn​，分发给 S 1 , S 2 , . . . , S n S_1,S_2,...,S_n S1​,S2​,...,Sn​。
秘密共享体系还具有同态的特性。如下图所示：有特征A和B，他们的值被随机分成碎片 ( X 1 , X 2 , … , X n ) (X_1, X_2, …, X_n) (X1​,X2​,…,Xn​)和 ( Y 1 , Y 2 , … , Y 3 ) (Y_1, Y_2, …, Y_3) (Y1​,Y2​,…,Y3​)，并分配到不同参与节点 ( S 1 , S 2 , … , S n ) (S_1,S_2, …, S_n) (S1​,S2​,…,Sn​)中，每个节点运算结果的加和，等同于原始A与B的加和。同样通过增加其他计算机制，也能满足乘积的效果，这就是秘密共享具备的“同态性”，各参与者可以在不交换任何数据的情况下直接对密码数据求和、乘积。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62fa8280094e973177a4353bc44eaa80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baaa6ee798ead45824f4897142286bc8/" rel="bookmark">
			【EasyRL学习笔记】第三章 表格型方法（Q-Table、Sarsa、Q-Learning）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、马尔可夫决策过程1.1 有模型1.2 免模型1.3 有模型与免模型的区别 二、Q表格三、免模型预测3.1 蒙特卡洛方法3.1.1 蒙特卡洛方法特点3.1.2 蒙特卡洛方法步骤3.1.3 蒙特卡洛方法优点3.1.4 蒙特卡洛方法缺点 3.2 时序差分方法3.2.1 时序差分方法特点3.2.2 时序差分方法步骤3.2.3 时序差分算法优点 3.3 动态规划方法、蒙特卡洛方法以及时序差分方法的自举和采样 四、免模型控制4.1 广义策略迭代方法4.2 基于探索性开始的蒙特卡洛方法4.3 基于 ε \varepsilon ε-贪心探索的蒙特卡洛方法4.4 Sarsa：同策略时序差分控制4.5 Q学习：异策略时序差分控制4.6 Sarsa与Q学习的区别 五、表格型方法总结六、关键词总结七、习题八、面试题九、Python代码实战9.1 Sarsa算法求解悬崖行走问题9.2 Q-Learning算法求解悬崖行走问题 策略最简单的表示是查找表（look-up table），即表格型策略（tabular policy）。
使用查找表的强化学习方法称为表格型方法（tabular method），如：
蒙特卡洛Q学习Sarsa 本章通过最简单的表格型方法来讲解如何使用基于价值的方法求解强化学习问题。
一、马尔可夫决策过程 强化学习是一个与时间相关的序列决策的问题。如下图所示，在t-1时刻，我看到熊对我招手，下意识的动作就是逃跑。熊看到有人逃跑，就可能觉得发现了猎物，并开始发动攻击。
而在 t 时刻，我如果选择装死的动作，可能熊咬咬我、摔几下就觉得挺无趣的，可能会走开。这个时候我再逃跑，可能就成功了，这就是一个序列决策过程。
1.1 有模型 有模型：环境的状态转移概率和奖励函数已知
如下图所示，我们把这些可能的动作和可能的状态转移的关系画成树状。它们之间的关系就是从 s t s_t st​ 到 a t a_t at​ ，再到 s t + 1 s_{t+1} st+1​ ，再到 a t + 1 a_{t+1} at+1​ ，再到 s t + 2 s_{t+2} st+2​ 的过程。我们与环境交互时，只能走一条完整的通路，这里面产生了一系列决策的过程，我们与环境交互产生了经验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baaa6ee798ead45824f4897142286bc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76533cd7c7a0ff3d3e9031af436ef272/" rel="bookmark">
			Java中如何根据图片文件创建Image对象，且将Image对象保存为文件形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建与保存 1.根据一个文件路径创建Image对象 Image image = ImageIO.read(new File(filepath)); 2.将Image对象保存为文件形式 //要想保存这个对象的，需要把image声明为BufferedImage 类型 BufferedImage image = ImageIO.read(new File(filepath)); ImageIO.write(image, "jpg", new File("f:/image/apple.jpg")); 二、在图像界面中显示图像 1.使用窗口加载，将图片变为背景显示 ImageIcon bg =new ImageIcon(image); JLabel jl = new JLabel(bg); jl.setBounds(0,0,bg.getIconWidth(),bg.getIconHeight()); jf.setSize(bg.getIconWidth(), bg.getIconHeight()); jf.setResizable(false); //将图片添加到分层窗格的最底层作为背景 jf.getLayeredPane().add(jl, new Integer(Integer.MIN_VALUE)); //内容窗格转化为JPanel，否则不能设置为透明 JPanel jp = (JPanel)getContentPane(); jp.setLayout(null); jp.setOpaque(false);//设置为透明 2.使用Graphics画笔将图片画在窗口中 重写窗体类的paint(Graphics g)方法 public void paint(Graphics g){ g.drawImage(0,0,400,300,null); //该方法的主体是窗口 } 当然也可以自己写一个画图的方法 public void draw（Graphics g）{ g.drwaImage(0,0,400,300,null); //记得传一个Graphics画笔进来 } 3.关于Graphics 对象为null的解决 (1) paint系列方法里的是jre创建的
(2) 当前类继承了jframe的话直接可以这样写的graphics g=getgraphics（）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76533cd7c7a0ff3d3e9031af436ef272/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/59/">«</a>
	<span class="pagination__item pagination__item--current">60/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/61/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>