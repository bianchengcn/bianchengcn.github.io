<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb9996d6bd72709e23f6df3d7683948c/" rel="bookmark">
			【Linux】进程间通信概念 | 匿名管道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是进程间通信进程间通信的概念进程间通信的目的进程间通信的分类进程间通信的本质 二、什么是管道三、匿名管道匿名管道的原理✨站在内核角度理解管道✨站在文件描述符角度理解管道 pipe系统调用fork后在父子进程间使用管道通信代码实现 匿名管道的读写规则管道的5种特性1. 匿名管道的局限性2. 管道内部自带同步与互斥机制3. 管道的生命周期随进程：4. 管道提供的是面向字节流的流式服务：5. 管道是单向通信的，半双工通信的一种特殊情况： 四、运用匿名管道建立进程池 [!Abstract] 进程间通信重点
进程间通信介绍 管道 消息队列 共享内存 信号量 一、什么是进程间通信 进程间通信的概念 进程间通信简称IPC（Interprocess communication），是操作系统中的一个重要概念，它允许不同的进程在执行过程中交换数据、共享资源、协调行为等。在多道程序设计环境下，多个进程可能需要相互通信以完成复杂的任务，而进程间通信提供了各种机制来实现这种交互。
进程间通信的目的 数据传输：一个进程需要将它的数据发送给另一个进程资源共享：多个进程之间共享同样的资源。通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 进程间通信的分类 管道：管道是最早的进程间通信机制之一，最早出现在UNIX系统中。它是一种简单而有效的通信方式，适用于具有父子关系的进程。管道只能用于具有共同祖先的进程之间的通信，通常用于父进程与子进程之间。管道分为：
匿名管道pipe命名管道 System V IPC：是一套在UNIX系统中引入的标准，包括：
System V 消息队列System V 共享内存System V 信号量
System V IPC 提供了更为灵活和通用的进程间通信机制，使得不同进程之间能够更灵活地交换信息和共享资源。 POSIX IPC：是为UNIX-like系统定义的一套标准。POSIX 进程间通信机制是在System V IPC的基础上进行改进和扩展的，以提供更简单和一致的接口。POSIX IPC包括：
消息队列共享内存信号量互斥量条件变量读写锁 进程间通信的本质 进程通信的本质是，让不同的进程看到同一份资源。
这种资源通常由操作系统提供。
二、什么是管道 管道是Unix中最古老的进程间通信的形式。
我们把从一个进程连接到另一个进程的一个数据流称为一个“管道”
例如，统计我们当前使用云服务器上的登录用户个数。可以在bash下输入命令 who | wc -l 执行一条简单的管道操作，这条命令的作用是将两个命令连接起来，将第一个命令的输出作为第二个命令的输入。
who：这个命令通常用于显示当前登录系统的用户信息，包括用户名、登录时间等。执行 who 会输出一些用户信息的列表。
|：这是管道符号，它将第一个命令的输出传递给第二个命令的输入。在这个例子中，它将 who 命令的输出传递给下一个命令。
wc -l：wc 是用于统计文件中行数、字数和字符数的命令，而 -l 参数表示只统计行数。因此，wc -l 会对输入的文本进行行数统计。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb9996d6bd72709e23f6df3d7683948c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0e5bfd6f6bde2810d728fd14680d692/" rel="bookmark">
			Oracle 11g安装配置详细教程：一步步实现数据库环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle 11g是甲骨文公司在2007年7月12日推出的最新数据库软件。它有400多项功能，并经过了1500多个小时的测试，开发工作量达到了3.6万人/月。Oracle 11g提供了高性能、伸展性、可用性和安全性，并能更方便地在低成本服务器和存储设备组成的网格上运行。相对过往版本而言，Oracle 11g具有了与众不同的特性，例如数据库重演（Database Replay）和自动诊断知识库（Automatic Diagnostic Repository ADR）。
数据库重演（Database Replay）这一特性可以捕捉整个数据的负载，并且传递到一个从备份或者standby数据库中创建的测试数据库上，然后重演以测试系统调优后的效果。自动诊断知识库（ADR）是当Oracle探测到重要错误时，会自动创纪一个事件（incident），并且捕捉到和这一事件相关的信息，同时自动进行数据库健康检查并通知DBA。此外，这些信息还可以打包发送给Oracle支持团队。
在安装Oracle 11g时，用户需要注意填写一些信息，如SID（Service ID）和密码（系统管理员的密码）。安装过程会检查电脑配置，如果符合要求就可以继续安装。安装结束后，会生成一个包含数据库信息的界面。
在使用Oracle 11g时，用户需要掌握其管理工具，如SQL*Plus、Oracle Enterprise Manager（OEM）和SQL Developer，并了解如何配置和管理数据库。此外，用户还需要了解Oracle 11g的安全特性，以保护数据库的安全性和完整性。
请注意，虽然Oracle 11g是一款优秀的数据库软件，但它也需要合适的硬件和软件环境才能发挥最佳性能。因此，在选择和使用Oracle 11g时，用户需要充分考虑自己的实际需求和系统环境。
步骤1：下载Oracle 11g安装文件 首先，你需要从Oracle官方网站下载Oracle 11g的安装文件。确保选择与你的操作系统版本相匹配的安装包。
步骤2：解压安装文件 下载完成后，使用压缩软件（比如WinRAR）将安装文件解压缩到你选择的目录中。解压后你会得到一个名为database的文件夹。
步骤3：运行安装向导 在database文件夹中找到setup.exe，右键点击并选择以管理员身份运行。这将启动Oracle 11g的安装向导。
步骤4：选择安装选项 安装向导启动后，选择“创建和配置数据库”选项，然后点击“下一步”。
步骤5：选择安装类型 在安装类型中，选择“自定义”以进行详细配置。点击“下一步”。
步骤6：配置数据库 在这一步，你需要配置数据库的名称、密码、监听端口等信息。确保你牢记数据库管理员（DBA）的密码，这将是你后续登录数据库的凭证。
步骤7：选择数据库安装位置 选择Oracle数据库的安装位置。建议使用默认的安装目录，点击“下一步”。
步骤8：准备安装 在这一步，安装向导将显示你选择的安装配置摘要。确认配置无误后，点击“安装”开始安装过程。
步骤9：等待安装完成 安装过程可能需要一些时间，请耐心等待。安装完成后，点击“完成”退出安装向导。
步骤10：配置环境变量 为了能够正常使用Oracle数据库，你需要配置系统的环境变量。在系统变量中，找到PATH变量，将Oracle的bin目录路径添加进去。
步骤11：启动数据库服务 在安装完成后，你可以在“开始”菜单中找到Oracle的程序组，启动数据库服务。确认数据库服务已成功启动。
至此，你已经完成了Oracle 11g数据库的安装和配置。你可以使用SQL*Plus等工具连接到数据库，开始你的数据库开发和管理工作。希望这个详细教程对你有帮助，祝你在Oracle的世界里愉快地探索！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b2e2707f32e533abb6cc522851f0a47/" rel="bookmark">
			学习鸿蒙基础（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		arkts是声名式UI
DevEcoStudio的右侧预览器可以预览。有个TT的图标可以看布局的大小。和html的布局浏览很像。
上图布局对应的代码：
@Entry //入口 @Component struct Index { @State message: string = 'Hello Harmonyos' //@State 数据改变了也刷新的标签 build() { Row() { Column() { Text(this.message) .fontSize(30) .margin(10) .padding(20) .backgroundColor("#333333") .fontColor(Color.White) .border({ width:3, color:Color.Blue }).borderRadius(10) .onClick(() =&gt; { console.log("点击了text") this.message = "text" }) .fontWeight(FontWeight.Bold) Divider().margin(10) Button("click") .width(100) .height(50) .onClick(this.read.bind(this)) } .width('100%') .height('50%') } .height('100%') .width('90%') } // 方法多的话写到这里 read() { console.log("我是button的点击事件") this.message = "button" } } 新建页面的时候选择page。就会主动把该页面添加在路由中。
此处就是新建的页面的路由。和微信小程序是一样一样的。要加到这个page上。
1、自定义组件内，自定义构件函数。
@Builder 注释来实现 @Entry //入口 @Component struct PageB { @State message: string = 'Hello World' //@State 数据改变了也刷新的标签 build() { Row() { Column() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b2e2707f32e533abb6cc522851f0a47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec5cf85413968596b7dfb7723e62bd70/" rel="bookmark">
			【Vue】2-6、侦听器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		watch 侦听器 watch 侦听器允许开发者监听数据的变化，从而针对数据的变化做特定的操作。
语法格式如下：
const vm = new Vuew({ el: '#app', data: { username: ''}, watch: { username(newVal,oldVal){ console.log(newVal,oldVal); } } }) &lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="username"&gt; &lt;/div&gt; &lt;!-- 导入 Vue 的库文件 --&gt; &lt;script src="./lib/vue.js"&gt;&lt;/script&gt; &lt;!-- Jquery --&gt; &lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt; &lt;!-- 创建 Vue 的实例对象 --&gt; &lt;script&gt; /** const vm = new Vue({ // el 固定写法，表示当前 vm 实例要控制页面上的哪个区域，接收的值是一个选择器 el: '#app', // data 对象就是要渲染到页面上的数据 data:{ username: '' }, watch: { username(newVal){ if(newVal !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec5cf85413968596b7dfb7723e62bd70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d31040a1348817f5937d4e678bd0f3/" rel="bookmark">
			idea激活教程（2020.1.4及以上版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先点击试用版本，进入软件，再依次进行一下操作
一、在idea的Plugins配置中添加Z大的插件市场 上图中加载出来的插件是默认的，大家不用在意，直接点击“Manage Plugin Repositoryies…”打开配置弹窗
点击+号，添加一行https://plugins.zhile.io
添加完之后，点击OK。
二、在Plugins中搜索IDE Eval Reset插件进行安装 三、打开idea的Help菜单，找到“Eval Reset”菜单 如果在启动后的首页找不到位置，可以随意打开一个项目，进入到项目页面之后，顶部菜单最后一个也是Help选项。
点击效果跟上面的弹窗一样，只不过是改了展现方式，不再弹窗了，直接在idea底部区域显示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8550146aaff309ba6c30afd28d6e78dc/" rel="bookmark">
			能够配合导入obsidian的zotcard模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://github.com/018/zotcard/discussions/2
【卡片名】：文献笔记
配合导出到obsidian使用，处理tags（每个tag前增加#）
【卡片模版】：
&lt;h1&gt;${title}&lt;/h1&gt; &lt;hr&gt; &lt;h1&gt; ${publicationTitle ? `${publicationTitle} | `:``} ${authors ? `${authors} | `:``} &lt;a href="${itemLink}"&gt;${title}&lt;/a&gt; (${year}) ${DOI?`, DOI:${DOI}`:``} &lt;/h1&gt; ${tags?`Tags: #${`${tags}`.replace(new RegExp(",","gm")," #")}`:``} &lt;hr&gt; &lt;h2&gt;摘要：&lt;/h2&gt; ${abstractNote} &lt;h2&gt;研究背景和研究问题：&lt;/h2&gt; &lt;h2&gt;研究方法及改进：&lt;/h2&gt; &lt;h2&gt;结果与讨论：&lt;/h2&gt; &lt;h2&gt;数据分析方法：&lt;/h2&gt; &lt;hr&gt; &lt;h2&gt;论文创新点：&lt;/h2&gt; &lt;h2&gt;启发与思考：&lt;/h2&gt; &lt;h2&gt;不足及可改进的点：&lt;/h2&gt; 结合哲学层面做了改进 &lt;h1&gt;${title}&lt;/h1&gt; &lt;hr&gt; &lt;h1&gt; ${publicationTitle ? `${publicationTitle} | `:``} ${authors ? `${authors} | `:``} &lt;a href="${itemLink}"&gt;${title}&lt;/a&gt; (${year}) ${DOI?`, DOI:${DOI}`:``} &lt;/h1&gt; ${tags?`Tags: #${`${tags}`.replace(new RegExp(",","gm")," #")}`:``} &lt;hr&gt; &lt;h2&gt;概念：#&lt;/h2&gt; &lt;h2&gt;本体论：&lt;/h2&gt; &lt;h3&gt;包含要素&lt;/h3&gt; &lt;h3&gt;内在逻辑&lt;/h3&gt; &lt;h3&gt;意义：&lt;/h3&gt; &lt;h2&gt;方法论：&lt;/h2&gt; 方法论是一种以解决问题为目标的理论体系或系统，通常涉及对问题阶段、任务、工具、方法技巧的论述。方法论会对一系列具体的方法进行分析研究、系统总结并最终提出较为一般性的原则。 &lt;hr&gt; &lt;h2&gt;创新点：&lt;/h2&gt; &lt;h2&gt;启发与思考：&lt;/h2&gt; &lt;h2&gt;不足及可改进的点：&lt;/h2&gt; 效果 这个#在自动导入obsidian以后 可以 自动和其他知识产生关联
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16e1e44c945474c8126318bb34bae5df/" rel="bookmark">
			如何理解Anaconda自带了许多用于科学计算的库？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 “预装”（pre-installed）意味着当你安装Anaconda时，某些软件包和库已经包含在安装程序中，因此在安装过程中，这些软件包和库会自动安装到你的系统中。这样做的好处是你不需要单独去安装这些常用的库，它们在安装Anaconda后就已经准备好可供使用了。
要查看Anaconda中预装的科学计算库，你可以通过以下几种方式：
Anaconda Navigator：
Anaconda Navigator是Anaconda提供的图形用户界面工具，它允许你管理Conda包、环境和其他Anaconda附加组件。在Navigator中，你可以查看已安装的包和可用的包，以及进行包的安装、更新和删除。 Conda命令行：
你可以使用Conda命令行工具来查看已安装的包。打开命令行或终端，输入conda list，这将显示当前环境中安装的所有包及其版本。如果你想看特定环境中的包，可以先激活该环境，然后运行conda list。 查看Anaconda官网：
Anaconda官网提供了Anaconda发行版中包含的包的列表。访问Anaconda distribution page可以查看当前和以往版本的Anaconda所包含的软件包列表。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be913ae1f421e7158f79f345197522e/" rel="bookmark">
			【Node.js】fs与path模块的基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、什么叫做模块二、fs模块2.1 fs模块是干什么的？2.2 fs模块的使用导入fs模块读取文件的内容写入文件内容处理路径问题path路径模块 总结 前言 在Node.js中，fs模块（文件系统模块）是一个重要的核心模块，它提供了对文件系统进行各种操作的能力。无论是读取文件内容、写入文件，还是创建、删除目录，fs模块都是不可或缺的工具之一。本文将深入探讨fs模块的基础使用，帮助开发者更好地理解如何在Node.js环境中进行文件操作，从而为构建文件处理相关的应用打下坚实基础。
一、什么叫做模块 在Node.js中，模块是一种组织和封装代码的机制，用于将应用程序拆分为独立且可维护的部分。每个模块都有自己的作用域，可以包含变量、函数、类等，这样可以有效地避免全局作用域的污染和命名冲突。
二、fs模块 2.1 fs模块是干什么的？ fs 模块是 Node.js 中的一个核心模块，用于处理文件系统操作。它提供了一系列的方法，使得你可以对文件和目录进行读取、写入、更新、删除等操作。以下是一些常见的 fs 模块的功能：
文件读写操作： fs 模块提供了读取和写入文件的方法，可以同步或异步地进行操作。这包括了文本文件和二进制文件的读写。
目录操作： 可以创建、删除、读取目录，以及获取目录下的文件列表等。
文件和目录信息： 提供了获取文件和目录信息的方法，如文件大小、创建时间、修改时间等。
文件重命名和删除： 可以通过 fs.rename() 方法进行文件重命名，通过 fs.unlink() 方法删除文件。
文件流操作： fs 模块支持使用文件流进行读写操作，这对于处理大型文件或流式数据非常有用。
文件权限操作： 可以设置和获取文件的权限信息，以及判断当前用户对文件的权限。
符号链接操作： 提供了创建、读取和删除符号链接的方法。
总的来说，fs 模块为 Node.js 提供了丰富的文件系统操作功能，使得开发者可以轻松地进行文件和目录的处理，适用于各种应用场景，从简单的文件读写到复杂的文件系统操作。通过这个模块，Node.js 可以方便地与本地文件系统进行交互，是构建文件处理和文件管理应用的重要工具。
2.2 fs模块的使用 导入fs模块 我们可以使用require函数导入指定的模块
参数填我们要导入的模块名称，我们可以通过使用返回值操作这个模块
const fs = require('fs') 读取文件的内容 语法格式：
fs.readFile(path[，options]，callback) 用中括号表示是可选的参数
参数解读
参数1:必选参数，字符串，表示文件的路径。
参数2:可选参数，表示以什么编码格式来读取文件
参数3:必选参数，文件读取完成后，通过回调函数拿到读取的结果
示例代码：
const fs = require('fs') fs.readFile('./fsTest.txt','utf8',(err,data)=&gt;{ console.log(data) console.log('--------------------------------') console.log(err) }) 中间的就是我们的可选参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7be913ae1f421e7158f79f345197522e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad3041051b7c64ee2d6aa20239300196/" rel="bookmark">
			如何利用Java的ServiceLoader机制来动态加载插件类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java的ServiceLoader机制是一种服务提供发现和加载机制，允许服务提供者在运行时被加载和查询，而无需对使用者的代码进行修改。以下是如何使用ServiceLoader来动态加载插件类的步骤：
定义服务接口： Java中的服务通常由接口或抽象类定义。 public interface MyService { void execute(); } 实现服务接口： 创建一个或多个服务接口的实现。 public class MyServiceImpl implements MyService { public void execute() { // 实现的具体逻辑 } } 在资源目录下声明服务提供者： 在您的项目中的META-INF/services目录下创建一个文件，文件命名为完整的接口名。在这个文件中，列出所有实现类的完全限定名，每行一个。 例如，如果你的服务接口是com.example.MyService，则在META-INF/services/com.example.MyService文件中添加：
com.example.MyServiceImpl com.example.AnotherServiceImpl 确保这个文件是项目打包后包含在内的。
使用ServiceLoader加载服务实现： 通过ServiceLoader载入并访问所有可用的服务实现。 ServiceLoader&lt;MyService&gt; serviceLoader = ServiceLoader.load(MyService.class); for (MyService service : serviceLoader) { service.execute(); // 调用service实例的方法 } 处理服务加载错误： 在使用ServiceLoader时，一定要考虑异常处理，因为动态加载服务可能会出现类加载错误和其他问题。 ServiceLoader.load()方法会懒惰地查找和加载服务实现，这就意味着实现类不会在ServiceLoader.load()调用时就立即加载，而是在你遍历ServiceLoader时加载。
记得，不同的类加载器可能会导致服务加载不一致的问题，尤其是在复杂的应用服务器和容器中。确保你使用适合的上下文类加载器，可以通过Thread.currentThread().getContextClassLoader()获取。如果有特定要求，ServiceLoader.load()也允许你指定类加载器。
ServiceLoader&lt;MyService&gt; serviceLoader = ServiceLoader.load( MyService.class, Thread.currentThread().getContextClassLoader() ); 使用ServiceLoader可以让你的应用架构保持灵活性和模块化，易于维护和扩展，特别是在你需要支持插件或组件化特性时。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7df2e84ae1a188df1f1327e655cd9493/" rel="bookmark">
			商务英语VR智能互动教学系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、增强教学互动性
实时反馈：VR智能互动教学系统可以实时监测学生的学习情况，并给予即时的反馈和建议，帮助学生更好地理解和掌握知识。 实时交流：VR环境允许学生和教师之间进行实时交流，打破传统课堂的时空限制，使得课堂教学更加灵活和互动性更强。 3. 角色扮演：通过VR技术，学生可以在虚拟环境中进行角色扮演，模拟商务场景，提高实际应用能力。
二、提升教学效果
沉浸式体验：VR智能互动教学系统能够为学生提供沉浸式的商务英语学习环境，使学生更容易进入学习状态，提高学习效果。 多元化学习方式：VR智能互动教学系统可以结合多种学习方式，如项目式学习等，激发学生的学习兴趣和积极性。 3. 个性化教学：VR智能互动教学系统可以根据每个学生的学习特点和需求，提供个性化的教学方案，提高教学效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41bfc8e8ff2b69e5e3d42a6832342365/" rel="bookmark">
			《Python基础教程》内容总览篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是爱编程的喵喵。双985硕士毕业，现担任全栈工程师一职，热衷于将数据思维应用到工作与生活中。从事机器学习以及相关的前后端开发工作。曾在阿里云、科大讯飞、CCF等比赛获得多次Top名次。现为CSDN博客专家、人工智能领域优质创作者。喜欢通过博客创作的方式对所学的知识进行总结与归纳，不仅形成深入且独到的理解，而且能够帮助新手快速入门。
个人精心开设的《Python基础课程》专栏订阅量2100+，帮助不少同学解决了Bug。最近有几个学习很认真的同学们给我反馈，专栏博客帮助他解决了大模型、爬虫、Python基础等各类问题，但有时候找起来不太方便，希望能对专栏的文章进行分门别类的整理，这样就能提高检索效率。
优秀的建议必须毫不犹豫地被接纳，虽然客观来说整理是一件工作量不小的事情，但想到蚕蛹化蝶之前必须经历痛苦的挣扎才能破茧成蝶。所以这两天一忙完工作就马不停蹄的继续整理。现有类别包括大模型、机器学习、爬虫、数据处理与可视化、anaconda &amp; pip &amp; jupyter notebook &amp; ipython &amp; pycharm、数据库与中间件、常用Python库、Python基础、github等，大家可点击博客右侧的按钮查看目录，如下图所示：
本专栏每周至少更新5篇相关文章，目标至少是1000篇+，所以后续还会不断进行扩充，希望最终能够对订阅的同学们有所帮助。
1. 大模型 1.1 transformers &amp; huggingface 如何检验下载的大模型checkpoint文件是否正确的解决方案transformers pipeline出现ConnectionResetError的解决方案huggingface_hub.utils._validators.HFValidationError Repo id must be in the form repo_name or name解决方案TypeError: transformers.tokenization_utils_base.PreTrainedTokenizerBase._from_pretrained() got multiple values for keyword argument 'use_auth_token’解决方案ModuleNotFoundError: No module named 'transformers.modeling_bert’解决方案ModuleNotFoundError: No module named 'transformers.modeling_bart’解决方案transformers加载模型时自动选择空闲的单个GPU的实战代码transformers加载模型时自动选择空闲的多个GPU的实战代码transformers设置StoppingCriteria的实战代码修改huggingface模型的储存位置的设置方法huggingface datasets离线加载文件的解决方案huggingface-cli: error: invalid choice: 'download’解决方案huggingface datasets map时出现KeyError: 'output’的解决方案RuntimeError: expected scalar type Half but found Float解决方案ValueError: paged_adamw_32bit is not a valid OptimizerNames, please select one of [‘adamw_hf’, ‘adamw_torch’, ‘adamw_torch_fused’, ‘adamw_torch_xla’, ‘adamw_apex_fused’, ‘adafactor’, ‘adamw_bnb_8bit’, ‘adamw_anyprecision’, ‘sgd’, ‘adagrad’]解决方案RuntimeError:Expected all tensors to be on the same device, but found at least two devices解决方案tokenizers＞=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41bfc8e8ff2b69e5e3d42a6832342365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b030ab4409674b66096580317646e78/" rel="bookmark">
			查看或编辑二进制文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当涉及到查看或编辑二进制文件时，许多人可能会感到有些困惑。与文本文件不同，二进制文件包含的是以字节形式表示的数据，而不是人类可读的文本。本文将介绍如何查看和编辑二进制文件的基本方法，以及一些常见的工具和技巧。
1. 什么是二进制文件？ 在计算机中，二进制文件是由字节（8位）组成的文件，其中包含了计算机程序或数据。与文本文件不同，二进制文件可能包含不可见字符、图形、压缩数据等。这些文件通常用于存储图像、音频、视频等多媒体信息，或者是执行计算机程序。
2. 查看二进制文件 2.1 使用命令行工具 在Unix/Linux系统中，你可以使用hexdump或xxd等命令来查看二进制文件的内容。例如：
hexdump -C your_binary_file 这将以十六进制和ASCII码形式显示文件的内容。
2.2 使用文本编辑器 一些文本编辑器也提供了二进制文件查看功能。例如，使用vim时，你可以通过以下命令打开一个文件：
vim -b your_binary_file 这样你可以查看文件的十六进制表示。
3. 编辑二进制文件 3.1 使用专业工具 有一些专门用于编辑二进制文件的工具，如Bless、Hex Fiend、010 Editor等。这些工具提供了友好的界面和强大的功能，使你能够直观地编辑二进制数据。
3.2 使用文本编辑器 一些高级文本编辑器也可以用于编辑二进制文件。在这种情况下，你需要确保以二进制模式打开文件，以免损坏数据。
4. 注意事项 在编辑二进制文件时，一定要小心谨慎。任何不小心的更改都可能导致文件不可用或数据损坏。建议在编辑之前备份文件，以防不测发生。
结论 查看或编辑二进制文件可能是一项高级任务，但熟悉了相关工具和技术后，你将能够更好地处理这些文件。记住在进行任何编辑操作之前备份文件，以免引起不必要的问题。希望这篇博客能帮助你更好地理解和处理二进制文件！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21b22e9f89b91d28714950e2fe03e78a/" rel="bookmark">
			curl参数解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 curl [options] [URL...] -A/--user-agent &lt;string&gt; 设定使用者的代理发送给服务器 -b/--cookie &lt;name=string/file&gt; 设置cookie文件的读取位置 -c/--cookie-jar &lt;file&gt; 操作结束后把cookie写入到指定文件中 -C/--continue-at &lt;offset&gt; 断点续传 -d/--data "data" 携带HTTP POST请求的data -D/--dump-header &lt;file&gt; 把header信息写入到指定文件中 -e/--referer 带入来源网址 -F/ 上传二进制文件，也可以当做-d来用 -H/--header 设定请求头 -i/--include 在输出中显示header -K：指定配置文件 -L：会让HTTP请求跟随服务器的重定向，curl默认不跟随重定向 -m：限制curl完成时间(overall time limit) -o/--output 把输出内容写入到指定文件中（重命名），等同于wget命令 -O/--remote-name 把输出内容写入到指定文件中,并保留原文件名 -r/--range &lt;range&gt; 返回HTTP/1.1或FTP服务器响应的指定范围字符 -s/--silent 静默模式，不输出任何东西 -T/--upload-file &lt;file&gt; 上传文件 -u/--user &lt;user[:password]&gt; 设定服务器的用户名和密码 -v/--verbose 输出更多信息，便于debug -w/--write-out [format] 请求完成后指定输出内容 -x/--proxy &lt;host[:port]&gt; 使用HTTP代理 -X/--request [GET|POST|PUT|DELETE|PATCH] 使用指定的 http method 来发出 http request -Y：设置下载限速 --dump-header：保存Header限速 --limit-rate：用来限制HTTP请求和回应的带宽，模拟慢网速的环境 --local-port：强制使用指定的本地端口号 --resolve HOST:PORT:ADDRESS 强制将 HOST:PORT 解析到指定的 IP ADDRESS --trace &lt;file&gt;：输出请求的详细信息 -#/--progress-bar 進度條顯示當前的傳送狀態 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a32ea5c724f7373a2650b7ca76cf12/" rel="bookmark">
			java spring cloud 企业电子招标采购系统源码:营造全面规范安全的电子招投标环境，促进招投标市场健康可持续发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目说明
随着公司的快速发展，企业人员和经营规模不断壮大，公司对内部招采管理的提升提出了更高的要求。在企业里建立一个公平、公开、公正的采购环境，最大限度控制采购成本至关重要。符合国家电子招投标法律法规及相关规范，以及审计监督要求；通过电子化平台提高招投标工作的公开性和透明性；通过电子化招投标，使得招标采购的质量更高、速度更快。过招投标文件电子化，节约招标成本，提升企业的资金节约率。
开发类型
电子招标采购软件
解决方案
招标面向的对象为供应商库中所有符合招标要求的供应商，当库中的供应商有一定积累的时候，会节省大量引入新供应商的时间。系统自动从供应商库中筛选符合招标要求的供应商，改变以往邀标的业务模式。招采工作完成对供应商进行评分，对不合格供应商进行拉黑；供应商报名、缴费以及投标、答疑等过程通过系统自助完成。以往线下存档资料管理困难，回溯项目过程不清晰，回溯过程复杂，现在通过线上存档的方式，存档方便，可以快捷高效的对以往招采项目进行回溯。
一、立项管理
1、招标立项申请
功能点：招标类项目立项申请入口，用户可以保存为草稿，提交。
2、非招标立项申请
功能点：非招标立项申请入口、用户可以保存为草稿、提交。
3、采购立项列表
功能点：对草稿进行编辑，驳回的立项编辑，在途流程查看。
二、项目管理
1、采购计划管理
功能点：采购计划新增、编辑、删除
2、采购过程管理
功能点：查询、维护基准价、组建评审小组、项目答疑澄清、文件费保证金审核、供应商报价维护、查看评审明细。
3、招标代理机构抽取
功能点：招标代理机构抽取
4、造价机构抽取
功能点：造价机构抽取
5、线下项目管理
功能点：新增、导入、删除、编辑。
三、采购公告管理
1、项目公告查询
功能点：招标类公告创建、非招标类公告创建、查看、编辑、提交审核、停用。
四、评审管理
1、项目评审
功能点：查询、评审人员提交评分。
五、考核管理
1、项目考核分派
功能点：查询、查看详情、发布考核、指派考核负责人。
2、项目考核查询
功能点：查询、查看详情、分配考核人。
3、项目考核
功能点：查询、查看详情、提交考核评分。
六、供应商企业中心
1、投诉建议
功能点：提交投诉建议
2、企业信息
功能点：修改企业信息
3、项目管理
功能点：查看公告、查看项目、下载标书、缴纳文件费、缴纳保证金、上传标书文件。
七、招标代理机构企业中心
1、基本信息
功能点：修改企业信息
2、项目管理
功能点：查看项目详情及状态
3、公告管理
功能点：招标类公告创建、非招标类公告创建、查看、编辑、提交审核、停用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ddf4e72b8e03a97994303d1f294b12/" rel="bookmark">
			父组件监听子组件的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
目录下新建 bus.js
// eventbus传值 new 的vue实例 import Vue from 'vue' export default new Vue() 子组件中使用方法：
&lt;script&gt; import Bus from './../bus.js' export default { data() { return {} }, methods: { goEdit(){ Bus.$emit('menuIndex', '4')//传递的值 }, } } &lt;/script&gt; 父组件：
&lt;script&gt; import Bus from './../bus.js' export default { data() { return { menuIndex:"" } }, mounted() { Bus.$on("menuIndex", (val) =&gt; { this.menuIndex = val; }); }, } &lt;/script&gt; 方法二：监听sessionStorage
在main.js中添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49ddf4e72b8e03a97994303d1f294b12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a44d8bdc056f067a28577587f37b8677/" rel="bookmark">
			【Node.js基础】Node.js的介绍与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、什么是Node.js？二、安装Node.js2.1 Windows系统2.2 macOS系统2.3 Linux系统 三、运行js代码总结 前言 随着互联网技术的不断发展，构建高性能、实时应用的需求日益增长。Node.js作为一种服务器端运行时环境，以其事件驱动、非阻塞I/O的特性，为开发者提供了一种全新的方式来构建快速、可伸缩的网络应用。本文将为您介绍Node.js的基础知识，以及如何在不同操作系统上进行简单的安装，为您进入Node.js开发的世界打下基础。
一、什么是Node.js？ Node.js是一个基于Chrome V8引擎的JavaScript运行时，用于构建高性能、可伸缩的网络应用。它使得我们可以使用JavaScript语言开发服务器端的应用程序，而不仅仅局限于浏览器端的脚本语言。
Node.js采用了事件驱动、非阻塞I/O的模型，这使得它非常适合构建实时应用程序，如聊天应用、在线游戏等。同时，Node.js的包管理工具npm（Node Package Manager）也是其强大功能之一，拥有丰富的第三方库和模块，可以方便地进行模块化开发。
二、安装Node.js 在开始使用Node.js之前，我们首先需要安装Node.js运行时环境。以下是在不同操作系统上安装Node.js的简单步骤：
2.1 Windows系统 访问Node.js官方网站 下载地址。
在网站首页，选择LTS（长期支持）版本，点击下载安装包。
打开下载的安装包，按照安装向导进行安装。
安装完成后，打开命令提示符或PowerShell，输入以下命令验证安装是否成功：
node -v npm -v 如果能够分别输出Node.js和npm的版本号，则说明安装成功。
2.2 macOS系统 使用Homebrew（包管理器）进行安装，打开终端并输入以下命令：
brew install node 安装完成后，同样在终端中输入以下命令验证安装：
node -v bash npm -v 2.3 Linux系统 在终端中使用包管理器安装Node.js，例如使用apt：
sudo apt-get update sudo apt-get install nodejs sudo apt-get install npm 验证安装：
node -v bash npm -v 安装完成后，你就成功地在你的系统上配置了Node.js。现在，你可以开始使用Node.js来构建服务器端应用程序，或者利用npm安装各种有用的模块和库进行开发。希望你享受Node.js带来的便利和强大功能！
三、运行js代码 在我们的vscode里面新建一个js文件
然后终端打开对应目录
输入node 对应文件
总结 通过本文，我们对Node.js有了一个基本的认识，并学习了如何在不同操作系统上安装Node.js。Node.js的强大功能和灵活性为开发者提供了丰富的工具和资源，使得构建现代化、实时的应用程序变得更加容易。在深入学习Node.js的过程中，我们将能够利用其事件驱动的模型、非阻塞I/O等特性，构建出更加高效、响应迅速的应用，迎接互联网时代的挑战。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3caa63fba14489a1b4e1908d5b2ec444/" rel="bookmark">
			微软警告：APT29间谍攻击猖狂；思科关键漏洞允许黑客远程接管统一通信系统；Jenkins漏洞远程代码执行攻击| 安全周报0126
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 微软警告：针对全球组织的APT29间谍攻击正在扩大 注：APT29是一个与俄罗斯情报机构有关的黑客组织，也被称为Cozy Bear、The Dukes或Office Monkeys。该组织以针对政府机构、外交实体、智库、国防承包商、能源、航空航天、科研、IT公司以及其他关键基础设施实体进行长期、复杂的网络间谍活动而闻名。
微软周四表示，2023年11月下旬对其系统发起网络攻击的俄罗斯国家支持威胁行动者一直在瞄准其他组织，微软目前正开始通知这些组织。
此前一天，惠普企业（HPE）透露，其曾受到一个黑客组织的攻击，该组织被追踪为APT29，也被称为BlueBravo、Cloaked Ursa、Cozy Bear、Midnight Blizzard（前称Nobelium）和The Dukes。
微软威胁情报团队在一份新的咨询报告中表示：“已知该威胁行动者主要针对美国和欧洲的政府、外交实体、非政府组织（NGO）和IT服务提供商。”
来源：https://thehackernews.com/2024/01/microsoft-warns-of-widening-apt29.html
2. 俄罗斯TrickBot幕后主使因网络犯罪被判5年监禁 美国司法部（DoJ）宣布，40岁的俄罗斯公民弗拉基米尔·杜纳耶夫因参与创建和分发TrickBot恶意软件而被判处五年零四个月监禁。
此消息发布于杜纳耶夫对计算机欺诈和身份盗窃以及共谋实施电汇欺诈和银行欺诈的指控表示认罪后近两个月。
司法部表示：“医院、学校和企业等都是数百万TrickBot受害者中的一员，他们遭受了数千万美元的损失。在活动期间，TrickBot恶意软件作为初始入侵媒介侵入受害者计算机系统，被用来支持各种勒索软件变体。”
TrickBot最初于2016年作为银行木马出现，后来演变为一把瑞士军刀，能够传递包括勒索软件在内的额外有效载荷。在试图摧毁僵尸网络之后，它于2022年被Conti勒索软件组织吸收。
来源：https://thehackernews.com/2024/01/russian-trickbot-mastermind-gets-5-year.html
3. Cisco 关键漏洞允许黑客远程接管统一通信系统 Cisco 已发布补丁，以解决影响其统一通信和联络中心解决方案产品的关键安全漏洞。该漏洞可能允许未经身份验证的远程攻击者在受影响的设备上执行任意代码。
该问题被追踪为CVE-2024-20253（CVSS评分：9.9），源于对用户提供的数据处理不当，攻击者可利用此漏洞向易受攻击设备的监听端口发送特制消息。
Cisco 在一份公告中表示：“成功利用此漏洞的攻击者可以在底层操作系统上以网络服务用户的权限执行任意命令。通过访问底层操作系统，攻击者还可以在受影响的设备上建立root访问权限。”
Cisco 建议用户立即应用提供的补丁以修复此漏洞，防止潜在的攻击。此事件再次强调了及时打补丁和更新系统的重要性，以确保网络安全。
来源：https://thehackernews.com/2024/01/critical-cisco-flaw-lets-hackers.html
4. Jenkins漏洞使服务器面临远程代码执行攻击 开源的持续集成/持续交付和部署（CI/CD）自动化软件Jenkins的维护者已经解决了九个安全漏洞，其中包括一个关键漏洞。如果成功利用该漏洞，可能会导致远程代码执行（RCE）。
该问题被分配了CVE标识符CVE-2024-23897，并被描述为通过内置命令行界面（CLI）的任意文件读取漏洞。
“Jenkins在处理CLI命令时，使用args4j库来解析Jenkins控制器上的命令参数和选项，”维护者在周三的一份公告中说。
“这个命令解析器有一个功能，它会替换参数中@字符后面的文件路径为文件的内容（expandAtFiles）。此功能默认启用，并且在Jenkins 2.441及更早版本、LTS 2.426.2及更早版本中并未禁用。”
针对这个问题，Jenkins的维护者已经发布了安全补丁，建议所有使用Jenkins的用户尽快更新到最新版本，以防止潜在的攻击。同时，这也再次提醒我们，对于任何软件，尤其是关键的基础设施软件，保持更新是非常重要的。
来源：https://thehackernews.com/2024/01/critical-jenkins-vulnerability-exposes.html
5. 苹果0Day漏洞补丁发布 周一，苹果发布了针对iOS、iPadOS、macOS、tvOS和Safari网页浏览器的安全更新，以解决一个在野外被积极利用的0Day漏洞。
该问题被追踪为CVE-2024-23222，是WebKit浏览器引擎中的一个类型混淆错误，当处理恶意制作的网页内容时，攻击者可以利用该错误实现任意代码执行。这家科技巨头表示，该问题已通过改进的检查得到修复。
苹果建议所有用户尽快安装这些更新，以确保设备安全并免受潜在攻击。这些安全补丁的发布再次提醒我们，定期更新操作系统和应用程序是保护设备安全的重要一环。
来源：https://thehackernews.com/2024/01/apple-issues-patch-for-critical-zero.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3efd9298219b5c27509a35f0d8b8bc8f/" rel="bookmark">
			F - Dragon Ball I ——最短路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		X星球上有一个关于龙珠的传说：如果有人收集到七个龙珠，龙神就会出现并帮助你实现愿望。
有一天，你惊讶地发现这个故事可能是真的：你在跳蚤市场发现了一个龙珠雷达！雷达会向你显示X星球上七个龙珠的位置。你想不失时机地检查关于为自己许愿的古老传说的真相！
行星X上总共有 n 个城市，编号从 1 到 n 。你目前在城市 1 。要从一个城市到另一个城市，你可以乘坐任意数量的 m 条双向传送之旅。第 i 条传送门每次使用的成本为 ti 枚硬币，它可以将你传送到城市 ai 和 bi 之间。要收集一颗龙珠，你只需要访问雷达上标示的龙珠所在的城市。同一个城市可能有多颗龙珠；在这种情况下，如果你访问了该城市，你可以一次性捡起所有的龙珠。
输入
第一行输入包含两个空格分隔的整数 n和 m（ 1≤n，m ≤2 00000），城市数量和可能的传送行程。然后跟随 包含三个空格分隔整数的 m 行 ai​,bi​,和 ti​ （1 ≤ ai​,bi​ ≤ n,0≤ ti​ ≤ 10000），如上所述，其表示通过传送旅程连接的两个城市，以及使用传送机的成本。然后跟随一行七个空格分隔的整数，代表雷达上显示的七个龙珠的城市ID。每个ID c 满足界 1 ≤ c ≤ n。
输出
打印收集龙珠雷达上显示的所有七个龙珠所需的最低硬币数量。如果无法完成此任务，请打印 −1。
Input1
10 9
1 2 1
2 3 1
3 4 1
4 5 1
5 6 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3efd9298219b5c27509a35f0d8b8bc8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339ca414591158435eb2c8859e1c7dd6/" rel="bookmark">
			字节二面：Spring Boot Redis 可重入分布式锁实现原理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是码哥，可以叫我靓仔。
书接上回，码哥上一篇《纠正误区：这才是 SpringBoot Redis 分布式锁的正确实现方式》分享了分布式锁如何从错误到残缺，再到青铜版本的高性能 Redis 分布式锁代码实战，让你一飞冲天。
这是我们最常用的分布式锁方案，今天码哥给你来一个进阶。
Chaya：「码哥，上次的分布式锁版本虽然好，但是不支持可重入获取锁，还差一点点意思。」
Chaya 别急，今日码哥给你带来一个高性能可重入 Redis 分布式锁解决方案，直捣黄龙，一笑破苍穹。
什么是可重入锁 当一个线程执行一段代码成功获取锁之后，继续执行时，又遇到加锁的代码，可重入性就就保证线程能继续执行，而不可重入就是需要等待锁释放之后，再次获取锁成功，才能继续往下执行。
public synchronized void a() { b(); } public synchronized void b() { // doWork } 假设 X 线程在 a 方法获取锁之后，继续执行 b 方法，如果此时不可重入，线程就必须等待锁释放，再次争抢锁。
锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~
可重入锁实现原理 Chaya：「Redis String 数据结构无法满足可重入锁，key 表示锁定的资源，value 是客户端唯一标识，可重入没地方放了。」
我们可以使用 Redis hash 结构实现，key 表示被锁的共享资源， hash 结构的 fieldKey 存储客户端唯一标识，fieldKey 的 value 则保存加锁的次数。
图 5-26 加锁原理 可重入锁加锁的过程中有以下场景需要考虑。
锁已经被 A 客户端获取，客户端 B 获取锁失败。
锁已经被客户端 A 获取，客户端 A 多次执行获取锁操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/339ca414591158435eb2c8859e1c7dd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5f2a1813806e8ba9ce99db4d84e4be/" rel="bookmark">
			HCIP---OSPF实验1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要求：1.合理规划IP地址，启用OSPF单区域
2.R1-R2之间启用PPP的pap单向认证
3.R2-R3之间启用PPP的chap认证
4.R3-R5-R6之间使用MGER，R3为hub端，R5 R6为spoke端；要求MGER接口网络类型为 BMA，spoke之间通信必须经过hub端
5.全网可达
1.配置IP地址，启用OSPF单区域 R1：
R2：
R3:
R4:
R5:
R6:
2.R1-R2之间启用PPP的pap单向认证 3.R2-R3之间启用PPP的chap认证 4.R3为hub端 R5 R6为spoke端，启用MGRE 查看R5 R6 端口只包含R3
从R6联系R5须通过R3 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/7/">«</a>
	<span class="pagination__item pagination__item--current">8/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/9/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>