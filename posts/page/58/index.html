<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db04dc00bb22a662c5cf7473a0f5d82e/" rel="bookmark">
			在table表单的多选功能里面做单选，点击全选选择最后一条数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看效果
， 这些功能其实很简单，主要是这二个事件
每次勾选都要清空原来的选择，点击全选的时候直接拿到数组的最后一条把它变为true。
点击单选的时候也是清空原来的选择，只是要注意，第一次选择只有一条数据所以加个else，点击第二个勾选就需要进行到val。legnth大于1的判断里面去了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c850a5067cb0d3c7d321ffd97c41a130/" rel="bookmark">
			oneforall安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OneForAll-子域名收集工具kali安装教程 1. oneforall下载 使用git clone url的形式来下载软件，首先需要下载git
apt-get install git
注意：非root用户需要在前面加上sudo
有两个途径可以下载oneforall，第一个是gitee上的，第二个是github上的（我用的第一个）
git clone https://gitee.com/shmilylty/OneForAll.git
git clone https://github.com/shmilylty/OneForAll.git
复制上面任意一个git clone，到kali中打开终端查看当前路径（会安装到当前路径下）
pwd
然后粘贴下载命令，开始下载
2. oneforall查看是否安装成功 跳转到OneForAll目录下,查看是否安装成功
cd OneForAll
python3 oneforall.py --help
注意：要python3，kali应该自己安装的有，不知道的可以输入python3看看，有对应版本就是有的
如果没有提示错误，则说明安装成功了，如果提示错误，则按照下面步骤
3. oneforall报错解决 可能是源不对。解决方法：更换为阿里的源 vi /etc/apt/sources.list
具体的源我就不列出来了，自己网上找一下，然后替换到上面的打开的文件里就行
最后刷新一下源列表
sudo apt-get update
没有对应的模块。解决方法：缺什么模块就安装什么模块 我出现的就是这个问题，所以详细写一下
在输入python3 oneforall.py --help后，出现下图错误
提示缺少fire模块，安装一下就行
pip3 install fire
我以为安装一个模块就行了，但是，这只是一个开始，安装好后我又输入python3 oneforall.py --help 发现又出现缺少模块，我直接把缺少的模块截图全部附一下
出一个，我直接 pip3 install xx 一个，最后终于跳出帮助页面
退出帮助页面 ：q
然后我查看了一下这个oneforall的版本
python3 onforall.py version
4. 帮助文档 最后附上OneForAll v0.4.5 的文档
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c850a5067cb0d3c7d321ffd97c41a130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c73cba8d4d05ff67f564b17934fd1e/" rel="bookmark">
			【实战】Python爬虫之代理使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python爬虫中，代理的使用非常常见。代理的主要作用是隐藏客户端的真实IP地址，从而实现更高的网络访问速度和更好的访问隐私保护。下面我们将通过Python爬虫的实例，带你详细了解Python爬虫中代理的使用方法。
目录
## 1. 代理原理和作用
## 2. Python爬虫代理的使用方式
## 3. 代理IP的获取
## 4. 多线程和多进程使用代理
## 5. 请求头的设置
总结
## 1. 代理原理和作用 代理是一种中间层服务器，在客户端和目标服务器之间传送请求和响应。代理可以缓存请求结果，从而大大减少网络请求的次数，也可以隐藏客户端真实IP地址，避免被目标服务器识别。
代理主要有以下作用：
- 隐藏客户端的真实IP地址，防止被服务器识别。
- 帮助访问本地系统无法访问的服务器。
- 缓存目标服务器的结果，避免重复请求浪费资源。
- 通过代理负载均衡优化网络请求的响应速度。
## 2. Python爬虫代理的使用方式 Python爬虫代理的使用，可以通过更改HTTP请求头信息或通过某些库辅助实现。例如，urllib和requests库中都已经提供了代理IP相关的设置方法。urllib库的代理IP设置可以通过创建代理处理器（proxy handler）实现：
import urllib.request proxy_handler = urllib.request.ProxyHandler({'http': 'http://127.0.0.1:8000'}) opener = urllib.request.build_opener(proxy_handler) urllib.request.install_opener(opener) response = urllib.request.urlopen('http://httpbin.org/ip') print(response.read().decode()) 代码中，即通过proxy_handler设置http代理进行访问。可以将这个代理handler作为参数传入build_opener创建一个opener，再通过urllib.request.install_opener()方法将opener设置为默认opener，最终通过response读取url对应的数据。如果proxy_handler、opener、install_opener方法都不清楚的话，可参阅Python标准库文档。
同样requests库中提供的代理IP设置代码如下：
import requests proxies = { "http": "http://127.0.0.1:8000", "https": "http://127.0.0.1:8000", } response = requests.get('http://httpbin.org/ip',proxies=proxies) print(response.content.decode()) 其中，在requests库中可以通过proxies参数设置代理IP，实现对目标网站的访问。
## 3. 代理IP的获取 在使用Python爬虫代理的过程中，要获取可用的代理IP非常关键。使用免费代理IP时，需要注意代理IP的质量和失效率，避免使用低质量的代理IP而导致爬虫失败或者被封禁。这里推荐站大爷代理IP供大家参考。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56c73cba8d4d05ff67f564b17934fd1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98059a62c68cd1a09328b96f4ed40c1/" rel="bookmark">
			前端通过post请求上传图片到oss,使用服务端签名直传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单说明： 根据上一篇我写的【前端上传图片到阿里云】,
这个的上传是通过oss的put方法上传的，并且配置是前端写死的，这样的安全性较低，比较好的方式还是在后台生成签名，后台将签名返回给前端，前端使用签名上传文件到OSS。服务端签名直传适用于上传大文件，客户端上传的数据量较小，适合需要控制上传的安全性的场景。官方文档：服务端签名直传，小程序上传还是之前那个，现在说的是vue的web端上传。这里不用引入ali-oss
1.引入axios import axios from 'axios' 2.从后端获取签名 这里就需要和后端商量调后端的接口，让后端返回policy和signature，
3.上传oss getoss({}).then((res) =&gt; {//这个是我调的后端接口，你们改成自己的 if (res.code == 0) {//调接口成功 var formData = new FormData() //注意formData里append添加的键的大小写 formData.append('key', url) //存储在oss的文件路径，如 a/b.jpg formData.append('OSSAccessKeyId', res.data.accessKeyID) //accessKeyId formData.append('policy', res.data.policy) //policy formData.append('Signature', res.data.signature) //Signature //如果是base64文件，那么直接把base64字符串转成blob对象进行上传就可以了 formData.append('file', file) formData.append('success_action_status', 200) //成功后返回的操作码 axios({ method: 'post', //bucketName和region都是可以去oss上得到的 url: `http://post-test.oss-cn-hangzhou.aliyuncs.com`, //这个地址是bucketname和区域拼接的 data: formData, withCredentials: false, headers: { 'Content-Type': 'multipart/form-data', }, }).then((value) =&gt; { if (value.status == 200) { console.log('上传成功', value) } else { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a98059a62c68cd1a09328b96f4ed40c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8606655d59c6d4a5062f0a417f844107/" rel="bookmark">
			python实现学生管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用python实现的命令行版本的学生管理系统 一、系统分析（一）功能模块图（二）模块描述（三）流程控制图 二、系统设计实现（一）主函数（二）保存和加载函数（三）新增学生函数（四）显示函数（五）删除函数（六）查找函数 三、完整代码 一、系统分析 本系统需要实现对学生信息的添加、显示、删除、查找，最后要将学生的信息保存到文件当中，永久化存储。
注：还需要什么功能可以在此基础上扩展
（一）功能模块图 本系统的主要模块如下图所示：
（二）模块描述 1、新增学生模块
用户先输入要新增的学生个数，然后添加每个学生具体信息，具体信息包括：学号、姓名、性别、班级。在新增学号、性别的时候进行合法检测，每个学生的学号是唯一的，性别必须是男或者在女
2、显示学生模块
将所有的学生信息打印在屏幕上
3、删除学生模块
用户可以根据学号、姓名进行删除，如果有同名的学生，将所有同名的学生打印在屏幕上，让用户输入编号，选择删除哪一个学生
4、查找学生模块
用户可以根据学号、姓名、性别、班级进行查找
（三）流程控制图 本系统的主要流程控制如下图所示：
二、系统设计实现 （一）主函数 1、主函数中实现程序的整体逻辑控制
2、程序每次开始运行时，先将文件中的数据加载到一个studentsList的全局变量中，studentsList类型是列表，再打印主菜单，用户输入选项选择对应的功能。每当执行完任一种功能后，都会再次返回到主菜单，当选择0的时候，则退出程序，退出程序前需要将本次运行后的数据保存到文件当中
# 主菜单 def mainMenu(): print('*******************************************') print('***** 《学生管理系统》 *****') print('***** 1、新增学生 *****') print('***** 2、显示学生 *****') print('***** 3、删除学生 *****') print('***** 4、查找学生 *****') print('***** 0、退出程序 *****') print('*******************************************') choice = input('请输入你的选择：') return choice # 主函数 def main(): load() # 程序每次运行前，先将文件中的数据加载过来 while True: choice = int(mainMenu()) # 打印菜单 if choice == 1: # 新增学生 insert() elif choice == 2: # 显示学生 show() elif choice == 3: # 删除学生 delete() elif choice == 4: # 查找学生 find() elif choice == 0: # 退出程序 save() # 将信息保存到文件当中 sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8606655d59c6d4a5062f0a417f844107/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6320dd207f5f9c9744c579fb8c52d378/" rel="bookmark">
			springboot&#43;mysql学生请销假审批管理系统-计算机毕业设计源码10262
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
21世纪的今天，随着社会的不断发展与进步，人们对于信息科学化的认识，已由低层次向高层次发展，由原来的感性认识向理性认识提高，管理工作的重要性已逐渐被人们所认识，科学化的管理，使信息存储达到准确、快速、完善，并能提高工作管理效率，促进其发展。
本设计主要实现集人性化、高效率、便捷等优点于一身的学生请销假审批管理系统，完成请假申请管理、长假审核管理、销假申请管理、健康上报管理等功能模块。系统通过浏览器与服务器进行通信，实现数据的交互与变更。只需通过一台电脑，动动手指就可以操作系统，实现数据通信管理。整个系统的设计过程都充分考虑了数据的安全、稳定及可靠等问题，而且操作过程简单。本系统通过科学的管理方式、便捷的服务提高了工作效率，减少了数据存储上的错误和遗漏。学生请销假审批管理系统使用Java语言，采取Mysql作为后台数据的主要存储单元，采用Springboot框架、JSP技术、Ajax技术进行业务系统的编码及其开发，实现了本系统的全部功能。
关键词：学生请销假审批管理；Springboot框架；关系型数据库
Springboot student leave approval management system
Abstract
Today in the 21st century, with the continuous development and progress of society, people's understanding of information science has developed from low level to high level, from the original perceptual knowledge to rational knowledge, and the importance of management has gradually been recognized by people. Scientific management can make information storage accurate, fast and complete, and can improve work management efficiency and promote its development.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6320dd207f5f9c9744c579fb8c52d378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/284d073c9e4155d993f27e71b3996c6a/" rel="bookmark">
			MySQL忘记/无root密码，强制修改root密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL忘记/无root密码强制修改root密码 重置MySQL的root密码步骤如下：步骤一：在命令行输入以下命令强制不检测mysql登录时的密码：步骤二：取消免密登录步骤三：测试root密码是否重置成功 重置MySQL的root密码步骤如下： 步骤一：在命令行输入以下命令强制不检测mysql登录时的密码： sudo vi /etc/mysql/my.cnf 修改文件如下（用于忽略mysql登入密码）：
[mysqld] skip-grant-tables 保存退出my.cnf
继续执行：
sudo service mysql restart mysql -u root -p use mysql; update mysql.user set authentication_string='' where user="root" and host="localhost"; flush privileges; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root'; exit; 步骤二：取消免密登录 将my.cnf的‘skip-grant-tables’注释掉或删掉，注释方法为在语句开头加上‘#’
步骤三：测试root密码是否重置成功 mysql -u root -p 输入你的新密码即可登录测试。
至此，在忘记或安装完MySQL，没有其root密码的情况下，以上步骤可帮助你快速重置MySQL的root密码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2f4f320a8b4882c6c390abc801ccda/" rel="bookmark">
			什么是vggnet?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VGGNet（Visual Geometry Group Network）是一种深度卷积神经网络，由牛津大学的研究团队开发，用于图像分类和识别任务。VGGNet于2014年在ImageNet Large-Scale Visual Recognition Challenge（ILSVRC）比赛中获得第二名，并因其卓越的性能和简单的架构而受到广泛关注。
VGGNet的主要特点是采用了非常深的网络结构，它使用了16层或19层的卷积层和全连接层。网络的基本组成部分是由卷积层和池化层交替堆叠而成的卷积块。VGGNet中的卷积层都采用了小尺寸（3x3）的卷积核，这种设计可以增加网络的深度，同时减少参数数量。池化层则用于逐渐降低特征图的空间维度。
VGGNet的一个重要贡献是证明了增加网络深度可以提升图像分类的性能。通过堆叠多个卷积块，VGGNet可以学习到更加复杂和抽象的图像特征，使得网络具有更强的表征能力。然而，由于VGGNet较深的结构，其参数量也相对较大，导致训练和推理过程的计算成本较高。
尽管VGGNet在ILSVRC比赛中表现出色，但在后续的研究中，一些更深、更高效的网络结构如ResNet、Inception和MobileNet等相继出现，取得了更好的性能。然而，VGGNet仍然是深度卷积神经网络领域的里程碑之一，为后续的研究奠定了基础，并广泛应用于图像分类、目标检测和语义分割等计算机视觉任务中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e37a3cf6dc5b2234145defaa9efbab/" rel="bookmark">
			微信小程序之 页面跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wx.navigateTo：保留当前页面，跳转到应用内的某个页面。使用 wx.navigateBack 可以返回原页面。该方法可以传递参数。（不能直接跳转tabBar页面）
wx.redirectTo：关闭当前页面，跳转到应用内的某个页面。不可返回原页面。该方法可以传递参数。（不能直接跳转到 tabBar 页面）
wx.switchTab：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。
wx.reLaunch：关闭所有页面，打开应用内的某个页面。
wx.navigateToMiniProgram：跳转到其他小程序。
wx.navigateToWebview：跳转到一个网页，可以在小程序内嵌入一个 webview 组件来展示网页。
wx.navigateBack：关闭当前页面，返回上一页面或多级页面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f36c2d77c7babd8a1a5454a1b743da53/" rel="bookmark">
			常用数字设计仿真工具(Questa,VCS,IUS/Xcelium,Verdi等)使用入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 前言
2. QuestaSim基本使用方法
2.1 命令行编译
2.2 命令行运行
2.3 启动GUI进行仿真
2.4 从GUI中进行编译运行
2.5 dump波形
2.6 指定随机种子
2.7 命令行指定testcase名
2.8 其它常用选项
2.9 基于Tcl脚本的运行方法
2.10 其它常用命令
3. VCS基本基本使用方法
3.1 编译
3.1.1 基本编译命令
3.1.2 包含路径的指定
3.1.3 其它常用选项
3.1.4 vcs选项一览表
3.2 vcs两步仿真
3.3 vcs三步仿真 3.4 fsdb波形输出选项
3.5 ucli
3.5.1 基础介绍
3.5.2 常见命令
3.5 VCS与VCS_MX的区别
4. IUS/Xcelium基本使用方法
4.0 帮助查询方法
4.1 基本使用方法
4.2 seed与svseed的区别
4.3 Xcelium
5. Verdi基本使用方法
5.1 verdi直接打开代码
5.2 kdb选项
5.3 verdi直接打开波形
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f36c2d77c7babd8a1a5454a1b743da53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8f58f38e4a91e50fb47a4ebd854721/" rel="bookmark">
			STM32单片机（六）TIM定时器 -＞ 第三节：TIM输出比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️ 专栏简介：本专栏记录了从零学习单片机的过程，其中包括51单片机和STM32单片机两部分；建议先学习51单片机，其是STM32等高级单片机的基础；这样再学习STM32时才能融会贯通。
☀️ 专栏适用人群 ：适用于想要从零基础开始学习入门单片机，且有一定C语言基础的的童鞋。
🌙专栏目标：实现从零基础入门51单片机和STM32单片机，力求在玩好单片机的同时，能够了解一些计算机的基本概念，了解电路及其元器件的基本理论等。
⭐️ 专栏主要内容： 主要学习STM32单片机的功能、各个模块、单片机的外设、驱动等，最终玩好单片机和单片机的外设，全程手敲代码，实现我们所要实现的功能。
🌴 专栏说明 ：如果文章知识点有错误的地方，欢迎大家随时在文章下面评论，我会第一时间改正。让我们一起学习，一起进步。
💑专栏主页：http://t.csdn.cn/HCD8v
本学习过程参考：https://space.bilibili.com/383400717
STM3单片机安装软件、各种资料以及源码的路径：
链接：https://pan.baidu.com/s/1snD0uuTfMhchFqOMWvAiHA?pwd=asdf#list/path=%2F 提取码：asdf
链接里压缩包的解压密码：32
本大节主要学习TIM定时器的相关知识，包含八小节：
第一小节主要学习定时器基本定时的功能，第二小节是对第一小节的内容写两个程序进行练习，分别是定时器定时中断和定时器外部时钟；
第三小节主要学习定时器输出比较的功能，第四小节是对第三小节的内容写三个程序进行练习，分别是PWM驱动LED呼吸灯、PWM驱动舵机以及PWM驱动直流电机；
第五小节主要学习定时器输入捕获的功能，第六小节是对第五小节的内容写两个程序进行练习，分别是输入捕获模式测频率和PWMI模式测频率占空比；
第七小节主要学习定时器的编码器接口功能，第八小节是对第七小节的内容写一个程序进行练习，即编码器接口测速；
最终附上所有的源代码；
本小节主要是学习定时器输出比较的功能；输出比较这个模块最常见的用途就是产生PWM波形，PWM波形又是驱动电机的必要条件，所以常用于驱动电机等设备；在此小节我们将会学习到使用STM32输出PWM波形，来驱动舵机和直流电机；
文章目录 一、输出比价和PWM简介1.1 输出比较简介1.2 PWM简介 二、输出比较基础知识2.1 输出比较通道（通用）2.2 输出比较通道（高级）2.3 输出比较模式 三、PWM基本知识3.1 PWM基本结构3.2 PWM参数计算 四、舵机和直流电机介绍4.1 舵机简介4.2 舵机硬件电路4.3 直流电机及驱动简介4.4 直流电机硬件电路 一、输出比价和PWM简介 1.1 输出比较简介 OC(Output Comepare)输出比较；IC（Input Capture）输入捕获；CC（Capture/Compare）输入捕获和输出比较的单元； 1.2 PWM简介 PWM波形是一个数字输出信号，也是由高低电平组成的；
解释一下PWM应用于控制LED灯亮度（也就是目标一的内容）：
按理说LED灯只能有完全亮和完全灭两种状态，怎么能实现控制亮度大小呢？通过PWM波形就可以实现。我们可以让LED不断点亮、熄灭、点亮、熄灭；当这个点灯、熄灭的频率足够大时，LED就不会闪烁了，而是呈现出一个中等亮度；当我们调控这个点亮和熄灭时间比例时，就能让LED呈现出不同的亮度级别了；
对于电机调速也是一样的道理，我们以一个很快的频率，给电机通电、断电、通电、断电，那么电机的速度就能维持在一个中等速度，这就是PWM的基本思想；
PWM参数的公式，要熟记
占空比等于高电平的时间比上低电平的时间；T_ON是高电平的时间，T_OFF是低电平的时间，T_S是一个周期的时间；所以占空比的含义就是高电平的时间相对于整个周期时间的比例；
比如占空比位50%，那就是高低电平时间相等的方波；波形如下图：
占空比为20%，那就是高电平占20%，低电平占80%，波形如下图
占空比为100%，那就是全程都是高电平；
占空比决定了PWM等效出来的模拟电压的大小； 占空比越大，那等效出来的模拟电压就越趋近于高电平；占空比越小，那等效出来的模拟电压就越趋近于低电平；分辨率就是占空比变化的细腻程度 二、输出比较基础知识 2.1 输出比较通道（通用） 上图的输出比较电路就对应上一节，通用定时器的如下图的红框部分:
左边是CNT和CCR比较的结果，右边就是输出比较电路，最后通过TIM_CH1输出到GPIO引脚上，下面还有三个同样的单元，分别输出到CH2、CH3、CH4；
在上图的输出比较电路图中，左边就是CNT计数器和CCR1第一路的捕获/比较寄存器，他俩进行比较，当CNT&gt;CCR1时，或者CNU=CCR1时，就会给输出模式控制器传一个信号，然后输出模式控制器就会改变它输出oc1ref的高低电平，REF信号实际上就是指这里的高低电平；REF是refense的缩写，即参考信号；
ref信号会到达上述箭头所指位置，这是一个极性选择，给这个寄存器0，信号就会往上走，就是信号电平不反转；给这个寄存器写1，信号就会往下走，就是信号通过一个非门取反，那输出的信号就是输入信号高低电平反转的信号；这就是极性选择，就是选择是不是要把高低电平反转一下；
再往后是输出使能电路，选择要不要输出；
最后是OC1引脚，这个引脚就是CH1通道的引脚；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d8f58f38e4a91e50fb47a4ebd854721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03bb5bd7750e509016f874635eeb9211/" rel="bookmark">
			Java遍历Map的五种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、遍历Map的五种方式 java中遍历map一般有五种方法，从最早的Iterator，到java5支持的foreach，再到java8的Lambda表达式。
如果只是获取key，或者value，推荐使用keySet或者values方式如果同时需要key或者value推荐使用entrySet如果需要在遍历过程中删除元素推荐使用Iterator如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中。 二、准备条件 初始化一个map
Map&lt;Integer,Integer&gt; map= new HashMap&lt;&gt;(); for(int i=0;i&lt;10000;i++){ map.put(i,i+1); } 三、keySet和values方式遍历 如果只是需要获取map的key或者value，用map的keySet或values方法无疑时最方便的
//keySet获取key @Test public void testKeySet(){ for (Integer key: map.keySet()){ System.out.println(key); } } //values获取value @Test public void testValues(){ for (Integer value: map.values()){ System.out.println(value); } } 四、keySet和get(key)方式遍历map 如果需要同时获取key和value，可以先获取key，然后再通过map的get(key)获取value，需要说明的是，该方法不是最优解，一般不推荐使用。
//keySet get(key)获取key 和value @Test public void testKeySetAndGetKey(){ for(Integer key: map.keySet()){ System.out.println(key+":"+map.get(key)); } } 五、entrySet方式遍历map 通过对map entrySet的遍历，也可以同时拿到key和value，一般情况下，性能要优于keySet,这一种也是最常用的遍历方法。
@Test public void testEntry(){ for (Map.Entry&lt;Integer,Integer&gt; entry: map.entrySet()){ System.out.println(entry.getKey()+":"+entry.getValue()); } } 六、Iterator方式遍历map 对于上面的foreach都可以用Iterator在Java5中才被支持，foreach的写法看起来更简洁。但Iterator也有优势：在用foreach遍历map时，如果改变其大小，会报错，但如果只是删除元素，可以使用Iterator的remove方法删除元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03bb5bd7750e509016f874635eeb9211/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f5a44d23827ba8e1cea4ca6a6c9cd5/" rel="bookmark">
			JAVA中的拦截器、过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA变成拦截器、过滤器 一、拦截器1、简介说明2、源码及方法说明3、拦截器自定义应用 二、过滤器1、简介说明2、源码及方法说明3、过滤器的自定义应用 三、Springboot中的WebMvcConfigurer1、简介2、主要方法3、添加拦截器 四、区别1、原理2、触发3、其他 一、拦截器 1、简介说明 相关解释：拦截器依赖于页面有访问controller的操作，且属于SpringMVC体系的动态拦截调用机制，是java中AOP思想的运用。
来看看源码作者的注释：
其中倒数第二段话，描述其类似于过滤器，但其特点只允许使用自定义预处理，不能处理程序本身。此处可体现AOP思想。
过滤器是在web.xml中配置，web.xml是应用程序上下文中的HandlerInterceptor。
最后一段话，则体现了拦截器常用情况，如常见处理程序代码和授权检查。
而过滤器非常适合请求内容和视图内容处理，如多部分表单和GZIP压缩。
2、源码及方法说明 HandlerInterceptor
HandlerInterceptor接口中有3个方法:
preHandler()：该方法会在控制器方法前执行，其返回值表示是否中断后续操作。当其返回值为true时，表示继续向下执行；当其返回值为false时，会中断后续的所有操作。
postHandle()：该方法会在控制器方法调用之后，且解析视图之前执行。可以通过此方法对请求域中的模型和视图做出进一步的修改。
afterCompletion()：该方法会在整个请求完成，即视图渲染结束之后执行。可以通过此方法实现一些资源清理、记录日志信息等工作。
3、拦截器自定义应用 实现 org.springframework.web.servlet.HandlerInterceptor 接口
如常见的白名单控制
package com.framework; import com.alibaba.fastjson.JSON; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @Component public class WhiteRosterInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if(checkWhiteList()){ return true; } response.setContentType("application/json; charset=utf-8"); response.setCharacterEncoding("UTF-8"); response.getWriter().append(JSON.toJSONString("白名单暂未设置")); return false; } private Boolean checkWhiteList(){ //业务处理 return true; } } 二、过滤器 1、简介说明 相关解释：java过滤器能够对目标资源的请求和响应进行截取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8f5a44d23827ba8e1cea4ca6a6c9cd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cf47f69b520d85d1b8b5ba1dcb14984/" rel="bookmark">
			花十分钟用Python写了个蹭WiFi的软件，于是获取了隔壁单身妹子的WiFi试了试效果，居然发现...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python写一个免费蹭WiFi的神器 前因后果注意事项主要代码效果展示怎么学好Python？ 前因后果 昨晚十点学姐跟我发消息说她家的WiFi 不知道为什么今天就很慢，让我赶紧去她家帮她看看，当时我就怒了，这大晚上的我都要睡觉了还给我整这破事，但是没办法，谁让她是我学姐呢。
但是过去是不可能过去的，都这么晚了，男孩子要学会自己保护自己，大晚上的不要乱出门！
还好我会Python，于是我直接开机打开pycharm，花十分钟用Python写了个蹭WiFi的软件，顺便获取了隔壁单身妹子的WiFi试了试效果，居然发现还挺好用，网速杠杠的！
注意事项 开始分享之前，还是要给大家提示一下：
wifi万能钥匙不能用于商用，仅供学习使用；一旦商用出现任何不好影响，都跟小编无关； 主要代码 这里我们基于Tkinter库进行开发
from tkinter import * import pywifi from pywifi import const import time import tkinter.filedialog # 在Gui中打开文件浏览 import tkinter.messagebox # 打开tkiner的消息提醒框 class WIFI_GUI(): def __init__(self, init_window_name): self.init_window_name = init_window_name # 密码文件路径 self.get_value = StringVar() # 设置可变内容 # 获取破解wifi账号 self.get_wifi_value = StringVar() # 获取wifi密码 self.get_wifimm_value = StringVar() # 抓取网卡接口 self.wifi = pywifi.PyWiFi() # 抓取第一个无线网卡 self.iface = self.wifi.interfaces()[0] # 测试链接断开所有链接 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cf47f69b520d85d1b8b5ba1dcb14984/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80caf35d654bd4d94aa8056419ab8c71/" rel="bookmark">
			蓝桥杯单片机第十四届省赛题目和程序答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、前言
2、题目
3、程序架构 3.1 display.c
3.2 ds1302.c
3.3 iic.c
3.4 onewire.c
3.5 main.c 主函数文件
3.6 环境配置
4. 历年蓝桥杯单片机试题和答案
1、前言 抽空复习了一下，拿下单片机省赛一等奖，在此分享一下最新的14届省赛程序设计答案
2、题目 3、程序架构 模块化编程，每个模块的程序单独写在一个文中，下面分别给出图中文件的详细代码
3.1 display.c 主要包含数码管、led显示。
#include "display.h" code unsigned char Seg_Table[] = { 0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90, //9 0x88, //A 0x83, //b 0xc6, //C 12 0xa1, //d 0x86, //E 0x8e, //F 15 0xbf, // - 16 0x89, // H 17 0x8C, // P 18 0x88 // R 19 }; //0-9带小数点 code unsigned char Seg_Table_f[] = { 0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00, 0x10}; void Delayms(int ms)	//@12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80caf35d654bd4d94aa8056419ab8c71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a2ac223f291fc6ca3a29fc82f565ab0/" rel="bookmark">
			WPS表格Excel：向下取某值的最大公倍数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：向下取原值的3的最大公倍数
公式：=ROUNDDOWN(A2/3,0)*3
公式解读，先向下取整原值除以3的值，再乘3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce7bbe6a7e3ce6aa38f0ccb320da16ac/" rel="bookmark">
			appscan扫描https协议之安装证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 下载证书
2. 把证书安装到火狐浏览器
3. 手工探测绕过登录 我们工作中最常遇到的工作场景是网站采用https协议，这时我们要用appscan进行扫描时，就需要先安装证书。
1. 下载证书 点击【手动扫描】，选择【外部设备】，
点击【记录代理配置】，选择【记录代理】，
找到AppScan SSL 证书，点击【导出】，选择存储位置，点击【保存】，导出压缩包成功后，点击【取消】
解压已保存的证书，得到一个crt的安全证书
2. 把证书安装到火狐浏览器 打开火狐浏览器，点击更多按钮，点击【设置】，
搜索【证书】，点击【查看证书】，
选择【证书颁发机构】，点击【导入】，选择所有文件，选中证书，点击【打开】
勾选信任，点击【确定】
点击【确定】，导入成功
3. 手工探测绕过登录 扫描过程回遇到网站存在手机验证码、图形验证码、滑动验证等等，这时候想要深度扫描，就需要登录绕过，此时有两种方式可以选择：
第一：使用定制头解决
第二：使用手工探索-外置设置进行登录绕过
①appscan：【手动探索】--【外部设备】-- 记录代理端口号
②火狐浏览器：先进入被测网站，登录，再配置，
开启代理，注意端口号的一致性，选择【appscan】
③手动进行操作
④appscan：【扫描】--【仅测试】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee8ca1f75e8e23992cf114770a28777/" rel="bookmark">
			推荐两个阅读论文的ai辅助网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Typeset.io（推荐，免费好用，功能强大） ChatDOC（不免费） ChatPDF(只是提取文字调用api) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7801cdda2adfa1757d0f3dfa2b7e791/" rel="bookmark">
			pyhton爬虫基础（六）urllib中的urlopen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习爬虫，最初的操作便是模拟浏览器向服务器发出请求。
我们只需要关心请求的链接是什么，需要的参数是什么，以及如何设置可选的请求头就行了，不需要深入了解它是怎样传输和通信的。
一、使用urllib 它是Pyhton内置的HTTP请求库，包含四个模块。
request：它是最基本的HTTP请求模块，可以用来模拟发送请求。就像在浏览器里输入网址然后回车一样，只用给库方法传入URL以及额外的参数，就可以模拟实现这个过程。
error：异常处理模块。
parse：一个工具模块，提供了许多处理URL方法。如拆分、解析、合并等。
robotparser：主要用识别网站的robots.txt文件，判断网站是否能爬取，一般不用。
1.发送请求 使用urllib的request模块，我们可以方便地实现请求的发送并得到响应。下面是具体用法。
(1)urlopen（） urllib.request模块提供了最基本的构造HTTP请求的方法，它还带有处理授权验证、重定向、浏览器Cookies以及其他内容。
import urllib.request resonse=urllib.request.urlopen('https://www.python.org') print(resonse.read().decode('utf-8')) 只需两行代码就实现Python官网的抓取，输出了网页的源代码。得到源代码后，我们就可以从中提取链接、网图地址、文本信息。
接下来看看它返回的是啥，用type（）方法输出响应类型：
import urllib.request resonse=urllib.request.urlopen('https://www.python.org') print(type(resonse)) 输出结果如下：
可以发现它是一个HTTPResonse类型的对象，主要包含read（）、readinto（）、getheader（name）、getheaders（）、fileno（）等方法，以及msg、version、status、reason、debuglevel、closed等属性。
得到这个对象后，我们把它赋值为response变量，然后就可以调用这些方法和属性，得到返回结果的一系列信息了。
data参数
data参数是可选的。如果要添加bytes类型的内容，则需要通过bytes（）方法转化。如传递了这个参数，则它的请求方式就不再是GET方式而是POST方式。
该方法第一个参数需要的是str类型，需要用urllib.parse模块里的urlencode（）方法来将参数字典转化为字符串：第二个参数指定编码格式。
timeout参数
timeout参数用于设置超时时间，单位为秒，意思就是如果超出了设置的这个时间，还没有得到响应，就会抛出异常。如果不指定该参数，就会使用全局默认时间。支持HTTP、HTTPS、HTP请求
因此，可以通过设置这个超时时间来控制一个网页如果长时间未响应，就跳过它的抓取。这可以利用try except语句来实现，
import socket import urllib.request import urllib.error try: response=urllib.request.urlopen('http://httpbin.org/get',timeout=0.1) except urllib.error.URLError as e: if isinstance(e.reason, socket.timeout): print('TIME OUT') 其他参数
context参数必须是ssl,SSLContext类型，用来指定SSL设置。
cafile和capath这俩参数分别指定CA证书和它的路径，这个在请求HTTPS链接时有用。
cadefault参数现在已经弃用了，其默认值为False。
更详细信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab46247967a3a7a01aa764ccf73db4e9/" rel="bookmark">
			编译原理 | 课程设计 — PL/0编译程序语义分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、任务描述 基于第二章的词法分析程序和第三章的语法分析程序，使用C/C++语言编写PL/0编译程序的语义分析程序，并生成四元式形式的中间代码。
2、编程要求 完成上述编程任务，将C/C++语言源程序复制粘贴到右侧代码编辑器，点击“评测”按钮，运行程序，系统会自动进行结果对比。
3、测试说明 平台会对你编写的代码进行测试：
测试输入：
const a = 10; var b, c; //单行注释 /* * 多行注释 */ procedure p; if a &lt;= 10 then begin c := b + a; end; begin read(b); while b # 0 do begin call p; write(2 * c); read(b); end; end. 预期输出：
语义正确 中间代码: (1)(syss,_,_,_) (2)(const,a,_,_) (3)(=,10,_,a) (4)(var,b,_,_) (5)(var,c,_,_) (6)(procedure,p,_,_) (7)(j&lt;=,a,10,$8) (8)(+,b,a,c) (9)(ret,_,_,_) (10)(read,b,_,_) (11)(j#,b,0,$13) (12)(j=,b,0,$17) (13)(call,p,_,_) (14)(*,2,c,T1) (15)(write,T1,_,_) (16)(read,b,_,_) (17)(syse,_,_,_) 符号表: const a 10 var b 0 var c 0 procedure p 测试输入：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab46247967a3a7a01aa764ccf73db4e9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/57/">«</a>
	<span class="pagination__item pagination__item--current">58/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/59/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>