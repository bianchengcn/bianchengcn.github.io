<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c3f7703962e6872aa29f1c8c65168ec/" rel="bookmark">
			人工智能时代：AI提示工程的奥秘 —— 驾驭大语言模型的秘密武器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引言二、提示工程与大语言模型三、大语言模型的应用实践四、策略与技巧五、结语《AI提示工程实战：从零开始利用提示工程学习应用大语言模型》亮点内容简介作者简介目录获取方式 一、引言 随着人工智能技术的飞速发展，大语言模型作为一种新型的机器学习模型，已经在自然语言处理领域取得了显著的成果。然而，如何将这些模型应用到实际问题中，一直是研究人员和工程师面临的重要挑战。本文将探讨如何利用提示工程学习应用大语言模型，以解决实际问题的具体实践和策略。
二、提示工程与大语言模型 提示工程是指通过提供示例、模板或指导信息，引导机器学习模型生成所需输出的技术。在大语言模型中，提示工程可以用来指导模型生成特定主题、风格的文本，或者解决特定的问题。通过精心设计的提示，我们可以充分利用大语言模型的强大能力，实现更加高效、精准的应用。
三、大语言模型的应用实践 文本生成：利用大语言模型生成高质量的文本内容，如小说、新闻、评论等。通过提示工程，可以控制生成文本的主题、风格和格式，以满足不同应用场景的需求。问答系统：通过训练大语言模型来回答用户的问题。通过提示工程，可以引导模型生成准确、简洁的答案，提高问答系统的用户体验。机器翻译：利用大语言模型进行多语言翻译。通过提示工程，可以优化翻译质量和效率，提高机器翻译的准确性和流畅性。智能客服：利用大语言模型构建智能客服系统，提供高效、便捷的客户服务。通过提示工程，可以定制化服务内容和响应方式，提高客户满意度。情感分析：利用大语言模型进行情感分析，挖掘文本中的情感倾向和语义信息。通过提示工程，可以提高情感分析的精度和稳定性。 四、策略与技巧 精心设计提示：针对具体任务和应用场景，设计简洁明了、具有指导性的提示信息。这有助于提高大语言模型的生成质量和效率。利用上下文信息：将上下文信息作为提示的一部分，引导大语言模型理解任务的背景和需求。这有助于提高模型的语义理解和生成能力。优化训练数据：为了提高大语言模型的性能，需要使用大规模的高质量数据进行训练。通过优化数据集的选择和标注方法，可以提高模型的泛化能力和准确性。探索多模态融合：将文本、图像、音频等多种模态的信息融合到大语言模型中，可以提高模型的感知和理解能力。通过多模态的提示和输入，可以拓展大语言模型的应用领域和效果。持续优化和调参：在应用大语言模型的过程中，需要持续地对模型进行优化和调参。通过不断的实践和迭代，可以找到最佳的模型配置和应用策略，提高模型的性能和稳定性。 五、结语 掌握了提示工程的艺术，你就能更好地与大语言模型沟通，发挥它们的最大效能。这不仅是一项技能，更是一种理解机器智能并能与之和谐共处的方式。让我们在智慧的海洋中乘风破浪，探索更多未知的可能。
《AI提示工程实战：从零开始利用提示工程学习应用大语言模型》 学会构建高质量的提示指令，掌握利用人工智能工具的艺术，成为与AI交流的高手。
掌握AI大语言模型，开启智能应用新时代！
亮点 ★全新起点：本书从大语言模型的使用环境出发，引导读者逐步实践、深入应用“提示工程”。★技术前沿：紧随技术发展趋势，介绍并探讨前沿技术应用，启发读者发掘更多潜在应用价值。★体系完善：章节内容组织得当，形成易于学习和理解的技术体系，帮助读者轻松掌握核心知识点。★实用导向：结合丰富提示实例进行讲解，提供实际应用场景中的解决方案，助读者解决工作、学习中的实际问题。★示例助力：提供大量提示示例，帮助读者触类旁通，轻松实现举一反三的效果。 内容简介 随着大语言模型的快速发展，语言AI已经进入了新的阶段。这种新型的语言AI模型具有强大的自然语言处理能力，能够理解和生成人类语言，从而在许多领域中都有广泛的应用前景。大语言模型的出现将深刻影响人类的生产和生活方式。本书将介绍提示工程的基本概念和实践，旨在帮助读者了解如何构建高质量的提示内容，以便更高效地利用大语言模型进行工作和学习。
本书内容通俗易懂，案例丰富，适合所有对大语言模型和提示工程感兴趣的读者。无论是初学者还是进阶读者，都可以从本书中获得有价值的信息和实用技巧，帮助他们更好地应对各种挑战和问题。
作者简介 兰一杰，资深软件工程师、项目经理，出版图书《Python大数据分析分析从入门到精通》《从零开始利用Excel与Python进行数据分析》。
于辉，曾组织参与20余项大数据、物联网、区块链等IT软件领域发明专利的研发，在云网边端、数据要素化和数字政府建设领域具有深入的研究和实践经验。
目录 第 1 章　认识大语言模型 1.1 大语言模型是什么 1.2 大语言模型的发展现状 1.3 大语言模型的重要概念 1.4 大语言模型的使用方式 第 2 章　ChatGPT应用体验 2.1 第一次对话 2.2 设计特定语境上下文 2.3 模拟 API 参数 2.4 专业领域助手 2.5 基于对话绘图 2.6 场景总结 第 3 章　ChatGPT API 3.1 准备工作 3.2 ChatGPT API 调用流程 第 4 章　Python ChatGPT API库 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c3f7703962e6872aa29f1c8c65168ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea1eb226e3631420e28fa3ee8bc18319/" rel="bookmark">
			前端工程化基础（四）：Git代码版本控制工具详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git版本控制工具详解 认识版本控制（版本控制） 是维护 工程蓝图的标准做法，能追踪工程蓝图从诞生一直到定案的过程版本控制也是 一种软件工程技巧，借此能在软件开发的过程中，确保不同的人所编辑的同一程序都能得到同步 版本控制的功能 不同版本的存储管理 一个项目不断进行版本迭代，来修复之前的一些问题，增加新的功能等如果手动维护的话，效率很低 重大版本的备份维护恢复之前的项目版本记录项目的点点滴滴多人开发的代码合并 集中式版本控制 CVS和SVN属于集中式版本控制系统
他们的主要特点是 单一的集中管理的服务器，保存所有文件修订版本系统开发人员通过客户端 连接到这台服务器，取出最新的文件或者提交更新但是存在一个核心问题 ：中央服务器不能出现故障 如果宕机一个小时，在这一个小时之内，谁都无法提交更新，也就无法协同工作如果中心数据库所在的磁盘发生了损坏，且没有做备份，将会丢失所有的数据 项目的历史版本都会存在于中央服务器中 分布式版本控制 Git是属于分布式版本控制系统
客户端并不只提取最新版本的文件快照，而是把 代码仓库完整的镜像下来，包括完整的历史记录
这么一来，任何一处协同工作用的 服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复
因为每一次克隆操作，实际上都是一次对代码仓库的完整备份
与中央服务器不同的是，项目的历史版本，都会被克隆到协作开发的本地电脑，即每台电脑上都有备份
Bash-CMD-GUI区别 Bash是Unix shell的一种， Linux与Mac OS X都将它作为默认的shell Git Bash 就是一个shell，是 windows下的命令行工具，可以执行Linux命令Git Bash是基于CMD的，在CMD的基础上增加了一些新的命令与功能 Git CMD 命令提示符（CMD）是Windows操作系统上的命令行解释程序其实就是 windows上面的CMD Git GUI 针对于不喜欢命令行界面的人提供了一个 图形用户界面来运行Git命令 获取Git仓库 git clone/git init 当从零到一创建一个项目的时候，可以使用 git init创建一个新的仓库 会生成一个.git文件 运行 git add .用于告诉git 管理当前目录下的所有文件运行 git commit -m "描述"将本地文件提交到本地的git仓库中 但没有提交到远程服务器中 当已经有一个项目，就可以复制远程仓库的地址，运行 git clone xxxxx 文件状态的划分 Git在管理项目文件的时候，会对项目划分为以下几种状态 **未跟踪：**一般在已经被Git管理的项目中，创建新文件的情况下**已跟踪：**当我们在项目文件中运行 git add .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea1eb226e3631420e28fa3ee8bc18319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb6188fef8ee33711755efe0c415fdb/" rel="bookmark">
			操作系统（8）---进程的同步与互斥以及信号量机制（万字总结~）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.进程的同步与互斥
1.进程的异步和同步
2.进程互斥
3.进程互斥的软件实现方法
（1）单标志法
（2）双标志法
（3）双标志后检查
（4）Peterson算法
4.进程互斥的硬件实现方法
（1）中断屏蔽方法
（2）TestAndSet(TS指令/TSL指令)
（3）Swap指令（XCHG指令）
补充：
互斥锁
排号自旋锁
条件变量
二.信号量机制
1.信号量的类别
（1）整型信号量
（2）记录型信号量
2.信号量机制实现进程互斥
3.信号量机制实现进程同步
4.信号量机制实现前驱关系
三.同步与互斥典型案例
1.生产者、消费者问题
2.多生产者、多消费者问题
3.读者、写者问题
4.哲学家进餐问题
四.管程
1.为什么要引入管程
2.管程的定义和基本特征
3.管程的例子
一.进程的同步与互斥 1.进程的异步和同步 异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。
例如：进程通信----管道通信
读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。如何解决这种异步问题，就是“进程同步”所讨论的内容。
同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。
2.进程互斥 进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I/O设备)
资源有两种共享方式：
(1)同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问。
(2)互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。
我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。对临界资源的访问，必须互斥地进行。
互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。
对临界资源的互斥访问，从逻辑上分为如下四个部分：
进入区：
负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志(可理解为“上锁”)，以阻止其他进程同时进入临界区
临界区：
访问临界资源的那段代码
退出区：
负责解除正在访问临界资源的标志(可理解为“解锁”)
剩余区：
做其他处理
注意进入区和临界区的区别：
临界区是进程中访问临界资源的代码段。
进入区和退出区是负责实现互斥的代码段。
为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:
1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;
2.忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；
3.有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿);
4.让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。
注：这里的忙等待可以类比while(1){}循环，占着CPU但不运行进程。
3.进程互斥的软件实现方法 （1）单标志法 两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予
例如：
turn表示当前允许进入临界区的进程号,在进入区时，进程会判断自己的进程号是否与允许进入临界区的进程号相同,若此时turn不等于自己的编号时，说明此时临界区只允许另一个进程进入。以上述例子为例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcb6188fef8ee33711755efe0c415fdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a992dacfa6729533ae733c9d1d419990/" rel="bookmark">
			设计模式之 has-a
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式之 has-a 在 C++中，一个类包含另一个类的对象称为组合（Composition）。这是一种常见的设计模式，用于表示一个类是由另一个类的对象组成的。这种关系通常表示一种"拥有"（“has-a”）的关系。
普通变量访问成员变量或者成员函数，使用 “ . ” 运算符指针变量访问成员变量或者成员函数，使用“ -&gt; ”运算符，像C语言的结构体用法 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Wheel { public: string brand; int year; void wheelPrintInfo(); }; void Wheel::wheelPrintInfo() { cout &lt;&lt; "我的轮胎品牌是：" &lt;&lt; brand &lt;&lt; endl; cout &lt;&lt; "我的轮胎日期是：" &lt;&lt; year &lt;&lt; endl; } //在 C++中，一个类包含另一个类的对象称为组合（Composition）。 class Car{ //汽车“类” public: // 成员数据 string color; //颜色 string brand; //品牌 string type; //车型 int year; //年限 Wheel wl; Wheel *pwl; // 成员数据 void (*printCarInfo)(string color, string brand, string type, int year); //函数指针，指向车介绍函数 void (*carRun)(string type); //函数指针，指向车运行的函数 void (*carStop)(string type); //函数指针，执行车停止的函数 // 成员函数 void realPrintCarInfo(); }; void Car::realPrintCarInfo() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a992dacfa6729533ae733c9d1d419990/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/270409be054e450e75ccb2e6dac9e1e9/" rel="bookmark">
			阿赵UE学习笔记——14、LOD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿赵UE学习笔记目录
大家好，我是阿赵。
继续学习虚幻引擎的用法。这次看看虚幻引擎的Level Of Detail(LOD)的用法。
一、测试场景准备 用植物系统，在地形上面刷了好多草：
这个时候看一下网格，会发现网格比较多和密集。
二、LOD系统的测试 接下来，对这个草的模型的LOD进行一下调整，先找到使用在植物系统的这棵草的模型：
在打开的网格体编辑窗口，为了看到模型的布线，我暂时改成了线框模式。然后前后移动一下摄像机，会看到左上角的信息发生变化，一开始是LOD等级0，三角形数是1352，这时候当前屏幕大小是0.6左右：
拉远一点之后，会发现LOD等级变成1，三角形数变成了676，当屏幕大小是0.24左右：
再拉远一点，会发现LOD等级变成2，三角形数变成338，当前屏幕大小是0.01左右：
这说明了UE的网格已经自带了LOD功能。不过由于LOD的参数都是默认的，所以效果并没有很理想。接下来我对LOD的设置进行一定的修改。
在右边的细节面板里面，可以找到LOD选取器，默认是LOD Auto，意思是根据当前的模型占屏幕大小来显示LOD：
把下拉框点开之后，就可以选取不同的LOD等级，然后进行编辑：
三、调整LOD生效范围 从刚才的实验可以知道，看起来LOD好像是根据距离来生效，但实际上来说，并不是距离，而是模型占屏幕的大小来让LOD产生效果的，所以调节屏幕尺寸，会让不同的LOD等级在不同的显示大小时生效：
在LOD设置里面，还有一个自动计算LOD距离的选项，如果把这个选项勾上了，那么上面的LOD等级的屏幕尺寸就会变成不可编辑状态。
我调整一下LOD1的屏幕尺寸，把它改成0.6：
那么当屏幕尺寸小于0.6的时候，LOD1就会生效了：
我们一直都是用着同一个静态网格模型来进行LOD变化的，并不会像Unity那样不同的LOD等级一定要自己做一个低边模型放进去。因为UE的LOD，是有自动减面的功能。
所以在简化设置里面，会有一个三角形百分比。我们可以通过调整这个百分比，来决定当前的LOD等级生效时，网格模型会被简化成什么样子。
百分比调得越低，三角面就越少，而同样的模型的细节就会越少。
四、不同LOD使用不同材质实例 由于在前面的文章里面，我已经把草加上了随风摆动的效果。但到了这个LOD调整的时候，我想达到的目的是，只有最近一层的草，才会有风摆动动画，后面的等级都不需要动画。
由于之前的学习知道，风摆动动画是在材质实例里面设置了风的参数，那么如果有不需要风的时候，就必须要复制一个材质实例了：
然后把风的选项勾选去掉
回到草的静态网格编辑，找到材质插槽，新增一个插槽，并且把刚才的noWind材质实例拖进去
这个时候，在指定LOD等级的编辑里面，就可以选择不同的材质球使用了，我把LOD1和LOD2的材质都换成noWind的。
这样设置之后，我的目的已经达到了，只有最近的一层是有风摆动的动画了。
五、自定义LOD模型 如果觉得UE的减面效果不好，想像Unity一样自己替换模型来做LOD，也是可以的，在LOD设置里面，找到重新导入LOD级别的选项：
就可以重新选择一个模型导入到该LOD级别：
做完了上面的设置之后，再回到场景里面看看，会发现LOD已经是调整过后的效果了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7f46c105991ce3301c2abe3247f239e/" rel="bookmark">
			阿赵UE学习笔记——13、贴花
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿赵UE学习笔记目录
大家好，我是阿赵。
继续学习虚幻引擎的使用。这次介绍一种特殊的材质类型，贴花。
一、获取贴花资源 在没有分析贴花的原理之前，可以先去获得一些免费的贴花资源来使用，比如在Quixel上面就有专门的一个资源类别是Decals：
选择其中的一种贴花资源，然后可以下载并导入到项目：
导入到项目之后，会发现这个贴花资源包括了一个材质实例和三张纹理贴图。
把材质实例直接拖动到场景里面，就会发现，地面上出现了一个挺好看的细节，这个就是贴花：
然后我们可以把贴花拖动，拖到斜坡的位置，会发现贴花会沿着斜坡变化，有一种投影的效果：
二、贴花的原理分析： 这个贴花效果，有点类似于Unity的投影器的效果。
展开这个贴花对象的细节面板，会看到有一个贴花的组件：
这里可以调节这个贴花对象的一些效果。
不过这个组件是怎样出现的呢？
正常的材质实例是不能拖动到场景成为贴花的：
我把材质实例的父项改成M_MS_Decal_Material
然后把贴图附上：
这时候，贴花就神奇的生效了，可以拖到场景里面。
很显然，一切的秘密就在刚才选择的那个父项的材质上面：
在内容管理器里面搜索一下，找到这个材质：
双击打开之后，里面连接的节点比较复杂，暂时也不需要去看，只需要看看左边的细节面板，里面有一个材质域，这里选择的是延迟贴花：
为了验证是不是这个选项起的作用，所以我也自己建了一个材质文件，然后简单拖了2张贴图进去节点，然后把材质域改成延迟贴花，把混合模式改成半透明：
把这个材质创建一个材质实例：
这次材质实例就可以变成贴花拖到场景里面了。至于没有半透明效果，是因为我在材质里面并没有处理透明通道的计算：
到此为止，就已经能确定，UE的这个贴花，就是靠材质里面的材质域选项决定的。所以我们也可以制作属于自己效果的各种贴花。
三、选择不接受贴花 有时候，我们会在场景里面摆一些其他的装饰品，比如我这里摆了一个立方体。但现在很明显贴花的效果叠在立方体上面是错误的。
我不想立方体接受贴花效果，所以打开立方体的细节面板，找到渲染——高级：
展开高级选项，会找到一个接收贴花的勾选项，把这个勾选去掉：
现在立方体就不再接受贴花的效果，看起来就比较的正常了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/024ce3ce8838678e068444392983c374/" rel="bookmark">
			Linux实验记录：远程控制服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 本文是一篇关于Linux系统初学者的实验记录。
参考书籍：《Linux就该这么学》
实验环境：
VmwareWorkStation 17——虚拟机软件
RedHatEnterpriseLinux[RHEL]8——红帽操作系统
备注： SSH（Secure Shell）是一种能够以安全的方式提供远程登录的协议，也是目前远程管理Linux系统的首选方式。
之前，一般使用FTP或Telnet进行远程登录。（明文传递）
使用SSH协议来远程管理Linux系统，需要配置部署sshd服务程序。
sshd是基于SSH协议开发的一款远程管理服务程序，方便快捷。提供两种安全验证方法：
基于密码的验证——用账户和密码来验证登录
基于密钥的验证——需要在本地生成密钥对，然后把密钥中的公钥上传至服务器，进行比较。
sshd服务的配置信息保存在/etc/ssh/sshd_config文件中。
sshd服务配置文件中包含的参数及作用：
参数作用 Port 22默认的sshd服务端口 ListenAddress 0.0.0.0设定sshd服务器监听的ip地址 Protocol 2SSH协议的版本号 HostKey /etc/ssh/ssh_host_key SSH协议版本为1时，DES私钥存放位置 HostKey /etc/ssh/ssh_host_rsa_key SSH协议版本为2时，RSA私钥存放位置HostKey /etc/ssh/ssh_host_dsa_keySSH协议版本为2时，DSA私钥存放位置PermitRootLogin yes设定是否允许root管理员直接登录StrictModes yes当远程用户的私钥改变时直接拒绝连接MaxAuthTries 6最大密码尝试数MaxSessions 10最大终端数PasswordAuthentication yes是否允许密码验证PermitEmptyPasswords no是否允许空密码登录 正文： 实验准备： 使用两台虚拟机，一台当服务器，一台当客户机。ip地址：
主机地址操作系统作用192.168.31.130CentOS 8 Linux客户机192.168.31.128RHEL 8 Linux服务器 实验1：尝试连接 实验2：修改配置文件 如果禁止以root管理员身份远程登录服务器，可以大大提供安全性。
下面进行相应配置：
让配置参数立即生效： 再次尝试访问：
实验3：安全密钥验证 在生产环境中使用密码进行验证终归存在着被暴力破解或嗅探截获的风险。
如果正确配置了密钥验证方式，那么sshd服务程序将更加安全。
Step1：在客户端主机中生成”密钥对” Step2：把客户端主机中生成的公钥文件传送至远程服务器 Step3：对服务器进行设置，使其只允许密钥验证，拒绝传统的密码验证方式。 Step4：客户端尝试登录服务器，此时无须输入密码 实验4：远程传输命令 scp（secure copy）是一个基于SSH协议在网络之间进行安全传输的命令
格式：scp[参数]本地文件 远程账户@远程IP地址：远程目录
如果想把一些文件通过网络从一台主机传输到其他主机，这两台主机又恰巧都是Linux系统
scp命令可以轻松完成：
参数作用-v显示详细的连接进度-P指定远程主机的sshd端口号-r用于传送文件夹-6使用IPv6协议 首先要以绝对路径的形式写清本地文件的存放位置
如果要传送整个文件夹内的所有数据，添加-r参数
下载远程服务器上的文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/024ce3ce8838678e068444392983c374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af35662120ecbcd8b371bb561e72c152/" rel="bookmark">
			算法训练营day19,二叉树8-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		type TreeNode struct {
Val int
Left *TreeNode
Right *TreeNode
}
450. 删除二叉搜索树中的节点
/*本题比较难，删除节点要分五种情况考虑
1.没有找到要删除的节点
2.找到要删除的节点是叶子节点
3.找到要删除的节点，左指针不为空，右指针为空
4.找到要删除的节点，左指针为空，右指针不为空
5.找到要删除的节点，左指针不为空，右指针不为空,这种情况最复杂，需要调整二叉树结构，既可以让左子树继承，也可以让右子树继承
*/
//根据上述分析，第五点让右子树继承写法
func deleteNode(root *TreeNode, key int) *TreeNode {
//1.未找到要删除的节点
if root == nil {
return root
}
if root.Val == key {
//2.找到要删除的节点是叶子节点
if root.Right == nil &amp;&amp; root.Left == nil {
return nil
// 3.找到要删除的节点，左指针不为空，右指针为空
} else if root.Left != nil &amp;&amp; root.Right == nil {
return root.Left
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af35662120ecbcd8b371bb561e72c152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495d62bbdcdf419291b18488556984c5/" rel="bookmark">
			Redis -- String 字符串, 计数命令，字符串操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"学如逆水行舟，不进则退。"
目录
Redis的String字符串
常见命令 set
get
mget
mset setnx
setex
psetex
计数命令 incr
incrby
decr
decrby
incrbyfloat
字符串操作
append
getrange
setrange
strlen
小结
string内部编码
Redis的String字符串 redis中所有的key都是字符串的，但是value是存在各种差异的。Redis中的字符串直接就是按照二进制的方式进行存储的，不会做任何编码转换，存的是啥取得就是啥。对于value来说，不仅仅可以存储文本数据，还可以存储整数，普通文本，Json，xml，还有一些二进制文件，例如图片音频等，但是redis对string类型限制了大小，最高位512MB。
下面是字符串类型的value的不同形式：
区别于MySQL，MySQL有一个默认的字符集，为拉丁文的字符集，插入中文机会检测插入失败。但是redis是直接存储的二进制，因此redis遇到乱码的概率就小的多。
常见命令 set 将 string 类型的 value 设置到 key 中。如果 key 之前存在，则覆盖，无论原来的数据类型是什么。之前关于此 key 的 TTL 也全部失效。
除了最常见的set key value之外，我们还可以在set的时候设置存活时间，类似于expire的操作。
语法：set key value [expiration EX seconds | PX milliseconds] [NX|XX]
相当于set key value和expire key 10这两步的操作。EX设置的相当于秒级，PX设置的表示毫秒级。NX表示如果key不存在才设置，XX表示key存在，则不设置，并且返回nil（相当于更新操作）
[ ]表示一个独立的单元，相当于一个可有可无的选项，[ ]中的|表示或者的意思，即使是多个|也只能选择其中的一个。[ ]和[ ]之间是可以同时存在的。
还有一个小技巧就是在redis-cli输入flushAll，这个操作就相当于mysql里面的drop database。
演示 ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495d62bbdcdf419291b18488556984c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e731a38c536eecfc98227329260c70c/" rel="bookmark">
			vscode 插件 Tailwind CSS IntelliSense 解决 class 提示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 如下写js字符串是没有class智能提示的：
const clsName = 'bg-[#123456] text-[#654321]' return &lt;div className={clsName}&gt;&lt;/div&gt; 解决方案： 安装 clsx 依赖 pnpm i clsx 设置 vscode 的 settings.json { "tailwindCSS.experimental.classRegex": [ [ "clsx\\(([^)]*)\\)", "(?:'|\"|`)([^']*)(?:'|\"|`)" ] ] } 之后就有提示了
原理: 就是通过 Tailwind CSS IntelliSense 插件配置 "clsx\\(([^)]*)\\)" 正则匹配到了就显示提示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168fb945c89f64fbd12b0e03a417cbbd/" rel="bookmark">
			win11 蓝屏分析，没有一定的原因，没有解决办法，只能不断尝试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件 读取分析 dump 文件：
如图，发生的日期很新鲜，原因很普遍 ntoskrnl.exe 内核驱动类
搜索：PAGE_FAULT_IN_NONPAGED_AREA
停止错误、bug 检查或蓝屏错误故障排除 - Windows Client | Microsoft Learn
找到官方的文章
70% 是由第三方驱动程序代码引起的。10% 是由硬件问题引起的。5% 是由 Microsoft 代码引起的。15% 的原因未知，因为内存已损坏，无法分析。 到这里基本完成了。
硬件 不过这个问题是发生在我的电脑上的。我的电脑是兼容机，自己配的，自己装的。
电脑配置：
操作系统 Windows 11 64位（Version 23H2 / DirectX 12）
处理器 12th Gen Intel Core i7-12700K
主板 华硕 ROG STRIX Z690-A GAMING WIFI D4（LPC Controller/eSPI Controller Z690芯片组）
显卡 英特尔 UHD Graphics 770 ( 128 MB / 华硕 )
内存 64 GB ( 威刚 DDR4 3600MHz 32GB x 2 )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/168fb945c89f64fbd12b0e03a417cbbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15674c4095a2f74ac7f09625ed820914/" rel="bookmark">
			Java希尔排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		希尔排序是一种改进的插入排序算法，也称为缩小增量排序。它通过将待排序的数组按照一定的间隔分割成若干个子序列，然后对这些子序列进行插入排序，随着排序进行，逐渐减小间隔，直至间隔为1，最后对整个数组进行一次插入排序。这样做的好处是，在初始阶段，子序列中的元素较少，插入排序的代价较小，而且数组中的元素已经基本有序，这样一来，后续的插入排序效率就会提高。
希尔排序的步骤如下：
选择一个增量序列，一般选择增量序列为n/2, n/4 , … , 1，其中n为数组的长度。按照增量序列对数组进行分组，分成若干个子序列。对每个子序列进行插入排序。缩小增量，重复步骤2和3，直至增量为1。 下面是用Java实现的希尔排序示例代码：
public class ShellSort { public static void shellSort(int[] arr) { int n = arr.length; // 初始增量设定为数组长度的一半，依次递减, 这里的 /2 可以用 &gt;&gt;1 替代,性能更佳 for (int gap = n / 2; gap &gt; 0; gap /= 2) { // 对每个子序列进行插入排序 for (int i = gap; i &lt; n; i++) { int temp = arr[i]; int j = i; // 插入排序 while (j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp) { arr[j] = arr[j - gap]; j -= gap; } arr[j] = temp; } } } public static void main(String[] args) { int[] arr = {5, 4, 1, 3, 2, 6, 8, 7, 9}; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15674c4095a2f74ac7f09625ed820914/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a73ea0b9994f1bad8eada352a87f45/" rel="bookmark">
			RobotFramework&#43;Eclispe环境安装篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境安装是学习任何一个新东西的第一步，这一步没走舒坦，那后面就没有心情走下去了。
引用名句：工欲善其事必先利其器！！
Robotframework：一款 自动化测试框架。
Eclipse：一款编辑工具。可以编辑python代码、java代码等。
环境安装一共分为四个步骤：
1、python环境 2、安装RobotFramework；
3、JDK1.8 + Eclipse安装 + RED插件；
4、配置eclipse
1）python环境
是python2还是python3？ python官方网站已表明对python2的维护到2020年截止。
目前robotframework第三方库中支持python3的很多，但是仍有一部分库停留在python2的版本，甚至库开发者都不再更新。
所以看自己工作中需要用的库，是否都是支持python3的。如果是，那可以用python3.
如果不太清楚后续用到什么库，目前保险起见，使用python2.
python环境安- 具体安装步骤请擢： 这里这里
2）robotframework安装
是一个python库，所以使得pip命令：pip install robotframework
3）JDK1.8 + Eclipse安装+RED插件
官方发布的每一个RED插件，都会有相应支持的Eclipe版本说明。（ps:jdk的安装跳过，网上百度就好）
所以，插件版本要与Eclipse版本匹配，否则安装或者使用过程中会有问题。
比如，RED插件0.8.1，只有Eclipse Oxygen(v4.7),Eclipse Neon(v4.6),Eclise Mars(v4.5)这三个eclipse版本能够完美支持。其它的eclipse版本不行。
下图为官方说明截图：
Eclipse中RED插件的安装有两种方式：
1、Eclipse中安装本地包（推荐，安装更快捷）：
第一步：从RED地址下载RED插件： Releases · nokia/RED · GitHub
第二步：eclipse面板，Help - Install New Software - 点击Add添加。
第三步：勾选 Robot Framework IDE. 点击Next.
一直到安装完成。
中间有其它要选择的步骤，一直选next就好。
2、Marketplace在线安装插件
Eclipse页面中，Help - Install New Software - 点击Add添加。
RED地址： http://master.dl.sourceforge.net/project/red-robot-editor/repository
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26a73ea0b9994f1bad8eada352a87f45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db4eb932fbfd7181504d1e85a6b145ca/" rel="bookmark">
			Jenkins &#43; Jmeter &#43; Ant 持续集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建提前安装好：ant Jenkins 环境
一、Jenkins 安装 Ant 插件： 进入Jenkins 配置插件页面，安装ant 插件：
打开插件配置页面，如下图：
点击“Available” 在输入框搜索 ant 安装即可：
二、安装 ant 进入 Global Tool Configuration 进行ant 安装：
注意：ANT_HOME 为本机 ant 安装目录
三、修改Jmeter相关配置 修改 jmeter.properties，此处修改的目的是为了后续生成html报告做准备
拷贝 jmeter 安装目录 extras 文件夹下的 ant-jmeter-1.1.1.jar 复制到 ant 安装目录下的 lib文件夹下。
以上步骤是用于发送邮件报告。
四、构建 Jenkins 项目 创建一个items项目：
注意：build.xml 文件路径不能错！！！！ 另外，需做修改！！！！
五、修改 build.xml （重要！！！） 注*：上述中需注意如下：
1、生成结果报告的路径文件夹需要自己手动创建；
2、声明运行的脚本，需根据自己实际路径填写！即存放后缀为 *.jmx文件的目录
注*：上述中需注意如下：
1、mail_from：发件人邮箱
2、password：是邮箱的授权码
3、mail_to：收件人邮箱。若想发给多个用户，则用英文逗号分隔
4、mailport：邮箱端口。我用的是腾讯smtp，所以587。其它邮箱可以问下度娘~~~
5、mailhost：邮箱的smtp地址
至此，build.xml 修改完成！
六、构建执行项目任务 查看报告：
总结：
感谢每一个认真阅读我文章的人！！！
作为一位过来人也是希望大家少走一些弯路，如果你不想再体验一次学习时找不到资料，没人解答问题，坚持几天便放弃的感受的话，在这里我给大家分享一些自动化测试的学习资源，希望能给你前进的路上带来帮助。
视频文档获取方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db4eb932fbfd7181504d1e85a6b145ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1097b5a0094d44154331118b2f3befe8/" rel="bookmark">
			《动手学深度学习(PyTorch版)》笔记4.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：书中对代码的讲解并不详细，本文对很多细节做了详细注释。另外，书上的源代码是在Jupyter Notebook上运行的，较为分散，本文将代码集中起来，并加以完善，全部用vscode在python 3.9.18下测试通过。
Chapter4 Multilayer Perceptron 4.8 Numerical Stability and Model Initialization 4.8.1 Gradient Vanishing and Gradient Exploding 考虑一个具有 L L L层、输入 x \mathbf{x} x和输出 o \mathbf{o} o的深层网络。每一层 l l l由变换 f l f_l fl​定义，该变换的参数为权重 W ( l ) \mathbf{W}^{(l)} W(l)，其隐藏变量是 h ( l ) \mathbf{h}^{(l)} h(l)（令 h ( 0 ) = x \mathbf{h}^{(0)} = \mathbf{x} h(0)=x）。我们的网络可以表示为：
h ( l ) = f l ( h ( l − 1 ) ) 因此 o = f L ∘ … ∘ f 1 ( x ) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1097b5a0094d44154331118b2f3befe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55ddf359daeed5d68192497887e37f98/" rel="bookmark">
			《动手学深度学习(PyTorch版)》笔记4.9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chapter4 Multilayer Perceptron 4.9 Environment and Distribution Shift 4.9.1 Types of Distribution Shift 在一个经典的情景中，假设训练数据是从某个分布 p S ( x , y ) p_S(\mathbf{x},y) pS​(x,y)中采样的，但是测试数据将包含从不同分布 p T ( x , y ) p_T(\mathbf{x},y) pT​(x,y)中抽取的未标记样本。如果没有任何关于 p S p_S pS​和 p T p_T pT​之间相互关系的假设，学习到一个分类器是不可能的。
4.9.1.1 Covariate Shift 在不同分布偏移中，协变量偏移（covariate shift）可能是最为广泛研究的。这里我们假设：虽然输入的分布可能随时间而改变，但标签函数（即条件分布 P ( y ∣ x ) P(y \mid \mathbf{x}) P(y∣x)）没有改变。这个问题是由于协变量（特征）分布的变化而产生的。虽然有时我们可以在不引用因果关系的情况下对分布偏移进行推断，但在我们认为 x \mathbf{x} x导致 y y y的情况下，协变量偏移是一种自然假设。假设在一个与测试集的特征有着本质不同的数据集上进行训练，如果没有方法来适应新的领域，可能会有麻烦。
4.9.1.2 Label Shift 标签偏移（label shift）指的是在目标域中的标签分布与源域中的标签分布存在差异的情况。这里我们假设标签边缘概率 P ( y ) P(y) P(y)可以改变，但是类别条件分布 P ( x ∣ y ) P(\mathbf{x} \mid y) P(x∣y)在不同的领域之间保持不变。当我们认为 y y y导致 x \mathbf{x} x时，标签偏移是一个合理的假设。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55ddf359daeed5d68192497887e37f98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a2e709b976bf80762c1ffd2739a5007/" rel="bookmark">
			【全csdn最前沿LVGL9】事件的高级使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、事件1.1 从对象删除某个事件1.2 Event CodesInput device eventDrawing eventsSpecial eventsOther events 1.3 发送事件1.4 刷新事件1.5 关于lv_event_t类型1.6 事件冒泡事件冒泡是什么事件冒泡的使用 总结 前言 在现代图形用户界面（GUI）开发中，事件处理是至关重要的一部分。LVGL（LittlevGL）是一个功能强大的开源GUI库，提供了丰富的事件系统，使开发人员能够轻松地实现交互式和响应式的用户界面。本文将探讨LVGL 9中事件处理的高级使用方法，帮助开发人员更好地利用事件系统构建灵活、交互性强的应用程序界面。
一、事件 1.1 从对象删除某个事件 我们可以通过：lv_obj_get_event_count(obj)函数来获取某个obj绑定event的数量
我们可以使用：lv_obj_get_event_dsc(obj, i)这个函数返回对象（obj）的第 i 个事件描述符（lv_event_dsc_t）。事件描述符包含有关特定事件的信息，例如回调函数（callback function）等
lv_event_dsc_get_cb(event_dsc)这个函数用于从事件描述符 (event_dsc) 中获取与之关联的回调函数 (cb，callback function)。回调函数是在事件发生时执行的函数，用于处理该事件。
lv_obj_remove_event(obj, i)这个函数用于从对象 (obj) 的事件列表中移除第 i 个事件。通过这个操作，开发者可以修改对象的事件处理逻辑或者取消特定事件的处理。
示例代码：
uint32_t i; uint32_t event_cnt = lv_obj_get_event_count(obj); for(i = 0; i &lt; event_cnt; i++) { lv_event_dsc_t * event_dsc = lv_obj_get_event_dsc(obj, i); if(lv_event_dsc_get_cb(event_dsc) == some_event_cb) { lv_obj_remove_event(obj, i); break; } } 我们可以通过遍历整个event数组，通过lv_event_dsc_get_cb找到对应的回调函数，然后进行要删除的回调函数然后去删除
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a2e709b976bf80762c1ffd2739a5007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/211c51deb2408f13c148c42693d4f5e3/" rel="bookmark">
			doris建表报错:Failed to find 3 backends for policy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体报错：
mysql&gt; CREATE TABLE `aaa` ( -&gt; ORDER_PROCESS_WT_OUT int(10) -&gt; ) ENGINE=OLAP -&gt; DUPLICATE KEY(`ORDER_PROCESS_WT_OUT`) -&gt; DISTRIBUTED BY HASH(`ORDER_PROCESS_WT_OUT`) BUCKETS 64 -&gt; PROPERTIES ( -&gt; "replication_allocation" = "tag.location.default:2", -&gt; "in_memory" = "false", -&gt; "storage_format" = "V2", -&gt; "storage_medium" = "HDD" -&gt; ); ERROR 1105 (HY000): errCode = 2, detailMessage = Failed to find 2 backends for policy: cluster|query|load|schedule|tags|medium: default_cluster|false|false|true|[{"location" : "default"}]|HDD 解决办法：
添加：
"storage_medium" = "SSD" 完整SQL：
CREATE TABLE `aaa` ( ORDER_PROCESS_WT_OUT int(10) ) ENGINE=OLAP DUPLICATE KEY(`ORDER_PROCESS_WT_OUT`) DISTRIBUTED BY HASH(`ORDER_PROCESS_WT_OUT`) BUCKETS 64 PROPERTIES ( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/211c51deb2408f13c148c42693d4f5e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a654f5e2f97ba63c44233b22e00db3/" rel="bookmark">
			安装docker-compose报错：No match for argument: docker-compose Error: Unable to find a match: docker-compo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天行健，君子以自强不息；地势坤，君子以厚德载物。
每个人都有惰性，但不断学习是好好生活的根本，共勉！
文章均为学习整理笔记，分享记录为主，如有错误请指正，共同学习进步。
文章目录 场景报错解决 场景 在Linux系统（centos）中安装docker-compose失败
事先已经安装了docker
报错 报错内容：
[root@k8s-master ~]# yum install docker-compose -y Last metadata expiration check: 3:59:14 ago on Mon 29 Jan 2024 04:49:28 PM CST. No match for argument: docker-compose Error: Unable to find a match: docker-compose 报错截图：
解决 解决方法：
参考文章安装即可：Linux系统安装docker-compose
感谢阅读，祝君暴富！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/033412f494387eff098fdd0314849e09/" rel="bookmark">
			缓存之SpringCache整合redis(五)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCache整合redis 一、引入pom二、配置1.springCache自动配置了redis2.配置yml3.开启缓存功能4.测试使用缓存5.缓存保存JSON格式 三、springCache的读写模式1.读模式2.写模式（缓存和数据库一致性） 一、引入pom &lt;!--springCache依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--springCache使用redis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 二、配置 1.springCache自动配置了redis 2.配置yml spring: cache: type: redis #配置reids作为缓存 redis: time-to-live: 60000 #缓存过期时间为60秒，单位毫秒 key-prefix: HEIZI_ #key增加前缀 use-key-prefix: true #是否开启前缀（Ⅰ.如果为true，并且key-prefix指定了值，那么缓存的key就是：HEIZI_key。Ⅱ.如果为true，key-prefix没有指定前缀，那么缓存的key就是：缓存的名字::key。Ⅲ.如果为false，缓存的key就是：key） cache-null-values: true #是否缓存空值，防止缓存穿透问题 3.开启缓存功能 #在启动类加上此注解 @EnableCaching 4.测试使用缓存 @Cacheable：保存到缓存中。
@CacheEvict：删除缓存。
@CachePut：不影响方法执行，更新缓存。（双写模式默认）
@Caching：多条命令操作。
@CacheConfig：共享缓存配置（类级别）。
# 把结果放到缓存，如果有缓存，那么不调用接口，直接返回缓存里面的数据。没有缓存，调用接口返回数据，并且把结果存到缓存中去。缓存的value存放的是jdk序列化的内容。 # 缓存的名称：ikun，一个缓存下可以有多个key，key的名称：ceshi（支持Spring的表达式语言SPEL语法） @Cacheable(value = {"ikun"},key = "'ceshi'") Object detail(@PathVariable("id") Serializable id); # 缓存的名称：ikun，一个缓存下可以有多个key，key的名称：结果的id值 @Cacheable(value = {"ikun"},key = "#result.id") Object detail(@PathVariable("id") Serializable id); # 缓存的名称：ikun，一个缓存下可以有多个key，key的名称：参数的id值 @Cacheable(value = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/033412f494387eff098fdd0314849e09/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/">«</a>
	<span class="pagination__item pagination__item--current">2/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/3/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>