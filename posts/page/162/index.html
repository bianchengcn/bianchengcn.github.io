<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/304dcab90b68521a3aa16b2202647b7b/" rel="bookmark">
			虚函数学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚函数是针对动态多态性设计的。什么是动态多态性呢？动态多态性是指程序运行时，不在编译时确定用哪个函数，而是在程序在运行过程中才动态地确定操作所针对的对象。这一过程需要通过虚函数来实现。
虚函数，就是在基类中声明此函数是虚拟的，并不是实际存在的函数，在派生类中，需要使用的时候再重新定义此函数。
虚函数的作用就是允许在派生类中重新定义与基类中完全重名的函数，并且允许通过基类指针或引用来访问基类和派生类中的通明函数。
1.虚函数的声明：
virtual void display(){ //virtua关键字 函数类型 函数名 //函数体 } 在基类中定义虚函数后，以此类为基类的派生类中出现与虚函数同名的函数默认为虚函数，可重新定义。
class base1 { public: virtual void display() const; //虚函数 }; void base1::display() const{ cout &lt;&lt; "base1::dispaly()" &lt;&lt; endl; } class base2 :public base1 { public: void display() const; //派生类中，基类中的虚函数根据函数名、参数列表等覆盖派生类的相应函数。 }; void base2::display() const { cout &lt;&lt; "base2::dispaly()" &lt;&lt; endl; } class base3 :public base2 { public: void display() const; //派生类中，基类中的虚函数根据函数名、参数列表等覆盖派生类的相应函数。 }; 2.可以被定义为虚函数的有：普通成员函数、析构函数。注意，构造函数不能是 虚函数，必须是实打实的哈哈哈。
析构函数被定义为虚函数，被称为虚析构函数。这种函数有两个优点：
可以通过基类指针删除派生类对象；可以通过基类指针调用对象的析构函数（利用delete删除动态内存分配的空间）。
base::~base() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/304dcab90b68521a3aa16b2202647b7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8db6cc414eeb9ff123f7778a68385f/" rel="bookmark">
			线性代数初步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 线性代数入门矩阵行、列向量增广矩阵:矩阵内初等运算矩阵间运算矩阵的转置单位矩阵矩阵的逆初等矩阵对角矩阵和三角形矩阵向量行列式伴随矩阵特征值特征值的乘积与和 线性代数入门 本文仅对OI有用部分的线性代数进行初步解析，
如果要了解练习与详细请阅读华章数学译丛 《线性代数》
矩阵 定义 A A A 为一 m × n m\times n m×n 的矩阵为
[ a 1 , 1 a 1 , 2 ⋯ a 1 , n a 1 , 2 a 2 , 2 ⋯ a 2 , n ⋮ a m , 1 a m , 2 ⋯ a m , n ] \begin{bmatrix}a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n}\\a_{1,2}&amp;a_{2,2}&amp;\cdots &amp;a_{2,n}\\\vdots\\a_{m,1}&amp;a_{m,2}&amp;\cdots &amp;a_{m,n}\end{bmatrix} ⎣⎢⎢⎢⎡​a1,1​a1,2​⋮am,1​​a1,2​a2,2​am,2​​⋯⋯⋯​a1,n​a2,n​am,n​​⎦⎥⎥⎥⎤​
行、列向量 行向量: a 1 → = [ a 1 , 1 a 1 , 2 ⋯ a 1 , n ] \overrightarrow{a_1}=\begin{bmatrix}a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n}\end{bmatrix} a1​ ​=[a1,1​​a1,2​​⋯​a1,n​​]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8db6cc414eeb9ff123f7778a68385f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a384585cb3b6113ab6d6b5cc14a883/" rel="bookmark">
			记一次线上数据库某个字段varchar长度不足，被自动截取情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这周项目在运行中。作业人员反馈部分单据查看详情的时候，报错了。
查看接口代码没有问题后，观察数据库中的数据，发现有个json字段，因为过长被自动截取了，字段的类型为varchar，长度为2048
因为不确定该字段最长可能达到多少，长度取决于用户的信息长度有多少，所以为了避免之后再发生自动截取的问题， 决定改varchar为text
在修改的过程中，dba提示不满足大字段准入规则。该部分代码比较老，是17年开始就有的，业务逻辑一层套一层，比较复杂，所以在解释清楚之后，提交了字段类型修改的SQL。
下面是SQL：
ALTER TABLE arg_open_bos_key MODIFY bos_key text COMMENT 'key值', MODIFY inner_bos_info text COMMENT 'bosInfo' 上面的两个modify因为改的是一个表，所以尽量放在一个SQL中去执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4960ac3b0992dc9c2359b1ca6a3a86e/" rel="bookmark">
			org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个异常是在使用mybatis plus时自己定义sql方法是出现的。出现的原因是：Maven默认只扫描src/main/java里面的.java文件，而不会去扫描xml文件。
我们可以通过在target/classes下找到编译后的文件，却找不到xml文件。
解决方法：
方法1、将xml文件全部复制到resource里面去。（需要修改相关路径）
方法2、
第一步：在pom.xml文件中添加
&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 第二步：在application.properties中添加上你的xml文件地址
#配置mapper xml文件的路径 mybatis-plus.mapper-locations=classpath:com/atguigu/edu/mapper/xml/*.xml 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7f2232ee52bf924f7d0de04e9403fac/" rel="bookmark">
			Java基础面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HashMap的特性 1.考察目标 HashMap底层的数据结构HashMap和Hashtable的区别 2. 题目分析 Map集合的特点
Map是一个双列集合，将键映射到值的对象
Map集合的数据结构，只针对键有效，跟值没有关系 Map集合的键不能重复，并且一个键最多只能映射到一个值
HashMap集合的数据结构是什么？
哈希表结构：数组 + 链表 通过哈希表结构配合对象类型的hashCode和equals方法就可以保证键的唯一性建议：今后Map集合中键是对象类型的，不要忘记重写它的hashCode和equals方法 HashMap和Hashtable的区别是？
相同点：
都是双列集合，一个键对应一个值都是键不能重复，但是值可以重复 不同点：
HashMap是JDK1.2版本出现的，允许存储null键和null值
Hashtable是JDK1.0版本出现的，不允许存储null键和null值
HashMap是不同步的，线程不安全
Hashtable是同步的，线程安全
应用场景：
双列集合优先使用HashMap集合如果是在多线程的场景下，也无需使用Hashtable集合，我们可以使用ConcurrentHashMap集合。该集合时一个线程同步的。Hashtable集合虽然使用不多，但是它有一个给力的子类：Properties集合还在大量使用中，一般配合IO流来加载配置文件！ 3. 问题扩展 JDK1.8之后，哈希表结构引入了二叉树
提高了查询的效率 JDK1.8版本之后，某一个索引下的节点数量达到一定程度的时候，会把原本的链表结构，改成二叉树结构
TreeSet集合：二叉树结构（数据能够排序）
二叉树取数据：先取节点左边的，当左边的全部获取完毕，再取自己，最后取节点右边的
4. 应用场景 用于商品出现次数的统计
/** * 统计商品出现次数的使用场景----HashMap * 关键是键的对象类型必须重写hashCode和equals方法 */ public class Demo02_HashMap { public static void main(String[] args) { Goods g1 = new Goods("小米手机", 1000); Goods g2 = new Goods("平板电脑", 7000); Goods g3 = new Goods("小米手机", 1000); List&lt;Goods&gt; goodsList = new ArrayList&lt;&gt;(); goodsList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7f2232ee52bf924f7d0de04e9403fac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15b630dffe0e1710a3cd295cee748acd/" rel="bookmark">
			Nacos启动出现 failed to req API:/nacos/v1/ns/instance after all servers。。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误描述 Nacos启动出现 failed to req API:/nacos/v1/ns/instance after all servers ([192.168.99.100:3333, 192.168.99.100:5555]) tried: failed to req API:192.168.99.100:3333/nacos/v1/ns/instance. code:500 msg: java.net.SocketTimeoutException: Read timed out 错误分析 出现此项错误的原因在于：
配置了 nacos 集群。分别启动单个nacos时，会监测 cluster.conf文件中的信息，当其中配置了其他nacos时，若其他未启动，则会出现上述报错！
错误解决 nacos 配置了集群后出现的问题，需要在配置中增加：
添加启动参数-Dnacos.standalone=true
如：
sh startup.sh -p 3333 -m standalone
sh startup.sh -p 5555 -m standalone
此处的 -p 在原有 startup.sh中没有，只是额外加的配置信息，可以忽略。
如果也想能够实现指定端口启动方式，可以修改startup.sh文件信息：
startup.sh 文件中自带的逻辑代码为：
此时，需要增加一个 port 性质的启动：
while getopts ":m:f:s:p:" opt do case $opt in m) MODE=$OPTARG;; f) FUNCTION_MODE=$OPTARG;; s) SERVER=$OPTARG;; p) PORT=$OPTARG;; ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15b630dffe0e1710a3cd295cee748acd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c40fb4cd488906b4797905800537dc/" rel="bookmark">
			MySQL进阶【十二】—— 深挖Innodb事务的多版本控制（MVCC）的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是多版本控制 多版本并发控制（Multi-Version Concurrency Control）是MySQL的InnoDB引擎实现隔离级别的一种具体方式。用于实现提交读和可重复读。
多版本控制的优势 同一行数据平时发生读写请求时，会上锁阻塞住。但mvcc用更好的方式去处理读—写请求，做到在发生读—写请求冲突时不用加锁。这个读是指的快照读，而不是当前读，当前读是一种加锁操作，是悲观锁。 当前读 它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行加锁，防止其他事务修改数据。是悲观锁的一种操作。
如下操作都是当前读： select lock in share mode (共享锁)select for update (排他锁)update (排他锁)insert (排他锁)delete (排他锁)串行化事务隔离级别 快照读 快照读的实现是基于多版本并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。
如下操作是快照读 不加锁的select操作（注：事务级别不是串行化） MVCC 解决了哪些并发问题 mvcc用来解决读—写冲突的无锁并发控制，就是为事务分配单向增长的事务id。为每个数据修改保存一个版本，版本与用回滚指针（roll_pointer）相连。
解决问题如下：
并发读-写时：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作。解决脏读、不可重复读等事务隔离问题，但不能解决上面的写-写 更新丢失问题。大大提高了并发性 实现原理 隐藏列 通过在每一张表上添加三个隐藏列，来实现不同的版本
trx_id 表示最近一次对本记录行作修改（insert | update）的事务ID。至于delete操作，InnoDB认为是一个update操作，不过会更新一个另外的删除位，将行表示为deleted。并非真正删除。roll_pointer 回滚指针，指向当前记录行 在 undo log 中上一个版本的数据deleted_bit 删除标记位，因Innodb将delete认为是一次update，所以需要一个删除标记位，标记数据是否删除 Readview (重要) Readview 是mvcc是先多版本控制的关键，通过生成Readview很好的实现了版本之间的隔离，生成Readview时，会将当前活跃的事务id放入Readview中
结构 low_limit_id : 当前活跃事务的最小IDup_limit_id ：当前活跃事务的最大IDtrx_ids ： 当前活跃事务的ID数组creator_trx_id ：当前创建事务的id号（也可能是试图的ID号） undo_log 一行数据在undo_log中的版本链
大多数对数据的变更操作包括 insert/update/delete，在InnoDB里，undo log分为如下两类： ①insert undo log : 事务对insert新记录时产生的undo log, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。②update undo log : 事务对记录进行delete和update操作时产生的undo log，不仅在事务回滚时需要，快照读也需要，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。 Purge线程：为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下旧记录的deleted_bit，并不真正将旧记录删除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1c40fb4cd488906b4797905800537dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe9b9b2d6826fdcc105eb4ff822afb6/" rel="bookmark">
			MySQL进阶【十一】—— Innodb 事务的两阶段提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两阶段提交是什么 prepare阶段：此阶段innodb将事务 trx_id洗入redo_log，将事务状态置为prepare状态commit阶段： 写入bin_log写入redo_log,将事务状态置为commit
两阶段提交解决了什么问题 故障恢复、主从、主备复制时，保持了数据的一致性
故障恢复过程 Innodb进行crash recovery时是根据binlog来进行前滚回滚的，只有记录了binlog才会根据redo log前滚或回滚事务。crash recovery的流程其实是：先扫描binlog，提取出xid，然后比较redo中checkpoint之后的xid，如果在binlog存在，那么提交，如果不存在那么回滚。二阶段日志提交其实是依靠一种内部的分布式（XA）机制避免的，因此MySQL的innodb_support_xa必须设置为1（默认为1且5.7.10后已经弃用）。来具体分析下二阶段提交各个阶段crash的恢复情况：如果是在一阶段（prepare阶段）后crash，那么binlog未写，事务回滚。如果在二阶段第一步后crash，那么binlog已写，重做事务。由于二阶段事务的提交是原子性的，这样总能保证binlog与innodb的一致，即便出现了XA事务内的crash，也能合理的进行事务前滚或回滚。 对于主从复制的影响： 上面讨论的二阶段日志提交解决了mysql server与innodb层的日志一致性的问题，单实例的情况下最多因为sync_binlog和innodb_flush_log_at_trx_commit的设置问题导致事务丢失，但是对于主从复制事务丢失却是很严重的问题–&gt;主从不一致。在主从复制的情况下如果innodb_flush_log_at_trx_commit不为1则有可能出现binlog已写但是redo log未写的情况，此时主库崩溃后在事务前滚时会出现找不到redo的情况导致前滚失败，而从库已经应用binlog，导致主从不一致。而sync_binlog不为1则可能出现主库直接丢失事务的情况。因此，为保证主从完全一致且事务不丢失，主库的innodb_flush_log_at_trx_commit和sync_binlog都必须设置为1。 参考链接：https://www.cnblogs.com/leohahah/p/8176553.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f4a1512b13286a947f66f5643843f3/" rel="bookmark">
			VGGNet网络结构详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VGGNet
VGG16使用了更小的卷积和步长。
例如用2个3×3的代替1个5*5的
1： input：224×24×3
要经过经过两次卷积cov3-64，
Conv1_1: 输入通道I为3，输出通道O为64，卷积核为N×N×I×O，stride=1，卷积核为3×3×3×64，则输出尺寸为224×224×64
*Conv1_2:*输入通道I为64，输出通道O为64，卷积核为N×N×I×O，stride=1，卷积核为3×3×64×64，则输出尺寸为224×224×64
Maxpooling:
Input:224×224×64
2×2的最大池化核，输出为112×112×64
2： input：112×112×64
要经过经过两次卷积cov3-64，
*Conv1_1:*输入通道I为64，输出通道O为128，卷积核为N×N×I×O，stride=1，卷积核为3×3×64×128，则输出尺寸为112×112×128
Conv1_2:输入通道I为128，输出通道O为128，卷积核为N×N×I×O，stride=1，卷积核为3×3×128×128，则输出尺寸为112×112×128
Maxpooling:
Input:112×112×128
2×2的最大池化核，输出为56×56×128
3. input：56×56×128
要经过经过两次卷积cov3-64，
*Conv1_1:*输入通道I为128，输出通道O为256，卷积核为N×N×I×O，stride=1，卷积核为3×3×128×256，则输出尺寸为56×56×256
*Conv1_2:*输入通道I为256，输出通道O为256，卷积核为N×N×I×O，stride=1，卷积核为3×3×256×256，则输出尺寸为56×56×256
Maxpooling:
Input:56×56×256
2×2的最大池化核，输出为28×28×256
4. input：28×28×256
要经过经过两次卷积cov3-64，
*Conv1_1:*输入通道I为256，输出通道O为512，卷积核为N×N×I×O，stride=1，卷积核为3×3×256×512，则输出尺寸为28×28×512
*Conv1_2:*输入通道I为512，输出通道O为512，卷积核为N×N×I×O，stride=1，卷积核为3×3×512×512，则输出尺寸为28×28×512
Maxpooling:
Input:28×28×512
2×2的最大池化核，输出为14×14×512
5. input：14×14×512
要经过经过两次卷积cov3-64，
*Conv1_1:输入通道I为512，输出通道O为512，卷积核为N×N×I×O，stride=1，卷积核为3×3×512512，则输出尺寸为14×14×512
*Conv1_2:输入通道I为512，输出通道O为512，卷积核为N×N×I×O，stride=1，卷积核为3×3×512512，则输出尺寸为14×14×512
Maxpooling:
Input: 14×14×512
2×2的最大池化核，输出为7×7×512
Fc6： Input：7×7×512
输出为1×1×4096
总参数量为7×7×512×4096
Fc7： Input：1×1×4096
输出为1×1×4096
总参数量为4096×4096
Fc8： Input：1×1×4096
输出为1000（softmax）
总参数量为4096×1000
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/111a0fbd0e0fdf6f34d47570f79fd7dd/" rel="bookmark">
			2020/10/02练习定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .time-item { width: 450px; height: 45px; margin: 0 auto; } .time-item strong { background: orange; color: #fff; line-height: 49px; font-size: 36px; font-family: Arial; padding: 0 10px; margin-right: 10px; border-radius: 5px; box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2); } .time-item&gt;span { float: left; line-height: 49px; color: orange; font-size: 32px; margin: 0 10px; font-family: Arial, Helvetica, sans-serif; } .title { width: 260px; height: 50px; margin: 200px auto 50px auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/111a0fbd0e0fdf6f34d47570f79fd7dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e103b62a4ae924eb0d56577ddc46896e/" rel="bookmark">
			牛客NC4-判断链表中是否有环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 判断给定的链表中是否有环
扩展：
你能给出空间复杂度O(1)的解法么？
C++
1.空间复杂度O(n)，利用哈希表，存在环即当前节点的next已经在哈希表中出现过
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ #include &lt;unordered_map&gt; class Solution { public: bool hasCycle(ListNode *head) { unordered_map&lt;ListNode*, int&gt; listmap; if(head == nullptr) return false; ListNode* pNow = head; while(pNow != nullptr){ auto it = listmap.find(pNow); if(it != listmap.end()){//找到了，存在环 return true; } else{ listmap[pNow]++; } pNow = pNow-&gt;next; } return false; } }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e103b62a4ae924eb0d56577ddc46896e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eccc3fc3ea9a973b649846cc45533ab/" rel="bookmark">
			JAVA的重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：学校开了JAVA课程，简单的翻阅书本后发现前几章与大一开设的C语言内容高度相似，所以很容易理解，所以JAVA的学习笔记就用来记述自己在学习中遇到的一些问题。
何为重载 在Java中，同一个类中的多个方法可以有相同的方法名称，但是有不同的参数列表，这就称为方法重载（method overloading）。
参数列表又叫参数签名，包括参数的类型、参数的个数、参数的顺序，只要有一个不同就叫做参数列表不同。重载是面向对象的一个基本特性。
特点：与返回值类型无关，只看参数列表（参数的个数、参数的类型、参数的顺序）。
例如：
public class Demo { //一个普通得方法，不带参数，无返回值 public void add(){ //method body } //重载上面的方法，并且带了一个整形参数，无返回值 public void add(int a){ //method body } //重载上面的方法，并且带了两个整型参数，返回值为int型 public int add(int a,int b){ //method body return 0; } } 为什么会有重载？
比如，我们想计算两个数的相加的和，如果没有重载，我们在写求和这个方法时，必须写一个对整数的，再写一个对小数的。这样非常麻烦且不易调用。但有了重载以后，我们可以把对整数和小数的求和整合到一个方法中，不论往里面传的是小数还是整数都可以通过一次调用解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3048243a3328a1be7e3921ab95c45fe3/" rel="bookmark">
			js实现案例全选全不选(超详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * { padding: 0; margin: 0; } .wrap { width: 300px; margin: 100px auto 0; } table { border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; width: 300px; } th, td { border: 1px solid #d0d0d0; color: #404060; padding: 10px; } th { background-color: #09c; font: bold 16px "微软雅黑"; color: #fff; } td { font: 14px "微软雅黑"; } tbody tr { background-color: #f0f0f0; } tbody tr:hover { cursor: pointer; background-color: #fafafa; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3048243a3328a1be7e3921ab95c45fe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26edba033563dabb6465abb117065577/" rel="bookmark">
			js.全选反选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;script&gt; var j_cbAll = document.getElementById("j_cbAll"); var j_tb = document.getElementById("j_tb").getElementsByTagName("input"); j_cbAll.onclick = function() { for (i = 0; i &lt; j_tb.length; i++) { j_tb[i].checked = this.checked; } }; for (i = 0; i &lt; j_tb.length; `i++`) { j_tb[i].onclick = function() { var flat = true; for (i = 0; i &lt; j_tb.length; i++) { if (!j_tb[i].checked) { flat = false; break; } } j_cbAll.checked = flat; }; } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/566cdfa1a1e7f9c8ef163946352c72e5/" rel="bookmark">
			git常用命令及常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用git克隆指定分支的代码 如图，一个项目有多个分支的情况下 我们需要克隆指定的分支
使用Git下载指定分支命令为：git clone -b 分支名仓库地址
$ git clone -b dev + 仓库地址 2、git更新版本 2.17.1 版本之前用 git update 2.17.1 版本之后用 git update-git-for-windows 3、创建新的分支并提交合并到主分支 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 4、删除本地分和远程分支 1、git branch 查看本地分支
2、删除本地分支tmp
git checkout dev 删除分支前先切换到其他分支git branch -D tmp 3、git branch -r 查看远程分支
4、git push origin --delete tmp 删除远程分支tmp。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/566cdfa1a1e7f9c8ef163946352c72e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a7d7b8c42d264e1f21c4eefc38345ca/" rel="bookmark">
			Checkbox全选反选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; // 1. 全选和取消全选做法： 让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可 // 获取元素 var j_cbAll = document.getElementById('j_cbAll'); // 全选按钮 var j_tbs = document.getElementById('j_tb').getElementsByTagName('input'); // 下面所有的复选框 // 注册事件 j_cbAll.onclick = function() { // this.checked 它可以得到当前复选框的选中状态如果是true 就是选中，如果是false 就是未选中 console.log(this.checked); for (var i = 0; i &lt; j_tbs.length; i++) { j_tbs[i].checked = this.checked; } } // 2. 下面复选框需要全部选中， 上面全选才能选中做法： 给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。 for (var i = 0; i &lt; j_tbs.length; i++) { j_tbs[i].onclick = function() { // flag 控制全选按钮是否选中 var flag = true; // 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中 for (var i = 0; i &lt; j_tbs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a7d7b8c42d264e1f21c4eefc38345ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc7103c52c189b08df1fdaab9cab7b1/" rel="bookmark">
			【编译原理】4 语义分析和中间代码生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第4章 语义分析和中间代码生成 1 属性文法2 三地址代码的具体实现（中间代码）3 表达式及赋值语句的翻译3.1 简单算术表达式和赋值语句的翻译3.2 布尔表达式的翻译 4 控制语句的翻译4.1 条件语句if的翻译4.2 循环语句的翻译 1 属性文法 2 三地址代码的具体实现（中间代码） 3 表达式及赋值语句的翻译 3.1 简单算术表达式和赋值语句的翻译 语义子程序（在归约的同时执行）所涉及的语义变量、语义函数说明： 对非终结符E（算术表达式）定义语义变量E.place，即用E.place表示存放E值的变量名在符号表中的入口地址或临时变量名的整数码定义语义函数newtemp()，即每次调用newtemp()时都将回送一个代表新临时变量的整数码
临时变量名按产生的顺序可设为： T 1 、 T 2 、 ⋯ T_1 、T_2 、⋯ T1​、T2​、⋯定义语义函数emit(op,arg1,arg2,result)：产生一个四元式并填入四元式表中定义语义函数lookup(i.name)：审查i.name是否出现在符号表中，是则返回i.name在符号表的入口指针，否则返回NULL 3.2 布尔表达式的翻译 计算布尔表达式的值的方式
（1）仿照计算算术表达式的方法，按布尔表达式的运算顺序一步步地计算出真假
（2）根据布尔运算的特点实施某种优化，省略不影响运算结果的运算确定一个表达式的真假出口
处理E.tc和E.fc引入的语义变量和函数
4 控制语句的翻译 4.1 条件语句if的翻译 4.2 循环语句的翻译 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca2da09bb9079fdda41aa1df7c943efe/" rel="bookmark">
			#如何解决The MySQL server is running with the --secure-file-priv option so it cannot execute this state
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何解决The MySQL server is running with the --secure-file-priv option so it cannot execute this statement 一、问题 在使用mysql代码将查询结果导出到EXCEL表中时，遇到 “server is running with the --secure-file-priv option so it cannot execute this statement” 报错信息
二、产生原因 Mysql配置文件规定了导出文件的默认路径，自定义路径会报错。
三、解决办法 1. 输入命令 show variables like 'secure%' 变量secure_file_priv对应的值就是你电脑上MySQL默认导出文件的路径，笔者电脑的默认路径是C:\ProgramData\MySQL\MySQL Server 8.0\Uploads\，要想修改路径，只需将MySQL配置文件修改，如果不想修改路径，直接用它给的默认路径即可。
2. 将上图路径复制到资源管理器，回车 查看上一级目录，配置文件my.ini即保存在这里的
用笔记本打开my.ini，搜索 secure
找到secure-file-priv，将原本的那行注释掉(用#号)，在下面一行写
secure-file-priv="" secure-file-priv=""表示任意路径都可以，也可以自己指定路径。
3. 最关建的一步，Windows在打开配置文件时，会自动修改配置文件的编码格式为UTF-8，而MySQL配置文件的默认编码格式为 ANSI。这一步很重要！！！一定不要搞错，不然会导致MySQL重启失败。 点击 右上方-&gt;另存为-&gt;ANSI。 是否替换，选择“是”
4. 最后，重启MySQL服务，点击 开始-&gt;搜索组件服务-&gt;点击服务-&gt;找到mysql-&gt;重启此服务
四、查看结果 查询成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc7f343e594a75ecf61cfe85574961b/" rel="bookmark">
			chrome 通知权限管理_如何在Chrome浏览器中阻止或管理通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chrome 通知权限管理
Webapps have come a long way. Thanks to features like notifications, they can even replace traditional desktop apps for many people. But if you’d rather not be bombarded by notifications, though, here’s how to manage Chrome’s notifications (and block them from certain apps).
Webapp已经走了很长一段路。 借助通知之类的功能，它们甚至可以代替许多人的传统桌面应用程序。 但是，如果您不希望被通知轰炸，则可以通过以下方法来管理Chrome的通知(并阻止它们进入某些应用程序)。
Before we jump in, all of these settings should be identical in Chrome on PCs, as well as on Chromebooks. I’m using a Chromebook Flip C302 for this tutorial, but you shouldn’t have any issues following along.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecc7f343e594a75ecf61cfe85574961b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f846e19ee19e89b128475049cae142e/" rel="bookmark">
			Hadoop搭建集群中输入hdfs namenode -format格式化节点时，提示：hdfs: command not found 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分析原因：
hadoop的安装路径没有加入到当前路径中
解决办法：
方法1：
进入hadoop的安装目录，在执行hadoop命令时在前面加上：./bin ./sbin
方法2:
进入/etc/profile文件中添加hadoop的安装路径
sudo vim /etc/profile 添加：
export HADOOP_HOME=本机的hadoop安装路径 export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH 例如：
保存后退出后
source /etc/profile 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/161/">«</a>
	<span class="pagination__item pagination__item--current">162/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/163/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>