<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ed656743169f107f6c30565790fe10/" rel="bookmark">
			智能信息处理专业是干嘛的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：主要是介绍智能信息处理专业是干嘛的，包括其定义，涉及的领域，学习的内容和算法、发展趋势、工作前景和相关学习资料。
def:
使用各种智能手段进行信息交换的过程，其中智能信手段包括人工智能、机器智能、计算机智能等技术。
所涉及学科：
智能信息处理的运用领域：
利用计算机对物体、图像、语音、字符等进行自动识别的技术，它的过程包括：样本采集、信息的数字化、预处理、数据特征的提取、与标准模式进行比较、分类识别等。
应用实列：
图像重建算法、医用CT机、频谱分析、语音处理、图像处理、计算机视觉。
应用领域图解:
智能信息处理学习的内容：
主要是研究机器学习的，主要研究内容是人工智能的各种算法，比如：模糊理论、神经网络、遗传算法、专家系统等。
模糊理论：用于解决使用精确的数学方法解决不了的问题，使用语言对其进行描述。
神经网络：是一种模拟人脑的神经网络以期能够实现类人工智能的机器学习技术。
学习内容图解：
未来发展趋势：
建立坚实的理论基础。
渴望新的思想、模型–基于各种生物原理与过程是源泉。
各种智能计算机综合技术的集成。
广泛的、深入的应用扩展。
研究方向如下图：
主要工作方向：
毕业后去大公司做研究员、进入国家科研所当研究员。
发展状况和前景
相关网站（个人感觉没啥用，说的不清不楚）：
这篇文章算是对智能信息处理专业介绍比较详细的了，想了解更多可以去B站搜智能信息处理，里面有个清华大学教授录了视频。有很多的不足，后期还会修改补上。
相关博文推荐：
神经网络与深度学习笔记（一）适合刚入门的小白
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/557c242a9ff7e7b2eb0133f85f457bb3/" rel="bookmark">
			ubuntu16.04下运行海康威视网络摄像头sdk(qtdemo)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为工程原因不得不在Ubuntu系统下链接海康威视相机.查阅了很多资料,对于我这种小白来说都不够用,自己摸索吧,然后给海康威视开发者发各种傻x邮件,不要脸地问问题,总在在qt里把相机画面调出来了,希望接下来可以和各位大神一起交流.
1.首先拿到相机,用网线连上电脑,根据操作手册,先把相机激活,http://192.168.1.64/doc/page/login.asp?_1587994274991&amp;page=preview 我的是这个网址,设置好账户密码(牢记密码),记住自己相机的ip地址.设置好之后相机画面应该就能实时在网页上显示了.
2.到海康威视官网下载Linux版本的sdk,解压打开,如图所示
这里的consoledemo我还没研究明白怎么弄,先不管,搞一下那个qt demo 打开qt软件,里面有个qt_demo_readme.txt,先按照操作一下,就是复制一下库到…(路径不写了,text里面有),打开qt软件,选择打开新的项目:QtDemo/Linux64/QtCreator/QtClientDemo.pro文件,加载编译一下就好了,运行一下,出现图形化界面右击左上角的devicetree,配置添加设备,输入device的ip地址,设备的账户密码(刚才让记住的),结果出现下面的界面,错误113,
发邮件问了sdk开发者,是由于有个组件库没加载(具体错误类型可以看开发文档里面的chm文件(这个文件需要专用的阅读器打开,不过值得一看,安装教程可以百度,很简单)),具体操作就是将HCNetSDKCom里面的几个库文件,拷到外面来(上一层目录),和其他的库文件放到一起如图所示,
再次编译qt,运行,devicetree重复刚才添加设备的动作就能显示画面了,下一步想办法开发自动抓图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b764ace1e001f26be4211638e32a477/" rel="bookmark">
			Typora中的各种图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考这里：Typora中的各种图表 还有 网友的博客
流程图 ```(flow) #复制时，去掉#号及后面的内容和flow两边的括号 st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub=&gt;subroutine: 子流程 io=&gt;inputoutput: 输入输出框 e=&gt;end: 结束框 st-&gt;op-&gt;cond cond(yes,bottom)-&gt;io-&gt;e cond(no,left)-&gt;sub(top)-&gt;op ``` 效果图：
Created with Raphaël 2.2.0 开始框 处理框 判断框(是或否?) 输入输出框 结束框 子流程 yes no 流程图中主要的节点有：开始框、结束框、处理框、判断框、输入输出框、子流程框、并行任务等。
流程图中的每一个节点都对应着源码中的一个对象，定义的如下：
名字=&gt;属性: 显示内容
属性表明该对象属于开始框、结束框、处理框… 中的哪一种。
如果不指定，判断框的yes流程默认是向下走的，no流程向右。
如：cond(yes) cond(no)
当然也可以交换过来，让no流程向下，yes向右：
如：cond(yes) cond(no,bottom)
子流程框的括号里可以写 top、bottom、right、left 等，指定方向。
如：**sub(top) sub(bottom) sub(right) sub(left) **
并行任务框的用法：
```(flow) #复制时，去掉#号及后面的内容和flow两边的括号 st=&gt;start: 开始框 op=&gt;operation: 处理框 op1=&gt;operation: 处理框 op2=&gt;operation: 处理框 op3=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b764ace1e001f26be4211638e32a477/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b93ad0fac401aca8e683b0e4733c7bcf/" rel="bookmark">
			数据结构与算法概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构与算法概述
开发工具与关键技术：Visual Studio 2015 数据结构与算法概述
作者：李国旭
撰写时间：2020年4月26日
什么是“数据结构”，我们可以从最开始接触到的说起：那就是一个数据库的设计，而数据库中里面也有数据类型和长度。数据库和数据结构的相同点就是：数据库中表的关系有，一对一和多对多、一对多的关系；长度呢，就跟我们的算法的时间的复杂度有些相似，只不过它们的性质处理方面不一样而已。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。是组织并存储数据以便能够有效使用的一种专门格式，它用来反映一个数据的内部构成。即一个数据由那些成分数据构成，以什么方式构成，是什么结构。
目前，最关键的一个问题就是说：如何编写出有一个高效率的处理程序，就需要解决如何合理地组织数据，建立合适的数据结构，还有设计一个较好的算法；这些都是用来提高程序执行效率。对此，瑞士著名的计算机科学家尼古拉斯.沃思，他提出了“算法＋数据结构＝程序”这样的观念。
一、数据结构
（1）线性结构。结构中的数据元素之间存在着一对一的线性关系。（2）树结构。结构中的数据元素之间存在着一对一的层次关系。（3）图结构。结构中的数据元素之间存在着多对多的关系。
如下图所示：三种基本的逻辑结构
也就是说，1、线性结构：除第一个和最后一个数据元素外，每个数据元素只有一个前驱和一个后继数据元素。2、树结构：除根节点外，每个数据元素只有一个前驱数据元素，可有0个或若干个后继数据元素。3、图结构：每个数据元素可有0个或若干个前驱数据元素和0个或若干个后继数据元素。
上面的就是我们所说数据的逻辑结构，当然了最重要的还是我们的算法设计，它是取决于数据的逻辑结构；而我们的算法的实现也是取决于数据的物理存储结构，这是不可或少的一个环节。算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。此外，一个算法还具有以下五个重要特性。
有穷性：一个算法应包含有限个操作步骤。即一个算法在执行若干个步骤之后应该能够结束，而且每一步都在有限时间内完成。 确定性：算法中的每一步都必须有确切的含义，不能产生二义性。 可行性：算法中的每一个步骤都应该是能有效地执行，并得到确定的结果。 输入：所谓输入，是指在算法执行时，从外界取得必要的数据。计算机运行程序的目的是为了进行数据处理，在大多数情况下，这些数据需要通过输入得到。有些情况下，数据已经包含在算法中，算法执行时不需要任何数据，所以一个算法可以有零个或多个输入。 输出：一个算法有一个或多个输出，这是算法进行数据处理后的结果。没有输出的算法是毫无意义的。 二、下面就是我们算法的时间复杂度：记作T(n)=O(f(n))
T(n)随n的增大而增大，增长得越慢，其算法的时间复杂度越低。那么一个算法的执行时间大致上等于其所有语句执行时间的总和，对于语句的执行时间是指该条语句的执行次数和执行一次所需时间的乘积。语句执行一次实际所需的具体时间是与机器的速度、编译程序质量、输入数据等密切相关，与算法设计的好坏无关。所以，可用算法中语句的执行次数来度量一个算法的效率。像我们平时用的for循环语句一样，循环的次数越多；所需的时间也是相应的增加。
首先定义算法中一条语句的语句频度，语句频度是指语句在一个算法中重复执行的次数。以下给出了两个n×n阶矩阵相乘算法中的各条语句以及每条语句的语句频度。例如下面的这个语句一样！（此语句转载自唐懿芳教授的文档）
语句 语句频度
for（i=0；i&lt; n;i++） n＋1
for （j=0；j&lt;n;j++） n2＋n
{
c[i][j]=0; n2
for (k=0;k&lt; n; k++) n3＋n2
c[i][j]=c[i][j]+a[i][k]*b[k][j]; n3
} 三、下面我们来了解一下数据的存储结构
（1）线性表的存储方式：它有两种存储方式一种是顺序表和链表。
顺序表的特点：就是元素按顺序存放，它的地址是连续的。
有存放当然也有插入和删除了，下面的就是顺序表的插入。
如图所示：
在3的这个位置插入一个X这个字符，那么后面的（a3、a4、a5）这三个都必须往后移一格，也就是说从最后面的那个a5开始往后开始移，给X这个字符留出足够的空间，把X存放进来。为什么呢？因为如果我们从前开始往后移，它就会把后面的元素冲掉。在这个插入的时候，还要判断一下顺序表开辟的存储空间是否已经满了，满了的话呢！那就无法插入了。同理，就好像我们在做那个项目的新增和删除、修改的时候一样，都要先判断一下数据库里面是否存在这条数据，没有就新增，修改、删除也一样是这样的操作。
这个时候我们就要注意了，在删除的时候要注意备份；删除的元素要挨个往前移一格，这样才能保证地址的连续存放的特点。那么在这里我们就要注意了，如果我们的顺序表原来就是空的，那就谈不上删除了；如果size等于0，直接返回顺序表为空
（2）线性表的链式表示和实现
然而，链表不是地址连续的空间，他的插入和删除不需要移动元素，它看到内存有空余地址就可以毫无顾忌地挤进去。
单链表的结构：单链表中构成链表的结点只有一个指向直接后继结点的指针域。
结构特点;逻辑上相邻的数据元素在物理上不一定相邻。
他们呢又有两个域，一个是数据域和指针域，那么什么又是数据域呢？它就是用来存储元素数值数据的，另一个指针域就是用来存储直接后继存储地址。而且它也不需要地址连续的单元来存储线性表。不管是插入还是删除，它们都要先定位在前一个元素。
如下图所示：插入和删除
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a0dd7410eb76440a084a1ce8e5fc7e/" rel="bookmark">
			为什么匿名内部类只能访问其所在方法中的final类型的局部变量？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		匿名内部类不能访问外部类方法中的局部变量，除非变量被声明为final类型
这里所说的“匿名内部类”主要是指在其外部类的成员方法内定义，同时完成实例化的类，若其访问该成员方法中的局部变量，局部变量必须要被final修饰。原因是编译程序实现上的困难：内部类对象的生命周期会超过局部变量的生命周期。局部变量的生命周期：当该方法被调用时，该方法中的局部变量在栈中被创建，当方法调用结束时，退栈，这些局部变量全部死亡。而内部类对象生命周期与其它类一样：自创建一个匿名内部类对象，系统为该对象分配内存，直到没有引用变量指向分配给该对象的内存，它才会死亡(被JVM垃圾回收)。所以完全可能出现的一种情况是：成员方法已调用结束，局部变量已死亡，但匿名内部类的对象仍然活着。如果匿名内部类的对象访问了同一个方法中的局部变量，就要求只要匿名内部类对象还活着，那么栈中的那些它要所访问的局部变量就不能“死亡”。解决方法：匿名内部类对象可以访问同一个方法中被定义为final类型的局部变量。定义为final后，编译程序的实现方法：对于匿名内部类对象要访问的所有final类型局部变量，都拷贝成为该对象中的一个数据成员。这样，即使栈中局部变量已死亡，但被定义为final类型的局部变量的值永远不变，因而匿名内部类对象在局部变量死亡后，照样可以访问final类型的局部变量，因为它自己拷贝了一份，且与原局部变量的值始终一致。 最后，Java 8更加智能：如果局部变量被匿名内部类访问，那么该局部变量相当于自动使用了final修饰。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df832d5fc8196079da8d90192a17a5a5/" rel="bookmark">
			关于Centos7 firewalld防火墙开放端口后，但不能访问ftp和nginx的问题的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在阿里轻量应用服务器搭建ftp服务器这篇博客中把防火墙换为iptables,因为当时无论我怎么设置firewalld,就是无法访问ftp服务器,今天在翻看其他博客的时候,突然发现firewalld有打开服务这么一个命令,然后我就找到了解决的办法.
查看当前开了哪些端口其实一个服务对应一个端口，每个服务对应/usr/lib/firewalld/services下面一个xml文件。
firewall-cmd --list-services
1
通过这个命令我们查看当前打开了那些服务,比如下面这个
我开启了两个服务,但是没有开启http和ftp服务,所以不能通过外网访问搭建的nginx服务器和ftp服务器
(1)可以通过下面这个命令查看可以打开的服务有哪些
firewall-cmd --get-services
1
(2)可以通过下面的命令添加一个服务到firewalld
firewall-cmd --add-service=http //http换成想要开放的service
1
这样添加的service当前立刻生效，但系统下次启动就失效，可以测试使用。要永久开发一个service，加上 --permanent
firewall-cmd --permanent --add-service=http
1
然后通过systemctl restart firewalld.service重启防火墙就生效了
这个时候就可以通过外网访问搭建的nginx和ftp服务器了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/629a74407a0edb6b83be66c165d9862d/" rel="bookmark">
			开发过程中git常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装git，首先去git官网下载git，https://git-scm.com/downloads，下载.exe格式并安装。
首先拿到一个github的项目以后我们要先在window上生成一个ssh秘钥
键入命令：ssh-keygen -t rsa -C “email@email.com”，"email@email.com"是你的github账号
此时，你的C:\Users\admin.ssh这个路径下会生成两个文件：id_rsa和id_rsa.pub
用记事本打开id_rsa.pub文件，复制内容，在github.com的网站上到ssh密钥管理页面，添加新公钥，随便取个名字，内容粘贴刚才复制的内容。
接着克隆线上项目 git clone github.com/demo****
切出一个新的自己写代码的分支 git checkout -b feature/ceshi
如果写完了代码就 git add 文件名（如果都提交就直接git add即可）
写入提交的注释 git commit -m “demo”
提交代码，第一次提交用 git push -u origin feature/demo 以后提交就可以直接git push
合并代码 先切入要合并的分支 git checkout master 接着更新一个本地的代码 git pull origin master 然后合并代码 git merge feature/demo 合并完以后用git status 查看代码
On branch master Your branch is ahead of 'origin/master' by 12 commits. (use "git push" to publish your local commits) nothing to commit, working tree clean 上面的意思就是你有12个commit，需要push到远程master上 最后执行下面提交命令 git push origin master
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/629a74407a0edb6b83be66c165d9862d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5756e668e8f2922659e8e7d14dd3c5f/" rel="bookmark">
			约瑟夫环问题【队列实现，循环数组实现】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起源 约瑟夫环问题的起源来自犹太历史学家约瑟夫和他的朋友以及39其余的犹太人，总共41人为了躲避敌人，藏在一个山洞中，
39个犹太人决定宁愿死也不被敌人抓到，于是决定自杀，所有人排成一个圈，由第一个人开始报数，每当数到3，就自杀。
这个游戏接着从自杀的位置开始，还是从1数到3。依次类推，约瑟夫将朋友和自己安排在了16和31的位置，最后顺利逃过了
自杀这一劫，因为最后就剩他一个人了。
题目描述 n 个人围成一圈，从第一个人开始报数,数到 k 的人出列，再由下一个人重新从 1 开始报数，数到 k 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。
输入 输入两个整数，n和m
输出 输出一行 n 个整数，按顺序输出每个出圈人的编号。
传送门 约瑟夫问题
思路1 我们可以用循环数组实现，数到指定的数过后，就标记为已出圈并且统计出圈人数，直到出圈人数等于所有人数。
代码 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int arr[105]; bool vis[105]; int main(){ int n,k; scanf("%d%d",&amp;n,&amp;k); int i=0,j=0,num=0,cnt=0; while(true){ j=i%n+1; if(!vis[j])	num++;//没走过就报数 if(num==k){//当报的数为指定值时，则标记为已出圈 num=0; cnt++;	vis[j]=true; printf("%d ",j); if(cnt==n)	break; } i++; } return 0; } 思路2 我们也可以把这个题想象为是一个队列操作，先把每个数压入队列，然后从队头开始遍历，如果报数等于指定数，则弹出队列，否则压入这个数(压入则是在队尾)，再弹出这个数，如果这里不理解，手画一遍，就能明白。
代码 #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main(){ queue&lt;int&gt;q; int n,k,num=1; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++)	q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5756e668e8f2922659e8e7d14dd3c5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a05a79c8b24c9afff0a2913939eecb71/" rel="bookmark">
			idea启动项目修改的代码不生效怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这仅是自己遇到的一种情况，没帮上请见谅 说一下自己的惨痛经历：一开始以为是配置文件或者pom没有导入依赖，检查了好几遍，确认和别的服务(项目)一样。。一开始以为是tomcat的问题猛找一番，找了四五个小时无果。后来发现，别的项目能起效，该项目每次都得clear。install之后才会生效。网上查了一下发现了罪魁祸首。。。。少了iml文件，主要是平时都ignore了也看不到少没少这个文件。。。
话不多说上菜：
第一个方法：第一个是整个大项目全部都重新生成。第二个是单个小服务。
第一个方法生成不了的话用第二个方法。
第二个方法：找到下面这个，跟cmd一样。。进入到你缺少iml的项目下面执行是mvn idea:module
重新启动项目，完成！
惨招idea毒打。
希望对看到的人有帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a63a1c4a45e45dfd7c0e93c5cebadca/" rel="bookmark">
			8.栈实现浏览器的前进后退
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈实现浏览器的前进后退 当你一次访问 1、2、3 页面之后，点击浏览器的后退按钮就可以返回到 2 和 1.当后退到 1，点击前进按钮还可以继续查看页面 2、3。但是当你退到 2 页面，点击了新的页面 4，那就无法继续通过前进、后退查看页面 3 了。
「我们如何实现这个功能呢？」
什么是栈 「栈」我们都知道 Java 虚拟机 JVM 就有『本地方法栈』『虚拟机栈』的划分，每个方法执行的时候都会创建一个栈帧用于存放局部变量表、操作数栈、动态链接、方法出口信息。
每一个方法从调用到结束，就对应着一个栈帧在「虚拟机栈」的入栈与出栈的过程。这里其实就是运用了「栈」数据结构的特性：「后进先出、先进后出」。就像一摞叠在一起的盘子，入栈就像我们放盘子，出栈就是我们从上往下一个个取。
栈 「栈是一种「操作受限」的线性表」，只允许在一端插入和删除数据。
是不是觉得这种数据结构有何意义，只有受限的操作，相比「数组」和「链表」感觉没有任何优势。为何还要用这个「操作受限」的「栈」呢？
特定的数据结构用在特定的场景，数组与链表暴露太多的操作接口，操作灵活带来的就是不可控，也就更加容易出错。
「当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构」。
比如我们的 JVM 栈结构，方法调用则是对应的入栈与出栈。
栈的实现 核心操作就是「入栈」「出栈」，也就是在栈顶插入元素、从栈顶取出元素。
理解了两个核心操作后，我们可以使用数组或者链表来实现。
数组实现的栈，叫做 「顺序栈」 。
用链表实现，叫做 「链式栈」。
这里我通过数组实现一个顺序栈，可用于实际开发中，我拓展了「清空栈」、「拓容」、「构建默认大小与最大限制」。代码我放在 GitHub https://github.com/UniqueDong/algorithms.git上，自己撸一遍，再对比下是否写的正确。
这里不仅仅作为一个 示例，我的例子还考虑了栈默认初始大小以及最大限制，当超过默认大小但是还没有达到最大限制的时候，还需要扩容操作。
import java.util.Arrays; /** * 基于数组实现的栈 * @param &lt;T&gt; */ public class ArrayStack&lt;T&gt; { /** * 默认大小 */ public static final int DEFAULT_SIZE = 128; /** * 默认最大限制，-1 表示无限制 */ private static final int DEFAULT_LIMIT = -1; /** * 初始化栈大小 */ private int size; /** * 栈最大限制数，-1 表示无限制 */ private final int limit; /** * 指向栈顶元素的下标，默认没有数据 -1 */ private int index; /** * 保存数据 */ private Object[] stack; /** * 默认构造方法，创建一个 128 大小，无限制数量的栈 */ public ArrayStack() { this(DEFAULT_SIZE, DEFAULT_LIMIT); } // 指定大小与最大限制的栈 public ArrayStack(int size, int limit) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a63a1c4a45e45dfd7c0e93c5cebadca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c62a1ddcd55ac4af3fdff78bfdd43f4/" rel="bookmark">
			empty/missing DT_HASH in &#34;libxxx.so&#34; (built with --hash-style=gnu?)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：在将开发的App放到Android4.4版本的手机上运行时，发现so库执行报了个错误：
java.lang.UnsatisfiedLinkError: dlopen failed: empty/missing DT_HASH in "libxxx.so" (built with --hash-style=gnu?)
网上查询了相关资料，有以下几种方法：
1. 参考 https://blog.csdn.net/keial/article/details/94748526
测试结果：加了之后没有起到效果。
2. 参考https://www.cnblogs.com/mthoutai/archive/2017/05/31/6922784.html
由于项目里用的是cmake编译NDK，所以没法用上面的方式直接配置，于是又陷入查询对应的cmake配置方法，花了好多时间。。最终在CMakeLists.txt中添加
set(CMAKE_LINK_DEF_FILE_FLAG "Wl,-hash-style=sysv") //跟图片上第一个配置项应该是匹配的
第二个配置项没能从CMakeLists.txt的提示中查到对应配置项故没能设置。编译之后，发现还是没解决问题。
3. 最终解决方案:修改build.gradle的minSdkVersion，从29改为19，重新编译so就可以了。之前没注意minSdkVersion被设成29，而且在Android8.0上也可以正常执行，没想到Android4.4的就运行不了，可看出minSdkVersion在NDK编译也是有起到的相关作用的，需要根据设备版本做对应配置。
参考：http://blog.sina.com.cn/s/blog_8acf1be10102w6x1.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59cb43ece607558c766b5723481d3994/" rel="bookmark">
			java.io.FileNotFoundException: xxx\.cxx\cmake\release\armeabi-v7a\android_gradle_build.json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：在编译NDK库文件Release版本时，出现以下错误：
FAILURE: Build failed with an exception.
* What went wrong:
Execution failed for task ':xxx:externalNativeBuildRelease'.
&gt; java.io.FileNotFoundException: xxx\.cxx\cmake\release\armeabi-v7a\android_gradle_build.json (系统找不到指定的路径。)
* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
* Get more help at https://help.gradle.org
BUILD FAILED in 2s
13 actionable tasks: 11 executed, 2 up-to-date
解决:
网上查了一下，发现是gradle版本的bug原因，更新gradle后，就可以正常编译。
步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59cb43ece607558c766b5723481d3994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7843d911223d682848a3ae39bc79d21/" rel="bookmark">
			串口偶尔接受不到数据的案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在调试产品的时候，发现显示端与串口小板相连调试的时候，串口通信稳定。
但是当设备整体运行的时候，显示端与充电模块通信就很不稳定。
后发现是因为，把uart 初始化的时候，把RX,TX设置为开漏，机器一运行，电磁干扰，就会影响串口的收发。
解决办法：把串口的收发设置为上拉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60e9eaf04950eca8d142cf547de50ee3/" rel="bookmark">
			双剑合璧：Markdown 与思维导图的相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown 与思维导图的相互转换 作者：毕小烦
思维导图重在逻辑梳理和推演，Markdown 重在简化写作的排版，若能将两者优点结合，那可真是太好了。
比如，
先使用思维导图梳理写作思路，再使用 Markdown 丰富细节，或者将已完成的 Markdown 文章导出为思维导图，重新理清逻辑。
具体该怎么做呢？
1. 思维导图转换为 Markdown 思维导图转换为 Markdown 比较简单，通过软件导出即可。
假如你使用的思维导图软件是 XMind 2020（XMind Zen），导出 Markdown 的步骤是：
菜单栏：文件 → 导出 → Markdown
用法比较简单，这里就不演示了。
2. Markdown 转换为思维导图 markmap-lib 是一个将 Markdown 转换为思维导图的工具，更准确的说是将 Markdown 转换为可视化、可交互的 HTML 格式的思维导图。
markmap-lib 提供了命令行（markmap）和在线（https://markmap.js.org/repl）两种使用方式。
基本信息
工具名称markmap-lib当前版本0.5.1开发语言JavaScript适用平台macOS、Linux、Windows开源地址https://github.com/gera2ld/markmap-lib 环境准备 安装 markmap-lib
# 方法 1 $ yarn global add markmap-lib # 方法 2 $ npm i markmap-lib -g 安装完成后查看版本
$ markmap -V 0.5.1 快速开始 STEP 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60e9eaf04950eca8d142cf547de50ee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39bf4ae37a1f73b3a332feefbaab5d88/" rel="bookmark">
			QT QTable的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置列数、列宽；设置HorizontalHeader：
列名、居中对齐、尾部不留白(setStretchLastSection)设置verticalHeader：
隐藏自动编号设置只读显示 QStringList header; ui-&gt;tableWidget-&gt;setColumnCount(3); ui-&gt;tableWidget-&gt;setColumnWidth(0, 50); ui-&gt;tableWidget-&gt;setColumnWidth(1, 100); ui-&gt;tableWidget-&gt;setColumnWidth(2, 200); header&lt;&lt;"序号"&lt;&lt;"ID"&lt;&lt;"名称"; ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(header); ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setDefaultAlignment(Qt::AlignCenter); //设置尾部不留白 ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setStretchLastSection(true); //隐藏自动编号 ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setHidden(true); //设置只读显示 ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d648e557f9699a82a75a10a54cc489/" rel="bookmark">
			c语言 * 和 **型指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于C语言的指针类型，有点乱，测试了一下。
了解到：
1.声明赋值与非声明赋值
2. * 与 ** 的区别与意义
3. 一些 &amp; 和 * 的利用方法
如 int * b=&lt;value&gt;,在这里b是int型指针，
声明时候需要加 * ，但是声明时赋值还是赋值给 b的
也就是 int *b =&lt;value&gt; 等价于 int *b， b =&lt;value&gt; 这两句
有声明时赋值可以拆为两句看
另外 直接输出b是b指向的对象的地址，
例如int *b =&amp;c //(c=2) b就是c的地址 *b就是取c的值—&gt;2
b=&amp;c与 *b=c是等效的
注意b声明是int *型指针，那么只能指向 int型的对象
int ** a=&amp;b
与 * 类似
声明时int ** a=&amp;b等价于 int ** a, a=&amp;b两句
a=&amp;b 等价于 *a =b
但是这里 a 声明是int **型指针,只能指向 int *型 的对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97d648e557f9699a82a75a10a54cc489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1994a1d64b8f48d3ad29bc6baf567321/" rel="bookmark">
			C语言strcpy函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		strcpy简单使用： #include &lt;stdio.h&gt; #include &lt;string.h&gt; struct Student { int sid; char name[20]; int age; } st; //此处分号不可省略 int main(void) { struct Student st = {1000,"zhangsan",20}; printf("%d %s %d\n", st.sid, st.name, st.age); st.sid = 500; // st.name="lisi" //error strcpy(st.name,"lisi"); st.age=20; while(true){} } 头文件：#include &lt;string.h&gt; 和 #include &lt;stdio.h&gt;
功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间
说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。返回指向dest的指针。
//C语言标准库函数strcpy的一种典型的工业级的最简实现。 //返回值：目标串的地址。 //对于出现异常的情况ANSI-C99标准并未定义，故由实现者决定返回值，通常为NULL。 //参数：des为目标字符串，source为原字符串。 char* strcpy(char* des,const char* source) {　char* r=des; assert((des != NULL) &amp;&amp; (source != NULL)); while((*r++ = *source++)!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1994a1d64b8f48d3ad29bc6baf567321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51de55025624a302cd00eeb4e3e76bf8/" rel="bookmark">
			最简单的Shiro免密登陆（springboot）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路比较简单，实现也简单，要的就是简单！ 实际项目中可以此基础上封装
重写UsernamePasswordToken 中 getCredentials() 方法。所以新增了类NoPwdToken
在UserRealm类中的 doGetAuthenticationInfo(AuthenticationToken authcToken) 方法执行时，判断参数authcToken的类型如果是NoPwdToken类型，则返回值改为getCredentials()方法对应的验证信息。（即：SimpleHash simpleHash = new SimpleHash("SHA-256", "123456", null, 16);）。
1、增加类：NoPwdToken （关键地方是20行重写的方法）
import org.apache.shiro.authc.UsernamePasswordToken; public class NoPwdToken extends UsernamePasswordToken { public NoPwdToken(String username) { this.username = username; } private String username; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } @Override public Object getCredentials() { //这里和下方的123456对应，也可以别的，一致即可。 return "123456"; } } 2、修改UserRealm类中 的 doGetAuthenticationInfo(AuthenticationToken authcToken) 方法。（关键地方是2-13行）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51de55025624a302cd00eeb4e3e76bf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ee363a1256e342632259172a0d9c4d/" rel="bookmark">
			【IDEA】idea父子项目创建module，解决springboot的&lt;parent&gt;标签问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建普通maven的父子节点 这个很简单，先建立一个maven项目，然后再新建这个项目的module:
观察父pom:
观察子pom:
这些都是自带的，父项目的src可以删除，基本父项目不写代码，只做pom引入公共jar包，测试：
在父pom，引入junit，子项目使用：
很简单，接下来看springboot:
二、maven+springboot父子项目创建 外面的父maven不多说，先建立好，步骤跟1一样，然后子模块新建springboot,发现问题了，springboot自带parent:
而且父pom，也不像上面的两个maven项目一样，会生成&lt;module&gt;标签内容.
Pom也不支持两个parent
所以，要手动调整，要把子pom里面的部分内容放到父pom：
原父pom:
by capricornce
现在的父pom:
看下现在的子module的pom：
测试如上个demo,不作演示。
注意：如果是spring-cloud模块，子pom的这一块也要剪切到父pom:
~END~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce73da948ec16f2e3cc154a1de218086/" rel="bookmark">
			AWS面向AIOT的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIOT, 概括为云端训练，边缘推理，在云平台上运用各种AI/ML工具，训练出模型，然后将模型推送到边缘设备，然后当传感器感知后，将信息输入到边缘设备，然后边缘设备通过模型直接进行运算并得出结论作出响应。而这些输入输出信息又可以提交到云平台作为基础数据，进行训练，整体上形成一个闭环的自循环的AIOT。
所以可以看出云端训练，面向历史数据，重在训练模型，而边缘推理，面向实时数据，重在部署模型，并根据模型得出结果。
IOT物联网收集数据，DT大数据技术ETL数据，甚至有初步BI可视化展示，然后通过AI训练模型，再回馈给IOT。
以上流程，AWS提供全套解决方案。在IOT端，提供Greengrass软件，安装在边缘设备中，它支持docker与lamda，可安装Tensorflow/MXNet等框架，用于模型部署、推理与推送数据至云端，而在云端，通过各种大数据技术，比如使用ElasticSearch做数据的清洗与可视化展示，然后通过各种AI服务(面向软件工程师，通过上传数据与调用API即可实现智能化)和ML服务(面向数据工程师，通过对各流行机器学习与深度学习框架集成，满足各种训练需要)。
AI服务
视觉CV：Amazon Rekongnition
语音：Amazon Polly
聊天机器人：Amazon Lex
预测：Amazon Forcast
ML服务
Amazon SageMaker
它支持的框架包括：TensorFlow、PyTorch、Apache MXNet、Chainer、Keras、Gluon、Horovod、Scikit-learn 和 Deep Graph Library。
案例1：
Amazon 包裹打包，解决客户开箱体验，节省企业成本。
案例2：
睿视智觉工业AI自训练系统，帮忙用户封装算法至设备，取代人工质检，甚至可用于生物细胞检验，其实只要有关视觉方面检验，这套解决方案都适用。
他们从最早的，把算法放到客户机器，进行训练，到目前远程把算法训练好，远程传到设备。
设备拍照&gt;机器学习分析&gt;出报告
客户本地将数据标注好，放到AWS，云端自动训练与测试，生成模型报告，比如对缺陷1敏感，对缺陷2不敏感，那么客户就可以再上传更多的缺陷2的数据。可以等报告针对所有缺陷都训练好再使用，或者对部分训练好的也可以直接使用。
案例3：
闹腾科技非标机加工件核价，解决非标机加工件核定价格问题，把原来依赖老师傅定价，训练模型，取代老师傅。
根据老师傅的经验去构建模型，然后通过历史数据训练得出模型。最后部署上云，提供API给甲方集成到现有系统，然后甲方客户通过线上上传他们的加工件3D模型，直接生成报价给用户。
其中对于初创者几点启示：
AWS提供Deep learning AMI，已包含TensorFlow,PyTorch，所以马上就可以用，不用花时间在部署软件上。
训练用GPU，而部署/预测用CPU，然后通过API，供企业调用。
GPU非常昂贵，AWS做到按需收费，对于初创公司节约成本非常重要。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/170/">«</a>
	<span class="pagination__item pagination__item--current">171/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/172/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>