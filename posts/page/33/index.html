<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81be7115291c99e7612bfee7db104b16/" rel="bookmark">
			解决IDEA中多个项目不在同一窗口下显示的问题和添加新的git的URL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以上是添加显示多个项目
以下是给新添加的项目添加git
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f0db8a0b7f783c9bbc5adab24adbf2/" rel="bookmark">
			python requests 请求https DH_KEY_TOO_SMALL错误解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我的 requests版本是2.31.0, 百度谷歌给出的方案就是不能解决问题
最后stackoverflow搜这个错误, 无意看到关于httpx ssl的问题, 果断换个框架, 解决问题.
import httpx httpx._config.DEFAULT_CIPHERS += ":ALL:@SECLEVEL=1" with httpx.Client() as client: response = client.get("https://xxxx") print(response.text) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d28cadfb511d6293382df774abd8ad65/" rel="bookmark">
			“十道机器学习问题，帮助你了解基础知识和常见算法“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简介： 1. 什么是机器学习？它与传统编程有什么不同之处？2. 请解释监督学习和无监督学习的区别。3. 什么是过拟合和欠拟合？如何解决这些问题？4. 请解释交叉验证在机器学习中的作用。5. 什么是特征选择？为什么它在机器学习中很重要？6. 请解释决策树算法的工作原理。7. 什么是支持向量机（SVM）？它在机器学习中的应用有哪些？8. 请解释神经网络是如何工作的。9. 什么是聚类算法？请举一个聚类算法的例子。10. 请解释朴素贝叶斯算法的原理。总结 简介： 机器学习是一种人工智能领域的重要分支，通过从数据中学习和改进来让计算机执行任务。与传统编程不同，机器学习使计算机能够从大量数据中发现模式和规律，并做出预测和决策。它的应用领域非常广泛，包括图像识别、语音识别、自然语言处理、推荐系统等。机器学习分为监督学习和无监督学习，前者通过输入和输出标签进行训练，后者从未标记的数据中自动发现模式和结构。过拟合和欠拟合是常见问题，可以通过增加训练数据、调整模型复杂度和使用正则化技术来解决。评估模型性能是关键任务，常用的方法是交叉验证。特征选择也很重要，可以提高模型性能和减少计算开销。常见的机器学习算法有决策树、支持向量机、神经网络、聚类算法和朴素贝叶斯算法。机器学习是充满挑战和机遇的领域，为解决复杂问题和实现智能化应用提供了强大的工具和方法。
1. 什么是机器学习？它与传统编程有什么不同之处？ 机器学习是一种人工智能（AI）的分支领域，旨在通过让计算机从数据中学习和改进，使其能够执行特定任务而无需明确编程。与传统编程相比，机器学习有以下几个不同之处：
数据驱动：在传统编程中，开发人员需要编写明确的规则和指令来指导计算机执行特定任务。而在机器学习中，算法通过从大量数据中学习模式和规律来进行决策和预测。
自动化学习：传统编程是通过手动编写代码来实现特定功能，需要开发人员具备领域知识和专业技能。而机器学习算法可以自动从数据中学习，并根据反馈进行自我改进，不需要人工干预。
适应性和泛化能力：机器学习算法具有适应性和泛化能力，它们可以根据新的数据进行学习和调整，以适应不同的情境和任务。而传统编程通常是针对特定的输入和输出进行编码，对于新的情况可能无法灵活应对。
处理复杂性：机器学习可以处理大量和复杂的数据，并从中提取有用的信息和模式。传统编程可能无法有效处理大规模的数据和复杂的问题。
2. 请解释监督学习和无监督学习的区别。 监督学习和无监督学习是机器学习中两种常见的学习方法，它们在学习过程和目标上有所不同。
监督学习（Supervised Learning）是一种通过已有的标记数据（有输入和对应的输出）来训练模型的学习方法。在监督学习中，我们提供给算法的训练数据集包含了输入特征和相应的标签或输出。算法的目标是根据输入特征预测或分类出正确的输出。监督学习的目标是让模型能够通过学习已有的标记数据，从中推广到新的未标记数据，并做出准确的预测。常见的监督学习算法包括线性回归、逻辑回归、决策树、支持向量机（SVM）和神经网络等。
无监督学习（Unsupervised Learning）是一种从未标记的数据中发现模式和结构的学习方法。在无监督学习中，我们提供给算法的训练数据集只包含输入特征，没有对应的标签或输出。算法的目标是通过学习数据中的内在结构、相似性或其他模式，来进行聚类、降维、异常检测等任务。无监督学习的目标是发现数据中的隐藏信息和结构，以便更好地理解数据的特点和关系。常见的无监督学习算法包括聚类算法（如K均值聚类、层次聚类）、关联规则挖掘、主成分分析（PCA）和自编码器等。
总结起来，监督学习依赖于已有的标记数据来训练模型，目标是预测或分类新的未标记数据。而无监督学习则从未标记的数据中发现模式和结构，目标是理解数据的内在特征和关系。这两种学习方法在解决不同类型的问题时具有各自的优势和应用场景。
3. 什么是过拟合和欠拟合？如何解决这些问题？ 过拟合（Overfitting）和欠拟合（Underfitting）是机器学习中常见的问题，它们都与模型的泛化能力有关。
过拟合指的是模型在训练数据上表现良好，但在新的未见过的数据上表现较差的情况。这是因为模型过于复杂，过度拟合了训练数据中的噪声和细节，导致对新数据的泛化能力下降。过拟合的模型可能会过度记住训练数据的细节，而无法适应新的数据。
欠拟合指的是模型无法充分拟合训练数据的情况。欠拟合的模型通常过于简单，无法捕捉数据中的复杂关系和模式，导致在训练数据和新数据上都表现不佳。
解决过拟合和欠拟合的方法如下：
解决过拟合：
数据集扩充：增加更多的训练数据，可以减少模型过拟合的风险。特征选择：选择最相关的特征，减少不必要的特征，以降低模型复杂度。正则化（Regularization）：通过添加正则化项（如L1正则化或L2正则化）来限制模型参数的大小，防止过度拟合。交叉验证：使用交叉验证来评估模型的性能，选择最佳的模型参数和超参数。提前停止（Early Stopping）：在训练过程中，根据验证集的性能来决定何时停止训练，避免过度拟合。 解决欠拟合：
增加模型复杂度：增加模型的容量，例如增加神经网络的层数或神经元的数量，使其能够更好地拟合数据。特征工程：通过添加更多的特征、多项式特征或其他特征变换来捕捉数据中的更多信息。减少正则化：减少正则化的程度，以允许模型更好地拟合训练数据。调整超参数：调整学习率、批次大小等超参数，以获得更好的拟合效果。收集更多数据：增加更多训练数据可以提供更多的信息，帮助模型更好地拟合数据。 4. 请解释交叉验证在机器学习中的作用。 交叉验证（Cross-validation）在机器学习中是一种评估模型性能和选择最佳模型参数的常用方法。它通过将训练数据划分为多个子集，然后在这些子集上进行多次训练和验证，来评估模型的泛化能力。
交叉验证的作用如下：
评估模型性能：通过将数据划分为训练集和验证集，交叉验证可以提供对模型性能的更准确评估。每个子集都会被用作验证集一次，从而获得多个性能指标，可以计算平均值或其他统计量来得到更可靠的性能估计。
防止过拟合：交叉验证可以帮助检测和防止模型的过拟合。通过在多个验证集上评估模型性能，可以更好地了解模型的泛化能力。如果模型在训练集上表现很好，但在验证集上表现较差，可能是过拟合的迹象。
模型选择：交叉验证可用于选择最佳的模型参数和超参数。通过在不同参数设置下进行交叉验证，并比较性能指标，可以选择具有最佳性能的模型。这有助于避免在训练集上过度优化，选择更具泛化能力的模型。
常见的交叉验证方法包括k折交叉验证（k-fold cross-validation）、留一交叉验证（leave-one-out cross-validation）和随机划分交叉验证（random split cross-validation）。在实际应用中，根据数据集的大小和特点，选择适当的交叉验证方法来评估和选择模型。
5. 什么是特征选择？为什么它在机器学习中很重要？ 特征选择是指从一组输入特征中选择一组最相关的特征，以提高机器学习模型的性能。它在机器学习中很重要，因为它可以减少训练数据量，减少计算复杂度，提高模型的准确性和稳定性，以及提高模型的可解释性。
6. 请解释决策树算法的工作原理。 决策树是一种用于分类和回归的机器学习算法，它通过一系列逻辑判断来推断出一个给定的数据集中的最优决策。决策树通常包括根节点、内部节点和叶节点。根节点代表整个数据集，而内部节点代表某个特征或属性，叶节点则代表结果类别。每个内部节点都代表一个特征测试，并且根据特征测试的结果将其子节点分为不同的分支，直到达到叶节点为止。
7. 什么是支持向量机（SVM）？它在机器学习中的应用有哪些？ 支持向量机（Support Vector Machine, SVM）是一种机器学习方法，它可以在高维空间中找到一条最佳分割超平面，将数据划分为两类。SVM的目标是在给定的数据集中找出一条最大边距的超平面，使得同类样本尽可能接近，异类样本尽可能远离。
SVM可以应用于各种机器学习任务，如分类、回归、聚类、异常检测等。它常用于文本分类、图像识别、生物医学数据分析等领域，在这些领域表现出强大的性能和有效性。
8. 请解释神经网络是如何工作的。 神经网络是一种机器学习模型，受到人类神经系统的启发而设计。它由多个神经元（或称为节点）组成，这些神经元通过连接权重相互连接，形成各个层级的网络结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d28cadfb511d6293382df774abd8ad65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/444378d6c3ce7949cb9de12d43e1c563/" rel="bookmark">
			“深入了解卷积神经网络（CNN）：工作原理、优点、应用和训练方法“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简介1.什么是卷积神经网络 (CNN)？2. 卷积神经网络的工作原理是什么？3. 卷积神经网络有什么优点和缺点？4. 卷积神经网络在哪些领域有应用？5. 如何训练卷积神经网络？6. 如何评估卷积神经网络的性能？7. 如何在卷积神经网络中进行特征提取？8. 如何在卷积神经网络中进行图像分类？9. 如何在卷积神经网络中进行目标检测？10. 如何在卷积神经网络中进行语义分割？总结 简介 卷积神经网络 (CNN) 是一种人工神经网络，它在处理图像和视频等具有局部结构的数据时表现出出色的性能。CNN 由一系列卷积层组成，每个卷积层都使用一个卷积核来提取输入数据的局部特征。这些特征然后被传递到下一层，在那里它们被进一步提取。最终，CNN 输出一个分类或回归结果。卷积神经网络（CNN）是用于处理具有局部结构的数据的人工神经网络。它通过卷积层提取输入数据的局部特征，并传递到下一层进行进一步提取，最终输出分类或回归结果。
1.什么是卷积神经网络 (CNN)？ 卷积神经网络 (CNN) 是一种人工神经网络，它在处理图像和视频等具有局部结构的数据时表现出出色的性能。CNN 由一系列卷积层组成，每个卷积层都使用一个卷积核来提取输入数据的局部特征。这些特征然后被传递到下一层，在那里它们被进一步提取。最终，CNN 输出一个分类或回归结果。
2. 卷积神经网络的工作原理是什么？ 卷积神经网络的工作原理类似于人眼。人眼通过视网膜将光线转换成电信号，然后这些电信号被传递到大脑，大脑将这些电信号解码成视觉信息。CNN 的工作原理类似于人眼，它使用卷积层来提取输入数据的局部特征，然后将这些特征传递到下一层，在那里它们被进一步提取。最终，CNN 输出一个分类或回归结果。
3. 卷积神经网络有什么优点和缺点？ 卷积神经网络的优点包括：
在处理图像和视频等具有局部结构的数据时表现出出色的性能。可以处理不同大小和形状的输入数据。可以并行处理数据。可以自动学习特征。 卷积神经网络的缺点包括：
训练时间可能很长。可能很难解释为什么 CNN 做出了某些预测。可能很容易过拟合。 4. 卷积神经网络在哪些领域有应用？ 卷积神经网络在许多领域都有应用，包括：
图像分类目标检测语义分割物体识别人脸识别自然语言处理机器翻译药物发现材料科学 5. 如何训练卷积神经网络？ 卷积神经网络可以通过监督学习或无监督学习进行训练。在监督学习中，卷积神经网络使用带有标签的数据进行训练。在无监督学习中，卷积神经网络使用没有标签的数据进行训练。
6. 如何评估卷积神经网络的性能？ 卷积神经网络的性能可以通过以下方式进行评估：
准确率召回率精度平均绝对误差均方根误差 7. 如何在卷积神经网络中进行特征提取？ 卷积神经网络可以通过以下方式进行特征提取：
卷积层池化层全连接层 8. 如何在卷积神经网络中进行图像分类？ 卷积神经网络可以通过以下方式进行图像分类：
使用卷积层提取图像的特征。使用池化层减少特征的数量。使用全连接层将特征转换成分类结果。 9. 如何在卷积神经网络中进行目标检测？ 卷积神经网络可以通过以下方式进行目标检测：
使用卷积层提取图像的特征。使用池化层减少特征的数量。使用全连接层将特征转换成目标的坐标。 10. 如何在卷积神经网络中进行语义分割？ 卷积神经网络可以通过以下方式进行语义分割：
使用卷积层提取图像的特征。使用池化层减少特征的数量。使用全连接层将特征转换成每个像素的类别标签。 总结 卷积神经网络（CNN）是用于处理具有局部结构的数据的人工神经网络。它通过卷积层提取输入数据的局部特征，并传递到下一层进行进一步提取，最终输出分类或回归结果。CNN的工作原理类似于人眼的视觉系统，使用卷积层提取局部特征，类似于视网膜将光线转换为电信号。特征经过池化层等处理后，类似于大脑对电信号进行解码和处理，生成视觉信息。CNN具有处理局部结构数据的优势，能处理不同大小和形状的输入数据，可并行处理数据，并能自动学习特征。然而，CNN的训练时间可能较长，解释预测结果困难，容易过拟合。CNN广泛应用于图像分类、目标检测、语义分割、物体识别、人脸识别、自然语言处理、机器翻译、药物发现和材料科学等领域。训练CNN可采用监督学习或无监督学习，评估性能可使用准确率、召回率、精度、平均绝对误差和均方根误差等指标。特征提取常使用卷积层、池化层和全连接层。图像分类通过卷积层提取特征，池化层减少特征数量，全连接层转换为分类结果。目标检测通过卷积层提取特征，池化层减少特征数量，全连接层转换为目标坐标。语义分割通过卷积层提取特征，池化层减少特征数量，全连接层转换为像素类别标签。总之，卷积神经网络是一种强大的神经网络架构，广泛应用于处理具有局部结构的数据，尤其在图像处理和其他领域中发挥重要作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd1bd103bf4d422fd28ce5dd992a8906/" rel="bookmark">
			前端面试题型汇总（适合社招两-三年水平）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【本文内容适合做过项目，有实操经验的社招同学，如果需要了解基础面经知识的同学，可以参考我之前写的文章：前端面试题型汇总（适合应届/社招1年水平）】
随着社区流行技术的更新迭代以及工作经验的增加，对于前端开发，我有了新的理解。
接下来总结工作中常见的问题以及面试中实际遇到的问题，整理出面经汇总。
目录
原生JS
ajax，fetch 和 axios
手撕代码题
React
关于fiber结构
React Hooks原理
React Router (V6)
状态管理库
React 与 Vue 的区别
React和Vue2.x、3.x Diff算法的区别
手写常用Hooks
Vue
vue3与react hooks对比
vue的keep-alive原理
网络协议
关于http协议
CDN原理
CDN回源与文件预热
浏览器
各控制面板操作
前端异常监控
打包工具
Webpack
Webpack的构建流程
Webpack Loader
Webpack Plugin
Webpack 热更新
Webpack Proxy 请求代理
Webpack 配置性能优化
Module Federation
Vite
微前端
微前端 - iframe方案
微前端 - qiankun 方案
微前端 - YY EMP方案
微前端 - 各种方案对比
其他
前端模块化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd1bd103bf4d422fd28ce5dd992a8906/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be9aef331243cd1a6743fe2b858e982b/" rel="bookmark">
			新版 Chrome 的下载通知切回以前的底部通知方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://zhuanlan.zhihu.com/p/665334436
八月初，Google改变了Chrome显示下载通知的方式。不再像以前那样，在屏幕底部的一个长条中显示大的矩形按钮。
现在Chrome下载通知的方式稍微有些低调地隐藏在右上角，一个小小的图标显示了你的下载进度和完成状态，点击后还可以看到最近的下载列表。
但如果你觉得这个更新让你不太适应（反正小妹是非常非常讨厌这个更新），你可以把它改回来。
Chrome 119.0.6045.106 之前的版本设置方式
对于 Chrome 119.0.6045.106 以前的版本，可以在 Chrome 的秘密设置中直接更改，也就是"标志"。
这些是实验性的设置，让用户可以微调Chrome的相关功能。通常情况下，除非有需要，否则请不要轻易修改这些设置。
在地址栏中输入以下代码并按下回车键：
chrome://flags/#download-bubble 这段代码会直接跳转到"Enable download bubble"设置项，这个设置会影响 Chrome 中下载通知的显示方式。
将后面的设置更改为“Enabled”，然后重新启动 Chrome。重启之后，Chrome 应该像更新之前一样运行，下载状态显示在屏幕底部的通知栏中。
Chrome 119.0.6045.106 及以后版本设置方式
但是如果 Chrome 已经更新到 Chrome 119.0.6045.106 或更新版本，上述的设置方式就无效了。
这是因为 Chrome 升级到 Chrome 119.0.6045.106 版本之后，直接将这个设置移除了，并且下载直接采用新的通知方式（即下载通知移到了右上角）。
要在 Chrome 119.0.6045.106 版本中将下载通知移回底部，首先要在桌面创建 Chrome 的快捷方式，右键点击 Chrome 快捷方式的图标，然后选择“属性”，然后点击顶部的“快捷方式”选项卡。
接着，在“目标”后面的输入框里，直接在目标栏最后添加以下代码-disable-features=DownloadBubble，如果 Chrome 不是安装在 C 盘，请自行修改安装路径。
注意: 有的文章里disable-features前面是用两个-，我这边测试的情况是一个-才生效，可以根据自己的环境试试哪个生效用哪个。
"C:\Program Files\Google\Chrome\Application\chrome.exe" -disable-features=DownloadBubble 然后，重新启动Chrome，就可以继续使用老式的下载方式啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d58d4ea7e8272168c74873cf92c8e97/" rel="bookmark">
			微信小程序查看接口信息(抓包)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅供交流学习使用
主要参考:
https://cloud.tencent.com/developer/article/1833591
https://www.cnblogs.com/x1you/p/12033839.html
由于参考文章在baidu权重不高(google才查到的), 所以自己重新记录一篇, 方便他人, 也防止参考文章丢失.
背景 需要知道微信小程序的接口地址
工具 下载charles,一键安装即可
https://www.charlesproxy.com/latest-release/download.do
破解(暂时不影响使用, 可空了再处理):
https://www.zzzmode.com/mytools/charles/
配置工具 配置代理
配置ssl
安装证书
信任证书
钥匙串访问, 搜char, 会发现证书没被信任, 双击证书,点击信任
抓包 正常登录pc版微信, 搜小程序, 接口都会显示在charles面板上. 可以先清空, 再访问小程序. 这样干净点. 双击具体的接口进去, 可以看到接口的详细信息, 包括地址、请求头、 参数、返回等. 自行摸索.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80d6dda9cd5a0a91083327aa7f4e5f1a/" rel="bookmark">
			【Vue】使用cmd命令创建vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇： node的安装与配置
https://blog.csdn.net/m0_67930426/article/details/134562278?spm=1001.2014.3001.5502
目录
一.创建空文件夹专门存放vue项目
二. 查看node , npm 和vue脚手架的版本
三.安装vue脚手架
四.创建vue项目
五.运行项目
一.创建空文件夹专门存放vue项目 这一步骤不是必须的，主要是将创建好的项目放在一起，便于查找
例如我在D盘创建了一个文件夹并命名Vue ( 文件夹命名随意）
二. 查看node , npm 和vue脚手架的版本 打开cmd ,最好是以管理员的身份打开cmd
查看node , npm 和vue脚手架的版本
确保这三者都有版本号输出，
输入node -v 或者 npm -v 出现不是内部命令或者外部命令一般是没安装node或者node没有
配置环境变量
输入 vue -Vue出现不是内部命令也不是外部命令，那就是没安装vue脚手架
三.安装vue脚手架 vue脚手架安装：
npm install -g @vue/cli
等待安装
四.创建vue项目 首先切换到创建好的空文件夹目录下
如果文件夹存放在D盘，在cmd输入D： 先进入D盘
我的文件夹是放在D盘中，名为Vue
然后再切换到Vue文件夹的目录下
然后再使用vue命令创建项目
格式： vue create 项目名
第一项和第二项是默认方式创建vue项目 第三项是手动创建项目 可以根据键盘的上下键进行选择，我选择第三项手动创建
点击回车
然后进入这一个选择步骤，使用键盘的上下键进行上下移动，空格键表示选中
然后点击回车
选择vue框架，如果你做的项目是2点几的就选择2点几，三点几就选择三点几
这里我选择了2.x 并回车
这一步是让你选择是否安装历史的路由，看自己的需求吧
我这里没啥需求，所以输入了 y，并回车
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80d6dda9cd5a0a91083327aa7f4e5f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dbf8087b1fd43131160f4f40bc8f834/" rel="bookmark">
			codeforces C. Theofanis‘ Nightmare
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意：大概把数组拆分成每个子数组，子数组如果有1-n个，求i*（子数组之和）。
思路：大概想到了应该尽量让最右边的正数拆分成单独一个，因为这样乘积会取最大。而且可以靠后缀和的方式来算子数组拆分之后的和。
但是想到了一个问题，如果出现1 1 1 -10000 -1 -1 1 1 这种情况怎么办，看了一下别的大佬的题解，大概理解了一下，就是把后缀和为负的数组塞在最左边，除非遇到了个比他更大的正数，就把他合并。
import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.*; public class Main { static Scanner cin=new Scanner(System.in); public static void main(String[] args) throws IOException { int t = cin.nextInt(); while (t-- != 0) solve(); } private static void solve() throws IOException { int n=cin.nextInt(); int[] a=new int[n]; for (int i = 0; i &lt; n; i++) { a[i]= cin.nextInt(); } Long sum=0L; Long ans=0L; for (int i=n-1;i&gt;=0;i--) { sum+=a[i]; if(sum&gt;0||i==0)ans+=sum; } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dbf8087b1fd43131160f4f40bc8f834/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a5c534d03a8f029170513c0575e65fe/" rel="bookmark">
			java List去重，根据多个字段属性去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 如果我有一个A类，里面有5个字段，对于数组List&lt;A&gt; list，我想根据其中的2个字段来去重，如果2个字段都是一样的，只取最新的一条数据即可。
实现思路： 如果你有一个A类，并且想根据其中的两个字段进行去重，只保留最新的一条数据，那么你可以不定义一个新的类PersonId。在这种情况下，你可以使用Java中的Map来达到去重的效果。
你可以将A类中的两个字段作为键（key），将A类的对象作为值（value）。然后，遍历你的数据列表，将每个对象添加到Map中。如果Map中已经存在相同的键，则将原来的值替换为当前对象（假设最新的数据具有更高的优先级）。最后，你只需要从Map中获取值，就可以得到根据这两个字段去重后的最新数据。
示例代码： import java.util.*; class A { private String field1; private String field2; // 其他字段... // 构造函数、getter和setter... } public class Main { public static void main(String[] args) { List&lt;A&gt; dataList = ... // 你的数据列表 Map&lt;String, A&gt; map = new HashMap&lt;&gt;(); for (A obj : dataList) { String key = obj.getField1() + "," + obj.getField2(); // 根据两个字段生成键 if (!map.containsKey(key)) { map.put(key, obj); } else { // 更新旧的数据（假设最新的数据具有更高的优先级） map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a5c534d03a8f029170513c0575e65fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c35713ef451117981d49c3c3ab87b932/" rel="bookmark">
			打包后移除console.log日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打包后移除console.log日志,把项目里所有的的console.log打印移除，这样上线后减少数据风险
"production":{ "plugins": ["transform-remove-console"] } { "presets": [ ["env", { "modules": false }], "stage-2" ], "ignore": [ "./src/lib/by-form-editor.umd.js" ], "plugins": ["transform-runtime", "transform-vue-jsx",["component", [ { "libraryName": "element-ui" } ]]], "env": { "test": { "presets": ["env", "stage-2"], "plugins": ["transform-es2015-modules-commonjs", "dynamic-import-node"] }, "production":{ "plugins": ["transform-remove-console"] } } } package.json 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0818b167fc24597740116e407cce92f/" rel="bookmark">
			CSS结构伪类选择器之否定伪类:not()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构伪类选择器是针对 HTML 层级结构的伪类选择器。
常用的结构化伪类选择器有：
:root选择器、:not选择器、:only-child选择器、:first-child选择器、:last-child选择器、
:nth-child选择器、:nth-child(n)选择器、:nth-last-child(n)选择器、:nth-of-type(n)选择器、
:empty选择器、:target选择器。
这些基本上都很常用，今天着重说下：否定伪类:not()
否定伪类特别有用，在css中, :not选择器 用于匹配非指定元素/选择器的每个元素,语法格式：
:not(selector) 比如：假设我想选择所有 div，除了 id 为 的那个 container。下面代码：
div:not(#container) { color: blue; } 否定伪类:not()的几个特点： :not()的优先级是 0，因为它的优先级是由括号里面的参数来定的；:not()伪类可以同时判断多个选择器，比如input:not(:disabled):not(:read-only)
{}，表示匹配不属于禁用状态同时也不处于只读状态的 input 元素；not()支持多个表达式，比如：.cs-li:not(li, dd)
{}，还有另外一种写法：.cs-li:not(li):not(dd) {}。但是这两种写法，要考虑兼容性问题；:not()也支持选择符，比如：input:not(.a &gt; .b) { border: red solid; }; 今天遇到一个问题，想把首页除了logo之外的其他元素变黑白，但是用否定伪类却出现很奇怪的问题，其他有部分元素还是彩色的，代码如下：
.home div:not(.logo) { -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: grayscale(100%); filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); _filter:none; filter: gray; } 然后改为：效果一样
.home div:not(.header &gt; .logo) { -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: grayscale(100%); filter:progid:DXImageTransform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0818b167fc24597740116e407cce92f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffe0b5c6a0740ffff39dca89578e988b/" rel="bookmark">
			【运筹优化】运筹学导论：求解线性规划问题 - 单纯形法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、单纯形法的实质（几何原理）1.1 示例的求解1.2 关键的解原理1.2.1 解原理11.2.2 解原理21.2.3 解原理31.2.4 解原理41.2.5 解原理51.2.6 解原理6 二、构建单纯形法（代数原理）三、单纯形法的代数形式3.1 初始化3.2 最优性检验3.3 确定移动的方向（迭代的步骤1）3.4 确定在何处停下（迭代的步骤2）3.5 求解新的BF解（迭代的步骤3）3.6 新BF解的最优性检验3.7 第2次迭代和最优解结果 四、单纯形法的表格形式4.1 单纯形法的总结（以迭代1为例）4.1.1 初始化4.1.2 最优性检验4.1.3 迭代4.1.4 第二次迭代与最优解 五、单纯形法的突破5.1 入基变量的相持5.2 出基变量的相持（退化）5.3 无出基变量（Z无界）5.4 多个最优解 六、改造适用于其他模型形式6.1 等式约束6.2 负的右端项6.3 大于等于形式的约束条件6.4 最小化6.5 求解放射治疗的例子6.6 两阶段法6.7 无可行解6.8 允许为负的变量6.8.1 允许为负的有界变量6.8.2 允许为负的无界变量 七、优化后分析7.1 再优化7.2 影子价格7.3 灵敏度分析7.4 参数线性规划 在阅读本博客前，请了解线性规划相关的知识：【运筹优化】运筹学导论：线性规划导论
单纯形法是求解线性规划问题的基本方法，它是由 George Dantzig 于 1947 年提出的。单纯形法已经被证明是真正有效的方法，如今通常用于在计算机上解决大型问题。
本博客介绍单纯形法的主要内容，介绍它的一般原理、几何解释以及如何用它求解任意标准形式的线性规划问题。
一、单纯形法的实质（几何原理） 单纯形法是一个代数计算过程，它本质上是基于几何原理。为了说明单纯形法的一般几何原理，将以 【运筹优化】运筹学导论：线性规划导论 中提到的 Wyndor Glass 公司问题为例。
该例子的模型和图形如下图所示。其中，每个约束边界是一条直线，约束边界的交点是这个问题的角点解（corner-point solution），在可行域上的角点解被称为角点可行解（CPF solution）
定理：对于一个有 n 个决策变量的线性规划问题来说，每个角点解位于 n 条约束边界的交点处（在 Wyndor Glass 公司的例子中，仅有 2 个决策变量，因此，每个角点解位于 2 个约束边界线的交点处）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffe0b5c6a0740ffff39dca89578e988b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c116332d830e8df77a73c0b082f974/" rel="bookmark">
			Ubuntu系统使用快速入门实践（七）——软件安装与使用（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu系统使用快速入门实践系列文章 下面是Ubuntu系统使用系列文章的总链接，本人发表这个系列的文章链接均收录于此
Ubuntu系统使用快速入门实践系列文章总链接 下面是专栏地址：
Ubuntu系统使用快速入门实践系列文章专栏 文章目录 Ubuntu系统使用快速入门实践系列文章Ubuntu系统使用快速入门实践系列文章总链接Ubuntu系统使用快速入门实践系列文章专栏 前言Ubuntu系统使用快速入门实践（七）——软件安装与使用显示网速cpu占用和内存占用率VSCodeVSCode安装与卸载VSCode使用VSCode 界面功能介绍常用快捷键VSCode 常用插件VSCode用户设置一、一般设置二、配置C/C++环境 前言 Ubuntu是一个以桌面应用为主的Linux发行版操作系统，也是大多数人第一个接触到的Linux系统，尤其是从事理工科研究工作的人，这个系列的文章主要讲述如何使用Ubuntu系统，完成日常的学习、科研以及工作
Ubuntu系统使用快速入门实践（七）——软件安装与使用 显示网速cpu占用和内存占用率 参考：ubuntu实时显示网速cpu占用和内存占用率
（1）添加indicator-sysmonitor的下载源，右键打开终端，复制后在终端按shift+ctrl+V粘贴下面的命令
sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor （2）更新apt-get
sudo apt-get update （3）安装indicator-sysmonitor
sudo apt-get install indicator-sysmonitor （4）启动
indicator-sysmonitor &amp; 这个时候通知栏就会出现cpu占用率和内存占用率，然后现在我们来设置显示网速与开机自启，注意，现在不要关闭终端，一关上面的显示就没了。
点击显示的文字，选择preferences
勾选开机自启
然后切换到advanced，修改编辑框为这样，在文字后面加入net{net} gpu{gpu}，
其中gpu显示需要先安装显卡驱动，详情见Ubuntu系统使用快速入门实践（六）——Ubuntu深度学习环境配置（1） 中安装英伟达驱动一节
点击Test，然后网速就出来了。
然后关闭终端，它会不见了，但是下次开机，它就会一直显示了。但是记住要点保存。
VSCode VSCode安装与卸载 ubuntu安装vscode的两种方法
安装方法
方法一：
依次输入如下命令
sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make sudo apt-get update sudo apt-get install ubuntu-make umake ide visual-studio-code 提示输入a即可
方法二：
进入VSCode官网下载：https://code.visualstudio.com/Download
下载.deb格式的安装包到本地，
安装：dpkg -i 安装包
cd 到存储deb包的文件夹下
sudo dpkg -i code_1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91c116332d830e8df77a73c0b082f974/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c2f8e52e113e9c37280b740d7f182c/" rel="bookmark">
			力扣209题 长度最小的子数组 双指针算法(滑动窗口)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是滑动窗口?
同向双指针
什么时候用滑动窗口?
利用带调性, 两个指针都不用回退的时候
怎么用?
初始化 left = 0; right= 0;进窗口判断是否出窗口 滑动窗口的正确性
利用单调性规避了很多没有必要的枚举行为
209. 长度最小的子数组 给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度**。**如果不存在符合条件的子数组，返回 0 。
示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：
输入：target = 4, nums = [1,4,4]
输出：1
示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
算法思路
解法一: 暴力
最初看到这个题的时候, 很多人都会第一时间想到暴力枚举, 「从前往后」枚举数组中的任意⼀个元素，把它当成起始位置。然后从这个「起始位置」开始，然后寻找⼀段最短的区间，使得这段区间的和「⼤于等于」⽬标值。将所有元素作为起始位置所得的结果中，找到「最⼩值」即可。显而易见, 这是超时的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92c2f8e52e113e9c37280b740d7f182c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac50463ba84eabef9a1e556d8333a450/" rel="bookmark">
			vue-cli3，vue2&#43;elementui实现用户自定义主题色，切换主题，（2023-02-10增加功能：后台可配置主题色以及功能色）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义主题色包含以下两种，并且这两种的主题色需要同步
element-ui的主题色程序员自己写的样式中的主题色 我参考
一篇博客：vue,elementUI切换主题，自定义主题 - 小兔额乖乖 - 博客园一个开源框架：腾讯的tDesign搭建的开源框架——TDesign Vue Next Starter 输出了此篇文章
说明1：小兔额乖乖文章中的项目示例，在修改主题色后，刷新一下，鼠标hover时会有问题，此问题在本篇文章中已经解决
说明2：我曾经尝试完全模仿腾讯那个框架的思路。但是此思路不适用于element-ui这个框架，会报错
说明3：下面的正文中，项目中修改主题色时，会运行 document.head.appendChild(style) ，修改一次颜色就会添加一个stylesheet，有兴趣的同学可以优化一下，改成替换掉上一次的style。
以下是正文
---------------------------------------------------------------------------------------------------------------------------------
1、创建一个vue项目 ① vue-cli3创建项目 vue create vue-custom-theme ② 安装element-ui相关
安装elementUI
npm i element-ui -S 安装sass npm install node-sass@4.11.0 sass-loader@7.1.0 -D 启动项目
npm run serve 2、引入element-ui ①在main,js中
import ElementUI from 'element-ui' import './styles.scss' Vue.use(ElementUI) ②给一个默认的主题色【此步骤可省略，不需要。因为可以在Theme.vue中直接从后台获取默认主题（this.$store.state.sysConfig.theme）。this.$store.state.sysConfig.theme是在后台获取的，存储在了vuex里面，获取时机是全局路由拦截，在进入页面之前获取的】
用户先从线上拉去配置主题的css文件，当用户更改颜色后，在把css文件里面所有的颜色值替换掉，然后把这个css文件重新插入到html中达到改变颜色。
在这里都需要修改再方法1的基础上进行扩展：在element-variables.scss（大部分项目都是）添加 默认我们自己设置的颜色。
当然这个颜色也可以在其他公共css修改。我是在style.scss中修改的，如下
style.scss
/* theme color */ $--color-primary: #ff6f4b; /* icon font path, required */ $--font-path: '~element-ui/lib/theme-chalk/fonts'; @import "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac50463ba84eabef9a1e556d8333a450/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f10b5eebddbfa9a276600426c930ba19/" rel="bookmark">
			Windows 操作系统获取 JCEF 相关 jar 包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JCEF一、前言二、相关链接三、准备工作1. Building from Source（从源代码处构建）I. For all platforms this includes:（以下信息适用于所有平台，包括：）II. For Linux platforms:（对于 Linux 平台：）III. For Mac OS X platforms:（对于 Mac OS X 平台：）IV. For Windows platforms:（对于 Windos 平台：） 2. 下载 CMake3. 下载 Git4. 下载 jdk5. 下载 Python6. 下载 Visual Studio 三、正式搞起I. Download JCEF source code using Git.（使用 Git 下载 JCEF 源代码）II. Building（构建）1. Run CMake（运行 CMake）2. 用 VS 2022 生成解决方案3. build the JCEF Java classes（构建 JCEF 的 Java 的 class 文件）4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f10b5eebddbfa9a276600426c930ba19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b8b5e7476824057b99e27993f195b6/" rel="bookmark">
			使用Prometheus监控Padavan路由器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prometheus监控Padavan路由器 1、背景 近期在Synology（群辉）中安装一套Prometheus监控程序，目前已经监控Synology，然后家中有有路由器（Padavan）型号，也准备使用Prometheus+Grafan进行监控。
‍
环境：
Prometheus：2.48.0
Grafan：10
Padavan：固件版本:3.4.3.9-099_22-05-1
​​
2、监控步骤 ‍
1、padavan_exporter 正确使用 地址：https://github.com/Bpazy/padavan_exporter/blob/master/README-zh_CN.md
padavan_exporter有两种方式（不是放到Padavan系统上的）
安装到Linux操作系统，通过ssh连接到路由器进行数据获取安装到Docker上，通过ssh连接到路由器进行数据获取 Linux操作系统 在Linux操作系统下载padavan_exporter
参数使用
$ ./padavan_exporter --help Flags: --help Show context-sensitive help (also try --help-long and --help-man). --web.listen-address=":9100" Address on which to expose metrics and web interface --padavan.ssh.host="127.0.0.1:22" Padavan ssh host --padavan.ssh.username="admin" Padavan ssh username --padavan.ssh.password="admin" Padavan ssh password --debug Debug mode 安装 padavan_exporter 并使用正确的参数启动（点击跳转项目首页）
wget https://github.com/Bpazy/padavan_exporter/releases/download/v0.0.2/padavan_exporter-linux-amd64-v0.0.2 sudo mv ./padavan_exporter-linux-amd64-v0.0.2 /usr/local/bin/padavan_exporter sudo chmod u=rwx,o=rx,g=rx /usr/local/bin/padavan_exporter sudo chgrp root /usr/local/bin/padavan_exporter sudo chown root /usr/local/bin/padavan_exporter # 自定义 systemd service sudo touch /lib/systemd/system/padavan_exporter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27b8b5e7476824057b99e27993f195b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/393aa7e76c569da64f77c290cbb0c35c/" rel="bookmark">
			HBase整合Phoenix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介1、Phoenix定义2、Phoenix架构 二、安装Phoenix1、安装 三、Phoenix操作1、Phoenix 数据映射2、Phoenix Shell操作3、Phoenix JDBC操作3.1 胖客户端3.2 瘦客户端 四、Phoenix二级索引1、为什么需要二级索引2、全局索引（global index）3、包含索引（covered index)4、本地索引（local index） 一、简介 1、Phoenix定义 1）官网地址：http://phoenix.apache.org/
Phoenix是HBase的开源SQL皮肤。可以使用标准JDBC API代替HBase客户端API来创建表，插入数据和查询HBase数据。
优点：使用简单，直接能写sql。
缺点：效率没有自己设计rowKey再使用API高，性能较差。
2、Phoenix架构 二、安装Phoenix 1、安装 将安装包上传到服务器目录
解压安装包
tar -zxvf apache-phoenix-5.0.0-HBase-2.0-bin.tar.gz -C /opt/module/ mv /opt/module/apache-phoenix-5.0.0-HBase-2.0-bin /opt/module/phoenix 复制server包并拷贝到各个节点Hadoop101、Hadoop102、Hadoop103的hbase/lib
cp /opt/module/phoenix/phoenix-5.0.0-HBase-2.0-server.jar /opt/module/hbase/lib/ xsync /opt/module/hbase/lib/phoenix-5.0.0-HBase-2.0-server.jar 配置环境变量
vim /etc/profile.d/my_env.sh 添加内容
#phoenix export PHOENIX_HOME=/opt/module/phoenix export PHOENIX_CLASSPATH=$PHOENIX_HOME export PATH=$PATH:$PHOENIX_HOME/bin 在hbase-site.xml中添加支持二级索引的参数(如果不需要创建二级索引，不用不加)。之后分发到所有regionserver的节点上。
vim /opt/module/hbase/conf/hbase-site.xml xsync /opt/module/hbase/conf/hbase-site.xml 配置内容
&lt;property&gt; &lt;name&gt;hbase.regionserver.wal.codec&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hbase.regionserver.wal.IndexedWALEditCodec&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.region.server.rpc.scheduler.factory.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hbase.ipc.PhoenixRpcSchedulerFactory&lt;/value&gt; &lt;description&gt;Factory to create the Phoenix RPC Scheduler that uses separate queues for index and metadata updates&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/393aa7e76c569da64f77c290cbb0c35c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8592e732341ed7c6b6f6454b2b7f26c/" rel="bookmark">
			使用LaTaX制作试卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Typesetting exams LaTeX 原 文：Pgfplots package
译 者：Xovee
翻译时间：2023年12月2日
文章目录 Typesetting exams LaTeX介绍基础创建新问题子问题（subparts） 多选题记分（grading）每道题的得分算分和一半分（counting points and half points）奖励分得分表 Overleaf `exam` 项目示例其它语言 参考指南调整题目记号的位置和样式改变得分表中的默认文字 延伸阅读 介绍 我们可以使用LaTeX内置的exam.cls来轻松制作试题。你还可以使用它来显示和计算成绩。我们首先将文档格式设置为exam：
\documentclass{exam} 然后我们就可以使用一些制作试卷的特殊命令，并且页边距也会加大（来让老师们有空间改卷）。
基础 让我们来看一个简单的例子：
\documentclass{exam} \begin{document} \begin{center} \fbox{\fbox{\parbox{5.5in}{\centering Answer the questions in the spaces provided. If you run out of room for an answer, continue on the back of the page.}}} \end{center} \vspace{5mm} \makebox[0.75\textwidth]{Name and section:\enspace\hrulefill} \vspace{5mm} \makebox[0.75\textwidth]{Instructor’s name:\enspace\hrulefill} \begin{questions} \question Is it true that \(x^n + y^n = z^n\) if \(x,y,z\) and \(n\) are positive integers?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8592e732341ed7c6b6f6454b2b7f26c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/32/">«</a>
	<span class="pagination__item pagination__item--current">33/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/34/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>