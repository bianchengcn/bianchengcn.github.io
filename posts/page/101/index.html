<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f5860f5c0e02998c47fd5b305a0f83/" rel="bookmark">
			java 面向对象编程——继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第五章、继承
一、继承
1.继承的格式
2.继承中的构造方法
3.父类的引用指向子类对象
4.总结
二、重写
1.方法的重写
2.重写时的super
3.重写与重载的区别
4.练习
第五章、继承 一、继承 通过extends关键字可以实现继承子类可以通过继承获取父类的属性和方法，也可以定义自己独有的属性和方法。继承单一性: 一个子类只能有一个父类(1个儿子只能有一个爸爸)，但一个父类可以有多个子类。继承： 子类继承父类---&gt;代码的复用性 1.主要作用： 子类可以通过继承获取父类的属性和方法
2.特性：单一继承性，一个子类只能有一个父类
1.继承的格式 格式： class Son extents Father extends:关键字 /** * 子类 * @author JeffLee * */ public class SubClass extends SuperClass{ ​ public static void main(String[] args) { ​ new SubClass().SuperInfo(); //子类对象调用了子类中继承的SuperInfo方法。 } } //父类 class SuperClass { String name; int age; public void SuperInfo() { System.out.println("SuperInfo...."); } } ​ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8f5860f5c0e02998c47fd5b305a0f83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ba9a3eaa0b98784f820eb8256f8c4ae/" rel="bookmark">
			WPS 字符串拼接详解（concat、concatenate）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 概述2 示例2.1 单元格拼接单元格2.2 拼接时含自定义字符 3 区别3.1 concat 支持多区域拼接3.2 concatenate 不支持多区域拼接 1 概述 字符串拼接 concat：将多个区域或字符串中的文本组合起来 concatenate：将多个文本合并成一个文本字符串 总的来说：两者语法一样，但 concat 的使用范围 &gt;= concatenate
1.若仅拼接列，效果一样，如：concat(A1, B1) = concatenate(A1, B1)
2.若拼接多个区域，仅支持 concat，如：concat(A1:A2, B1:B2) 成功，concatenate 则失败
2 示例 测试 Excel 样例：
姓名性别年龄张三女18李四男19王五女20 2.1 单元格拼接单元格 -- 语法： =conncat(字符串1, 字符串2, ..., 字符串n) 步骤1：在 fx 处，输入函数 = concat()
步骤2：列选择完成后，按 Enter，拼接完成（如：姓名性别年龄）
步骤3：鼠标放置右下角，出现 “十” 后向下拉，即可完成其它列的拼接
提示：若数据行很多，拉取不方便，可用 向下填充 Ctrl+D，效果一样
2.2 拼接时含自定义字符 使用 双引号 即可，如：“自定义字符” 3 区别 3.1 concat 支持多区域拼接 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ba9a3eaa0b98784f820eb8256f8c4ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c57a830b28e49c7c3ffa5628ab9f40fd/" rel="bookmark">
			IDEA卸载和删除注册表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在用idea的时候，idea的环境出现了莫名其妙的问题，怎么也找不到问题原因的时候可以试着把idea卸载重新安装。但是如果你卸载的时候没有删除干净注册表里的信息。就算再次安装回来也还是解决不了问题。
如何删除干净IDEA 1.卸载程序
打开控制面板，选中idea点击卸载。如果没有uninstall.exe，就先直接删除idea解压包。
2.删除注册表
windows + R 输入regedit进入注册表，右键一级菜单HKEY_CURRENT_USER， 右键查找，输入idea，会找到jetbrains，然后，右键删除jetbrains整个文件夹。
3.删除掉后还有一些残留垃圾需要删除
C:\user\${用户名称}\ideaProjects\
C:\Users\${用户名称}\AppData\Roaming\JetBrains
C:\Users\${用户名称}\AppData\Local\JetBrains
C:\Program Files\JetBrains
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\JetBrains\
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9ab6255a5c21cacd179a5ac84d9eab2/" rel="bookmark">
			Android MediaPlayer IllegalStateException源码分析定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.源码分析，定位报错点 最近发现Bugly上存在一个长期的bug：
java.lang.IllegalStateException： android.media.MediaPlayer._start(Native Method) android.media.MediaPlayer.startImpl(MediaPlayer.java:1373) android.media.MediaPlayer.start(MediaPlayer.java:1345) org.appplay.lib.SoundPlayer$1.onPrepared(SoundPlayer.java:46) android.media.MediaPlayer$EventHandler.handleMessage(MediaPlayer.java:3453) android.os.Handler.dispatchMessage(Handler.java:106) android.os.Looper.loop(Looper.java:224) android.app.ActivityThread.main(ActivityThread.java:7087) java.lang.reflect.Method.invoke(Native Method) com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:604) com.android.internal.os.ZygoteInit.main(ZygoteInit.java:928) 从上面的报错看，只能根据源码走向，推断报错点了。
从MediaPlayer#startImpl()方法开始追踪：
frameworks/base/media/java/android/media/MediaPlayer.java：
private void startImpl() { //... _start();// 通过jni 调用native 层的开始方法 } 接下来找到java 中_start（） 对应的native层方法 ，media 对应的jni 类一般都是放在frameworks/base/media/jni中。
frameworks/base/media/jni/android_media_MediaPlayer.cpp：
static const JNINativeMethod gMethods[] = { {"_start", "()V", (void *)android_media_MediaPlayer_start} } 在该类中全局检索_start , 找对对应的jni 方法android_media_MediaPlayer_start()。
接下来看下该方法：
static void android_media_MediaPlayer_start(JNIEnv *env, jobject thiz) { ALOGV("start"); sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz); if (mp == NULL ) { //关键点：mp 为空,则抛出异常 jniThrowException(env, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9ab6255a5c21cacd179a5ac84d9eab2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911af581de49969bfba3e1062a7e165b/" rel="bookmark">
			Centos7 防火墙配置详解（非常详细！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7 防火墙配置详解（非常详细） 一. zone的概念1.1 预定义的zone1.2 将interface和source划分到某个zone1.3 zone配置文件 二. Service的概念2.1 service配置文件2.2 service相关的指令 三. ipset的概念四. direct.xml Centos7中使用firewalld来作为防火墙，其底层调用的命令仍然是iptables等命令，但是在配置上发生了较大的变化。 Centos7中有两个位置存放了firewall的配置文件，一个是/etc/firewalld，一个是/usr/lib/firewalld，前者是用户配置目录，后者是系统配置目录。/usr/lib/firewalld目录中存放的是firewalld提供的一些默认和备份的配置文件，一般不随意改变，/etc/firewalld目录下才是用户配置的真正生效的配置文件，只有在/etc/firewalld目录不存在或该目录下不存在配置文件的情况下/usr/lib/firewalld目录下的配置文件才会生效。
一. zone的概念 zone定义了防火墙对某个连接、网口（interface）或源地址的信任等级，我们可以把他理解为防火墙对不同的连接（connection）、网口（interface）或源地址（source address）划分到不同的zone当中，而不同的zone定义了不同的规则，因此防火墙可以针对不同的连接、网口（interface）或源地址做出不同的行为。例如，我们将10.12.18.201这个地址划分到zone1中，将10.12.18.202这个地址划分到zone2中，然后zone1中定义的规则为：允许访问3306端口，其余的端口都拒绝访问；zone2中定义的规则为：拒绝访问3306端口，其余的端口都允许访问。那么10.12.18.201就仅能访问本机的3306端口，10.12.18.202就仅不能访问本机的3306端口。每个zone的防火墙规则是通过/etc/firewalld/zones目录下的xml配置文件来配置的。
zone和connection、interface、source address之间是一对多的关系，即一个connection、interface或source address仅能划分到一个zone中，而一个zone中可以包含多个connection、interface或source address。
1.1 预定义的zone Centos7中firewalld为用户预定义了9个zone，分别为drop，block，public，external，dmz，work，home，internal，trusted。这9个zone的配置文件在/usr/lib/firewalld/zones目录下，通过查看他们的配置文件可以得知这9个zone的规则是怎么样的。
drop：任何传入本机的网络数据包都会被丢弃，并且不会回复，只允许本机对外访问其他服务器。
block：任何传入本机的网络连接请求都会被拒绝，并且会回复一条拒绝访问的消息。
public：用于本机处于公共网络环境的场景下，仅接受特定的连接请求，如仅接受某些特定的IP的连接请求，或仅对外部开放特定的某些端口。Centos 7 默认的public.xml文件中仅开放用于ssh连接请求的22端口和dhcpv6-client服务的546端口。
external：与public类似，Centos 7 默认仅开放用于ssh连接请求的22端口。
dmz：与external一样，Centos 7 默认也是仅开放用于ssh连接请求的22端口。
work：用于工作网络环境场景下，信任大部分的其他的计算机不会对本机进行攻击。Centos 7 默认开放用于ssh连接请求的22端口，dhcpv6-client服务的546端口，以及IPP协议的631端口。
home：用于家庭网络环境，信任网络上的其他计算机不会攻击本机。Centos 7默认开放用于ssh连接请求的22端口，dhcpv6-client服务的546端口，IPP协议的631端口，samba服务的137、138端口，mDNS服务的5353端口。
internal：与home一样，Centos 7默认开放用于ssh连接请求的22端口，dhcpv6-client服务的546端口，IPP协议的631端口，samba服务的137、138端口，mDNS服务的5353端口。
trusted：所有对本机的网络连接请求都会被接受。
1.2 将interface和source划分到某个zone 将某个source划分到某个zone的命令如下：
firewall-cmd [--permanent] [--zone=zone] --add-source=source 例如：
firewall-cmd --permanent --zone=trusted --add-source=192.168.5.112 这条命令会将192.168.5.112这个网口划分到trusted这个zone，–permanent参数会将该配置写入trusted这个zone的配置文件trusted.xml中，使其永久生效，如果不加–permanent，则只会临时生效，重启防火墙或者调用firewall-cmd --reload重新加载配置文件会使得该项配置失效。
将某个网口（interface）划分到某个zone的命令如下：
firewall-cmd [--permanent] [--zone=zone] --add-interface=interface 例如
firewall-cmd --permanent --zone=block --add-interface=ens33 这条命令会将ens33这个网口划分到block这个zone，这样其他机器访问本机的ens33网口时就会默认走这个zone。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911af581de49969bfba3e1062a7e165b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51194719ca62e7d4c78ba341affb32b/" rel="bookmark">
			Idea创建Maven子项目时，加载完后pom.xml里没有parent标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先创建一个空的Maven项目做为父项目
2、然后创建一个Maven项目作为子项目
3、创建后刚开始有parent标签，加载完之后就没有了，所以只需要手动加上parent标签即可，将原本的artifactId和packageing标签移到parent标签外，然后在parent标签里面再创建一个artifactId标签，这两个标签的值不要搞错了。(详情看图) 4、可能的原因
原因就是webapp模板在maven项目创建完后，会自动部署自己的模板，包括pom.xml，web.xml，index.jsp等文件，就会把maven子项目默认生成的pom.xml（含有 正确的parent）给覆盖掉，你可以去看找到模板的jar包去看它的pom.xml和生成的一模一样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4042d1c2e0ac39c5fdc03070c92c2d3e/" rel="bookmark">
			华为、Cisco、H3C、中兴网络设备如何配置syslog日志采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为、Cisco、H3C、中兴网络设备如何配置syslog日志采集 《网络安全法》和公安部82号令要求网络日志留存180天，为了满足国家网络安全法要求，企业客户通常会配置日志审计系统将网络日志进行集中存储，那么日志审计系统是如何将华为、Cisco、H3C、中兴厂商的网络设备/安全设备的syslog日志采集到日志审计系统中的呢？下面我就介绍一下华为、Cisco、H3C、中兴厂商的网络设备如何配置syslog日志采集。
一、华为设备配置syslog日志采集 &lt;huawei&gt; system-view //进入系统视图
[huawei] info-center enable // 开启信息中心
[huawei] info-center loghost 192.168.1.2 channel loghost
// 指定向日志主机输出日志信息的通道为 loghost 通道
[huawei] info-center source default channel loghost debug state off log state off trap state off
//关闭所有模块（模块：各种信息，如ARP、pppoe、nat）日志主机的 trap、log、debug 的状态。 Log：日志信息 trap：告警信息 debug：调试信息
[huawei] info-center loghost 192.168.1.2 facility local6 language english
// 将 IP 地址为192.168.1.2的主机作为日志主机，设置信息级别为informational，输出语言为英文
[huawei] info-center source default channel loghost log level warning
[huawei] info-center source default channel loghost debug state on
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4042d1c2e0ac39c5fdc03070c92c2d3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b23f822abf9abd2fe63ded38be02f9/" rel="bookmark">
			关于C&#43;&#43;调用::CoCreateInstance创建对象提示没有注册类的问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于C++调用::CoCreateInstance创建对象提示没有注册类的问题的解决 最近做一个C++项目的时候，遇到一个棘手的问题，是关于COM组件的，我完全不会这个技术，因为我没接触过C++后端，所以关于这个COM组件我更是一脸懵逼，我试着把自己编写的代码加入到其中，测试看看结果，但是在我代码运行之前，我要使用的对象没有办法创建出来：
它报的是xxx.没有注册类，我调试代码把问题定位到了以下一段代码：
HRESULT hr; hr = m_Core.CoCreateInstance(CLSID_Core2); 于是我去了解了下这个方法，就是依靠具体的UUID去创建一个类，而这个类必须注册到我们系统的注册表中。
以下是很多种情况，可以对号入座试试：
解决方法： 看看提示到的dll文件有没有在系统文件夹中出现，没有的话就添加并注册 于是我先去看了看问题描述的combase.dll，这个类肯定是需要在系统文件夹里面要出现的，因为要提示说要用到它 ；我打开了C:\Windows\System32和C:\Windows\SysWOW64文件夹（我也不知道是用哪个，说64位系统看Systeam32文件夹，32位看SysWOW64文件夹），看有没有combase.dll，如果没有就找一个放进去，然后使用regsvr32命令注册一下试试。对于部分dll文件没有注册类，这类办法应该是有作用的；但是我这里这个dll文件完全注册不了，所以这种解决办法对我没有作用。
看看注册的类的UUID具体是啥，能否在系统注册表中找到 在程序种找到自己要创建类的UUID，对比UUID去查找注册表中的值，看是否有对应的值存在于注册表，如果没有的话，你得考虑这个类是自己设定的UUID值，还是其他程序主动写入注册表的，如果是你自己写入的话，你可以尝试将对应的类和UUID写入到注册表中（可以去百度一下），如果是程序写入的话，尝试卸载重装软件，以管理员身份运行安装，看看注册表中会不会出现对应的UUID。如果你发现UUID已经存在，并且还是出现没有注册类，那可能就是最后一种问题了。
看看自己的运行环境，将x64环境改为x86环境 我这里的问题就是系统盘存在对应的dll文件，注册表中也有相应的值，但是就是无法创建出对象，会提示没有注册类的错误，这时候将自己的调试环境转换到了x86之后，我发现CoCreateInstance创建对象就成功了。
这里我能想到的解决方案就只有以上几种，如果都不行，那只能自行去慢慢摸索了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad26edfa2110582f389ca9a4a1726076/" rel="bookmark">
			将两个有序链表合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将两个有序链表合并
思路：
1）设定两个指针，分别指向链表1的头和链表2的头;
2）创建新得链表头p;
3）如果p1的值&lt;p2的值，则p1的值为新链表的头节点值，即p=p1-&gt;value;
反之，则p2的值为新链表的头节点值，即p=p2-&gt;value;
4）对于剩下的链表用同样的方式进行比较，将较小的值拿去新链表并与上个数值链接起来。
5）可以采用递归实现，后面剩余节点的比较
6）特殊情况：当链表1为空时，新得合并链表为链表2；当链表2为空时，新得合并链表为链表1.
#include&lt;iostream&gt; using namespace std; struct Node { int value; Node* next; Node(int v) :value(v) {} }; //创建一个有序链表 Node* CreateList1() { Node *head; Node* n1 = new Node(1); Node* n3 = new Node(3); Node* n5 = new Node(5); Node* n7 = new Node(7); Node* n9 = new Node(9); head = n1; n1-&gt;next = n3; n3-&gt;next = n5; n5-&gt;next = n7; n7-&gt;next = n9; n9-&gt;next = NULL; return head; } Node* CreateList2() { Node* head; Node* n2 = new Node(2); Node* n4 = new Node(4); Node* n6 = new Node(6); Node* n8 = new Node(8); //Node* n10 = new Node(10); head = n2; n2-&gt;next = n4; n4-&gt;next = n6; n6-&gt;next = n8; n8-&gt;next = NULL; return head; } //释放链表空间 void FreeList(Node *head) { if (head == NULL) { return; } else { Node* temp = head-&gt;next; delete head; head = temp; FreeList(head); } } //递归的方式遍历链表中的元素 void BianList(Node* head) { if (head) { cout &lt;&lt; head-&gt;value &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad26edfa2110582f389ca9a4a1726076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be9aabe0abd3fb8b8a247112101be4c/" rel="bookmark">
			利用Sqlmap进行SQL注入攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql注入的核心：将用户的输入拼接到代码中，并被当作sql语句执行
POST注入高危点：
登录框
查询框
等各种和数据库有交互的框
信息收集 渗透测试的灵魂在于信息收集，首先打开要渗透的靶场。
首先利用御剑扫描了一下目标靶场的敏感目录信息时发现一堆200页面，然后访问根目录为/admin.html直接跳转到了靶场后台。
这就是该目标网站的后台管理系统
我们继续对该目标网站进行awvs主动式web扫描得到了一些有关sql注入漏洞的报告
我们已经确定了该目标网站存在sql注入，对网站后台登录框用burp抓一下包之后以post.txt文件保存，启动sqlmap把文件放里面跑一下
sqlmap -r post.txt --delay 1 --level 2 --batch Sqlmap跑出来结果是该目标网站存在报错注入，联合注入，盲注等
继续用Sqlmap跑出来该数据库名信息
sqlmap -r post.txt --delay 1 --level 2 --batch --dbs 可以查询qcms数据库里的表名信息
sqlmap -r post.txt --delay 1 --level 2 --batch -D qcms --tables sqlmap跑出来这些qcms数据库里的表名信息里最有可能存在管理员账号和密码的表名应该是qcms_admin这个表，所以继续查询该表里的字段名信息
字段名里发现了admin和pwd，这就是后台管理员账号和密码
继续查询admin和pwd字段内容
管理员的账号是admin密码为1bde85b48d956de30f316f0602c130ca，密码应该是md5加密了所以我们需要md5解密一下看看
密码为ssgxjj665a. 得到了账号：admin
密码：ssgxjj665a. 登录网站后台可以成功进
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/352a211680490518073f503efdd7d2dd/" rel="bookmark">
			python使用代理时报错ssl.SSLEOFError: EOF occurred in violation of protocol (_ssl.c:1129)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用代理的时候出现如下错误：
ssl.SSLEOFError: EOF occurred in violation of protocol (_ssl.c:1129)
将urllib3的版本降级到1.25.11就可以解决问题
pip install urllib3==1.25.11
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a6cb7fa8eb86d5ebecb8451e165ca9/" rel="bookmark">
			如何用Python将普通视频变成动漫视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 容我废话一下一、思路流程二、图像转动漫三、视频帧读取与视频帧写入 容我废话一下 最近几个月，毒教材被曝光引发争议，那些编写度教材的人着实可恶。咱程序员也没有手绘插画能力，但咱可以借助强大的深度学习模型将视频转动漫。所以今天的目标是让任何具有python语言基本能力的程序员，实现短视频转动漫效果。
效果展示
一、思路流程 读取视频帧将每一帧图像转为动漫帧将转换后的动漫帧转为视频 难点在于如何将图像转为动漫效果。这里我们使用基于深度学习的动漫效果转换模型，考虑到许多读者对这块不了解，因此我这边准备好了源码和模型，直接调用即可。不想看文章细节的可以直接拖到文章末尾，获取源码。
二、图像转动漫 为了让大家不关心深度学习模型，已经为大家准备好了转换后的onnx类型模型。接下来按顺序介绍运行onnx模型流程。
安装onnxruntime库
pip install onnxruntime 如果想要用GPU加速，可以安装GPU版本的onnxruntime:
pip install onnxruntime-gpu 需要注意的是：
onnxruntime-gpu的版本跟CUDA有关联，具体对应关系如下：
当然，如果用CPU运行，那就不需要考虑那么多了。考虑到通用性，本文全部以CPU版本onnxruntime。
运行模型
先导入onnxruntime库，创建InferenceSession对象，调用run函数。
如下所示
import onnxruntime as rt sess = rt.InferenceSession(MODEL_PATH) inp_name = sess.get_inputs()[0].name out = sess.run(None, {inp_name: inp_image}) 具体到我们这里的动漫效果，实现细节如下：
import cv2 import numpy as np import onnxruntime as rt # MODEL = "models/anime_1.onnx" MODEL = "models/anime_2.onnx" sess = rt.InferenceSession(MODEL) inp_name = sess.get_inputs()[0].name def infer(rgb): rgb = np.expand_dims(rgb, 0) rgb = rgb * 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51a6cb7fa8eb86d5ebecb8451e165ca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a8afa6bf7a5ac86666e1ca3b45c6f8/" rel="bookmark">
			微信小程序天气预报功能实现(支持自动定位,附源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言天气API获取微信小程序后台域名配置页面代码注意问题（必看）源码总结 由于和风天气API的更新，之前写的那篇文章 可能会出现版本不兼容的 情况。所以 更新了 这个 使用新版API的 小程序。
效果图
天气API获取 这里我用的是和风天气的API，打开官网注册或者登陆你的账号
进入控制台,选择应用管理,新建应用（应用版本 选择 免费开发版，key的类型 选择 Web API）
创建成功后就可以看到 待会要用到的 key了
微信小程序后台域名配置 登陆小程序后台，分别点击开发和开发设置
点击修改，将我们要用到的 API的域名添加到request合法域名里面，https://devapi.qweather.com 和 https://geoapi.qweather.com 。
页面代码
&lt;view class="header-modular" wx:if="{{now}}"&gt; &lt;image class="bg-wave" src="https://codermoyv.gitee.io/coder-moyv/assets/images/wechat/bg_wave.gif"&gt;&lt;/image&gt; &lt;view class="row"&gt; &lt;view class="row location-wrap" bindtap="selectLocation"&gt; &lt;image class="icon" src="/images/icon_location.png"&gt;&lt;/image&gt; &lt;view class="title"&gt;{{City}} {{County}}&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="row"&gt; &lt;view class="tmp"&gt;{{now.temp}}°&lt;/view&gt; &lt;image class="icon-weather" src="https://codermoyv.gitee.io/coder-moyv/assets/images/wechat/weather_custom/{{now.icon}}.png"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class="tips-wrap"&gt; &lt;view class="tips "&gt;{{now.windDir}} {{now.windScale}}级&lt;/view&gt; &lt;view class="tips "&gt;湿度 {{now.humidity}}%&lt;/view&gt; &lt;view class="tips "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84a8afa6bf7a5ac86666e1ca3b45c6f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c3b93223708a402b59bc26106e4f34/" rel="bookmark">
			Spring-TX-Propagation-事务传播行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring-Tx 传播行为 propagation提交异常捕获后异常required (rollbackOnly)do nothing / commitsetRollbackOnly / rollbacksetRollbackOnly / rollbackrequired_new (isNewTransaction)commit / commitrollback / rollbackrollback / commitcommit / rollbacknested (savePoint)releaseSavepoint / commitrollbackToSavepoint &amp; releaseSavepoint / rollbackrollbackToSavepoint &amp; releaseSavePoint / commit REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。 本质上是同一个事务 提交：什么也不做 异常传递：rollbackOnly = true 异常捕获：rollbackOnly = true REQUIRED_NEW 新建事务，如果当前存在事务，把当前事务挂起。 提交：isNewTx = true 提交 异常传递：rollback / rollback 异常捕获：rollback / commit 异常后捕：commit / rollback A、B不可操作同一条记录，因为处于不同事务中，会产生死锁。 NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 提交：releaseSavepoint / commit 异常传递：rollbackToSavepoint &amp; releaseSavepoint / rollback 异常捕获：rollbackToSavepoint &amp; releaseSavepoint / commit A、B可操作同一条记录，因为处于同一个事务中。 SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 提交： 异常捕获： 异常传递： MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 提交： 异常捕获： 异常传递： NOT_SUPPORTS 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 提交： 异常捕获： 异常传递： NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 提交： 异常捕获： 异常传递： 核心代码-AOP // Standard transaction demarcation with getTransaction and commit/rollback calls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15c3b93223708a402b59bc26106e4f34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a50e9ea69d1e9002582a58cfd31b29e5/" rel="bookmark">
			uniApp运行到微信小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要就是记录uniApp运行到小程序的过程。
首先，咱得有个HBuilderX账号 为什么呢？首先哈，进来这个配置，就要点击获取这个ID哈，但是捏，没有账号是获取不到的
呐，点击获取就会出现弹窗。
这个配置捏，我也给大家看一下哈，就一下哈，别的就不多看了
很详细明了了哈
配置完了捏，就运行到微信小程序就行了哈..直接点第一个哈 这个是会自动打开小程序滴
这有个错是什么意思捏，我跟大家伙说会哈..
这是要你自己去微信公众平台申请一个appid，然后配置在HBuilder里面，再重新运行。
既然说到这个appid，咱们不用去申请id也要去配置这个appid，这个确实是要的哈..
复制下来哈 添到这里就可以了 去搜那个错误信息，不要相信网上说的，把刚才的操作然后关闭打开运行就可以了哈，反正我是不行，那个错还在。可能我是个游客吧，对我起不了什么作用哈。
这个错捏不会对小程序造成什么影响滴，当它不存在也是可以滴 好了哈，这篇记录就到这里了哈，goodbey！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a76a2b723b055cabf96b9f96021dde/" rel="bookmark">
			取消网页中列表的滚动条，或者调试网页的展示效果。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候想一次性看多点的列表内容，但是列表有滚动条限制了高度。这时候可以运用一点前端知识，改下高度（暂时性的）。
（1）步骤如下：
浏览器打开网页后，键盘F12打开调试，调试界面左上角点击【Select an element in the page to inspect it】按钮，或者键盘【Ctrl+Shift+C】，其实就是抓取页面元素或控件，就能查看相关前端代码，就可以改下高度的数值了，改好后回车，页面就发生了变化，列表的滚动条就没有了，能一次看到更多数据。
（2）截图如下：
如果想调试网页的展示效果，其实步骤差不多，测试人员可能用得上，前端人员大概也用得上吧...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf5a837258f211d6a0f00cbecd1962d0/" rel="bookmark">
			pc网页调整为手机模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌浏览器打开网页后，键盘F12打开调试，调试界面左上角点击【Toggle device toolbar】按钮，或者键盘【Ctrl+Shift+M】，操作后，网页顶部有变化
可以选择任一选项
选择后，网页就会变成手机模式
也可以输入对应的分辨率，查看页面效果（一些特定分辨率的大屏会需要看效果）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b692e0bd78f329ed5e6fa945a7e57d03/" rel="bookmark">
			微信开发者工具-真机调试，可查看接口信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前测试小程序查看接口信息，是需要打开调试模式，手机界面小，看着多多少少有点不方便。
现在发现了可以直接找前端要文件包，用【微信开发者工具】打开该文件包，然后选择【真机调试】-【二维码真机调试】，生产二维码后，接着使用微信扫描就可以，会出现一个【真机调试】页面，接口信息就在这个页面查看。
如果用【F12】看电脑浏览器的控制台，会发现控制台和【真机调试】页面的内容差不多。
手机上操作小程序，调用到的接口信息都一目了然，在电脑上看接口信息还是很舒服的，总得来说就是好啊。
以下是步骤及效果截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87514408d2466ecc0be4e07e57664366/" rel="bookmark">
			Python基础常识:导入一个库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello，我是梁同学，今天给大家分享如何导入一个库？
方法1 import 库（最简单最基础的方法）
代码实例:
import turtle turtle.forward(50) 第一行先导入turtle画图库，第二行是调用库中的函数。
格式:库.函数(参数1,参数2,......,参数n)
优点:简单明了，看代码时一看就懂，适合小白。
缺点:每次调用函数都需要完整抄写库名，很麻烦，容易写错，导致报错。
方法2 import 库 as 代替库名使用的名字（升级版方法）
代码实例:
import turtle as t t.forward(50) 第一行，先导入turtle，然后指定使用t代替turtle。第二行可以直接使用t.函数名使用。
格式:代替库名使用的名字.函数(参数1,参数2,......,参数n)
优点:后面可以更省字节，而且很好理解。
缺点:可能出现两个库有相同函数的可能，而且代替库名使用的名字相同，这样系统就不知道该是哪个库运行函数了。
方法3 from 库 import *（顶级版方法）
代码实例:
from turtle import * forward(50) 第一行，先导入turtle，再减掉调用函数时前面的前缀。第二行可以直接使用forward函数，不需要写前缀。
格式:函数(参数1,参数2,......,参数n)
优点:更节省字节。
缺点:1.对于某些初学者而言，在一次导入多个库使用这种方法时，可能出现难理解的情况。2.还是可能会出现和第二个方法相同的缺点，系统不知道运行哪个库的函数。
总结:
总结 ↓方法→优缺点优点缺点import 库简单明了，看代码时一看就懂，适合小白每次调用函数都需要完整抄写库名，很麻烦，容易写错，导致报错import 库 as 代替库名使用的名字后面可以更省字节，而且很好理解可能出现两个库有相同函数的可能，而且代替库名使用的名字相同，这样系统就不知道该是哪个库运行函数了from 库 import *更节省字节1.对于某些初学者而言，在一次导入多个库使用这种方法时，可能出现难理解的情况2.还是可能会出现和第二个方法相同的缺点，系统不知道运行哪个库的函数 好了，这期分享到此结束，谢谢大家阅读，望大家借鉴！
如有疑问，请发到评论区，谢谢。
点击蓝字打开csdn官方网址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/092f6b647800d0c33c16f1d031e7c78c/" rel="bookmark">
			分布式唯一ID生成算法—雪花算法思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 雪花算法用于生成分布式唯一ID，总共有64位
首先想一个问题，我们为什么需要分布式唯一ID呢？
数据库自增ID：可用性难以保证，数据库挂了就寄了uuid其实是一个不错的本地生成唯一ID方案，但是其无法保证趋势递增，并且uuid过长，往往用字符串表示，作为主键建立索引查询效率低时间戳也可以，但是在并发1000的情况下，会生成重复的ID，这是一个致命弱点 ID结构 雪花算法生成的一个ID长度固定为64字节
第一位是表示正负数，而分布式唯一ID是整数，所以应恒为0后41位是时间戳后10位是机器ID，即最多可以容纳1024个机器最后12位是序列号，即最多4096个ID，从0~4095 那么也就是说一个时间戳的时间范围内，雪花算法可以生成1024*4096个ID，大约是四百万+个，可以看出来效率是非常高的
官方给出的实现示例 /** Copyright 2010-2012 Twitter, Inc.*/ package com.twitter.service.snowflake import com.twitter.ostrich.stats.Stats import com.twitter.service.snowflake.gen._ import java.util.Random import com.twitter.logging.Logger /** * An object that generates IDs. * This is broken into a separate class in case * we ever want to support multiple worker threads * per process */ class IdWorker(val workerId: Long, val datacenterId: Long, private val reporter: Reporter, var sequence: Long = 0L) extends Snowflake.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/092f6b647800d0c33c16f1d031e7c78c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/100/">«</a>
	<span class="pagination__item pagination__item--current">101/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/102/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>