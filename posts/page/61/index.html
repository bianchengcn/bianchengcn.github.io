<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b33662a6159ff0b0a3d5a2daad38950/" rel="bookmark">
			基于Q-Table的强化学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Q-Table的强化学习笔记 1 几个概念1.1 状态空间 S S S和动作空间 A A A1.2 奖励 R R R1.3 价值函数与Q-Table1.4 马尔可夫性 2 基于Q-Table的强化学习算法2.1 SARSA算法2.2 Q-learning算法 1 几个概念 最近也从小白入手看了些强化学习(Reinforcement Learning，RL)的相关知识，做了一些简单的笔记巩固一下。
1.1 状态空间 S S S和动作空间 A A A 给定强化学习的状态空间 S S S，空间的元素 s ∈ S s \in S s∈S为每一个状态；给定动作空间 A A A，空间中的元素 a ∈ A a \in A a∈A为可执行的动作。
1.2 奖励 R R R 某状态 s s s下执行动作 a a a获得的回报称为奖励，表示为 R R R，当前 t t t时间下的累计期望奖励表示为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b33662a6159ff0b0a3d5a2daad38950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ae6d973eaef5312b73798eb9e7b3e8/" rel="bookmark">
			PHP上传Excel文件导入数据到MySQL数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做Excel文件导入数据到数据库。网站如果想支持批量插入数据，可以制作一个上传Excel文件，导入里面的数据内容到MySQL数据库的小程序。
要用到的工具：
ThinkPHP：轻量级国产PHP开发框架。可在ThinkPHP官网下载。
PHPExcel：Office Excel 文档的一个PHP类库，它基于微软的OpenXML标准和PHP语言。可在CodePlex官网下载。、
1.设计MySQL数据库product
创建product数据库
CREATE DATABASE product DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 创建pro_info表，表结构
CREATE TABLE pro_info( pId int(4) NOT NULL PRIMARY KEY AUTO_INCREMENT, pName varchar(20) NOT NULL, pPrice float NOT NULL, pCount float NOT NULL ); 2.生成项目
先在ThinkPHP同级目录下新建index.php文件，生成项目Home.
&lt;?php define('APP_NAME', 'Home'); //项目名称 define('APP_PATH', './Home/'); //项目路径 define('APP_DEBUG', true); //开启DEBUG require './ThinkPHP/ThinkPHP.php'; //引入ThinkPHP核心运行文件 ?&gt; 3.上传文件表单
在Home/Tpl文件夹下新建Index文件夹，里面新建index.html文件
&lt;html&gt; &lt;head&gt; &lt;title&gt;上传文件&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;form id="upload" action="__URL__/upload/" method="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ae6d973eaef5312b73798eb9e7b3e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e02c66493a10de39e66d7c0caf5110/" rel="bookmark">
			Ubuntu安装g&#43;&#43;-7 : Depends: libstdc&#43;&#43;-7-dev (= 7.5.0-6ubuntu2) but it is not going to be installedE: Un
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接安装g++会出现错误：
The following packages have unmet dependencies: g++ : Depends: g++-9 (&gt;= 9.3.0-3~) but it is not going to be installed E: Unable to correct problems, you have held broken packages. 我怀疑是ubuntu自动安装的gcc9.4.0的版本无法匹配导致。因此我主动安装gcc-7：
sudo apt-get install gcc-7 是可以安装成功的，但是当我使用sudo apt-get install g++-7却始终无法安装，报错：
The following packages have unmet dependencies:
g+±7 : Depends: libstdc+±7-dev (= 7.5.0-6ubuntu2) but it is not going to be installed
E: Unable to correct problems, you have held broken packages.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21e02c66493a10de39e66d7c0caf5110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bec0d9e4ebcf0bb1b20eca26b95590c/" rel="bookmark">
			幂等问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是幂等性？ 幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。
在数学中，主要有两个定义
如果在一元运算中，x 为某集合中的任意数，如果满足 f(f(x))=f(x)，那么该 f 运算具有幂等性，比如绝对值运算就是幂等性函数。
如果在二元运算中，x 为某集合中的任意数，如果满足 f(x,x)=x，前提是 f 运算的两个参数均为 x，那么我们称 f
运算也有幂等性，比如求大值函数就是幂等性函数。
在编程领域里，幂等操作的特点是
其任意多次执行所产生的影响均与一次执行的影响相同。
业务上理解幂等性不仅仅只是一次或多次操作对资源产生相同影响，还包括第一次操作产生影响后，以后多次操作不会再产生影响。举例：服务端会进行重试等操作或客户端有可能会进行多次点击提交。如果这样请求多次的话，那最终处理的数据结果就一定要保证统一，如支付场景或者下单。此时就需要通过保证业务幂等性。
幂等的维度 时域唯一性 定义幂等的有效期。有些业务需要永久性保证幂等，如下单、支付等。而部分业务只要保证一段时间幂等即可。
空域唯一性 定义了幂等的范围，如生成订单的话，不允许出现重复下单。 一次操作=服务方法+传入的业务数据
HTTP协议语义幂等性 http1.1文档：https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
在HTTP/1.1中，对幂等性进行了定义。它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果（错误或网络超时问题除外）。也就是其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。
从这边可以看出GET、HEAD、PUT、DELETE是幂等的，POST、PATCH是非幂等的。
为什么出现幂等性问题 在接口调用时一般情况下都能正常返回信息不会重复提交，不过在遇见以下情况时可以就会出现问题：
前端重复提交表单：用户在点击一些按钮时，很多时候会因网络波动没有及时对用户做出提交成功响应，致使用户一直点提交按钮，这时就会发生重复提交表单请求。或者用户进行恶意刷单，导致接口接收到重复提交的请求。接口超时重复提交：很多时候 HTTP客户端工具都默认开启超时重试的机制，尤其是第三方调用接口时候，为了防止网络波动超时等造成的请求失败，都会添加重试机制，导致一个请求提交多次。消息进行重复消费： 当使用 MQ 消息中间件时候，如果发生消息中间件出现错误未及时提交消费信息，导致发生重复消费。 方案一：数据库主键或唯一索引 数据库主键的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。
使用数据库唯一主键完成幂等性时需要注意的是，该主键一并不是使用数据库中自增主键，而是使用分布式 ID 充当主键，这样才能能保证在分布式环境下 ID 的全局唯一性。
或者使用唯一索引，避免脏数据，无法插入重复数据，保证数据唯一性。
适用于插入、删除操作
方案二：数据库乐观锁 数据库乐观锁不仅可以用来当分布式锁，也可以用来幂等处理。
用法就是对应的数据表中加入version字段，每次查询时将其查出，每次更新时先判断version是否还是之前查出的值，如果是的话，就进行操作；否则，不进行操作。
适用于更新操作。
方案三：防重 Token 令牌 简单的说就是调用方在调用接口的时候先向后端请求一个全局 ID（Token），请求的时候携带这个全局 ID 一起请求（Token 最好将其放到 Headers 中），后端需要将这个 Token 作为 Key，用户信息作为 Value 到 Redis 中进行键值内容校验，如果 Key 存在且 Value 匹配就执行删除命令，然后正常执行后面的业务逻辑。如果不存在对应的 Key 或 Value 不匹配就返回重复执行的错误信息，这样来保证幂等操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bec0d9e4ebcf0bb1b20eca26b95590c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e93a9d94788c84312cfc89ab7a8667e4/" rel="bookmark">
			linux下挂载光驱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二、mount挂载
1、查看Linux光驱设备
[root@server1 ~]# ls -l /dev/cdrom
lrwxrwxrwx. 1 root root 3 Feb 3 22:21 /dev/cdrom -&gt; sr0
[root@server1 ~]# ls -l /dev/sr0
brw-rw----+ 1 root cdrom 11, 0 Feb 3 22:21 /dev/sr0
2、挂载操作
使用mount命令
格式：mount 设备路径 挂载点目录
[root@server1 ~]# mkdir /dvd
[root@server1 ~]# ls /dvd
[root@server1 ~]# mount /dev/cdrom /dvd/
mount: /dev/sr0 写保护，将以只读方式挂载
常见错误：
没有将光盘镜像文件，放入光驱设备
光驱设备没有连接
[root@server1 ~ ]# mount /dev/cdrom /nsd01
mount: 在 /dev/sr0 上找不到媒体
1
2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e93a9d94788c84312cfc89ab7a8667e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/427842942c7a4a7477fd9ca2292ae2b1/" rel="bookmark">
			【解决】VMware下的Linux虚拟机（CentOS 7无法ssh远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		宿主机macOS arm m1，VMWare下是centos7
结合我的实际情况，问题解决如下：
1、开启SSH服务：service sshd start
2、关闭liunx防火墙：chkconfig iptables off（实际上我在使用这一个的时候似乎没有用，相当于没有这一步，也成功了）
3、重启liunx:reboot
4、SSH连接虚拟机，输入地址、账号、密码，连接成功！
参考：SSH连不上虚拟机的问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88686c8909a3207c3855f941cffe790a/" rel="bookmark">
			Chat-GPT 聚合平台 Poe：集成多个 AI 聊天机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chat-GPT 聚合平台 Poe：集成多个 AI 聊天机器人 介绍 Poe 是知名问答社区 Quora 推出的 AI 平台——开放探索平台 (Platform for Open Exploration, Poe)。Poe 集成了多个基于大型语言模型的聊天机器人，包括 ChatGPT，以及 Sage、Claude、Dragonfly 等。每个机器人都有独特的个性，用户可根据其特性和用途来切换使用。
Claude：更擅长创意写作任务，但更容易拒绝回答问题。Sage 和 ChatGPT：更擅长英语以外的语言，更擅长与编程相关的任务。Dragonfly 响应较短，并且在输入中给出示例时更容易让 Dragonfly 遵循说明。 在背后的技术实现上，Sage、ChatGPT 和 Dragonfly 由 OpenAI 提供支持。Sage 和 ChatGPT 使用 gpt-3.5-turbo 模型，而 Dragonfly 使用 text-davinci-003。Claude 由 Anthropic 提供支持。
可以访问 GPT4 ，Claude+，Claude-instant-100k,Claude-instat,ChatGPT3.5,Dragonfly
目前，Poe 已发布了适用于 iOS 的应用程序、以及适用于手机和 PC 的网页版本。
Poe 网页版：poe.comPoe for iOS 版：https://apps.apple.com/app/apple-store/id1640745955 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8rpdnGBr-1685117955881)(C:\Users\56342\AppData\Local\Temp\WeChat Files\69d79a196c255a0ba32aea313297f69.png)]
注册方式 以下是具体的步骤：
访问Poe官方网站。首先，在浏览器中打开Poe官方网站。点击注册按钮。在网站首页，您会看到“注册”按钮，点击进入。填写注册信息。在注册页面，您需要填写邮箱地址，设置密码和确认密码。请注意，密码需要包含数字和字母，长度至少为8个字符。完成人机验证。填写信息后，您需要完成一个简单的人机验证，确认您不是机器人。首先要进行手机号码验证，中国手机也是支持的。邮箱验证。点击提交后，系统会向您的邮箱发送一封验证邮件。您需要打开这封邮件，点击其中的链接以完成验证。完成注册。当您完成邮箱验证后，就成功注册了Poe账号。您现在可以使用该账号登录Poe AI Chat，开始体验其丰富的功能。 在中国注册Poe账号并不需要使用代理工具，只需要您的网络可以正常访问Poe的官方网站。同时，Poe支持使用中国的邮箱地址进行注册。但是，为了能成功接收验证邮件，您需要确保您的邮箱能正常接收并发送邮件
订阅 poe有免费的7天试用期，之后需要进行每月订阅收费，折合人民币120元左右。如何你想优惠，可以联系我wx: heyi_master，折合人民币120元左右。如何你想优惠，可以联系我wx: heyi_master
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78fa9a15ec23624df9f1bc5256f224ca/" rel="bookmark">
			渗透测试 | 目录扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 免责声明 本文仅限于学习讨论与技术知识的分享，不得违反当地国家的法律法规。对于传播、利用文章中提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，本文作者不为此承担任何责任，一旦造成后果请自行承担！
0x01 前言 信息收集可以说是在渗透测试中最重要的一部分，其中目录扫描也占有重要位置。通过目录扫描，可以查找到目标系统中可能存在的敏感文件和目录，在进行目录扫描之前，必须获得授权并遵守法律和道德准则。
0x02 HTTP状态码详解 Ⅰ 状态码的五种类型
状态码类型1xx信息状态码2xx成功状态码3xx重定向状态码4xx客户端错误状态码5xx服务器错误状态码 Ⅱ 2xx状态码
200 OK
状态码 200 表示请求成功。默认情况状态码是 200 的响应可以被缓存。
201 Created
HTTP 成功创建新资源，状态码为 201 ，状态码 201 表示服务器已成功创建了新资源并返回给客户端。
202 Accepted
HTTP 协议中，状态码 202 表示服务器已经收到请求，但还未处理完毕。但需要注意的是，服务器不能保证处理一定成功，并且也不能通过 HTTP 协议异步地通知客户端请求的处理结果。
Ⅲ 3xx状态码
301 Moved Permanently
当 Web 服务器接收到用户的访问请求时，如果请求的 URL 已经发生改变，可以采用 301 跳转的方式，将请求的 URL 永久地重定向到新的 URL 地址。此时，服务器会返回一个状态码为 301 的响应，告知搜索引擎和浏览器该页面已经永久性地被移动到了一个新的位置。
302 Found
当使用 HTTP 协议请求资源时，如果服务器暂时将资源移动到了另一个 URL 上，它将返回 302 Found 状态码。这表示浏览器应该重定向到该 URL 来获取资源。但搜索引擎不会更新链接并仍将原始 URL 视为资源的地址。所以，这个状态码在一些情况下可以帮助维护者快速更新网站资源的位置，但也有可能导致搜索引擎无法正确索引资源。
Ⅳ 4xx状态码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78fa9a15ec23624df9f1bc5256f224ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee8b72f7ebec5076095bc5ab5a082182/" rel="bookmark">
			vue3 app.directive()防止用户多次连续点击按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在项目中，需要对操作按钮加以限制，来防止用户多次连续点击。这就需要用到自定义指令directive。
main.js中全局注册方法如下：
const app = createApp(App); /** @方法名：directive(app.directive,vue3内置api) @参数： @描述：用于防止多次点击保存效果，仅用于button **/ app.directive('preventReClick', (el, binding) =&gt; { function preventReClickFun(elValue, bindingValue) { if (!elValue.disabled) { elValue.disabled = true setTimeout(() =&gt; { elValue.disabled = false }, bindingValue.value || 3000) } } el.addEventListener('click', () =&gt; preventReClickFun(el, binding)) binding.dir.unmounted = function() { el.removeEventListener('click', () =&gt; preventReClickFun(el, binding)) } }); 使用：
&lt;el-button type="primary" @click="handleClick" v-preventReClick&gt;&lt;/el-button&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6324b6c5781d96da96a208a29dda032e/" rel="bookmark">
			加密与认证技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、对称加密和非对称加密
二、消息摘要技术
三、数字签名技术
四、会话安全管理
一、对称加密和非对称加密 1. 数据加密
在计算机技术应用中，为有效防止被非法窃取，采用数据加密技术可以有效保证信息在网络中的传播安全。
2. 对称加密（单密钥加密）
· 概念：采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密
· 特点：算法公开、计算量小、加密速度快、加密效率高
· 主要算法：DES（已破解，不再安全）、AES（最常用）
3. 非对称加密算法
· 加密和解密使用的是两个不同的密钥：公钥（public key）、私钥（private key）
· 私钥自己保存，公钥对外发布
· 一个加密另一个解密：私钥加密，公钥解密；公钥加密，私钥解密
· 常见算法：RSA、DHE_RSA、ECDHE_RSA
二、消息摘要技术
1. 概念 消息摘要是把输入的原始数据消息，通过摘要算法，产生长度固定的字符串。而原始数据中的任何内容发生变化（哪怕多了一个空格）都会产生不一样的摘要信息。这个特点被用来检测文件内容的完整性和是否被篡改过。
2. 散列函数
消息摘要是通过“散列函数”来实现的，即将任意长度的输入转化为定长输出的一种算法。
散列函数的结果也常被称为“散列”、“指纹”、“摘要”或者“哈希”。
它有以下几个特点：
· 单向性：散列函数是不可逆的，即无法通过一个给定的散列结果，反向找到生成它的原始信息内容
· 抗碰撞性：通过计算无法找到两个不同的原始信息具有相同散列的情况
3. 算法
MD5，仍在大量使用，但是已经证明可以通过碰撞攻击技术破解
SHA-3（使用Keccak算法），至今尚未显示出不安全性
4. MD5破解
MD5是单向不可逆的，源数据和hash后的数据是一一对应关系，就可以进行反向破解。
线上海量存储查询：https://md5jiami.bmcx.com/
线上解密破解：https://www.cmd5.com/
彩虹表破解：将MD5哈希后的密文比作一把锁，破解就相当于有很多可以尝试的钥匙，将钥匙按照某种规律进行分组，每组钥匙中只需要带有最有特点的一个，当发现某个“特征钥匙”差一点就能开锁了，则当场对该钥匙进行简单的打磨，直到能开锁为止，
注：因数据量太大，并不一定能找到源数据
三、数字签名技术 数字签名，是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。
数字签名不仅仅是对hash摘要的加密，还包括：签名者的名字、签名时间、Hash算法、Hash加密方法、加密后的hash值、数字机构。 四、会话安全管理 1. 会话鉴权和认证
· 会话鉴权及认证技术包括：cookie管理、session会话技术和token令牌技术
· cookie管理是浏览器的一种策略，用于解决http协议是无状态连接问题的，cookie可以记录用户浏览历史，辨别用户身份、进行session跟踪而存储在用户本地终端上的数据。
· 不管是session会话技术还是token令牌技术都是基于cookie管理进行的。
会话安全管理需要授权和鉴权两个步骤：
授权：相当于下发一个通行证（通行证保存cookie管理器）
鉴权：鉴定是否有权访问（判断有请求是否正确携带通行证）
2. cookie状态保持
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6324b6c5781d96da96a208a29dda032e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1ecfb9e5e2b349d757f06244953db4/" rel="bookmark">
			Windows&amp;Linux共享文件夹之利用虚拟机VM创建共享文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 利用虚拟机创建共享文件夹 由于大部分人常用和熟悉的系统是Windows系统，所以在Linux下进行操作很多时候会感到不太方便，就比如程序代码开发时大多数情况下都是在Windows下进行的，所以比较熟悉Windows下的开发环境。要进行Linux开发的时候，多数情况下都是借助Windows平台进行代码的编辑，然后去Linux上进行编译和运行，这个时候就需要去创建共享文件夹，来实现在Windows下对Linux的一些操作。
虚拟机软件就为我们提供了一种Windows与Linux之间共享文件夹的方法，下面我们就来实际操作一下
点击虚拟机设置→点击选项→选择共享文件夹
点击添加，进入添加共享文件夹向导
选择主机上要共享的文件夹的路径
点击完成就创建好了
你也可以通过这种方法创建多个共享文件夹
创建好后，重启Linux虚拟机。共享文件夹Linux下的位置在/mnt/hgfs目录下面
如果创建后，在指定文件夹下并没有看到共享文件夹，不要慌后面有解决（亲身经历）
就可以看到共享的文件夹了
可能出现找不到共享文件夹的问题 可能出现的问题：mnt下没有找到共享的文件夹
原因：可能是共享文件夹没有自动映射到Linux上面，导致没有共享文件夹
解决方法：
1、进入mnt/hgfs文件夹下
命令：cd /mnt/hgfs
如果系统提示没有指定的文件夹，则用mkdir命令创建文件夹就可以
2、查看共享文件夹
命令：vmware-hgfsclient
3、把共享文件夹映射到/mnt/hgfs文件夹下
命令：vmhgfs-fuse .host:/ /mnt/hgfs
4、重新进入hgfs文件夹就可以看到共享文件夹
利用虚拟机来创建Windows与Linux共享文件夹到这里就结束了
感谢观看学习，大佬们多多指点，愿明天的自己会感谢当下的努力！！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d274fd099167e3b95ad6abadb9bd945/" rel="bookmark">
			MySQL设置远程登录（为root用户设置远程登陆权限）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL8以前的版本 如果是8以前的版本可以使用
-- GRANT privileges ON database_name.table_name TO 'username'@'hostname' IDENTIFIED BY 'password'; -- privileges表示授予的权限，database_name和table_name表示要授权的数据库和表名，username和hostname表示要授权的用户和主机名，password表示用户的密码 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; -- 刷新权限 FLUSH PRIVILEGES; 重启MySQL服务，此时应当可以连接成功。
MySQL8及以上版本 问题 在MySQL8之后，使用 GRANT 命令的使用不会默认创建新账户，所以如果你执行上面的语句显示
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'IDENTIFIED BY '123456' WITH GRANT OPTION' at line 1 恭喜你，你应当使用的是MySQL8的版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d274fd099167e3b95ad6abadb9bd945/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062f390966e7287011e51b30634ed589/" rel="bookmark">
			如何查看cpu核数以及线程数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Windows机器 简介：win机器常见几种cpu类型
单核：一个厨师，一个灶眼
双核：两个厨师，两个灶眼
双核四线程（虚拟四核）：两个厨师，四个灶眼
四核：四个厨师，四个灶眼
四核八线程（虚拟八核）：四个厨师，八个灶眼
八核：八个厨师，八个灶眼
方法①：打开命令窗口Win+R，输入cmd，然后在命令窗口界面输入systeminfo
此处表示一颗cpu
方法②：在命令窗口输入wmic
获取win机器cpu核数 C:\Users\lhh&gt;wmic wmic:root\cli&gt;cpu get NumberOfCores NumberOfCores 4 获取win机器线程数目 wmic:root\cli&gt;cpu get NumberOfLogicalProcessors NumberOfLogicalProcessors 8 方法③直接打开任务管理器，查看这个界面即可；由图得知，此机器为4核8线程
方法④：查看win机器线程数目，由此图得知，该win机器线程数目为8
2、Linux机器查看cpu核心数以及线程数 方法①：
# 总核数 = 物理CPU个数 X 每颗物理CPU的核数 # 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数
# 查看物理CPU个数
cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l
# 查看每个物理CPU中core的核数
cat /proc/cpuinfo| grep "cpu cores"| uniq
# 查看逻辑CPU的线程数
cat /proc/cpuinfo| grep "processor"| wc -l
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/062f390966e7287011e51b30634ed589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a16bdfba4ab8ac73c9d304bfb366d9/" rel="bookmark">
			安全测试基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、软件安全测试概述
二、 安全漏洞
三、软件安全测试方法
四、软件安全测试内容
五、软件安全测试的过程
六、web安全测试范围
七、web安全测试分类
八、0day&amp;1day
一、软件安全测试概述 1. 概念
安全性测试是指有关验证应用程序的安全等级和识别潜在安全性缺陷的过程。
2. 分类
· 应用软件的安全性测试
软件自身程序设计中存在的安全隐患，并检查应用程序对非法侵入的防范能力。
· 系统级别的安全性测试
确保只有具备系统平台访问权限的用户才能访问，包括对系统的登录或远程访问。
导致软件出现安全问题的主要原因或根源是软件的安全漏洞
二、 安全漏洞 1. 概念
特指硬件、软件、协议，在逻辑设计上或具体实现或系统安全策略上存在的缺陷或错误。
· 漏洞的产生主要是由于程序员不正确和不安全编程引起的
· 不法者可以通过漏洞获取系统额外权限，并对系统植入木马、病毒，已窃取系统资料
· 威胁到系统安全的错误才是漏洞
2. 危害
· 系统完整性：非法篡改破坏数据的完整性
· 系统可用性：破坏系统或者网络，导致服务器不可用
· 系统机密性：泄露个人或企业的隐私信息
· 系统可靠性：造成系统不能正常提供有效服务
三、软件安全测试方法 1. 代码安全性测试
主要通过对源代码进行安全扫描，根据程序中数据流、控制流、语义等信息与其特有软件安全规则库进行匹对，从中找出代码中潜在的安全漏洞。
2. 渗透测试
主要使用自动化工具或者人工的方法模拟黑客的输入，对应用系统进行攻击性测试，从中找出运行时刻所存在的安全漏洞。
3. 程序数据扫描
数据扫描的手段通常是进行内存测试，内存测试可以发现许多诸如缓冲区溢出这类的漏洞，而这类漏洞使用除此之外的测试手段都难以发现。
四、软件安全测试内容 1. 功能验证
对涉及到安全的软件功能进行有效性验证，如管理模块、权限模块、加密系统、认证系统等。
2. 漏洞扫描
安全漏洞扫描主要是借助于特定的漏洞扫描器完成的，系统管理员能够发现系统存在的安全漏洞。
3. 模拟攻击
模拟攻击测试是一组特殊的极端的测试方法，以模拟攻击方式来验证软件系统的安全防护能力。
4. 侦听技术
也称网络监听，可以获取网络上传输的信息，如果从获取的信息中提取到消息中提取到系统的隐私数据，就存在安全性问题。
五、软件安全测试的过程 基于安全需求，将系统可能面临的安全问题进行分类，画出威胁树，可以针对威胁树选择应对的方法和技术，是为需求分析。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39a16bdfba4ab8ac73c9d304bfb366d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e1a4a43b1a84323803a51f6c1aa924/" rel="bookmark">
			stream流排序的各种类型方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int类型 List&lt;Integer&gt; list= new ArrayList&lt;&gt;(); list.add(3); list.add(5); list.add(1); List&lt;Integer&gt; collect = list.stream() .sorted(Comparator.comparingInt(Integer::intValue)) .collect(Collectors.toList()); System.out.println(collect); //[1, 3, 5] //要是相反的话则加上reversed() List&lt;Integer&gt; collect = list.stream() .sorted(Comparator.comparingInt(Integer::intValue).reversed()) .collect(Collectors.toList()); String类型 //按照ascii码排序 List&lt;String&gt; list= new ArrayList&lt;&gt;(); list.add("a"); list.add("c"); list.add("b"); List&lt;String&gt; collect = list.stream() .sorted(Comparator.comparing(String::toString)) .collect(Collectors.toList()); System.out.println(collect); //[a, b, c] //按照长度排序 List&lt;String&gt; list= new ArrayList&lt;&gt;(); list.add("a1"); list.add("c11"); list.add("b111"); List&lt;String&gt; collect = list.stream() .sorted(Comparator.comparing(String::length)) .collect(Collectors.toList()); System.out.println(collect); //[a1, c11, b111] Long类型 List&lt;Long&gt; list= new ArrayList&lt;&gt;(); list.add(3L); list.add(5L); list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9e1a4a43b1a84323803a51f6c1aa924/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd59a8d365bf69f2e552bd821af62970/" rel="bookmark">
			vue2的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue2有8个生命周期 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestory destoryed 进入组件会执行的生命周期 beforeCreate(){ console.log(this.$el,this.$data) // 在Vue2中，this.$el是一个DOM元素，表示当前组件渲染的根元素。this.$data是一个对象，包含了当前组件的所有数据。这些数据可以通过模板或JavaScript代码进行访问和修改。this.$data对象中的属性与组件中定义的data选项中的属性一一对应，可以通过this.$data来访问和修改这些属性。需要注意的是，虽然可以使用this.$data来直接修改组件中的数据，但是在大多数情况下，应该使用Vue提供的响应式数据更新方法来修改数据，以确保组件的响应式更新能够正常工作。 // undefined undefined } created(){ // undefined {……} } beforeMount(){ // undefined {……} } mounted(){ // &lt;div class="app"&gt;&lt;/div&gt; {……} } 父组件中引入子组件，生命周期的执行顺序 // 父 beforeCreate created beforeMount 子1 beforeCreate created beforeMount mounted 子2 …… // 父 Mounted 发请求是放在created还是mounted中 这个问题具体看项目业务的情况，因为组件加载顺序是，父组件引入了子组件，那么就会先执行父的前三个生命周期，再执行子的前四个生命周期， 那么如果我们的业务是父组件引入子组件，并且优先加载子组件的数据，那么在父组件中当前的请求要放在mounted 如果当前组件对子组件没有依赖关系，放在哪个生命周期都可以 为什么发请求不在beforeCreated中？beforeCreat和created有什么区别？ 因为：如果请求是在methods封装好了，在beforeCreate调用的时候，beforeCreate阶段是拿不到methods里面的方法的（会报错） 在created中怎么获取dom 很简单，只要在beforeCreat中书写异步代码，在异步代码里就可以获取dom，（由于代码执行顺序原因，异步代码会在所有进入页面的四个生命周期都执行完了才会执行，） //1、只要写异步代码，获取dom是在异步中获取的，就可以了 例如：setTimeout 请求， promise 等等 //2、使用vue系统内置的 this.$nextTick 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca6693b28ba94d234f656393fa0ff59/" rel="bookmark">
			关于配置feign: hystrix: enabled: true的一点小测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：学习springCloud的hystrix的服务降级。这里8001的服务的提供者，80是消费者。 同时8001和80都配置了服务降级后出现的下列几种情况。
注意：1）这里使用了这个配置后：①就不会显示服务提供者的服务降级了。假设服务提供者（提供者设置的1500，消费者设置5000）超时报错了，80不会返回8001的降级服务返回，会直接返回80的降级服务。
②假设我们注释掉80的服务降级相关配置 会直接报错500 timeout 并且提示没有对应的fallback
2）如果没有这个配置，①当服务消费者这边没有超时（设置的5000），而提供者超时（设置的1500）的时候会返回8001的降级返回。
②当80设置1500，8001也是1500的时候返回的是80的服务降级。
③ 后续测试发现②是因为两个配置一样的时候，这里80直接超时了，因为8001调用整个过程可能使用了1600ms， 所以直接返回了80的降级服务了，开始以为会优先返回调用端的降级服务返回。后来发现：这里我把80设置为2800 8001设置还是1500，发现返回的是8001的降级服务
也就是这里80其实就没有超时了，是调用到了8001的降级服务结果，80这里就不算调用超时，所以返回
综上所述 我觉得这里还是不加这个配置好一点
后续学习知道这个配置是开启feign的hystrix 与这里其实没有太大的关系。 @FeignClient(value = “cloud-provider-hystrix-payment”, fallback = FeignHystrixFallBackService.class)
要使用这里这个fallback 就必须开启这个注解。 专门针对feign去调用接口的时候使用的。 而服务的消费方 调用这个接口的方法要使用服务降级的话，就是使用hystrix 本身，与这个注解并没有关系。
后续继续学习的时候发现： 1）使用这个配置时候 ①这里没有返回8001报错是因为Hystrix默认的超时时间为1S ，当我们使用了这个配置过后，在使用Feign接口调用hystrix默认的超时时间久为1S了（而我们在方法上面配置的5000毫秒其实是整个方法的hystrix超时时间），所以上诉①是直接80这边调用对应接口1S过后就超时了，然后报错超时，启用了80 的降级服务。上诉②其实也是80这边1S过后就直接超时了，但是因为注释掉了80这边服务降级配置，所以直接返回了调用FeignHystrixOrderService.findTimeOut超时！！
也就是说这里要是我们在配置yml文件上加上hystrix:command:default:execution:isolation:thread:timeoutInMilliseconds:15000 过后。然超时时间延迟过后这里的①应该是返回8001的服务降级返回。经过测试也确实是这样。
2）没有使用这个配置的时候 这里因为没有启用该配置时候（Feign调用接口没有启用降级服务）hystrix的超时时间就是注解上的超时时间，也即使80整个方法调用的超时时间，所以这里的一切返回都是合理的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17613c2a70580f33b87484c88c9f795c/" rel="bookmark">
			压缩包安装 Mysql5.7.36
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.下载压缩包 并 解压 官网下载网址：
https://downloads.mysql.com/archives/community/
二.mysql安装配置 以解压的路径为 ${PATH} 为例说明
1.在解压的目录里面新建一个txt文件，并输入信息，然后保存为 my.ini [client] port=3306 [mysql] default-character-set=utf8 [mysqld] basedir = "D:/mysql-5.7.36" # mysql安装路径 datadir = "D:/mysql-5.7.36/data" # mysql安装路径下的data的路径 port = 3306	max_connections=200	character-set-server=utf8	default-storage-engine=INNODB 2.初始化数据库 以及 添加服务 # 前提：${PATH}/bin 目录下 # 1.初始化 mysqld --initialize-insecure # 2.注册mysql服务，如果有报错提示服务已经存在的话用下面的命令卸载旧版mysql服务 mysqld -install # 停止以及卸载旧版mysql服务（如果需要的话） net stop mysql mysqld -remove mysql # 3.启动服务 net start mysql 然后数据库就可以正常使用了，下面继续一些配置
3.配置环境变量 以及 设置mysql密码 # 1.添加环境变量： # 在环境变量中加入 解压路径下/bin 的绝对路径：${PATH}/bin (ps:${PATH}表示mysql解压的路径) # 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17613c2a70580f33b87484c88c9f795c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbebdffd8aa27d8c432f827458fe0069/" rel="bookmark">
			Vscode参数输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般使用launch.json配置文件进行参数配置
增加输入参数 例如
{ "version": "0.2.0", "configurations": [ { "name": "Python: Current File with Arguments", "type": "python", "request": "launch", "program": "${file}", "args": ["--foo", "bar"] } ] } 将 “args” 属性设置为您要传递给 Python 脚本的参数。
增加环境变量 { "version": "0.2.0", "configurations": [ { "name": "Python: Current File", "type": "python", "request": "launch", "program": "${file}", "env": { "MY_VAR": "some value", "ANOTHER_VAR": "another value" } } ] } 在这个示例配置中，“env” 属性指定要设置的环境变量及其值，此处包括 “MY_VAR” 和 “ANOTHER_VAR” 两个环境变量。您可以根据需要添加或删除环境变量。
请注意：如果变量的值包含空格或其他特殊字符，则必须使用引号将其括起来。例如：“MY_VAR”: “some value with spaces”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70d81e78dde30e56ab342567047ad146/" rel="bookmark">
			Js异步编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JavaScript (JS) 是一种单线程执行的编程语言，因此在处理复杂或耗时的任务时，如果采用同步编程方式，则会让浏览器或服务器阻塞，导致用户体验变差或性能下降。
异步编程可以解决这个问题。它使得可以同时处理多个任务，不需要等待某些操作完成再执行下一个操作，而是立即将控制权返回给调用者。当相应的操作完成时，异步函数会调用回调函数或Promise对象的then()方法，并在事件队列中排队等待执行，从而实现非阻塞式的并发执行。
以下是两种异步编程实现的方式：
一.Promise.all 实现 methodExec() { // 1.定义一个Array存储调用方法后的数据 const promiseArray = [] // 2.将要异步执行的两个方法添加到Array中 promiseArray.push( fun1(), fun2() ) // 3.使用 Promise.all() + .then() 等待方法返回结果都返回，然后获取异步调用的方法的信息 Promise.all(promiseArray).then((result) =&gt; { console.log(result[0]) console.log(result[1]) }) } async methodExec() { // await等待Promise.all()返回全部数据，方法和效果跟上面一模一样 let [fun1Data,fun2Data] = await Promise.all([fun1(),fun2()]); } 二.async/await 实现 // async 是一个关键字，定义异步函数 async methodExec() { // 定义变量接收方法fun1()和fun2()的返回值，此时fun1()的执行不阻塞fun2() let fun1Promise = fun1() let fun2Promise = fun2() // await 是一个关键字，可以等到fun1Promise和fun2Promise接受到返回值后才赋值到fun1Data和fun2Data let fun1Data = await fun1Promise; let fun2Data = await fun2Promise; } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/60/">«</a>
	<span class="pagination__item pagination__item--current">61/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/62/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>