<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe237516a4886f2c4c9d17bc0ac37a63/" rel="bookmark">
			漫画：程序员的最强大脑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“程序员小灰”，选择“置顶公众号”
有趣有内涵的文章第一时间送达！
三月份，草长莺飞，又到了我们公众号送书的时候。
感谢博文视点，为我们赞助了10本技术类图书：
我们这一次的送书方式是什么呢？
玩一场“最强大脑”的游戏！
游戏规则如下：
1.请大家思考上面的图形推理题目，在文末留言给出答案和解题思路，只有答案和解题思路都正确者，才算回答正确。
2.活动进行过程中，和答案有关的留言暂时不上墙，活动结束后统一上墙。我们的活动截止到3月14日 22:00，回答正确者方可入围抽奖，小灰会抽出10名幸运读者。
3.获奖者可以在上面的图书中任选一本，同时可以免费加入小灰的知识星球。
至于什么是知识星球，还不知道的朋友们可以看看小灰之前的介绍：
小灰的知识星球正式开通！
目前星球已有将近600位渴望知识的朋友，每天都在讨论技术问题，交流面试经验。有兴趣的小伙伴们欢迎加入！
最后，再一次感谢大家的支持。
祝大家在这个美好的春天一帆风顺，心想事成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5def5c7982b61976969cc80007459dec/" rel="bookmark">
			链表：调换相邻元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个链表，把相邻的两个元素进行互换。
如给定链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，则互换后的结果为2-&gt;1-&gt;4-&gt;3-&gt;6-&gt;5。
public ListNode swapPairs(ListNode head) { if(head == null || head.next == null) return head; if(head.next.next == null){ //只有两个元素 head.next.next = head; head = head.next; head.next.next = null; return head; } ListNode pre = head; ListNode curr = head.next; ListNode next = curr.next; head = head.next; while(true){ curr.next = pre; if(next.next != null &amp;&amp; next.next.next != null){ //正常往前循环 pre.next = next.next; pre = next; curr = pre.next; next = next.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5def5c7982b61976969cc80007459dec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d448f9c0e861e0dfa12d8c9ed1127ac5/" rel="bookmark">
			docker build 命令后 . 号的意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击在我的博客 xuxusheng.com 中查看，有更好的排版哦~ 参考文章: https://yeasy.gitbooks.io/docker_practice/content/image/build.html
我们在使用 docker build 命令去构建镜像时，往往会看到命令最后会有一个 . 号。
比如：
docker build -t xxx . 那么这里的 . 号代表什么意思呢？
在跟后端小悦悦同学交流的过程中，就发现小悦悦同学对 . 号的理解有所偏差，以为是用来指定 Dockerfile 文件所在的位置的，但其实 -f 参数才是用来指定 Dockerfile 的路径的，那么 . 号究竟是用来做什么的呢？
Docker 在运行时分为 Docker引擎（服务端守护进程） 以及 客户端工具，我们日常使用各种 docker 命令，其实就是在使用客户端工具与 Docker 引擎 进行交互。
那么当我们使用 docker build 命令来构建镜像时，这个构建过程其实是在 Docker引擎 中完成的，而不是在本机环境。
那么如果在 Dockerfile 中使用了一些 COPY 等指令来操作文件，如何让 Docker引擎 获取到这些文件呢？
这里就有了一个 镜像构建上下文 的概念，当构建的时候，由用户指定构建镜像的上下文路径，而 docker build 会将这个路径下所有的文件都打包上传给 Docker 引擎，引擎内将这些内容展开后，就能获取到所有指定上下文中的文件了。
比如说 dockerfile 中的 COPY ./package.json /project，其实拷贝的并不是本机目录下的 package.json 文件，而是 docker引擎 中展开的构建上下文中的文件，所以如果拷贝的文件超出了构建上下文的范围，Docker引擎 是找不到那些文件的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d448f9c0e861e0dfa12d8c9ed1127ac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fde3f79268897542f04afad7bc49cbf6/" rel="bookmark">
			解决JavaFX Scene Builder打不开.fxml文件的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前面介绍了用JavaFX Scene Builder来进行界面开发，用起来很方便。但最近在使用时发现了一个问题。 要打开fxml文件来设置控制器以及元素与控制器中的属性的对应关系时，JavaFX Scene Builder一直没有响应，只在通知栏显示一个图标，鼠标悬浮在上面时也只是显示一个小黑窗口。下面是从知乎上找来的答案，亲测可用。
解决方法如下： 打开JavaFX Scene Builder File -&gt; Open Recent -&gt; Clear Menu 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b81a831a13452e06ed176316277eb28/" rel="bookmark">
			【数据库设计】无损连接的判别方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据库设计】无损连接的判别方法 无损连接是指分解后的关系通过自然连接可以恢复成原来的关系，即通过自然连接得到的关系与原来的关系相比，既不多出信息、又不丢失信息。保持函数依赖分解是指在模式的分解过程中，函数依赖不能丢失的特性，即模式分解不能破坏原来的语义。
判断是否无损连接的方法：
若关系模式R(U,F)中，被分解为p={R1, R2}是R的一个分解，若R1∩R2 → R1 - R2或者R1∩R2 → R2 - R1，则为无损连接
下面来看个例题
设有关系模式R(U，V，W，X，Y，Z)，其函数依赖集：F＝{U→V，W→z，Y→U，WY→X}，现有下列分解：p＝{UVY，WXYZ}
判断分解p是否为无损连接
首先计算 R1∩R2 为Y，R1-R2为UV因为 Y→U，U→V，因此Y→UV。
所以为无损连接
此外我们还可以构造一个二维表来进行判断是否为无损连接，就刚刚这个题来说
UVWXYZ分解1a1a2a5分解2a3a4a5 因为U→V，Y→U，因此可以得出
UVWXYZ分解1a1a2a5分解2a1a2a3a4a5 因此可以得出，为无损连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60072cb4ea8cb04b1393bfd576f35ebf/" rel="bookmark">
			【数据库设计】求闭包和候选键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据库设计】求闭包和候选键 闭包 设F为R关系模式上的函数依赖集，被F所逻辑蕴含的全体构成的集合，称为F的闭包，记作F⁺
先来看一个例子。 关系R（A，B，C）满足下列函数依赖F（A → B，A→C，B→AC），求A的闭包
通俗的来讲，就是A能直接或者间接推出的属性的集合
A → B, A→C, A→BC, A→Φ, A→A
空集可以省略不写，因此，A的闭包为ABC，同时A也为R上的候选键（原因是什么我们后面再讲）
如果换一下求B的闭包，知道了原理，那也非常容易了
B→AC, B→A, B→C, B→B, B→Φ
因此，B的闭包也是ABC，B也为R上的候选键
求C的闭包呢？
C→Φ, C→C
因此C的闭包就是C
候选键 若K为R&lt; U,F&gt;上的一个属性集，如果U完全依赖于K，则称K为R上的候选键。
简单的来说，如果K的闭包为U的话，那么K就为R上的候选键
比如上面的R(A, B, C)，A的闭包为ABC，那么A就为R上的候选键，同理，B的闭包也为ABC，则B也为R上的候选键，C的闭包为C，因此，C不是R上的候选键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18dfb5e0f6112da6cc3495f51be6b6d2/" rel="bookmark">
			如何理解内网和外网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何理解内网和外网 写这篇博文的动力来自于，大狗问我什么是内网和外网（没错，我就是站在程序猿顶端的有女票的程序猿:p），一个惊讶，为什么她会问这样的问题，在现实生活中，不管你是不是做it，是否触及it领域，内网和外网这个词已经被用的人人知晓，但是真的是大家都懂内网和外网的概念吗，嘿！别急，这篇文章就是来解决你的疑惑的。
内网和外网的区别 划分内网和外网的重要依据主要是判断它是不是与广阔的外界相连。 此时我们可以说，局域网就是内网，internet就是外网，当然，内网和外网不是绝对的概念，而是相对的，比如你在一个单位上班，你们单位有个庞大的局域网，你办公室的几台电脑组成小的局域网，那么可以说单位的大局域网是外网，而办公室的小局域网是内网。
很好理解对吧
我们再来看看内网的疑惑
内网的疑惑 首先上一张OSI/RM七层模型，这是早期为了解决不同网络标准之间通信所制定的模型，放到现在也依然使用
通常来说，局域网是属于链路层的，也就是说，通过交换机就能够搭建起一个简单的局域网，在这个局域网内通信，我们称为内网通信。
那么如何判断是否在一个局域网内呢？
功臣tcp/ip协议的网际层的ip协议为每个电脑都分配了一个ip地址，我们可以通过ip地址与子网掩码进行运算，得出的结果相同，就证明在一个局域网内，需要明确的是，局域网内是可以直接通信的，因为局域网属于第二层，不需要经过网络层转发数据包。
什么是内网ip ipv4是目前比较广泛使用的一个版本，它是由32位二进制数组成的，但是ip毕竟是有限的，随着计算机的爆炸性增长和移动网络的普及，ip地址越来越不够用，于是出现了一门技术叫NAT技术，NAT（Network Address Translation）网络地址转换，就是替换ip报文头部的地址信息。NAT通常部署在一个组织的网络出口位置，通过将内部网络IP地址替换为出口的IP地址提供公网可达性和上层协议的连接能力。那么，什么是内部网络IP地址？ RFC1918规定了三个保留地址段落：10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255。这三个范围分别处于A,B,C类的地址段，不向特定的用户分配，被IANA作为私有地址保留。这些地址可以在任何组织或企业内部使用，和其他Internet地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到Internet，就可以使用这些地址而不用向IANA提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。 简单的来讲，计算机在内网会获得一个ip地址，这个地址被称作内网ip，它仅仅是在内网内不能重复，当内网的一台计算机想要跟外网通信的时候，需要通过NAT做ip转换，也就是把计算机的内网ip转换为外网ip。这样可以大大的缓解ip数量危机。
外网的疑惑 那什么是外网呢？简单的说，外网就是广阔的外界。内网与广阔的外界通信，就是在与外网通信，首先需要明确的是，计算机网络是计算机技术和通信技术的结合，三台计算机之间的通信也能叫计算机网络，早期的ARPANET就是由少量计算机相连构建的网络。网络最重要的作用也就是数据通信与资源共享了，你访问一个网页，其实也是在跟服务器通信，也是在访问服务器上的一个文件而已，通过服务器返回的文件，经过浏览器的渲染机制才呈现在了你的面前。总的来说，外网不仅仅是WAN，而与局域网外的通信都可以叫做与外网通信，比如开头的例子，你们单位有个庞大的局域网，你办公室的几台电脑组成小的局域网，那么可以说单位的大局域网是外网，而办公室的小局域网是内网。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b2c775d54e9358d479549d8f955cdbb/" rel="bookmark">
			Cocos2dx使用spine骨骼动画导致在iphone6s、iphone7真机闪退的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在cocos2dx 3.x版本中，在某些情况下使用了spine骨骼动画和LayerColor，可能会导致在iphone6s，和iphone7真机上闪退，其他机型正常，xCode调试发现是在LayerColor::onDraw glDrawArrays(GLTRIANGLE_STRIP, 0, 4)这个方法中崩溃的，网上找到一篇国外开发者的解决方法，经过测试确实可用。（国外解决方法原文地址：https://github.com/cocos2d/cocos2d-x/issues/16543） 解决办法： 1、找到 PolygonBatch::flush这个方法； 2、将： GL::bindVAO(0); glEnableVertexAttribArray(GLProgram::VERTEX_ATTRIB_POSITION); glEnableVertexAttribArray(GLProgram::VERTEX_ATTRIB_COLOR); glEnableVertexAttribArray(GLProgram::VERTEX_ATTRIB_TEX_COORDS); 替换为：
GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POSITION | GL::VERTEX_ATTRIB_FLAG_COLOR | GL::VERTEX_ATTRIB_FLAG_TEX_COORD); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49203040b6dad35456eeed51f0f46a41/" rel="bookmark">
			图片上传压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;XMLHttpRequest上传文件&lt;/title&gt; &lt;script type="text/javascript"&gt; /* 三个参数 file：一个是文件(类型是图片格式)， w：一个是文件压缩的后宽度，宽度越小，字节越小 objDiv：一个是容器或者回调函数 photoCompress() */ function photoCompress(file,w,objDiv){ var ready=new FileReader(); /*开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容.*/ ready.readAsDataURL(file); ready.οnlοad=function(){ var re=this.result; canvasDataURL(re,w,objDiv) } } function canvasDataURL(path, obj, callback){ var img = new Image(); img.src = path; img.onload = function(){ var that = this; // 默认按比例压缩 var w = that.width, h = that.height, scale = w / h; w = obj.width || w; h = obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49203040b6dad35456eeed51f0f46a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf873d665a3d4bea3bbda47412a43a5/" rel="bookmark">
			Python--操作数据库class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import pymysql
class OpMySql1: # 经典类
pass
class OpMySql(object): # 新式类
def __init__(self, host, user, password, db, port=3306, charset='utf8'):
schema = {
'user': user,
'host': host,
'password': password,
'db': db,
'port': port,
'charset': charset
}
try:
self.coon = pymysql.connect(**schema)
except Exception as e:
print('数据库连接异常！%s' % e)
quit()
else: # 没有异常的情况下，建立游标
self.cur = self.coon.cursor(cursor=pymysql.cursors.DictCursor)
def execute(self, sql):
try:
self.cur.execute(sql)
except Exception as e:
print('sql语句有错误！%s' % e)
return e
if sql[:6].upper() == 'SELECT':
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caf873d665a3d4bea3bbda47412a43a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f27e2706a2dde947b47087d8a64c5c13/" rel="bookmark">
			关于JAVA中的Class.cast方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日看到了一片文章就是说的Class.cast()方法，我感觉这篇文章有问题，所以写了一片文章来说明一下cast方法。
我们来看一下JDK中这个方法的源码！
@SuppressWarnings("unchecked") public T cast(Object obj) { if (obj != null &amp;&amp; !isInstance(obj)) throw new ClassCastException(cannotCastMsg(obj)); return (T) obj; }
其中return (T) obj;就是强制转换成你所需要的类型，相当于你自己写（假设有A和B两个类，B继承了A类）：
A a = (A) b1; cast方法不过是给你做了一些安全措施而已。下面说明方法中的泛型T，我们参照下面这个列子，将ServletRequest转换成HttpServletRequest：
HttpServletRequest request = HttpServletRequest.class.cast(req);
以下是截图：
这个泛型T就是自动判断你要转换成什么类型，这也是一个安全措施！
网上的这个说法我认为是错误的 （假设有A和B两个类，B继承了A类）： 输出
这个说法是错误的，其实就是把b1类型强制转换成了A类型，此时a指向b1（父类引用指向子类对象），之所以a.getClass()输出的是B类型，这是因为对象在获取Class（a.getClass()）的时候和类.class（A.class）不同(a.getClass()返回引用a运行时真正所指的对象(因为:儿子对象的引用可能会赋给父对象的引用变量中)所属的类的Class的对象)，具体可以参考:http://blog.sina.com.cn/s/blog_7ffb8dd5010127ix.html
如果有错误，请多多指正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d876767f7a8aafb1d052bd7d574edb0e/" rel="bookmark">
			git 使用——git从远程仓库下载项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于如何从最开始使用 git 及从本地上传项目到GitHub 上述过程中关联GitHub仓库完成后，即可从GitHub上下载项目到本地。 在想要保存项目的路径下右键点击Git Bash Here，输入命令 git clone http://github.com/userName/gitName.git 最后一个是库的url，打开GitHub可以找到 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80983a59f44c0dc231dbd3552c5cfd46/" rel="bookmark">
			Java 按照多个字段对集合去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Comparator; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; import java.util.TreeSet;
public class JavaUtil {
public static &lt;T&gt; List&lt;T&gt; filterList(List&lt;T&gt; list,String... args){ //如果没有数据，无需去重 if (null == list || list.isEmpty()){ return new ArrayList&lt;T&gt;(); } //set集合去重复 Set&lt;T&gt; set = new TreeSet&lt;T&gt;(new Comparator&lt;T&gt;() { @SuppressWarnings({ "unchecked", "rawtypes" }) public int compare(T o1, T o2) { Class clazz1 = o1.getClass(); Class clazz2 = o2.getClass(); Method mv1; Method mv2; try { //比较参数的个数 //int size = args.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80983a59f44c0dc231dbd3552c5cfd46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e31e0aa32e1a98bc21915990674a0c28/" rel="bookmark">
			Homestead环境报错Bringing machine ‘default’ up with ‘virtualbox’ provider…
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间：2017-02 环境：win7（64bit） Bringing machine ‘default’ up with ‘virtualbox’ provider… Your VM has become “inaccessible.” Unfortunately, this is a critical error with VirtualBox that Vagrant can not cleanly recover from. Please open VirtualBox and clear out your inaccessible virtual machines or find a way to fix them. 解决方 案 ： Google了一下解决办法，有篇blog说直接删除vagrant目录下生成的.vagrant隐藏文件即可，该blog下的七八个comments都表示这个方法有效。不过这个方法并没有解决我的问题。
再仔细看了看vagrant无法访问的提示：Please open VirtualBox and clear out your inaccessible virtual machines or find a way to fix them.看到这句话，于是打开virtualbox界面，virtualbox也提示该虚拟机无法启动，是因为C:\Users\denglj\VirtualBox VMs\vagrant_default_1411538218356_15372\vagrant_default_1411538218356_15372.vbox文件不存在。于是进入该文件的目录，发现并没有后缀为.vbox文件，而是多了一个.vbox-tmp的文件。
抱着试试的想法，简单地将该文件后缀中的-tmp去掉，在执行vagrant up命令，成功了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e31e0aa32e1a98bc21915990674a0c28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e3fd7f47ac0d62dc6b7b215acb9d630/" rel="bookmark">
			Homestead环境报错 There was an error while executing `VBoxManage`
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间：2018-01-22
环境：win7（64bit）
第一种情况 $ vagrant up
There was an error while executing `VBoxManage`, a CLI used by Vagrant
for controlling VirtualBox. The command and stderr is shown below.
Command: ["showvminfo", "6437a12d-a98c-4365-9b76-01864dfc0eb8"]
Stderr: VBoxManage.exe: error: Failed to create the VirtualBox object!
VBoxManage.exe: error: Failed to instantiate CLSID_VirtualBox w/ IVirtualBox, but CLSID_VirtualBox w/ IUnknown works.
VBoxManage.exe: error: PSDispatch looks fine. Weird
VBoxManage.exe: error: Details: code E_NOINTERFACE (0x80004002), component VirtualBoxClientWrap, interface IVirtualBoxClient
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e3fd7f47ac0d62dc6b7b215acb9d630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e9f607c08b577cccb6f0c0ee71a70e/" rel="bookmark">
			windows下docker toolbox无法下载boot2docker.iso
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 到 docker toolbox 安装目录下例如（C:\Program Files\Docker Toolbox）,复制boot2docker.iso到 %HOMEPATH%\.docker\machine\cache 目录,重新打开Docker Quickstart Terminal就行了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c376e925b71c1dc4e6dc577e08a8083d/" rel="bookmark">
			maven安装本地jar包到本地仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		！！！！一定要用纯文本粘贴到命令行
步骤1. 在命令行里运行:
mvn install:install-file -Dfile=jar包的绝对位置 -DgroupId=pom文件依赖的groupId -DartifactId=pom文件依赖的artifactId -Dversion=pom文件依赖的version -Dpackaging=jar 例:
mvn install:install-file -Dfile=F:\mavenproject\task6\jnshu\lib\Sdk4J.jar -DgroupId=com.mycom.myapp -DartifactId=sdk4j -Dversion=1.0 -Dpackaging=jar 步骤2. 在pom文件里添加:
&lt;dependency&gt; &lt;groupId&gt;com.mycom.myapp&lt;/groupId&gt; (这个是这个jar包在.m2仓库中的文件地址)
&lt;artifactId&gt;sdk4j&lt;/artifactId&gt; (这个是jar文件去掉.jar后缀的名称)
&lt;version&gt;1.0&lt;ersion&gt; (jar包版本)
&lt;/dependency&gt; 图示 1
2.
3.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d163626e72926f2f8889d5a50b96e999/" rel="bookmark">
			thunderbird 雷鸟中文版下载,安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开官网:https://www.mozilla.org/en-US/thunderbird/
z
找到简体中文版本
2.下载安装包直接安装就行,好像是只能安装在C盘
3.如果在绑定邮箱遇到"配置无法被验证的问题"时,参考
http://blog.csdn.net/qingshantang/article/details/79094087
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f30fbe1df69ad8259cc88719f6b667/" rel="bookmark">
			微信小程序页面带参数跳转及接收参数内容navigator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能从index页面跳转到draw页面，并在draw页面获取id及imgUrl index.wxml
&lt;navigator class='looks-view' wx:for="{{imgUrlNew}}" wx:key="index" url="/pages/draw/draw?id={{item.id}}&amp;imgUrl={{item.img}}"&gt; &lt;image src='{{item.img}}' class='looks-view-image'&gt;&lt;/image&gt; &lt;text class='looks-view-text'&gt;{{item.name}}&lt;/text&gt; &lt;/navigator&gt; 在draw.js中：
data: { id:'', imgUrl:'' }, onLoad: function (options) { this.setData({ id: options.id, imgUrl: options.imgUrl }) }, 很简单，这样就可以获取了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a973b93ab1e7c076be087a45e224c329/" rel="bookmark">
			thunderbird 配置无法被验证问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题:安装thunderbird后绑定邮箱发现虽然我账号密码都是正确的,但是绑定的时候会报错:配置无法被验证-请查看用户名或密码是否正确
解决办法:
一.绑定QQ邮箱
登录qq邮箱--点击设置--点击账号--下拉找到账户安全--点击开启(IMAP/SMTP服务)--按要求发送短信--复制授权码--重新回到thunderbird绑定QQ邮箱--粘贴授权码代替密码--点击完成
二.绑定网易邮箱
验证失败--点击手动配置--在服务器主机名中添加"ym"--点击完成
三.绑定QQ企业邮箱
参考网易邮箱
其他邮箱应该同理,没试...
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/200/">«</a>
	<span class="pagination__item pagination__item--current">201/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/202/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>