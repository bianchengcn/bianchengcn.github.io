<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26dea960d489c87efa917905567070d7/" rel="bookmark">
			【Java基础知识 1】Java入门级概述，让阿里架构师告诉你为什么要分库分表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1998年12月8日，第二代Java平台的企业版J2EE发布。
1999年4月27日，HotSpot虚拟机发布。
2005年6月，在Java One大会上，Sun公司发布了Java SE 6。此时，Java的各种版本已经更名，已取消其中的数字2，如J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME。
2009年，甲骨文公司宣布收购Sun。
2014年3月Oracle发布正式版JDK8，JDK8改进比较多，最大的改进是Lambda表达式（以及因之带来的函数式接口，很多原有类都做了变更，但能够与以往版本兼容，堪称奇功！），还有Stream API流式处理，joda-time等等一些新特性。
二、JDK 与 JRE
JDK：java development kit （java开发工具）
JRE：java runtime environment （java运行时环境）
JVM：Java Virtual Machine （java虚拟机）
1、jdk–开发环境（核心）
Java development kit的缩写，意思是Java开发工具，我们写文档做PPT需要office 办公软件，开发当然需要开发工具了，说到开发工具大家肯定会想到Eclipse，但是如果直接安装Eclipse你会发现它是运行不起来 是会报错的，只有安装了JDK，配置好了环境变量和path才可以运行成功。这点相信很多人都深有体会。
jdk主要包含三个部分：
第一部分是Java运行时环境，JVM
第二部分是Java的基础类库，这个类库的数量还是相当可观的
第三部分是Java的开发工具，它们都是辅助你更好地使用Java的利器jre–运行环境
2、jre–运行环境
① jdk中的jre
如下图：jdk中包含的jre，在jre的bin目录里有个jvm.dll，既然JRE是运行时环境，那么运行在哪？肯定是JVM虚拟机上了。另，jre的lib目录中放的是一些JAVA类库的class文件，已经打包成jar文件。
② 第二个JRE（独立出来的运行时环境）
如下图，不管是JDK中的JRE还是JRE既然是运行时环境必须有JVM。所以JVM也是有两个的。
3、JVM——转换环境
Java Virtual Machine （java虚拟机）的缩写。
大家一提到JAVA的优点就会想到：一次编译，随处运行，说白了就是跨平台性好，这点JVM功不可没。
Java的程序也就是我们编译的代码都会编译为class文件，class文件就是在jvm上运行的文件，只有JVM还不能完全支持class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。
JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改的运行。
JVM也是一门很深的学问，感兴趣的同学可以深入研究，只有好处，没有坏处。
其实有时候面试官问JDK和JRE的区别的目的不是想让你解释什么名词的，而是想看看你的基础和研究Java的深浅，还有另一方面就是你是不是经常喜欢问为什么。
三、语言的五大特性
万物皆对象
程序就是多个对象彼此调用方法的过程
从内存角度而言，每个对象都是由其它更基础的对象组成的
每一个对象都有类型，都可以进行实例化
同一类型的对象可以接收相同的消息
面向对象编程的最大挑战就是如何在问题空间的元素和解决方案空间的对象之间建立一对一的关联。
四、对象间的四种关系
1、依赖 依赖关系表示一个类依赖于另一个类的定义。例如，一个人(Person)可以买车(car)和房子(House)，Person类依赖于Car类和House类的定义，因为Person类引用了Car和House。与关联不同的是，Person类里并没有Car和House类型的属性，Car和House的实例是以参量的方式传入到buy()方法中去的。一般而言，依赖关系在Java语言中体现为局域变量、方法的形参，或者对静态方法的调用。
2、关联 关联(Association）关系是类与类之间的联接，它使一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的。在Java语言中，关联关系一般使用成员变量来实现。
3、聚合 聚合(Aggregation) 关系是关联关系的一种，是强的关联关系。聚合是整体和个体之间的关系。例如，汽车类与引擎类、轮胎类，以及其它的零件类之间的关系便整体和个体的关系。与关联关系一样，聚合关系也是通过实例变量实现的。但是关联关系所涉及的两个类是处在同一层次上的，而在聚合关系中，两个类是处在不平等层次上的，一个代表整体，另一个代表部分。
4、组合 组合(Composition) 关系是关联关系的一种，是比聚合关系强的关系。它要求普通的聚合关系中代表整体的对象负责代表部分对象的生命周期，组合关系是不能共享的。代表整体的对象需要负责保持部分对象和存活，在一些情况下将负责代表部分的对象湮灭掉。代表整体的对象可以将代表部分的对象传递给另一个对象，由后者负责此对象的生命周期。换言之，代表部分的对象在每一个时刻只能与一个对象发生组合关系，由后者排他地负责生命周期。部分和整体的生命周期一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26dea960d489c87efa917905567070d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ab49ddc99d327eea79d4cf0298f0373/" rel="bookmark">
			内网安全攻防读书笔记（2）——powershell基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.基本概念1.1 .ps1文件1.2 执行策略1.3 管道 2.常用命令2.1 文件操作命令2.2 绕过本地权限并执行2.3 使用base64对PowerShell命令进行编码2.3 运行32位和64位powershell powershell是windows的一种命令行外壳程序。只要一台计算机上可以运行代码，就可以将powershell脚本文件执行，甚至无需写入到磁盘中。powershell拥有以下几个重要的特点： 脚本可以在内存中运行，不需要写入到磁盘中。可以远程执行。可用于管理活动目录。 使用以下命令，可以查看powershell的版本和进入powershell命令行：
powershell Get-host $PSVersionTable.PSVERSION 1.基本概念 1.1 .ps1文件 .ps1文件是powershell脚本文件的拓展名。其中包含一系列Powershell命令，每个命令显示为独立的一行。
1.2 执行策略 为了防止运行恶意脚本，powershell在默认情况下，这个执行策略被设置为“不能运行”。执行下面的cmdlet命令查询当前的执行策略：
Get-ExecutionPolicy )
执行策略有下面几种类型：
Restricted：脚本不能运行（默认设置）。RemoteSigned：在本地创建的脚本可以运行，但从网上下载的脚本不能运行（拥有数字证书签名的除外）AllSigned：仅当脚本由受信任的发布者签名时才能运行。Unrestricted：允许当前所有脚本执行。 可以执行下面的命令设置执行策略：
Set-ExecutionPolicy &lt;policy-name&gt; 1.3 管道 管道的作用是将一个命令的输出作为另外一个命令的输入，两个命令之间用‘’|‘’连接。如下面一个例子，让所有运行的、名字以字符“p”开头的程序停止运行。
get-process p* | stop-process 2.常用命令 2.1 文件操作命令 基础命令基本兼容shell Linux，下面是文件操作常用命令：
New-Item vuln -ItemType Directory 新建目录 New-Item 1.txt -ItemType File 新建文件 Remove-Item .\while\ 删除目录 Get-Content .\1.txt 显示文本内容 Set-Content .\1.txt -Value "hello world!" 设置文本内容 Add-Content .\1.txt -Value "i love you"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ab49ddc99d327eea79d4cf0298f0373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6b9d233c7402951ca6efd1e988b67c/" rel="bookmark">
			EasyTouch对图片进行缩放 设置缩放的大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using HedgehogTeam.EasyTouch;
using System.Collections;
public class UIScale : MonoBehaviour
{
private TextMesh textMesh;
//限制缩小的最小值
public float min;
//限制放大的最大值
public float max;
// Subscribe to events void OnEnable() { EasyTouch.On_TouchStart2Fingers += On_TouchStart2Fingers; EasyTouch.On_PinchIn += On_PinchIn; EasyTouch.On_PinchOut += On_PinchOut; EasyTouch.On_PinchEnd += On_PinchEnd; } void OnDisable() { UnsubscribeEvent(); } void OnDestroy() { UnsubscribeEvent(); } // Unsubscribe to events void UnsubscribeEvent() { EasyTouch.On_TouchStart2Fingers -= On_TouchStart2Fingers; EasyTouch.On_PinchIn -= On_PinchIn; EasyTouch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6b9d233c7402951ca6efd1e988b67c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e2260515a2ea9bfbae59365ffc60f7/" rel="bookmark">
			vue-cli2和vue-cli3下的lib-flexible适配（移动端&#43;大屏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 lib-flexible 是淘宝项目组开发的一个插件，用于移动端适配，但 lib-flexible 往往并不独立出现，而是搭配 px2rem-loader 自动将css中的px转换成rem来一起做适配方案。
1. 移动端适配 lib-flexible本身就是用来做移动端适配，故使用很简单，不需要修改什么。至于 px2rem-loader，笔者没有在移动端实践过，故只是在此记录一下使用步骤。
1.1 安装 lib-flexible npm install lib-flexible --save-dev 1.2 引入 lib-flexible 在入口文件中引入lib-flexible
// main.js import 'lib-flexible' 1.3 安装 px2rem-loader npm install px2rem-loader --save-dev 1.4 配置 px2rem-loader 1.4.1 vue-cli 2.x 1、在build/utils.js下的exports.cssLoaders添加
// 增加代码，px转rem配置（需要将px2remloader添加进loaders数组中） const px2remLoader = { loader: 'px2rem-loader', options: { remUnit: 75, //以设计稿750为例， 750 / 10 } } 2、修改build/utils.js下generateLoaders中的loaders配置
// 注释掉这一行 // const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader] // 修改为 const loaders = options.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e2260515a2ea9bfbae59365ffc60f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a60f9bb064619c07b4a5725ba7ae9cb/" rel="bookmark">
			编译原理 实验4 语义分析（基于PL/0，使用C&#43;&#43;代码编写）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 实验任务2 实验内容3 错误类型声明4 文件结构与代码4.1 代码结构4.2 详细代码4.3 递归下降子程序的声明 5 常变量说明6 运行结果 1 实验任务 审查每一个语法结构的静态语义，即验证语法正确的结构是否有意义。此部分不再借助已有工具，需手写代码来完成。
2 实验内容 （1）实验要求
你的程序需要对输入文件进行语义分析并检查错误进行输出。
（2）输入格式
一个包含源代码的文本文件，程序需要能够接收一个输入文件名作为参数。
（3）输出格式
要求通过标准输出打印程序的运行结果。对于那些没有语义错误的输入文件，你的程序不需要输出任何内容。对于那些存在语义错误的输入文件，你的程序应当输出相应的错误信息，这些信息包括错误类型、出错的行号以及说明文字，其格式为：
Error type [错误类型] at Line [行号]: [说明文字].
3 错误类型声明 自定义错误类型如下（与C–重合的部分不再给出补充说明）：
错误类型 1：变量在使用时未经定义。错误类型 2：函数在调用时未经定义。错误类型 3：变量出现重复定义，或变量与前面定义过的结构体名字重复。错误类型 4：函数出现重复定义（即同样的函数名出现了不止一次定义）。
说明：在测试此功能时，要注意PL/0不能将变量定义在begin、end内，只能在过程体外部定义。否则会引发过程相关的错误。错误类型 5：赋值号两边的表达式类型不匹配。
说明：改进的PL/0 类型只有常量、变量、过程类型。它们三者互相赋值会导致此错误，事实上，只有左部为变量类型才是合法的赋值。
同时，常量只能由数字赋初值。错误类型 6：操作数类型不匹配或操作数类型与操作符不匹配。
说明：当因子为过程或其他非法值时，使得操作数不合法或表达式运算不合法。错误类型 7：过程声明格式不正确（procedure后不为标识符）（原：return 语句的返回类型与函数定义的返回类型不匹配。）
说明：PL/0仅有过程体，无返回值。故进行如上修改。错误类型 8：read或write函数的调用不完整（括号缺失）（原：函数调用时实参与形参的数目或类型不匹配。）
说明：PL/0调用过程无参数。但read和write需要参数，故进行如上修改。错误类型 9：read函数的参数不是id（原：对非数组型变量使用“[…]”（数组访问）操作符。）
说明：改进的PL/0无数组。错误类型 10：调用函数格式非法（call后不为过程标识符）（原：对普通变量使用“(…)”或“()”（函数调用）操作符。） 说明：PL/0与C–调用方式不同。
前十个错误类型是对C–相关错误的进行一定修改，以下是结合书后代码新增的一些错误类型。有些错误设计后在实际测试时发现不合适就删除了，下面只给出保留部分的声明。
错误类型 11：缺少赋值符号或赋值符号不正确。错误类型 12：一条语句定义（多个）常量或变量时漏掉了逗号或者分号/过程结束时漏了分号。错误类型 14：数字过长。错误类型 16：if后缺少then语句。错误类型 18：while语句缺少do。错误类型 19：地址超出上界。错误类型 20：逻辑表达式不合法（逻辑符号不合法）。错误类型 21：因子标识符为过程。错误类型 22：应输入)，表达式不完整。错误类型 24：程序不以.结尾。 4 文件结构与代码 算法在处理上的词法分析思路与第一个实验一致（专栏实验1），而语法分析则**采用了递归下降（专栏实验2）**的方法，在此基础上做出改进并进行了出错处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a60f9bb064619c07b4a5725ba7ae9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/906bbe1763cb0b2ba94f8e63c52a5b10/" rel="bookmark">
			Java-String长度限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 String数据结构限制JVM规范限制总结 String数据结构限制 Java中String用char value[]存储：
/** The value is used for character storage. */ private final char value[]; String长度length()取自数组长度，返回类型是int
/** * Returns the length of this string. * The length is equal to the number of &lt;a href=" "&gt;Unicode * code units&lt;/a &gt; in the string. * * @return the length of the sequence of characters represented by this * object. */ public int length() { return value.length; } 从这方面看，String的长度上限应该是Java中int的上限，即 2^31 - 1 = 2147483647，在Java中 char类型占2 byte（Character.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/906bbe1763cb0b2ba94f8e63c52a5b10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31332c588835fe0f02f401232f4b111/" rel="bookmark">
			简单的递归思想： gcd（最大公因数）&#43;hanoi（汉诺塔）&#43;quicksort（快排）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、gcd（求最大公因数）
二、hanoi（描述汉诺塔）
三、quicksort（快排）
上次博客本是说这周分享算法的，后来还是想先分享一下递归思想。递归在编程学习中可谓是无处不在，计算机的所有运算拆分开都是递归。比如1+2，可以拆成1+（1+1），同理，所有的加减乘除都可以拆成1+1的式子，这就是递归。给一个拆分的路径，不断地将一个式子递归拆分成一个个小式子，化繁为简。
下面我们用三个经典递归（gcd，hanoi，quicksort）来走进这种思想。
一、gcd（求最大公因数） 求最大公因数，不得不提的就是辗转相除法，也叫欧几里得算法。具体操作：用两数中的较大数除以较小数，之后以除数作被除数，余数作除数，不断相除，以致最后一次余数等于零，此时除数位上的数就为原来两个数的最大公因数。
拿一个具体的例子来说：求20与12的最大公因数。
第一步：20%12==1......8
第二步：12%8==1......4
第三步：8%4==2......0
此时余数已为0，所以20与12的最大公因数为除数位置上的4，即gcd(20,12)==4、
那么用代码如何去实现呢？根据直观感受，我们可以这样写：
int gcd(int x, int y)//自定义函数，确保两数中，x&gt;y { int yu = x % y;//余数 while (yu)//循环至余数等于零 { x = y; y = yu; yu = x % y; } return y;//此时的除数就为最大公因数 } 但结合除数一定大于余数的知识和递归思想，我们却能进一步简化：
int gcd(int x, int y) { return x % y == 0 ? y : gcd(y,x%y); } 一个条件表达式，x%y==0吗，即余数等于0吗，如果等于，说明此时有我们想要的y值，如果不等于，继续调用gcd函数本身，依次下去，直到求出最大公因数。好好领悟，只有一行语句（当然也得保证第一次的形参是x&gt;y），是不是简化了特别多？这就是递归奇妙的地方，当你找到某种规律时，递归很有可能就会派上用场。
二、hanoi（描述汉诺塔） 汉诺塔（Tower of Hanoi），又称河内塔，是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
——《百度百科》
我们现在假设有这样一个情形：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b31332c588835fe0f02f401232f4b111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51798fa0ca4ffeb1d5c9f0864a0ce6c8/" rel="bookmark">
			linux使用usermod修改用户主目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux使用usermod修改用户主目录 介绍usermod命令的基本语法是usermod要求usermod 的选项1. 向用户账户添加信息2. 更改用户主目录3. 设置用户账户到期日4. 更改用户主要组5. 向现有用户添加组6. 为用户添加补充组和主组7. 更改用户登录名8. 锁定用户账户9. 解锁用户账户10. 将用户主目录移动到新位置11. 为用户创建未加密的密码12. 更改用户shell13. 更改用户 ID (UID)14. 使用多个选项修改用户帐户15. 更改用户的 UID 和 GID 介绍 创建用户帐户后，在一些需要更改现有用户属性的场景中，例如更改用户的主目录、登录名、登录 shell、密码到期日期等，在这种情况下使用 usermod 命令。
当我们在终端中执行 usermod 命令时，会使用和影响以下文件。
/etc/passwd– 用户帐户信息。/etc/shadow– 帐户密码信息。/etc/group– 组帐户信息。/etc/gshadow– 组密码信息。/etc/login.defs– 是设置用户帐号限制的文件。该文件里的配置对root用户无效。 usermod命令的基本语法是 usermod [options] username usermod要求 我们必须有现有的用户帐户才能执行 usermod 命令。
只允许超级用户（root）执行 usermod 命令。
usermod 命令可以在任何 Linux 发行版上执行。
必须具有带选项的 usermod 命令的基本知识
usermod 的选项 这 usermod 命令使用起来很简单，有很多选项可以对现有用户进行更改。让我们通过以下选项的帮助，通过修改 Linux box 中的一些现有用户来看看如何使用 usermod 命令。
-c= 我们可以为用户帐户添加评论字段。-d= 修改任何现有用户帐户的目录。-e= 使用此选项，我们可以使帐户在特定时期到期。-g= 更改用户的主要组。-G= 添加补充组。-a= 将组中的任何人添加到辅助组。-l= 将登录名从 rumenz 更改为 rumenz_admin。-L= 锁定用户帐户。这将锁定密码，因此我们无法使用该帐户。-m= 将主目录的内容从现有主目录移动到新目录。-p= 使用未加密的密码作为新密码。（不安全）。-s= 为新帐户创建一个指定的 shell。-u= 用于为 0 到 999 之间的用户帐户分配 UID。-U= 解锁用户帐户。这将删除密码锁并允许我们使用用户帐户。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51798fa0ca4ffeb1d5c9f0864a0ce6c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c724fe6e47c309ac2eebccbc84b80ce4/" rel="bookmark">
			Python学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9.24
===============================================================================================================
一、课程学习资源：
1.www.runoob.com 2.www.liaoxuefeng.com
3.www.csdn.net
4.B站
5.个人CSDN博客主页https://blog.csdn.net/WQ0025?spm=1020.2143.3001.5343
二、知识要点 1.编程语言的种类
低级语言（1）机器语言
（2）汇编语言
高级语言（3）高级语言
（4）超级语言(python)
2.学习方法：
先学习----后模仿----在自主创新
3.静态语言 (编译）：C语言、Java语言
脚本语言（解释）：python语言、JavaScript语言、PHP语言
4.两种编程方式：
（1）交互式(Read-Eval-Print-Loop)
（2）文件式（必须先保存 Ctrl+N 在保存Ctrl+S 最后在执行F5）
5.编程的基本编写方法（IPO）:
(1)I:input()程序的输入（提出问题）
(20P:process程序的逻辑处理（分析问题）
（3）O:output()程序的输出（解决问题）
6.编程的基本步骤：
（1）确定IPO（Input-process-output）
(2)编写程序
（3）调试程序
7.基本的语法元素：
（1）程序框架
缩进：一般情况下四个空格或者一个Tab，有单层或多层缩进
注释：单行注释（#），独写一行或者在一行代码的最后。
多行注释，三单引号（'''...........'''）或者三双引号（"""........."""）
命名:（标识符）：大小写字母、数字、下划线（shift+-）和汉字（不能单独出现），第一个字符不能是数字。
10.9
===============================================================================================================
对象：身份、类型（type）、值（value）---常量、变量
变量
保留字：import and as class if or pass from try with in is else not return true while
assert continue break def finally except elif lambda del yield raise global nonlocal none
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c724fe6e47c309ac2eebccbc84b80ce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba6538a4a2897b381058e94ed9f5e925/" rel="bookmark">
			第六章：S7-200 SMART PLC的功能指令与应用(查表型)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些简单的指令就不讲了，我只讲一些我不会的 数据传送指令 数学运算指令 四则运算 递增（INC）递减（DEC） 书上还有一个有意思的例题，或许用得上 与 或 异或 取反 移位 剩下的数据转换就不拍了吧
这篇文章作为一个查表类型的文章吧…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4720ce58bfa174ce0d4390d1202a0e35/" rel="bookmark">
			Delphi7 如何调整背景色为黑色容易护眼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开开发工具
2.在编辑区域，鼠标右键
3.选择properties-&gt;color -&gt;color speedsettting:Twilight
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91ac9c65a4c2fa0d2f2fdfa095e979aa/" rel="bookmark">
			Shrio 自定义算法登录认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.实现shrio SimpleCredentialsMatcher的doCredentialsMatch算法 package cn.steven.manager.security; import cn.sh.ideal.manager.util.AESUtils; import org.apache.shiro.authc.AuthenticationInfo; import org.apache.shiro.authc.AuthenticationToken; import org.apache.shiro.authc.credential.SimpleCredentialsMatcher; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * @FileName: CustomCredentialsMatcher * @Author Steven * @Date: 2021/11/17 */ public class CustomCredentialsMatcher extends SimpleCredentialsMatcher{ private Logger logger = LoggerFactory.getLogger(getClass()); @Override public boolean doCredentialsMatch(AuthenticationToken authenticationToken, AuthenticationInfo info) { //获得前台传过来的密码 SystemUsernamePasswordToken token = (SystemUsernamePasswordToken) authenticationToken; //这是数据库里查出来的密码 String sqlOriginalPassword=(String)info.getCredentials(); boolean flag = AESUtils.aesEncrypt(String.valueOf(token.getPassword())).equals(sqlOriginalPassword); return flag; } } 2.自定义算法 package cn.sh.ideal.manager.util; import org.apache.commons.codec.binary.Base64; import sun.misc.BASE64Decoder; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91ac9c65a4c2fa0d2f2fdfa095e979aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e994e52ce9d7a3fa417cec957c91fca9/" rel="bookmark">
			关于IDEA创建Maven子项目pom.xml中没有parent标签的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在IDEA中创建Maven子项目，子项目中的pom.xml没有parent标签
其实在创建后刚开始有parent标签，等Maven加载完之后就没有了。
解决办法 pom.xml 中是项目的一些配置信息，我们可以手动加上parent标签解决，示例如下（注意看我的注释）： &lt;!--父标签，自然是父项目的一些信息--&gt; &lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;!--注意：这里是父项目的 artifactId--&gt; &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!--注意：这里是该子项目的artifactId--&gt; &lt;artifactId&gt;servlet-01&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; 点击 Maven 同步即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a885a1f59ae701906c1166a17331c811/" rel="bookmark">
			优雅地实现if-else（python版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 if-else版：
def if_else(operator,x,y): if operator=='mul': return x*y elif operator=='add': return x+y elif operator=='div': return x/y elif operator=='sub': return x-y else: return None 优雅版：
def dispatch_dict(operator,x,y): return { 'mul':lambda :x*y, 'add':lambda :x+y, 'div':lambda :x/y, 'sub':lambda :x-y }.get(operator,lambda :None)() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de2e124ddeadd9953e84cfc27cd5f211/" rel="bookmark">
			二叉树：后序遍历非递归算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分析：后序遍历是三种遍历中最难的一种，后序遍历的特点为左右根，并且也需要借助一个栈来完成，如图，虚线表示p,q最开始的位置，用r指向最近访问过的结点。首先从根节点开始，沿着根的左孩子，将左孩子依次进行入栈。当D入栈之后，由于D没有右孩子，所以将D出栈，此时r指向D。
D出栈之后读栈顶元素B，p指向B，发现B有右孩子，然后将右孩子E入栈。
然后判断栈顶元素E，E没有右孩子了，所以将E出栈，此时r指向E。
然后判断栈顶元素B，B的两个孩子都已经操作过了，所以B出栈，p指向A，判断栈顶元素A，A有右孩子，右孩子C入栈，此时r指向C。
判断栈顶元素C，C无右孩子，所以C出栈，此时栈中只剩A，A的两个孩子都已经操作过了，所以A也出栈，结束，最终后序遍历结果为：DBECA
算法思想：
1、沿着根的左孩子，依次入栈，直到左孩子为空；
2、读栈顶元素进行判定，若右孩子不空且未被访问，将右孩子执行第一步；
3、栈顶元素出栈。
代码：
void PostOrder(BiTree){ // 全篇❤ InitStack(s); BiTree *p=T,*r=NULL; // r标记最近访问过的结点 while(p!=NULL || !IsEmpty(s)){ if(p!=NULL){ push(s,p); // 一直向左走，左孩子入栈 p=p-&gt;lchild; } else{ GetTop(s,p); // 获取s的栈顶元素赋值给p // GetTop(s,p)意思就是判断栈顶元素的情况 //❤case one❤ if(p-&gt;rchild &amp;&amp; p-&gt;rchild!=r){ // 若右孩子存在且未被访问 p=p-&gt;rchild; // 就让右孩子 push(s,p) // 入栈 p=p-&gt;lchild; // 让右孩子向左 //上面三句意思就是让右孩子的左孩子一直入栈，一直向左走 } // ❤case two❤ else{ pop(s,p); // 右孩子为空或未被访问过，就出栈 visit(p-&gt;data); r=p; // r标记最近访问结点 p=NULL; // r置空 // 置空原因：因为这个结点已经出栈了 //继续指向就没必要了，置空后r不标记任何结点 } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1a2d65e9914e023ea3f0094d561fd5/" rel="bookmark">
			SQL注入知识梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.数字型和UNION注入2.数据库结构未知是如何得知数据表的字段名和表名？3.字符型注入和布尔注入3.1 字符型注入3.2 布尔盲注 4.报错注入5.堆叠注入6.二次注入7.注入点7.1 SELECT注入7.2 insert注入7.4 update注入7.4 delete注入 8.注入的防御8.1 字符替换8.2 逃逸引号 1.数字型和UNION注入 有如下数据库结构：
&lt;?php require_once 'conn.php'; $res = mysqli_query($conn,"select title,content from wp_news where id=".$_GET['id']); $row = mysqli_fetch_array($res); echo "&lt;center&gt;"; echo"&lt;h1&gt;".$row['title']."&lt;/h1&gt;"; echo "&lt;br&gt;"; echo "&lt;h1&gt;".$row['content']."&lt;/h1&gt;"; echo "&lt;/center&gt;"; ?&gt; 示例的部分代码如上，下面演示SQL注入攻击过程：
访问链接：http://x.x.x.x/sql/sql1.php?id=2
再去访问：http://47.94.144.61/sql/sql1.php?id=3-1
可以看到页面仍然显示和之前id=2一样的结果，说明mysql对’3-1‘进行了计算，结果为2。从数字运算这个特征行为可以判断该注入点为数字型注入，表现为输入点“$_GET[‘id’]”附近没有引号包裹。select title,content from wp_news where id=1 union select user,pwd from wp_user;
这个SQL语句的作用是查询新闻表中id=1时对应行的title、content字段的数据，并且联合查询用户表中的user、pwd（即账号密码字段）的全部内容。此时我们构造pauload，http://x.x.x.x/sql/sql1.php?id=1 union select user,pwd from wp_user，但是发现只显示了一行内容，事实上，MySQL确实查询出了两行记录，但是PHP代码决定了该页面只显示一行记录，所以我们需要将账号密码的记录显示在查询结果的第一行。有两种方法：
（1）使用limit 1,1 语句：http://x.x.x.x/sql/sql1.php?id=1 union select user,pwd from wp_user limit 1,1
（2）指定id=-1或者一个很大的值，使得第一行记录无法被查询到，这样结果就只有一行记录：http://x.x.x.x/sql/sql1.php?id=-1 union select user,pwd from wp_user通常把使用UNION语句将数据展示到页面上的注入办法称为UNION（联合查询）注入。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f1a2d65e9914e023ea3f0094d561fd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfbb961bbd7bd7dbc11dcc6525db3ca5/" rel="bookmark">
			用uni-app写一个简单的豆瓣电影微信小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题，这个项目是用 uni-app 写的，只有一个列表页，没有详情页。
截图
首页 选择标签 搜索列表 封装api
./api/api
// 定义基本URL const BASE_URL = 'https://movie.douban.com/j/'; // 封装请求 const request = (url, method, data) =&gt; { return new Promise((resolve, reject) =&gt; { wx.request({ url: BASE_URL + url, method: method, data: data || {}, header: { Accept: "application/json", 'Content-Type': 'application/x-www-form-urlencoded' }, success(request) { resolve(request.data) }, fail(error) { reject(error) }, complete(res) { console.log('loading completed'); } }) }) } // 扩展 promise 的 finally 方法 Promise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfbb961bbd7bd7dbc11dcc6525db3ca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb0b9f3d40eba13e14f83204e9f47c9d/" rel="bookmark">
			【Qt】QtIFW 安装包制作总结 -如何使用样式表来定制安装器的显示界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QtIFW 安装包制作总结 -如何使用样式表来定制安装器的显示界面 一、引言 ​ 在一个安装器的流程页面中，主要使用到的控件有：按钮、文本标签、输入框、下拉框、文本显示框、CheckBox等。
那么在QtIFW中可以使用样式表来定制显示页面以及页面中的控件。
​本文的主题是：如何使用样式表来定制安装器的显示界面。包括：
（1）页面背景颜色、文字大小
（2）页面的显示设置、风格设置
（3）页面中控件的显示效果、点击效果
二、操作过程 ​ 首先用于构建一个安装包主要有两个目录。包括config目录和packages目录，然后安装器的组件包放置在packages目录中，其中包括meta和data目录用于描述一个安装组件以及具体的数据本体。
​ 核心点：
​ 【在config.xml文件中可以使用给定的xml元素来指定页面中的样式，对于页面中的具体组件可以使用样式表文件来描述】
​
2-1、编写config.xml配置文件 ​ （1）在config/config.xml文件中使用&lt;StyleSheet&gt;来指定样式表文件，参数为具体的样式表文件，对于安装器页面的各控件可以在样式表文件中进行描述。
​ （2）在config/config.xml文件中使用&lt;WizardStyle&gt;来指定风格。具体参数可选择：“Modern”, “Mac”, “Aero” or “Classic”
​ （3）在config/config.xml文件中使用&lt;TitleColor&gt;来指定标题的颜色。
​ （4）在config/config.xml文件中使用&lt;WizardDefaultWidth&gt;来指定安装器页面的默认显示宽度。
​ （5）在config/config.xml文件中使用&lt;WizardDefaultHeight&gt;来指定安装器页面的默认显示高度。
​ （6）在config/config.xml文件中使用&lt;WizardShowPageList&gt;来设置是否显示左侧的安装步骤。默认：显示。
​ （7）在config/config.xml文件中使用&lt;AllowNonAsciiCharacters&gt;在设置允许在中文路径下安装。默认：false
​ config.xml文件内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Installer&gt; &lt;Name&gt;WeightMonitor&lt;/Name&gt; &lt;Version&gt;1.0.0&lt;/Version&gt; &lt;Title&gt;WeightMonitor&lt;/Title&gt; &lt;Publisher&gt;iriczhao&lt;/Publisher&gt; &lt;StartMenuDir&gt;WeightMonitor&lt;/StartMenuDir&gt; &lt;TargetDir&gt;@HomeDir@/&lt;/TargetDir&gt; &lt;AllowNonAsciiCharacters&gt;true&lt;/AllowNonAsciiCharacters&gt; &lt;WizardStyle&gt;Classic&lt;/WizardStyle&gt; &lt;StyleSheet&gt;style.qss&lt;/StyleSheet&gt; &lt;TitleColor&gt;#97CBFF&lt;/TitleColor&gt; &lt;WizardDefaultWidth&gt;200ex&lt;/WizardDefaultWidth&gt; &lt;WizardDefaultHeight&gt;200ex&lt;/WizardDefaultHeight&gt; &lt;WizardShowPageList&gt;true&lt;/WizardShowPageList&gt; &lt;/Installer&gt; ​
2-2、编写style.qss样式表文件 ​ 在config目录下新创建一个样式表文件：style.qss
​ style.qss文件内容如下：
QWidget { color: white; font:14px 'Microsoft YaHei'; background-color: rgb(65, 65, 65); } QPushButton { background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 rgba(150, 150, 150, 60%), stop:1 rgba(50, 50, 50, 60%)); border-color: rgb(60, 60, 60); border-style: solid; border-width: 2px; border-radius: 6px; min-height: 30px; max-height: 30px; min-width: 80px; max-width: 80px; padding-left: 15px; padding-right: 15px; } QPushButton:pressed, QPushButton:checked { background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 rgba(50, 50, 50, 60%), stop:1 rgba(150, 150, 150, 60%)); } 2-3、生成安装包 binarycreator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb0b9f3d40eba13e14f83204e9f47c9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44bd07caff461c781237d0f73d4e761d/" rel="bookmark">
			【Qt】QtIFW 安装包制作总结-通用打包过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QtIFW 安装包制作总结 一、引言 ​ 当一个软件开发完成后，需要发布。面对发布，故而需要制作一个安装器，将其软件运行本体打包。并可根据软件运行的平台进行相关平台参数的定制。从而实现软件的安装。
​ 一个软件包安装器，可能包含以下几个部分：
​ 本系列文章围绕QtIFW为主题，记录如何使用QtIFW进行软件的打包，以及安装包的个性化定制、多组件安装等。
二、一个常规软件发布安装包的制作流程细节 ​ 注：本部分内容假设运行平台环境为Windows。
​ 基于QtIFW的软件发布，需要进行以下几个步骤的处理：
（1）创建一个包含所有配置文件和可安装包的包目录。
（2）创建一个配置文件（config.xml），其中包含关于如何构建安装程序二进制文件和在线存储库的信息。
（3）创建包含可安装组件信息的包信息文件。
（4）创建安装程序内容并将其复制到包目录。
（5）使用binarycreator工具来创建安装程序。
2-1、创建一个包含所有配置文件和可安装包的包目录 ​ 创建一个反映安装程序设计的目录结构，并允许将来扩展安装程序。该目录必须包含名称为config和packages的子目录。如下图所示：
2-2、创建一个配置文件（config.xml） ​ 在config目录中，创建一个名为config.xml的文件，包含以下内容：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Installer&gt; &lt;Name&gt;gammaray&lt;/Name&gt; &lt;Version&gt;2.11.50&lt;/Version&gt; &lt;Title&gt;gammaray&lt;/Title&gt; &lt;Publisher&gt;kdab Qt-Project&lt;/Publisher&gt; &lt;!-- Directory name is used in component.xml --&gt; &lt;StartMenuDir&gt;gammaray&lt;/StartMenuDir&gt; &lt;TargetDir&gt;@HomeDir@/gammaray&lt;/TargetDir&gt; &lt;/Installer&gt; ​ config.xml配置文件指定了在简介页面显示的信息：
&lt;Title&gt;元素指定显示在标题栏上的安装程序名称。
&lt;Name&gt;元素指定添加到页面名称和介绍文本中的应用程序名称。
&lt;Version&gt;元素指定应用程序的版本号。
&lt;Publisher&gt;元素指定软件的发布者(例如，在Windows控制面板中显示)。
&lt;StartMenuDir&gt;元素指定Windows开始菜单中产品的默认程序组的名称。
&lt;TargetDir&gt;元素指定向用户显示的默认目标目录是当前用户的主目录中的InstallationDirectory(因为预定义的变量@HomeDir@用作值的一部分)
2-3、创建包含可安装组件信息的包信息文件。 ​ 在这个简单的场景中，安装程序只处理一个名为org.gammaray.entry的组件。为了向安装程序提供有关组件的信息，创建一个名为package.xml的文件，包含以下内容，并将其放在目录中:
​ package.xml文件内容：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Package&gt; &lt;DisplayName&gt;gammaray&lt;/DisplayName&gt; &lt;Description&gt;gammaray&lt;/Description&gt; &lt;Version&gt;2.11.50&lt;/Version&gt; &lt;ReleaseDate&gt;2021-09-04&lt;/ReleaseDate&gt; &lt;Licenses&gt; &lt;License name="gammaray Public License Agreement"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44bd07caff461c781237d0f73d4e761d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9293670c2f6627d11ff753d651d25456/" rel="bookmark">
			Word 2016 撰写论文: 公式居中、编号右对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
方法1：表格法
方法2：制表位法
新建“样式”批量设置
参考资料
写论文时，要求公式居中，编号右对齐。刚开始碰到这种问题，很麻烦，网上看了好多方法，目前，两种方法比较实用。第一种是表格法，方便快捷；第二种是制表位法，刚开始设置比较繁琐，一旦设置好了，比表格法速度还要快。个人推荐制表位法，当然，这样看自己的习惯了。下面将依次介绍两种方法实现公式居中，编号右对齐。
方法1：表格法 1、插入一行三列的表格，在表格中依次插入公式，序号；
2、接下来，设置公式居中，编号右对齐。将光标定位到公式处的单元格 ——&gt; 段落选项卡选择居中的图标；
再选中表格中编号处单元格 ——&gt; 段落卡选择右对齐的图标。设置完成后，公式居中，编号右对齐了，接下来将表格的框线去除就可以了。
3、选中整个表格——&gt;段落选项卡找到边框的图标 ——&gt; 选择“无框线”。
这样，就设置完毕了，其他的基本设置，自己慢慢探索吧。
方法2：制表位法 插入制表位的思想是用两个制表位将一行分为三个部分，关键在于两个制表位参数的设置。这也是制表位中较为繁琐的，不同期刊要求的页面的页边距不同，所设置的也不同。
1、熟悉制表位
光标在任意位置 ——&gt; 右击选择“段落” ——&gt; 选择“制表位” ——&gt; 看到对齐方式：“居中”，“右对齐”
2、 熟悉自己页面纸张大小和页边距，一般论文都是用默认的A4纸，A4纸大小为 21cm×29.7cm。 页边距默认为：上下左右分别为：2.54cm，2.54cm，3.18,cm，3.18cm。下面将以这些参数设置制表符，这些参数一定要知道，也是制位表的关键。
3、熟悉了制位表，纸张大小和页边距，下面就要正式进入主题了。
（1）第一个制表位：设置在页面中间，计算公式为：(21cm-3.18cm×2)÷2=7.32 cm ;
（2）第二个制表位：设置在页面右侧，计算公式为：21cm-3.18cm=17.82 cm ;
看到这，是不是很懵，默默地拿起笔，在纸上算，什么鬼，居然还有计算公式？为了更直观理解，可以参考下图。
（3）设置第一个制表位，在光标处右击“段落” ——&gt; “制表位” ——&gt; “制表位位置” 输入：7.32厘米 ——&gt; “对齐方式” 选择“居中” ——&gt; 确定；
（4）设置第二个制表位
在光标处右击“段落” ——&gt; “制表位” ——&gt; “制表位位置”输入：17.82厘米 ——&gt; “对齐方式”选择“右对齐”——&gt;确定；
（5）设置好制表位后，在原先的光标处输入公式和编号，此时公式和编号处于居中，将光标放到公式前面，按“&lt;——Backspace” 键，使其左对齐；
（6）光标放在公式前，按“Tab”键；此时，公式和编号居中。
接着光标定位到公式后和编号中间，同样按“Tab”键，此时公式居中，编号右对齐。
至此，制位表法设置完毕。假如每个公式都是这样设置，太麻烦，刚才是针对某一个公式设置。实际，在写论文，有很多公式，此时需要借助“样式”，来帮助我们完成批量设置。
新建“样式”批量设置 （1）第一步，新建公式的样式。
选择“样式选项卡”右下角小箭头，选择“新建样式”；
设置名称为：公式
后续段落样式为：正文
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9293670c2f6627d11ff753d651d25456/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/125/">«</a>
	<span class="pagination__item pagination__item--current">126/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/127/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>