<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f924721602831e29f3322e8741c3bd/" rel="bookmark">
			数值计算作业：matlab实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目一 syms x; fx=inline('54*x^6+45*x^5-102*x^4-69*x^3+35*x^2+16*x-4'); % 首先利用diff(54*x^6+45*x^5-102*x^4-69*x^3+35*x^2+16*x-4)求解函数的导数 dfx=inline('324*x^5 + 225*x^4 - 408*x^3 - 207*x^2 + 70*x + 16'); %% 绘图 x=-1.5:0.0001:1.2; y=54.*x.^6+45.*x.^5-102.*x.^4-69.*x.^3+35.*x.^2+16.*x-4; y2=0.*(1&lt;=x);% 找到零点的大致范围，以便在牛顿迭代法中设置初值 plot(x,y,x,y2) %% 调用函数分别求出五个根 [re1,step1]=NewtonDiedai(fx,dfx,-1.39); [re2,step2]=NewtonDiedai(fx,dfx,-0.68); [re3,step3]=NewtonDiedai(fx,dfx,0.23); [re4,step4]=NewtonDiedai(fx,dfx,0.51); [re5,step5]=NewtonDiedai(fx,dfx,1.18); function [result,step] = NewtonDiedai(fx,dfx,x0) %此方法为牛顿迭代法求解非线性方程的根 % fx为原函数 dfx为导函数 x0为初值 % result为结果，step为迭代步数 x1=x0; step=1; while 1 x0=x1; x1=x0-feval(fx,x0)/feval(dfx,x0); %feval()函数执行指定的函数 if abs(x0-x1)&lt;0.0001 %判断迭代结果精度是否达到要求 break; end if(step&gt;50) %当步数大于50时认为迭代不收敛，退出 break; end step=step+1; %记录步数 end result=x0; end 题目二 %% 求导 syms x; fx=(1-3/(4*x))^(1/3); diff(fx) %求出函数的导数 %% 绘图 x=-3:0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f924721602831e29f3322e8741c3bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d31c94b8b6bfa02f4a3be9d263a86724/" rel="bookmark">
			缓和曲线放样资料计算与精度评定程序编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件约束 软件界面 “缓和曲线放样资料计算与精度评定软件”主要有两个子界面，图6.1所示界面用于计算缓和曲线放样资料，图6.2所示界面用于测设数据精度评定。
软件操作 缓和曲线放样资料计算 在窗口中输入各个常数的值；
点击“导出数据”，选择导出的文件，当弹出如图6.4（右）的数据导出成功的提示后，代表数据导出成功；
我们打开导出的文件，内容如图6.5所示，每一行数据从左到右代表：放样点，置镜点，后视点，距离值，角度值，正反拨。 测设数据精度评定 首先点击“导入数据”，选择待精度评定的数据文件；
点击“计算显示”，界面中会分别用图和表格的形式表示各个点的精度情况。
附录：源代码 LayOffCaculate.h #ifndef LAYOFFCACULATE_H #define LAYOFFCACULATE_H #include&lt;iostream&gt; #include&lt;vector&gt; #define PI 3.141592653589793238 using namespace std; struct Point { string name; string zhiJing; string houShi; double juLi; double rad; int ZhengFan; double liCheng; }; double dgree2rad(int dd, int mm, double ss); void rad2degree(int &amp;dd, int &amp;mm, double &amp;ss, double rad); double biaozhunLicheng2Caculate(size_t bignum, double smallnum); void caculateLicheng2Biaozhun(size_t &amp;bignum, double &amp;smallnum, double cacunum); double fangxiangAngle(double dx, double dy); class ZhuDian { public: ZhuDian(double r_, double l0_, double alpha_, double zh_lc_, double t_, double l_, double e_) :r(r_), l0(l0_), alpha(alpha_), zh_lc(zh_lc_),t(t_), l(l_), e(e_) {} Point caculateZH(); Point caculateQZ(); Point caculateHY(); private: double r, l0, alpha, zh_lc, t, l, e; }; class HuanHe { public: HuanHe(Point ZH_, Point HY_, double r_, double l0_) //拷贝类型 :ZH(ZH_),HY(HY_),r(r_),l0(l0_){} vector&lt;Point&gt; caculateHH(); protected: int point_count(); private: Point ZH, HY; double r; double l0; }; class YuanQX { public: YuanQX(double r_, double l0_, Point HY_,Point QZ_, Point ZH_) :r(r_),l0(l0_),HY(HY_),QZ(QZ_),ZH(ZH_){}; vector&lt;Point&gt; caculateYQX(); protected: double caculateM(); double caculateP(); double caculateBelta0(); private: double r, l0; Point HY, QZ, ZH; }; #endif LAYOFFCACULATE_H LayOffCaculate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d31c94b8b6bfa02f4a3be9d263a86724/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/448da4416a98cf968a1f5f3dfadde474/" rel="bookmark">
			JAVA全栈知识体系--java三大特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA全栈知识体系--java三大特性 前言封装继承多态 前言 从事java研发三年，从最初的servlet到现在流行的springboot、springcloud微服务的架构，之间大大小小的项目都在做，所学所用的技术体系也是平凡不能再平凡，有时候深感这个行业的技术迭代如此之快，也深感自身java基础理解不是很透彻，要想突破技术上的瓶颈，必须对自己的东西做一个总结。这段时间相比之前没有这么忙了，考虑了一段时间后，还是想自己写写博客，一是弥补自己在java基础的薄弱，二是总结所学知识，形成一定的知识图谱，三是跟上技术的更新，充实自己的生活。内容部分借鉴网上相关内容，加上自己的一些想法，如有瑕疵和问题，望见谅！
public class Husband{ // 姓名 private String name; // 年龄 private String age; // 妻子 private Wife wife; public String getAge() { return age; } public void setAge(String age) { this.age = age; } public String getName(){ return name; } public void setAge(int age){ if(age &gt; 100){ this.age = String.valueOf(0); } this.age = String.valueOf(age); } public void setName(String name){ this.name = name; } public void setWife(Wife wife){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/448da4416a98cf968a1f5f3dfadde474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/943ceabfa1a4dac4e1ef8c7d9430dfaf/" rel="bookmark">
			Linux下编译JNI so库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近接到领导的一项任务，要求把C++的录音处理算法包一层JNI，提供Java接口给到客户的Java工程师在Linux服务器上去调用。在初步接到任务时，以为使用Android的NDK将算法源码编译x86_64平台的so库就可以搞定，没想到开搞后事情并没有想象中的顺利。。
本来以为拿到的会是源码，结果只有一个C++接口头文件，加两个so库（一个是算法具体实现，另一个是算法依赖的加密类so库），拿到算法文件后就蒙了，之前还没搞过用NDK编译so库时依赖链接另一个so库。。在这里对编译实践过程做一个总结，加深印象的同时，希望也能帮助有需要的同学。
一、AS环境下配置Cmake链接第三方动态库进行编译 #需添加 #设置so库路径,设置my_lib_path为相对CMakeLists.txt路径下的libs目录 set(my_lib_path ${CMAKE_SOURCE_DIR}/libs) #file (SO_RECURSE DIR_SRCS "${PROJECT_SOURCE_DIR}/jniLibs/libs/x86/*.so") #将第三方库作为动态库引用，algorithm为算法具体实现so库，全名为libalgorithm.so add_library( algorithm SHARED IMPORTED ) #需添加 #指名第三方库的绝对路径属性，ANDROID_ABI为build.gradle中配置要编译的平台 set_target_properties( algorithm PROPERTIES IMPORTED_LOCATION ${my_lib_path}/${ANDROID_ABI}/libalgorithm.so ) target_link_libraries( # Specifies the target library. athena-call-lib # 链接第三方库libalgorithm.so algorithm # Links the target library to the log library # included in the NDK. # 由于要在Linux下运行，故注释掉链接Android log库 # ${log-lib} ) 以上参考自：https://blog.csdn.net/cool_fuwei/article/details/77239480，感谢该博主。
接下来对引入第三方库相关配置做进一步做了解
1. add_library( algo​​​​​​​rithm SHARED IMPORTED ) 创建一个名为&lt;name&gt;的导入库目标。没有生成任何规则来构建它，并且IMPORTED目标属性为True。目标名称在创建它的目录及其下面具有作用域，但是GLOBAL选项扩展了可见性。它可以像项目中构建的任何目标一样被引用。导入的库对于从target_link_libraries()这样的命令中方便地引用是有用的。 （来自：https://cmake.org/cmake/help/latest/command/add_library.html#imported-libraries）
2. set_target_properties ( algorithm PROPERTIES IMPORTED_LOCATION
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/943ceabfa1a4dac4e1ef8c7d9430dfaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48198ef6492bc6d99a99732a5f33363/" rel="bookmark">
			springboot&#43;quartz的简单整合使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 注意事项 1.首先是引入POM2.Quartz自带JOB类3. 为Quartz的增删改提供一个统一的接口4. 具体业务中的使用 完 注意事项 文章只提供默认配置下quartz的集成及简单增删改。如需要更加复杂的功能可自行阅读官方api进行实现。
对quartz一点都不了解的可以阅读下面的文章。
[https://cloud.tencent.com/developer/article/1745977]
1.首先是引入POM &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; 2.Quartz自带JOB类 继承QuartzJobBean ,实现你自己的业务逻辑即可。如有多个任务可新建多个类继承QuartzJobBean public class AddWorkTask extends QuartzJobBean { @Override protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException { // jobExecutionContext.getTrigger().getJobDataMap(); 可以获取传入的参数 //TODO...这里实现你自己的业务逻辑 } } 3. 为Quartz的增删改提供一个统一的接口 @Component public class QuartzService { private Logger logger = LoggerFactory.getLogger(QuartzService.class); /** * 注入Scheduler */ @Autowired private Scheduler scheduler; /** * 新增任务 * @param clazz Job类 * @param name 名称 * @param group 组名 * @param cron 表达式 * @param data 额外传入的值 */ public void addJobs(Class clazz,String name,String group,String cron,Object data){ JobDataMap jobDataMap=new JobDataMap(); if(data!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b48198ef6492bc6d99a99732a5f33363/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c671e260e03520591ff05588a76493bd/" rel="bookmark">
			[傅老師/Unity教學]渲染相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[傅老師/Unity教學]渲染相关知识 01 基础渲染步骤02 室內光影基础实验03 用一颗石头架场景!! 室外光影基础实验04 05 shader graph --- Lambert Diffuse &amp; specular06 场景烘焙知识07 Guilty Gear X 卡通渲染Shader08 Light probe, Realtime GI, Baked GI09 Cloudy sky10 11 Global Illumination Reflection Probe13 Volumetric Light14 Realtime lighting详解 本文章总结来自傅老师的B站教学
01 基础渲染步骤 首先是颜色空间——伽马校正，可以回顾以前的笔记，没有特殊要求直接用线性空间即可
关于阴影，默认的阴影会长这样
把环境光和环境反射都变黑就纯黑了
把相机颜色变黑，灯光颜色调白就会纯黑白
渲染过程可以在window选项卡中找到frame debug工具
过程包括首先清空g-buffer（color+Z+stencil）,然后用深度算影子
影子质量什么的可以在project setting——quality里面设置，URP管线可以到pipeline asset里设置
之后正常的前向渲染流程逐个分析
02 室內光影基础实验 搭了一个场景，然后介绍基础的pbr材质球设置
然后选一些光源放到房间，反射球
调节各种光源和材质参数
03 用一颗石头架场景!! 室外光影基础实验 比较重复性的工作，使用一个石块模型组合以后搭出场景，配上天空盒，打个背光
加上抗锯齿，bloom，sun shafts，vignette，depth of field
04 05 shader graph — Lambert Diffuse &amp; specular 该节讲一下lambert漫反射和phong镜面光怎么用shader graph连
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c671e260e03520591ff05588a76493bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af3e2764783473a9cda4be0c7558f7e2/" rel="bookmark">
			数组指针 一维数组的遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组指针的遍历 本文主要讲以为数组的遍历，因为我在学习数组指针的时候遇到了问题，我用数组指针指向了一个一维数组，结果在遍历的时候不能准确的打印出数组的值，经过查阅资料例子如下：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int a[2]={1,3}; int (*p)[2]; int i; p=a; for(i=0;i&lt;2;i++) { printf(" %d ",*(*p+i)); } system("pause"); return 0; } *p代表的是数组首地址，所以用 *(*p+i)就是数组里面元素的位置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c18803bc89afa24d8a85a46b04020af/" rel="bookmark">
			Docker 容器之间无法ping通的原因分析。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近配置ctfd遇到了个问题，总是提示
Waiting for db: to be ready 去翻了下docker-entrypoint发现是ping db命令ping不通。
docker有着内部的dns，db这个域名会被解析成如172.18.0.4这样的内部地址，ping db不通那显然是ip不通的原因。
可问题是，我ctfd的ip是172.18.0.4/24，显然和db的ip在同一网段，但却不通，这是什么原因呢？
看了下这篇文章：
https://maximorlov.com/4-reasons-why-your-docker-containers-cant-talk-to-each-other/
检查了下，发现com.docker.network.bridge.enable_icc也是开了的。那原因估计出在iptables上。
翻看了iptables。发现大概如下，记得要加-v参数：
ych@ych-XFS:~$ sudo iptables -L -v Chain INPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination Chain FORWARD (policy DROP 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 3012 514K DOCKER-USER all -- any any anywhere anywhere 3012 514K DOCKER-ISOLATION-STAGE-1 all -- any any anywhere anywhere 0 0 ACCEPT all -- any docker0 anywhere anywhere ctstate RELATED,ESTABLISHED 0 0 DOCKER all -- any docker0 anywhere anywhere 0 0 ACCEPT all -- docker0 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c18803bc89afa24d8a85a46b04020af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd2b487d9f3a7dcbf16b751aac7a14b/" rel="bookmark">
			jQuery学习知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结：如果属性的类型是boolean则使用prop()方法，否则使用attr（）方法
只要jQuery元素才能被jQuery进行操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c682c2bcc37efcbeeff68e1293024479/" rel="bookmark">
			计算分子描述符——使用E-Dragon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 计算分子描述符（又称理论分子描述符）不需借助于任何实验信息，只需要分子的结构信息就可以计算出来，例如分子的组成，拓扑结构以及量子化学描述符等等。其优点是对化合物结构的描述更全面细致，物理化学意义更明确，理论性更强。与Abraham描述符相比，无需依靠实验，因此实用性更广，更易于推广。
方法 有多个软件可以获取物质的计算分子描述符。
例如，史新宇采用Accelrys Discovery Studio分子模拟软件作为工具生成化合物的2D和3D分子特征。该工具提供了12中不同类别的分子特征，这些类别中一共包含了355个分子特征。例如溶解度、疏水原子数、疏水表面积和拓扑指数、子结构描述符、MQS（Molecular Quantum Similarity）、QSCD（Quantized Surface Complementarity Diversity）、分子形状、分子总表面积等。
也有文献采用Dragon软件来获取计算分子描述符。王雅采用以下步骤获取描述符：
从ChemACX.com下载吸附物的2D分子结构；用ChemBio3D Ultra（Version 12.0）将其转为3D结构；用MOPAC 2016中的PM7算法对所有的3D结构进行优化，并将介电常数设置为78.6来模拟水环境最终得到最稳定结构；综合考虑吸附过程中可能涉及到的静电作用、疏水作用、氢键作用和范德华作用，将能够表征这些相互作用的量化描述符（最高占据分子轨道能级、最低未占据分子轨道能级、分子偶极矩、原子电荷）从MOPAC 2016优化成功的结果文件中提取出来，用于后续建模过程；使用Dragon软件对优化成功的结构进行计算，得到327个理论分子结构描述符，并将这些描述符值与12个量化描述符值整合用于模型的构建。 陈召阳利用E-Dragon来获取描述符。
由于E-Dragon免费且使用方便，本文将介绍用这种方式获取计算分子描述符。
E-Dragon 准备分子结构文件 打开E-Dragon网站后，首页简单介绍了如何使用这个工具：
To run DRAGON the user needs molecular structure files previously obtained by other specific molecular modelling software. 运行Dragon前，用户需要通过其他分子建模软件获得的分子结构文件。In E-DRAGON the accepted molecular structure files SMILES, SDF (MDL) or MOL2 (Sybyl) files. E-Dragon可接受的分子结构文件有SMARES、SDF(MDL)或MOL2(Sybyl)文件。DRAGON requires 3D optimised structures with HYDROGENS. 3D优化结构需要包含氢原子。In E-DRAGON, if the 3D atom coordinates are not available for molecules, the user can calculate them on-line using CORINA, provided by Molecular Networks GMBH.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c682c2bcc37efcbeeff68e1293024479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d1baa53c7c02fe2b5b4c863f56c7df/" rel="bookmark">
			计算机系的土味情话,大学各专业土味情话大比拼，你够我土吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高考在即，相信高三童鞋萌现在都鸭梨山大，神经紧绷。为了给各位学子减减压，今天新姐给大嘎找来了大学一些专业的土味情话，可别不信，这些土甜土甜的话语，把新姐撩的不要不要的~
No1 电子商务：
你是我的支付宝账号
我的微信钱包
来来来，支付密码请给一下。
No2 会计：
对你
我只有一套账
准确核算进销项
按时报税
愿意随时随地接受你的审计
这么听话的恋人，我能认领一只不？
No3 金融管理：
我向你借一份长期借款
我愿偿还你一辈子的财务费用
我学了四年金融管理
只因为想最后管理我金融的人
是你
有空一起数钱
愿意，愿意！说到钱眼里就冒星星，请把钱包乖乖给我奉上~
No4 计算机科学与技术:
见到你时
我的脑海里就浮现了语句：
if(today==Valentine’s Day):print”I love u”
if(distance(you,me)&gt;0):print”I miss u”
else:I hold(your hand)
你是我遇到的最美的bug
我愿用一生去修复。
哇，程序猿果然脑路清奇，相信很多妹纸就算看不懂，也会欣然接受吧。
No5 市场营销:
我做了四年的市场调研，还是不太了解你，
现在起一颗心交给你打理，
你也把我swot分析一下。
猴犀利！言简意赅，却让人感受到从一颗炽热的心散发出的满满诚意。
No6 建筑工程技术:
我要送你一块地，对你的死心塌地。
我愿用钢筋混凝土般强大的内心 守护你一生一世
我要造出最美的园子
你要成为最美的风景
想要多少房子，给你盖
建筑生的爱
无论哪个半球，都没有时差
因为我们不睡觉呀
我在努力的打地基
只为让你看到更高的云
土不土，撩不撩？新姐此刻已要沦陷。传统的表白套路已经out了！现在跟新新人类表白，没点才华，还真的不好意思说出口啊。
No7 学前教育:
你愿意和我一起哄孩子吗？
我们教他唱歌跳舞弹琴画画和手工
这算不算立下“与君共度余生”的誓言？相信很多女孩子听到都会感动到泪牛满面吧。
No8 行政管理:
对你的爱就像公共义务，必须强制执行。
这霸道总裁的口吻，就差没承包鱼塘了，此刻的新姐，无比幸福，似乎已经忘记了尘世的种种，只想过只羡鸳鸯不羡仙的生活了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d1baa53c7c02fe2b5b4c863f56c7df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e2a59ccabe94af2323207651ea872a/" rel="bookmark">
			Pytorch-Center Loss在图像分类上的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在测试Center Loss在图像分类上的性能，以此记录一下学习历程。
Center Loss论文：Wen et al. A Discriminative Feature Learning Approach for Deep Face Recognition. ECCV 2016.
pytorh版本地址：https://github.com/KaiyangZhou/pytorch-center-loss
我使用的图像分类算法是EfficientNet-V2-L版本，使用SoftMax+Center Loss进行图像分类。具体代码为：
1、模型结构 efficient_v2_model.py
from collections import OrderedDict from functools import partial from typing import Callable, Optional import torch.nn as nn import torch from torch import Tensor def drop_path(x, drop_prob: float = 0., training: bool = False): """ Drop paths (Stochastic Depth) per sample (when applied in main path of residual blocks).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02e2a59ccabe94af2323207651ea872a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e7da2cd4e81bb5c062b957c9968f759/" rel="bookmark">
			整蛊：聊天中，连续发送消息的vbs脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何实现连续发送消息呢？
准备工作：
只要我们将下面这段代码复制放在记事本里，然后保存退出将记事本文件后缀名改为.vbs就可以了
On Error Resume Next Dim wsh,s,xTimes,tle set wsh=createobject("wscript.shell") xTimes = inputbox("请输入重发消息的次数") 'clipboardData.SetData s for i=1 to Cint(xtimes) wscript.sleep 30 wsh.AppActivate(cStr(tle)) wsh.sendKeys "^v" wsh.sendKeys "%s" next wscript.quit 进行连续发送整蛊操作方式😄：
先复制一下你想发送的内容，再双击运行vbs脚本,在输入框里输入想发送的次数点击确认。
此脚本只要是有聊天框都可以实现自动重复发消息，微信、QQ、甚至可以用来发弹幕。
建议慎用，避免被拉黑哦（手动滑稽）
运行之后界面：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7124c1b7fd81924068194dc6af503c53/" rel="bookmark">
			Opencv学习笔记(十):opencv和base64之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import requests import base64 import json,cv2 import numpy as np # opencv读取出来的图片相当于numpy数组 def cv2_to_base64(image): image1 = cv2.imencode('.jpg', image)[1] image_code = str(base64.b64encode(image1))[2:-1] return image_code def base64_to_cv2(image_code): #解码 img_data=base64.b64decode(image_code) #转为numpy img_array=np.fromstring(img_data,np.uint8) #转成opencv可用格式 img=cv2.imdecode(img_array,cv2.COLOR_RGB2BGR) return img 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2175efe45673b24db32d456d8688082e/" rel="bookmark">
			Python循环结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		循环结构 1. for 循环结构 语法： for 变量 in 序列: 循环体 ​ 循环的次数与序列中的元素个数有关。
​ 常见序列：字符串、元组、列表、字典、集合、迭代器、生成器、range
range函数 ​ 用于产生指定范围的数字序列
1. range(N) - 产生[0,N)的数字序列，其中步长是1 2. range(M,N) - 产生[M,N)的数字序列，步长为1 3. range(M,N,step) - 产生[M,N)的数字序列，步长为step指定的值 练习： 打印100以内所有偶数
# 方法一： for i in range(100): if i % 2 == 0: print(i, end=' ') print('\n') # 方法二 for i in range(0, 100, 2): print(i, end=' ') print('\n') 2. while 循环 语法 while 条件语句: 循环体 ​ while 循环控制循环次数的原则：让条件经历过指定次数后由True变成False
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2175efe45673b24db32d456d8688082e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e36bd637ef2572fcf9c47ac65202da7/" rel="bookmark">
			关于Cause: java.sql.SQLException: The server time zone value 的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序按照视频敲完后一直报错，无法将数据库里的信息读出，一开始我以为是数据库版本的问题，因为我用的数据库是8.0版本的，再将mybatis-confing.xml里的语句：
&lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; 改为：
&lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt; 运行还是报错，在查看控制台的报错信息后，发现出现了serverTimezone的提示，于是我想到了视频中说到的一句话：添加时钟区，所以我在将连接语句改为如下：
&lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai"/&gt; 最终成功运行，出现了想要的结果，感动到流泪。
&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 希望能帮助遇到同样问题的小伙伴。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9327b9d8cd432e586718761208ed70d3/" rel="bookmark">
			redis如何做亿级用户登录日活统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案一：使用string（排除） 如何用合适的数据类型来存储1亿用户的数据，用普通的字符串来存储肯定不行。经过查看一个最简单的kv(key为aaa，value为1)的内存占用，发现为48byte。
假设每个用户每天登陆需要占据1对KV的话，那一亿就是(48*100000000)/1024/1024/1024=4.47G。这还是一天的量。
方案二：bitmap 1、bitmap介绍 在redis 2.2.0版本之后，新增了一个位图数据，其实它不是一种数据结构。实际上它就是一个一个字符串结构（涉及单个bitmap可存储最大值问题），只不过value是一个二进制数据，每一位只能是0或者1。redis单独对bitmap提供了一套命令。可以对任意一位进行设置和读取。
主要命令有：
SETBIT
GETBIT
BITCOUNT
BITPOS
BITOP
BITFIELD
具体可参考：http://redisdoc.com/bitmap/index.html
相关语法为：
SETBIT key offset value
GETBIT key offset
BITCOUNT key [start] [end]
BITOP operation destkey key [key …]
注意事项：
bitmap本质为字符串，使用type命令对bitmap的相关key进行操作，可以看出结果为"string"，因此最大不能超过512MB，故可存储id号最大为：4294967295=4294967296-1（42亿多），计算方式为512MB可容纳的最大数据：2 = 512* 2 * 2
offset为偏移量，对使用大的 offset 的 SETBIT 操作来说，内存分配可能造成 Redis 服务器被阻塞
2、登录统计方案设计 （1）登录标记
用户登录时，使用setbit命令和用户id（假设id=123456）标记当日（2020-10-05）用户已经登录，具体命令如下：
# 时间复杂度O(1) setbit login:20201005 123456 1 （2）每日用户登录数量统计
# 时间复杂度O(N) bitcount login:20201005 （3）活跃用户（连续三日登录）统计
如果我们想要获取近三日活跃用户数量的话，可以使用bitop命令，
bitmap的bitop命令支持对bitmap进行AND(与)，(OR)或，XOR(亦或)，NOT(非)四种相关操作，我们对近三日的bitmap做AND操作即可，操作之后会形成一个新的bitmap，我们可以取名为login:20201005:b3
# 时间复杂度O(N) bitop and login:20201005:b3 login:20201005 login:20201004 login:20201003 然后我们可以对login:20201005:b3使用bitcount或者getbit命令，用于统计活跃用户数量，或者查看某个用户是否为活跃用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9327b9d8cd432e586718761208ed70d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0264e23c2dbb7b91fded02093e5ea76/" rel="bookmark">
			Mybatis之collection标签嵌套查询(select)的写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务：查询一种商品，展示该商品多种规格。
GroupDetailsVo ：
package com.community.api.vo; import java.io.Serializable; import java.math.BigDecimal; import java.util.Date; import java.util.List; import lombok.Data; /** * 团购详情vo * * @author admin * @date 2019 -11-20 15:29:51 */ @Data public class GroupDetailsVo implements Serializable{ private Long groupById; /** * 团购状态 2:未开始 3:团购中 4:已结束 */ private Byte groupBuyStatus; /** * 主图 */ private String mainPicture; /** * 商品名称 */ private String name; /** * 详情 */ private String content; /** * 配送方式 1:自提 2:上门 */ private String deliveryType; /** *满额免费配送 */ private BigDecimal freeDeliveryPrice; /** *已卖总数量 */ private Integer sellNumber; /** * 原价 */ private BigDecimal originalPrice; /** * 团购价 */ private BigDecimal groupByPrice; /** * 开始时间 */ private Date startTime; /** * * 结束时间 */ private Date endTime; /** * 单、多规格详情vo */ private List&lt;StandardDetailsVo&gt; standardDetailsVos; } StandardDetailsVo ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0264e23c2dbb7b91fded02093e5ea76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ffeedcce37b72daed83013b6f85a00/" rel="bookmark">
			Python3取余不等于0（巨坑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python3取余不等于0
buydate = datetime.strptime("2021-7-12 12:0:0", "%Y-%m-%d %H:%M:%S") sec = buydate - datetime.now() if sec.total_seconds() &gt; 5: print((sec.total_seconds() % 5) == 0) if (sec.total_seconds() % 5) == 0: print("秒：%d" % sec.total_seconds()) 这样的代码看着貌似没什么问题，但是最后一个IF语句始终进不去，用print((sec.total_seconds() % 5) == 0)打印逻辑运算结果发现永远为False，最后想到是不是取余后的数不等于0，把最后一个if语句改成了
if int(sec.total_seconds() % 5) == 0: 果然能正确执行了。同学们小心坑啊。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/999f87d68f940ac56a71f9bba8ceaa1d/" rel="bookmark">
			构建数据仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是数据仓库 数据仓库试图提供一种从操作型系统到决策支持环境的数据流架构模型。
处理过程收集、清洗、整合来自多个数据源的数据。
数据仓库描述：一个面向主题的、集成的、随时间变化的、非易失的数据集合。
面向主题：
数据仓库是面向主题的。主题是一个抽象概念，简单地说就是与业务相关的数据的类别，每一个主题基本对应一个宏观的分析领域。
主题域是对某个主题进行分析后确定的主题的边界；
集成：
集成的概念与面向主题是密切相关的。从公司层面整体分析销售数据，必须将多个分散的数据源统一成一致的、无歧义的数据格式后，再放置到数据仓库中。
随时间变化：
这与联机事务处理（OLTP）系统形成鲜明的对比。联机事务处理反应的是当前时间点的数据情况，要求高性能、高并发和极短的响应时间，。
数据仓库中的数据是反映了某一历史事件点的数据快照。数据是有生命周期的，到时间后将删除。
非易失：
非易失是指，一旦进入到数据仓库中，数据就不应该再有改变。
数仓的数据是不改变的；数据仓库中的数据基本是静态的，保留了数据变化的历史轨迹。
数据粒度：
数据粒度一直是数据仓库设计需要重点思考的问题。如果数据被装载进数据仓库的频率是每天一次，那么一天之内的数据更新将被忽略。
粒度级别越低，数据量越大，查询的细节程度越高，查询范围越广泛，反之亦然。
如果得到的数据粒度级别比数据仓库的高，那将意味着在数据存入数据仓库前，开发人员必须花费大量设计和资源来对数据进行拆分。数据会以很低的粒度级别进入数据仓库，如日志类型的数据或单击流数据，此时应该对数据进行编辑、过滤和汇总。
这些业务数据经过一系列的数据抽取、转换、清洗，最终以一种统一的格式装载进数据仓库。数据仓库里的数据作为分析用的数据源，提供给后面的即席查询、分析系统、数据集市、报表系统、数据挖掘系统等。
数据仓库的好处：
将多个数据源集成到单一数据存储，因此可以使用单一数据查询引擎展示数据。
缓解在事务处理数据库上因执行大查询而产生的资源竞争问题。
维护历史数据。
通过对多个源系统的数据整合，使得在整个企业的角度存在统一的中心视图。
通过提供一致的编码和描述，减少或修正坏数据问题，提高数据质量。
一致性地表示组织信息。
提供所有数据的单一通用数据模型，而不用关心数据源。
重构数据，使数据对业务用户更有意义。
向复杂分析查询交付优秀的查询性能，同时不影响操作型系统。
开发决策型查询更简单。
事务
事务是工作于数据库管理系统（或类似系统）中的一个逻辑单元，该逻辑单元中的操作被以一种独立于其他事务的可靠方式所处理。事务一般代表着数据改变，它提供“all-or-nothing”操作，就是说事务中的一系列操作要么完全执行，要么完全不执行。
在数据库中使用事务主要出于两个目的：
（1）保证工作单元的可靠性。当数据库系统异常宕机时，其中执行的操作或者已经完成或者只有部分完成，很多没有完成的操作此时处于一种模糊状态。在这种情况下，数据库系统必须能够恢复到数据一致的正常状态。
（2）提供并发访问数据库的多个程序间的隔离。如果没有这种隔离，程序得到的结果很可能是错误的。
ACID特性：
原子性
事务中的一系列操作，全执行或不执行。原子性可防止数据被部分修改。
一致性
一致性是指任何数据库事务，只能以允许的方式修改数据。一致性并不保证应用程序逻辑的正确性。
隔离性
隔离性决定其他用户所能看到的事务完整性程度。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/138/">«</a>
	<span class="pagination__item pagination__item--current">139/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/140/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>