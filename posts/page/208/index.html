<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83dface3ac8a94087e6d07d0fad4ce59/" rel="bookmark">
			c语言指向结构体的指针作为函数参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意
这里包括形参和实参
struct dangdangtest { char name[30]; int num; }; void change(int num)//值传递 新建一个变量接受传递的值 { num = 1000; } //使用结构体作为参数 浪费内存 需要建立结构体 void change2(struct dangdangtest ddt) { ddt.num = 1000; printf("\nmain=%p,%p",ddt,&amp;ddt.num);//函数内部结构体地址 } //函数内部改变需要地址 所以需要指针保存 void changeall(struct dangdangtest *p) { (*p).num = 1000;//*根据地址取出内容 } void main5() { struct dangdangtest ddt; ddt.num = 99; sprintf(ddt.name,"adf");//初始化 printf("\nmain=%p,%p",ddt,&amp;ddt.num);//main函数内部结构体地址 /*change(ddt.num); printf("%d",ddt.num);99*/ /*change2(ddt); printf("%d",ddt.num);*/ changeall(&amp;ddt); printf("\n%d",ddt.num); getchar(); } //参数对于数组来说传递的是地址 4个字节 void datatest(struct dangdangtest ddd[10]) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83dface3ac8a94087e6d07d0fad4ce59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/175a02c77a1ee57534ea8a3aa4778c5c/" rel="bookmark">
			哈佛结构 和 冯·诺依曼结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序 和 数据 程序和数据都是以0和1的形式存储在相应的存储介质当中的。
数据 数据是CPU操作的内容。相当于加工的原材料。
程序 程序是指示CPU具体的操作步骤与操作流程。相当于加工的方法。
冯·诺依曼结构 和 哈佛结构 冯·诺依曼结构 冯·诺依曼结构的计算机由CPU和存储器构成，其程序和数据共用一个存储空间，程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置；采用单一的地址及数据总线，程序指令和数据的宽度相同。程序计数器（PC）是CPU内部指示指令和数据的存储位置的寄存器。
CPU通过程序计数器提供的地址信息，对存储器进行寻址，找到所需要的指令或数据，然后对指令进行译码，最后执行指令规定的操作。处理器执行指令时，先从存储器中取出指令解码，再取操作数执行运算，即使单条指令也要耗费几个甚至几十个周期；在高速运算时，在传输通道上会出现瓶颈效应。 目前使用冯·诺依曼结构的CPU和微控制器品种有很多，例如Intel公司的8086系列及其他CPU、ARM公司的ARM7、MIPS公司的MIPS处理器等。
哈佛结构 哈佛结构的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个相互独立的存储器，每个存储器独立编址、独立访问。系统中具有程序的数据总线与地址总线及数据的数据总线与地址总线。这种分离的程序总线和数据总线可允许在一个机器周期内同时获取指令字（来自程序存储器）和操作数（来自数据存储器），从而提高了执行速度及数据的吞吐率。又由于程序和数据存储器在两个分开的物理空间中，因此取指和执行能完全重叠，具有较高的执行效率。
目前使用哈佛结构的CPU和微控制器品种有很多，除DSP处理器外，还有Freescale公司的MC68系列，Zilog公司的28系列，ATMEL公司的AVR系列和ARM公司的ARM9、ARM10、ARM11等。
对比 冯诺依曼结构中程序和数据不区分的放在一起，因此安全和稳定性是个问题，好处是处理起来简单。
哈佛结构中程序（一般放在ROM、flash中）和数据（一般放在RAM中）独立分开存放，因此好处是安全和稳定性高，缺点是软件处理复杂一些（需要统一规划链接地址等）
程序空间和数据空间是否是一体的。冯·诺依曼结构数据空间和程序空间是不分开的，哈佛结构数据空间和程序空间是分开的。
早期的微处理器大多采用冯·诺依曼结构，典型代表是Intel公司的X86微处理器。取指和取操作数都在同一总线上，通过分时复用的方式进行的。缺点是在高速运行时，不能达到同时取指令和取操作数，从而形成了传输过程的瓶颈。
哈佛总线技术应用是以DSP和ARM为代表的。采用哈佛总线体系结构的芯片内部程序空间和数据空间是分开的，这就允许同时取指和取操作数，从而大大提高了运算能力。
改进型的哈佛结构与哈佛体系结构差别 与冯.诺曼结构处理器比较，哈佛结构处理器有两个明显的特点：
使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；
使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。
后来，又提出了改进的哈佛结构，其结构特点为：
使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；
具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；
两条总线由程序存储器和数据存储器分时共用。
总结 体系结构与采用的独立与否的总线无关，与指令空间和数据空间的分开独立与否有关。51单片机虽然数据指令存储区是分开的，但总线是分时复用的，所以属于改进型的哈佛结构。ARM9虽然是哈佛结构，但是之前的版本(例如ARM7)也还是冯·诺依曼结构。早期的X86能迅速占有市场，一条很重要的原因，正是靠了冯·诺依曼这种实现简单，成本低的总线结构。现在的处理器虽然外部总线上看是诺依曼结构的，但是由于内部CACHE的存在，因此实际上内部来看已经 类似 改进型哈佛结构的了。至于优缺点，哈佛结构就是复杂，对外围设备的连接与处理要求高，十分不适合外围存储器的扩展。所以早期通用CPU难以采用这种结构。而单片机，由于内部集成了所需的存储器，所以采用哈佛结构也未尝不可。现在的处理器，依托CACHE的存在，已经很好的将二者统一起来了。
参考内容：朱有鹏老师视频教程课件 &amp; 网友文章 参考内容：http://www.weboch.com.cn/ARM/neumann-harvard.asp 参考内容：http://www.weboch.com.cn/ARM/harvard-architecture.asp
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0471b11706dda85f65471539e7bbe602/" rel="bookmark">
			一键端2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新仙剑ol ： 链接：http://pan.baidu.com/s/1i3xZHLb 密码：hyly 链接: http://pan.baidu.com/s/1c0HgGKw 密码: druj 本帖隐藏的内容 龙之谷133服务端： 链接：http://pan.baidu.com/s/1i351tZn 密码：odvd 藏龙ol： 链接：http://pan.baidu.com/s/1yTVHk 密码：nbf7 星愿： 链接：http://pan.baidu.com/s/1c0jqOwS 密码：mrbh 链接：http://pan.baidu.com/s/1jGhcIeq 密码：y0e9 神创天下： 链接：http://pan.baidu.com/s/1pJmsqdt 密码：mzk7 猎灵： 链接：http://pan.baidu.com/s/1eQdNeZC 密码：8qcs 天龙八部： 唐门+新五代神器版 链接：http://pan.baidu.com/s/1i3pJtEd 密码：v23k 天龙八部单机端慕容版 链接：http://pan.baidu.com/s/1pJBbl27 密码：036s 天龙八部 2015唐门一键端 【简单版】 链接：http://pan.baidu.com/s/1hqF6rFA 密码：r0gl 斩仙录： 链接：http://pan.baidu.com/s/1sj5QXVf 密码：5tnv 链接：http://pan.baidu.com/s/1o6F04qu 密码：dubu 热血传奇： 链接：http://pan.baidu.com/s/1sjoqcDR 密码：9kue 孽族： 链接：http://pan.baidu.com/s/1ntmws33 密码：9t8m 最无极： 链接：http://yunpan.cn/cFsXWDssTMmyJ 访问密码 d356 大唐豪侠： 链接: http://pan.baidu.com/s/1c0EH6EG 密码: sdi7 天龙八部神翼版： 天龙八部-神翼一键端 【简单版】 http://yunpan.cn/cd8fXP8ZyQWgW 访问密码 25c9 XP虚拟机桌面的 GM工具可以刷装备 解压密码kukutu130.taobao.com 大荒传奇： 链接：http://pan.baidu.com/s/1sjBqC25 密码：b8hl 古羌传奇： 链接：http://pan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0471b11706dda85f65471539e7bbe602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0884ac17940a2c4ce4b193304cb8306a/" rel="bookmark">
			地址总线与数据总线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CPU通过地址总线寻址，然后通过数据总线与外部设备互换信息。
地址总线 地址总线的位数决定CPU寻址范围。 若CPU的地址总线宽度是32位，那么CPU的寻址范围是4G，所以最多支持4G内存。
数据总线 数据总线的位数决定CPU单次通信能交换的信息数量
数据总线的宽度对CPU的性能的影响 首先，总线的速度（即：CPU的主频，CPU的性能指标之一）决定CPU和外设互换信息的速度。
其次，数据总线的宽度也是表示CPU性能的参数之一（通常，我们说“64位的CPU”是指CPU的数据总线的宽度是64位）。 如：64位数据总线的CPU一次就能取出64bit的数据，8位数据总线的CPU一次只能取出8bit的数据，在相同频率的情况下，8位数据总线的CPU就得连续取8次数据，数据量才能和64位数据总线一次取出的数据量相同，单就比较取数据的性能就相差8倍。况且，通常CPU中的寄存器的位数与数据总线的宽度一样，所以在数据处理方面，64位的CPU又比8位的CPU快很多。
CPU的地址总线位数和数据总线可以不同（典型代表就是51单片机），但是一般都相同。
以下内容摘抄自网友的文章： 地址总线宽度不是直接影响到性能的参数。给个例子： 假如说有个36位地址总线宽度、32位数据总线宽度的A型号的CPU， 假如还有个32位地址总线宽度、32位数据总线宽度的B型号的CPU。 你觉得这两个型号的CPU性能上能差到哪吗？只不过B型号的CPU地址超过了32位可能就不行能，也可能需要用其他的方式组合出更长位宽的地址来，总之不如A型号直接、高效。但是，只要不是这样的情况，A和B的其他因素相同，你觉得A和B两个CPU的性能差到哪吗。
其实，intel的x86CPU就刚好有这样的情况，36位地址总线宽度、32位数据总线宽度,寄存器是32位的，你会想，那寄存器放不下36位的地址，那怎么办呢，其实它是用某种方法组合出来的36位地址，段地址32位向高位偏移4位后加上偏移地址，就出来36位的地址。 一般，寄存器的宽度和数据总线宽度是一致的，地址总线可以通过某种方式组合出来，所以可以不一致。毕竟寄存器绝大部分时间是要存储和处理数据的，不是吗，地址作为数据使用的情况在整个程序运行中占的时间是很少数的。
参考来源：朱有鹏老师视频教程课件 网友文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b80965e3adce18f8de5afb931598f80/" rel="bookmark">
			Server Tomcat v9.0 Server at localhost failed to start.解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇到这个问题纠结了半天，百度上的答案也是不一致。 我就来简单的说一下这个问题的解决方案，其实根本原因有两个。 1、自己的web.xml 配置有误，有可能是servlet-name写错了，或者class写错了，这个自己去检查
2、就是包名重复，是所有部署到服务器上的包名有重复，这个错误不应该哦
如果解决以上两个问题，你会发现你的服务器又能重新启动了。当然，还是希望大家多看看tomcat的报错信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d914b60b215c6c34b2c5fa12a9e53d02/" rel="bookmark">
			Matconvnet工具箱在Matlab中的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将官网http://www.vlfeat.org/matconvnet/quick/上的“Quick start”中的代码拷贝到Matlab工作空间并运行即可进行自动下载并安装。
自动安装时，程序包会被安装到Matlab/toolbox之中。
自己手动安装教程：
下载 到官网http://www.vlfeat.org/matconvnet/上下载相应的版本。 将下载的压缩文件解压到合适的路径下。 安装 编译前确保Matab已绑定C++编译器，否则使用命令&gt;&gt;mex -setup 进行绑定编译器。 将Matalb的工作路径切换到Matconvnet目录下，../matconvnet-1.0-beta23。 编译工具箱，&gt;&gt;run matlab/vl_compilenn ; 安装工具箱，&gt;&gt;run matlab/vl_setupnn ; 测试 在Matlab工作空间输入一下代码，并运行；成功显示图片说明安装成功。 % Download a pre-trained CNN from the web (needed once). urlwrite('http://www.vlfeat.org/matconvnet/models/imagenet-vgg-f.mat','imagenet-vgg-f.mat') ; % Load a model and upgrade it to MatConvNet current version. net = load('imagenet-vgg-f.mat') ; net = vl_simplenn_tidy(net) ; % Obtain and preprocess an image. im = imread('peppers.png') ; im_ = single(im) ; % note: 255 range im_ = imresize(im_, net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d914b60b215c6c34b2c5fa12a9e53d02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d739d044709bc56c98773d8cc4ab7c1/" rel="bookmark">
			变量声明-TS学习笔记（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let和const是JavaScript里相对较新的变量声明方式。 像我们之前提到过的，let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。
因为TypeScript是JavaScript的超集，所以它本身就支持let和const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替var。
var 声明 一直以来我们都是通过var关键字定义JavaScript变量。
var a = 10; 大家都能理解，这里定义了一个名为a值为10的变量。
我们也可以在函数内部定义变量：
function f() { var message = "Hello, world!"; return message; } 并且我们也可以在其它函数内部访问相同的变量。
function f() { var a = 10; return function g() { var b = a + 1; return b; } } var g = f(); g(); // returns 11; 上面的例子里，g可以获取到f函数里定义的a变量。 每当g被调用时，它都可以访问到f里的a变量。 即使当g在f已经执行完后才被调用，它仍然可以访问及修改a。
function f() { var a = 1; a = 2; var b = g(); a = 3; return b; function g() { return a; } } f(); // returns 2 作用域规则 对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d739d044709bc56c98773d8cc4ab7c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db171c6cdfca15f291a3cfbdc7fb507/" rel="bookmark">
			jquery 实时监听输入框值变化的完美方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 只需要同时绑定 oninput 和 onpropertychange 两个事件，但是这并不完美
$('.input-form :input').bind('input propertychange', function() { //获取.input-form下的所有 &lt;input&gt; 元素,并实时监听用户输入 //逻辑 }) 以上代码在因为用的bind，所以当遇到追加的新input标签时，则不能监听了。 如下情景： 由上图可以看到189和135号码是可以监听的，但是新追加的178和188则无效。
怎么解决这个问题呢？ 整了大半天，好吧，用live代替bind即可
$('.input-form :input').live('input propertychange', function() { //获取.input-form下的所有 &lt;input&gt; 元素,并实时监听用户输入 //逻辑 }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/551f663c3b0ace29271a8c0cf6aae89c/" rel="bookmark">
			Django管理文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 本页文档讲述Django 的文件访问API，例如用户上传的文件。这些底层的API 足够通用以致于你可以用于其它目的。如果你想要处理静态文件（JS、CSS等），参见管理静态文件（CSS和图像）。
默认情况下，Django 将文件储存在本地， 用到的设置是MEDIA_ROOT 和MEDIA_URL。下面的例子假设你使用它们的默认值。
然而，Django 提供编写自定义文件储存系统方法，允许你完全自定义Django 在哪里以及如何储存文件。这篇文档的另外一半描述这些储存系统如何工作。
在模型中使用文件 当你使用FileField 或者 ImageField的时候，Django为你提供了一系列的API用来处理文件。
考虑下面的模型，它使用ImageField来储存一张照片：
from django.db import models class Car(models.Model): name = models.CharField(max_length=255) price = models.DecimalField(max_digits=5, decimal_places=2) photo = models.ImageField(upload_to='cars') 任何Car的实例都有一个 photo字段，你可以通过它来获取附加图片的详细信息：
&gt;&gt;&gt; car = Car.objects.get(name="57 Chevy") &gt;&gt;&gt; car.photo &lt;ImageFieldFile: chevy.jpg&gt; &gt;&gt;&gt; car.photo.name 'cars/chevy.jpg' &gt;&gt;&gt; car.photo.path '/media/cars/chevy.jpg' &gt;&gt;&gt; car.photo.url 'http://media.example.com/cars/chevy.jpg' 例子中的car.photo 对象是一个File 对象，这意味着它拥有下面描述的所有方法和属性。
注意
文件保存是数据库模型保存的一部分，所以磁盘上真实的文件名在模型保存之前并不可靠。
例如，你可以通过设置文件的 name属性为一个和文件储存位置 （MEDIA_ROOT，如果你使用默认的FileSystemStorage）相关的路径，来修改文件名称。
&gt;&gt;&gt; import os &gt;&gt;&gt; from django.conf import settings &gt;&gt;&gt; initial_path = car.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/551f663c3b0ace29271a8c0cf6aae89c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a89a8abc2cf3d0628fce070f25cc574/" rel="bookmark">
			jQuery的LG的自定义插件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下：
(function ($)
{
//全局系统对象
window['LG'] = {};
LG.cookies = (function ()
{
var fn = function ()
{
};
fn.prototype.get = function (name)
{
var cookieValue = "";
var search = name + "=";
if (document.cookie.length &gt; 0)
{
offset = document.cookie.indexOf(search);
if (offset != -1)
{
offset += search.length;
end = document.cookie.indexOf(";", offset);
if (end == -1) end = document.cookie.length;
cookieValue = decodeURIComponent(document.cookie.substring(offset, end))
}
}
return cookieValue;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a89a8abc2cf3d0628fce070f25cc574/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c194a92f869efcd68bd206ef906b5742/" rel="bookmark">
			Jquery的$.ajax防止重复提交的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、第一种，对于onclick事件触发的的ajax 可以采用如下方法： 即在beforeSend中使点击按钮不可用，ajax结果返回后置为可用
$.ajax( { type: 'POST', url: APP+'?m=Shopping&amp;a=ajaxSubmitorder&amp;sid='+sid+'&amp;src='+src, cache:false, dataType: 'json', data: {'src':src,"uid": uid,'shipping_id':shipping_id,'order_amount':order_amount,'amount':amount,'postscript':postscript,'addr_id':addr_id}, async: false, beforeSend:function() { //触发ajax请求开始时执行 $('#submit_font').text('提交订单中...'); $('.pay_alipay').attr('onclick','javascript:void();');//改变提交按钮上的文字并将按钮设置为不可点击 }, success: function (msg, textStatus) { if(msg.result==1) { $.Alert('成功提交订单', 160); window.location.href=APP+'?m=Pay&amp;a=index&amp;sid='+ sid + '&amp;fuid='+ fuid + '&amp;parent_order_sn='+msg.parent_order_sn; } else { $.Alert(msg.msg, 160); $('#submit_font').text('提交订单'); $('.pay_alipay').attr('onclick','submitorder();');//改变提交按钮上的文字并将按钮设置为可点击 } }, error: function (textStatus) { $.Alert('网络繁忙，请稍后再试...', 160); $('#submit_font').text('提交订单'); $('.pay_alipay').attr('onclick','submitorder();');//改变提交按钮上的文字并将按钮设置为可点击 }, complete: function(msg, textStatus) { //ajax请求完成时执行 if(msg.result==1) { $('#submit_font').text('提交订单'); $('.pay_alipay').attr('onclick','javascript:void();');//改变提交按钮上的文字并将按钮设置为可以点击 } } }); 2、利用jquery ajaxPrefilter中断请求 1）Prefilters是一个预过滤器，在每个请求之前被发送和$.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c194a92f869efcd68bd206ef906b5742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca581cb0c2d27b7cc7ac4eecb5d3ee3e/" rel="bookmark">
			STM32F103按键操作的另一种实现——状态机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#ifndef _KEY_H_ #define _KEY_H_ #include "HAL_gpio.h" // 换成STM32F103对应的GPIO库 #include "type.h" // type.h主要是一些类型的重命名 #define KEY_UP_GRP GPIOA #define KEY_UP_IDX GPIO_Pin_9 #define KEY_UP_IS_DOWN() GPIO_ReadInputDataBit(KEY_UP_GRP, KEY_UP_IDX) #define KEY_UP_CONFIG() GPIOConfig(KEY_UP_GRP, KEY_UP_IDX, GPIO_Mode_IPU) // 这个函数我在之前帖子里面写过 #define KEY_DOWN_GRP GPIOA #define KEY_DOWN_IDX GPIO_Pin_10 #define KEY_DOWN_IS_DOWN() GPIO_ReadInputDataBit(KEY_DOWN_GRP, KEY_DOWN_IDX) #define KEY_DOWN_CONFIG() GPIOConfig(KEY_DOWN_GRP, KEY_DOWN_IDX, GPIO_Mode_IPU) #define KEY_FUNC_GRP GPIOA #define KEY_FUNC_IDX GPIO_Pin_11 #define KEY_FUNC_IS_DOWN() GPIO_ReadInputDataBit(KEY_FUNC_GRP, KEY_FUNC_IDX) #define KEY_FUNC_CONFIG() GPIOConfig(KEY_FUNC_GRP, KEY_FUNC_IDX, GPIO_Mode_IPU) #define KEY_TURN_GRP GPIOA #define KEY_TURN_IDX GPIO_Pin_12 | GPIO_Pin_13 #define KEY_TURN_IS_DOWN() GPIO_ReadInputDataBit(KEY_TURN_GRP, KEY_TURN_IDX) #define KEY_TURN_CONFIG() GPIOConfig(KEY_TURN_GRP, KEY_TURN_IDX, GPIO_Mode_IPU) //==================================================================================== typedef enum { CONFIRM_KEY = 1, FUNC_KEY, UP_KEY, DOWN_KEY } key_event_t; #define state_keyUp 0 //初始状态,未按键 #define state_keyDown 1 //键被按下 #define state_keyLong 2 //长按 #define state_keyTime 3 //按键计时态 #define return_keyUp 0x00 //初始状态 #define return_keyPressed 0x01 //键被按过,普通按键 #define return_keyLong 0x02 //长按 #define return_keyAuto 0x04 //自动连发 #define key_down 0 //按下 #define key_up 0xf0 //未按时的key有效位键值 #define key_longTimes 100 //10ms一次,200次即2秒,定义长按的判定时间 #define key_autoTimes 20 //连发时间定义,20*10=200,200毫秒发一次 #define KEYS1_VALUE 0xe0 //keyS1 按下 #define KEYS2_VALUE 0xd0 //keyS2 按下 #define KEYS3_VALUE 0xb0 //keyS3 按下 #define KEYS4_5_VALUE 0x70 //keyS4_5 按下 //==================================================================================== void KeyProcess(void); //T0定时器调用的工作函数 void KeyTimerInit(void); #endif /* _KEY_H_ */ #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca581cb0c2d27b7cc7ac4eecb5d3ee3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72f41288cbf36a1bd7e86b6d030f1d3/" rel="bookmark">
			Url参数中出现&#43;、空格、=、%、&amp;、#等字符的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://www.jeffjade.com/2015/04/16/2015-04-16-deal-url-special-char/
Url出现了有+，空格，/，?，%，#，&amp;，=等特殊符号的时候，可能在服务器端无法获得正确的参数值，抑或是造成不能正常下载文件(作为Download Url时候)，如何是好？解决办法：就是需要将这些字符转化成服务器可以识别的字符；但是为何Url中有这些字符就会出现问题呢？这就得涉及到URL编码与解码问题了。
URL编码与解码 一般来说，URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。Url的编码格式采用的是ASCII码，而不是Unicode，这也就是说你不能在Url中包含任何非ASCII字符，例如希腊字母or中文。比如，世界上有英文字母的网址http://www.abc.com，但是没有希腊字母的网址http://www.aβγ.com（读作阿尔法-贝塔-伽玛.com）。这是因为网络标准RFC 1738做了硬性规定：
只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!*’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。 这意味着，如果URL中有汉字，等特殊字符的时候，就必须编码后使用。而+，空格，/，?，%，#，&amp;，=，这些字符(不安全)，当把他们直接放在Url中的时候，可能会引起解析程序的歧义，因此也必须经过编码才能使用。
解决办法 将这些字符转化成服务器可以识别的字符，对应关系如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e3bf42599f926bed116b6176f797916/" rel="bookmark">
			WinEdt 和 Sumatra 双向关联设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）配置PDF Viewer，在菜单栏选Options -&gt; Execution Modes -&gt;PDF Viewer -&gt; 点击右侧的“Browse”按钮，在弹出窗口中选择SumatraPDF程序的路 径，"xxxxx\SumatraPDFPortable\App\sumatrapdf\SumatraPDF.exe"，一定要SumatraPDF.exe 文件才行！xxxxx是你机器上的路径。注意到PDF Viewer窗口下方的“Use -- synctex ……”前的选项一定要打勾。 （2） SumatraPDF软件中，设置--选项--请输入双击PDF文档时的命令行调用： 输入 "xxxxxx\WinEdt\WinEdt.exe" "[Open(|%f|);SelPar(%l,8)]" 第一个引号里面 是你的 WinEdt.exe 的文件路径。 （3）在菜单栏选Options -&gt; Execution Modes -&gt; Console Applications -&gt;在左侧面板 Accessories 中选择PDFLaTeX 项，然后在中间的 Process Flow 窗口勾选 Start Viewer 以及之下的 Forward Serach 这两个选项。保存即可。 转载于:https://www.cnblogs.com/lvchaoshun/p/5906871.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada2262037064761cf3881c8b58cbae9/" rel="bookmark">
			jquery实现内容滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML代码：
&lt;div class="scollNews"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;6&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;7&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;8&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;9&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;10&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; jquery代码：
$(function(){ var settime; $(".scollNews").hover(function(){ clearInterval(settime); },function(){ settime=setInterval(function(){ var $first=$(".scollNews ul:first"); //获取类名下的第一个ul var height=$first.find("li:first").height(); //获取第一个li的高 $first.animate({"marginTop":-height+"px"},100,function(){ $first.css({marginTop:0}).find("li:first").appendTo($first); //设置上边距为零，为了下一次移动做准备 }); },1000); }).trigger("mouseleave"); //自动触发元素的制定事件类型 }) 注：只要修改动画时间就可以控制滚动的速度。
转载于:https://www.cnblogs.com/zhiling/p/5812288.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d26e560246b27994a300c7ff9c74888a/" rel="bookmark">
			Spring mvc  ajax post 415 Unsupported Media Type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1很明显是客户端错误，于服务端无关。出现这个的问题在于，你想使用对象传参。 2.解决方案有二种： 1.ajax代码修改如下：
$.ajax({ type: 'POST', contentType: 'text/javascript', url: url + '?r=' + Math.random(), data: JSON.stringify(datamodel),//这里要和后端对象属性对应 dataType: datatype ? datatype : 'json', success: function (d) { if (callbackSuccess != null) { callbackSuccess(d); } }, error: function (XMLHttpRequest, textStatus, errorThrown) { callbackFailed(textStatus, XMLHttpRequest); }, timeout: 30000 }); spring mvc配置文件： &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="false"&gt; &lt;bean class="org.springframework.http.converter.ByteArrayHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.FormHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;!-- *****自定义JSON返回类型***** --&gt; &lt;value&gt;text/javascript;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d26e560246b27994a300c7ff9c74888a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d86f93f29e8c853218853ccbd25391c1/" rel="bookmark">
			题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。
解析：思路一：遍历的顺序是从头到尾的顺序，可输出的顺序却是从尾到头。也就是说第一个遍历到的结点最后一个输出，而最后一个遍历到的结点第一个输出。这就是典型的“后进先出”，我们可以用栈实现这种顺序。
每经过一个结点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，此时输出的结点的顺序已经反转过来了。
代码实现 ：
//利用栈：从尾到头打印链表 void PrintListReversing_Stack(ListNode* pHead) { std::stack&lt;ListNode*&gt; node; ListNode* pNode = pHead; while (pNode!=NULL) { node.push(pNode); pNode = pNode-&gt;m_pNext; } while (!node.empty()) { pNode = node.top(); cout &lt;&lt; pNode-&gt;m_nValue &lt;&lt; " "; node.pop(); } } 思路二：用递归实现
//递归法：从尾到头打印链表 void PrintListReversing_Recursive(ListNode* pHead) { if (pHead != NULL) { if (pHead-&gt;m_pNext != NULL) { PrintListReversing_Recursive(pHead-&gt;m_pNext); } cout &lt;&lt; pHead-&gt;m_nValue &lt;&lt; " "; } } 上面的基于递归的代码看起来很简洁，但是当链表非常长的时候，就会导致函数递归很深，从而有可能导致函数调用栈溢出。显然用栈基于循环实现的代码的鲁棒性要好一些。
测试用例：
// ====================测试代码==================== void Test(ListNode* pHead) { PrintList(pHead); cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d86f93f29e8c853218853ccbd25391c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f668888d3ade58b1c9ee0c3a5f15fa1/" rel="bookmark">
			android开发 java.lang.IllegalStateException at android.media.MediaPlayer._prepare(Native Method)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到一个问题，我在service里面播放一段音乐时遇到了IllegalStateException异常，代码是这样的：
protected void play() { System.out.println("play"); mpMediaPlayer = MediaPlayer.create(this, R.raw.dd); try { mpMediaPlayer.prepare(); } catch (IllegalStateException e) { e.printStackTrace(); }catch (IOException e){ e.printStackTrace(); } mpMediaPlayer.start(); mpMediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {//设置重复播放 @Override public void onCompletion(MediaPlayer mediaPlayer) { mpMediaPlayer.start(); mpMediaPlayer.setLooping(true); } }); } error:
08-16 14:47:09.822 21109-23341/com.shangyi.supplier W/System.err: java.lang.IllegalStateException 08-16 14:47:09.822 21109-23341/com.shangyi.supplier W/System.err: at android.media.MediaPlayer._prepare(Native Method) 08-16 14:47:09.822 21109-23341/com.shangyi.supplier W/System.err: at android.media.MediaPlayer.prepare(MediaPlayer.java:1193) 08-16 14:47:09.822 21109-23341/com.shangyi.supplier W/System.err: at com.shangyi.service.SupplierService.play(SupplierService.java:139) 08-16 14:47:09.822 21109-23341/com.shangyi.supplier W/System.err: at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f668888d3ade58b1c9ee0c3a5f15fa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5232255f6a342ad60f28139ab2845aee/" rel="bookmark">
			30天自制操作系统第二天笔记  Makefile文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Makefile的作用就是将我们之前所需的make.bat,run.bat,install.bat这些批处理文件整合到一起写入到该文件中，我们直接用Makefile就可以取代这些文件了。 Makefile文件写法非常简单，首先生成一个不带扩展名的Makefile,然后用文本编辑器写入一下内容：
default : ../z_tools/make.exe img # 文件生成方法 ipl.bin : ipl.nas Makefile ../z_tools/nask.exe ipl.nas ipl.bin ipl.lst helloos.img : ipl.bin Makefile ../z_tools/edimg.exe imgin:../z_tools/fdimg0at.tek \ wbinimg src:ipl.bin len:512 from:0 to:0 imgout:helloos.img # コマンド asm : ../z_tools/make.exe -r ipl.bin img : ../z_tools/make.exe -r helloos.img run : ../z_tools/make.exe img copy helloos.img ..\z_tools\qemu\fdimage0.bin ../z_tools/make.exe -C ../z_tools/qemu install : ../z_tools/make.exe img ../z_tools/imgtol.com w a: helloos.img clean : -del ipl.bin -del ipl.lst src_only : ../z_tools/make.exe clean -del helloos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5232255f6a342ad60f28139ab2845aee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42ad197a29fb7663aaec6698439b173f/" rel="bookmark">
			使用zsh插件`zsh-syntax-highlighting`高亮你的zsh可用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装zsh 在ubuntu中安装与配置zsh与oh-my-zsh
效果展示 安装 对于OS X用户 直接
brew install zsh-syntax-highlighting 会自动下载这个插件，并将
source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 这一句加在你的~/.zshrc中。
对于Oh-my-zsh用户 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 然后激活这个插件，通过在 ~/.zshrc 中加入插件的名字 plugins=( [plugins...] zsh-syntax-highlighting) 最后当然是source一下，让改变生效
source ~/.zshrc Note:插件可以装很多，但是装多了之后会在每次进入命令提示符的时候明显变慢。慎用。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/207/">«</a>
	<span class="pagination__item pagination__item--current">208/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/209/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>