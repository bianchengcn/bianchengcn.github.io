<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6627367e1e4627199852f1406cea8465/" rel="bookmark">
			int a; int* a; int** a; int (*a)[]; int (*a)(int)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a) int a;表示一个内存空间，这个空间用来存放一个整数（int）；
b) int* a;表示一个内存空间，这个空间用来存放一个指针，这个指针指向一个存放整数的空间，即a)中提到的空间；
c) int** a;表示一个内存空间，这个空间用来存放一个指针，这个指针指向一个存放指针的空间，并且指向的这个空间中的指针，指向一个整数。也简单的说，指向了一个b)中提到的空间；
d) int (*a)[4];表示一个内存空间，这个空间用来存放一个指针，这个指针指向一个长度为4、类型为int的数组；和int** a的区别在于，++、+=1之后的结果不一样，其他用法基本相同。
以上四种类型见上图表示。
e) int (*a)(int);表示一个内存空间，这个空间用来存放一个指针，这个指针指向一个函数，这个函数有一个类型为int的参数，并且函数的返回类型也是int。
重点：
int *p[]和int (*p)[]
前者是指针数组，后者是指向数组的指针。更详细地说。
前: 指针数组;是一个元素全为指针的数组.
后: 数组指针;可以直接理解是指针,只是这个指针类型不是int也不是char而是 int [4]类型的数组.(可以结合函数指针一并看看......)
int*p[4]------p是一个指针数组，每一个指向一个int型的
int (*q)[4]---------q是一个指针，指向int[4]的数组。
定义涉及两个运算符：“*”（间接引用）、“[]”（下标），“[]”的优先级别大于“*”的优先级别。
首先看int *p[4]，“[]”的优先级别高，所以它首先是个大小为4的数组，即p[4]；剩下的“int *”作为补充说明，即说明该数组的每一个元素为指向一个整型类型的指针。int *p[4]的存储结构如下：(存储方格横向排列或竖向排列没区别，只要按内存地址顺序排列就行，此处只是为画图方便)
再看int (*q)[4]。它首先是个指针，即*q，剩下的“int [4]”作为补充说明，即说明指针q指向一个长度为4的数组。int (*q)[4]的存储结构如下：
请看以下定义：
int a[2][4]={{2,5,6,8},{22,55,66,88}};
int c[4]={5,8,9,4};
int d[3]={23,12,443};
int *p[4],(*q)[4];
q=a;
*p=c;
*(p+1)=d；
则int *p[4]和int (*q)[4]的存储数据为：
验证：
#include &lt;stdio.h&gt;
int main(void)
{
int a[2][4]={{2,5,6,8},{22,55,66,88}};
int c[4]={5,8,9,4};
int d[3]={23,12,443};
int *p[4],(*q)[4];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6627367e1e4627199852f1406cea8465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d14487054347e0c0bfbb710012ceb4/" rel="bookmark">
			java经典问题（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：
1、介绍你做过的项目中遇到的难点以及你是如何解决的。 2、java中有指针吗？ 3、java的垃圾回收机制 4、用过什么框架 5、数据库防守、注入的常用手段 6、list、map 7、arraylist和linkedlist数据结构的区别 8、介绍一下堆排序 9、最近在读哪些书？ 10、linux文件系统分为几种？ 11、如何对linux文件进行更改权限的操作 12、java中异常的分类，outofmemory异常是在什么情况下产生的？ 13、Java中的可以指定进行内存回收吗（垃圾回收机制方面的问题） 其实电话面试并不难，主要是问一些基础性的东西。电面官有点严肃，有点给人心理压力。 14、arraylist的长度是多少？ 我的回答以及后期的修正（当时回答的特别差劲，现在的答案是后来思考和查找了一些资料）： 1、根据个人的项目经验而异，这个大多数面试中都会被问到。 2、Java中不存在指针，C、 C++中有，这是Java和C、C++的区别。C和C++的区别在于他们解决问题的思想不一样。C++是设计这个概念被融入到C++之中，而对于C，更注重的是算法。Java中对于指针进行伪装，概念上弱化和淡化，实际上是有的。 3、对于Java中的垃圾回收机制并没有过多的了解，只知道Java是会自动回收垃圾的，而且回收垃圾对于程序员而言是不可见的，无法预知垃圾回收是否完成。 4、过去所做的项目中几乎都没怎么用框架，之后要开始学习框架的使用。比较熟悉的可能就是MVC设计模式了。 model（模型层）、view（视图层）、controller（控制层） 5、要了解数据库防守，就得对注入有一定的了解。数据库注入的常用手段有，URL地址注入、表单注入和使用注入工具等等。 防守：黑白名单验证、表单验证以及权限控制。 6、list和map的区别。map是键值对的映射，都是属于Java的集合类。 7、arraylist的是使用数组存储 而linkedlist使用的是链表存储。他们存储方式的不同也就导致了他们在插入、查找的时候的效率也不同。 8、堆排序 这是常识了 9、鸟哥的Linux私房菜（答此题要慎重，后面一连串关于Linux的问题由此而来，可是我才看这本书不久） 10、不懂 11、chmod 12、一共分为两大类。所有的异常都继承自java.lang.Throwable类 Throwable有两个直接子类。error和exception 13、当时回答不可以，后来查资料知道是可以的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e621a37fa696438a3d914c64b44f84/" rel="bookmark">
			[进阶]-Python3 异步编程详解（史上最全篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 什么是异步编程
1.1 阻塞
1.2 非阻塞
1.3 同步
1.4 异步
1.5 并发
1.6 并行
1.7 概念总结
1.8 异步编程
1.9 异步之难(nán)
2 苦心异步为哪般
2.1 CPU的时间观
2.2 面临的问题
2.3 解决方案
3 异步I/O进化之路
3.1 同步阻塞方式
3.2 改进方式：多进程
3.3 继续改进：多线程
3.4 非阻塞方式
3.5 非阻塞改进
3.5.1 epoll
3.5.2 回调(Callback)
3.5.3 事件循环（Event Loop）
3.5.4 总结
4 Python 对异步I/O的优化之路
4.1 回调之痛，以终为始
4.2 核心问题
4.3 协程
4.4 基于生成器的协程
4.4.1 未来对象(Future)
4.4.2 重构 Crawler
4.4.3 任务对象(Task)
4.4.4 事件循环(Event Loop)驱动协程运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38e621a37fa696438a3d914c64b44f84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61002d662b20fd3ab9d0c34a54e377e8/" rel="bookmark">
			Java位运算总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是自己4年前的Java学习笔记，现发布在ITEye留作纪念，同时也希望对那些刚刚接触Java的童鞋们有些许帮助。
情如痕，缘似印，奈何情深缘浅海誓山盟空对月，流尽痴泪只为你我心再近，踏破情路惟愿红尘有你。
---------清晨随感
前天几天研究了下JDK的Collection接口，本来准备接着研究Map接口，可是一查看HashMap类源码傻眼咯，到处是位运算实现，所以我觉得还是有必要先补补位运算知识，不然代码看起来有点费力。今天系统研究了下，现记录如下。
首先要明白一个概念，Java位运算是针对于整型数据类型的二进制进行的移位操作。主要包括位与、位或、位非，有符号左移、有符号右移，无符号右移等等。需要注意一点的是，不存在无符号左移&lt;&lt;&lt;运算符。根据位运算的概念规定，我们首先需要弄明白两个问题，java有哪些数据类型是整型数据类型和各数字进制之间转换问题。Java整型数据类型有：byte、char、short、int、long。要把它们转换成二进制的原码形式，必须明白他们各占几个字节。我们都知道，一个字节占8位。
数据类型 所占位数
byte 8 boolean 8
short 16
int 32 long 64 float 32 double 64 char 16
还需要明白一点的是：计算机表示数字正负不是用+ -加减号来表示，而是用最高位数字来表示，0表示正，1表示负
所以比如-4用二进制原码表示就是1111 1111 1111 1111 1111 1111 1111 1100
下面根据实例一个一个的来说明各种位运算的运算规则：
位与&amp;(真真为真 真假为假 假假为假)
4&amp;6
0000 0000 0000 0000 0000 0000 0000 0100
0000 0000 0000 0000 0000 0000 0000 0110
0000 0000 0000 0000 0000 0000 0000 0100
结果：4
位或|(真真为真 真假为真 假假为假)
4|6
0000 0000 0000 0000 0000 0000 0000 0100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61002d662b20fd3ab9d0c34a54e377e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c916a61c39ffab08df929ee149db6a/" rel="bookmark">
			Win7x64系统过TP的一些尝试和目前遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实渣新学内核编程不过半个月时间，帖中难免有幼稚的想法和错误，遇到的问题我会用蓝色文字表述，还请各位前辈指正，感激不尽！ 我把自己目前的进展和遇到的问题一起说说吧： x64系统过TP大概分两步，首先要过双机调试，然后要过应用层调试。 1、过双机调试，这里也分两步 (1)首先要保证debug模式下启动游戏不蓝屏。 我也是第一次研究TP，对这之前的保护不了解，不过看网上所说这个启动蓝屏似乎是最近几个月新加的。 要过这个需要对内核调试引擎有一定的了解，不过还好我们是站在巨♂人♀的肩膀上，在看雪找到了篇帖子，比较详细的分析了系统启动时内核调试引擎初始化的几个标志。 TP只是检测了其中一个(待定)， KdEnteredDebugger，它通过MDL映射来判断这个标志是不是True，如果是就蓝屏，解决方法我照抄了那篇帖子，直接在Hook一下IoAllocateMdl， 把判断的地址改到一个恒为False的地方这样就可以绕过了 [C++] 纯文本查看 复制代码 ? 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 PMDL newIoAllocateMdl( __in_opt PVOID VirtualAddress, __in ULONG Length, __in BOOLEAN SecondaryBuffer, __in BOOLEAN ChargeQuota, __inout_opt PIRP Irp OPTIONAL) { if (VirtualAddress == KdEnteredDebugger) { //DbgPrint("[KdEnteredDebugger] address: %p\n", KdEnteredDebugger); VirtualAddress = ( PUCHAR )KdEnteredDebugger + 0x30; //据观察，+0x30 的位置恒为0 } return oldIoAllocateMdl(VirtualAddress, Length, SecondaryBuffer, ChargeQuota, Irp); } 不过这样做带来一个问题，蓝屏是不蓝屏了，TP的驱动模块也能加载，但只能启动登陆客户端Client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72c916a61c39ffab08df929ee149db6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859b429980701826e2f2fbca0b4c1dc3/" rel="bookmark">
			C&#43;&#43;学习：使用libssh2实现交互式shell的ssh2，linux和windows通用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用ssh2实现shell自动化测试，实际工作中遇到非常多。各种语言都有相应的库可以使用。比如，c/c++语言可以使用libssh2；python可以使用paramkio库等。但这些库网上的帮助，都不是很全，都比较浅显。shell自动化，最基本的三个需求，一个是适合多重类型的操作系统；二是要能够支持交互式shell，比如使用sudo执行时，需要输入密码；三是读数据时要非阻塞的。
paramkio好像不支持交互式（shell命令不需要再根据输出输入不同的参数，实际上，这种情况遇到非常多），而且paramkio在windows上也很不好用，要实现非阻塞，找了几天都没能找到好的办法。
libssh2表面上不支持交互式，官方的例子也没有针对交互式shell进行举例，给库的使用者带来很大的困扰，比较难入门。实际上libssh2库是支持交互式shell的，而且支持多种OS，实现起来也相当的简单，只是过程摸索过于痛苦。关于libssh2的编译，也比较简单，这里就不列举了。libssh2是c语言的，样例写起来很繁琐，因此我用c++进行封装，学习起来比较直观。
实际libssh2两个官方的样例scp.c和scp_echo.c已经提供了交互式shell的实现方式，只是scp_echo.c有关ssh2登陆认证方式，没有像scp.c使用了ssh2的键盘交互式方式，一般ssh2服务器默认提供这个认证方式。scp_echo.c不容易调试通过。
首先，先看一下实现Ssh2类的使用代码：
#include &lt;iostream&gt; #include "ssh2.h" int main(int argc, const char * argv[]) { using namespace std; using namespace fish; Ssh2 ssh("127.0.0.1"); ssh.Connect("test","xxxxxx"); Channel* channel = ssh.CreateChannel(); channel-&gt;Write("cd /;pwd"); cout&lt;&lt;channel-&gt;Read()&lt;&lt;endl; channel-&gt;Write("ssh 127.0.0.1"); cout&lt;&lt;channel-&gt;Read(":")&lt;&lt;endl; channel-&gt;Write("xxxxxx"); cout&lt;&lt;channel-&gt;Read()&lt;&lt;endl; channel-&gt;Write("pwd"); cout&lt;&lt;channel-&gt;Read()&lt;&lt;endl; delete channel; return 0; } 读写都是非阻塞的，这个实际使用非常方便。代码就不详细讲解了。
Ssh2类的实现代码如下:
class Ssh2 { public: Ssh2(const string &amp;srvIp, int srvPort=22 ); ~Ssh2(void); bool Connect( const string &amp;userName, const string &amp;userPwd); bool Disconnect(void); Channel* CreateChannel(const string &amp;ptyType = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/859b429980701826e2f2fbca0b4c1dc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218677bd34909818a294095a4744c97e/" rel="bookmark">
			VB调试中的条件断点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如某For循环中，最终发现当i=31时出错，这时你需要在i=31时单步调试，有4个方法： 1.在n = fun1(i)行设置断点，然后按F5一步步到i=31时改按F8进入子函数单步调试 2.插入一小片代码设置断点，例如： Visual Basic code ? 1 2 3 4 5 6 7 8 9 10 Dim i%, n% For i = 1 To 100 '其他代码 if i=31 then aa=1 '在这行设置断点，这行本身没有意义就是为了可以设置断点的。 end if n = fun1(i) debug.print i,n '其他代码 Next 3.用debug.assert Visual Basic code ? 1 2 3 4 5 6 7 8 Dim i%, n% For i = 1 To 100 '其他代码 debug.assert i&lt;&gt;31 n = fun1(i) debug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/218677bd34909818a294095a4744c97e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da9dd6d73c5f7925102fee0247dac67e/" rel="bookmark">
			Cocos2d-x碰撞检测原理与英雄要打死怪物--之游戏开发《赵云要格斗》（7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里是Evankaka的博客，欢迎大家前面讨论与交流～～～～～～
转载请注明出处http://blog.csdn.net/evankaka/article/details/42689689
本文将详细讲述cocos2dx中英雄与怪物的碰撞检测原理，其实就是精灵和精灵碰撞检测哈。本文主要从矩形碰撞入手，自己编写了一个矩形碰撞检测的函数，并且在游戏中来进行应用。另一方面，当英雄出动攻击后，如果英雄和怪物碰撞到的话，怪物就要掉血，并且当怪物血量为0时，怪物死亡，死亡之前它还会倒在地上闪烁几下。下面，开始吧
cocos2d-x版本：2.2.5
工程环境：windows7+VS2010
打开方式：将工程放在cocos2d-x安装目录下的project文件夹下用VS打开
源码免费下载
先来看看效果：
目录
一、精灵碰撞检测原理
二、自定义碰撞检测函数
三、英雄要打死怪物
四、思路总结
一、精灵碰撞检测原理 碰撞检测网上有很多人在讲，但是一般都只讲怎么用，也都没具体的讲讲原理，自己下来就摸索了下，发现其实这个确实很简单。
首先，我们来看看两个矩形，我们定义如下两个矩形，矩形1：红色；矩形2：黑色
如果我们把它们所有的不碰撞的情形列出来，那么其它的不就是碰撞的么，想到这一点，我就从这个出发，然后它们不碰撞的情形我们可以分为四种
矩形1：红色；矩形2：黑色
1.矩形1在矩形2左方，两者无碰撞
成立条件：x1+w1*0.5&lt;x2-w2*0.5
2.矩形1在矩形2右方，两者无碰撞
成立条件：：x1-w1*0.5&gt;x2+w2*0.5
3.矩形1在矩形2下方，两者无碰撞
成立条件：：y1+h1*0.5&lt;y2-h2*0.5
4.矩形1在矩形2上方，两者无碰撞
成立条件：y1-h1*0.5&gt;y2+h2*0.5
上面四种就是所有的不碰撞的情况了，然后我们弄个判断，依次检测上面四种情形，一旦发现有一种情况成立，就返回无碰撞，如果四种情况都不成立，那恭喜你了，碰撞成功了！
二、自定义碰撞检测函数 碰撞检测对于精灵类可以用
sprite1-&gt;boundingBox().intersectsRect(sprite1-&gt;boundingBox()) 只不过我这个游戏中的英雄和怪物都是自己定义的类，所以直接调用上面的函数就出点儿问题，所以自己就把前面碰撞检测的原理写了个函数，可以直接调用了，不用管你是什么对像。
首先，在用到碰撞检测的地方#include "HelloWorldScene.h"
定义函数
//矩形碰撞检测
bool isRectCollision (CCRect rect1, CCRect rect2);
然后在其实现函数里HelloWorldScene.cpp里：
///碰撞检测 bool HelloWorld::isRectCollision (CCRect rect1, CCRect rect2) { float x1 = rect1.origin.x;//矩形1中心点的横坐标 float y1 = rect1.origin.y;//矩形1中心点的纵坐标 float w1 = rect1.size.width;//矩形1的宽度 float h1 = rect1.size.height;//矩形1的高度 float x2 = rect2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da9dd6d73c5f7925102fee0247dac67e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a537e123b12e7b445a9214d4737fa977/" rel="bookmark">
			varchar和text说不清的那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有几个同学问我varchar和text有啥别吗，这个问题，以前说真的也没太多的整理，以前遇到text在设计中就是尽可能的拆到另一个表中，保持主表尽量的瘦小，可以让innodb bp缓存更多的数据。
今天借次机会系统整理一下，主要从存储上，最大值，默认值几个方面进行比较。
BTW： 从ISO SQL:2003上讲VARCHAR是一个标准型，但TEXT不是（包括tinytext）.varchar在MySQL 5.0.3之前只支持0-255byte, 在5.0.3之后才支持到0-65535byte.
从存储上讲：
- text 是要要进overflow存储。 也是对于text字段，不会和行数据存在一起。但原则上不会全部overflow , 会有768字节和原始的行存储在一块，多于768的行会存在和行相同的Page或是其它Page上。 - varchar 在MySQL内部属于从blob发展出来的一个结构，在早期版本中innobase中，也是768字节以后进行overfolw存储。 - 对于Innodb-plugin后： 对于变长字段处理都是20Byte后进行overflow存储 （在新的row_format下：dynimic compress） 说完存储后，说一下使用这些大的变长字段的缺点：
- 在Innobase中,变长字段，是尽可能的存储到一个Page里，这样，如果使用到这些大的变长字段，会造成一个Page里能容纳的行 数很少，在查询时，虽然没查询这些大的字段，但也会加载到innodb buffer pool中，等于浪费的内存。 （buffer pool 的缓存是按page为单位）（不在一个page了会增加随机的IO） - 在innodb-plugin中为了减少这种大的变长字段对内存的浪费，引入了大于20个字节的，都进行overflow存储， 而且希望不要存到相同的page中，为了增加一个page里能存储更多的行，提高buffer pool的利用率。 这也要求我们， 如果不是特别需要就不要读取那些变长的字段。 那问题来了？ 为什么varchar(255+)存储上和text很相似了，但为什么还要有varchar, mediumtext, text这些类型？ （从存储上来讲大于255的varchar可以说是转换成了text.这也是为什么varchar大于65535了会转成mediumtext)
我理解：这块是一方面的兼容，另一方面在非空的默认值上varchar和text有区别。从整体上看功能上还是差别的。
这里还涉及到字段额外开销的：
- varchar 小于255byte 1byte overhead - varchar 大于255byte 2byte overhead - tinytext 0-255 1 byte overhead - text 0-65535 byte 2 byte overhead - mediumtext 0-16M 3 byte overhead - longtext 0-4Gb 4byte overhead 备注 overhead是指需要几个字节用于记录该字段的实际长度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a537e123b12e7b445a9214d4737fa977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8d525256695637063e7f07e6a068ccb/" rel="bookmark">
			Python父进程退出后，子进程自动退出的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PR_SET_PDEATHSIG (since Linux 2.1.57) Set the parent process death signal of the calling process to arg2 (either a signal value in the range 1..maxsig, or 0 to clear). This is the signal that the calling process will get when its parent dies. This value is cleared for the child of a fork(2). import ctypes libc = ctypes.CDLL('libc.so.6') pid = os.fork() if pid == 0: libc.prctl(1, 15) # something in child elif pid &gt; 0: # something in child
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8d525256695637063e7f07e6a068ccb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1652ad9ff314fa1825f67deb88755d51/" rel="bookmark">
			【ASP】数据库查询的内容分页显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于大数据的查询，你不可以一次性地把所有数据中显示出来，
比如一张学生表上面有一百多号人，
那么在页面中就应该一次显示10人左右，
提供翻页功能给用户进行翻阅，不要一次性显示100多号人。
翻页系统是网页中很常见的功能
一、基本目标
首先还是在Access2007数据库有一张有8条数据的用户信息表，
在页面做分页显示，
翻到最后一页，翻到最前一页，提示暂无记录，给一个超级链接让用户返回
每一页用户可以自定义显示1条、2条、3条记录，如果做100条记录的翻页，可以设置成每页显示10条、15条、20条记录
定义显示不同记录的时候，页数的多少会随之改变
翻页时，下拉菜单会提示翻到哪一页，用户可以自定义翻到哪一页，
二、制作过程
整个系统就一个页面page.asp，翻页与显示记录的多少是通过id与per来控制的。
页面参数由于id与per并不是什么涉及安全性的或者大数据的变量，故使用get方法传递
整个页面的代码如下，每一段都有注释的，请看注释即可：
&lt;!--asp页面必须要有此句，否则页面乱码--&gt; &lt;%@LANGUAGE="VBSCRIPT" CODEPAGE="65001"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;!--页面使用utf-8否则容易乱码--&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;翻页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;名单：&lt;/h1&gt; &lt;!--拿走穿过来的id变量与per变量，如果拿不到，那么用户必定是第一次进入这个页面了，默认id为1，从数据库的第一条记录开始，per为1，一条记录--&gt; &lt;!--注意asp中判断变量是否为空的方法--&gt; &lt;% id=Request.QueryString("id") if id="" then id=0 end if %&gt; &lt;% per=Request.QueryString("per") if per="" then per=1 end if %&gt; &lt;!--lower与upper必须定义，asp不支持即时运算的算术表达式，此两个变量时同个数学的方法确定查询test中id的范围--&gt; &lt;!--asp由于变量是没有类型的，变量间数字间的运算必须使用cint来声明此乃数字运算，否则默认是字符串的连接运算--&gt; &lt;% lower=0 upper=0 lower=cint(id)*cint(per) upper=cint(id)*cint(per)+cint(per)+1 %&gt; &lt;!--连接数据库--&gt; &lt;% db="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1652ad9ff314fa1825f67deb88755d51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2925e76af188341e6187056fb1254fb/" rel="bookmark">
			【ASP】连接Access数据库的登陆系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本目标
首先在Access数据库Database.mdb中存在着用户信息表test：
编写一个登陆系统，如果用户输入的用户名在表中没有，则提示“查无此人”，如果输入密码错误，则提示“密码错误”
如果用户输入的用户名与密码都正确，则跳转到登陆成功页
登陆成功页在普通情况下，不允许通过输入网址就能访问
二、基本思想
使用asp的session对象确保了用户名与密码的传递。
弹出部分使用了javascript的脚本语言
使用asp对用户信息表进行查询。
站点的基本结构如下：
三、制作过程
整个站点使用utf-8码保证不会乱码，所以每一页在页头必须有&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;，如果使用DW的高版本则自动添加，低版本请把gb2312改成utf-8，记事本自便。
1、登陆页面login.html仅仅是一个表单的静态页面。关键是用post方法传递信息，Action是到login.asp
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method="post" action="login.asp"&gt; username:&lt;input type="text" name="username" /&gt; password:&lt;input type="password" name="password" /&gt; &lt;input type="submit" value="login" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 2、login.asp登陆验证页面是本系统最核心的页面 &lt;%@LANGUAGE="VBSCRIPT" CODEPAGE="65001"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2925e76af188341e6187056fb1254fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f06cd4e7eb3f17f19b1a825c03aa83a/" rel="bookmark">
			【ASP】ASP对Access数据库的连接、增删改查及ASP的基本语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文讨论的是ASP，而不是Visual Studio写出来的.ASPX也就是ASP.NET。
ASP不需要任何插件的支持，关键你是配置好WINDOWS的IIS服务器，把页面扔在上面执行就可以了。
不同WINDOWS系统的IIS服务器配置，除了某些被阉割的WINXP装机版系统之外，都支持IIS服务器配置，都在WINDOWS的组件中，不需要下载任何东西。如何配置IIS服务器不是本文讨论的重点。
一、基本目标
假设Access2007数据库database.mdb中存在表test如下：
id为自增列，username,password皆为文本
现在要求把这张表在ASP页面中查询出来。并且再下面继续增加一项username=3,password=a的内容。
运行asp网页的时候记得把access关掉，不可以边打开access边运行asp网页。
二、制作过程
asp代码必须写在&lt;%%&gt;之中，
asp声明变量可以用dim a;声明，a不分类型，系统自动识别。dim可以不写，也就是完全可以写出a=什么，
改变a的值必须用set a=..不能直接a=...，此乃对a的初始化。
数据库声明部分conn与rs的值必须用set conn的形式赋予，因为系统已经自动对其初始化。
&lt;head&gt;部分不需要引用任何文件。
整个网页的代码如下，下面一段一段进行说明：
&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;数据库的连接、增删改查&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% db="Database.mdb" Set conn = Server.CreateObject("ADODB.Connection") conn.Open "driver={Microsoft Access Driver (*.mdb)};pwd=admin;dbq=" &amp; Server.MapPath(db) response.write "数据库连接成功！" Set rs = Server.CreateObject( "ADODB.Recordset" ) sql = "select * from test;" rs.open sql,conn,1,3 %&gt; &lt;br/&gt; 表test的内容: &lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;username&lt;/td&gt; &lt;td&gt;password&lt;/td&gt; &lt;/tr&gt; &lt;% if (rs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f06cd4e7eb3f17f19b1a825c03aa83a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19ccf0b2f95c42ec6b38caad10ed0d55/" rel="bookmark">
			php接收textarea内容后如何显示换行和空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php接收表单提交的信息之后 存入数据库
再次从数据库获取数据再前端显示时 空格还有回车都消失了；
解决办法：
1，存入数据库时候进行替换 2，或者在取出数据之后进行替换 然后再在html中显示
str_replace(" "," ",str_replace("\n","&lt;br/&gt;",$_POST['content'])); 第一步进行回车替换 然后进行空格替换
也可以使用nl2br进行回车替换
echo nl2br($_POST['content']); //nl2br() 函数在字符串中的每个新行 (\n) 之前插入 HTML 换行符 (&lt;br /&gt;)。 注：要用双引号，不然无法替换；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c0fa0ca34cd1e25118c5f6c73439c0/" rel="bookmark">
			libcurl的使用总结（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近的项目中由于要在C++代码中调用PHP的URL，所以不得不借助libcurl这个库，由于第一次用，所以很多地方很是纠结，特此写在这里，方便给同样刚入门的朋友指引。 分两篇介绍，第一篇是理论知识，第二篇是实例。快速链接–libcurl的使用总结（一）
一.下载安装 1.到http://curl.haxx.se/download.html上下载最新版本，由于公司的机器安装rpm有依赖关系，所以直接下载了source 2.编译。解压后进入curl的目录，直接执行 make all 就行。 3.等待编译结束后，可以查看目录结构。 curl/include/curl ： 头文件目录 （一般只要包含curl.h即可） curl/lib/.lib/ ： lib文件目录（有libcurl.a和libcurl.so，注意，如果这两个文件在同一目录下，-lcurl默认是链接.so滴）
二.函数简要说明 在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。下面是利用libcurl完成传输任务的流程：
1. 调用curl_global_init()初始化libcurl 2. 调用 curl_easy_init()函数得到 easy interface型指针 3. 调用curl_easy_setopt设置传输选项 4. 根据curl_easy_setopt设置的传输选项，实现回调函数以完成用户特定任务 5. 调用curl_easy_perform（）函数完成传输任务 6. 调用curl_easy_cleanup（）释放内存
在整过过程中设置curl_easy_setopt()参数是最关键的，几乎所有的libcurl程序都要使用它。
1）CURLcode curl_global_init(long flags); 描述： 这个函数只能用一次。(其实在调用curl_global_cleanup 函数后仍然可再用) 如果这个函数在curl_easy_init函数调用时还没调用，它讲由libcurl库自动完成。 参数：flags CURL_GLOBAL_ALL //初始化所有的可能的调用。 CURL_GLOBAL_SSL //初始化支持 安全套接字层。 CURL_GLOBAL_WIN32 //初始化win32套接字库。 CURL_GLOBAL_NOTHING //没有额外的初始化。
2）void curl_global_cleanup(void); 描述：在结束libcurl使用的时候，用来对curl_global_init做的工作清理。类似于close的函数。
3.char *curl_version( ); 描述: 打印当前libcurl库的版本。
4）CURL *curl_easy_init( ); 描述: curl_easy_init用来初始化一个CURL的指针(有些像返回FILE类型的指针一样). 相应的在调用结束时要用curl_easy_cleanup函数清理. 一般curl_easy_init意味着一个会话的开始. 它的返回值一般都用在easy系列的函数中.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7c0fa0ca34cd1e25118c5f6c73439c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc325d70ec64b2d385316a073ec04ca/" rel="bookmark">
			vim 跳到指定行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在编辑模式下输入 ngg 或者 nG n为指定的行数(如25) 25gg或者25G 跳转到第25行. 在命令模式下输入行号n : n 如果想打开文件即跳转 vim +n FileName 查看当然光标所在的行 Ctrl+g 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42e90c759f7cc19340771889845801ad/" rel="bookmark">
			HM学习心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		帧内模式决策的认识 最近，随着对HM认识的了解更加深入，对一些以前只是在理论上认识的知识，在HM的实现上如何实现有了具体的认知。现在总结下，对帧内模式决策的认识。 首先，分析下帧内模式决策的理论知识。在HEVC帧内模式决策的最佳模式过程需要四个过程（其实也可以说是三个过程）。 首先，是对35种帧内模式进行RMD（粗选择）。在RMD中主要实现对35种模式低复杂度代价的计算，根据PU的大小选取代价较小的前几个模式构成初始候选模式集，进行下一过程。 其次，进行MPM（最有可能模式选择）。所谓的MPM即，判断RMD后的模式是否包含有当前PU左邻近与上邻近的最佳模式。如果RMD后的模式不包含当前PU左邻近与上邻近的最佳模式，则将相应不包含的模式纳入初始候选模式集；反之，则不进行处理。 再次，对经MPM的初始候选模式集进行RDO过程。此时的RDO过程是在TU最大尺寸上进行的，从候选模式集中选出RDcost最小的模式，作为当前PU的最佳模式。 最后，在最佳模式上进行RQT，即在最佳模式上决定最佳TU分割。（之所以说三个过程就可以，那是因为前三个过程已经确定了最佳模式，只不过在RDO中也涉及到了TU，所以就说是四个过程了。） 具体代码实现如下各图所示。 图1 RMD 图2 MPM 以下程序为RDO过程： for( UInt uiMode = 0; uiMode &lt; numModesForFullRD; uiMode++ )//对RMD和MPM后的模式集进行RDO { // set luma prediction mode UInt uiOrgMode = uiRdModeList[uiMode]; pcCU-&gt;setLumaIntraDirSubParts ( uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth ); // set context models if( m_bUseSBACRD ) { m_pcRDGoOnSbacCoder-&gt;load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] ); } // determine residual for partition UInt uiPUDistY = 0; UInt uiPUDistC = 0; Double dPUCost = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42e90c759f7cc19340771889845801ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b877ba809db56bf54079c3295ea21e/" rel="bookmark">
			点击提交按钮触发ajax请求时，做到处理完前一个请求后再处理第二个请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：点击提交按钮触发ajax请求时，做到处理完前一个请求后再处理第二个请求；提高用户体验。因为如果不这样限制的话，用户点击频率太高，会导致服务器返回的第二条请求快过第一条的响应速度。
代码如下：不是很好，先这样做吧，有更好的处理方法的话，再总结
&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;充值&lt;/title&gt; &lt;script src='./jquery-1.7.2.min.js'&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;input name='sub' class="submit" id='1' οnclick='test(this)' type="button" value="确认提交"/&gt;&lt;/li&gt; &lt;li&gt;&lt;input class="return" type="submit" value="返回修改"/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;input type='hidden' value='OK' name='ff' id='ff'/&gt; &lt;script&gt; function fuck_you(){ var test = 13; $.ajax({ url:'index.php', data:{'test':test}, dataType:'JSON', type:'post', success:function(data){ if(data.msg == 'OK'){ $('input[name=sub]').attr('id','1'); $('input[name=sub]').attr('value','确认提交') alert('成功'); }else{ $('input[name=sub]').attr('id','1'); $('input[name=sub]').attr('value','确认提交') alert('失败'); } } }).done().fail().always(); } function test(obj){ var _status = obj.id; if(_status != '1' || _status == undefined){ $('input[name=sub]').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46b877ba809db56bf54079c3295ea21e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26ed6c916a1c5354abacf4cbcd27ebe8/" rel="bookmark">
			Spring与Mybatis三种常用整合方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍Spring与Mybatis三种常用整合方法，需要的整合架包是mybatis-spring.jar，可通过链接http://code.google.com/p/mybatis/ 下载到。
1、采用数据映射器（MapperFactoryBean）的方式，不用写mybatis映射文件，采用注解方式提供相应的sql语句和输入参数。
（1）Spring配置文件：
&lt;beans &gt; &lt;!-- 引入jdbc配置文件 --&gt; &lt;context:property-placeholder location="jdbc.properties"/&gt; &lt;!--创建jdbc数据源 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="${driver}"/&gt; &lt;property name="url" value="${url}"/&gt; &lt;property name="username" value="${username}"/&gt; &lt;property name="password" value="${password}"/&gt; &lt;property name="initialSize" value="${initialSize}"/&gt; &lt;property name="maxActive" value="${maxActive}"/&gt; &lt;property name="maxIdle" value="${maxIdle}"/&gt; &lt;property name="minIdle" value="${minIdle}"/&gt; &lt;/bean&gt; &lt;!-- 创建SqlSessionFactory，同时指定数据源--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!--创建数据映射器，数据映射器必须为接口--&gt; &lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="com.xxt.ibatis.dbcp.dao.UserMapper" /&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;bean id="userDaoImpl2" class="com.xxt.ibatis.dbcp.dao.impl.UserDaoImpl2"&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26ed6c916a1c5354abacf4cbcd27ebe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d671dbe0e5f704948844a323f1a223/" rel="bookmark">
			HEVC测序序列特点介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行HEVC快速算法研究中，经常要做测试。拿哪 个序列做测试是一个问题，总不能每次都对所有的序列测试，这样的话工作量太大了。经过阅读文献与经验的总结，个人认为做测试的序列应满足如下条件：
第一：每种类别（Class）的序列都应该涉及；在“Common HM test conditions and software reference configuration”文献中，规定了帧内、帧间预测时的配置及测试序列类别，从Class A 到 Class E,其分辨率分别为2560X1600、 1920X1280、832X480、 416X240、1080X720。在做测试的时侯尽量每种类别都选取一到两个；
第二：尽量包含每种类别的纹理复杂和纹理简单的序列。各个测试序列的纹理情况见下表1所示（个人总结，仅供参考）。
表1
相信只要在做初步测试的时候用满足这样条件的测试序列跑程序，如果出来的数据情况良好的话，那么测试剩余的序列的测试结果应该不会坏到哪里去。（如果有个别序列的数据太差的话，那可以用Class F序列代替试下！）
补充描述：Traffic：复杂背景，对象有适度的、中等的运动；Vidyo：缓慢运动；Vidyo4：简单序列；FourPeople：简单的背景，缓慢的对象运动；Cactus：复杂不规则运动；
BasketballDrill：快速、不规则运动。BQSquare：适度的、中等的运动；ParkScene：中等的运动。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/211/">«</a>
	<span class="pagination__item pagination__item--current">212/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/213/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>