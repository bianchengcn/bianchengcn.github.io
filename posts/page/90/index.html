<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09f372e3da6941a483e281110dddfda8/" rel="bookmark">
			golang调用外部程序，创建进程，fork，守护进程，shell命令，fd查看，lsof
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、syscall.Exec() 函数原型
func Exec(argv0 string, argv []string, envv []string) (err error)
函数说明
Exec invokes the execve(2) system call.
此方法会将在当前进程空间里，用新的程序覆盖掉当前程序，并执行新的程序，它们依然在同一个进程里，只是进程的内容发生了变化。
main11.go
package main import ( "fmt" "syscall" ) func main() { // 打印当前进程号 fmt.Println(syscall.Getpid()) } go build main11.go 得到 main11 可执行文件
main10.go
package main import ( "fmt" "os" "os/exec" "syscall" ) func main() { fmt.Println("11111") fmt.Println(syscall.Getpid()) f3() // 后面的依然属于当前进程的内容，不会被执行到 fmt.Println("22222") } func f3() { // LookPath获得绝对地址；参数可以是绝对路径或相对路径。 // binary 应该是一个可执行文件，对于全局的命令，也需要找到其具体的命令文件的位置。 binary, lookErr := exec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09f372e3da6941a483e281110dddfda8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18e93acd64f2c90165e620004c3b217d/" rel="bookmark">
			新手向【服务器安装Java运行环境】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍如何往服务器上安装jdk，按照步骤来保证没有任何问题！
1、下载jdk
首先进入服务端的命令行，可别装到本地了啊…
直接在服务器命令行中通过wget命令下载jdk，jdk的压缩包将下载到服务器的当前目录下。
wget https://dragonwell.oss-cn-shanghai.aliyuncs.com/8/8.4.4-GA/Alibaba_Dragonwell_8.4.4-GA_Linux_x64.tar.gz Dragonwell是阿里巴巴的开源jdk，下载速度很快，如果愿意折腾可以自己去找 oracle jdk的镜像源，这里不赘述（不会还有墙外的老哥看这篇文章吧？-.- ）
若wget 出现 command not found ，说明没有安装wget，请自行百度解决方法。
下载完成后使用 ls 可查看下载的文件：
2、解压
使用解压命令：
tar xf Alibaba_Dragonwell_8.4.4-GA_Linux_x64.tar.gz 可以通过 ls 看到提取出的 jdk 文件：
执行如下命令查看jdk版本：
./jdk8u282-b01/bin/java -version 验证结果：
出现此结果，说明下载的jdk没有任何问题。
3、添加环境变量
接下来只需将此jdk路径写到环境变量中，便可以直接使用 java命令了。
首先进入刚解压的文件夹jdk8u282-b01中：
cd jdk8u282-b01/ 然后使用pwd查看当前路径
pwd 得到的结果：
可以看到 我的路径是/root/jdk8u282-b01，这里因人而异，复制下来你的这个路径就好。
接下来编辑配置文件：
vim /etc/profile 在文件末尾添加：
JAVA_HOME=/root/jdk8u282-b01 CLASSPATH=$JAVA_HOME/lib/ PATH=$PATH:$JAVA_HOME/bin export PATH JAVA_HOME CLASSPATH 注意 这里的第一行JAVA_HOME= 后面的内容就是你刚刚复制的路径，不要照抄！！
编辑完成后按esc 输入 :wq 命令保存文件
最后执行刷新配置文件命令：
source /etc/profile 到此为止，jdk的安装就全部完成了，查看安装情况：
java -version 如果一步一步跟着做肯定没有问题~！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7051198645fa4235f18a485c9bcc56f/" rel="bookmark">
			一份CPP的面试题，这是要招聘大师吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++程序员试题 (以下程序代码假设都在32位机器上运行)
写出结果 1. int i=3, j=5, k;
k = (++i) + (i++) + (j++);
i= j= k= 2. 计算sizeof 的值.
char str[] = “flower”
char *p = str ;
int n = 10;
sizeof (str ) = （1）
sizeof ( p ) = （2）
sizeof ( n ) = （3）
void Foo ( char str[100])
{
sizeof( str ) = （4）
}
void *p = malloc( 100 );
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7051198645fa4235f18a485c9bcc56f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef1c8fc49e51c77f996faaf486aefe6d/" rel="bookmark">
			【深度学习】VGG16网络结构复现 | pytorch |
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、VGG16介绍二、VGG16网络复现——pytorch 前言 这篇文章按道理来说应该是很简单的，但是因为一个很小的bug，让我难受了一晚上，直到现在我也没找出原因。后面我会提到这个bug。
今天这篇文章主要用来手动搭建vgg16这个网路，以前都是直接调用的。VGG16网络是非常重要，尤其是后面U-net这种网络，是基于VGG-16
一、VGG16介绍 VGG16论文地址：https://arxiv.org/pdf/1409.1556.pdf
主要介绍（翻译一下摘要吧）：
本文研究了在大规模图像识别环境中，卷积网络深度对卷积网络精度的影响。我们的主要贡献是使用一个非常小(3 × 3)卷积滤波器的架构对增加深度的网络进行彻底的评估，这表明通过将深度推到16-19个权重层，可以实现对现有技术配置的显著改进。这些发现是我们的 ImageNet 挑战2014提交的基础，我们的团队在本地化和分类轨道上分别获得了第一和第二名。我们还表明，我们的表示很好地推广到其他数据集，在那里他们实现了最先进的结果。我们已经公开了我们的两个性能最好的 ConverNet 模型，以促进深度视觉表示在计算机视觉中的应用的进一步研究。
这些网络结构中，D用的最多，今天我们也重点对D进行复现。
二、VGG16网络复现——pytorch import torch.nn as nn import torch class VGG16(nn.Module): def __init__(self): super(VGG16,self).__init__() self.conv1=nn.Sequential( nn.Conv2d(3,64,3,1,1), nn.BatchNorm2d(64), nn.ReLU(inplace=True), nn.Conv2d(64,64,3,1,1), nn.BatchNorm2d(64), nn.ReLU(inplace=True), nn.MaxPool2d(2,2) ) self.conv2 = nn.Sequential( nn.Conv2d(64, 128, 3, 1, 1), nn.BatchNorm2d(128), nn.ReLU(inplace=True), nn.Conv2d(128, 128, 3, 1, 1), nn.BatchNorm2d(128), nn.ReLU(inplace=True), nn.MaxPool2d(2, 2) ) self.conv3 = nn.Sequential( nn.Conv2d(128, 256, 3, 1, 1), nn.BatchNorm2d(256), nn.ReLU(inplace=True), nn.Conv2d(256, 256, 3, 1, 1), nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef1c8fc49e51c77f996faaf486aefe6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66cd84a5e7a351cec38bd36722f0f901/" rel="bookmark">
			HTML基础知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、HTML 简介 1.1、什么是 HTML? HTML 是用来描述网页地一种语言。
HTML 指的是超文本标记语言（Hyper Text Markup Language）HTML 不是一种编程语言，而是一种标记语言（markup language）标记语言是一套标记标签（markup tag）HTML 使用标记标签来描述网页 1.2、HTML 标签 HTML 标记标签通常被称为 HTML 标签（HTML tag）。
HTML 标签是由尖括号包围地关键词，比如&lt;html&gt;HTML 标签通常是成对出现地，比如&lt;body&gt;&lt;/body&gt;标签对中地第一个标签是开始标签，第二个标签是结束标签开始和结束标签也被称为开放标签和闭合标签 1.3、HTML 文档 = 网页 HTML 文档描述网页HTML 文档包含 HTML 标题和纯文本HTML 文档也被称为网页 Web 浏览器地作用是读取 HTML 文档，并以网页地形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。
2、HTML 基础功能标签 标签描述&lt;!DOCTYPE&gt;定义文档类型&lt;html&gt;HTML 根元素，定义 HTML 文档&lt;head&gt;定义关于文档的元信息&lt;title&gt;定义文档标题&lt;body&gt;定义文档主体h1~h6定义 HTML 标题&lt;p&gt;定义段落&lt;br定义简单的折行hr定义水平线&lt;!--...--&gt;定义注释 2.1、&lt;!DOCTYPE&gt;定义和用法 &lt;!DOCTYPE&gt;声明必须是 HTML 文档的第一行，位于 html 标签之前。
&lt;!DOCTYPE&gt;声明不是 HTML 标签；它是指示 web 浏览器使用哪个 HTML 版本进行编写的指令。
在 HTML 4.0.1 中，&lt;!DOCTYPE&gt;声明引用 DTD，因为 HTML 4.0.1 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确的呈现内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66cd84a5e7a351cec38bd36722f0f901/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bb268b7d1709298b5ea55d346593a46/" rel="bookmark">
			godot引擎学习6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目管理器结构： 主要类ProjectManager
1，CanvasItem : public Node 任何2d的基类。
void _draw ( ) virtual
调用（如果存在）以绘制画布项。
Control : public CanvasItem 所有用户界面节点都继承自控件。控件的定位点和页边距相对于其父控件调整其位置和大小。
所有与UI相关的节点的基类。 Control 其特征是定义范围的边界矩形、相对于其父控件或当前视区的定位点位置以及表示定位点偏移的边距。当节点、其父节点或屏幕大小发生变化时，页边距自动更新。
相关属性：
枚举 FocusMode ：焦点相关
FOCUS_NONE = 0 ---节点无法获取焦点。与一起使用 focus_mode .
FOCUS_CLICK = 1 ---节点只能通过鼠标点击来获取焦点。与一起使用 focus_mode .
FOCUS_ALL = 2 ---该节点可以通过鼠标单击或使用键盘上的箭头和制表键来获取焦点。与一起使用 focus_mode .
枚举 CursorShape ： 光标显示位置与形状
CURSOR_ARROW = 0 ---当用户悬停节点时，显示系统的箭头鼠标光标。与一起使用 mouse_default_cursor_shape .
CURSOR_IBEAM = 1 ---用户悬停节点时，显示系统的工字梁鼠标光标。工字钢指针的形状类似于“I”。它告诉用户可以突出显示或插入文本。
CURSOR_POINTING_HAND = 2 ---用户悬停节点时，显示系统的鼠标指针。
CURSOR_CROSS = 3 ---用户悬停节点时，显示系统的鼠标光标。
CURSOR_WAIT = 4 ---当用户悬停在节点上时，显示系统的等待鼠标光标，通常是沙漏。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bb268b7d1709298b5ea55d346593a46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f6f2110ad39da4307b67b06f675dc1d/" rel="bookmark">
			解决linux 每次登陆时都需要 source ~/.bashrc 的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vi ~ /.bash_profile 添加
# .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ] ; then source ~/.bashrc fi 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51126c0ba1c4135da9251526fd05dbf8/" rel="bookmark">
			使用pe系统 修复引导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在给朋友重新安装系统的时候 因为手贱 把引导盘给删除了，导致重新安装完系统后启动黑屏
解决办法：
进入pe （我使用的微pe）打开用Dism++
新建 ESP MSR分区
然后使用UEFI引导修复 这样就可以把误删除的引导建立好
具体也可以参考这个视频 查资料看到的
【[2P更新]误删系统引导？一分半都不用，教你一键恢复系统引导】 https://www.bilibili.com/video/BV1HE411Y7zm/?share_source=copy_web&amp;vd_source=5cee5df0045741e69beb17e2542b06ec
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d157639cdb3e357ccad06828a3cd96e/" rel="bookmark">
			javaweb实现购物车功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章讲的是如何使用javaweb相关知识模拟购物车功能 (web练手小项目) 使用到的相关知识(部分知识点在文章中简单涉及到):
html cs javascript jsp servlet ajax jQuery Mysql MyBatis(持久层框架，用来连接数据库，这里可以使用jdbc进行数据库的连接) 功能使用MVC设计模式，以及三层架构思想
注: 本篇使用Session对购物车进行存储,具体参考下文WelcomeServlet.java
功能实现效果:
购物车为空状态 功能大致目录结构:
前端界面代码:
(1) shopcar.jsp(购物车界面)
&lt;%@ page import="edu.pdsu.shop.pojo.CarGoods" %&gt; &lt;%@ page import="java.util.List" %&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;shop car&lt;/title&gt; &lt;link rel="stylesheet" href="css/shoplist.css" type="text/css"&gt; &lt;script type="text/javascript" src="${pageContext.request.contextPath}/js/jquery-3.6.1.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;style type="text/css"&gt; th, td { border-bottom: 1px solid green; } th { background-color: #4CAF50; color: white; } table{ text-align: center; } &lt;/style&gt; &lt;body style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d157639cdb3e357ccad06828a3cd96e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23318374044534cc73bc6fd56a7c780f/" rel="bookmark">
			抖音自动私信Auto.js脚本源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 抖音自动私信脚本，用来引流或者互粉养号。一个简单的私信脚本。（需要开启无障碍）可以自行修改。
代码如下:
launchApp("抖音");//打开抖音sleep(5000);//等5秒click(99,147);//点击直播sleep(3000);//等3秒var i =0//定义开始为0//循环开始while(i&lt;100){//循环100次sleep(2000);//等待2秒click(894,156);//点击直播名单sleep(2000);//等待2秒click(451,1369);//点击第一个人物sleep(1000);//等待1秒click(534,1711);//点击头像sleep(1000);//等待1秒id("iin").findOne().click();//点击三个点sleep(300);//等待0.3秒id("hic").findOne().click();//点击私信sleep(1000);//等待1秒click(340,2255);//点击输入框sleep(1000);//等待1秒setText("不好意思，打扰了，软希源码：www.58soho.cn");sleep(1000);//等待1秒click(977,1426)sleep(1000);back();sleep(300);back();sleep(300);back();sleep(1000);click(451,1572);//点击第二个人sleep(1000);click(534,1711);//点击头像sleep(1000);id("iin").findOne().click();//点击三个点sleep(300);id("hic").findOne().click();//点击私信sleep(1000);click(340,2255);//点击输入框sleep(1000);setText("不好意思，打扰了，软希源码：www.58soho.cn");sleep(1000);click(977,1426)sleep(1000);back();sleep(300);back();sleep(300);back();sleep(300);back();sleep(5000);swipe(542,1984,542,500,600);i=i+1;}log("脚本已循环100次，请重新开始。") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3647942585ce3dc306adeeded390e552/" rel="bookmark">
			YoLo V1详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YoLo系列都是在V1的基础上进行改进的，所以学好YoLo V1至关重要
图像分类、目标检测、图像分割（将目标以抠图的形式标记出来）
图像分割又分为Semantic Segmentation(语义分割)和Instance Segmentation(实例分割)
语义分割就是对每一个像素分类，不管这个像素是属于哪几个物体的，只管它是属于什么类别的
实例分割就是把同一个类别的不同实例给它区分出来
论文思想：
1.将一幅图像分成7*7个网格，如果某个目标的中心（GTBOX的中心）落在这个网格，则这个网格就负责预测这个目标
2.每个网格要预测2个bounding BOX,每个bounding box除了要预测位置之外（x,y,w,h）还要附带预测一个confidence(置信度，预测目标与真实目标的交并比乘以0或1，网格中有目标就乘以1，没有目标就乘以0)，每个网格还要预测C（voc取20）个类别的分数
预测阶段（前向推断）
预测就是在模型已经训练完成之后，输入未知图片来对模型进行测试。
yolo v1输入的是448*448*3的图像，输出的是7*7*30的张量，这个张量里面包含置信度，坐标，只需要对这个张量的信息进行解读。
首先将图片分为7*7的网格，每一个网格都有2个预测框，这两个预测框的中心点都落在网格里面。预测框就包含x,y,w,h（框中心点的坐标x,y以及框的宽高w,h）,有这4个坐标就可以确定框的位置。以及包含它是不是一个物体的置信度（置信度用来判断边界框内的物体是正样本还是负样本，大于置信度阈值的判定为正样本，小于置信度阈值的判定为负样本即背景。），图中的置信度就以框线的粗细来表示。粗线表示置信度比较高，细线就表示置信度比较低。
每一个网格还能生成每一个类别的条件概率，将每一个预测框的置信度乘以类别的条件概率就能够获得每一个预测框的各类别的概率。
结合这两个信息就可以获得最终的结果。这些信息来源与7*7*30的张量中获取的。
完整的过程：
7*7*30中的30是怎么来的呢？
每个网格包含2个预测框，每个预测框有5个参数（x,y,w,h,confidence value置信度）
2个框就是10个参数
Pascal VOC里面包含20个类别
5*2+20=30
yolo v1对小目标或者密集目标预测性能较差
预测阶段 后处理（置信度过滤，非极大值抑制）
对于yolo而言，后处理就是将纷繁复杂的预测出来的98（49*2）个预测框进行筛选、过滤，把重复的预测框只保留一个，最终获得目标检测的结果（NMS）。
NMS：
先把最高的拿出来，然后再将每一个都跟最高的作比较。
先将第一个和第二个作比较，如果他俩的lou大于某个阈值，那我们就认为他俩是重复识别了同一个物体，那我们就把低概率的给过滤掉。如果lou阈值设置的很低，那么框与框之间就不会有交集，如果阈值设置的很高，那么同一个物体就会有很多预测框。
最后只留下一个概率最高的检测框
训练阶段（反向传播）
深度学习或者监督学习（监督学习（supervised learning）擅长在“给定输入特征”的情况下预测标签。 每个“特征-标签”对都称为一个样本（example）。 有时，即使标签是未知的，样本也可以指代输入特征。 我们的目标是生成一个模型，能够将任何输入特征映射到标签，即预测。）
是通过梯度下降和反向传播方法跌打的去微调神经元中的权重。来使得损失函数最小化的过程。目标检测是一个典型的监督学习问题。就是说，在训练集上，肯定已经人工标注出来了一个绿框（Ground Truth），而我们的算法就是让这个预测结果尽量去拟合这个绿框。
而这个绿框的中心点落在哪个网格里面，就应该由哪个网格预测出的Bounding Box去负责拟合这个绿框。每个网格有2个Bounding Box，应该由这2个Bounding Box中的一个（与Ground Truth交并比比较大的）去拟合这个绿框。并且这个网格输出的类别也应该是Ground Truth的类别。
YoLo V1损失函数
这个损失函数包含5项：
第1项是负责检测物体的Bounding Box的中心点定位误差。BBox要和GT从x,y,w,h上都要尽可能的一致。
回归问题就是要预测出一个连续的值，把这个值与标注值进行比较，越接近越好。
yolo是把目标检测问题当作回归问题解决的。
第2项是负责检测物体的BBox的宽高定位误差。加根号是使得小框对误差更敏感。同样的偏差，小框造成的损失函数会更大，大框造成的损失函数会更小。这样对大框更加的公平。
第3项是负责检测物体的BBox的Confidence（置信度）误差
第4项是不负责检测物体的BBox的Confidence（置信度）误差。一种是不负责检测物体的BBox，一种是检测物体但是被淘汰的BBox。他们的置信度越接近于0越好
第5项时负责检测物体的网格的分类误差。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b6e87d0665f43d981fb10ad39375365/" rel="bookmark">
			Nginx解决跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、跨域问题
1.什么是跨域
2.CORS
二、Nginx跨域处理
三.补充
前言 这几天出现了一个问题，我们中的一个A系统需要给B系统调用，造成了跨域问题。
一、跨域问题 1.什么是跨域 当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。
2.CORS CORS是一个W3C标准，全称是跨域资源共享(Cross-origin resource sharing)。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
简单来说就是跨域的目标服务器要返回一系列的Headers，通过这些Headers来控制是否同意跨域。
CORS提供的Headers，在Request包和Response包中都有一部分:
二、Nginx跨域处理 下面就是我Nginx的一些配置：
server { listen 443 ssl; server_name 这里是域名; #定义跨域变量 set $cors_origin ""; #访问的域名与填写的域名比较 if ($http_origin ~* "^这里填写调用我们系统的域名地址$") { set $cors_origin $http_origin; } //这里填*就是任何域名都允许跨域 add_header Access-Control-Allow-Origin $cors_origin; #CORS请求默认不发送Cookie和HTTP认证信息。但是如果要把Cookie发到服务器，要服务器同意，指定 #Access-Control-Allow-Credentials字段。 add_header Access-Control-Allow-Credentials 'true'; #设置跨域请求允许的Header头信息字段，以逗号分隔的字符串 add_header Access-Control-Allow-Headers 'Origin,X-Requested-With,Content-Type,Accept,Authorization,token'; #设置跨域允许的请求 add_header Access-Control-Allow-Metthods 'POST,GET,PUT,OPTIONS,DELETE'; # 预检请求处理 if ($request_method = OPTIONS) { return 204; } 三.补充 我们前面的预检请求我们简单来说一说，CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b6e87d0665f43d981fb10ad39375365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9de801dcd344a1af1228f17014f6839/" rel="bookmark">
			亚马逊云科技×讯联数据，多维赋能支持业务系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为技术类服务商，多年来讯联数据深耕移动支付领域，为支付产业链中各类型机构提供顶层技术支持，业务版图也逐渐从国内延伸到海外市场，成功将国内业务模式输出至海外，成为了海外支付服务商中的佼佼者。
随着海外业务的不断扩张，系统稳定性成为其需要予以考量的重要因素，从根本上来说，讯联数据需要IT基础服务兼顾系统稳定性、扩展性与成本，满足对客户承诺的SLA，方便实现系统功能与性能的扩展，同时支持动态调整系统成本结构，达成资源、成本优化配置。在对可行性、成本与合规等多个维度进行了全面、审慎的综合评估后，讯联数据最终选择亚马逊云科技作为支撑其海外业务的首选云服务商。
业务层面：讯联数据重点关注其支付处理类核心业务与客户市场对接的平滑度。在海外市场，银行、支付机构和大型商户对亚马逊云科技的认可度非常高，并且，亚马逊云科技可全方位满足不同地区行业及客户的安全合规要求，终端用户可以直接继承。比如，亚马逊云科技拥有支付卡行业数据安全标准（PCI DSS）1级服务提供商认证，通过ISO/IEC系列合规认证，能够安全、合规地存储、处理或传输数据，确保讯联数据的安全管理计划全面符合行业标准。
技术层面：讯联数据主要考虑基于云构建系统与后续运维管理的复杂度，以及系统稳定性、性能与安全性等综合素质。从技术栈角度看，亚马逊云科技拥有完善集成、功能强大的服务组件，可高效满足讯联数据各类型业务场景扩展，并支持定制化技术方案快速落地，架构弹性与灵活性俱佳；从系统稳定性角度看，亚马逊云科技既支持单个区域的多可用区部署，也支持跨区域的异地容灾，可充分确保业务连续性符合SLA。此外，亚马逊云科技在跨区域网络协同、资源动态扩展方面更具优势，可以帮助讯联数据更好地平衡成本效益。
服务支持与体验层面：亚马逊云科技命令行界面（CLI）学习曲线平滑，具备很强的灵活度，与讯联数据内部使用的工具链高度契合，方便团队更好地集成内部系统部署，维护相关流程和工具。官方提供丰富的技术资料和实施指南，社区活跃度高，针对各类技术架构问题，讯联数据都能方便快捷地找到答案。技术培训方面，亚马逊云科技提供的内容实用性强，组织安排合理到位，帮助讯联数据快速上手构建。
降低管理复杂度：大幅降低系统监控、跨区域网络互连等方面管理复杂度，释放系统与网络硬件环境运维压力。比如，利用Amazon EC2的AMI生命周期管理功能，结合讯联数据自研的MongoDB oplog的增量备份数据，合理控制备份资源、成本，支持周期性全量备份+增量备份的策略；利用VPC Peering、Amazon PrivateLink等，结合CloudWatch，组建高速安全的跨区域互联网络，延时由原来的秒级降低至毫秒级，实现资源高效协同。
优化成本：显著优化成本，加速产品服务创新价值兑现。硬件成本方面，基于亚马逊云科技，讯联数据成功实现系统成本根据业务需求动态扩展，可按需伸缩服务资源，避免大规模硬件成本投入；运维管理及人力成本方面，释放团队资源投入创新，从传统运维向SRE（站点可靠性工程）方向转变。基于Amazon EKS、ElastiCache等服务，结合CI/CD流水线，构建基于云的DevOps体系，将软件版本迭代周期由4-6周缩短至2周。
助力业务可持续发展：安全稳定与系统性能兼顾，助力业务可持续发展。系统层面，通过Amazon WAF、Amazon Shield，对于常见的外部攻击如DDoS提供基础防护，并将渗透测试、漏洞扫描等功能结合使用，确保应用平台安全无虞，连续多年0安全事故；数据层面，涉及数据存储、传输等各环节，实现静态和动态数据加密，为数据库启用传输层安全（TLS）。通过Amazon KMS管理生产环境密钥，满足合规要求。基于亚马逊云科技，讯联数据应用程序的整体可用性达到99.95%，有效提升客户满意度，获得更多市场认可。
未来，讯联数据计划进一步丰富“线上”业务，如定制化营销系统、风控识别等，亚马逊云科技功能强大的智能湖仓、大数据相关的机器学习和分析服务都大有用武之地。系统服务的容器化改造也是一大重点方向。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fd0460dc3c3e946616d2f066af3de11/" rel="bookmark">
			excel提取技巧：单元格部分内容提取的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		excel提取技巧：单元格部分内容提取的三种方法 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9652a33dfc8e535d1b93a18573826b77/" rel="bookmark">
			Java小项目实训——扑克牌
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目要求： 一个窗口实现无序发放52张扑克牌；另一个窗口实现记录打出的扑克牌 Poke类 public class Poke { String name[] = { "fang", "hong", "mei", "hei" }; String a[] = new String[52]; String b[] = new String[52]; String c[] = new String[13]; String d[] = new String[13]; String e[] = new String[52]; public void 生成牌() { int k = 0; for (int i = 0; i &lt; 4; i++) { for (int j = 1; j &lt;= 13; j++) { a[k] = name[i] + j; k++; } } } public void 打印牌(String[] p) { int cout = 0; for (int i = 0; i &lt; p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9652a33dfc8e535d1b93a18573826b77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e852447014e650a486d50edd6dc52d54/" rel="bookmark">
			虚拟机与window互传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、到FileZilla中文网下载 下载 - FileZilla中文网
2.下载好安装包就开始安装 点击install安装就好了。
3.在文件传输前先打开Ubuntu的FTP服务 打开 Ubuntu 的终端窗口，然后执行如下命令来安装 FTP 服务：
sudo apt-get install vsftpd 等待软件自动安装，安装完成以后使用如下 VI 命令打开/etc/vsftpd.conf，命令如下：
sudo vi /etc/vsftpd.conf 打开以后 vsftpd.conf 文件以后找到如下两行：
local_enable=YES
write_enable=YES
确保上面两行前面没有“#”，有的话就取消掉，完成以后如图 所示：
(有#的，上图的文件已经进入了vim编辑模式，所以可以直接用命令删除#，光标对准#后按” x “键就能删除光标下的字符，然后点击” Esc “键后再点击“ : ”键 就能保存并退出，看不懂的可以查vim命令)
修改完 vsftpd.conf 以后保存退出，使用如下命令重启 FTP 服务：
sudo /etc/init.d/vsftpd restart 出现如下显示即已经打开FTP服务
4.打开FileZilla 1）新建站点（随便命名一个名字即可）
需要手动操作的有如下：
协议：FTP - 文件传输协议
主机：ip地址在Ubuntu中终端命令输入ifconfig即可查看
加密：选择只使用明文FTP
用户：例如此时登录的是hadoop用户，在该用户下开启的FTP服务，所以上面的用户填hadoop（注意是此时Ubuntu正在登录的用户的用户名，比如我Ubuntu下除了root用户，还有hadoop用户）
密码：该用户对应的密码
然后确认连接即可
5.传输文件 直接将window的文件拖到ubuntu下想要放置的某个目录即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec7e7db5993d05641845dddde08469a9/" rel="bookmark">
			Mybatis中拦截器的使用场景和技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景描述 中小业务系统中，有时候会面临一些比较相似的业务场景。
当XXX创建成功后，需要给XXX推送一条业务消息；当XXX更新的时候，需要给XXX推送一条业务提醒；当XXX创建OR更新的时候，需要将最新的数据推送到搜索引擎中，以方便其他业务系统在搜索引擎中能查询到；当XXX更新的时候，需要更新分布式缓存的XXX数据；…… 这些场景都有相似的特征，如下
特征描述异步实际上与主流程关系不大，可以作为附属流程异步执行事务大多在事务结束之后执行并行可以串行执行，也可以并行执行，对最终结果影响不大 Mybatis拦截器 Mybatis提供了一些机制，可以允许我们在做数据库操作的时候进行我们额外的一些程序。当然，这看起来并没有JPA的EntityListener好用。
但是通过这些机制，我们可以达成我们主要的目的，解耦合。（解耦合的好处显而易见，我们在关注主流程业务的时候，附属流程的业务也更容易扩展）
下面是我们即将用到的一些简单概念，如下
概念描述解耦解耦的本质就是将类之间的直接关系转换成间接关系观察者模式一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象。EventBus基于事件驱动，观察者们监听自己感兴趣的特定事件，进行相应的处理。 锚定事件发生 首先，我们要找到事件发生的地方，通常来说我们更愿意在业务代码里写
Company company = new Company(); company.setCompanyName(companyName); companyMapper.insert(company); // 创建XXX成功后，触发了一些操作； doSomething(company); 复制代码 但是，这种方式是耦合的，我们在doSomething() 里发生的一些异常会影响到主流程，而每一次增加附属流程的改动，都会产生影响范围的蔓延。
这里，我们使用Mybatis提供的一种方式来锚定事件发生
@Component @Intercepts( { @Signature(method = "update", type = Executor.class, args = { MappedStatement.class, Object.class }) }) public class EntityInterceptor implements Interceptor { private static final Logger LOGGER = LoggerFactory.getLogger(EntityInterceptor.class); @Override public Object intercept(Invocation invocation) throws Throwable { Object proceed = invocation.proceed(); try { Object[] args = invocation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec7e7db5993d05641845dddde08469a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/151e65fadf8ee64c50ca259642393b3a/" rel="bookmark">
			windows/linux查看服务器CPU配置命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念：
Intel的处理器分为至强Xeon、酷睿Core、赛扬Celeron、奔腾Pentium和凌动Atom5个系列。
英特尔® 酷睿™ 、奔腾® 、赛扬® 系列处理器都是面向笔记本或台式机的CPU。而至强Xeon则主要面向商用服务器的CPU，至今已更新至第三代。
新一代英特尔® 至强® 可扩展处理器由高到低又分为Platinum、Gold、Silver三个系列（E7/E5/E3--个人工作站服务器，P/G/S--中高端服务器），就类似于我们常见的酷睿i9、i7和i5。以英特尔® 至强® Platinum处理器为例，它至多可搭载40个内核，最高睿频可达4.4GHz，并包含8条内存通道，速度至高可达3200MT/秒。
总核数 = 物理CPU个数 * 每颗物理CPU的核数
总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数
linux查看服务器CPU配置命令
# CPU信息（型号）
cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
# 物理CPU个数
cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l
# 物理CPU中core的个数(即核数)
cat /proc/cpuinfo| grep "cpu cores"| uniq
# 逻辑CPU的个数
cat /proc/cpuinfo| grep "processor"| wc -l
windows查看服务器CPU配置命令
# CPU信息（型号）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/151e65fadf8ee64c50ca259642393b3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e5a3777925c75626160f477cd769ef9/" rel="bookmark">
			工具推荐——三个Burp插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xia Liao（瞎料） 用于web渗透注册时，快速生成需要的资料用来填写，资料包含：姓名、手机号、身份证、统一社会信用代码、组织机构代码、银行卡，以及各类web语言的hello world输出和生成弱口令字典。
BurpBountyPlus 菜单功能Scan All Param对所有参数【PARAM_BODY|PARAM_URL|PARAM_JSON】进行漏洞扫描Scan Get Param单独扫描GET[]里面的每个参数Scan POST Param单独扫描POST[]里面的每个参数Fuzz All Param对所有参数【PARAM_BODY|PARAM_URL|PARAM_JSON】进行FuzzFuzz Get Param单独fuzz GET[]里面的每个参数Fuzz POST Param单独fuzz POST[]里面的每个参数Insert Fuzz Scan对光标所在的位置插入Profile payload 进行FuzzStop Scan停止所有的漏洞扫描Config配置对话框【线程池数量|忽略测试的参数名】 chunked-coding-converter 本插件主要用于分块传输绕WAF
插件使用 延时分块传输
获取方式 关注浪飒sec公众号回复221107
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ffcb02238690c4f74415d03acc8a083/" rel="bookmark">
			删除字符串中的重复字符，只使用一个数组，尝试用指针实现。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序：
#include &lt;stdio.h&gt; int main(int argc, const char *argv[]) { char arr[30]="qwertyuwertasdfgwq"; char *p=arr; int len=sizeof(arr)/sizeof(arr[0]); int i=0; int j=0; int k=0; for(i=0;i&lt;len;i++) { char s=*(p+i); for(j=0;j&lt;len;j++) { if(s==*(p+j) &amp;&amp; i!=j) { for(k=j;k&lt;len;k++) { *(p+k)=*(p+k+1); } } } } puts(p); return 0; } 运行效果：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/89/">«</a>
	<span class="pagination__item pagination__item--current">90/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/91/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>