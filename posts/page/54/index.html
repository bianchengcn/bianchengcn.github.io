<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6ff7ff803eaa96f0f0d741e10e1772/" rel="bookmark">
			设置显卡为非独占模式，解决CUDA error: all CUDA-capable devices are busy or unavailable CUDA kernel errors might b
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当调用显卡时，报错：CUDA error: all CUDA-capable devices are busy or unavailable CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect. For debugging consider passing CUDA_LAUNCH_BLOCKING=1
再看nvidia-smi显卡信息，最右边一列，Volatile Uncorr. ECC GPU-Util MIG M.这里，显示的是E.Process Disabled
原因：这是因为显卡设置了独占模式
解决方案：解除显卡的独占模式：
nvidia-smi -c 0 #设置所有显卡为独占模式False user:~$ sudo nvidia-smi -c 0 [sudo] password for speed: Set compute mode to DEFAULT for GPU 00000000:01:00.0. Set compute mode to DEFAULT for GPU 00000000:02:00.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6ff7ff803eaa96f0f0d741e10e1772/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/245bc26e74e30ef08cc383e19358ebd4/" rel="bookmark">
			nvidia-smi命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nvidia-smi（NVIDIA System Management Interface）是一种命令行实用程序，用于监控和管理 NVIDIA GPU（图形处理器）的状态和性能。它提供了一种简单而强大的方式来获取有关 GPU 的实时信息，并且可以用于诊断、优化和管理 GPU 资源。
详细的信息可以去手册中查找：man nvidia-smi
在大多数情况下，nvidia-smi 是与 NVIDIA GPU 驱动程序一起安装的，当安装 NVIDIA GPU 驱动程序时，nvidia-smi 工具通常会自动包含在驱动程序软件包中，并在安装过程中将其放置在适当的位置。
目录
1. nvidia-smi 面板解析
2. nvidia-smi 常用选项
3. 显存与GPU的区别
1. nvidia-smi 面板解析 GPU：本机中的GPU编号，从0开始，上图为0，1，2，3四块GPUFan：风扇转速（0%-100%），N/A表示没有风扇Name：GPU名字/类型，上图四块均为NVIDIA GeForce RTX 3080Temp：GPU温度（GPU温度过高会导致GPU频率下降）Perf：性能状态，从P0（最大性能）到P12（最小性能），上图均为P2Pwr：Usager/Cap：GPU功耗，Usage表示用了多少，Cap表示总共多少Persistence-M：持续模式状态，持续模式耗能大，但在新的GPU应用启动时花费时间更少，上图均为OnBus-Id：GPU总线Disp.A：Display Active，表示GPU是否初始化Memory-Usage：显存使用率Volatile GPU-UTil：GPU使用率，与显存使用率的区别可参考显存与GPUUncorr. ECC：是否开启错误检查和纠错技术，0/DISABLED，1/ENABLED，上图均为N/ACompute M：计算模式，0/DEFAULT，1/EXCLUSIVE_PROCESS，2/PROHIBITED，上图均为Default Processes：显示每个进程占用的显存使用率、进程号、占用的哪个GPU
Reference：Adenialzz
补充：ECC纠错
ECC（Error Correction Code）纠错码，是一种在数据传输或存储过程中用于检测和纠正错误的技术。在数据传输过程中，由于噪声、干扰或设备故障等原因，数据可能会发生错误。ECC纠错码被设计用来检测这些错误，并尽可能地纠正它们，以确保数据的完整性和准确性。
ECC纠错码使用一系列算法和技术，将原始数据编码为一组冗余数据，称为校验码。这些校验码根据数据的特定规则计算得出，并随着数据一起传输或存储。接收方在接收到数据后，会使用相同的算法和技术对接收到的数据进行校验码的计算。然后，接收方会比对原始数据和校验码，如果发现错误，则会尝试通过纠正算法自动修复错误，恢复原始数据的准确性。
ECC纠错码的使用可以提高数据传输和存储系统的可靠性。它常用于存储介质（如硬盘、闪存）和通信渠道（如网络传输）中，以确保数据的完整性和可靠性。ECC纠错码的应用领域包括计算机存储系统、无线通信、数字广播等。不同类型的ECC纠错码有不同的纠错能力，可以根据特定的需求选择适当的纠错码。
2. nvidia-smi 常用选项 注意⚠️：命令的可用选项和输出可能会因 NVIDIA 驱动程序版本和 GPU 型号而有所不同，可以通过 nvidia-smi --help 命令查看完整的选项列表和用法说明。
-h 查看帮助手册：nvidia-smi -h 动态地观察 GPU 的状态：watch -n 0.5 nvidia-smi -i 查看指定GPU：nvidia-smi -i 0-L 查看GPU列表及其UUID：nvidia-smi -L-l 指定动态刷新时间，默认5秒刷新一次，通过Ctrl+C停止：nvidia-smi -l 5-q 查询GPU详细信息：nvidia-smi -q只列出某一GPU的详细信息，可使用 -i 选项指定：nvidia-smi -q -i 0在所有 GPU 上启用持久性模式：nvidia-smi -pm 1指定开启某个显卡的持久模式：nvidia-smi -pm 1 -i 0以 1 秒的更新间隔监控整体 GPU 使用情况：nvidia-smi dmon以 1 秒的更新间隔监控每个进程的 GPU 使用情况：nvidia-smi pmon 补充：UUID
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/245bc26e74e30ef08cc383e19358ebd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e23deed77abf917b046e74b465bdb7/" rel="bookmark">
			MySql进阶使用之视图、索引（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql进阶使用（详细讲解） 文章目录 Mysql进阶使用（详细讲解）前言1.视图1.1 什么是视图1.2 视图与数据库表的区别1.3 视图的优点1.4 视图的使用语法语法说明案例结果显示创建视图结果查看视图结果 注意事项：显示结果 2. 索引2.1 什么是索引2.2 为什么要使用索引2.3 索引的优缺点优点缺点 2.4 什么时候使用索引2.5 索引什么情况下会失效2.6 索引的分类2.6.1 普通索引创建语法修改表结构方式添加索引删除索引案例 2.6.2.唯一索引2.6.3.主键索引2.6.4.组合索引2.6.5.全文索引 3. 数据备份与还原3.1 什么是数据备份与还原3.2 为什么要数据备份与还原3.3 数据备份与还原的操作3.3.1 导出3.3.2 导入 结束语 前言 今天给大家带来分享有关MySql进阶使用的知识分享，希望能给大家带来帮助，请认真阅读。接下来跟着我们的思维导图一起来看看吧。
1.视图 1.1 什么是视图 视图（View）是在数据库中创建的虚拟表，它基于查询的结果集。它是通过使用存储在数据库中的数据来动态生成的，但在物理存储上并不保留数据。视图可以被视为一个存储了特定数据的虚拟表，类似于物理表，但实际上并不存储任何数据。
视图可以由一个或多个表的列组成，并且可以根据需求进行筛选、过滤、排序和聚合等操作。它提供了一种简化和抽象的方式来访问和处理数据库中的数据。
使用视图可以为用户隐藏复杂的数据模型和查询，只暴露所需的数据和字段，从而简化数据访问和操作。视图还可以提供数据安全性，限制用户对敏感数据的访问权限。
通过创建视图，可以避免重复编写复杂的查询语句，提高查询的效率和可重用性。视图还可以用作其他视图的基础，实现更复杂的数据操作和分析。
1.2 视图与数据库表的区别 数据存储：数据库表是物理存储的实体，它在数据库中占据一定的存储空间，直接存储数据记录。而视图只是一个虚拟的、基于查询结果集的表，不直接存储数据，它只存储了查询定义和规则。数据内容：数据库表存储了完整的数据记录，包括每个字段的值和行之间的关系。视图是基于表或其他视图的查询结果集，它只包含符合查询条件的部分数据或经过筛选、聚合、计算等操作后得到的结果。数据维护：表是可以直接修改、插入和删除数据的实体，对表的操作会直接影响存储在其中的数据。视图是只读或有限可写的，对视图进行的操作会间接地对底层的表或数据进行修改。数据结构：表有自己的列和行，定义了数据的结构和关系。视图可以由一个或多个表的列、行和数据关系组成，它是基于表结构和查询条件来动态生成的。数据访问：表可以直接被用户查询、更新和操作，用户可以直接访问表中的数据。而视图通常用于提供简化、安全和抽象的数据访问层，用户可以通过视图来查询和操作数据，而对于底层的表结构和数据的具体细节可以隐藏起来。 1.3 视图的优点 简化数据访问：视图提供了对数据的简化和抽象访问方式。通过创建视图，可以隐藏复杂的查询语句和数据模型，用户可以直接从视图中查询、过滤和操作数据，无需了解底层表的结构和关系。数据安全性：视图可以用于实现数据安全性和权限控制。通过视图，可以限制用户只能访问特定的列、行或满足特定条件的数据，从而保护敏感数据的安全性，并确保用户只能获取其所需的数据。数据简化与聚合：视图可以对底层表执行复杂的查询、筛选、排序和聚合操作，从而简化了用户对数据的操作。用户可以通过视图获取已经聚合或计算好的结果，而不需要自己编写复杂的查询语句。逻辑数据独立性：通过使用视图，可以实现逻辑数据独立性。当数据库的表结构发生变化时，只需要修改视图的定义，而不需要修改使用这些视图的应用程序或查询。查询重用：视图提供了查询的重用性。可以创建基础视图，然后在其他视图或查询中使用它们，从而避免重复编写复杂的查询语句，并提高查询的效率和可维护性。数据逻辑封装：视图可以将复杂的数据逻辑封装在一个虚拟的表中。这样，应用程序和用户只需要与视图交互，而无需了解底层数据模型和具体的计算逻辑，提高了数据的抽象和封装程度。 1.4 视图的使用 语法 CREATE VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt; 语法说明 &lt;视图名&gt;：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。&lt;SELECT语句&gt;：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。 对于创建视图中的 SELECT 语句的指定存在以下限制：
用户除了拥有 CREATE VIEW 权限外，还具有操作中涉及的基础表和其他视图的相关权限。SELECT 语句不能引用系统或用户变量。SELECT 语句不能包含 FROM 子句中的子查询。SELECT 语句不能引用预处理语句参数。 案例 --创建视图 CREATE view v_student_score as select s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61e23deed77abf917b046e74b465bdb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f584494f6d7bbfd573bcbf64b522eb4/" rel="bookmark">
			jquery和php json字符串转数组对象 和 数组对象转json字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON 与 数组对象转化 要实现从对象转换为 JSON 字符串，使用 JSON.stringify() 方法：
var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{"a": "Hello", "b": "World"}' 要实现从 JSON 转换为对象，使用 JSON.parse() 方法：
var obj = JSON.parse('{"a": "Hello", "b": "World"}'); //结果是 {a: 'Hello', b: 'World'} 数组和字符串的转换： 数组变字符串 var a,b; //两变量 一个数组a 一个字符串b a=new Array[0,1,2,3,4,5]; b=a.join("-"); //b="0-1-2-3-4-5" ,js里面数组变成字符串用的是 数组名.join("-")； 字符串变数组 var b="0-1-2-3-4-5"; var a=b.split("-"); //在-分解, js里面字符串变数组用的是 字符串.split("-"); 拼接和分割法 php中Json和数组转化 json转数组 json_decode( string $json , bool $assoc = false , int $depth = 512 , int $options = 0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f584494f6d7bbfd573bcbf64b522eb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199616a0d7034bcbe8a9850c1a301fe9/" rel="bookmark">
			JavaWeb-HTTP协议（服务器数据的接收、处理、响应流程）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 HTTP协议HTTP请求两种HTTP请求方式在服务器接收信息（HttpServletRequest）请求行请求头请求体 处理响应 HTTP协议 ● 什么是HTTP协议？ 超文本传输协议（Hypertext Transfer Protocol）服务器传输超文本到本地浏览器的传送协议，是互联网上应用最为流行的一种网络协议，用于定义客户端浏览器和服务器之间交换数据的过程
● HTTP是基于TCP/IP通信协议来传送数据
● HTTP是属于引用层的协议，由于棋简捷、快速的方式、适用于分布式超媒体信息系统
HTTP请求 客户端连上服务器后，向服务器请求某个web资源，称之为客户端向服务器发送一个http请求。
就是从浏览器中以超链接，表单等向服务器发送的请求都称为http请求。
请求包括：请求行，请求头，(这两部分会自动发送) 请求体。
请求行：http请求方式，请求资源名称，http版本（例如post、post、text.jsp、HTTP/1.1）
请求头：服务器端和客户端的一些信息格式为键值对。
请求体：是指表单post方式请求时，向服务器端发送的数据
请求头包含主机地址，以及客户端的一些环境信息，以键值对的形 式传递.
Host: 127.0.0.1:8088 请求的主机地址
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8 浏览器能够处理的内容类型
Accept-Encoding: gzip, deflate, br 浏览器能够处理的压缩编码
Accept-Language: zh-CN,zh;q=0.9 浏览器当前设置的语言
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 使用的浏览器和操作平台信息
Connection: keep-alive 浏览器与服务器之间连接的类型
请求体代表着浏览器在post请求方式中传递给服务器的参数，请求体中参数以 键值形式传递， 多个用&amp;链接，服务器接收到后再解析. username=admin&amp;userpwd=123
两种HTTP请求方式 get（获得）：从服务器端获取数据，在地址栏会显示发送的数据,但是一般有以下状况
1、不安全
2、传输的数据大小受限制 一般浏览器的大小为2-5kb
● 以超链接访问，默认是GET方式
● form提交，不指定method，默认为GET方式
post（发送）：向服务器端发送数据，向服务器端发送数据，发送的数据是在请求体当中，安全（相对安全），大小不受限制
● form提交，指定method=“post”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/199616a0d7034bcbe8a9850c1a301fe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fafc7925e2d1607c39e31651b2d1d3a/" rel="bookmark">
			vue引入高德地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先index.html引入
&lt;script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.15&amp;key=XXXXXXXXXXXXXXXXXXXXXXXXXXXX"&gt;&lt;/script&gt; 2.引入并插入坐标点
&lt;template&gt; &lt;div class="all"&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;el-dialog title="介绍" :visible.sync="dialogVisible" width="30%"&gt; &lt;span style="display: flex;justify-items: center;flex-flow: column;align-items: center;"&gt; &lt;!-- &lt;img style="width: 50%;" :src="pic" alt=""&gt; --&gt; &lt;div&gt;{{ details }}&lt;/div&gt; &lt;/span&gt; &lt;span slot="footer" class="dialog-footer"&gt; &lt;el-button type="primary" @click="dialogVisible = false"&gt;关 闭&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { dialogVisible: false, details: "", pic: "", }; }, mounted() { var map = new AMap.Map('container', { zoom: 11, center: [116.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fafc7925e2d1607c39e31651b2d1d3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55eae8b1a91ea8dc9953a61eaa92ee6/" rel="bookmark">
			wps如何加载mathtype和Endnote
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了支持国产化软件，弃用office套装，现在改用wps办公软件，但是写作科技论文的时候还是会出现很多的不方便，比如文献引用、公式排版编号等等。尽管wps自带了公式编辑器，然鹅这可太不方便了，因此把几个技巧总结了一下：
1 wps嵌入mathtype 1.1 安装mathtype 关闭wps，傻瓜式运行默认安装程序即可
1.2 安装wps.vba.exe 互联网有相关资源，安装vba之后才能用mathtype，相关链接为https://pan.baidu.com/share/init?surl=DD-1j-fnRnNo_Uk00__rag，提取码：will。傻瓜式直接安装即可
1.3 点击加载项 打开wps，找到开发工具里面的加载项，点进去后选择添加 选择mathtype安装路径下面的support文件夹，注意要看清楚wps的版本，我的是32位的，所以找到32位的以下文件
选择一个dotm文件进行添加，同理添加32位的mathpage文件
1.4 缺点和改进 第一是每次使用都要去重新点击加载项，所以可以直接放到启动项中，路径如下图
于是，每次启动就可以直接使用了。
第二是插入公式后后面会有自带空格，通过更改注册表可以在Office Word上有效果，但是目前对wps还不知道怎么搞。
2 wps嵌入Endnote 这个很简单，直接安装endnote即可，一般默认会关联的，如果没有的话在开发工具里的com加载项里找一下直接勾上即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922954765010cc438e09cd2f5a84e0de/" rel="bookmark">
			JavaScript 实现全选、单选和反选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;全选、单选、反选&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="checkbox" id="selectAll"&gt; 全选&lt;br&gt; &lt;input type="checkbox" class="item"&gt; 选项1&lt;br&gt; &lt;input type="checkbox" class="item"&gt; 选项2&lt;br&gt; &lt;input type="checkbox" class="item"&gt; 选项3&lt;br&gt; &lt;!-- 更多选项... --&gt; &lt;script&gt; const selectAllCheckbox = document.getElementById('selectAll'); const itemCheckboxes = document.getElementsByClassName('item'); // 全选 selectAllCheckbox.addEventListener('change', function() { for (let i = 0; i &lt; itemCheckboxes.length; i++) { itemCheckboxes[i].checked = this.checked; } }); // 单选 for (let i = 0; i &lt; itemCheckboxes.length; i++) { itemCheckboxes[i].addEventListener('change', function() { let allChecked = true; for (let j = 0; j &lt; itemCheckboxes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/922954765010cc438e09cd2f5a84e0de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/708b9a206a50df010a3bc5bb07da216b/" rel="bookmark">
			编译原理实验：自下而上的语法分析（LR分析程序），附代码（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、写在前面
二、实现要求
三、思路及代码
文法分析
构造DFA：
构造LR分析表
移进
归约
非终结符
构造SLR分析表
归约
一、写在前面 2023.7.7更新，针对这篇文章提到的不足更新了新的文章：
其中实现了大于一个字符变量的运算和扩展了运算符（这个程序只有加法和乘法），并且做了完整的编译器：自下而上的编译器
1.本人并不擅长编程和编译原理这门课程，只是写代码之后蛮有意义。觉得可以分享出来，各位可以交流学习，如果有错误欢迎指出。
2.不保证思路和解决方式是最佳思路，也不能保证正确性，请勿将本文当做考试复习参考。其中涉及到专业名词的部分可能会有描述错误，请谅解。
3.本人个人写代码不习惯写注释，变量的命名也很随意，请谅解。
4.本文会讲述全部代码思路，代码是按模块分段展示的（也会在文中提及主函数的编写逻辑），代码需要自己整合，有编程基础的朋友一定能在阅读后根据提示写出完整程序。因为看到很多朋友在解决此法时遇到困难，仅作为交流。如果是想要直接复制完整代码的本站有其他大佬的分享帖。
5.请谅解文章中的错别字，标点符号，以及的地得！
6.ncwu慎用。
二、实现要求 （1）根据给定文法，先对文法进行解析，构造识别活前缀的 DFA 并输出；
（2）根据 DFA 构造 LR 分析表并输出；
（3）分析给定表达式是否是该文法识别的正确的算术表达式（要求输出归约过程）
（4）假如给定表达式文法为：
G（E’）: E’→#E#
E→E+T | T
T→T*F |F
F→(E)|i
分析的句子可为: (i+i)*i 和 i+i)*i
三、思路及代码 这里受篇幅限制就不介绍LR分析法的原理了，大家可以自行阅读教材，这里我使用的是陈火旺编写的《编译原理》教材。
这个代码实现步骤其实很清晰，我们可以把他拆分成四步：拿到文法进行分析-&gt;构造DFA-&gt;构造LR分析表-&gt;归约。那么这里就按照这四步分别展开阐述。
文法分析 为了后面阅读的通畅这里介绍一下程序的一些前期的初始化。我们建立了类word，在构造函数中提前把表达式文法放到了数组id[]中。关于word类中后续的元素以及作用会在后面的文章中提及。
class word{ public: string id[50]; string w[50];//存放完整的文法 string VN[50],VNPLUS[50][50];//存放非终结符 string VT[50];//存放终结符 string cla[50],flag[50][50];//flag是是否存放非终结符的标志 string gui[50],yuan[50]; string LR[50][50],action_goto[50][50]; int n=4,n1,x,numlr;//x是非终结符个数 numlr为lr的行 int list[50][50],numplus[50],nnn[50]; //numplus为 VNPLUS数量 nnn为lr的每个元素数量 int t,f[50],numvex[50],deff[50],numdef; //终结符个数 int SLR[50],slr,notes,numfollow[50];//这里如果出现移进归约冲突，用SRL标记其是否为LR文法 string fx1,fx2; string follow[50][50]; word(); void makefollow();//求follow集 void flit(); void settle(); //整理前面不完美的 VNPLUS，VNPLUS的目的是把规范族整理方便计算 bool flagVN(string a); void copy(int a,int b); int number(string a,int i);//返回坐标函数,i=1表示终结符 void guiyue(string a);//开始归约 int getLR(string a);//寻找这是第几个生成式 string int_tostr(string a[],int i); string suibianla(string a);//这个是取数字的，不知道起什么名字 typedef struct //这是一个图 { string vex[50][50];//存放顶点 string arcs[50][50];//邻接矩阵 int vexnum,arcnum;//边数和节点数量 }AMGC; void Createamg(AMGC &amp;G,string str[],int a); void foll(AMGC &amp;G,string str,int a); void full(AMGC &amp;G); void makelist(AMGC &amp;G); void check(AMGC &amp;G,int i,int dot,int chaoji); //用于检查，如果新生成的规范组是之前有的，那么及时地删掉，也可以防止死循环 void makeslr(AMGC &amp;G);//如果不是LR，就生成SLR }; word::word(){ this-&gt;id[0]="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/708b9a206a50df010a3bc5bb07da216b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d83a0445f44bf00004661a59ca2c8ca7/" rel="bookmark">
			编译原理设计：自下而上的编译器，（C&#43;&#43;实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位好，这次分享的是编译原理课程中的自下而上的编译器设计，在这之前，我在本站分享过自下而上LR分析程序的完整代码，见此链接：自下而上的语法分析（LR分析程序）
但那个程序只能分析加法和乘法运算，且无法分析大于一个字符的运算变量，在这个程序中，对于以上问题进行了完善，但为了方便采用了算符优先分析，至于LR的分析各位有兴趣可以看上面那篇文章进行参考。
目录
一、写在前面
二、功能需求
三、需求分析
四、详细过程
4.1输入
4.2词法分析 4.3语法分析
4.4中间代码生成
五、测试与运行结果
一、写在前面 1.本人并不擅长编程，各位可以交流学习，如果有错误欢迎指出。
2.不保证思路和解决方式是最佳思路，也不能保证正确性，请勿将本文当做考试复习参考。其中涉及到专业名词的部分可能会有描述错误，请谅解。
3.本人个人写代码不习惯写注释，变量的命名也很随意，请谅解。
4.本文会讲述全部代码思路，代码需要自己整合，仅作为交流。
5.请谅解文章中的错别字，标点符号，以及的地得！
二、功能需求 本编译器完成了一下需求：
任务：编写一个完整的编译程序，包括词法分析器、语法分析器以及实现对简单程序设计语言中
的逻辑运算表达式、算术运算表达式、赋值语句、While语句，并生成中间代码。
具体如下：
1) 可以输入要编译的文件名，从给定文件中读取编译的源程序，也可从键盘输入；
2) 能进行功能选择进行词法分析，语法分析，中间代码生成，输出
3) 可以输出二元式序列，分析过程，四元式表；
4) 语法分析给出分析过程，分析结果。
5) 以自下而上方法实现语法分析
三、需求分析 根据题目要求，要实现词法分析，语法分析，中间代码生成，三个要求，这三个要求相辅相成，词法分析能保住语法分析，语法分析的结果也能够为中间代码生成提供输入，且输入需满足逻辑运算表达式、算术运算表达式、赋值语句、While语句。
在这里我们提供的输入形式也要满足两个要求：输入要编译的文件名，从给定文件中读取编译的源程序，从键盘输入。
同时要照顾到三个不同的测试数据，分别为1、全部合法数据；2、整体非法数据；3、局部非法数据。
四、详细过程 这里我们按照步骤来对每一个模块进行相应地说明。
4.1输入 输入我们放在Word类中的fileopen()函数中。这里不光满足了题目要求中两种方式，我们还内置了一个范例语句：
main(){
int A=0,B=1,C=1,D=2;
while(!A &amp;&amp; C&gt;D){
C=(A+B*D)*C;
}
}
这个范例语句包含了题目的所有要求：逻辑运算表达式、算术运算表达式、赋值语句、While语句。
在fileopen()中，我们根据用户的选择读入输入的语句，而内置的范例语句其实也是放在文件中的。如果用户不选择输入地址就会默认采用范例语句所在文件的地址。
接下来，无论是以哪种方式，我们都要把输入的语句放在数组K中，便于后续操作，这里如果是采用从键盘输入时需要注意，因为输入空格会被cin识别成两个语句，而int后面必须要加一个空格（不然int无法被识别成标识符）。所以在这里要有一个特例进行讨论：
代码如下：
void word::fileopen() { char str[100][101]; char a[100]; int i = 1, Fun, line; FILE* file; h = 0; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d83a0445f44bf00004661a59ca2c8ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ee630c2800f9bc7bacb745ca480e439/" rel="bookmark">
			Vite&#43;Vue3 React Seo预渲染插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 预渲染原理基本上都是启动无头浏览器，加载页面路由并将结果保存为静态HTML文件，存在很多优点。
如果你还在翻遍百度查找关于vite+vue3和react的预渲染，看这篇就够了。写一个完全符合自己需求的预渲染插件。
1.在项目安装无头浏览器，npm add puppeteer --dev
2.新建插件文件如./prerender.js，内容为：
import puppeteer from 'puppeteer' import fs from "fs" /** @param routes 预渲染路由地址 */ const seoPrerender = (routes) =&gt; { return { name: "viteSeoPrerender", async closeBundle() { // 预渲染逻辑放这里，即打包完成后执行预渲染 // 复制puppeteer官方示例 const browser = await puppeteer.launch() const page = await browser.newPage() for (const key in routes) { // 遍历需渲染的路由 // 这里先简单化把url固定，可通过先启动vite preview的方式取得访问地址和端口 await page.goto("http://127.0.0.1:4173" + key) await page.setViewport({width: 1024, height: 768}) const content = await page.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ee630c2800f9bc7bacb745ca480e439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e46be805a799282c231789c855cef24/" rel="bookmark">
			PyTorch使用TensorBoard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 直接使用pip安装即可。
pip install tensorboard 代码体中要做的事 首先导入tensorboard
from torch.utils.tensorboard import SummaryWriter 这里的SummaryWriter的作用就是，将数据以特定的格式存储到刚刚提到的那个文件夹中。
首先我们将其实例化
writer = SummaryWriter('./path/to/log') 这里传入的参数就是指向文件夹的路径，之后我们使用这个writer对象“拿出来”的任何数据都保存在这个路径之下。
这个对象包含多个方法，比如针对数值，我们可以调用
writer.add_scalar(tag, scalar_value, global_step=None, walltime=None) 这里的tag指定可视化时这个变量的名字，scalar_value是你要存的值，global_step可以理解为x轴坐标。
举一个简单的例子：
for epoch in range(100) mAP = eval(model) writer.add_scalar('mAP', mAP, epoch) 这样就会生成一个x轴跨度为100的折线图，y轴坐标代表着每一个epoch的mAP。这个折线图会保存在指定的路径下（但是现在还看不到）
同理，除了数值，我们可能还会想看到模型训练过程中的图像。
writer.add_image(tag, img_tensor, global_step=None, walltime=None, dataformats='CHW') writer.add_images(tag, img_tensor, global_step=None, walltime=None, dataformats='NCHW') 可视化 我们已经将关心的数据拿出来了，接下来我们只需要在命令行运行
：
tensorboard --logdir=./path/to/the/folder --port 8123 然后打开浏览器，访问地址http://localhost:8123/即可。这里的8123只是随便一个例子，用其他的未被占用端口也没有任何问题，注意命令行的端口与浏览器访问的地址同步。
如果发现不显示数据，注意检查一下路径是否正确，命令行这里注意是
--logdir=./path/to/the/folder 而不是
--logdir= './path/to/the/folder ' 另一点要注意的是tensorboard并不是实时显示（visdom是完全实时的），而是默认30秒刷新一次。
细节 1.变量归类 命名变量的时候可以使用形如
writer.add_scalar('loss/loss1', loss1, epoch) writer.add_scalar('loss/loss2', loss2, epoch) writer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e46be805a799282c231789c855cef24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/147b63aee28daba20100d9ef878f3390/" rel="bookmark">
			华为交换机命令集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 华为交换机命令大全 1、进入系统视图2、更改设备名3、显示交换机mac地址4、查看接口详细信息，包括状态、mac地址等5、显示接口当前配置![在这里插入图片描述](https://img-blog.csdnimg.cn/fb5cfc17ab894587b08bc47d1d9e7c3b.png)6、退回到上一层7、跨级退出![在这里插入图片描述](https://img-blog.csdnimg.cn/8826fab692fc42718023cf1f8e1d6f13.png)8、保存设置9、清除接口的配置，需指定接口![](https://img-blog.csdnimg.cn/26c5d09b07934af9b2945fc7b68ff2d1.png)10、清除接口的配置，需指定接口11、清除已保存的配置![在这里插入图片描述](https://img-blog.csdnimg.cn/1641d206657f4a10b4d9fe3db605be1e.png)12、重启![在这里插入图片描述](https://img-blog.csdnimg.cn/5815d773291443329b894c8c4eed5158.png)13、设置用console线连接时永不超时，默认是10min14、直接在接口模式下切换到其他接口不用退出当前视图15、查看mac地址表16、关闭自协商功能，默认是自动协商，需先关闭之后可手动设置速率17、关闭监视功能18、禁止弹出接口信息19、历史命令查询 1、进入系统视图 2、更改设备名 3、显示交换机mac地址 4、查看接口详细信息，包括状态、mac地址等 5、显示接口当前配置 6、退回到上一层 7、跨级退出 8、保存设置 9、清除接口的配置，需指定接口 10、清除接口的配置，需指定接口 11、清除已保存的配置 12、重启 13、设置用console线连接时永不超时，默认是10min 14、直接在接口模式下切换到其他接口不用退出当前视图 15、查看mac地址表 16、关闭自协商功能，默认是自动协商，需先关闭之后可手动设置速率 17、关闭监视功能 18、禁止弹出接口信息 19、历史命令查询 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e0276232013ebd78d5e8e6423ec811c/" rel="bookmark">
			虚拟机内更换账户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.win+r打开面板
二.在输入框内输入netplwiz弹出
三.点击添加,选择 "不使用Microsoft账户登录"
四.点击下一页,使用本地账户登录
五.输入用户名和密码,点击下一页,点击完成
六.选中刚刚创建的用户名,点击属性,然后点击组成员
七.选择管理员,点击确定
八.选择电脑原来的账户,点击属性改为标准用户
九.点击确定之后电脑会弹出对话框让你确认重启,重启后更改账户进行登录
选择刚刚创建的账户输入密码进行登录,进去之后就会看到账户已经更改 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce5aad8a6cf7c1fefab1605aff568489/" rel="bookmark">
			JVM篇：CMS与G1区别&amp;适用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于JMV垃圾收集器，面试常问CMS与G1的区别问题，总是记不住。为了方便记录，整理成如下表格，从不同维度对比CMS和G1两个收集器。
区别CMSG1回收对象 回收老年代
需要配合新生代收集器一起使用
老年代和新生代STW时间以最小停顿时间为目标可预计的垃圾回收停顿时间回收算法标记清除标记整理垃圾碎片产生内存碎片没有内存碎片垃圾回收过程 初始标记（STW）并发标记重新标记（STW）并发清除 初始标记(STW)并发标记最终标记(STW)筛选回收(STW)浮动垃圾 会产生浮动垃圾（第四阶段产生）
没有浮动垃圾（第四阶段，用户线程卡停）
浮动垃圾产生原因第四阶段并发清楚，GC线程和用户线程同时运行，用户线程会产生浮动垃圾浮动垃圾导致结果浮动垃圾导致内存不足时候，出现“Concurrent Mode Failure”，出现此错误时就会切换到SerialOld收集模式大对象处理直接进入老年代如果大于一个region的50%，会横跨多个region进行存放优点 并发收集，低停顿 控制垃圾回收时间：选择一组合适的region最为回收目标，达到实时收集目的空间整理：不会产生空间碎片缺点 标记清除，产生大量内存碎片。（导致fullGc）无法处理浮动垃圾，内存不足时出现“Concurrent Mode Failure”（并发模式故障），切换到SerialOld收集模式CPU敏感资源敏感，第二阶段并发阶段虽然不会导致用户线程停顿，但如果再CPU资源不足情况下，应用会有明显卡顿使用场景 JDK8及更高版本同等环境下只要cpu性能比较好并且内存不算大 (最少4G)可以使用CMSJDK7及更低版本同等环境下 可选择CMS (G1不完善) 实时数据占用超过一半的堆空间对象分配或者晋升的速度变化大希望消除长时间的GC停顿G1适合8/16G以上的内存使用 参考资料
垃圾回收器CMS和G1_Ysming88的博客-CSDN博客
CMS收集器和G1收集器的区别_cms和g1的区别_技术无产者的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a112943661935baf886b14156c9ed42c/" rel="bookmark">
			保姆级VMware虚拟机安装Linux(CentOS7)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.VMware安装 下载 VMware16：
下载链接：https://pan.baidu.com/s/1Fgnzw2EEDMV9HtKWhWDDnA?pwd=6666
提取码：6666
下载完成后点击安装即可，VMware 虚拟机安装比较简单，下面仅给出关键步骤。
自定义安装路径，推荐安装在 C 盘以外的磁盘：
不要勾选 VMware Workstation 增强型键盘功能：
不要勾选 VMware Workstation 软件检查更新和帮助完善：
安装完成后不要点击完成，点击许可证：
没有激活 VMware 许可证密匙的点赞 + 收藏 + 关注，为了避免看不到私信已经将密钥放在评论区了。😊
安装成功后的虚拟机页面如下：
激活信息如下:
2.CenOS7安装 下载 CentOS7 ，下面给出 CentOS7 桌面版链接：
下载链接：https://pan.baidu.com/s/1vFtWh8iecHCwHf-e0_QV2w?pwd=8080
提取码：8080
友友也可以自行下载不同的镜像，下面给出一些地址：
网易镜像：http://mirrors.163.com/centos/7/isos/x86_64/搜狐镜像：http://mirrors.sohu.com/centos/7/isos/x86_64/ 在正式开始之前，先检查检查 BIOS 虚拟化支持是否开启：【任务管理器 ctrl + shift + esc】-【性能】
打开 VMware 新建虚拟机：
虚拟机向导页面选择自定义：
虚拟机硬件兼容性保持默认即可：
安装客户机操作系统页面，选择稍后安装操作系统：
选择客户机操作系统页面，选择 Linux：
设置虚拟机名称和存储位置（建议放在 C 盘以外的磁盘）：
处理器配置页面需要根据自己电脑的实际情况来进行分配，可以打开【任务管理器 ctrl + shift + esc】，查看自己的电脑处理器数量与核数进行合理分配：
设置虚拟机内存（选择 2 GB即可，后期可修改）：
选择网络类型，推荐使用网络地址转换（NAT）：
使用桥接网络：虚拟机相当于一台独立的与主机同级别的电脑，拥有自己独立的 IP 地址，外网能够单独访问到虚拟机。使用网络地址转换：外网不能直接访问虚拟机。 I/O 控制器类型保持默认：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a112943661935baf886b14156c9ed42c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ab533805275f3b4748ae8757361e30/" rel="bookmark">
			项目实战系列之解决Mybatis-plus利用collection查询一对多分页数据的Bug【一】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天开发一个分页功能的时候，前端找我说数据不对。自己测试了一下，果然有问题。
请求参数如下：
相应结果如下（字段太多，删除了一些非关键字段）：
total是总记录数的意思，有4条，但是结果只有3条。
网上搜索一番，定位到问题所在，这个是mybatis-plus关于分页的一个bug，我这里的collection写法如下（其中collection还有javaType属性，这里回退代码没有回退到底）：
需要改一下collection的写法，分成两次查就可以了：
说明：
column是关联的id，意思就是根据哪个字段来查询关联表的字段；另外需要删除原来写法下一个select语句中collection下的字段（因为现在转移到了第二个select中）。这种写法存在一个问题就是：dao中的参数传递不到collection对应的select语句中，collection对应的select语句的条件参数只能来自外层column属性。 通过修改为上面写法后，按照网上的说法就没问题了，但是我这里报了序列化的错误（因为postman测试工具中内容太长，就粘贴到了文本编辑器中）：
网上搜索了一下，是需要相关实体类实现序列化接口并且在类上添加注解@JsonIgnoreProperties(value = {“handler”})，作用是json序列化时忽略bean中的一些属性序列化和反序列化时抛出的异常：
然后在请求测试就可以了，结果就不贴出来了。
写在最后：collection对应的从表和主表关联条件必须在collection层级存在，不然在resultMap中会映射不到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90f570f96abcc3611dc6e3c8aad74afa/" rel="bookmark">
			网络安全应急响应最全教程(2023年7月)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0、写在前面1、概念及应急响应流程2、Windows排查2.1文件排查2.2、进程排查2.3、系统信息排查2.4、工具排查2.5、日志排查 3、Linux排查3.1、文件排查3.2、进程排查3.3、系统信息排查3.4、后门排查3.5、日志排查3.5.1、基于时间的日志管理3.5.2、系统日志管理3.5.3、中间件日志3.5.4、数据库日志3.5.6、相关处置 4、实际案例分析4.1、案例：信息泄露 0、写在前面 最近逛CSDN发现很多文章都写的不够深入与详细，所以就想着自己能不能写一个全面且深入的教程，能覆盖到目前所有可能会遇到的问题，在翻看了国内外各个论坛和文章之后写下的这篇文章。
1、概念及应急响应流程 应急响应流程是一种在突发事件发生时组织和协调资源、快速响应并减轻损失的计划。一个有效的应急响应流程可以帮助组织提高应对风险的能力，保障人员安全和财产
2、PDCERF(6阶段)
（1）事件预警/发现：
通过安全监控系统或日志报警、告警等方式发现异常或有风险的行为。
(2）事件确认：
事件预警后需要进行核实，确认事件的具体情况，确定事件的类型、影响范围、紧急程度等。
（3）事件分类：
根据事件的类型和影响程度对事件进行分类，并作出响应计划。
（4）紧急响应：
根据响应计划，启动紧急响应模式，调集相关的人员和资源，进行紧急处理和控制事件。
（5）事件调查：
对事件进行深入分析，找出事件的成因，并根据分析结果调整相关防护策略和措施，降低风险。
（6）事件修复/恢复：
恢复受影响的系统、数据和业务功能，确保业务恢复正常运作。
（7）事件总结/报告：
回顾事件处理过程，总结经验教训，撰写事件报告，并需要对相关人员进行培训和宣传，提高业务人员的安全意识和技能水平。
2、Windows排查 2.1文件排查 （1）查看开机启动有无异常文件
【开始】➜【运行】➜【msconfig】
任务管理器中也可进行查看
（2）各个盘下的temp( tmp)相关目录下查看有无异常文件 ：Windows产生的临时文件
（3）浏览器浏览痕迹、浏览器 下载文件、浏览器cookie信息，根据不同浏览器进行排查；例如：IE浏览器，打开IE浏览器点击【查看】➜【浏览器栏】➜【历史记录】（快捷键是Ctrl+Shift+H）
谷歌浏览器如下：
（4）Recent是系统文件夹，里面存放着你最近使用的文档的快捷方式，查看用户recent相关文件，通过分析最近打开分析可疑文件：
【开始】➜【运行】➜【%UserProfile%\Recent】
（5）根据文件夹内文件列表时间 进行排序，查找可疑文件。当然也可以搜索指定日期范围的文件及文件
1.了解应急的时间轴，以及确定攻击ip
2.根据发生安全事件的时间轴梳理事件流程
3.根据时间轴查找可疑文件，减少可疑文件范围）
（6）查看文件时间，创建时间、修改时间、访问时间 ，黑客通过菜刀类工具改变的是修改时间。所以如果修改时间在创建时间之前明显是可疑文件
（7）搜索webshell 相关内容
例如：PHP webshell
findstr Window系统自带的命令，查找指定的一个或多个文件
findstr /m /i /s “eval” *.php (注意字符串编码格式) 参数说明：
/m	如果文件包含匹配项，则仅打印该文件名 /i 指定搜索不区分大小写 /s 在当前目录和所有子目录中搜索匹配的文件 /b 如果位于行的开头则匹配模式 /e 如果位于行的末尾则匹配模式 /x 打印完全匹配的行 /v 只打印不包含匹配的行 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90f570f96abcc3611dc6e3c8aad74afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15ae11e00f579e0aed0ef307992dc696/" rel="bookmark">
			HTTP首部（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始头大，哈哈，这个东西真的很无聊且枯燥，奈何最近的学习中经常用到这些知识，还是过一遍比较放心。上一篇博客中我们讨论了http报文首部，其划分为请求头和响应头。请求头主要由请求行、请求字段、通用字段、实体字段组成，那么响应头也由响应行、响应首部字段、通用首部字段、实体首部字段等组成。
这些字段都有不同的用途， 每一个字段还有自己不同的指令，所以整体看起来还是有一些繁杂，不过没关系，一遍留个映像，大家在后续的持续学习中，会对经常用到的几个字段加以掌握深化就行。
1. 响应首部字段 响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。
1.1 Accept-Ranges Accept-Ranges: bytes 首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。
可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。
1.2 Age Age: 600 首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。
若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段Age。
1.3 ETag ETag: "82e22293907ce725faf67773957acd12" 首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag值。
另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。
资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览器访问 http://www.google.com/ 时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。
强 ETag 值和弱 Tag 值
强 ETag 值 – 不论实体发生多么细微的变化都会改变其值。
弱 ETag 值 – 弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。
1.4 location Location: http://www.usagidesign.jp/sample.html 使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15ae11e00f579e0aed0ef307992dc696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/039b9ab79e460113017294857ed3967e/" rel="bookmark">
			vs code小工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 新公司主流语言为js及其框架eggjs，需要尽快上手，而核心编辑器vscode就是必备技能，对比IDEA，通过demo项目快速了解开发中常用功能对应的快捷键等，保证快速上手。
1. 常用快捷键 快捷键功能Ctrl+P快速查找文件Ctrl+J快速打开终端Ctrl+/单行注释Alt+上下箭头移动当前代码行alt+←返回上次浏览位置ctrl+enter向下开辟一行，开始新一行，相当于vim的oend跳转行尾home跳转行首Ctrl+W关闭当前文件Ctrl+G快速跳转指定行SHIFT+ALT+上下箭头快速复制指定行的代码CTRL+SHIFT+F代码格式化F2方法重命名CTRL+-&gt;光标跳转下个单词或符号ALT+上下箭头移动代码行 2. 好用的插件 项目管理器 vscode缺少项目管理器，需要搞个插件管理多个项目markdown 随便搞个就行 3. 快捷命令 类似IDEA的一些live template，js项目也有很多console.log()之类的共同代码需要快捷命令
设置-&gt;管理-&gt;用户代码片段-&gt;javascript
修改对应的javascript.json，在该json文件中增加
"Print to console": { "prefix": "clg", "body": ["console.log($1);"], "description": "Log output to console" } 后续就能用clg+tab键生成console.log()代码了
4. 方法不自动带括号的处理 设置-用户，
搜索typescript.suggest.completeFunctionCalls和javascript.suggest.completeFunctionCalls 勾选后即生效
5. js代码默认末尾加逗号 同样，搜索javascript.format.semicolons 选择insert即可，每次shift+alt+F格式化后都会自动添加分号
3. 项目上手参考 koa与node.js开发实战 讲解比较详细，有对应github项目教程chatGPTB站黑马nodejs视频 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/53/">«</a>
	<span class="pagination__item pagination__item--current">54/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/55/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>