<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程中国的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程中国的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ba742583e43c103f26fbff8b81ca60/" rel="bookmark">
			C语言函数递归调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、函数递归调用的定义
递归函数定义：一个函数在 自己的函数体内 调用自己；执行递归函数将反复调用其自身，每调用一次就有一个新层
#include&lt;stdio.h&gt; // 函数声明 void diguifunc(); int main() //主函数 { diguifunc(); //运行后程序会崩溃，资源耗尽了 } // 递归函数的定义 void diguifunc() { int tempvar1 = 150; //局部变量：在函数内部定义的变量，当函数整个执行完毕后，局部变量所占的内存会被系统自动回收，回收后该局部变量就不可以再使用了。 printf("diguifunc函数执行-----\n"); diguifunc(); } // 调用栈(一块系统分配给咱们这个程序有特殊用途的内存)：就是把形式参数，函数调用关系，局部变量等进行保存在栈里面。 这段内存是有限的，如果一旦超过这个内存大小，就会出现崩溃现象。 函数递归调用运行图：
2、递归调用的出口
因为上面这种递归调用会产生死循环，所以这种自己调用自己的方式必须要有一个出口，这个出口也叫做递归结束条件，从而能够让这种函数调用结束。
范例：计算5的阶乘，其实就是计算 1*2*3*4*5，
我们并不知道5的阶乘是多少，但是我们知道一点，4的阶乘 * 5他就等于5的阶乘。
我们并不知道4的阶乘是多少，但是我们知道一点，3的阶乘 * 4他就等于4的阶乘。
我们并不知道3的阶乘是多少，但是我们知道一点，2的阶乘 * 3他就等于3的阶乘。
所以递归调用的出口肯定是在1的阶乘，因为1的阶乘是1，可以作为出口，我们能够求出2的阶乘，也就是1*2；以此类推瑞。
#include&lt;stdio.h&gt; // 函数声明 int dg_jiecheng(int n); int main() //主函数 { int result = dg_jiecheng(5); printf("result=%d\n",result); // 结果为120 } // 函数定义 int dg_jiecheng(int n) { int result; // 局部变量，保存阶乘结果 if(n==1) // 1的阶乘就是1 { return 1; // 这里就是该递归调用的出口 } else { // 第一次是 result = dg_jiecheng(4)*5,然后进入到了 dg_jiecheng(4),这行代码就被暂存了； 第二次是 result = dg_jiecheng(3)*4,然后进入到了 dg_jiecheng(3),这行代码就被暂存了； 第三次是 result = dg_jiecheng(2)*3,然后进入到了 dg_jiecheng(2),这行代码就被暂存了； 第四次是 result = dg_jiecheng(1)*2,然后进入到了 dg_jiecheng(1),这行代码就被暂存了； 此时，dg_jiecheng(1)的出口条件成立了，终于，能够执行return 1，这可是 return 语句第一次捞着执行。 第一次：return 1，返回的是1，返回到dg_jiecheng(2)这里： return =1*2 并且也执行return result；，返回1*2=2； 返回到dg_jiecheng(3)这里： return =2 并且也执行return result；，返回2*3=6； 返回到dg_jiecheng(4)这里： return =6 并且也执行return result；，返回6*4=24； 返回到dg_jiecheng(5)这里： return =24 并且也执行return result；，返回24*5=120； result = dg_jiecheng(n-1)* n; } return result; } 3、递归的优缺点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04ba742583e43c103f26fbff8b81ca60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b832b000103240c88d66bfb21a97df3c/" rel="bookmark">
			高德地图 AMap.xxx is not constructor 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AMap.xxx is not constructor 出现这个问题是map的插件还没有加载完。
解决办法:
在public文件夹下的index.html直接引入地图的sdk，也可以单独引入到组件下面。 在index.html中写入
&lt;script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.4&amp;key=你的key&amp;plugin=AMap.Geocoder&amp;plugin=AMap.Autocomplete&amp;plugin=AMap.PolyEditor"&gt;&lt;/script&gt; 需要引入的插件
&amp;plugin=AMap.Geocoder&amp;plugin=AMap.Autocomplete&amp;plugin=AMap.PolyEditor
或者 &lt;script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.15&amp;key='key自己申请'&amp;plugin=AMap.MouseTool,AMap.Geolocation,AMap.ControlBar,Map3D,AMap.DistrictSearch,AMap.RangingTool,AMap.PolyEditor"&gt;&lt;/script&gt; &amp;plugin=AMap.MouseTool,AMap.Geolocation,AMap.ControlBar,Map3D,AMap.DistrictSearch,AMap.RangingTool,AMap.PolyEditor
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbfe9586f82013f69b4ff7b7d23e0cfb/" rel="bookmark">
			数据库-mysql的text属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 属性对比 属性 一种特殊的字符串，存储单位为字节，有四种类型
TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT
不同的是可以存储的字符串的长度以及空间占用大小
使用时不需要指定长度，因为已经有默认最大可存储字节数，长度可变
这意味着，如果要存储字符，一个中文字符可能占用3个字节，存储选择哪种类型需要根据实际选择
对比 1.char长度固定，即每条数据占用等长字节空间，适合用在身份证号码、手机号码等。超过255字节只能用varchar或者text。
2.varchar可变长度，可以设置最大长度，适合已知最大可用长度的情况下，用在长度可变的属性。
3.text不设置长度，当不知道属性的最大长度时，适合用text，能用varchar的地方不用text。
按照查询速度：char &gt; varchar &gt; text最慢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/110a7df6fe40835b7c0dba1ea8559676/" rel="bookmark">
			Mybatis快速入门及遇到的问题（不支持发行版本）（黑马程序员Javaweb）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
快速入门：
1.创建一个Maven项目
2.在pom.xml文件中加入mybatis依赖、mysql驱动、junit单元测试坐标、添加slf4j日志api、添加logback-classic依赖、添加logback-core依赖
3.在sre/main下创建resources文件夹，创建mybatis-config.xml，该文件主要用来配置数据库连接信息。代码可从官网中复制粘贴即可
4.在resources下创建logback.xml日志文件
5.在resources下创建xxxMapper.xml文件。（此处以UserMapper.xml为例） 该文件为映射的sql语句
到此，resources配置文件完成 6.在src/main/java下创建com.itheima.poji.User的java类
7.创建测试函数。在src/main/java下创建com.itheima.MyBatisDemo的java类
8.1常见错误：不支持发行版本5
官方帮助文档：入门_MyBatis中文网
快速入门： 准备工作：mysql数据库 本篇文章数据库为mybatis，student表
1.创建一个Maven项目 2.在pom.xml文件&lt;dependency&gt;中加入mybatis依赖、mysql驱动、junit单元测试坐标、添加slf4j日志api、添加logback-classic依赖、添加logback-core依赖 &lt;dependencies&gt; &lt;!--mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit单元测试坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;junit &lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--添加slf4j日志api--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.20&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加logback-classic依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加logback-core依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.在sre/main下创建resources文件夹，创建mybatis-config.xml，该文件主要用来配置数据库连接信息。代码可从官网中复制粘贴即可 &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/110a7df6fe40835b7c0dba1ea8559676/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddfd2e3854e779df4d7e215ac517267b/" rel="bookmark">
			WEB安全-SQL注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：文章仅供大家参考学习
文章目录 前言一、SQL注入是什么？二、造成SQL注入的原因三、SQL注入原理四、修复建议五、靶场演示六、关键分析代码 前言 注意：文章仅供大家参考
网络安全中的SQL注入漏洞
一、SQL注入是什么？ 注意：个人理解
了解SQL注入之前，我们首先需要知道数据库的概念，数据库是企业或者程序开发人员用于存储数据的地方，数据库有相应的语句，语法，可以让我们对存储在数据库中的内容进行增删改查，渗透测试时，通过在网站上某些特殊位置，构造有特殊目的的数据库语句，从而可以得到我们想要的网站数据，包括像用户名，密码，甚至是用户和网站的敏感信息，假如得到管理员的账户信息，那危害可想而知，我们把这个构造特殊目的的数据库语句，并成功让服务器执行的过程就叫SQL注入；常见的数据库有MYSQL，ORACLE，SQL SERVER等
二、造成SQL注入的原因 web应用程序对用户输入数据的合法性没有判断或过滤不严格，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，以此欺骗数据库服务器执行非授权的任意查询，从而拿到自己想要的数据
三、SQL注入原理 网站一般都分为前端后端，前端主要是与用户进行交互的，用户在前端进行操作，后端根据用户的操作，执行相应的数据处理，并将数据返回到前端，前端再将数据渲染到页面，在后端进行数据处理的时候，一般需要使用SQL语句查询数据库，在页面数据交互的地方，攻击者构造sql语句，使web服务器执行恶意命令访问数据库，得到敏感数据，需要注意的是，参数用户可以控制，而且参数可以带入数据库查询，是sql注入的重要条件
四、修复建议 对用户输入的数据进行过滤，过滤sql语句的关键字，像select，union，order by，'，"，），from等在开发过程中，尽量使用预处理，或者使用最新的框架，来替换平常的sql语句安装相应的安全设备，如WAF（web应用防火墙） 五、靶场演示 靶场为sqli-lab 在这里给参数"id"传值，发现页面会显示用户名和密码，接下来我们探测注入点
我们给参数id传值 1’ 发现页面报错
再给参数id传值 1" 发现页面显示正常，可以验证这里是存在注入点， 闭合使用的是’
接下来判断有几个字段，并使用 " ’ --+ "来闭合SQL语句, 构造Payload id=1’ order by 4 --+, 发现报错，说明数据库中的字段个数不足4，小于4，继续向下测试
构造payload id=1’ order by 3 --+ 发现页面显示正常， 说明有3个字段
构造payload id=1’ and 1=2 union select 1,2,3 --+ 判断那个字段可以回显
经过上面判断，回显的字段，在2，3 字段，构造payload id=1’ and 1=2 union select 1,database(),@@datadir --+ 查看当前数据库，以及数据库的路径
经过上面测试，知道当前的数据库名字为security , 构造payload id=1’ and 1=2 union select 1,(select group_concat(table_name) from information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddfd2e3854e779df4d7e215ac517267b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2feaa35541866d68d4eb4a1202e6a1ed/" rel="bookmark">
			MySql中json类型数据的查询以及在MyBatis-Plus中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表结构和初始数据 新建表结构 CREATE TABLE `json_test` ( `id` int NOT NULL AUTO_INCREMENT, `roles` json DEFAULT NULL COMMENT '角色', `project` json DEFAULT NULL COMMENT '项目', PRIMARY KEY (`id`) ) ENGINE=InnoDB; 复制代码 初始数据 INSERT INTO `ctts_dev`.`json_test`(`id`, `roles`, `project`) VALUES (1, '[{"id": 10001, "name": "管理员"}, {"id": 10002, "name": "开发"}, {"id": 10003, "name": "测试"}]', '{"id": 11111, "name": "项目1"}'); INSERT INTO `ctts_dev`.`json_test`(`id`, `roles`, `project`) VALUES (2, '[{"id": 10002, "name": "开发"}]', '{"id": 22222, "name": "项目2"}'); INSERT INTO `ctts_dev`.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2feaa35541866d68d4eb4a1202e6a1ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d015b228e10bb628f30653934ca0742/" rel="bookmark">
			/lib64/libstdc&#43;&#43;.so.6: version `GLIBCXX_3.4.21‘ not found的解决办法及注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题出现： 在做一个项目的时候，我用到了我的虚拟机去跑一个程序，这时候出现/lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found的错误，这时候我去百度了一下，找了一些解决办法，我试着操作了一下，自己差点没有升天。（由于本人linux经验的问题，所以没有意识到问题的严重性，所以在此也提醒下同样的小伙伴）
解决办法1：（注：千万不要使用！） 我最开始找到的办法，这个办法解决了问题，差点连我本人也一起解决掉了。你如果被这种办法迫害过的话，我下面附加了解决这种问题的办法。
这里把一些重要的话说在前面，要是你要做一些修改系统文件的复杂操作的时候，在这之前记得给自己的虚拟机留下一份快照，以防万一，说不准你的虚拟机就坏掉了，说在前面也是怕一些人不看提示就操作，到时弄坏了自己的虚拟机。
具体解决过程：
这里出现的问题是因为我们的libstdc++.so.6.0.n(&lt;21)的库版本太旧了，我们要更换上版本高一点的库，版本不低于6.0.21就可以了。（/lib64下面使用find命令查看是否有这样的库：find ./ -name “libstdc++.so.6*”） 然后我们可以看见有如下两个文件：
libstdc++.so.6 libstdc++.so.6.0.xxx (&lt;21) 所以我们下载libstdc++.so.6.0.21（≧ 21都行）的动态库，将其放入到我们的lib64文件夹中。 rm -rf libstdc++.so.6 这时候我们删除掉原来的libstdc++.so.6（只是删除软链接），然后重新创建一个软连接到我们新下载的动态库（不要操作！不要操作！不要操作！） ln -s ./libstdc++.so.6.0.21 ./libstdc++.so.6 这时候我们重新打开之前的程序，这下运行成功了！ 这时候你可能觉得没有什么问题，当你关掉虚拟机，重新开机的时候，这时候你会发现你的虚拟机突然之间就进入不了登录界面了，就是一直黑屏。我当时一脸懵逼，我以为是我虚拟机只是突然抽风卡了，于是我又重启了几遍，还是老样子，到登录界面前就一直黑屏了。我想重装系统的话，我之前的文件啥的都丢失了，项目还得重新去编译，还有其他的东西也要编译，一套流程下来可不是说重装就重装的。而且我也没有保存当时的快照，真是惨痛的教训。
下面是遇到这种情况的解决办法：
切换到命令行窗口，或使用命令行方式启动系统 这是在你还能成功开机的情况下能进行的。上面只是我们的GUI桌面没法使用了，我们可以想办法打开我们的命令行窗口，毕竟我们linux本来就可以无GUI界面使用命令行窗口的方式启动。我使用的是centos7，我切换命令行界面的操作是ctrl+alt+F3（开机完成之后再按），其他系统你可以百度一下怎么切换到命令行界面。
将原本的文件恢复，将软链接链回之前的动态库 rm -rf libstdc++.so.6 ln -s ./libstdc++.so.6.0.19 ./libstdc++.so.6 假如你把libstdc++.so.6.0.19文件删除了的话，你可以重新去下载一个，使用①linux下载命令或者是②windows下载使用共享文件夹传进来，然后放入到/lib64文件夹中
完成上面的操作就可以重启了。重启之后就没有问题了。 解决办法2：(正确有效的方式) 我们使用LD_PRELOAD命令来设置我们运行时首先采用的动态库
这里我们下载好之前的libstdc++.so.6.0.21设置运行时首先采用的库（进入到需要运行的程序的目录下） export LD_PRELOAD="/lib64/libstdc++.so.6.0.21" 运行我们的程序运行完之后我们不使用了，使用unset LD_PRELOAD取消我们的应用 unset LD_PRELOAD 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b13de5a51517734a85463de36ce16e/" rel="bookmark">
			Unity Visual Scripting 常见操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建自定义节点 创建一个简单的自定义节点 1.创建c#脚本
using Unity.VisualScripting; using UnityEngine; public class MyNode : Unit { protected override void Definition() //The method to set what our node will be doing. { } } 2.配置项目设置以重新生成节点库
1）Edit &gt; Project Settings
2）选择Visual Scripting，点击Regenerate Nodes
3.打开一个Script Graph，添加你的节点
为你的节点添加port 1.修改c#脚本
using Unity.VisualScripting; using UnityEngine; using System; [UnitCategory("FirstLevel/SecondLevel")] public class MyNode : Unit { public ControlInput inputTrigger; public ControlOutput outputTrigger; [DoNotSerialize] public ValueInput myValueA; [DoNotSerialize] public ValueInput myValueB; [DoNotSerialize] public ValueOutput result; private string resultValue; protected override void Definition() //The method to set what our node will be doing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5b13de5a51517734a85463de36ce16e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/719abc76757ee51a5148cb27c11f0526/" rel="bookmark">
			UDP（数据报通信）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.和TCP的区别
（1）UDP不需要再一个端口上侦听，等待连接。只需生成一个端口描述符，把这个端口描述符绑定到本地地址就可以。
**【重要】UDP数据报通信流程** 2.socket函数说明
3.bind（）函数
4.connect()
connect()系统调用由客户端调用，它的用法如下：
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int connect(int sockfd,struct sockaddr *serv_addr,int addrlen);
4.sendto 和 recvfrom函数
5.close（）和shutdown（）函数
下面是代码示例：
客户端代码：
服务端代码：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd1825968ee8dfcdc8510fed04bc80b/" rel="bookmark">
			Django pytcharm社区版创建django项目及虚拟环境下configuration配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、注册app 将创建的app写入到配置文件settings.py中。
写入语句，本例语句为：
'app01.apps.App01Config' 如图所示：
二、编写URL与函数对应关系 1.在urls.py文件中创建页面与函数映射 （1）导入views
（2）创建映射
2.编写函数 三、启动项目 1.命令行启动 python manage.py runserver 2.pycharm启动 点击右上角绿色的箭头启动manage.py并运行服务器。
这里遇到了一点问题⭐：自己的python是在虚拟环境下运行的，没有自动创建解释器，因此需要手动的修改，方法如下：
转到编辑配置（运行/调试菜单）–&gt;pycharm界面（如上图）左侧目录里在脚本路径中提供manage.py位置，–&gt;修改manage.py 的run configuration 里Parameters为runserver–&gt;现在可以使用pycharm运行和调试django项目。
四、启动结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def98590d1c653fb51707efe8a677f75/" rel="bookmark">
			宝塔面板的卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过命令进行卸载，我们要登录SSH执行命令，命令如下：
wget http://download.bt.cn/install/bt-uninstall.sh sh bt-uninstall.sh 当输入第二个命令的时候会有两个提示：
卸载宝塔卸载宝塔及运行环境 注：输入"1"只单纯性的卸载宝塔面板；输入"2"就会卸载宝塔面板和运行环境。
因为今天是给大家做的宝塔面板卸载教程，我这里输入的"2"，大家按需进行卸载，如果输入"2"就会影响网站以及数据库等信息，请谨慎操作，如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db86c5625dc230420af4007ee289937a/" rel="bookmark">
			Navicat报错：1045-Access denied for user root@localhost(using passwordYES)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 事情是这样的，昨天我在调试导师给的一个oython的项目，这个项目是没有文档的，所以数据库那些信息我需要自己去匹配去创建，于是我将这个项目连接到了我本地的数据库，来进行调试，在我连接上数据库后，运行了这个Flask项目，结果数据库就再也打不开了，显示报错：
1045-Access denied for user root@localhost(using password:YES)。为了让遇到同样问题的朋友们避开这个坑，我将解决的过程记录下来。
正文： 在终端上面遇到这个问题的小伙伴大概率都是忘记了密码，但是遇到Navicat打不开数据库的，大概率是发生了什么错误，细节我也不清楚，我是这么解决的：
首先以管理员的身份打开终端，然后打开数据库：
然后输入指令：mysql -u root -p
再键入你的密码。然后是输入一行修改你目前密码的命令：
Ps：这个地方一定要尝试！！！刚开始我也不相信修改了密码后就可以了，觉得这个问题应该要从根源上解决，但是事实证明改密码真的有效，我就是改完密码后又可以用Navicat登陆进去的。
mysql8.0前的版本修改密码的命令：
update mysql.user set authentication_string=password(“新密码”) where user=“root”;
mysql8.0以后的版本修改密码的命令：
ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘新密码’
如何看自己的mysql是什么版本的呢，可以从Navicat上看：
当然如果按照相应版本的指令无效的话，也试一下另一条指令。
在输入指令后，退出mysql，然后用新密码登录一次就可以了：
如果不行的话，需要再看看其他博主的文章，因为这个报错，真的是很突然，解决的也很突然。。。
总结： 在遇到这类问题，可以先从最简单的修改密码开始尝试，如果修改数据库密码都解决不了的话，再去寻找进一步的方法，至少排除了一种可能。如果大家有更好的解决方法，还请大家在下方评论或者私信给我，感激不尽！???
最后 深知大多数初中级Java工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则近万的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《Java开发全套学习资料》送给大家，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
小编已加密：aHR0cHM6Ly9kb2NzLnFxLmNvbS9kb2MvRFVrVm9aSGxQZUVsTlkwUnc==出于安全原因，我们把网站通过base64编码了，大家可以通过base64解码把网址获取下来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f37a8edeb285ccddd7031f5f6d589a2/" rel="bookmark">
			EasyTouch☀️ 五、实现限制物体缩放大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
📢 本章效果展示
🟥 限制物体缩放大小
1️⃣ 修改QuickPinch缩放脚本
2️⃣ 挂载缩放限制脚本
📢 本章效果展示 EasyTouch中的缩放，会使得物体缩放到负数，物体比例到0后接下来会变大。
因此我们要限制最小的缩放比例，避免出现这个问题。
🟥 限制物体缩放大小 1️⃣ 修改QuickPinch缩放脚本 盒子上配置好QuickPinch缩放脚本，该脚本修改内容如下：
当前缩放为判断x轴比例。各位可根据需要修改
void On_Pinch(Gesture gesture) { if (actionTriggering == ActionTiggering.InProgress &amp;&amp; pinchDirection == ActionPinchDirection.All) { if (GetComponent&lt;ScaleLimit&gt;()) { if ( ((transform.localScale.x &gt;= GetComponent&lt;ScaleLimit&gt;().sx_min) &amp;&amp; (transform.localScale.x &lt;= GetComponent&lt;ScaleLimit&gt;().sx_max)) || ((transform.localScale.x &lt; GetComponent&lt;ScaleLimit&gt;().sx_min) &amp;&amp; gesture.deltaPinch &gt; 0) || ((transform.localScale.x &gt; GetComponent&lt;ScaleLimit&gt;().sx_max) &amp;&amp; gesture.deltaPinch &lt; 0) ) DoAction(gesture); } else DoAction(gesture); } } 2️⃣ 挂载缩放限制脚本 脚本内容如下，并设置好限制的缩放大小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f37a8edeb285ccddd7031f5f6d589a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b646fa560171eb72e0dd9592a2130812/" rel="bookmark">
			两个单链表求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：给定两个单链表，求出单链表中元素组成的数字，两个单链表分别可以生成两个数字，求着两个数字的和。链表的头到尾对应数字的高位到低位。
思路：
1、考虑到链表的头为数字高位，且两数相加应该从低位开始运算，所以用栈来存储链表的数字
2、定义两个栈s1和s2分别用来存储两个链表的数据
3、分别利用while循环将两个链表存储到栈中
4、考虑到两数相加可能会大于10，产生进位，所以设置变量cnt表示进位，并定义返回值指针
5、两个栈不同时为空，就分别取出两个栈的栈顶元素相加+进位cnt；
6、定义一个新的链表节点用来存储求和数值的个位，即sum%10；
7、将新的链表节点作为返回结果的链表的最后一个节点，即temp-&gt;next=res;
8、将返回指针前移，即res=temp;
9、链表的节点值加完后，cnt不为0.则新建链表节点来存储cnt，并将其链接到res链表，res前移。
10、直到循环结束，将res输出
#include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; struct ListNode { int value; ListNode* next; ListNode(int x) :value(x), next(NULL) {} }; ListNode* addList(ListNode* head1, ListNode* head2) { stack&lt;int&gt; s1, s2;//定义两个栈来存储链表的数值 while (head1)//将链表1入栈 { s1.push(head1-&gt;value); head1 = head1-&gt;next; } while (head2)//将链表2入栈 { s2.push(head2-&gt;value); head2 = head2-&gt;next; } int cnt = 0;//定义进位的变量 ListNode* res = nullptr;//定义返回链表的指针； while (!s1.empty() || !s2.empty())//两个栈不同时为空进入循环 { int x1 = s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b646fa560171eb72e0dd9592a2130812/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed4aa12fed76b4797b677dfbdd1daa4/" rel="bookmark">
			YOLO_v1讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一：YOLO_v1的出现二：网络模型三：训练阶段step1：训练数据的制作step2：损失函数 四：测试阶段step1：输入原图step2：计算每个bbox的类别得分 五：YOLO_v1的不足 一：YOLO_v1的出现 YOLO_v1的出现，打破了Faster R-CNN的一统图像检测江山的格局，首次提出了one-stage的图像检测模型，真正实现了end-to-end，其具体优势如下：
快，非常的快，基础版YOLO每秒可以处理45帧；快速版能达到155帧每秒，绝对是开挂的速度准确率高，map达到63.4 map易优化，整体上是一个单阶段网络，很容易进行端到端的优化 二：网络模型 通过上面结构图，我们可以很直接的看出yolov1的网络结构，用了一系列的卷积层、最大池化下载样层以及全连接层，在这里说明一下全连接层。
通过第一个Conn.Layer时，需要进行三个处理：①transpose处理。不一定要进行②flateen。因为要和全连接层连接，所以要进行展平处理。③fc(4096)。通过一个节点个数为4096的全连接层进行连接。此时得到一个4096维的向量。
通过第二个Conn.Layer时，需要进行两个处理：①通过一个节点个数为1470的全连接层。因为要得到一个7×7×30的特征矩阵，所以需要1470。②进行reshape处理。把向量调整为7×7×30的矩阵。
可见，YOLOv1的网络结构还是比较简单的，因为它的关键部分在于它的逻辑，就是它的输入输出的映射和损失函数设计，下面我将从训练阶段和测试阶段进行剖析：
三：训练阶段 step1：训练数据的制作 标签为007732.jpg 341 217 487 375 8 114 209 183 298 8 237 110 320 176 19，其中8表示chair，19表示tvmonitor。
下面演示如何将这些坐标和类别信息转化为YOLO的target张量（7×7×30）：
首先，7×7好理解，就是对一张图片，切成了49个cell，我们对其中一个cell的30个元素进行分析，如下图：
如果该cell中有物体（可能有多个物体），那么x1,y1,w1,h1=x2,y2,w2,h2=cell中程序遍历到的最后一个物体的坐标和长宽，confidence1=confidence2=1，类别就是独热编码。
如果该cell中没有物体，那么30个元素都是0。
def encode(self, boxes, labels): """ Encode box coordinates and class labels as one target tensor. Args: boxes: (tensor) [[x1, y1, x2, y2]_obj1, ...], normalized from 0.0 to 1.0 w.r.t. image width/height. labels: (tensor) [c_obj1, c_obj2, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ed4aa12fed76b4797b677dfbdd1daa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c8435e1b7728a03cfa5efb6b6b8c6c/" rel="bookmark">
			路由跳转的两种方式及动态创建路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跳转路由的方式,有两种 1.声明导航 1) 跳转 router-link 是 vue -router提供的一个全局组件 router-link 实质上最终会渲染成一个a标签,to属性等价于 href属性(to不需要) router-link 提供了声明导航高亮的功能(字典类名) 2) 传参 在router-link 上的to属性传值,方法如下: (方式一) to=/path?参数名 = 值 例:&lt;router-link to="/about?name=小明"&gt;&lt;/router-link&gt; 获取陆游的参数: this.$route.query.参数名 例:this.$route.query.name (方式二) to="/path/值"(需要在路由规则里配置: /path/:参数名) 例: to="/path/小豆芽" 配置: path: "/about/:username" 获取参数 this.$route.params.参数名 例:this.$route.params.username 2.编程式导航 用js代码来进行跳转 语法:path 或者name任选一个 $router 和 $route 的区别 $router: 是路由的操作对象(比喻成路由器.装着所有的路由),跳转的时候用 $route: 是路由的信息对象(比喻成一个路由,存储这当前路由中的所有信息),获取路由参数的时候用 跳转的具体方式: 语法: path 或者 name 人选一个 this.$router.push({name:"路由中配置的文件",query:{name="值"}}) 接收参数: 在对应的页面 let name_nex = this.$route.query.name 3.区别(重点!!!) 跳转方式的区别: 1.path和name的相同点: 都可以实现页面得切换(路由跳转) 都需要在路由中提前配置好. 声明式导航和编程式导航都可以使用 不同点: path的值是会变得,例如: 动态路由/path/:username(路径) name的值是不会变的,前缀不需要带 /,只是一个名字(字符串) *** 使用path跳转路由时,path会忽略params(参数为undefined),所以path和params不能一起使用 推荐使用name和query的方式来实现路由跳转 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87c8435e1b7728a03cfa5efb6b6b8c6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7284a9167e47f4ba6eebc81a66cb54ed/" rel="bookmark">
			Makefile篇---动态库编译和测试动态库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Makefile篇---动态库编译和测试动态库 编写code非主目录SoTest.hSoTest.cpptest.cpp 编译动态库测试动态库主目录SoTest.hmain.cpp 编写code 结构如下：
非主目录 （下面三个代码 SoTest.h SoTest.cpp test.cpp 是在001的文件夹下，非主目录）
SoTest.h #ifndef INC_0303_SOTEST_H #define INC_0303_SOTEST_H class SoTest { public: void func1(); virtual void func2(); virtual void func3()=0; }; #endif //INC_0303_SOTEST_H SoTest.cpp #include&lt;iostream&gt; #include "SoTest.h" void SoTest::func1(){ printf("func1\n"); }; void SoTest::func2(){ printf("func2\n"); }; test.cpp #include &lt;iostream&gt; #include "SoTest.h" class Test:public SoTest{ public: void func2(){ printf("test-func2\n"); } void func3(){ printf("test-func3\n"); } }; int main() { Test t1; t1.func1(); t1.func2(); t1.func3(); return 0; } 编译动态库 g++ -shared -fPIC SoTest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7284a9167e47f4ba6eebc81a66cb54ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1911a331f030c320d7ee95d51aa8a01/" rel="bookmark">
			Pico Neo 3教程☀️ 三、SDK 的进阶功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🟥 场景切换渐变效果🟧 Tracking Origin：关于摄像头位置🟨 设置屏幕刷新率🟩 眼球追踪🟦 注视点渲染1️⃣ 如何设置注视点渲染2️⃣ 注视点渲染效果展示 🟪 MultiView：单摄像机渲染🟫 快速编译工具 🟥 场景切换渐变效果 SDK提供场景切换渐变效果，开启该选项，便可开启渐变功能。
设置渐变效果：
当勾选该选项时，SDK会自动给 Camera 添加 PXR_ScreenFade 脚本。
FadeTime：持续时间（时间单位为秒）FadeColor：渐变的颜色 🟧 Tracking Origin：关于摄像头位置 SDK提供设置“追踪原点类型”的功能，默认为Floor模式。
当设置为Floor模式时，将根据设备检测到地面的高度来计算追踪原点（该模式需要设备支持地面检测功能（e.g. Neo 3））。当设置为Device模式时，为通常理解的Eye模式，不会将根据设备检测到地面的高度来计算追踪原点。当设置为Tracking Reference模式时，为通常理解的Stage模式，校准的时候不会重置场景正方向。
建议：
Device：适合坐姿体验的应用Floor：适合站立式体验的应用Tracking Reference：适合想要用户在体验期间保持固定空间和方位的场景，但是并非绝对。
Camera Y Offset： 是当选择Device的时候会在Camera的Y方向增加的偏移量。当选择Floor或者Tracking Reference的时候此offset值无效。
🟨 设置屏幕刷新率 SDK提供配置屏幕刷新率的功能，通过设置Display Refresh Rates相关选项来进行配置，配置方式如下:
Default：系统默认RefreshRate72：刷新率上限72hzRefreshRate90：刷新率上限90hzRefreshRate120：刷新率上限120hz 🟩 眼球追踪 Pico Neo3 Pro设备支持眼球追踪，眼球追踪可以追踪眼球注视位置，配合注视点渲染可以优化渲染性能。勾选Eye Tracking即可。
🟦 注视点渲染 1️⃣ 如何设置注视点渲染 注视点渲染（Foveation Rendering）可以优化VR场景的渲染，该技术通过为视野中心提供全分辨率（无损），降低周边视野（人眼焦点区域之外）分辨率的方式来达到优化渲染的目的。
静态注视点渲染（FFR）是指将视野焦点固定在视口中心位置，实现从中心向周围逐渐降低清晰度的效果。开启和配置“Foveated Rendering”选项如下图所示。
动态注视点渲染（DFR）是指视野焦点会随着视线移动，除了开启和配置“Foveated Rendering”选项，还需配合 Neo3 Pro系列（支持EyeTracking的设备）实现。
在Foveation Level中，选择非None的等级，即可实现注视点渲染功能，无需开发者额外的编码。
2️⃣ 注视点渲染效果展示 Low级别，放大10倍后右下角截图：图像稍微模糊 Med级别，放大10倍后右下角截图 ：图像有些模糊 High级别，放大10倍后右下角截图 ：图像更模糊了 🟪 MultiView：单摄像机渲染 SDK基于Unity的SinglePass的原生功能，开发了MultiView功能。即用一个摄像机实现立体渲染。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1911a331f030c320d7ee95d51aa8a01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eddbde6dc08b9c6671143ae3babb38f3/" rel="bookmark">
			nacos部署到centos无法访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前最新版本是nacos2.0.3，这一版本是有grpc通信，所以当我部署在centos以后，开通了8848端口，网页可以访问，但是client还是无法连接，报
NacosException: Client not connected,current status:STARTING 经过一方努力，找到了是还需要开通9848端口
参考
https://blog.csdn.net/qq_46122292/article/details/125301563
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c364fccf0ee5ce6e5271183e27188ebb/" rel="bookmark">
			GitHub上标星120K!Alibaba官网发布了这份Java全栈知识体系手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java作为当下最热门的编程语言，刷新了编程圈的全新认知，也导致了现在很多一线互联网大厂对程序员的要求提高了一个大的台阶！
但是还是有很多的程序员对整个java的体系只停留在学习中的片段，殊不知其内容已经发生了翻天覆地的变化，为了帮助大家完成这一难题，小编特意给大家找到了一份java全栈知识体系手册分享给大家
内容展示： 这里先给大家展示本书的内容，下面会给大家展示知识体系，需要获取到的小伙伴可以直接转发+关注后私信（学习）免费获取！
全栈知识体系总览： java基础
数据结构与算法
数据库
方法论
部署和工具
开发基础和框架
项目学习
微服务设计
架构与系统设计
需要获取的小伙伴可以直接转发+关注后私信（学习）免费获取篇！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/97/">«</a>
	<span class="pagination__item pagination__item--current">98/220</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/99/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>