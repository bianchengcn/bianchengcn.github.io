<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于Redis GEO实现加油站搜索附近车辆 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于Redis GEO实现加油站搜索附近车辆" />
<meta property="og:description" content="声明：以下部分图片来源于网上
业务背景 现在越来越多的互联网应用都在提供基于地理位置的服务，假设现在有这样一个业务场景，加油站想要知道附近的车辆信息，那么我们该怎么做？这里主要涉及两个步骤，一个是对应的应用要保存和更新车辆实时的上报信息数据，二就是我们要根据加油站的信息来查询它附近的车辆信息。
这里我们首先忽略车辆信息上报这个阶段，因为这涉及到车子与加油站业务对接的相关内容。那么我们来看一下第二个搜索阶段，也就是今天要说的，根据加油站的地理位置信息（这里指的是经纬度）和给定的距离信息来搜索出周边满足条件的车辆，然后根据需要可以进一步按照距离远近进行排序或者限制返回的数量。
2.探索-解决方案选择 在看到搜索这个词的时候，首先意识到这是个对性能有要求的查询，无论是读或者还是写数据，都是要求非常快速的。并且车辆这个数据应该是蛮大的，因为车辆数和车辆的实时数据就是一个大批量的数据了。所以想到了与缓存相关的技术redis，它的读写非常快速，读的速度能达到11万次每秒，写的速度能达到8.1万次每秒。
（1）模糊匹配-keys 使用redis的keys命令，它是遍历算法，时间复杂度是O(N)。由于redis是单线程的，可能会阻塞进程，导致Redis服务卡顿，严重情况下，会导致宕机的可能。在实际生产中是不能使用的，因此不予采用。
（2）扫描-scan 使用redis的scan命令，它的时间复杂度虽然也是O(N)，但是它是通过游标分步进行的，不会阻塞线程，还提供了limit参数，可以控制每次返回结果的最大条数。然而通过实际测试，在达到一定量的数据中查找时，还是挺耗时的，这个时间大概在2～5s，无法满足我们这个业务需求。
（3）GEO 使用redis的扩展类型GEO，它的时间复杂度是O(logN)，通过实际性能测试，百万级数据查询可以在极短的时间内返回。采用此方案，下面主要就是介绍这个方案。
3. 经纬度 这里简单先介绍一下经纬度的概念，将一张世界地图铺开，以赤道为界将地球分成南北，以本初子午线将地球分成东西。赤道和本初子午线都是0度；以赤道0度开始，向上和向下分别分出90度，南极和北极分别为南纬90度和北纬90度，南极到北极的跨度是（-90,90），其中赤道到南极称为南纬，赤道到北极称为北纬；从本初子午线0度开始，向左和向右分别分出180度，跨度是（-180,180），其中本初子午线向左称为西经，本初子午线向右称为东经
坐标限制:
Redis有效的经度从-180度到180度。有效的纬度从-85.05112878度到85.05112878度。当坐标位置超出上述指定范围时，该命令将会返回一个错误。中国的经度范围:73°33′E至135°05′E。纬度范围:3°51′N至53°33′N。
4. GEO算法 （1）geo算法介绍 Geo算法是业界比较常用的地理位置排序算法，Redis也采用该算法，它是将二维的经纬度数据映射到一维的整数，这样所有的元素都会被挂在到一条线上，距离相近的二维坐标映射到一维后的点之间距离也会很近，当加油站查找附近的车辆时候，首先将目标位置映射到这条线上，然后在这个一维的线上获取附近的点就可以了。
下图展示了天安门 9 个区域的 geohash 字符串，每个字符串表示一个矩形区域（使用一维数据来表示二维坐标）。
（2）分块思想： Geo算法将整个地球看成一个二维平面，然后划分成了一系列正方形的方格，就像围棋棋盘，所有地图元素坐标都被放置于唯一的方格中，方格越小，坐标越精确，随后对这些方格进行整数编码，越是靠近的方格编码越接近。对于一个完整的二维空间，我们可以用二分的思想将它均匀划分。也就是在水平方向上一分为二，在垂直方向上也一分为二。这样一个空间就会被均匀地划分为四个子空间，这四个子空间，我们可以用两个比特位来编号。在水平方向上，我们用 0 来表示左边的区域，用 1 来表示右边的区域；在垂直方向上，我们用 0 来表示下面的区域，用 1 来表示上面的区域。
应用上述的分块思想，对某块区域进行编码：
这种区域编码的方式有 2 个优点：
a.区域有层次关系：如果两个区域的前缀是相同的，说明它们属于同一个大区域；
b.区域编码带有分割意义：奇数位的编号代表了垂直切分，偶数位的编号代表了水平切分，这会方便区域编码的计算（奇偶位是从右边以第 0 位开始数起的）。
5.GeoHash编码原理 （1）编码原理 GeoHash是一种地址编码方法，基本原理就是“二分区间，区间编码”。当我们要对一组经纬度进行 GeoHash 编码时，我们要先对经度和纬度分别编码，然后再把经纬度各自的编码组合成一个最终编码。而后base32后成为一个短字符串。
（2）编码过程 以经纬度(116.397457,39.909181)为例计算geohash
a.经纬度分别编码
纬度 39.909181 编码为:1011100011 00001 00
同理，地球经度区间是[-180,180]，
经度116.397457编码为:1101001011 00010 110
b.合并：偶数位放经度，奇数位放纬度，结果如下：
将 11100 11101 0010001111 00000 01001 10100 转成十进制，分别是：28、29、4、15、0、9、20 base32的编码(0-9、a-z,去掉a、i、l、o四个字母)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8bbaa2addf2486a1d3f159705b288936/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-14T20:20:36+08:00" />
<meta property="article:modified_time" content="2023-03-14T20:20:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于Redis GEO实现加油站搜索附近车辆</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;"><span class="kdocs-italic" style="font-style:italic;">声明：以下部分图片来源于网上</span></span></p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h2><span class="kdocs-bold" style="font-weight:bold;">业务背景</span></h2></li></ol> 
 <p style="text-indent:1.4em;text-align:left;"> 现在越来越多的互联网应用都在提供基于地理位置的服务，假设现在有这样一个业务场景，加油站想要知道附近的车辆信息，那么我们该怎么做？这里主要涉及两个步骤，一个是对应的应用要保存和更新车辆实时的上报信息数据，二就是我们要根据加油站的信息来查询它附近的车辆信息。</p> 
 <p style="text-indent:1.4em;text-align:left;"> 这里我们首先忽略车辆信息上报这个阶段，因为这涉及到车子与加油站业务对接的相关内容。那么我们来看一下第二个搜索阶段，也就是今天要说的，根据加油站的地理位置信息（这里指的是经纬度）和给定的距离信息来搜索出周边满足条件的车辆，然后根据需要可以进一步按照距离远近进行排序或者限制返回的数量。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:460px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:41.52174%;height:0;"> 
    <img src="https://images2.imgbox.com/ba/2f/yr5FXkT6_o.png" style="margin-left:;display:block;width:460px;margin-top:-41.52174%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h2 style=""><span class="kdocs-bold" style="font-weight:bold;">2.探索-解决方案选择</span></h2> 
 <p style="text-align:left;"> 在看到搜索这个词的时候，首先意识到这是个对性能有要求的查询，无论是读或者还是写数据，都是要求非常快速的。并且车辆这个数据应该是蛮大的，因为车辆数和车辆的实时数据就是一个大批量的数据了。所以想到了与缓存相关的技术redis，它的读写非常快速，读的速度能达到11万次每秒，写的速度能达到8.1万次每秒。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:517px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:39.26499%;height:0;"> 
    <img src="https://images2.imgbox.com/de/07/xJXog6sV_o.png" style="margin-left:;display:block;width:517px;margin-top:-39.26499%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h3 style="text-align:left;">（1）模糊匹配-keys</h3> 
 <p style="text-align:left;"> 使用redis的keys命令，它是遍历算法，时间复杂度是O(N)。由于redis是单线程的，可能会阻塞进程，导致Redis服务卡顿，严重情况下，会导致宕机的可能。在实际生产中是不能使用的，因此不予采用。</p> 
 <h3 style="text-align:left;">（2）扫描-scan</h3> 
 <p style=""> 使用redis的scan命令，它的时间复杂度虽然也是O(N)，但是它是通过游标分步进行的，不会阻塞线程，还提供了limit参数，可以控制每次返回结果的最大条数。然而通过实际测试，在达到一定量的数据中查找时，还是挺耗时的，这个时间大概在2～5s，无法满足我们这个业务需求。</p> 
 <h3 style="text-align:left;">（3）GEO</h3> 
 <p style=""> 使用redis的扩展类型GEO，它的时间复杂度是O(logN)，通过实际性能测试，百万级数据查询可以在极短的时间内返回。采用此方案，下面主要就是介绍这个方案。</p> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3. 经纬度</span></h2> 
 <p style=""> 这里简单先介绍一下经纬度的概念，将一张世界地图铺开，以赤道为界将地球分成南北，以本初子午线将地球分成东西。赤道和本初子午线都是0度；以赤道0度开始，向上和向下分别分出90度，南极和北极分别为南纬90度和北纬90度，南极到北极的跨度是（-90,90），其中赤道到南极称为南纬，赤道到北极称为北纬；从本初子午线0度开始，向左和向右分别分出180度，跨度是（-180,180），其中本初子午线向左称为西经，本初子午线向右称为东经</p> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">坐标限制:</span></p> 
 <p style="text-indent:1.4em;text-align:left;"> Redis有效的经度从-180度到180度。有效的纬度从-85.05112878度到85.05112878度。当坐标位置超出上述指定范围时，该命令将会返回一个错误。中国的经度范围:73°33′E至135°05′E。纬度范围:3°51′N至53°33′N。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:695px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:48.20144%;height:0;"> 
    <img src="https://images2.imgbox.com/56/41/sBtT4Qeo_o.png" style="margin-left:;display:block;width:695px;margin-top:-48.20144%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h2 style=""><span class="kdocs-bold" style="font-weight:bold;">4. GEO算法</span></h2> 
 <h3 style="text-align:left;">（1）geo算法介绍</h3> 
 <p style="text-align:left;"> Geo算法是业界比较常用的地理位置排序算法，Redis也采用该算法，它是将二维的经纬度数据映射到一维的整数，这样所有的元素都会被挂在到一条线上，距离相近的二维坐标映射到一维后的点之间距离也会很近，当加油站查找附近的车辆时候，首先将目标位置映射到这条线上，然后在这个一维的线上获取附近的点就可以了。</p> 
 <p style="text-indent:1.4em;text-align:left;"> 下图展示了天安门 9 个区域的 geohash 字符串，每个字符串表示一个矩形区域（使用一维数据来表示二维坐标）。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:390px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:110.0%;height:0;"> 
    <img src="https://images2.imgbox.com/da/9b/0uhIaTNI_o.png" style="margin-left:;display:block;width:390px;margin-top:-110.0%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="text-align:null;">（2）分块思想：</h3> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:462px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:101.731606%;height:0;"> 
    <img src="https://images2.imgbox.com/ee/dc/XKuDl3Yf_o.png" style="margin-left:;display:block;width:462px;margin-top:-101.731606%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="text-align:left;"> Geo算法将整个地球看成一个二维平面，然后划分成了一系列正方形的方格，就像围棋棋盘，所有地图元素坐标都被放置于唯一的方格中，方格越小，坐标越精确，随后对这些方格进行整数编码，越是靠近的方格编码越接近。对于一个完整的二维空间，我们可以用二分的思想将它均匀划分。也就是在水平方向上一分为二，在垂直方向上也一分为二。这样一个空间就会被均匀地划分为四个子空间，这四个子空间，我们可以用两个比特位来编号。在水平方向上，我们用 0 来表示左边的区域，用 1 来表示右边的区域；在垂直方向上，我们用 0 来表示下面的区域，用 1 来表示上面的区域。</p> 
 <p style="text-indent:1.4em;text-align:left;"> 应用上述的分块思想，对某块区域进行编码：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:667px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:44.527737%;height:0;"> 
    <img src="https://images2.imgbox.com/6a/c1/9AkHlkTD_o.png" style="margin-left:;display:block;width:667px;margin-top:-44.527737%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">这种区域编码的方式有 2 个优点：</span></p> 
 <p style="text-align:left;">a.区域有层次关系：如果两个区域的前缀是相同的，说明它们属于同一个大区域；</p> 
 <p style="text-align:left;">b.区域编码带有分割意义：奇数位的编号代表了垂直切分，偶数位的编号代表了水平切分，这会方便区域编码的计算（奇偶位是从右边以第 0 位开始数起的）。</p> 
 <h2 style=""><span class="kdocs-bold" style="font-weight:bold;">5.GeoHash编码原理</span></h2> 
 <h3 style="text-align:left;">（1）编码原理</h3> 
 <p style="text-align:left;"> GeoHash是一种地址编码方法，基本原理就是“二分区间，区间编码”。当我们要对一组经纬度进行 GeoHash 编码时，我们要先对经度和纬度分别编码，然后再把经纬度各自的编码组合成一个最终编码。而后base32后成为一个短字符串。</p> 
 <h3 style="text-align:left;">（2）编码过程</h3> 
 <p style="text-align:left;"> 以经纬度(116.397457,39.909181)为例计算geohash</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:483px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:124.2236%;height:0;"> 
    <img src="https://images2.imgbox.com/73/1f/7qaDX4vl_o.png" style="margin-left:;display:block;width:483px;margin-top:-124.2236%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">a.经纬度分别编码</span></p> 
 <p style="text-align:left;">纬度 39.909181 编码为:1011100011 00001 00</p> 
 <p style="text-align:left;">同理，地球经度区间是[-180,180]，</p> 
 <p style="text-align:left;">经度116.397457编码为:1101001011 00010 110</p> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">b.合并：偶数位放经度，奇数位放纬度，结果如下</span>：</p> 
 <p style="text-align:left;">将 11100 11101 0010001111 00000 01001 10100 转成十进制，分别是：28、29、4、15、0、9、20 </p> 
 <p style="text-align:left;">base32的编码(0-9、a-z,去掉a、i、l、o四个字母)</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:664px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:21.686747%;height:0;"> 
    <img src="https://images2.imgbox.com/57/de/WC1VnBt1_o.png" style="margin-left:;display:block;width:664px;margin-top:-21.686747%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h3 style="text-align:left;">（3）经纬度距离换算（精度）</h3> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">在纬度相等的情况下：</span></p> 
 <p style="text-align:left;">经度每隔0.00001度，距离相差约1米；每隔0.0001度，距离相差约10米；每隔0.001度，距离相差约100米；每隔0.01度，距离相差约1000米；每隔0.1度，距离相差约10000米。</p> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">在经度相等的情况下：</span></p> 
 <p style="text-align:left;">纬度每隔0.00001度，距离相差约1.1米；每隔0.0001度，距离相差约11米；每隔0.001度，距离相差约111米；每隔0.01度，距离相差约1113米；每隔0.1度，距离相差约11132米。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:483px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:97.10145%;height:0;"> 
    <img src="https://images2.imgbox.com/8b/51/84Y1MZs9_o.png" style="margin-left:;display:block;width:483px;margin-top:-97.10145%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;"> 6.ZSET数据结构（简单介绍）</span></h2> 
 <p style="text-align:null;"> GEO 类型的底层数据结构就是用 Sorted Set 来实现的， GEO 类型是把经纬度所在的区间编码作为 Sorted Set 中元素的权重分数，把和经纬度相关的车辆 VIN码作为 Sorted Set 中元素本身的值保存下来，这样相邻经纬度的查询就可以通过编码值的大小范围查询来实现。如下图， Sorted Set的value值就是用户的ID ，score值就是GeoHash的52位整数值，在redis中使用的时候，通过Sorted Set的score排序就可以得到附近的元素，然后在将score值还原成经纬度坐标信息。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:559px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:51.699463%;height:0;"> 
    <img src="https://images2.imgbox.com/40/e3/DJnk9nkn_o.png" style="margin-left:;display:block;width:559px;margin-top:-51.699463%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;text-align:left;">Sorted Set使用了两种不同的存储结构，分别是 zipList（压缩列表）和 skipList（跳跃列表）。</p> 
 <h3 style="text-align:left;">（1）zipList（压缩列表）</h3> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;"> </span>当 zset 满足以下条件时使用压缩列表：成员的数量小于128个；每个成员的字符串长度都小于 64 个字节。下图展示的是ziplist的数据结构</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:957px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:32.079414%;height:0;"> 
    <img src="https://images2.imgbox.com/fa/80/j0XHLh75_o.png" style="margin-left:;display:block;width:957px;margin-top:-32.079414%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">（2）skipList（跳跃列表）</span></h3> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;"> </span>当有序集合不满足使用压缩列表的条件时，就会使用 skipList 结构来存储数据。对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低。如下图所示，这样我们就需要使用跳表（使用多级索引）来解决。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:726px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:62.121212%;height:0;"> 
    <img src="https://images2.imgbox.com/7e/bc/I57fRFvl_o.png" style="margin-left:;display:block;width:726px;margin-top:-62.121212%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/259df79032daa3da783d22cd7cc72403/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">蓝桥杯 算法训练 Python</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff39a54412c8ae19960ecc3738c8dec5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JAVA的安装与配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>