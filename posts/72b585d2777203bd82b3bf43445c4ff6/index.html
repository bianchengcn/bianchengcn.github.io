<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【字节跳动青训营】- 如何写好JS？ - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【字节跳动青训营】- 如何写好JS？" />
<meta property="og:description" content="各司其职 HTML/CSS/JS各司其职
应当避免不必要的由JS直接操作样式
可以用class来表示状态
纯展示类交互寻求零JS方案（可以用CSS实现）
例如：实现一个网页的“夜间模式”
方法一：
const btn = document.getElementById(&#39;modeBtn&#39;); btn.addEventListener(&#39;click&#39;, (e) =&gt; { const body = document.body; if(e.target.innerHTML === &#39;&#39;) { body.style.backgroundColor = &#39;black&#39;; body.style.color = &#39;white&#39;; e.target.innerHTML = &#39;&#39;; } else { body.style.backgroundColor = &#39;white&#39;; body.style.color = &#39;black&#39;; e.target.innerHTML = &#39;&#39;; } }); 缺点
程序用了js直接操作样式
代码显得复杂繁琐、且复用性差
改进：
可以用class来表示状态 方法二：
const btn = document.getElementById(&#39;modeBtn&#39;); btn.addEventListener(&#39;click&#39;, (e) =&gt; { const body = document.body; if(body.className !== &#39;night&#39;) { body.className = &#39;night&#39;; } else { body." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/72b585d2777203bd82b3bf43445c4ff6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-19T15:17:08+08:00" />
<meta property="article:modified_time" content="2021-08-19T15:17:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【字节跳动青训营】- 如何写好JS？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>各司其职</h2> 
<ul><li> <p>HTML/CSS/JS各司其职</p> </li><li> <p>应当<strong>避免不必要</strong>的由JS直接操作样式</p> </li><li> <p>可以用class来表示状态</p> </li><li> <p>纯展示类交互寻求零JS方案（可以用CSS实现）</p> </li></ul> 
<p>例如：实现一个网页的“夜间模式”</p> 
<p><img src="https://images2.imgbox.com/9a/d7/5oSAVoVo_o.png" alt="请添加图片描述"></p> 
<p><strong>方法一：</strong></p> 
<pre><code class="prism language-JavaScript">const btn = document.getElementById('modeBtn');
btn.addEventListener('click', (e) =&gt; {
  const body = document.body;
  if(e.target.innerHTML === '') {
    body.style.backgroundColor = 'black';
    body.style.color = 'white';
    e.target.innerHTML = '';
  } else {
    body.style.backgroundColor = 'white';
    body.style.color = 'black';
    e.target.innerHTML = '';
  }
});

</code></pre> 
<p>缺点</p> 
<ul><li> <p>程序用了js直接操作样式</p> </li><li> <p>代码显得复杂繁琐、且复用性差</p> </li></ul> 
<p>改进：</p> 
<ul><li>可以用class来表示状态</li></ul> 
<hr> 
<p><strong>方法二：</strong></p> 
<pre><code class="prism language-JavaScript">const btn = document.getElementById('modeBtn');
btn.addEventListener('click', (e) =&gt; {
  const body = document.body;
  if(body.className !== 'night') {
    body.className = 'night';
  } else {
    body.className = '';
  }
});
</code></pre> 
<p>优点：</p> 
<ul><li>相比方法一没有用js直接操作样式</li></ul> 
<p>改进：</p> 
<ul><li>可以用纯css实现此效果，让代码更简洁</li></ul> 
<hr> 
<p><strong>方法三：(推荐)</strong></p> 
<pre><code class="prism language-JavaScript">&lt;input id="modeCheckBox" type="checkbox"&gt;
  &lt;div class="content"&gt;
    &lt;header&gt;
      &lt;label id="modeBtn" for="modeCheckBox"&gt;&lt;/label&gt;
      &lt;h1&gt;深夜食堂&lt;/h1&gt;
    &lt;/header&gt;
    &lt;main&gt;
        ······
    &lt;/main&gt;
   &lt;/div&gt; 
</code></pre> 
<pre><code class="prism language-JavaScript">#modeCheckBox:checked + .content {
  background-color: black;
  color: white;
  transition: all 1s;
}

</code></pre> 
<p>优点：</p> 
<ul><li> <p>是非常好的零js展示方案</p> </li><li> <p>完全满足了HTML/CSS/JS各司其职的书写理念</p> </li></ul> 
<hr> 
<h2><a id="_106"></a>组件封装</h2> 
<blockquote> 
 <p>组件：指Web页面上抽出来的一个个包含模板(HTML)、功能(JS)、样式(CSS)的单元</p> 
</blockquote> 
<p>组件设计的原则：<strong>封装性、正确性、扩展性、复用性</strong></p> 
<h3><a id="_112"></a>实现组件的步骤：</h3> 
<p>如轮播图为例：<a href="https://code.h5jun.com/reba/3/edit?html,css,js,output" rel="nofollow">轮播图</a></p> 
<h4><a id="HTML_116"></a>结构设计：HTML</h4> 
<p>轮播图是一个典型的列表结构，可以使用无序列表</p> 
<ul><li>
  元素来实现 
</li></ul> 
<p></p> 
<pre><code class="prism language-HTML">&lt;div id="my-slider" class="slider-list"&gt;
  &lt;ul&gt;
    &lt;li class="slider-list__item--selected"&gt;
      &lt;img src="https://p5.ssl.qhimg.com/t0119c74624763dd070.png"/&gt;
    &lt;/li&gt;
    &lt;li class="slider-list__item"&gt;
      &lt;img src="https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg"/&gt;
    &lt;/li&gt;
    &lt;li class="slider-list__item"&gt;
      &lt;img src="https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg"/&gt;
    &lt;/li&gt;
    &lt;li class="slider-list__item"&gt;
      &lt;img src="https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg"/&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;

</code></pre> 
<h4><a id="CSS_140"></a>展现效果：CSS</h4> 
<ul><li> <p>使用CSS绝对定位将图片重叠在同一个位置</p> </li><li> <p>轮播图切换的状态使用修饰符（modifier）</p> </li><li> <p>轮播图切换动画使用CSS transition</p> </li></ul> 
<pre><code class="prism language-CSS">#my-slider{
  position: relative;
  width: 790px;
}

.slider-list ul{
  list-style-type:none;
  position: relative;
  padding: 0;
  margin: 0;
}

.slider-list__item,
.slider-list__item--selected{
  position: absolute;
  transition: opacity 1s;
  opacity: 0;
  text-align: center;
}

.slider-list__item--selected{
  transition: opacity 1s;
  opacity: 1;
}

</code></pre> 
<h4><a id="_176"></a>行为设计</h4> 
<h5><a id="API_178"></a>API(功能)</h5> 
<p>API设计应保证原子操作，职责单一，满足灵活性。</p> 
<ul><li> <p>Slider</p> 
  <ul><li> <p>+getSelectedItem( ) 当前选中被展现出的图</p> </li><li> <p>+getSelectedItemIndex( ) 当前选中被展现出的图<strong>的索引</strong></p> </li><li> <p>+slideTo( ) 跳转并展示某个图</p> </li><li> <p>+slideNext( ) 切换下一张图</p> </li><li> <p>+slidePrevious( ) 切换上一张图</p> </li></ul> </li></ul> 
<pre><code class="prism language-JavaScript">class Slider{
  constructor(id){
    this.container = document.getElementById(id);
    this.items = this.container
    .querySelectorAll('.slider-list__item, .slider-list__item--selected');
  }
  getSelectedItem(){
    const selected = this.container
      .querySelector('.slider-list__item--selected');
    return selected
  }
  getSelectedItemIndex(){
    return Array.from(this.items).indexOf(this.getSelectedItem());
  }
  slideTo(idx){
    const selected = this.getSelectedItem();
    if(selected){ 
      selected.className = 'slider-list__item';
    }
    const item = this.items[idx];
    if(item){
      item.className = 'slider-list__item--selected';
    }
  }
  slideNext(){
    const currentIdx = this.getSelectedItemIndex();
    const nextIdx = (currentIdx + 1) % this.items.length;
    this.slideTo(nextIdx);
  }
  slidePrevious(){
    const currentIdx = this.getSelectedItemIndex();
    const previousIdx = (this.items.length + currentIdx - 1)
      % this.items.length;
    this.slideTo(previousIdx);  
  }
}
//展示第一张图
const slider = new Slider('my-slider');
slider.slideTo(1);
</code></pre> 
<h5><a id="Event_236"></a>Event(控制流)</h5> 
<p>轮播图下面的控制按钮</p> 
<pre><code class="prism language-JavaScript"> &lt;a class="slide-list__next"&gt;&lt;/a&gt;
  &lt;a class="slide-list__previous"&gt;&lt;/a&gt;
  &lt;div class="slide-list__control"&gt;
    &lt;span class="slide-list__control-buttons--selected"&gt;&lt;/span&gt;
    &lt;span class="slide-list__control-buttons"&gt;&lt;/span&gt;
    &lt;span class="slide-list__control-buttons"&gt;&lt;/span&gt;
    &lt;span class="slide-list__control-buttons"&gt;&lt;/span&gt;
  &lt;/div&gt;
</code></pre> 
<p>使用自定义事件来解耦</p> 
<pre><code class="prism language-JavaScript">  const detail = {index: idx}
  const event = new CustomEvent('slide', {bubbles:true, detail})
  this.container.dispatchEvent(event)
</code></pre> 
<p>组件封装优点：</p> 
<ul><li> <p>复用性强</p> </li><li> <p>可读性好</p> </li><li> <p>加强自己的代码管理能力</p> </li></ul> 
<h2><a id="_267"></a>过程抽象</h2> 
<ul><li> <p>用来处理局部细节控制的一些方法</p> </li><li> <p><strong>函数式编程</strong>思想的基础应用</p> </li></ul> 
<blockquote> 
 <p>函数式编程是一种<strong>编程范式</strong>，我们常见的编程范式有<strong>命令式编程（Imperative programming）</strong>，<strong>函数式编程</strong>，<strong>逻辑式编程</strong>，常见的面向对象编程是也是一种命令式编程。</p> 
</blockquote> 
<blockquote> 
 <p>命令式编程是面向<strong>计算机硬件</strong>的抽象，有<strong>变量</strong>（对应着存储单元），<strong>赋值语句</strong>（获取，存储指令），<strong>表达式</strong>（内存引用和算术运算）和<strong>控制语句</strong>（跳转指令），一句话，命令式程序就是一个<strong>冯诺依曼机</strong>的<strong>指令序列</strong>。</p> 
</blockquote> 
<blockquote> 
 <p>而函数式编程是面向数学的抽象，将计算描述为一种<strong>表达式求值</strong>，一句话，函数式程序就是一个<strong>表达式</strong>。</p> 
</blockquote> 
<h3><a id="_279"></a><strong>函数式编程的本质</strong></h3> 
<p>函数式编程中的<strong>函数</strong>这个术语不是指计算机中的函数（实际上是<strong>Subroutine</strong>），而是指数学中的函数，即自<strong>变量的映射</strong>。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。</p> 
<p>比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。<strong>相同的输入总是得到相同的输出，复用性好</strong>。</p> 
<h4><a id="1_285"></a>1、表达式化</h4> 
<p>函数式编程的思维就是首先转变我们传统的编程观念。去可变量，去循环，把命令式改成声明式</p> 
<p>命令式：</p> 
<p><img src="https://images2.imgbox.com/be/b6/OPkObkPr_o.png" alt="请添加图片描述"></p> 
<p>声明式</p> 
<p><img src="https://images2.imgbox.com/7c/29/tls8rOep_o.png" alt="请添加图片描述"></p> 
<h4><a id="2_299"></a>2、高阶逻辑</h4> 
<blockquote> 
 <p>用了函数式，思维就要从<strong>循环、赋值</strong>这些低阶逻辑转移成<strong>高阶</strong>的思考问题。函数式又叫声明式，也就是需要做什么操作，只需要说一下就行，而非写个遍历，做个状态判断.</p> 
</blockquote> 
<blockquote> 
 <p>用函数式就不需要考虑这样，你不知道函数式的列表是怎么遍历的，中间向两边? 从后往前?这也是为何函数式适合并发的原因之一，你想知道列表中大于3的数有多少，只要，list.count(_ &gt; 3) 而不是写循环，你可以直接写你的业务，不要拘泥于细节，有点像sql, 你需要什么告诉电脑就行，你或许会问，<strong>count foreach filter</strong> 这些函数怎么来的? 因为有了他们你才不需要写循环，他们把你留在高阶逻辑中。</p> 
</blockquote> 
<h4><a id="3___305"></a>3、组合子逻辑 或又叫 自底向上的设计</h4> 
<blockquote> 
 <p>面向对象是自顶向下的设计，函数式是<strong>自底向上</strong>的设计，也就是先定义最基本的操作，然后不断<strong>组合</strong>，不断堆积以满足你的所有需要，如sql定义了select, from, where…这几个组合子，来满足你的查询需求，同理函数式语言会提供foreach, map等组合子(操作)来满足你的需求，所以你必须自下而上的设计你的代码结构，并且满足你的需求，当你只用<strong>组合子</strong>写代码时，你会发现你写的全是高阶逻辑</p> 
</blockquote> 
<h4><a id="_311"></a>总结：</h4> 
<p>函数式思维，其实就是组合子逻辑，用简单的几个函数组合来构建复杂逻辑，始终以高阶的角度去表达问题，而非依赖副作用。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9a645dff14015390157a5a98718fa103/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">⭐算法入门⭐《队列》简单01 —— LeetCode 933. 最近的请求次数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/542acd0580f6bec85b3addce1c75a4fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java项目】 在线OJ系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>