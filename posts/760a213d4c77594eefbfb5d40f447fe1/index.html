<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java基础知识 1】Java入门级概述 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java基础知识 1】Java入门级概述" />
<meta property="og:description" content="🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪
，专注Java硬核干货分享，立志做到Java赛道全网Top N。
🏆本文收录于，Java基础教程系列，目前已经700&#43;订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
🏆姐妹篇，Java基础教程（入门篇），包含面向对象、基本数据类型、数组、继承和多态、泛型、枚举等Java基础知识点。
🏆姐妹进阶篇，Java基础教程（进阶篇），包含Java高并发、Spring、MySQL等Java进阶技术栈。
🏆全部订阅，可加入Java学习星球，完成Java从入门、实战、进阶全方位的Java知识体系学习。
小编之前写过一期Java学习路线总结❤️搬砖工逆袭Java架构师❤️（全网最强，建议收藏） 广受大家喜爱，有的粉丝问我，能不能出一期入门级别的博客，好吧，是我考虑不周了，今天我就将它补上。
目录 一、Java成名史
二、JDK 与 JRE 三、语言的五大特性
四、对象间的四种关系
1、依赖
2、关联
3、聚合
4、组合
五、封装、继承、多态
1、封装
2、继承
3、多态
六、我的第一个Java程序
1、先配置环境变量
2、hello world
七、八种基本数据类型
八、Java的重要概念
1、类
2、普通类和抽象类
3、接口和抽象类
4、成员变量和局部变量
5、对象的创建和声明周期
6、final 和 static 7、final、finally、finalize
8、Java运算符
9、循环结构
10、条件表达式
11、super与this
12、方法的重写
13、在 Java 中，什么时候用重载，什么时候用重写？
14、抽象类和接口
15、克隆
16、javac
九、Java Character 类
十、String
十一、数组
1、概念
2、格式
3、初始化
4、遍历
5、常见异常
十二、数据保存在哪里
1、寄存器
2、堆与栈
3、常量存储
4、非RAM存储
十三、java异常
十四、序列化与反序列化
十五、Java IO流" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/760a213d4c77594eefbfb5d40f447fe1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-04T22:37:20+08:00" />
<meta property="article:modified_time" content="2023-05-04T22:37:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java基础知识 1】Java入门级概述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪<br> ，专注Java硬核干货分享，立志做到Java赛道全网Top N。</p> 
 <p>🏆本文收录于，<a class="link-info" href="https://blog.csdn.net/guorui_java/category_11276743.html" title="Java基础教程系列">Java基础教程系列</a>，目前已经700+订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。</p> 
 <p>🏆姐妹篇，<a class="link-info" href="https://blog.csdn.net/guorui_java/category_11461823.html" title="Java基础教程（入门篇）">Java基础教程（入门篇）</a>，包含面向对象、基本数据类型、数组、继承和多态、泛型、枚举等Java基础知识点。</p> 
 <p>🏆姐妹进阶篇，<a class="link-info" href="https://blog.csdn.net/guorui_java/category_12196381.html" title="Java基础教程（进阶篇）">Java基础教程（进阶篇）</a>，包含Java高并发、Spring、MySQL等Java进阶技术栈。</p> 
 <p>🏆全部订阅，可加入<a class="link-info" href="https://bbs.csdn.net/topics/614261188" title="Java学习星球">Java学习星球</a>，完成Java从入门、实战、进阶全方位的Java知识体系学习。</p> 
</blockquote> 
<p> 小编之前写过一期<a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/120098618" title="Java学习路线总结❤️搬砖工逆袭Java架构师❤️（全网最强，建议收藏）">Java学习路线总结❤️搬砖工逆袭Java架构师❤️（全网最强，建议收藏）</a> </p> 
<p>广受大家喜爱，有的粉丝问我，能不能出一期入门级别的博客，好吧，是我考虑不周了，今天我就将它补上。</p> 
<p id="main-toc"><strong>目录</strong> </p> 
<p id="%E4%B8%80%E3%80%81Java%E6%88%90%E5%90%8D%E5%8F%B2-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81Java%E6%88%90%E5%90%8D%E5%8F%B2" rel="nofollow">一、Java成名史</a></p> 
<p id="%E4%BA%8C%E3%80%81JDK%20%E4%B8%8E%20JRE%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81JDK%20%E4%B8%8E%20JRE%C2%A0" rel="nofollow">二、JDK 与 JRE </a></p> 
<p id="%E4%B8%89%E3%80%81%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BA%94%E5%A4%A7%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BA%94%E5%A4%A7%E7%89%B9%E6%80%A7" rel="nofollow">三、语言的五大特性</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%85%B3%E7%B3%BB" rel="nofollow">四、对象间的四种关系</a></p> 
<p id="1%E3%80%81%E4%BE%9D%E8%B5%96-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E4%BE%9D%E8%B5%96" rel="nofollow">1、依赖</a></p> 
<p id="2%E3%80%81%E5%85%B3%E8%81%94-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%85%B3%E8%81%94" rel="nofollow">2、关联</a></p> 
<p id="3%E3%80%81%E8%81%9A%E5%90%88-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E8%81%9A%E5%90%88" rel="nofollow">3、聚合</a></p> 
<p id="4%E3%80%81%E7%BB%84%E5%90%88-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E7%BB%84%E5%90%88" rel="nofollow">4、组合</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81" rel="nofollow">五、封装、继承、多态</a></p> 
<p id="1%E3%80%81%E5%B0%81%E8%A3%85-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%B0%81%E8%A3%85" rel="nofollow">1、封装</a></p> 
<p id="2%E3%80%81%E7%BB%A7%E6%89%BF-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E7%BB%A7%E6%89%BF" rel="nofollow">2、继承</a></p> 
<p id="3%E3%80%81%E5%A4%9A%E6%80%81-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%A4%9A%E6%80%81" rel="nofollow">3、多态</a></p> 
<p id="%E5%85%AD%E3%80%81%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F" rel="nofollow">六、我的第一个Java程序</a></p> 
<p id="1%E3%80%81%E5%85%88%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%85%88%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" rel="nofollow">1、先配置环境变量</a></p> 
<p id="2%E3%80%81hello%20world-toc" style="margin-left:80px;"><a href="#2%E3%80%81hello%20world" rel="nofollow">2、hello world</a></p> 
<p id="%E4%B8%83%E3%80%81%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E4%B8%83%E3%80%81%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">七、八种基本数据类型</a></p> 
<p id="%E5%85%AB%E3%80%81Java%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E5%85%AB%E3%80%81Java%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5" rel="nofollow">八、Java的重要概念</a></p> 
<p id="1%E3%80%81%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E7%B1%BB" rel="nofollow">1、类</a></p> 
<p id="2%E3%80%81%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB" rel="nofollow">2、普通类和抽象类</a></p> 
<p id="3%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB" rel="nofollow">3、接口和抽象类</a></p> 
<p id="4%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" rel="nofollow">4、成员变量和局部变量</a></p> 
<p id="5%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F" rel="nofollow">5、对象的创建和声明周期</a></p> 
<p id="6%E3%80%81final%20%E5%92%8C%20static%C2%A0-toc" style="margin-left:80px;"><a href="#6%E3%80%81final%20%E5%92%8C%20static%C2%A0" rel="nofollow">6、final 和 static </a></p> 
<p id="7%E3%80%81final%E3%80%81finally%E3%80%81finalize-toc" style="margin-left:80px;"><a href="#7%E3%80%81final%E3%80%81finally%E3%80%81finalize" rel="nofollow">7、final、finally、finalize</a></p> 
<p id="8%E3%80%81Java%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#8%E3%80%81Java%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">8、Java运算符</a></p> 
<p id="9%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#9%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84" rel="nofollow">9、循环结构</a></p> 
<p id="10%E3%80%81%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:80px;"><a href="#10%E3%80%81%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">10、条件表达式</a></p> 
<p id="11%E3%80%81super%E4%B8%8Ethis-toc" style="margin-left:80px;"><a href="#11%E3%80%81super%E4%B8%8Ethis" rel="nofollow">11、super与this</a></p> 
<p id="12%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99-toc" style="margin-left:80px;"><a href="#12%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99" rel="nofollow">12、方法的重写</a></p> 
<p id="13%E3%80%81%E5%9C%A8%20Java%20%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E5%86%99%EF%BC%9F-toc" style="margin-left:80px;"><a href="#13%E3%80%81%E5%9C%A8%20Java%20%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E5%86%99%EF%BC%9F" rel="nofollow">13、在 Java 中，什么时候用重载，什么时候用重写？</a></p> 
<p id="14%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#14%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3" rel="nofollow">14、抽象类和接口</a></p> 
<p id="15%E3%80%81%E5%85%8B%E9%9A%86-toc" style="margin-left:80px;"><a href="#15%E3%80%81%E5%85%8B%E9%9A%86" rel="nofollow">15、克隆</a></p> 
<p id="16%E3%80%81javac-toc" style="margin-left:80px;"><a href="#16%E3%80%81javac" rel="nofollow">16、javac</a></p> 
<p id="%E4%B9%9D%E3%80%81Java%20Character%20%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E4%B9%9D%E3%80%81Java%20Character%20%E7%B1%BB" rel="nofollow">九、Java Character 类</a></p> 
<p id="%E5%8D%81%E3%80%81String-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E3%80%81String" rel="nofollow">十、String</a></p> 
<p id="%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84" rel="nofollow">十一、数组</a></p> 
<p id="1%E3%80%81%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E6%A6%82%E5%BF%B5" rel="nofollow">1、概念</a></p> 
<p id="2%E3%80%81%E6%A0%BC%E5%BC%8F-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E6%A0%BC%E5%BC%8F" rel="nofollow">2、格式</a></p> 
<p id="3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">3、初始化</a></p> 
<p id="4%E3%80%81%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E9%81%8D%E5%8E%86" rel="nofollow">4、遍历</a></p> 
<p id="5%E3%80%81%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8" rel="nofollow">5、常见异常</a></p> 
<p id="%E5%8D%81%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C" rel="nofollow">十二、数据保存在哪里</a></p> 
<p id="1%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8" rel="nofollow">1、寄存器</a></p> 
<p id="2%E3%80%81%E5%A0%86%E4%B8%8E%E6%A0%88-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%A0%86%E4%B8%8E%E6%A0%88" rel="nofollow">2、堆与栈</a></p> 
<p id="3%E3%80%81%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8" rel="nofollow">3、常量存储</a></p> 
<p id="4%E3%80%81%E9%9D%9ERAM%E5%AD%98%E5%82%A8-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E9%9D%9ERAM%E5%AD%98%E5%82%A8" rel="nofollow">4、非RAM存储</a></p> 
<p id="%E5%8D%81%E4%B8%89%E3%80%81java%E5%BC%82%E5%B8%B8-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%B8%89%E3%80%81java%E5%BC%82%E5%B8%B8" rel="nofollow">十三、java异常</a></p> 
<p id="%E5%8D%81%E5%9B%9B%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E5%9B%9B%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96" rel="nofollow">十四、序列化与反序列化</a></p> 
<p id="%E5%8D%81%E4%BA%94%E3%80%81Java%20IO%E6%B5%81-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%BA%94%E3%80%81Java%20IO%E6%B5%81" rel="nofollow">十五、Java IO流</a></p> 
<p id="%E5%8D%81%E5%85%AD%E3%80%81%E6%B3%9B%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E5%85%AD%E3%80%81%E6%B3%9B%E5%9E%8B" rel="nofollow">十六、泛型</a></p> 
<p id="%E5%8D%81%E4%B8%83%E3%80%81%E6%9E%9A%E4%B8%BE-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%B8%83%E3%80%81%E6%9E%9A%E4%B8%BE" rel="nofollow">十七、枚举</a></p> 
<p id="%E5%8D%81%E5%85%AB%E3%80%81%E6%B3%A8%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E5%85%AB%E3%80%81%E6%B3%A8%E8%A7%A3" rel="nofollow">十八、注解</a></p> 
<p id="%E5%8D%81%E4%B9%9D%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%B9%9D%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" rel="nofollow">十九、动态代理</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E3%80%81%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8D%81%E3%80%81%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6" rel="nofollow">二十、反射机制</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81Java%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81Java%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">二十一、Java注意事项</a></p> 
<hr id="hr-toc"> 
<h3 id="%E4%B8%80%E3%80%81Java%E6%88%90%E5%90%8D%E5%8F%B2">一、Java成名史</h3> 
<p>想要学好一门语言，一定要了解它的历史，了解它存在的价值和意义。 </p> 
<p>1991年成立了一个称为Green的项目小组，帕特里克、詹姆斯·高斯林、麦克·舍林丹和其他几个工程师一起组成的工作小组在加利福尼亚州门洛帕克市沙丘路的一个小工作室里面研究开发新技术，专攻计算机在家电产品上的嵌入式应用。</p> 
<p>由于C++所具有的优势，该项目组的研究人员首先考虑采用C++来编写程序。但对于硬件资源极其匮乏的单片式系统来说，C++程序过于复杂和庞大。</p> 
<p>为了解决困难，他们首先着眼于语言的开发，    对于新语言的设计，Sun公司研发人员并没有开发一种全新的语言，而是根据嵌入式软件的要求，对C++进行了改造，去除了留在C++的一些不太实用及影响安全的成分，并结合嵌入式系统的实时性要求，开发了一种称为Oak的面向对象语言。</p> 
<p>1994年将Oak语言更名为Java。</p> 
<p>1996年1月，Sun公司发布了Java的第一个开发工具包（JDK 1.0），这是Java发展历程中的重要里程碑，标志着Java成为一种独立的开发工具。</p> 
<p>1998年12月8日，第二代Java平台的企业版J2EE发布。</p> 
<p>1999年4月27日，HotSpot虚拟机发布。<br> 2005年6月，在Java One大会上，Sun公司发布了Java SE 6。此时，Java的各种版本已经更名，已取消其中的数字2，如J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME。</p> 
<p>2009年，甲骨文公司宣布收购Sun。</p> 
<p>2014年3月Oracle发布正式版JDK8，JDK8改进比较多，最大的改进是Lambda表达式（以及因之带来的函数式接口，很多原有类都做了变更，但能够与以往版本兼容，堪称奇功！），还有Stream API流式处理，joda-time等等一些新特性。</p> 
<h3 id="%E4%BA%8C%E3%80%81JDK%20%E4%B8%8E%20JRE%C2%A0"><strong>二、JDK 与 JRE </strong></h3> 
<p><strong><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/104247758" title="49天精通Java，第8天，JDK 和 JRE 、final 与 static 、堆和栈">49天精通Java，第8天，JDK 和 JRE 、final 与 static 、堆和栈</a></strong></p> 
<p>JDK：java development kit （java开发工具）</p> 
<p>JRE：java runtime environment （java运行时环境）</p> 
<p>JVM：Java Virtual Machine （java虚拟机）</p> 
<p>1、jdk--开发环境（核心）</p> 
<p>Java development kit的缩写，意思是Java开发工具，我们写文档做PPT需要office 办公软件，开发当然需要开发工具了，说到开发工具大家肯定会想到Eclipse，但是如果直接安装Eclipse你会发现它是运行不起来 是会报错的，只有安装了JDK，配置好了环境变量和path才可以运行成功。这点相信很多人都深有体会。</p> 
<p>jdk主要包含三个部分：</p> 
<p>第一部分是Java运行时环境，JVM</p> 
<p>第二部分是Java的基础类库，这个类库的数量还是相当可观的</p> 
<p>第三部分是Java的开发工具，它们都是辅助你更好地使用Java的利器jre--运行环境</p> 
<p>2、jre--运行环境</p> 
<p>① jdk中的jre</p> 
<p>如下图：jdk中包含的jre，在jre的bin目录里有个jvm.dll，既然JRE是运行时环境，那么运行在哪？肯定是JVM虚拟机上了。另，jre的lib目录中放的是一些JAVA类库的class文件，已经打包成jar文件。</p> 
<p>② 第二个JRE（独立出来的运行时环境）</p> 
<p>如下图，不管是JDK中的JRE还是JRE既然是运行时环境必须有JVM。所以JVM也是有两个的。</p> 
<p>3、JVM——转换环境</p> 
<p>Java Virtual Machine （java虚拟机）的缩写。</p> 
<p>大家一提到JAVA的优点就会想到：一次编译，随处运行，说白了就是跨平台性好，这点JVM功不可没。</p> 
<p>Java的程序也就是我们编译的代码都会编译为class文件，class文件就是在jvm上运行的文件，只有JVM还不能完全支持class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。</p> 
<p>JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改的运行。</p> 
<p>JVM也是一门很深的学问，感兴趣的同学可以深入研究，只有好处，没有坏处。</p> 
<p>其实有时候面试官问JDK和JRE的区别的目的不是想让你解释什么名词的，而是想看看你的基础和研究Java的深浅，还有另一方面就是你是不是经常喜欢问为什么。</p> 
<p><img alt="" src="https://images2.imgbox.com/92/4a/BtoCLj2M_o.jpg"></p> 
<h3 id="%E4%B8%89%E3%80%81%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BA%94%E5%A4%A7%E7%89%B9%E6%80%A7">三、语言的五大特性</h3> 
<ol><li>万物皆对象</li><li>程序就是多个对象彼此调用方法的过程</li><li>从内存角度而言，每个对象都是由其它更基础的对象组成的</li><li>每一个对象都有类型，都可以进行实例化</li><li>同一类型的对象可以接收相同的消息</li></ol> 
<p>面向对象编程的最大挑战就是如何在问题空间的元素和解决方案空间的对象之间建立一对一的关联。</p> 
<h3 id="%E5%9B%9B%E3%80%81%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%85%B3%E7%B3%BB">四、对象间的四种关系</h3> 
<h4 id="1%E3%80%81%E4%BE%9D%E8%B5%96">1、依赖</h4> 
<p>依赖关系表示一个类依赖于另一个类的定义。例如，一个人(Person)可以买车(car)和房子(House)，Person类依赖于Car类和House类的定义，因为Person类引用了Car和House。与关联不同的是，Person类里并没有Car和House类型的属性，Car和House的实例是以参量的方式传入到buy()方法中去的。一般而言，依赖关系在Java语言中体现为局域变量、方法的形参，或者对静态方法的调用。 </p> 
<h4 id="2%E3%80%81%E5%85%B3%E8%81%94">2、关联</h4> 
<p>关联(Association）关系是类与类之间的联接，它使一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的。在Java语言中，关联关系一般使用成员变量来实现。</p> 
<h4 id="3%E3%80%81%E8%81%9A%E5%90%88">3、聚合</h4> 
<p>聚合(Aggregation) 关系是关联关系的一种，是强的关联关系。聚合是整体和个体之间的关系。例如，汽车类与引擎类、轮胎类，以及其它的零件类之间的关系便整体和个体的关系。与关联关系一样，聚合关系也是通过实例变量实现的。但是关联关系所涉及的两个类是处在同一层次上的，而在聚合关系中，两个类是处在不平等层次上的，一个代表整体，另一个代表部分。 </p> 
<h4 id="4%E3%80%81%E7%BB%84%E5%90%88">4、组合</h4> 
<p>组合(Composition) 关系是关联关系的一种，是比聚合关系强的关系。它要求普通的聚合关系中代表整体的对象负责代表部分对象的生命周期，组合关系是不能共享的。代表整体的对象需要负责保持部分对象和存活，在一些情况下将负责代表部分的对象湮灭掉。代表整体的对象可以将代表部分的对象传递给另一个对象，由后者负责此对象的生命周期。换言之，代表部分的对象在每一个时刻只能与一个对象发生组合关系，由后者排他地负责生命周期。部分和整体的生命周期一样。 </p> 
<h3 id="%E4%BA%94%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81">五、封装、继承、多态</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/121194734" title="49天精通Java，第10天，Java继承和多态">49天精通Java，第10天，Java继承和多态</a></p> 
<h4 id="1%E3%80%81%E5%B0%81%E8%A3%85">1、封装</h4> 
<p>封装就是把对象的属性和行为结合为一个独立的整体，并尽可能多的隐藏对象的内部实现细节。</p> 
<h4 id="2%E3%80%81%E7%BB%A7%E6%89%BF">2、继承</h4> 
<p>对象用来封装数据和功能，但我们要创建一个新类，然而它又与已存在的类具有部分相同的属性或功能，此时，为了代码复用原则，可以使用继承来实现。</p> 
<p>继承通过基类和子类的概念来表达，基类的所有特征和行为都可以与子类共享。也就是说，你可以通过基类呈现核心思想，从基类继承的子类则为核心思想提供不同的实现方式。</p> 
<p>有时基类和子类的方法都是一样的，这时你就可以直接用子类的对象代替基类的对象，这种纯替代关系通常叫做替换原则。</p> 
<p>有时，子类会添加一些新的方法，此时就是不完美替换。</p> 
<h4 id="3%E3%80%81%E5%A4%9A%E6%80%81">3、多态</h4> 
<p>通过将子类对象引用赋给父类对象引用来实现动态方法调用。</p> 
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></pre> 
<h3 id="%E5%85%AD%E3%80%81%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F">六、我的第一个Java程序</h3> 
<h4 id="1%E3%80%81%E5%85%88%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1、先配置环境变量</h4> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/119293833" title="【Java基础知识 3】为何要配置环境变量？">【Java基础知识 3】为何要配置环境变量？</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3d/56/tUX63x56_o.png"></p> 
<h4 id="2%E3%80%81hello%20world">2、hello world</h4> 
<pre><code class="language-java">package com.guor;

public class Test{
    public static void main(String[] args) {
        System.out.println("hello world!");
    }
}
</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/50/6d/DljdBiqj_o.png"></p> 
<h3 id="%E4%B8%83%E3%80%81%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">七、八种基本数据类型</h3> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>数据类型</td><td>内存</td></tr><tr><td>byte</td><td>8位</td></tr><tr><td style="vertical-align:top;"> <p>short</p> </td><td style="vertical-align:top;"> <p>16位</p> </td></tr><tr><td style="vertical-align:top;"> <p>int</p> </td><td style="vertical-align:top;"> <p>32位</p> </td></tr><tr><td style="vertical-align:top;"> <p>long</p> </td><td style="vertical-align:top;"> <p>64位</p> </td></tr><tr><td style="vertical-align:top;"> <p>float</p> </td><td style="vertical-align:top;"> <p>32位</p> </td></tr><tr><td style="vertical-align:top;"> <p>double</p> </td><td style="vertical-align:top;"> <p>64位</p> </td></tr><tr><td style="vertical-align:top;"> <p>char</p> </td><td style="vertical-align:top;"> <p>16位</p> </td></tr><tr><td>boolean</td><td>1个字节或4个字节</td></tr></tbody></table> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/104247762" title="【Java基础知识 5】装箱和拆箱">【Java基础知识 5】装箱和拆箱</a></p> 
<p>java中的方法可以传递参数，参数的传递方法就是值传递。</p> 
<p>参数有形参和实参，定义方法时写的参数叫形参，真正调用方法时，传递的参数叫实参。</p> 
<p>调用方法时，会把实参传递给形参，方法内部其实是在使用形参。</p> 
<p>所谓值传递就是当参数是基本类型时，传递参数的值，比如传递i=10，真实传参时，把10赋值给了形参。</p> 
<p>当参数是对象时，传递的是对象的值，也就是对象的首地址。就是把对象的地址赋值给形参。</p> 
<h3 id="%E5%85%AB%E3%80%81Java%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5">八、Java的重要概念</h3> 
<h4 id="1%E3%80%81%E7%B1%BB">1、类</h4> 
<p>类的创建者负责在创建新的类时，只暴露必要的接口给客户程序员，同时隐藏其它所有不必要的信息。</p> 
<p>为什么这么做呢？</p> 
<p>（1）因为如果这些信息对于客户程序员而言是不可见的，那么类的创建者就可以任意修改隐藏信息，而无需担心对其它任何人造成影响。隐藏的代码通常代表着一个对象内部脆弱的部分，如果轻易暴露给粗心或经验不足的客户程序员，就可能在顷刻之间被破坏殆尽。所以，隐藏代码的具体实现可以有效减少程序bug。</p> 
<p>（2）让类库的设计者在改变类的内部工作机制时，不用担心影响到使用该类的客户程序员。</p> 
<p>Java提供了三个显示关键字来控制访问权限。</p> 
<h4 id="2%E3%80%81%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB">2、普通类和抽象类</h4> 
<ol><li>抽象类不能被实例化；</li><li>抽象类可以有抽象方法，只需申明，无须实现；</li><li>有抽象方法的类一定是抽象类；</li><li>抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类；</li><li>抽象方法不能声明为静态、不能被static、final修饰。</li></ol> 
<h4 id="3%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB">3、接口和抽象类</h4> 
<p>（1）接口</p> 
<ol><li>接口使用interface修饰；</li><li>接口不能实例化；</li><li>类可以实现多个接口；</li><li>java8之前，接口中的方法都是抽象方法，省略了public abstract。②java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；</li></ol> 
<p>（2）抽象类</p> 
<ol><li>抽象类使用abstract修饰；</li><li>抽象类不能被实例化；</li><li>抽象类只能单继承；</li><li>抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；</li><li>如果一个类继承了抽象类，①如果实现了所有的抽象方法，子类可以不是抽象类；②如果没有实现所有的抽象方法，子类仍然是抽象类。</li></ol> 
<h4 id="4%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">4、成员变量和局部变量</h4> 
<p>（1）在类中的位置不同</p> 
<p>成员变量：类中方法外；</p> 
<p>局部变量：方法定义中或者方法声明上；</p> 
<p>（2）在内存中的位置不同</p> 
<p>成员变量：在堆中</p> 
<p>局部变量：在栈中</p> 
<p>（3）生命周期不同</p> 
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失</p> 
<p>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</p> 
<p>（4）初始化值不同</p> 
<p>成员变量：有默认值</p> 
<p>局部变量：没有默认值，必须定义，赋值，然后才能使用</p> 
<h4 id="5%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F">5、对象的创建和声明周期</h4> 
<p>对象的创建需要消耗一些资源，尤其是内存资源。</p> 
<p>当我们不再需要一个对象时，就要及时清理它，这样占用的资源才能被释放并重复使用。</p> 
<p>如果要最大化运行时效率，可以通过栈区（局部变量）来保存对象，或者将对象保存在静态区里，这样在编写程序时就可以明确的知道对象的内存分配和生命周期，这种做法会优先考虑分配和释放内存的速度。但是代价就是牺牲了灵活性，因为你必须在编写代码时就明确对象的数量、生命周期以及类型，但是这种写法的限制性很大。</p> 
<p>还有一种方案是在内存池中动态创建对象，这个内存池也就堆。如果使用这个方案，直到运行时你才能知道需要多少对象，以及它们的生命周期和确切的类型是什么。如果需要创建一个新对象，可以直接通过堆来创建。因为堆是在运行时动态管理内存的，所以堆分配内存所花费的时间通常会比栈多一些。栈通常利用汇编指令向下或向上移动栈指针来管理内存，而堆何时分配内存则取决于内存机制的实现方式。</p> 
<p>Java只允许动态分配内存，每当要创建一个对象时，都需要使用new来创建一个对象的动态实例。</p> 
<p>如果在栈中创建对象，编译器会判断对象存在时间以及负责自动销毁该对象。</p> 
<p>如果在堆中创建对象，编译器就无法得知对象的生命周期。</p> 
<p>Java支持垃圾回收机制，它会自动找到没用的对象将其销毁。</p> 
<h4 id="6%E3%80%81final%20%E5%92%8C%20static%C2%A0">6、final 和 static </h4> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/121191475" title="49天精通Java，第9天，java final关键字">49天精通Java，第9天，java final关键字</a></p> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/125267799" title="Java 中的 static 关键字详解">Java 中的 static 关键字详解</a></p> 
<p>都可以修饰类、方法、成员变量</p> 
<p>static可以修饰类的代码块，final不可以</p> 
<p>static不可以修饰方法内局部变量，final可以</p> 
<p>static修饰表示静态或全局</p> 
<p>static修饰的代码块表示静态代码块，当JVM加载类时，只会被创建一次</p> 
<p>static修饰的变量可以重新赋值</p> 
<p>static方法中不能用this和super关键字</p> 
<blockquote> 
 <p>因为this代表的是调用这个函数的对象的引用，而静态方法是属于类的，不属于对象，静态方法成功加载后， 对象还不一定存在。 this代表对本类对象的引用，指向本类已创建的对象。 super代表对父类对象的引用，指向父类对象。 静态优先于对象存在，方法被static修饰之后，方法先存在，所需的父类引用对象晚于该方法的出 现，也就是super所指向的对象还没出现，当然就会报错。</p> 
</blockquote> 
<p>static方法必须被实现，而不能是抽象的abstract</p> 
<p>static方法只能被static方法覆盖</p> 
<p>final修饰表示常量、一旦创建不可被修改</p> 
<p>final标记的成员变量必须在声明的同时赋值，或在该类的构造方法中赋值，不可重新赋值</p> 
<p>final方法不能被子类重写</p> 
<p>final类不能被继承，没有子类，final类中的方法默认是final的</p> 
<p>final不能用于修饰构造方法</p> 
<p>private类型的方法默认是final类型的</p> 
<h4 id="7%E3%80%81final%E3%80%81finally%E3%80%81finalize">7、final、finally、finalize</h4> 
<p>final可以修饰类，变量，方法，修饰的类不能被继承，修饰的变量不能重新赋值，修饰的方法不能被重写</p> 
<p>finally用于抛异常，finally代码块内语句无论是否发生异常，都会在执行finally，常用于一些流的关闭。</p> 
<p>finalize方法用于垃圾回收。</p> 
<p>一般情况下不需要我们实现finalize，当对象被回收的时候需要释放一些资源，比如socket链接，在对象初始化时创建，整个生命周期内有效，那么需要实现finalize方法，关闭这个链接。</p> 
<p>但是当调用finalize方法后，并不意味着gc会立即回收该对象，所以有可能真正调用的时候，对象又不需要回收了，然后到了真正要回收的时候，因为之前调用过一次，这次又不会调用了，产生问题。所以，不推荐使用finalize方法。</p> 
<h4 id="8%E3%80%81Java%E8%BF%90%E7%AE%97%E7%AC%A6">8、Java运算符</h4> 
<ul><li>算术运算符</li><li>关系运算符</li><li>位运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符</li></ul> 
<h4 id="9%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">9、循环结构</h4> 
<ol><li>for</li><li>while</li><li>do...while</li></ol> 
<h4 id="10%E3%80%81%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F">10、条件表达式</h4> 
<ol><li>if...else...</li><li>switch case</li></ol> 
<h4 id="11%E3%80%81super%E4%B8%8Ethis">11、super与this</h4> 
<ol><li>super关键字可以在子类的构造方法中显示地调用父类的构造方法，super()必须为子类构造函数中的第一行。</li><li>super可以用来访问父类的成员方法或变量，当子类成员变量或方法与父类有相同的名字时也会覆盖父类的成员变量或方法，这个时候要想访问父类的成员变量或方法只能通过super关键字来访问，子类方法中的super.方法名()不需要位于第一行。</li><li>this关键字指向的是当前对象的引用，用来区分成员变量和局部变量（重名问题）</li><li>this() 不能使用在普通方法中 只能写在构造方法中。</li><li>必须是构造方法中的第一条语句。</li></ol> 
<h4 id="12%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99">12、方法的重写</h4> 
<p>父类的功能无法满足子类的需求时，则需要用到重写；</p> 
<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p> 
<p>重写的注意事项：</p> 
<ol><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类中被重写的方法的访问权限更低；</li><li>声明为final的方法不能被重写；</li><li>声明为static的方法不能被重写，但是能够被再次声明；</li><li>构造方法不能被重写；</li><li>子类和父类在同一个包中，那么子类可以重写父类所有除了声明为private和final 的方法；</li><li>如果不能继承一个方法，则不能重写这个方；</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和 protected的非final方法；</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是， 重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性 异常，反之则可以。</li></ol> 
<h4 id="13%E3%80%81%E5%9C%A8%20Java%20%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E5%86%99%EF%BC%9F">13、在 Java 中，什么时候用重载，什么时候用重写？</h4> 
<p>（1）重载是多态的集中体现，在类中，要以统一的方式处理不同类型数据的时候，可以用重载。</p> 
<p>（2）重写的使用是建立在继承关系上的，子类在继承父类的基础上，增加新的功能，可以用重写。</p> 
<p>（3）简单总结：</p> 
<ol><li>重载是多样性，重写是增强剂；</li><li>目的是提高程序的多样性和健壮性，以适配不同场景使用时，使用重载进行扩展；</li><li>目的是在不修改原方法及源代码的基础上对方法进行扩展或增强时，使用重写；</li></ol> 
<h4 id="14%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3">14、抽象类和接口</h4> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/129963398" title="49天精通Java，第11天，java接口和抽象类的异同，default关键字">49天精通Java，第11天，java接口和抽象类的异同，default关键字</a></p> 
<p>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：在 Java 中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。</p> 
<p>接口通常被用来表示附属描述或行为如： Runnable 、 Clonable 、 Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable( 注：这里的意思是指如果把 Runnable 等实现为抽象类的情况 ) ，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</p> 
<p>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</p> 
<h4 id="15%E3%80%81%E5%85%8B%E9%9A%86">15、克隆</h4> 
<p>（1）什么要使用克隆？</p> 
<p>想对一个对象进行复制，又想保留原有的对象进行接下来的操作，这个时候就需要克隆了。</p> 
<p>（2）如何实现对象克隆？</p> 
<p>实现Cloneable接口，重写clone方法；<br> 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。<br> BeanUtils，apache和Spring都提供了bean工具，只是这都是浅克隆。</p> 
<p>（3）深拷贝和浅拷贝区别是什么？</p> 
<p>浅拷贝：仅仅克隆基本类型变量，不克隆引用类型变量；<br> 深克隆：既克隆基本类型变量，又克隆引用类型变量；</p> 
<h4 id="16%E3%80%81javac">16、javac</h4> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/123886579" title="Java是动态语言吗？从《Java核心编程》探索真知">Java是动态语言吗？从《Java核心编程》探索真知</a></p> 
<p>（1）javac是什么</p> 
<ol><li>javac是一种编译器，能够将一种语言规范转化成另外一种语言规范</li><li>javac的任务就是将Java源代码转化成JVM能够识别的一种语言（Java字节码），这种字节码不是针对某种机器、某种平台的</li></ol> 
<p>（2）javac编译器编译程序的步骤</p> 
<p>① 词法分析</p> 
<p>首先是读取源代码，找出这些字节中哪些是我们定义的语法关键词，如Java中的if、else、for等关键词。</p> 
<p>语法分析的结果：从源代码中找出一些规范化的token流。</p> 
<p>注：token是一种认证机制</p> 
<p>② 语法分析</p> 
<p>检查关键词组合在一起是不是Java语言规范，如if后面是不是紧跟着一个布尔表达式。</p> 
<p>语法分析的结果：形成一个符合Java语言规范的抽象语法树</p> 
<p>③ 语义分析</p> 
<p>把一些难懂的、复杂的语法转化为更加简单的语法。</p> 
<p>语义分析的结果：完成复杂语法到简单语法的简化，如将foreach语句转化成for循环结果，还有注解等。最后形成一个注解过后的抽象语法树，这颗语法树更接近目标语言的语法规则。</p> 
<p>④ 生成字节码</p> 
<p>通过字节码生成器生成字节码，根据经过注解的抽象语法树生成字节码，也就是将一个数据结构转化成另一个数据结构。</p> 
<p>代码生成器的结果：生成符合Java虚拟机规范的字节码。</p> 
<p>注：抽象语法树</p> 
<p>在计算机科学中，抽象语法树是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p> 
<p>（3）javac编译器的基本结构</p> 
<p>按照上述编译步骤来看，可以将javac编译器分为4个模块：词法分析器、语法分析器、语义分析器和代码生成器。</p> 
<h3 id="%E4%B9%9D%E3%80%81Java%20Character%20%E7%B1%BB">九、Java Character 类</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/113827704" title="【Java集合 4】Java.lang.Character类详解">【Java集合 4】Java.lang.Character类详解</a></p> 
<h3 id="%E5%8D%81%E3%80%81String">十、String</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/117935620" title="【Java基础知识 7】toString()、String.valueOf、(String)强转">【Java基础知识 7】toString()、String.valueOf、(String)强转</a></p> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/120240687" title="【Java基础知识 8】String、StringBuilder、StringBuffer详解">【Java基础知识 8】String、StringBuilder、StringBuffer详解</a></p> 
<h3 id="%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84">十一、数组</h3> 
<h4 id="1%E3%80%81%E6%A6%82%E5%BF%B5">1、概念</h4> 
<p>同一种数据类型的集合，数组是一个容器。</p> 
<p>数组能够对存储的元素进行自动排号，编号从0开始，方便操作。</p> 
<h4 id="2%E3%80%81%E6%A0%BC%E5%BC%8F">2、格式</h4> 
<pre><code class="language-java">int[] arr = new int[10]; </code></pre> 
<h4 id="3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96">3、初始化</h4> 
<pre><code class="language-java">//方式1
int[] arr = { 1, 2, 3, 4, 5 };

//方式2
int[] arr3=new int[3];
arr3[0]=1;
arr3[1]=2;
arr3[2]=3;</code></pre> 
<h4 id="4%E3%80%81%E9%81%8D%E5%8E%86">4、遍历</h4> 
<pre><code class="language-java">
public class Test{
    public static void main(String[] args) {
        String[] arr = new String[3];
        arr[0] = "CSDN";
        arr[1] = "哪吒";
        arr[2] = "博客专家";
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }

        for (String str:arr) {
            System.out.println(str);
        }
    }
}</code></pre> 
<h4 id="5%E3%80%81%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8">5、常见异常</h4> 
<ol><li>NullPointerException 空指针异常</li><li>ArrayIndexOutOfBoundsException 索引值越界</li></ol> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/117968801" title="【Java基础知识 4】秒懂数组拷贝，感知新境界">【Java基础知识 4】秒懂数组拷贝，感知新境界</a></p> 
<h3 id="%E5%8D%81%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C">十二、数据保存在哪里</h3> 
<h4 id="1%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8">1、寄存器</h4> 
<p>寄存器是速度最快的数据存储方式，数据直接保存在中央处理器，然而寄存器的数量是有限的，所以只能按需分配。</p> 
<p>JVM中有4种常见的寄存器：</p> 
<ol><li>pc程序寄存器</li><li>optop操作数栈顶指针</li><li>frame当前执行环境指针</li><li>vars指向当前执行环境中第一个局部变量的指针</li></ol> 
<p>所有寄存器都为32位。</p> 
<p>pc用于记录程序的执行，optop,frame和vars用于记录指向Java栈区的指针。</p> 
<h4 id="2%E3%80%81%E5%A0%86%E4%B8%8E%E6%A0%88">2、堆与栈</h4> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/128710485" title="一文读懂JVM类加载机制过程及原理">一文读懂JVM类加载机制过程及原理</a></p> 
<p>（1）堆内存用于存放new创建的对象</p> 
<p>在堆中分配的内存，由JVM自动垃圾回收器管理。</p> 
<p>在堆中产生一个对象后，会在栈中定义一个特殊变量，这个变量的取值等于数组或对象在堆内存中的首地址，在栈中的这个特殊的变量就编程了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的对象。</p> 
<p>对象在没有引用变量指向它的时候，才会编程垃圾，不能再被使用，但是仍然占着内存，在随后一个不确定的时间点被垃圾回收器释放掉。这也是Java程序比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是Java中的指针。</p> 
<p>（2）在函数中定义的一些基本类型的变量和对象的引用变量都是在栈内存中分配的。</p> 
<p>当一段代码定义一个变量时，java就在栈中分配一个内存，当超过变量的作用域后，java会自动释放掉该变量分配的内存空间。</p> 
<p>简而言之，堆是用来存放对象的，栈是运行程序的。</p> 
<p>堆：为成员分配和释放，由程序员自己申请、自己释放。否则发生内存泄露。典型为使用 new 申请的堆内容。</p> 
<p>栈为编译器自动分配和释放，如函数参数、局部变量、临时变量等等。</p> 
<p>如果想迅速进行垃圾回收，可以将对象置为null。</p> 
<h4 id="3%E3%80%81%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8">3、常量存储</h4> 
<p>常量通常会直接写在程序代码中，不可变。</p> 
<h4 id="4%E3%80%81%E9%9D%9ERAM%E5%AD%98%E5%82%A8">4、非RAM存储</h4> 
<p>不保存在应用程序里的数据，最典型的例子就是序列化对象，它指的是转换为字节流并可以发送到其它机器的对象。另一个例子则是持久化对象，它指的是保存在磁盘上的对象。也支持使用数据库存储对象信息。</p> 
<p>大多数微处理芯片有额外的缓存内存，只不过缓存内容使用的是传统的内存管理方式，而非寄存器。</p> 
<p>一个例子是字符串常量池，所有字符串和字符串常量都会被自动放置到这个特殊的存储空间中。</p> 
<p>特殊情况 -&gt; 原始类型</p> 
<p>原始类型是直接创建一个“自动变量”，不是引用，该变量直接在栈上保存它的值，运行效率更高。</p> 
<h3 id="%E5%8D%81%E4%B8%89%E3%80%81java%E5%BC%82%E5%B8%B8">十三、java异常</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/120190080" title="【Java基础知识 6】Java异常详解">【Java基础知识 6】Java异常详解</a></p> 
<h3 id="%E5%8D%81%E5%9B%9B%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">十四、序列化与反序列化</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/128027906" title="Java序列化与反序列化详解">Java序列化与反序列化详解</a></p> 
<h3 id="%E5%8D%81%E4%BA%94%E3%80%81Java%20IO%E6%B5%81">十五、Java IO流</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/113985421" title="【Java基础知识 10】Java IO流详解">【Java基础知识 10】Java IO流详解</a></p> 
<h3 id="%E5%8D%81%E5%85%AD%E3%80%81%E6%B3%9B%E5%9E%8B">十六、泛型</h3> 
<p>在Java5之前，JAVA语言的集合所支持的通用类型是Object。因为单根结构决定了所有对象都属于Object类型，所以一个持有Object的集合就可以持有任何对象，这就使得集合十分易于复用。</p> 
<p>其实并不能保存原始数据类型，不过自动装箱机制在一定程度上解决了这个问题。</p> 
<p>当集合中持有Object类型时，要添加一个对象到集合中，该对象会向上转型为Object，从而失去了原本的类型。当你需要将其取出时，会获得一个Object类型的对象引用，这就不是当初的类型了，需要进行向下转型。但除非明确知道对象的具体类型，否则向下转型是不安全的，转型失败会抛出异常。</p> 
<p>这个问题的解决方式是“参数化类型”，一个被参数化的类型是一种特殊的类，可以让编译器自动适配特定的类型，参数化类型也叫泛型，通过尖括号中间加上类名来定义泛型，比如List&lt;String&gt;。</p> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/106808115" title="【Java 基础知识 11】Java泛型详解">【Java 基础知识 11】Java泛型详解</a></p> 
<h3 id="%E5%8D%81%E4%B8%83%E3%80%81%E6%9E%9A%E4%B8%BE">十七、枚举</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/106789054" title="【Java基础知识 12】Java枚举详解">【Java基础知识 12】Java枚举详解</a></p> 
<h3 id="%E5%8D%81%E5%85%AB%E3%80%81%E6%B3%A8%E8%A7%A3">十八、注解</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/106658179" title="【Java基础知识 13】Java注解详解">【Java基础知识 13】Java注解详解</a></p> 
<h3 id="%E5%8D%81%E4%B9%9D%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">十九、动态代理</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/108630273" title="【Java基础知识 14】Java动态代理">【Java基础知识 14】Java动态代理</a></p> 
<h3 id="%E4%BA%8C%E5%8D%81%E3%80%81%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6">二十、反射机制</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/108351185" title="【Java基础知识 15】Java反射机制">【Java基础知识 15】Java反射机制</a></p> 
<h3>二十一、Java高并发编程</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/126727119" title="Java高并发编程实战1，那些年学过的锁">Java高并发编程实战1，那些年学过的锁</a></p> 
<h3 id="%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81Java%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">二十二、Java注意事项</h3> 
<ol><li>​尽量使用final修饰符</li><li>尽量重用对象</li><li>尽可能使用局部变量</li><li>及时关闭流</li><li>尽量减少对变量的重复计算</li><li>尽量采用懒加载的策略，即在需要的时候才创建</li><li>慎用异常</li><li>不要在循环中使用trycatch，应该把其放在最外层</li><li>尽量能估计到待添加的内容的长度，为底层以数组方式实现的集合、工具类指定初始长度</li><li>当复制大量数据时，使用system.arraycopy命令</li><li>乘法和除法使用移位操作</li><li>循环内不要不断创建对象引用</li><li>基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</li><li>尽量使用hashmap、ArrayList、stringbuilder，除非线程安全需要，否则不建议使用hashtable、vector、stringbuffer，后三者由于使用同步机制而导致了性能开销。</li><li>不要讲数组声明为public static final</li><li>尽量在合适的场合使用单例模式</li><li>尽量避免使用静态变量</li><li>及时清除不再需要的会话</li><li>实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环</li><li>使用同步代码块代替同步方法</li><li>将常量声明为static final，并以大写命名</li><li>不要创建一些不使用的对象，不要导入一些不使用的类</li><li>程序运行过程中避免使用反射</li><li>使用数据库连接池和线程池</li><li>使用带缓冲的输入输出流进行IO操作</li><li>顺序插入和随机访问比较多的场景用ArrayList，元素删除和中间插入比较多的场景使用LinkedList</li><li>不要让public方法中有太多的参数</li><li>字符串变量和字符串常量equals的时候将字符串常量写在前面</li><li>请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者</li><li>不要对数组使用toString方法</li><li>不要对超出范围的基础数据类型做向下强制类型转型</li><li>公用的集合类中不使用的数据一定要及时的remove掉</li><li>把一个基本类型转为字符串，toString最快，String.valueOf次之，数据+“”最慢</li><li>使用最有效率的方法去遍历map</li><li>对资源的close()建议分开操作</li></ol> 
<hr> 
<blockquote> 
 <p>🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪<br> ，专注Java硬核干货分享，立志做到Java赛道全网Top N。</p> 
 <p>🏆本文收录于，<a class="link-info" href="https://blog.csdn.net/guorui_java/category_11276743.html" title="Java基础教程系列">Java基础教程系列</a>，目前已经700+订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。</p> 
 <p>🏆姐妹篇，<a class="link-info" href="https://blog.csdn.net/guorui_java/category_11461823.html" title="Java基础教程（入门篇）">Java基础教程（入门篇）</a>，包含面向对象、基本数据类型、数组、继承和多态、泛型、枚举等Java基础知识点。</p> 
 <p>🏆姐妹进阶篇，<a class="link-info" href="https://blog.csdn.net/guorui_java/category_12196381.html" title="Java基础教程（进阶篇）">Java基础教程（进阶篇）</a>，包含Java高并发、Spring、MySQL等Java进阶技术栈。</p> 
 <p>🏆全部订阅，可加入<a class="link-info" href="https://bbs.csdn.net/topics/614261188" title="Java学习星球">Java学习星球</a>，完成Java从入门、实战、进阶全方位的Java知识体系学习。</p> 
</blockquote> 
<h4>上一篇：<a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/120643691" title="Java学习路线总结（思维导图篇）">Java学习路线总结（思维导图篇）</a></h4> 
<h4 id="%E7%B2%89%E4%B8%9D%E4%B8%93%E5%B1%9E%E7%A6%8F%E5%88%A9%C2%A0">下一篇：<a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/121176945" title="【Java基础知识 2】配置java环境变量">【Java基础知识 2】配置java环境变量</a></h4> 
<p style="margin-left:0;text-align:justify;"></p> 
<p></p> 
<p style="margin-left:0px;text-align:center;"><img alt="" src="https://images2.imgbox.com/15/3d/XMDfllD0_o.gif"></p> 
<p style="text-align:center;"> <span style="color:#fe2c24;"><strong>关注公众号，备注1024，获取Java学习路线思维导图、加入万粉计划交流群</strong></span> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b0a0ca0ec176c8340376aa72cda87475/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">matlab读取excel文件详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3f85bfb7af8f2e22b74baa8d47eedff6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java：for循环内部设置多线程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>