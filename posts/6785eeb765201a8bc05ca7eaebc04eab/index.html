<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java线程池ThreadPoolExecutor使用和分析(一) - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java线程池ThreadPoolExecutor使用和分析(一)" />
<meta property="og:description" content="相关文章目录：
Java线程池ThreadPoolExecutor使用和分析(一)
Java线程池ThreadPoolExecutor使用和分析(二) - execute()原理
Java线程池ThreadPoolExecutor使用和分析(三) - 终止线程池原理
线程池是可以控制线程创建、释放，并通过某种策略尝试复用线程去执行任务的一种管理框架，从而实现线程资源与任务之间的一种平衡。
以下分析基于 JDK1.7
以下是本文的目录大纲：
一、线程池架构
1、Executor接口
2、ExecutorService接口
3、ScheduledExecutorService接口
二、ThreadPoolExecutor
1、ThreadPoolExecutor构造参数
2、ThreadPoolExecutor线程池执行流程
三、Executors静态工厂创建几种常用线程池
一、线程池架构
概括一下：
Executor是最基础的执行接口；
ExecutorService接口继承了Executor，在其上做了一些shutdown()、submit()的扩展，可以说是真正的线程池接口；
AbstractExecutorService抽象类实现了ExecutorService接口中的大部分方法；
TheadPoolExecutor继承了AbstractExecutorService，是线程池的具体实现；
ScheduledExecutorService接口继承了ExecutorService接口，提供了带&#34;周期执行&#34;功能ExecutorService；
ScheduledThreadPoolExecutor既继承了TheadPoolExecutor线程池，也实现了ScheduledExecutorService接口，是带&#34;周期执行&#34;功能的线程池；
Executors是线程池的静态工厂，其提供了快捷创建线程池的静态方法。
1、Executor接口
“执行者”接口，只提供了一个方法：
void execute(Runnable command); 可以用来执行已经提交的Runnable任务对象，这个接口提供了一种将“任务提交”与“任务执行”解耦的方法。
2、ExecutorService接口
“执行者服务”接口，可以说是真正的线程池接口，在Executor接口的基础上做了一些扩展，主要是
(A) 管理任务如何终止的 shutdown相关方法
/** * 启动一次有序的关闭，之前提交的任务执行，但不接受新任务 * 这个方法不会等待之前提交的任务执行完毕 */ void shutdown(); /** * 试图停止所有正在执行的任务，暂停处理正在等待的任务，返回一个等待执行的任务列表 * 这个方法不会等待正在执行的任务终止 */ List&lt;Runnable&gt; shutdownNow(); /** * 如果已经被shutdown，返回true */ boolean isShutdown(); /** * 如果所有任务都已经被终止，返回true * 是否为终止状态 */ boolean isTerminated(); /** * 在一个shutdown请求后，阻塞的等待所有任务执行完毕 * 或者到达超时时间，或者当前线程被中断 */ boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; (B) 可以生成用于追踪一个或多个异步任务执行结果的Future对象的 submit()相关方法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/6785eeb765201a8bc05ca7eaebc04eab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-24T15:59:50+08:00" />
<meta property="article:modified_time" content="2022-03-24T15:59:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java线程池ThreadPoolExecutor使用和分析(一)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>相关文章目录：</p> 
<p>    Java线程池ThreadPoolExecutor使用和分析(一)</p> 
<p>    Java线程池ThreadPoolExecutor使用和分析(二) - execute()原理</p> 
<p>    Java线程池ThreadPoolExecutor使用和分析(三) - 终止线程池原理</p> 
<p></p> 
<p>    线程池是可以控制线程创建、释放，并通过某种策略尝试复用线程去执行任务的一种管理框架，从而实现线程资源与任务之间的一种平衡。</p> 
<p>    以下分析基于 JDK1.7</p> 
<p></p> 
<p>    以下是本文的目录大纲：</p> 
<p>    一、线程池架构</p> 
<p>        1、Executor接口</p> 
<p>        2、ExecutorService接口</p> 
<p>        3、ScheduledExecutorService接口</p> 
<p>    二、ThreadPoolExecutor</p> 
<p>        1、ThreadPoolExecutor构造参数</p> 
<p>        2、ThreadPoolExecutor线程池执行流程</p> 
<p>    三、Executors静态工厂创建几种常用线程池</p> 
<p></p> 
<p>一、线程池架构<br><img alt="" src="https://images2.imgbox.com/c9/d2/JqkE1K2q_o.png"></p> 
<p> 概括一下：</p> 
<p>Executor是最基础的执行接口；</p> 
<p>ExecutorService接口继承了Executor，在其上做了一些shutdown()、submit()的扩展，可以说是真正的线程池接口；</p> 
<p>AbstractExecutorService抽象类实现了ExecutorService接口中的大部分方法；</p> 
<p>TheadPoolExecutor继承了AbstractExecutorService，是线程池的具体实现；</p> 
<p>ScheduledExecutorService接口继承了ExecutorService接口，提供了带"周期执行"功能ExecutorService；</p> 
<p>ScheduledThreadPoolExecutor既继承了TheadPoolExecutor线程池，也实现了ScheduledExecutorService接口，是带"周期执行"功能的线程池；</p> 
<p>Executors是线程池的静态工厂，其提供了快捷创建线程池的静态方法。</p> 
<p></p> 
<p>1、Executor接口</p> 
<p>“执行者”接口，只提供了一个方法：</p> 
<pre><code class="language-java">void execute(Runnable command);</code></pre> 
<p><br> 可以用来执行已经提交的Runnable任务对象，这个接口提供了一种将“任务提交”与“任务执行”解耦的方法。</p> 
<p></p> 
<p>2、ExecutorService接口</p> 
<p>“执行者服务”接口，可以说是真正的线程池接口，在Executor接口的基础上做了一些扩展，主要是</p> 
<p>(A) 管理任务如何终止的 shutdown相关方法</p> 
<pre><code class="language-java">/**
 * 启动一次有序的关闭，之前提交的任务执行，但不接受新任务
 * 这个方法不会等待之前提交的任务执行完毕
 */
void shutdown();
 
/**
 * 试图停止所有正在执行的任务，暂停处理正在等待的任务，返回一个等待执行的任务列表
 * 这个方法不会等待正在执行的任务终止
 */
List&lt;Runnable&gt; shutdownNow();
 
/**
 * 如果已经被shutdown，返回true
 */
boolean isShutdown();
 
/**
 * 如果所有任务都已经被终止，返回true
 * 是否为终止状态
 */
boolean isTerminated();
 
/**
 * 在一个shutdown请求后，阻塞的等待所有任务执行完毕
 * 或者到达超时时间，或者当前线程被中断
 */
boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;</code></pre> 
<p><br>  </p> 
<p>(B) 可以生成用于追踪一个或多个异步任务执行结果的Future对象的 submit()相关方法</p> 
<pre><code class="language-java">/**
 * 提交一个可执行的任务，返回一个Future代表这个任务
 * 等到任务成功执行，Future#get()方法会返回null
 */
Future&lt;?&gt; submit(Runnable task);
 
/**
 * 提交一个可以执行的任务，返回一个Future代表这个任务
 * 等到任务执行结束，Future#get()方法会返回这个给定的result
 */
&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);
 
/**
 * 提交一个有返回值的任务，并返回一个Future代表等待的任务执行的结果
 * 等到任务成功执行，Future#get()方法会返回任务执行的结果
 */
&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</code></pre> 
<p></p> 
<p>3、ScheduledExecutorService接口</p> 
<pre><code class="language-java">/**
 * 在给定延时后，创建并执行一个一次性的Runnable任务
 * 任务执行完毕后，ScheduledFuture#get()方法会返回null
 */
public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit);
 
/**
 * 在给定延时后，创建并执行一个ScheduledFutureTask
 * ScheduledFuture 可以获取结果或取消任务
 */
public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, ong delay, TimeUnit unit);
 
/**
 * 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期
 * 也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推
 * 如果执行任务发生异常，随后的任务将被禁止，否则任务只会在被取消或者Executor被终止后停止
 * 如果任何执行的任务超过了周期，随后的执行会延时，不会并发执行
 */
public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);
 
/**
 * 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟
 * 如果执行任务发生异常，随后的任务将被禁止，否则任务只会在被取消或者Executor被终止后停止
 */
public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                     TimeUnit unit);</code></pre> 
<p>二、ThreadPoolExecutor<br> 1、ThreadPoolExecutor构造参数</p> 
<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
</code></pre> 
<p><br> corePoolSize</p> 
<p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；</p> 
<p>如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；</p> 
<p>如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p> 
<p>maximumPoolSize</p> 
<p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</p> 
<p>keepAliveTime</p> 
<p>线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用</p> 
<p>workQueue</p> 
<p>workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能</p> 
<p>几种排队的策略：</p> 
<p>（1）不排队，直接提交<br> 将任务直接交给线程处理而不保持它们，可使用SynchronousQueue<br> 如果不存在可用于立即运行任务的线程（即线程池中的线程都在工作），则试图把任务加入缓冲队列将会失败，因此会构造一个新的线程来处理新添加的任务，并将其加入到线程池中（corePoolSize--&gt;maximumPoolSize扩容）<br> Executors.newCachedThreadPool()采用的便是这种策略</p> 
<p>（2）无界队列</p> 
<p>可以使用LinkedBlockingQueue（基于链表的有界队列，FIFO），理论上是该队列可以对无限多的任务排队</p> 
<p>将导致在所有corePoolSize线程都工作的情况下将新任务加入到队列中。这样，创建的线程就不会超过corePoolSize，也因此，maximumPoolSize的值也就无效了</p> 
<p>（3）有界队列</p> 
<p>可以使用ArrayBlockingQueue（基于数组结构的有界队列，FIFO），并指定队列的最大长度</p> 
<p>使用有界队列可以防止资源耗尽，但也会造成超过队列大小和maximumPoolSize后，提交的任务被拒绝的问题，比较难调整和控制。</p> 
<p>threadFactory</p> 
<p>创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名</p> 
<pre><code class="language-java">/**
 * The default thread factory
 */
static class DefaultThreadFactory implements ThreadFactory {
    private static final AtomicInteger poolNumber = new AtomicInteger(1);
    private final ThreadGroup group;
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;
 
    DefaultThreadFactory() {
        SecurityManager s = System.getSecurityManager();
        group = (s != null) ? s.getThreadGroup() :
                              Thread.currentThread().getThreadGroup();
        namePrefix = "pool-" +
                      poolNumber.getAndIncrement() +
                     "-thread-";
    }
 
    public Thread newThread(Runnable r) {
        Thread t = new Thread(group, r,
                              namePrefix + threadNumber.getAndIncrement(),
                              0);
        if (t.isDaemon())
            t.setDaemon(false);
        if (t.getPriority() != Thread.NORM_PRIORITY)
            t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }
}</code></pre> 
<p><br> Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”</p> 
<p>RejectedExecutionHandler（饱和策略）</p> 
<p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p> 
<p>（1）AbortPolicy：直接抛出异常，默认策略；</p> 
<p>（2）CallerRunsPolicy：用调用者所在的线程来执行任务；</p> 
<p>（3）DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p> 
<p>（4）DiscardPolicy：直接丢弃任务；</p> 
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p> 
<p></p> 
<p>2、ThreadPoolExecutor线程池执行流程</p> 
<p>根据ThreadPoolExecutor源码前面大段的注释，我们可以看出，当试图通过execute方法将一个Runnable任务添加到线程池中时，按照如下顺序来处理：</p> 
<p>（1）如果线程池中的线程数量少于corePoolSize，就创建新的线程来执行新添加的任务；</p> 
<p>（2）如果线程池中的线程数量大于等于corePoolSize，但队列workQueue未满，则将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行（线程池中有线程空闲出来后依次将队列中的任务交付给空闲的线程执行）；</p> 
<p>（3）如果线程池中的线程数量大于等于corePoolSize，且队列workQueue已满，但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务；</p> 
<p>（4）如果线程池中的线程数量等于了maximumPoolSize，就用RejectedExecutionHandler来做拒绝处理</p> 
<p>总结，当有新的任务要处理时，先看线程池中的线程数量是否大于corePoolSize，再看缓冲队列workQueue是否满，最后看线程池中的线程数量是否大于maximumPoolSize</p> 
<p>另外，当线程池中的线程数量大于corePoolSize时，如果里面有线程的空闲时间超过了keepAliveTime，就将其移除线程池</p> 
<p>最后，通过下面的图来看看线程池中的任务调度策略：</p> 
<figure class="image"> 
 <img alt="" src="https://images2.imgbox.com/35/c1/djoKl0gC_o.png"> 
 <figcaption>
   图1 
 </figcaption> 
</figure> 
<p style="text-align:center;"> </p> 
<figure class="image"> 
 <img alt="" src="https://images2.imgbox.com/af/2e/IipYzG7F_o.png"> 
 <figcaption>
   图2 
 </figcaption> 
</figure> 
<p> </p> 
<p>说明：</p> 
<p>在图1中，线程池中有N个任务。"任务1", "任务2", "任务3"这3个任务在执行，而"任务3"到"任务N"在阻塞队列中等待。正在执行的任务，在workers集合中，workers集合包含3个Worker，每一个Worker对应一个Thread线程，Thread线程每次处理一个任务。</p> 
<p>当workers集合中处理完某一个任务之后，会从阻塞队列中取出一个任务来继续执行，如图2所示。图2表示"任务1"处理完毕之后，线程池将"任务4"从阻塞队列中取出，放到workers中进行处理。</p> 
<p></p> 
<p>三、Executors静态工厂创建几种常用线程池<br> Exectors工厂类提供了线程池的初始化接口，主要有如下几种：</p> 
<p>newFixedThreadPool</p> 
<pre><code class="language-java">public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
 
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;(),
                                  threadFactory);
}</code></pre> 
<p><br> 创建一个指定工作线程数的线程池，其中参数 corePoolSize 和 maximumPoolSize 相等，阻塞队列基于LinkedBlockingQueue</p> 
<p>它是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是在线程池空闲时，即线程池中没有可运行任务时，它也不会释放工作线程，还会占用一定的系统资源</p> 
<p>newSingleThreadExecutor</p> 
<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
 
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;(),
                                threadFactory));
}</code></pre> 
<p><br> 初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行，内部使用LinkedBlockingQueue作为阻塞队列</p> 
<p>newCachedThreadPool</p> 
<pre><code class="language-java">public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
 
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;(),
                                  threadFactory);
}</code></pre> 
<p><br> 创建一个可缓存工作线程的线程池，默认存活时间60秒，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列；</p> 
<p>在没有任务执行时，当线程的空闲时间超过keepAliveTime，则工作线程将会终止，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销</p> 
<p>newScheduledThreadPool</p> 
<pre><code class="language-java">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
 
public static ScheduledExecutorService newScheduledThreadPool(
        int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}</code></pre> 
<p><br> 初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据</p> 
<p>注意：</p> 
<p>ScheduledExecutorService#scheduleAtFixedRate() 指的是“以固定的频率”执行，period（周期）指的是两次成功执行之间的时间</p> 
<p>比如，scheduleAtFixedRate(command, 5, 2, second)，第一次开始执行是5s后，假如执行耗时1s，那么下次开始执行是7s后，再下次开始执行是9s后</p> 
<p>而ScheduledExecutorService#scheduleWithFixedDelay()  指的是“以固定的延时”执行，delay（延时）指的是一次执行终止和下一次执行开始之间的延迟</p> 
<p>还是上例，scheduleWithFixedDelay(command, 5, 2, second)，第一次开始执行是5s后，假如执行耗时1s，执行完成时间是6s后，那么下次开始执行是8s后，再下次开始执行是11s后</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/397506879ad0b872eb4cd590b2a28567/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">还不会华为交换机如何恢复出厂设置的，看这里</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e036e33b2c8dfe27c3cd78987e1eeede/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">内部 IP 地址泄露/在Web服务器上发现不必要的文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>