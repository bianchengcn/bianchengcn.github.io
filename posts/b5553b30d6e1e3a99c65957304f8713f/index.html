<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2020 前端面试题总结大全 及 答案 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2020 前端面试题总结大全 及 答案" />
<meta property="og:description" content="1、link和@import的区别 1、link是html的标签，不仅可以加载css还可以定义Rss , rel连接属性；@import是css的语法规则，只能引入样式； 2、加载页面时，link是同时加载的，@impor是页面加载完后才加载 3、link没有兼容性的问题，而@import只在较高版本的浏览器才可以识别 4、link可以通过js插入操作dom，@import 不可以！ 查看更多企业面试真题 2、如何理解js中的原型链 1；每个构造函数都有一个原型对象 2；每个原型对象都有一个指向构造函数的指针 3；每个实例函数都有一个指向原型对象的指针。 4；查找方式是一层一层查找，直至顶层。Object.prototype 3、怎么理解js中的内存泄露 定义：程序不需要的内存，由于某些原因其不会返回到操作系统或者可用内存池中。 内存泄露会导致（运行缓慢 ，高延迟，崩溃）的问题 常见的导致内存泄露的原因有： 1；意外的全局变量 2；被遗忘的计时器或回调函数 3；脱离文档的DOM的引用 4；闭包 4、跨域问题 由于浏览器的同源策略会导致跨域，同源策略又分为 一：DOM同源策略：禁止对不同源页面的DOM进行操作，主要是不同域名的ifram是限制互相访问的 二：xmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起http请求，只要域名 协议 端口有一个不同都被当做不同的域之间的请求，即跨域请求 解决方式： 1、CORS跨域资源共享 后端需要设置Access--Control-Allow-Credentials:true 2、jsonp实现跨域：动态创建script，利用src属性进行跨域 3、 nginx代理跨域 4、nodejs中间件代理跨域 5、WebSokect协跨域 6、window.name&#43;ifram跨域 5、vuex：Vue.js应用程序的状态管理模式&#43;库。 1、state 保存vuex中的数据源，通过this.$store.state获取 2、getters 用于监听state中的值的变化，返回计算后的结果。getter的返回值会根据它的依赖被缓存起来 3、mutations 是修改store中的值得唯一方式 4、action 官方建议提交一个actions，在actions中提交mutations再去修改状态值。 this.$store.dispatch(&#39;add&#39;) //this.$store.commit(&#39;add&#39;) 5、modules 模块化 6、vue的生命周期 Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。 beforeCreate: vue元素的挂载元素el和数据都为undefined，还未初始化； created：vue实例的数据对象data有了，el还没有； beforeMount：vue实例的$el和data都初始化了，但是还挂载在之前的虚拟dom节点上，data.message还未替换； mounted：vue实例挂载完成，data.message成功渲染。 更新前后：data变化时会触发beforeUpdate和updated方法； 销毁前后：beforeDestory和destoryed，在执行destoryed方法后，对data的改变不会触发周期函数，说明vue实例已经解除了事件监听以及dom绑定，但是dom结构依然存在； vue生命周期的作用： 他的生命周期中有多个事件钩子，让我们控制整个vue实例的过程时更容易形成良好的逻辑。 生命周期钩子的一些使用方法： beforeCreate：loading事件，在加载实例时触发。 created：初始化完成事件，异步请求。 mounted：挂载元素，获取dom节点 uptaded：对数据统一处理 beforeDestory：确认事件停止。 nextTick：更新数据后立即操作dom。 7、computed和watch的区别 computed 计算结果并返回，只有当被计算的属性发生改变时才会触发（即：计算属性的结果会被缓存，除非依赖的响应属性变化才会重新及孙） watch 监听某一个值，当被监听的值发生变化时，执行相关操作。（与computed的区别是，watch更加适用于监听某一个值得变化，并做对应操作，比如请求后太接口等。而computed适用于计算已有的值并返回结果。） 监听简单数据类型： data(){ return{ &#39;first&#39;:2 } }, watch:{ first(){ console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/b5553b30d6e1e3a99c65957304f8713f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-04T09:15:23+08:00" />
<meta property="article:modified_time" content="2020-03-04T09:15:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2020 前端面试题总结大全 及 答案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1linkimport_0"></a>1、link和@import的区别</h3> 
<pre><code class="prism language-javascript"><span class="token number">1</span>、link是html的标签，不仅可以加载css还可以定义Rss <span class="token punctuation">,</span> rel连接属性；@<span class="token keyword">import</span>是css的语法规则，只能引入样式；
<span class="token number">2</span>、加载页面时，link是同时加载的，@impor是页面加载完后才加载
<span class="token number">3</span>、link没有兼容性的问题，而@<span class="token keyword">import</span>只在较高版本的浏览器才可以识别
<span class="token number">4</span>、link可以通过js插入操作dom，@<span class="token keyword">import</span> 不可以！
</code></pre> 
<h3><a id="_8"></a>查看更多企业面试真题</h3> 
<p><img src="https://images2.imgbox.com/ac/98/rTgxb89R_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="2js_11"></a>2、如何理解js中的原型链</h3> 
<pre><code class="prism language-javascript"><span class="token number">1</span>；每个构造函数都有一个原型对象

<span class="token number">2</span>；每个原型对象都有一个指向构造函数的指针

<span class="token number">3</span>；每个实例函数都有一个指向原型对象的指针。

<span class="token number">4</span>；查找方式是一层一层查找，直至顶层。Object<span class="token punctuation">.</span>prototype
</code></pre> 
<h3><a id="3js_23"></a>3、怎么理解js中的内存泄露</h3> 
<pre><code class="prism language-javascript">定义：程序不需要的内存，由于某些原因其不会返回到操作系统或者可用内存池中。   内存泄露会导致（运行缓慢 ，高延迟，崩溃）的问题

常见的导致内存泄露的原因有：

<span class="token number">1</span>；意外的全局变量

<span class="token number">2</span>；被遗忘的计时器或回调函数

<span class="token number">3</span>；脱离文档的<span class="token constant">DOM</span>的引用

<span class="token number">4</span>；闭包
</code></pre> 
<h3><a id="4_39"></a>4、跨域问题</h3> 
<pre><code class="prism language-javascript">由于浏览器的同源策略会导致跨域，同源策略又分为

一：<span class="token constant">DOM</span>同源策略：禁止对不同源页面的<span class="token constant">DOM</span>进行操作，主要是不同域名的ifram是限制互相访问的

二：xmlHttpRequest同源策略：禁止使用<span class="token constant">XHR</span>对象向不同源的服务器地址发起http请求，只要域名  协议  端口有一个不同都被当做不同的域之间的请求，即跨域请求

解决方式：

<span class="token number">1</span>、<span class="token constant">CORS</span>跨域资源共享   后端需要设置Access<span class="token operator">--</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials<span class="token punctuation">:</span><span class="token boolean">true</span>

<span class="token number">2</span>、jsonp实现跨域：动态创建script，利用src属性进行跨域

<span class="token number">3</span>、 nginx代理跨域

<span class="token number">4</span>、nodejs中间件代理跨域

<span class="token number">5</span>、WebSokect协跨域

<span class="token number">6</span>、window<span class="token punctuation">.</span>name<span class="token operator">+</span>ifram跨域
</code></pre> 
<h3><a id="5vuexVuejs_63"></a>5、vuex：Vue.js应用程序的状态管理模式+库。</h3> 
<pre><code class="prism language-javascript"><span class="token number">1</span>、state

保存vuex中的数据源，通过<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state获取

 
<span class="token number">2</span>、getters

用于监听state中的值的变化，返回计算后的结果。getter的返回值会根据它的依赖被缓存起来


<span class="token number">3</span>、mutations

是修改store中的值得唯一方式

<span class="token number">4</span>、action 

官方建议提交一个actions，在actions中提交mutations再去修改状态值。 <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'add'</span><span class="token punctuation">)</span>

<span class="token comment">//this.$store.commit('add')</span>

<span class="token number">5</span>、modules 模块化
</code></pre> 
<h3><a id="6vue_89"></a>6、vue的生命周期</h3> 
<pre><code class="prism language-javascript">Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。

beforeCreate<span class="token punctuation">:</span> vue元素的挂载元素el和数据都为undefined，还未初始化；


created：vue实例的数据对象data有了，el还没有；

beforeMount：vue实例的$el和data都初始化了，但是还挂载在之前的虚拟dom节点上，data<span class="token punctuation">.</span>message还未替换；

mounted：vue实例挂载完成，data<span class="token punctuation">.</span>message成功渲染。

更新前后：data变化时会触发beforeUpdate和updated方法；

销毁前后：beforeDestory和destoryed，在执行destoryed方法后，对data的改变不会触发周期函数，说明vue实例已经解除了事件监听以及dom绑定，但是dom结构依然存在；

vue生命周期的作用：

他的生命周期中有多个事件钩子，让我们控制整个vue实例的过程时更容易形成良好的逻辑。

生命周期钩子的一些使用方法：

beforeCreate：loading事件，在加载实例时触发。

created：初始化完成事件，异步请求。

mounted：挂载元素，获取dom节点

uptaded：对数据统一处理

beforeDestory：确认事件停止。

nextTick：更新数据后立即操作dom。
</code></pre> 
<h3><a id="7computedwatch_126"></a>7、computed和watch的区别</h3> 
<pre><code class="prism language-javascript">computed

计算结果并返回，只有当被计算的属性发生改变时才会触发（即：计算属性的结果会被缓存，除非依赖的响应属性变化才会重新及孙）

watch
 监听某一个值，当被监听的值发生变化时，执行相关操作。（与computed的区别是，watch更加适用于监听某一个值得变化，并做对应操作，比如请求后太接口等。而computed适用于计算已有的值并返回结果。）

监听简单数据类型：
<span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span><span class="token punctuation">{<!-- --></span>
        <span class="token string">'first'</span><span class="token punctuation">:</span><span class="token number">2</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    watch<span class="token punctuation">:</span><span class="token punctuation">{<!-- --></span>
      <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

</code></pre> 
<h3><a id="8jsonxml_150"></a>8、json和xml数据的区别</h3> 
<pre><code class="prism language-javascript"><span class="token number">1</span>、数据体积方面：xml是重量级的，json是轻量级的，传递的速度更快些。。

<span class="token number">2</span>、数据传输方面：xml在传输过程中比较占带宽，json占带宽少，易于压缩。

<span class="token number">3</span>、数据交互方面：json与javascript的交互更加方便，更容易解析处理，更好的进行数据交互

<span class="token number">4</span>、数据描述方面：json对数据的描述性比xml较差

<span class="token number">5</span>、xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。
</code></pre> 
<h3><a id="9httphttps_163"></a>9、http和https的区别</h3> 
<pre><code class="prism language-javascript">Http：超文本传输协议（Http，HyperText Transfer Protocol<span class="token punctuation">)</span>是互联网上应用最为广泛的一种网络协议。设计Http最初的目的是为了提供一种发布和接收<span class="token constant">HTML</span>页面的方法。它可以使浏览器更加高效。Http协议是以明文方式发送信息的，如果黑客截取了Web浏览器和服务器之间的传输报文，就可以直接获得其中的信息。

Https：是以安全为目标的Http通道，是Http的安全版。Https的安全基础是<span class="token constant">SSL</span>。<span class="token constant">SSL</span>协议位于<span class="token constant">TCP</span><span class="token operator">/</span><span class="token constant">IP</span>协议与各种应用层协议之间，为数据通讯提供安全支持。<span class="token constant">SSL</span>协议可分为两层：<span class="token constant">SSL</span>记录协议（<span class="token constant">SSL</span> Record Protocol），它建立在可靠的传输协议（如<span class="token constant">TCP</span>）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。<span class="token constant">SSL</span>握手协议（<span class="token constant">SSL</span> Handshake Protocol），它建立在<span class="token constant">SSL</span>记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

<span class="token constant">HTTP</span>与<span class="token constant">HTTPS</span>的区别

<span class="token number">1</span>、<span class="token constant">HTTP</span>是超文本传输协议，信息是明文传输，<span class="token constant">HTTPS</span>是具有安全性的<span class="token constant">SSL</span>加密传输协议。

<span class="token number">2</span>、<span class="token constant">HTTPS</span>协议需要ca申请证书，一般免费证书少，因而需要一定费用。

<span class="token number">3</span>、<span class="token constant">HTTP</span>和<span class="token constant">HTTPS</span>使用的是完全不同的连接方式，用的端口也不一样。前者是<span class="token number">80</span>，后者是<span class="token number">443</span>。

<span class="token number">4</span>、<span class="token constant">HTTP</span>连接是无状态的，<span class="token constant">HTTPS</span>协议是由<span class="token constant">SSL</span><span class="token operator">+</span><span class="token constant">HTTP</span>协议构建的可进行加密传输、身份认证的网络协议，安全性高于<span class="token constant">HTTP</span>协议。

https的优点

尽管<span class="token constant">HTTPS</span>并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但<span class="token constant">HTTPS</span>仍是现行架构下最安全的解决方案，主要有以下几个好处：

<span class="token number">1</span>）使用<span class="token constant">HTTPS</span>协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

<span class="token number">2</span>）<span class="token constant">HTTPS</span>协议是由<span class="token constant">SSL</span><span class="token operator">+</span><span class="token constant">HTTP</span>协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

<span class="token number">3</span>）<span class="token constant">HTTPS</span>是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

<span class="token number">4</span>）谷歌曾在<span class="token number">2014</span>年<span class="token number">8</span>月份调整搜索引擎算法，并称“比起同等<span class="token constant">HTTP</span>网站，采用<span class="token constant">HTTPS</span>加密的网站在搜索结果中的排名将会更高”。

Https的缺点

<span class="token number">1</span>）Https协议握手阶段比较费时，会使页面的加载时间延长近。

<span class="token number">2</span>）Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响；

<span class="token number">3</span>）<span class="token constant">SSL</span>证书通常需要绑定<span class="token constant">IP</span>，不能在同一<span class="token constant">IP</span>上绑定多个域名，IPv4资源不可能支撑这个消耗。

<span class="token number">4</span>）Https协议的加密范围也比较有限。最关键的，<span class="token constant">SSL</span>证书的信用链体系并不安全，特别是在某些国家可以控制<span class="token constant">CA</span>根证书的情况下，中间人攻击一样可行。
</code></pre> 
<h3><a id="10vue_router__203"></a>10、vue router 跳转方式</h3> 
<p><strong>1、this.$router.push()</strong></p> 
<pre><code class="prism language-javascript">跳转到不同的url，但这个方法会向history栈添加一个记录，点击后退会返回到上一个页面。
 <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>path<span class="token punctuation">:</span> <span class="token string">'/home/sort/detail'</span><span class="token punctuation">,</span>query<span class="token punctuation">:</span><span class="token punctuation">{<!-- --></span>id<span class="token punctuation">:</span> <span class="token string">'abc'</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>     
 获取参数 <span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>userId<span class="token punctuation">}</span><span class="token punctuation">}</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>name<span class="token punctuation">:</span> <span class="token string">'detail'</span><span class="token punctuation">,</span>params<span class="token punctuation">:</span><span class="token punctuation">{<!-- --></span>id<span class="token punctuation">:</span> <span class="token string">'abc'</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
获取参数：<span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>userId<span class="token punctuation">}</span><span class="token punctuation">}</span>
ps<span class="token punctuation">:</span>
</code></pre> 
<p><strong>query和params 的区别：</strong></p> 
<p><strong>用法上</strong></p> 
<pre><code class="prism language-javascript">query要用path来引入，params要用name来引入：eg

<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
   name<span class="token punctuation">:</span><span class="token string">"detail"</span><span class="token punctuation">,</span>
   params<span class="token punctuation">:</span><span class="token punctuation">{<!-- --></span>
    name<span class="token punctuation">:</span><span class="token string">'nameValue'</span><span class="token punctuation">,</span>
    code<span class="token punctuation">:</span><span class="token number">10011</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>展示上的</strong></p> 
<pre><code class="prism language-javascript">　query更加类似于我们ajax中<span class="token keyword">get</span>传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示

<span class="token number">1</span>、<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。

<span class="token number">2</span>、<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>

相对于当前页面向前或向后跳转多少个页面<span class="token punctuation">,</span>类似 window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>。n可为正数可为负数。正数返回上一个页面
</code></pre> 
<p><strong>声明式：</strong></p> 
<pre><code class="prism language-javascript"><span class="token number">1</span><span class="token punctuation">)</span> 根据路由路径（<span class="token operator">/</span>home<span class="token operator">/</span>sort<span class="token operator">/</span>detail）跳转 <span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token punctuation">:</span>to<span class="token operator">=</span><span class="token string">"{path: '/home/sort/detail', query:{id: 'abc'}}"</span><span class="token operator">&gt;</span>点击查看子页面<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>

<span class="token number">2</span><span class="token punctuation">)</span> 根据路由名称（detail）跳转 <span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token punctuation">:</span>to<span class="token operator">=</span><span class="token string">"{name: 'detail', params:{id: 'abc'}}"</span><span class="token operator">&gt;</span>点击查看子页面<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>    <span class="token punctuation">:</span>to<span class="token operator">=</span><span class="token string">""</span> 可以实现绑定动态的 路由 和 参数
</code></pre> 
<h3><a id="_256"></a>查看更多企业面试真题</h3> 
<p><img src="https://images2.imgbox.com/b5/19/gzF3znL9_o.jpg" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21e752bdd4e7bfc4ea8ffcf594acc68b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Anaconda3一些常用命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/344ec6fc381f7c75df2efd038bb9d829/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是扁平化设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>