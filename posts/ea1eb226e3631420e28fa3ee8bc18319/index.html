<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端工程化基础（四）：Git代码版本控制工具详解 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端工程化基础（四）：Git代码版本控制工具详解" />
<meta property="og:description" content="Git版本控制工具详解 认识版本控制（版本控制） 是维护 工程蓝图的标准做法，能追踪工程蓝图从诞生一直到定案的过程版本控制也是 一种软件工程技巧，借此能在软件开发的过程中，确保不同的人所编辑的同一程序都能得到同步 版本控制的功能 不同版本的存储管理 一个项目不断进行版本迭代，来修复之前的一些问题，增加新的功能等如果手动维护的话，效率很低 重大版本的备份维护恢复之前的项目版本记录项目的点点滴滴多人开发的代码合并 集中式版本控制 CVS和SVN属于集中式版本控制系统
他们的主要特点是 单一的集中管理的服务器，保存所有文件修订版本系统开发人员通过客户端 连接到这台服务器，取出最新的文件或者提交更新但是存在一个核心问题 ：中央服务器不能出现故障 如果宕机一个小时，在这一个小时之内，谁都无法提交更新，也就无法协同工作如果中心数据库所在的磁盘发生了损坏，且没有做备份，将会丢失所有的数据 项目的历史版本都会存在于中央服务器中 分布式版本控制 Git是属于分布式版本控制系统
客户端并不只提取最新版本的文件快照，而是把 代码仓库完整的镜像下来，包括完整的历史记录
这么一来，任何一处协同工作用的 服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复
因为每一次克隆操作，实际上都是一次对代码仓库的完整备份
与中央服务器不同的是，项目的历史版本，都会被克隆到协作开发的本地电脑，即每台电脑上都有备份
Bash-CMD-GUI区别 Bash是Unix shell的一种， Linux与Mac OS X都将它作为默认的shell Git Bash 就是一个shell，是 windows下的命令行工具，可以执行Linux命令Git Bash是基于CMD的，在CMD的基础上增加了一些新的命令与功能 Git CMD 命令提示符（CMD）是Windows操作系统上的命令行解释程序其实就是 windows上面的CMD Git GUI 针对于不喜欢命令行界面的人提供了一个 图形用户界面来运行Git命令 获取Git仓库 git clone/git init 当从零到一创建一个项目的时候，可以使用 git init创建一个新的仓库 会生成一个.git文件 运行 git add .用于告诉git 管理当前目录下的所有文件运行 git commit -m &#34;描述&#34;将本地文件提交到本地的git仓库中 但没有提交到远程服务器中 当已经有一个项目，就可以复制远程仓库的地址，运行 git clone xxxxx 文件状态的划分 Git在管理项目文件的时候，会对项目划分为以下几种状态 **未跟踪：**一般在已经被Git管理的项目中，创建新文件的情况下**已跟踪：**当我们在项目文件中运行 git add ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ea1eb226e3631420e28fa3ee8bc18319/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-01T02:11:39+08:00" />
<meta property="article:modified_time" content="2024-02-01T02:11:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端工程化基础（四）：Git代码版本控制工具详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Git_0"></a>Git版本控制工具详解</h2> 
<h3><a id="_2"></a>认识版本控制（版本控制）</h3> 
<ul><li>是维护 <strong>工程蓝图</strong>的标准做法，能追踪工程蓝图从诞生一直到定案的过程</li><li>版本控制也是 <strong>一种软件工程技巧</strong>，借此能在软件开发的过程中，<strong>确保不同的人所编辑的同一程序都能得到同步</strong></li></ul> 
<h3><a id="_7"></a>版本控制的功能</h3> 
<ul><li>不同版本的存储管理 
  <ul><li>一个项目不断进行版本迭代，来修复之前的一些问题，增加新的功能等</li><li>如果手动维护的话，效率很低</li></ul> </li><li>重大版本的备份维护</li><li>恢复之前的项目版本</li><li>记录项目的点点滴滴</li><li>多人开发的代码合并</li></ul> 
<h3><a id="_17"></a>集中式版本控制</h3> 
<blockquote> 
 <p>CVS和SVN属于集中式版本控制系统</p> 
</blockquote> 
<ul><li>他们的主要特点是 <strong>单一的集中管理的服务器，保存所有文件修订版本</strong></li><li>系统开发人员通过客户端 <strong>连接到这台服务器，取出最新的文件或者提交更新</strong></li><li>但是存在一个核心问题 ：<strong>中央服务器不能出现故障</strong> 
  <ul><li>如果宕机一个小时，在这一个小时之内，谁都无法提交更新，也就无法协同工作</li><li>如果中心数据库所在的磁盘发生了损坏，且没有做备份，将会丢失所有的数据</li></ul> </li><li><strong>项目的历史版本都会存在于中央服务器中</strong></li></ul> 
<h3><a id="_28"></a>分布式版本控制</h3> 
<ul><li> <p><strong>Git是属于分布式版本控制系统</strong></p> </li><li> <p>客户端并不只提取最新版本的文件快照，而是把 <strong>代码仓库完整的镜像下来，包括完整的历史记录</strong></p> </li><li> <p>这么一来，任何一处协同工作用的 <strong>服务器发生故障</strong>，<strong>事后都可以用任何一个镜像出来的本地仓库恢复</strong></p> </li><li> <p><strong>因为每一次克隆操作，实际上都是一次对代码仓库的完整备份</strong></p> </li><li> <p>与中央服务器不同的是，<strong>项目的历史版本，都会被克隆到协作开发的本地电脑，即每台电脑上都有备份</strong></p> </li></ul> 
<h3><a id="BashCMDGUI_40"></a>Bash-CMD-GUI区别</h3> 
<ul><li>Bash是<strong>Unix shell的一种</strong>， <strong>Linux与Mac OS X都将它作为默认的shell</strong> 
  <ul><li>Git Bash 就是一个shell，是 <strong>windows下的命令行工具，可以执行Linux命令</strong></li><li>Git Bash是基于CMD的，<strong>在CMD的基础上增加了一些新的命令与功能</strong></li></ul> </li><li><strong>Git CMD</strong> 
  <ul><li>命令提示符（CMD）是<strong>Windows操作系统上的命令行解释程序</strong></li><li>其实就是 windows上面的CMD</li></ul> </li><li>Git GUI 
  <ul><li>针对于不喜欢命令行界面的人</li><li>提供了一个 <strong>图形用户界面</strong>来运行Git命令</li></ul> </li></ul> 
<h3><a id="Git_git_clonegit_init_52"></a>获取Git仓库 git clone/git init</h3> 
<ul><li>当从零到一创建一个项目的时候，可以使用 <code>git init</code>创建一个新的仓库 
  <ul><li>会生成一个.git文件</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/41/93/z2xL0Dm9_o.png" alt="image.png"></p> 
<ul><li>运行 <code>git add .</code>用于告诉git 管理当前目录下的所有文件</li><li>运行 <code>git commit -m "描述"</code>将本地文件提交到本地的git仓库中 
  <ul><li>但没有提交到远程服务器中</li></ul> </li><li>当已经有一个项目，就可以复制远程仓库的地址，运行 <code>git clone xxxxx</code></li></ul> 
<h3><a id="_64"></a>文件状态的划分</h3> 
<ul><li><strong>Git在管理项目文件的时候，会对项目划分为以下几种状态</strong> 
  <ul><li>**未跟踪：**一般在已经被Git管理的项目中，创建新文件的情况下</li><li>**已跟踪：**当我们在项目文件中运行 <code>git add .</code>的命令后，就会将文件变为已跟踪的状态 
    <ul><li>**staged：**暂缓区中的文件状态，一般是在运行完 <code>git add .</code>命令后，就会放入暂缓区中</li><li>**Unmodified：**运行完 <code>git commit -m ""</code>命令后，文件所处的状态，代表已经将代码提交到了本地的git仓库</li><li>**Modified：**当对文件进行修改时候，文件的状态</li></ul> </li></ul> </li><li>运行命令顺序为 
  <ul><li><code>git add .</code></li><li><code>git commit -m ""</code></li><li>同时可以通过 <code>git commit -a -m ""</code>合并成一行代码</li></ul> </li></ul> 
<h3><a id="git_status_77"></a>检查文件状态-git status</h3> 
<ul><li>在项目目录下，输入命令 `git status，可以查看项目中的文件状态</li></ul> 
<p><img src="https://images2.imgbox.com/3a/9c/BUEttn4I_o.png" alt="image.png"></p> 
<h3><a id="git_83"></a>git忽略文件</h3> 
<blockquote> 
 <p>项目中存在特殊的文件（比如node_modules等），不希望git对其进行跟踪和管理的，可以对其进行忽略</p> 
</blockquote> 
<ul><li>创建 <strong>.gitignore</strong>文件即可啊，在文件中写入需要忽略的文件 
  <ul><li>实际开发中，不需要手动创建，通常框架的脚手架会自动生成</li><li>必要时候可以自己添加即可</li><li>在文件中写入的文件，使用 <code>git status</code>将不会查看该文件状态</li></ul> </li></ul> 
<pre><code class="prism language-.gitignore">test.js
</code></pre> 
<ul><li>在 <strong>github</strong>中有一个 <strong>gitignore</strong>项目，可以查看开发项目需要忽略的文件</li></ul> 
<h3><a id="Git_98"></a>Git的校验和</h3> 
<p><img src="https://images2.imgbox.com/53/29/4hrAKBNQ_o.png" alt="image.png"></p> 
<ul><li>当我们输入 <code>git log</code>命令的时候，就可以查看到 commit后面跟着的字符串，这个字符串即为 <strong>校验和</strong></li><li><strong>校验和</strong>可以当作本次提交的唯一标识符，可以通过查看本次提交对文件的修改</li><li><strong>校验和是通过SHA-1散列的算法生成的</strong></li></ul> 
<h3><a id="__git_log_106"></a>查看提交的历史 - git log</h3> 
<ul><li>前面我们知道，可以通过 <code>git log</code>命令查看提交记录</li></ul> 
<p><img src="https://images2.imgbox.com/ca/95/6yxa0H0F_o.png" alt="image.png"></p> 
<ul><li>同时为了方便查看，我们可以使用 <code>git log --pretty=oneline</code></li></ul> 
<p><img src="https://images2.imgbox.com/09/cc/tt1vq6Ga_o.png" alt="image.png"></p> 
<ul><li>通常在实际开发过程中，会有多个分支的出现，此时使用 <code>git log --pretty=oneline --grapg</code> 进行查看</li></ul> 
<p><img src="https://images2.imgbox.com/4a/f6/F3h0fdU8_o.png" alt="image.png"></p> 
<h3><a id="__git_reset_120"></a>版本回退 - git reset</h3> 
<blockquote> 
 <p>当我们对一个项目进行了多次的提交，想要回退到之前的版本，可以使用git reset命令进行操作</p> 
</blockquote> 
<ul><li>在上面的学习中，我们可以看到在最后一次提交后，commit的校验和后面都跟着一个 <strong>HEAD–&gt;master</strong></li><li>而 <strong>git reset</strong>实际上就是在 修改 <strong>HEAD</strong>的指向 
  <ul><li><code>git reset --hard HEAD^</code>回退到上一版本</li><li><code>git reset --hard xxxxx</code>回退到指定的版本</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/a2/0c/e0AvqR6E_o.png" alt="image.png"></p> 
<ul><li>但是当我们回退到了指定的版本后，再通过 <code>git log</code>查看提交记录，会发现丢失了部分的提交记录</li></ul> 
<p><img src="https://images2.imgbox.com/fd/12/k7Hcx1Yg_o.png" alt="image.png"></p> 
<ul><li>此时我们若想回到最新的提交记录，需要使用 <code>git reflog</code>命令进行查看所有的提交记录</li></ul> 
<p><img src="https://images2.imgbox.com/5e/a6/NYjPIOn5_o.png" alt="image.png"></p> 
<ul><li>之后通过 <code>git reset --hard xxxxx</code>命令即可恢复到最新的版本</li></ul> 
<h3><a id="_141"></a>远程仓库的操作</h3> 
<blockquote> 
 <p>目前常用的三方远程仓库有：GitHub、Gitee以及GitLab</p> 
 <p>接下来我们以Gitee为例子，进行远程仓库的学习</p> 
</blockquote> 
<h4><a id="Gitee_147"></a>创建Gitee账号以及创建一个仓库</h4> 
<ul><li>登录<a href="https://gitee.com/" rel="nofollow">Gitee官网</a>进行账号注册</li><li>注册成功后，登录账号来到首页，创建一个新的仓库</li></ul> 
<p><img src="https://images2.imgbox.com/c7/1e/Dw3A7jCs_o.png" alt="image.png"></p> 
<ul><li>输入仓库的名称，仓库的介绍等信息，之后选择创建仓库</li></ul> 
<p><img src="https://images2.imgbox.com/79/b6/bNiaZfwN_o.png" alt="image.png"></p> 
<ul><li>此时我们就完成了一个仓库的创建</li></ul> 
<p><img src="https://images2.imgbox.com/a7/f5/1WmpJh3A_o.png" alt="image.png"></p> 
<h4><a id="__git_clone_162"></a>远程仓库拉取/提交代码 - git clone</h4> 
<blockquote> 
 <p>当我们有了一个远程仓库的地址，可以使用 <code>git clone</code>的方式将仓库中的代码克隆下来</p> 
 <p>但是在克隆的前，需要进行验证</p> 
</blockquote> 
<h5><a id="_168"></a>远程仓库的验证-凭证</h5> 
<blockquote> 
 <p>通过HTTPS协议克隆代码</p> 
</blockquote> 
<ul><li> <p><strong>因为HTTP协议是无状态的连接</strong>，<strong>所以每一次连接都需要输入用户名和密码</strong></p> </li><li> <p>但是 <strong>Git拥有一个凭证系统，来保证我们只需要第一次输入凭证即可</strong></p> </li><li> <p>当我们使用 <code>git clone</code>克隆代码的时候，会出现以下现象</p> </li></ul> 
<p><img src="https://images2.imgbox.com/b5/a7/okzxhpFu_o.png" alt="image.png"></p> 
<ul><li>当我们输入完用户密码之后，Git就会将凭证自动保存下来，在后续的操作中，不用再输入凭证</li><li>随后我们就可以将修改完的代码进行提交 
  <ul><li><code>git add .</code></li><li><code>git commit -m "描述"</code></li><li><code>git push</code></li></ul> </li></ul> 
<h4><a id="push_186"></a>本地仓库与远程仓库创建连接并push代码</h4> 
<blockquote> 
 <p>当我们本地有一个项目，且通过 <code>git init</code>初始化了本地的仓库</p> 
 <p>同时，再Gitee上面，有一个线上仓库</p> 
 <p>那么，我们想让这两个仓库创建连接，应当怎么做</p> 
</blockquote> 
<ul><li>首先进入到项目目录中，通过输入 <code>git remote add '远程仓库地址'</code></li><li>这样就建立了相应的连接</li><li>但是我们要清楚，本地仓库中有可能存在多个分支，远程仓库中也存在很多的分支</li></ul> 
<p><img src="https://images2.imgbox.com/b2/56/1RXzCGdR_o.png" alt="image.png"></p> 
<ul><li>因此，为了顺利拉取提交代码，需要指定远程仓库的分支 <code>git pull &lt;remote&gt; &lt;branch&gt;</code></li></ul> 
<h5><a id="_202"></a>本地分支的上游分支</h5> 
<blockquote> 
 <p>每次拉取/提交代码的时候，都需要指定远程仓库的分支，会很麻烦，因此我们可以设置一下本地分支的上游分支，可以省略重复的步骤</p> 
</blockquote> 
<ul><li> <p>通过输入命令 <code>git branch --set-upstream-to=&lt;远程仓库&gt;/&lt;远程仓库的分支&gt; &lt;本地仓库的分支&gt;</code></p> </li><li> <p>例如 <code>git branch --set-upstream-to=origin/master master</code></p> </li><li> <p>这样就设置了本地仓库的上游分支，可以直接通过 pull/push对代码进行提交以及拉取</p> </li></ul> 
<h5><a id="_212"></a>拒绝合并不相干的历史</h5> 
<blockquote> 
 <p>通常我们做了以上操作后，拉取代码的时候依旧会发生错误</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8f/eb/tuRkUOLS_o.png" alt="image.png"></p> 
<ul><li>在过去 <code>git merge</code>允许将两个没有共同基础的分支进行合并 
  <ul><li>比如，我在本地创建了一个本地仓库，在Gitee上创建了一个远程仓库，这两个分支就没有共同的基础</li><li>这样造成 <strong>新创建的项目可能被一个维护者合并了很多没有必要的历史，到一个已经存在的项目中</strong></li></ul> </li><li>而在 Git2.9版本之后，对 <strong>git merge</strong>进行了纠正，而我们可以通过 <code>git merge --allow-unrelated-histories</code>来恢复之前的操作</li><li>这样我们就可以正常的拉取代码了</li></ul> 
<h3><a id="Gittag_224"></a>Git标签（tag）</h3> 
<blockquote> 
 <p>目的就是在某一个重大版本，打上版本的标签</p> 
</blockquote> 
<h4><a id="_228"></a>创建标签</h4> 
<ul><li>创建轻量标签 <code>git tag v1.0.0</code></li><li>创建附注标签 <code>git tag -a v1.0.1 -m "附注标签"</code></li></ul> 
<h4><a id="_233"></a>查看标签</h4> 
<ul><li>查看简单的标签 <code>git tag</code></li></ul> 
<p><img src="https://images2.imgbox.com/00/b7/v2HT7WuX_o.png" alt="image.png"></p> 
<ul><li>查看某一个tag的详细信息 <code>git show v1.0.0</code></li></ul> 
<p><img src="https://images2.imgbox.com/3a/48/QZcRdshJ_o.png" alt="image.png"></p> 
<h4><a id="tag_243"></a>提交tag</h4> 
<ul><li>提交某一个<strong>tag</strong> <code>git push origin v1.0.1</code></li><li>提交所有的<strong>tag</strong> <code>git push origin tags</code></li></ul> 
<h4><a id="tag_248"></a>删除tag</h4> 
<ul><li>删除本地的<strong>tag</strong> <code>git tag -d v1.0.0</code></li><li>删除远程的<strong>tag</strong> <code>git push origin -d v1.0.1</code></li></ul> 
<h4><a id="tag_253"></a>检出tag</h4> 
<blockquote> 
 <p>回退到某一个tag的版本</p> 
</blockquote> 
<ul><li>使用 <code>git checkout v1.0.0</code>即可</li></ul> 
<h3><a id="GitGit_259"></a>Git提交对象（Git原理）</h3> 
<blockquote> 
 <p>前面我们对Git的基本操作进行了学习，那么它的底层原理是怎么样的</p> 
</blockquote> 
<ul><li>我们从0-1创建一个项目，首先需要使用 <code>git init</code>初始化本地仓库 
  <ul><li>在项目文件夹下面会自动生成一个 <strong>.git</strong>的隐藏文件夹</li><li>而我们项目的文件就会保存在 <strong>.git/objects</strong>文件夹下面</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/12/44/qv019pFO_o.png" alt="image.png"></p> 
<ul><li>我们在项目中新增一个 <strong>test.js</strong>文件，其中写入 <code>console.log(123)</code>代码 
  <ul><li>此时objects文件夹中没有变化</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/3c/12/jMDyCaLv_o.png" alt="image.png"></p> 
<ul><li>当我们运行 <code>git add .</code>命令后，会生成一个文件夹 
  <ul><li>文件夹里面会包含一长串的字符串</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/34/f2/6O09o2nl_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><img src="https://images2.imgbox.com/ac/f1/HQgYStQF_o.png" alt="image.png"></p> 
<ul><li>我们可以通过 <code>git cat-file -p 文件夹名称+文件名称</code>查看这个文件中的具体内容 
  <ul><li><code>git cat-file -p 97eb</code></li><li>由此我们可以知道，<code>git add .</code>命令就会将我们的文件转成二进制文件保存在 <strong>objects文件夹中</strong></li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/11/6e/MHxLN8oZ_o.png" alt="image.png"></p> 
<ul><li>当我们执行 <code>git commit -m "描述"</code>命令 
  <ul><li>会生成两个文件夹，41和e6</li><li>分别查看两个二进制文件，会发现在e6文件中，有一个tree 指向了41文件</li><li>而41 文件右指向了97中的文件</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/ae/dd/IJvcaRcE_o.png" alt="image.png"></p> 
<ul><li>可以通过以下图形，进行理解</li></ul> 
<p><img src="https://images2.imgbox.com/25/a4/gdp8GRoW_o.png" alt="image.png"></p> 
<ul><li>多次提交</li></ul> 
<p><img src="https://images2.imgbox.com/bf/0d/i5645gQD_o.png" alt="image.png"></p> 
<h3><a id="Git_master_302"></a>Git master分支</h3> 
<ul><li>我们可以使用 <code>git branch 分支名称</code>来创建一个分支：例如创建一个 dev分支 <code>git branch dev</code></li><li>而Git实现分支的切换，实际上是通过控制<strong>HEAD的指向进行控制的</strong></li></ul> 
<p><img src="https://images2.imgbox.com/ee/d9/sOK26rUW_o.png" alt="image.png"></p> 
<ul><li>我们可以使用 <code>git checkout dev</code>来切换分支</li></ul> 
<p><img src="https://images2.imgbox.com/9c/51/wSD4UxdM_o.png" alt="image.png"></p> 
<ul><li>当我们在 dev分支进行了改动，并执行了 <code>git add. git commit -m "描述"</code>命令，会发生什么</li></ul> 
<p><img src="https://images2.imgbox.com/cd/93/J9Oor46v_o.png" alt="image.png"></p> 
<ul><li>同时我们可以使用一条命令创建分支的同时，并切换过去 <code>git checkout -b prod</code>，这样git的分支就切换到了 <strong>prod</strong>上面</li></ul> 
<h4><a id="_319"></a>为什么需要使用分支</h4> 
<ul><li>我们在开发一个项目的时候，通常默认会在 <strong>master分支下进行开发</strong> 
  <ul><li>当开发到了一定进展的时候，就会发布，并打上tag标签</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/f9/93/KJCPeQzZ_o.png" alt="image.png"></p> 
<ul><li>但是上线的 <strong>v1.0.0</strong>版本，此时发现了bug，此时，就需要创建一条新的分支hotfix，用于修复bug</li></ul> 
<p><img src="https://images2.imgbox.com/6a/36/NvPAaM6l_o.png" alt="image.png"></p> 
<ul><li>同时在后续的版本中，需要将<strong>master</strong>分支和 <strong>hotfix</strong>分支的代码进行合并操作</li><li>首先切换到主分支 <code>git checkout master</code></li><li>而后通过命令 <code>git merge hotfix</code>进行代码的合并，并提交代码</li></ul> 
<p><img src="https://images2.imgbox.com/0a/cd/kc03HhIF_o.png" alt="image.png"></p> 
<h4><a id="_336"></a>查看和删除分支</h4> 
<ul><li>查看分支 <code>git branch</code></li></ul> 
<p><img src="https://images2.imgbox.com/2d/dc/FnLfDH2W_o.png" alt="image.png"></p> 
<ul><li>查看每个分支的最后一次提交 <code>git branch -v</code></li></ul> 
<p><img src="https://images2.imgbox.com/29/81/QvS5rV8t_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<ul><li>删除一个分支 <code>git branch -d 分支名称</code> 
  <ul><li><strong>注意删除的只是这个指针，所提交的文件不会删除</strong></li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/74/ea/bzASPgVB_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fcb6188fef8ee33711755efe0c415fdb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">操作系统（8）---进程的同步与互斥以及信号量机制（万字总结~）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c3f7703962e6872aa29f1c8c65168ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人工智能时代：AI提示工程的奥秘 —— 驾驭大语言模型的秘密武器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>