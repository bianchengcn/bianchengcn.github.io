<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UE4读写JSON数据介绍 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="UE4读写JSON数据介绍" />
<meta property="og:description" content="JSON 语法是 JavaScript 对象表示法语法的子集。
数据在名称/值对中：名称是字符串，使用双引号表示。值可以是：数字（整数或浮点数），字符串（在双引号中）,数组（在方括号中）,对象（在花括号中），true/false/null。数据由逗号分隔：花括号保存对象：对象可以包含各种数据，包括数组。方括号保存数组：数字可以包含对象。 使用中，json有以下三种结构：
对象：{&#34;Name&#34;:&#34;ChenHong&#34;,&#34;Age&#34;:24}数组：比如：[{&#34;Name&#34;:&#34;ChenHong&#34;,&#34;Age&#34;:24},{&#34;Name&#34;:&#34;LiuHong&#34;,&#34;Age&#34;:25}]值：{&#34;Name&#34;:&#34;ChenHong&#34;, &#34;Birthday&#34;:{&#34;Month&#34;:8,&#34;Day&#34;:26}}，类似于对象嵌套对象. 很多人疑惑{}和[]形式的区别。看到一段很经典的总结：大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。
JsonTests.cpp介绍许多 Json读写例子：
// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved. #include &#34;CoreMinimal.h&#34; #include &#34;Misc/AutomationTest.h&#34; #include &#34;Policies/CondensedJsonPrintPolicy.h&#34; #include &#34;Serialization/JsonTypes.h&#34; #include &#34;Serialization/JsonReader.h&#34; #include &#34;Policies/PrettyJsonPrintPolicy.h&#34; #include &#34;Serialization/JsonSerializer.h&#34; #if WITH_DEV_AUTOMATION_TESTS /** * FJsonAutomationTest * Simple unit test that runs Json&#39;s in-built test cases */ IMPLEMENT_SIMPLE_AUTOMATION_TEST(FJsonAutomationTest, &#34;System.Engine.FileSystem.JSON&#34;, EAutomationTestFlags::ApplicationContextMask | EAutomationTestFlags::SmokeFilter ) typedef TJsonWriterFactory&lt; TCHAR, TCondensedJsonPrintPolicy&lt;TCHAR&gt; &gt; FCondensedJsonStringWriterFactory; typedef TJsonWriter&lt; TCHAR, TCondensedJsonPrintPolicy&lt;TCHAR&gt; &gt; FCondensedJsonStringWriter; typedef TJsonWriterFactory&lt; TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt; &gt; FPrettyJsonStringWriterFactory; typedef TJsonWriter&lt; TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt; &gt; FPrettyJsonStringWriter; /** * Execute the Json test cases * * @return	true if the test was successful, false otherwise */ bool FJsonAutomationTest::RunTest(const FString&amp; Parameters) { // Null Case { const FString InputString = TEXT(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/fa51841e2b374257ab9f0a4699d58b1b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-11T10:30:07+08:00" />
<meta property="article:modified_time" content="2019-04-11T10:30:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UE4读写JSON数据介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>JSON 语法是 JavaScript 对象表示法语法的子集。</p> 
<ul><li>数据在名称/值对中：名称是字符串，使用双引号表示。值可以是：数字（整数或浮点数），字符串（在双引号中）,数组（在方括号中）,对象（在花括号中），true/false/null。</li><li>数据由逗号分隔：</li><li>花括号保存对象：对象可以包含各种数据，包括数组。</li><li>方括号保存数组：数字可以包含对象。</li><li> <p>使用中，json有以下三种结构：</p> </li><li>对象：{"Name":"ChenHong","Age":24}</li><li>数组：比如：[{"Name":"ChenHong","Age":24},{"Name":"LiuHong","Age":25}]</li><li>值：{"Name":"ChenHong", "Birthday":{"Month":8,"Day":26}}，类似于对象嵌套对象.</li><li> <p> 很多人疑惑{}和[]形式的区别。看到一段很经典的总结：<a href="http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" rel="nofollow">大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）</a>。</p> </li></ul> 
<p>    JsonTests.cpp介绍许多 Json读写例子：</p> 
<pre class="has"><code class="language-cpp">// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

#include "CoreMinimal.h"
#include "Misc/AutomationTest.h"
#include "Policies/CondensedJsonPrintPolicy.h"
#include "Serialization/JsonTypes.h"
#include "Serialization/JsonReader.h"
#include "Policies/PrettyJsonPrintPolicy.h"
#include "Serialization/JsonSerializer.h"

#if WITH_DEV_AUTOMATION_TESTS

/**
 * FJsonAutomationTest
 * Simple unit test that runs Json's in-built test cases
 */
IMPLEMENT_SIMPLE_AUTOMATION_TEST(FJsonAutomationTest, "System.Engine.FileSystem.JSON", EAutomationTestFlags::ApplicationContextMask | EAutomationTestFlags::SmokeFilter )

typedef TJsonWriterFactory&lt; TCHAR, TCondensedJsonPrintPolicy&lt;TCHAR&gt; &gt; FCondensedJsonStringWriterFactory;
typedef TJsonWriter&lt; TCHAR, TCondensedJsonPrintPolicy&lt;TCHAR&gt; &gt; FCondensedJsonStringWriter;

typedef TJsonWriterFactory&lt; TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt; &gt; FPrettyJsonStringWriterFactory;
typedef TJsonWriter&lt; TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt; &gt; FPrettyJsonStringWriter;

/** 
 * Execute the Json test cases
 *
 * @return	true if the test was successful, false otherwise
 */
bool FJsonAutomationTest::RunTest(const FString&amp; Parameters)
{
	// Null Case
	{
		const FString InputString = TEXT("");
		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create( InputString );

		TSharedPtr&lt;FJsonObject&gt; Object;
		check( FJsonSerializer::Deserialize( Reader, Object ) == false );
		check( !Object.IsValid() );
	}

	// Empty Object Case
	{
		const FString InputString = TEXT("{}");
		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create( InputString );

		TSharedPtr&lt;FJsonObject&gt; Object;
		check( FJsonSerializer::Deserialize( Reader, Object ) );
		check( Object.IsValid() );

		FString OutputString;
		TSharedRef&lt; FCondensedJsonStringWriter &gt; Writer = FCondensedJsonStringWriterFactory::Create( &amp;OutputString );
		check( FJsonSerializer::Serialize( Object.ToSharedRef(), Writer ) );
		check( InputString == OutputString );
	}

	// Empty Array Case
	{
		const FString InputString = TEXT("[]");
		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create( InputString );

		TArray&lt; TSharedPtr&lt;FJsonValue&gt; &gt; Array;
		check( FJsonSerializer::Deserialize( Reader, Array ) );
		check( Array.Num() == 0 );

		FString OutputString;
		TSharedRef&lt; FCondensedJsonStringWriter &gt; Writer = FCondensedJsonStringWriterFactory::Create( &amp;OutputString );
		check( FJsonSerializer::Serialize( Array, Writer ) );
		check( InputString == OutputString );
	}

	// Simple Array Case
	{
		const FString InputString = 
			TEXT("[")
			TEXT(	"{")
			TEXT(		"\"Value\":\"Some String\"")
			TEXT(	"}")
			TEXT("]");

		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create( InputString );

		TArray&lt; TSharedPtr&lt;FJsonValue&gt; &gt; Array;
		bool bSuccessful = FJsonSerializer::Deserialize(Reader, Array);
		check(bSuccessful);
		check( Array.Num() == 1 );
		check( Array[0].IsValid() );

		TSharedPtr&lt; FJsonObject &gt; Object = Array[0]-&gt;AsObject();
		check( Object.IsValid() );
		check( Object-&gt;GetStringField( TEXT("Value") ) == TEXT("Some String") );

		FString OutputString;
		TSharedRef&lt; FCondensedJsonStringWriter &gt; Writer = FCondensedJsonStringWriterFactory::Create( &amp;OutputString );
		check( FJsonSerializer::Serialize( Array, Writer ) );
		check( InputString == OutputString );
	}

	// Object Array Case
	{
		const FString InputString =
			TEXT("[")
			TEXT(	"{")
			TEXT(		"\"Value\":\"Some String1\"")
			TEXT(	"},")
			TEXT(	"{")
			TEXT(		"\"Value\":\"Some String2\"")
			TEXT(	"},")
			TEXT(	"{")
			TEXT(		"\"Value\":\"Some String3\"")
			TEXT(	"}")
			TEXT("]");

		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create(InputString);

		TArray&lt; TSharedPtr&lt;FJsonValue&gt; &gt; Array;

		bool bSuccessful = FJsonSerializer::Deserialize(Reader, Array);
		check(bSuccessful);
		check(Array.Num() == 3);
		check(Array[0].IsValid());
		check(Array[1].IsValid());
		check(Array[2].IsValid());

		TSharedPtr&lt; FJsonObject &gt; Object = Array[0]-&gt;AsObject();
		check(Object.IsValid());
		check(Object-&gt;GetStringField(TEXT("Value")) == TEXT("Some String1"));

		Object = Array[1]-&gt;AsObject();
		check(Object.IsValid());
		check(Object-&gt;GetStringField(TEXT("Value")) == TEXT("Some String2"));

		Object = Array[2]-&gt;AsObject();
		check(Object.IsValid());
		check(Object-&gt;GetStringField(TEXT("Value")) == TEXT("Some String3"));

		FString OutputString;
		TSharedRef&lt; FCondensedJsonStringWriter &gt; Writer = FCondensedJsonStringWriterFactory::Create(&amp;OutputString);
		check(FJsonSerializer::Serialize(Array, Writer));
		check(InputString == OutputString);
	}

	// Number Array Case
	{
		const FString InputString =
			TEXT("[")
			TEXT("10,")
			TEXT("20,")
			TEXT("30,")
			TEXT("40")
			TEXT("]");

		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create(InputString);

		TArray&lt; TSharedPtr&lt;FJsonValue&gt; &gt; Array;
		bool bSuccessful = FJsonSerializer::Deserialize(Reader, Array);
		check(bSuccessful);
		check(Array.Num() == 4);
		check(Array[0].IsValid());
		check(Array[1].IsValid());
		check(Array[2].IsValid());
		check(Array[3].IsValid());

		double Number = Array[0]-&gt;AsNumber();
		check(Number == 10);

		Number = Array[1]-&gt;AsNumber();
		check(Number == 20);

		Number = Array[2]-&gt;AsNumber();
		check(Number == 30);

		Number = Array[3]-&gt;AsNumber();
		check(Number == 40);

		FString OutputString;
		TSharedRef&lt; FCondensedJsonStringWriter &gt; Writer = FCondensedJsonStringWriterFactory::Create(&amp;OutputString);
		check(FJsonSerializer::Serialize(Array, Writer));
		check(InputString == OutputString);
	}

	// String Array Case
	{
		const FString InputString =
			TEXT("[")
			TEXT("\"Some String1\",")
			TEXT("\"Some String2\",")
			TEXT("\"Some String3\",")
			TEXT("\"Some String4\"")
			TEXT("]");

		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create(InputString);

		TArray&lt; TSharedPtr&lt;FJsonValue&gt; &gt; Array;
		bool bSuccessful = FJsonSerializer::Deserialize(Reader, Array);
		check(bSuccessful);
		check(Array.Num() == 4);
		check(Array[0].IsValid());
		check(Array[1].IsValid());
		check(Array[2].IsValid());
		check(Array[3].IsValid());

		FString Text = Array[0]-&gt;AsString();
		check(Text == TEXT("Some String1"));

		Text = Array[1]-&gt;AsString();
		check(Text == TEXT("Some String2"));

		Text = Array[2]-&gt;AsString();
		check(Text == TEXT("Some String3"));

		Text = Array[3]-&gt;AsString();
		check(Text == TEXT("Some String4"));

		FString OutputString;
		TSharedRef&lt; FCondensedJsonStringWriter &gt; Writer = FCondensedJsonStringWriterFactory::Create(&amp;OutputString);
		check(FJsonSerializer::Serialize(Array, Writer));
		check(InputString == OutputString);
	}

	// Complex Array Case
	{
		const FString InputString =
			TEXT("[")
			TEXT(	"\"Some String1\",")
			TEXT(	"10,")
			TEXT(	"{")
			TEXT(		"\"Value\":\"Some String3\"")
			TEXT(	"},")
			TEXT(	"[")
			TEXT(		"\"Some String4\",")
			TEXT(		"\"Some String5\"")
			TEXT(	"],")
			TEXT(	"true,")
			TEXT(	"null")
			TEXT("]");

		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create(InputString);

		TArray&lt; TSharedPtr&lt;FJsonValue&gt; &gt; Array;
		bool bSuccessful = FJsonSerializer::Deserialize(Reader, Array);
		check(bSuccessful);
		check(Array.Num() == 6);
		check(Array[0].IsValid());
		check(Array[1].IsValid());
		check(Array[2].IsValid());
		check(Array[3].IsValid());
		check(Array[4].IsValid());
		check(Array[5].IsValid());

		FString Text = Array[0]-&gt;AsString();
		check(Text == TEXT("Some String1"));

		double Number = Array[1]-&gt;AsNumber();
		check(Number == 10);

		TSharedPtr&lt; FJsonObject &gt; Object = Array[2]-&gt;AsObject();
		check(Object.IsValid());
		check(Object-&gt;GetStringField(TEXT("Value")) == TEXT("Some String3"));

		const TArray&lt;TSharedPtr&lt; FJsonValue &gt;&gt;&amp; InnerArray = Array[3]-&gt;AsArray();
		check(InnerArray.Num() == 2);
		check(Array[0].IsValid());
		check(Array[1].IsValid());

		Text = InnerArray[0]-&gt;AsString();
		check(Text == TEXT("Some String4"));

		Text = InnerArray[1]-&gt;AsString();
		check(Text == TEXT("Some String5"));

		bool Boolean = Array[4]-&gt;AsBool();
		check(Boolean == true);

		check(Array[5]-&gt;IsNull() == true);

		FString OutputString;
		TSharedRef&lt; FCondensedJsonStringWriter &gt; Writer = FCondensedJsonStringWriterFactory::Create(&amp;OutputString);
		check(FJsonSerializer::Serialize(Array, Writer));
		check(InputString == OutputString);
	}

	// String Test
	{
		const FString InputString =
			TEXT("{")
			TEXT(	"\"Value\":\"Some String, Escape Chars: \\\\, \\\", \\/, \\b, \\f, \\n, \\r, \\t, \\u002B\"")
			TEXT("}");
		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create( InputString );

		TSharedPtr&lt;FJsonObject&gt; Object;
		bool bSuccessful = FJsonSerializer::Deserialize(Reader, Object);
		check(bSuccessful);
		check( Object.IsValid() );

		const TSharedPtr&lt;FJsonValue&gt;* Value = Object-&gt;Values.Find(TEXT("Value"));
		check(Value &amp;&amp; (*Value)-&gt;Type == EJson::String);
		const FString String = (*Value)-&gt;AsString();
		check(String == TEXT("Some String, Escape Chars: \\, \", /, \b, \f, \n, \r, \t, +"));

		FString OutputString;
		TSharedRef&lt; FCondensedJsonStringWriter &gt; Writer = FCondensedJsonStringWriterFactory::Create( &amp;OutputString );
		check( FJsonSerializer::Serialize( Object.ToSharedRef(), Writer ) );

		const FString TestOutput =
			TEXT("{")
			TEXT(	"\"Value\":\"Some String, Escape Chars: \\\\, \\\", /, \\b, \\f, \\n, \\r, \\t, +\"")
			TEXT("}");
		check(OutputString == TestOutput);
	}

	// Number Test
	{
		const FString InputString =
			TEXT("{")
			TEXT(	"\"Value1\":2.544e+15,")
			TEXT(	"\"Value2\":-0.544E-2,")
			TEXT(	"\"Value3\":251e3,")
			TEXT(	"\"Value4\":-0.0,")
			TEXT(	"\"Value5\":843")
			TEXT("}");
		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create( InputString );

		TSharedPtr&lt;FJsonObject&gt; Object;
		bool bSuccessful = FJsonSerializer::Deserialize(Reader, Object);
		check(bSuccessful);
		check( Object.IsValid() );

		double TestValues[] = {2.544e+15, -0.544e-2, 251e3, -0.0, 843};
		for (int32 i = 0; i &lt; 5; ++i)
		{
			const TSharedPtr&lt;FJsonValue&gt;* Value = Object-&gt;Values.Find(FString::Printf(TEXT("Value%i"), i + 1));
			check(Value &amp;&amp; (*Value)-&gt;Type == EJson::Number);
			const double Number = (*Value)-&gt;AsNumber();
			check(Number == TestValues[i]);
		}

		FString OutputString;
		TSharedRef&lt; FCondensedJsonStringWriter &gt; Writer = FCondensedJsonStringWriterFactory::Create( &amp;OutputString );
		check( FJsonSerializer::Serialize( Object.ToSharedRef(), Writer ) );

		// %g isn't standardized, so we use the same %g format that is used inside PrintJson instead of hardcoding the values here
		const FString TestOutput = FString::Printf(
			TEXT("{")
			TEXT(	"\"Value1\":%.17g,")
			TEXT(	"\"Value2\":%.17g,")
			TEXT(	"\"Value3\":%.17g,")
			TEXT(	"\"Value4\":%.17g,")
			TEXT(	"\"Value5\":%.17g")
			TEXT("}"),
			TestValues[0], TestValues[1], TestValues[2], TestValues[3], TestValues[4]);
		check(OutputString == TestOutput);
	}

	// Boolean/Null Test
	{
		const FString InputString =
			TEXT("{")
			TEXT(	"\"Value1\":true,")
			TEXT(	"\"Value2\":true,")
			TEXT(	"\"Value3\":faLsE,")
			TEXT(	"\"Value4\":null,")
			TEXT(	"\"Value5\":NULL")
			TEXT("}");
		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create( InputString );

		TSharedPtr&lt;FJsonObject&gt; Object;
		bool bSuccessful = FJsonSerializer::Deserialize(Reader, Object);
		check(bSuccessful);
		check( Object.IsValid() );

		bool TestValues[] = {true, true, false};
		for (int32 i = 0; i &lt; 5; ++i)
		{
			const TSharedPtr&lt;FJsonValue&gt;* Value = Object-&gt;Values.Find(FString::Printf(TEXT("Value%i"), i + 1));
			check(Value);
			if (i &lt; 3)
			{
				check((*Value)-&gt;Type == EJson::Boolean);
				const bool Bool = (*Value)-&gt;AsBool();
				check(Bool == TestValues[i]);
			}
			else
			{
				check((*Value)-&gt;Type == EJson::Null);
				check((*Value)-&gt;IsNull());
			}
		}

		FString OutputString;
		TSharedRef&lt; FCondensedJsonStringWriter &gt; Writer = FCondensedJsonStringWriterFactory::Create( &amp;OutputString );
		check( FJsonSerializer::Serialize( Object.ToSharedRef(), Writer ) );

		const FString TestOutput =
			TEXT("{")
			TEXT(	"\"Value1\":true,")
			TEXT(	"\"Value2\":true,")
			TEXT(	"\"Value3\":false,")
			TEXT(	"\"Value4\":null,")
			TEXT(	"\"Value5\":null")
			TEXT("}");
		check(OutputString == TestOutput);
	}

	// Object Test &amp;&amp; extra whitespace test
	{
		const FString InputStringWithExtraWhitespace =
			TEXT("		\n\r\n	   {")
			TEXT(	"\"Object\":")
			TEXT(	"{")
			TEXT(		"\"NestedValue\":null,")
			TEXT(		"\"NestedObject\":{}")
			TEXT(	"},")
			TEXT(	"\"Value\":true")
			TEXT("}		\n\r\n	   ");

		const FString InputString =
			TEXT("{")
			TEXT(	"\"Object\":")
			TEXT(	"{")
			TEXT(		"\"NestedValue\":null,")
			TEXT(		"\"NestedObject\":{}")
			TEXT(	"},")
			TEXT(	"\"Value\":true")
			TEXT("}");

		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create( InputStringWithExtraWhitespace );

		TSharedPtr&lt;FJsonObject&gt; Object;
		bool bSuccessful = FJsonSerializer::Deserialize(Reader, Object);
		check(bSuccessful);
		check( Object.IsValid() );

		const TSharedPtr&lt;FJsonValue&gt;* InnerValueFail = Object-&gt;Values.Find(TEXT("InnerValue"));
		check(!InnerValueFail);

		const TSharedPtr&lt;FJsonValue&gt;* ObjectValue = Object-&gt;Values.Find(TEXT("Object"));
		check(ObjectValue &amp;&amp; (*ObjectValue)-&gt;Type == EJson::Object);
		const TSharedPtr&lt;FJsonObject&gt; InnerObject = (*ObjectValue)-&gt;AsObject();
		check(InnerObject.IsValid());

		{
			const TSharedPtr&lt;FJsonValue&gt;* NestedValueValue = InnerObject-&gt;Values.Find(TEXT("NestedValue"));
			check(NestedValueValue &amp;&amp; (*NestedValueValue)-&gt;Type == EJson::Null);
			check((*NestedValueValue)-&gt;IsNull());

			const TSharedPtr&lt;FJsonValue&gt;* NestedObjectValue = InnerObject-&gt;Values.Find(TEXT("NestedObject"));
			check(NestedObjectValue &amp;&amp; (*NestedObjectValue)-&gt;Type == EJson::Object);
			const TSharedPtr&lt;FJsonObject&gt; InnerInnerObject = (*NestedObjectValue)-&gt;AsObject();
			check(InnerInnerObject.IsValid());

			{
				const TSharedPtr&lt;FJsonValue&gt;* NestedValueValueFail = InnerInnerObject-&gt;Values.Find(TEXT("NestedValue"));
				check(!NestedValueValueFail);
			}
		}

		const TSharedPtr&lt;FJsonValue&gt;* ValueValue = Object-&gt;Values.Find(TEXT("Value"));
		check(ValueValue &amp;&amp; (*ValueValue)-&gt;Type == EJson::Boolean);
		const bool Bool = (*ValueValue)-&gt;AsBool();
		check(Bool);

		FString OutputString;
		TSharedRef&lt; FCondensedJsonStringWriter &gt; Writer = FCondensedJsonStringWriterFactory::Create( &amp;OutputString );
		check( FJsonSerializer::Serialize( Object.ToSharedRef(), Writer ) );
		check(OutputString == InputString);
	}

	// Array Test
	{
		const FString InputString =
			TEXT("{")
			TEXT(	"\"Array\":")
			TEXT(	"[")
			TEXT(		"[],")
			TEXT(		"\"Some String\",")
			TEXT(		"\"Another String\",")
			TEXT(		"null,")
			TEXT(		"true,")
			TEXT(		"false,")
			TEXT(		"45,")
			TEXT(		"{}")
			TEXT(	"]")
			TEXT("}");
		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create( InputString );

		TSharedPtr&lt;FJsonObject&gt; Object;
		bool bSuccessful = FJsonSerializer::Deserialize(Reader, Object);
		check(bSuccessful);
		check( Object.IsValid() );

		const TSharedPtr&lt;FJsonValue&gt;* InnerValueFail = Object-&gt;Values.Find(TEXT("InnerValue"));
		check(!InnerValueFail);

		const TSharedPtr&lt;FJsonValue&gt;* ArrayValue = Object-&gt;Values.Find(TEXT("Array"));
		check(ArrayValue &amp;&amp; (*ArrayValue)-&gt;Type == EJson::Array);
		const TArray&lt; TSharedPtr&lt;FJsonValue&gt; &gt; Array = (*ArrayValue)-&gt;AsArray();
		check(Array.Num() == 8);

		EJson ValueTypes[] = {EJson::Array, EJson::String, EJson::String, EJson::Null,
			EJson::Boolean, EJson::Boolean, EJson::Number, EJson::Object};
		for (int32 i = 0; i &lt; Array.Num(); ++i)
		{
			const TSharedPtr&lt;FJsonValue&gt;&amp; Value = Array[i];
			check(Value.IsValid());
			check(Value-&gt;Type == ValueTypes[i]);
		}

		const TArray&lt; TSharedPtr&lt;FJsonValue&gt; &gt;&amp; InnerArray = Array[0]-&gt;AsArray();
		check(InnerArray.Num() == 0);
		check(Array[1]-&gt;AsString() == TEXT("Some String"));
		check(Array[2]-&gt;AsString() == TEXT("Another String"));
		check(Array[3]-&gt;IsNull());
		check(Array[4]-&gt;AsBool());
		check(!Array[5]-&gt;AsBool());
		check(FMath::Abs(Array[6]-&gt;AsNumber() - 45.f) &lt; KINDA_SMALL_NUMBER);
		const TSharedPtr&lt;FJsonObject&gt; InnerObject = Array[7]-&gt;AsObject();
		check(InnerObject.IsValid());

		FString OutputString;
		TSharedRef&lt; FCondensedJsonStringWriter &gt; Writer = FCondensedJsonStringWriterFactory::Create( &amp;OutputString );
		check( FJsonSerializer::Serialize( Object.ToSharedRef(), Writer ) );
		check(OutputString == InputString);
	}

	// Pretty Print Test
	{
		const FString InputString =
			TEXT("{")									LINE_TERMINATOR
			TEXT("	\"Data1\": \"value\",")				LINE_TERMINATOR
			TEXT("	\"Data2\": \"value\",")				LINE_TERMINATOR
			TEXT("	\"Array\": [")						LINE_TERMINATOR
			TEXT("		{")								LINE_TERMINATOR
			TEXT("			\"InnerData1\": \"value\"")	LINE_TERMINATOR
			TEXT("		},")							LINE_TERMINATOR
			TEXT("		[],")							LINE_TERMINATOR
			TEXT("		[ 1, 2, 3, 4 ],")				LINE_TERMINATOR
			TEXT("		{")								LINE_TERMINATOR
			TEXT("		},")							LINE_TERMINATOR
			TEXT("		\"value\",")					LINE_TERMINATOR
			TEXT("		\"value\"")						LINE_TERMINATOR
			TEXT("	],")								LINE_TERMINATOR
			TEXT("	\"Object\":")						LINE_TERMINATOR
			TEXT("	{")									LINE_TERMINATOR
			TEXT("	}")									LINE_TERMINATOR
			TEXT("}");
		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create( InputString );

		TSharedPtr&lt;FJsonObject&gt; Object;
		check( FJsonSerializer::Deserialize( Reader, Object ) );
		check( Object.IsValid() );

		FString OutputString;
		TSharedRef&lt; FPrettyJsonStringWriter &gt; Writer = FPrettyJsonStringWriterFactory::Create( &amp;OutputString );
		check( FJsonSerializer::Serialize( Object.ToSharedRef(), Writer ) );
		check(OutputString == InputString);
	}
	  
	// Line and Character # test
	{
		const FString InputString =
			TEXT("{")									LINE_TERMINATOR
			TEXT("	\"Data1\": \"value\",")				LINE_TERMINATOR
			TEXT("	\"Array\":")						LINE_TERMINATOR
			TEXT("	[")									LINE_TERMINATOR
			TEXT("		12345,")						LINE_TERMINATOR
			TEXT("		True")							LINE_TERMINATOR
			TEXT("	],")								LINE_TERMINATOR
			TEXT("	\"Object\":")						LINE_TERMINATOR
			TEXT("	{")									LINE_TERMINATOR
			TEXT("	}")									LINE_TERMINATOR
			TEXT("}");
		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create( InputString );

		EJsonNotation Notation = EJsonNotation::Null;
		check( Reader-&gt;ReadNext( Notation ) &amp;&amp; Notation == EJsonNotation::ObjectStart );
		check( Reader-&gt;GetLineNumber() == 1 &amp;&amp; Reader-&gt;GetCharacterNumber() == 1 );

		check( Reader-&gt;ReadNext( Notation ) &amp;&amp; Notation == EJsonNotation::String );
		check( Reader-&gt;GetLineNumber() == 2 &amp;&amp; Reader-&gt;GetCharacterNumber() == 17 );

		check( Reader-&gt;ReadNext( Notation ) &amp;&amp; Notation == EJsonNotation::ArrayStart );
		check( Reader-&gt;GetLineNumber() == 4 &amp;&amp; Reader-&gt;GetCharacterNumber() == 2 );

		check( Reader-&gt;ReadNext( Notation ) &amp;&amp; Notation == EJsonNotation::Number );
		check( Reader-&gt;GetLineNumber() == 5 &amp;&amp; Reader-&gt;GetCharacterNumber() == 7 );

		check( Reader-&gt;ReadNext( Notation ) &amp;&amp; Notation == EJsonNotation::Boolean );
		check( Reader-&gt;GetLineNumber() == 6 &amp;&amp; Reader-&gt;GetCharacterNumber() == 6 );
	}

	// Failure Cases
	TArray&lt;FString&gt; FailureInputs;

	// Unclosed Object
	FailureInputs.Add(
		TEXT("{"));

	// Values in Object without identifiers
	FailureInputs.Add(
		TEXT("{")
		TEXT(	"\"Value1\",")
		TEXT(	"\"Value2\",")
		TEXT(	"43")
		TEXT("}"));

	// Unexpected End Of Input Found
	FailureInputs.Add(
		TEXT("{")
		TEXT(	"\"Object\":")
		TEXT(	"{")
		TEXT(		"\"NestedValue\":null,"));

	// Missing first brace
	FailureInputs.Add(
		TEXT(	"\"Object\":")
		TEXT(		"{")
		TEXT(		"\"NestedValue\":null,")
		TEXT(		"\"NestedObject\":{}")
		TEXT(	"},")
		TEXT(	"\"Value\":true")
		TEXT("}"));

	// Missing last character
	FailureInputs.Add(
		TEXT("{")
		TEXT(	"\"Object\":")
		TEXT(	"{")
		TEXT(		"\"NestedValue\":null,")
		TEXT(		"\"NestedObject\":{}")
		TEXT(	"},")
		TEXT(	"\"Value\":true"));

	// Extra last character
	FailureInputs.Add(
		TEXT("{")
		TEXT(	"\"Object\":")
		TEXT(	"{")
		TEXT(		"\"NestedValue\":null,")
		TEXT(		"\"NestedObject\":{}")
		TEXT(	"},")
		TEXT(	"\"Value\":true")
		TEXT("}0"));

	// Missing comma
	FailureInputs.Add(
		TEXT("{")
		TEXT(	"\"Value1\":null,")
		TEXT(	"\"Value2\":\"string\"")
		TEXT(	"\"Value3\":65.3")
		TEXT("}"));

	// Extra comma
	FailureInputs.Add(
		TEXT("{")
		TEXT(	"\"Value1\":null,")
		TEXT(	"\"Value2\":\"string\",")
		TEXT(	"\"Value3\":65.3,")
		TEXT("}"));

	// Badly formed true/false/null
	FailureInputs.Add(TEXT("{\"Value\":tru}"));
	FailureInputs.Add(TEXT("{\"Value\":full}"));
	FailureInputs.Add(TEXT("{\"Value\":nulle}"));
	FailureInputs.Add(TEXT("{\"Value\":n%ll}"));

	// Floating Point Failures
	FailureInputs.Add(TEXT("{\"Value\":65.3e}"));
	FailureInputs.Add(TEXT("{\"Value\":65.}"));
	FailureInputs.Add(TEXT("{\"Value\":.7}"));
	FailureInputs.Add(TEXT("{\"Value\":+6}"));
	FailureInputs.Add(TEXT("{\"Value\":01}"));
	FailureInputs.Add(TEXT("{\"Value\":00.56}"));
	FailureInputs.Add(TEXT("{\"Value\":-1.e+4}"));
	FailureInputs.Add(TEXT("{\"Value\":2e+}"));

	// Bad Escape Characters
	FailureInputs.Add(TEXT("{\"Value\":\"Hello\\xThere\"}"));
	FailureInputs.Add(TEXT("{\"Value\":\"Hello\\u123There\"}"));
	FailureInputs.Add(TEXT("{\"Value\":\"Hello\\RThere\"}"));

	for (int32 i = 0; i &lt; FailureInputs.Num(); ++i)
	{
		TSharedRef&lt; TJsonReader&lt;&gt; &gt; Reader = TJsonReaderFactory&lt;&gt;::Create( FailureInputs[i] );

		TSharedPtr&lt;FJsonObject&gt; Object;
		check( FJsonSerializer::Deserialize( Reader, Object ) == false );
		check( !Object.IsValid() );
	}

	return true;
}

#endif //WITH_DEV_AUTOMATION_TESTS
</code></pre> 
<p>简单例子：</p> 
<pre class="has"><code class="language-cpp">FString UTestActor::GetValueByID(FString Key)
{
	FString LoginInfo = "";
	LoginInfo = NDXGetLoginInfo();
	if (!LoginInfo.IsEmpty())
	{
		TSharedPtr&lt;FJsonObject&gt; JsonParsed;
		TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader =     TJsonReaderFactory&lt;TCHAR&gt;::Create(LoginInfo);
		if (FJsonSerializer::Deserialize(JsonReader, JsonParsed))
		{
			if (JsonParsed.IsValid())
			{
				FJsonObject&amp; MyJosnObject = *JsonParsed.Get();
				FString value= "0";
				if (MyJosnObject.TryGetStringField(Key, value))
				{
					UE_LOG(LogTemp, Warning, TEXT("GetValueByID() value:%s"), *value);
					return value;
				}
				else
				{
					UE_LOG(LogTemp, Warning, TEXT("MyJosnObject dont contain %s"), *Key);
				}
			}
			else
			{
				UE_LOG(LogTemp, Warning, TEXT(" JsonParsed.IsValid() is false!"));
			}
		}
		else
		{
			UE_LOG(LogTemp, Warning, TEXT("FJsonSerializer::Deserialize(JsonReader, JsonParsed) is false!"));
		}
	}
	else
	{
		UE_LOG(LogTemp, Warning, TEXT("LoginInfo is empty!"));
	}
	UE_LOG(LogTemp, Warning, TEXT("Final GetValueByID:%s : %s"),*Key, "0");
	return "0";
}</code></pre> 
<pre class="has"><code class="language-cpp">void UTestActor::OnSteamResponseRec(FHttpRequestPtr Request, FHttpResponsePtr Response, bool bWasSuccessful)
{
	if (Response.IsValid())
	{
		//Create a pointer to hold the json serialized data
		TSharedPtr&lt;FJsonObject&gt; JsonObject;

		//Create a reader pointer to read the json data
		TSharedRef&lt;TJsonReader&lt;&gt;&gt; Reader = TJsonReaderFactory&lt;&gt;::Create(Response-&gt;GetContentAsString());

		//Deserialize the json data given Reader and the actual object to deserialize
		if (FJsonSerializer::Deserialize(Reader, JsonObject))
		{
			const TSharedPtr&lt;FJsonObject&gt;* response;
			if (JsonObject-&gt;TryGetObjectField(TEXT("response"), response))
			{
				const TSharedPtr&lt;FJsonObject&gt;* params = nullptr;
				if (response &amp;&amp; (*response)-&gt;TryGetObjectField(TEXT("params"), params))
				{
					if (params)
					{
						(*params)-&gt;TryGetStringField(TEXT("country"), SteamCountry);
						(*params)-&gt;TryGetStringField(TEXT("currency"), SteamCurrency);
					}
				}
			}

		}
	}

}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b92d977e0a38ddf64d861902ff3127c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C/C&#43;&#43;语言中的int a; int* a; int** a; int (*a)[]; int (*a)(int)，重点介绍指针数组与数组指针</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af3dc7a9f7d6b2e7cf8f747c42dfdc46/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue 中 import from @ 是什么意思？怎么配置？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>