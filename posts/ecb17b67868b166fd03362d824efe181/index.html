<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基本分段存储管理方式（分段 段表 地址变换 分段、分页管理的对比） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基本分段存储管理方式（分段 段表 地址变换 分段、分页管理的对比）" />
<meta property="og:description" content=" 文章目录 前言知识总览分段段表地址变换分段、分页管理的对比知识回顾与重要考点 前言 此篇文章是我在B站学习时所做的笔记，大部分图片都是课件老师的PPT，方便复习用。此篇文章仅供学习参考。
提示：以下是本篇文章正文内容
知识总览 分段 进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程)，每段从0开始编址内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。
解说：
由于各个分段是按功能模块来划分的，并且这些段名是由用户自己定义的，所以用户在读这个程序的时候就知道这两句代码做的事情是把某个全局变量的值赋值X的这个子函数当中的某个变量，因此对于用户来说采用分段机制之后程序的可读性还是很高的。在用户编程时，使用的是段名来操作各个段，但是在CPU具体执行的时候其实是使用段号这个参数，所以编译程序会把段名转换为与它们各自相对应的段号，然后CPU再执行这些指令的时候是根据段号来区分各个段的。 段号的位数决定了每个进程最多可以分几个段
段内地址位数决定了每个段的最大长度是多少
段表 问题：程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。
相对于页表来说，段表多了“段长”，因为每个分段的长度可能是不一样的，而在在分页存储管理当中，每个页面的长度是一样的，所以在分页存储中页长是不需要显示记录的，在分段存储中是需要显示的。
物理内存大小为4GB（即232B，可用32位表示整个物理内存地址空间）
1个字节=8位（1B=8bit）
48位大小的数字，只用6B的空间就可以表示。
地址变换 解说：
如果说此时要访问的逻辑地址的段号是2，然后段内地址是1024的话，那首先需要用段号2和段表长度M进行一个检查，那显然此时这个进程的段表长度应该是3，因为它有3个段，所以段号是&lt;段表长度的，因此段号合法，所以就可以进行下一步用段号和段表始址查到这个段号对应的段表项，那这样的话就找到了2号段对应的段表项，那接下来需要对段内地址的合法性进行一个检查，段内地址和段长对比，发现2号段的段长是6k，而段内地址是1024也就是1k，所以段内地址&lt;段长，因此在这个地方并不会产生越界中断，可以继续执行下去，那接下来通过这个段表项，我们知道了这个段在内存当中存放的起始地址是40k，所以用这个段的起始地址40k&#43;段内地址w，也就是1024，那这样的话，我们就得到了最终想访问的目标内存单元，也就是A那个变量存放的位置，那这样的话，就完成了对这个逻辑地址的访问。
分段、分页管理的对比 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要,完全是系统行为，对用户是不可见的。段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。 分段比分页更容易实现信息的共享和保护。 不能被修改的代码称为纯代码或可重入代码（不属于临界资源)，这样的代码是可以共享的。
可修改的代码是不能共享的
访问一个逻辑地址需要几次访存?
1、分页（单级页表)︰第一次访存――查内存中的页表，第二次访存――访问目标内存单元。总共两次访存
2、分段：第一次访存――查内存中的段表，第二次访存――访问目标内存单元。总共两次访存与分页系统类似，分段系统中也可以引入 快表 机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。 知识回顾与重要考点 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ecb17b67868b166fd03362d824efe181/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-31T15:57:34+08:00" />
<meta property="article:modified_time" content="2021-08-31T15:57:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基本分段存储管理方式（分段 段表 地址变换 分段、分页管理的对比）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">前言</a></li><li><a href="#_9" rel="nofollow">知识总览</a></li><li><a href="#_11" rel="nofollow">分段</a></li><li><a href="#_22" rel="nofollow">段表</a></li><li><a href="#_31" rel="nofollow">地址变换</a></li><li><a href="#_36" rel="nofollow">分段、分页管理的对比</a></li><li><a href="#_57" rel="nofollow">知识回顾与重要考点</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>前言</h2> 
<p><font color="#999AAA">此篇文章是我在B站学习时所做的笔记，大部分图片都是课件老师的PPT，方便复习用。此篇文章仅供学习参考。</font><br> </p> 
<hr color="#000000" size='1"'> 
<p><font color="#999AAA">提示：以下是本篇文章正文内容</font></p> 
<h2><a id="_9"></a>知识总览</h2> 
<p><img src="https://images2.imgbox.com/73/73/tzNPbUjI_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_11"></a>分段</h2> 
<ul><li>进程的地址空间：按照程序<mark>自身的逻辑</mark>关系<mark>划分为若干个段</mark>，每个段都有一个段名（在低级语言中，程序员使用段名来编程)，<mark>每段从0开始编址</mark></li><li>内存分配规则：以段为单位进行分配，<mark>每个段在内存中占据连续空间</mark>，但<mark>各段之间可以不相邻</mark>。<br> <img src="https://images2.imgbox.com/dd/dc/zbpEdzFr_o.png" alt="在这里插入图片描述"><br> <strong>解说</strong>：<br> 由于各个分段是按功能模块来划分的，并且这些段名是由用户自己定义的，所以用户在读这个程序的时候就知道这两句代码做的事情是把某个全局变量的值赋值X的这个子函数当中的某个变量，因此对于用户来说采用分段机制之后程序的可读性还是很高的。在用户编程时，使用的是段名来操作各个段，但是在CPU具体执行的时候其实是使用段号这个参数，所以编译程序会把段名转换为与它们各自相对应的段号，然后<mark>CPU再执行这些指令的时候是根据段号来区分各个段的</mark>。</li></ul> 
<p><img src="https://images2.imgbox.com/4e/d0/CNsjhYWE_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><mark><strong>段号的位数决定了每个进程最多可以分几个段<br> 段内地址位数决定了每个段的最大长度是多少</strong></mark></p> 
</blockquote> 
<h2><a id="_22"></a>段表</h2> 
<p>问题：程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。<br> <img src="https://images2.imgbox.com/91/39/ihTPGl3s_o.png" alt="在这里插入图片描述"><br> 相对于页表来说，段表多了“段长”，因为每个分段的长度可能是不一样的，而在在分页存储管理当中，每个页面的长度是一样的，所以在分页存储中页长是不需要显示记录的，在分段存储中是需要显示的。</p> 
<blockquote> 
 <p>物理内存大小为4GB（即2<sup>32</sup>B，可用32位表示整个物理内存地址空间）<br> 1个字节=8位（1B=8bit）<br> 48位大小的数字，只用6B的空间就可以表示。</p> 
</blockquote> 
<h2><a id="_31"></a>地址变换</h2> 
<p><img src="https://images2.imgbox.com/ed/67/nQKHivnd_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/67/bc/9t45pyaa_o.png" alt="在这里插入图片描述"><br> <strong>解说</strong>：<br> 如果说此时要访问的逻辑地址的段号是2，然后段内地址是1024的话，那首先需要用段号2和段表长度M进行一个检查，那显然此时这个进程的段表长度应该是3，因为它有3个段，所以段号是&lt;段表长度的，因此段号合法，所以就可以进行下一步用段号和段表始址查到这个段号对应的段表项，那这样的话就找到了2号段对应的段表项，那接下来需要对段内地址的合法性进行一个检查，段内地址和段长对比，发现2号段的段长是6k，而段内地址是1024也就是1k，所以段内地址&lt;段长，因此在这个地方并不会产生越界中断，可以继续执行下去，那接下来通过这个段表项，我们知道了这个段在内存当中存放的起始地址是40k，所以用这个段的起始地址40k+段内地址w，也就是1024，那这样的话，我们就得到了最终想访问的目标内存单元，也就是A那个变量存放的位置，那这样的话，就完成了对这个逻辑地址的访问。</p> 
<h2><a id="_36"></a>分段、分页管理的对比</h2> 
<ul><li><mark>页</mark>是<mark>信息的物理单位</mark>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要,完全是系统行为，<mark>对用户是不可见的</mark>。</li><li><mark>段</mark>是<mark>信息的逻辑单位</mark>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<mark>分段对用户是可见的</mark>，用户编程时需要显式地给出段名。</li><li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</li></ul> 
<blockquote> 
 <ul><li><mark>分页</mark>的用户进程<mark>地址空间是一维的</mark>，程序员只需给出一个记忆符即可表示一个地址。</li><li><mark>分段</mark>的用户进程<mark>地址空间是二维的</mark>，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c6/3a/XV2OYQW9_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f6/52/QpF9CyK1_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/49/43/2t1WdnEi_o.png" alt="在这里插入图片描述"></p> 
<ul><li><mark>分段</mark>比分页<mark>更容易实现信息的共享和保护</mark>。</li></ul> 
<blockquote> 
 <p><strong>不能被修改的代码称为<mark>纯代码</mark>或<mark>可重入代码</mark>（不属于临界资源)，这样的代码是可以<mark>共享</mark>的。<br> 可修改的代码是不能共享的</strong></p> 
</blockquote> 
<ul><li>访问一个逻辑地址需要几次访存?<br> 1、<mark>分页（单级页表)</mark>︰第一次访存――查内存中的页表，第二次访存――访问目标内存单元。总共<mark>两次访存</mark><br> 2、<mark>分段</mark>：第一次访存――查内存中的段表，第二次访存――访问目标内存单元。总共<mark>两次访存</mark></li><li>与分页系统类似，分段系统中也<mark>可以引入</mark> <mark><strong>快表</strong></mark> <mark>机构</mark>，将近期访问过的段表项放到快表中，这样<mark>可以少一次访问</mark>，加快地址变换速度。</li></ul> 
<h2><a id="_57"></a>知识回顾与重要考点</h2> 
<p><img src="https://images2.imgbox.com/2d/68/pAbp2P5a_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aed3d625576d25b367afc269d89c8142/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">宝塔面板利用反向代理实现图片及其它资源的访问</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e84e0b89acb202ca2942a878e7a178a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2021-08-31 从原理上理解补码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>