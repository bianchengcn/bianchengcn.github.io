<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaScript学习（九） —— 函数式编程 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JavaScript学习（九） —— 函数式编程" />
<meta property="og:description" content="百科定义: 函数式编程(Functional Programming)是种编程范式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。
写在前头：本人之前并没有过多了解过函数式编程，也很少发散思维和总结。直到最近开始写技术文章，写到函数式编程这个主题时，阅览了大量大神写的文章后才恍然，发现实战项目中很多模块用到了函数式编程。写这篇博文的过程也是自己系统学习这种编程范式的过程，用自己所学的知识尽力把函数式编程涉及到的知识点都说明白。
目录 一、纯函数二、函数柯里化(Currying)三、函数组合四、一个实际例子五、一些通用函数库 一、纯函数 要弄清楚函数式编程的具体实现和实际使用方法，需要先弄清楚纯函数的概念。我们一直说的函数式编程中的函数指的是数学中的函数，类似我们高中学过的关于自变量x的函数f(x)、g(x)还有复合函数f(gx)等概念。这样的数学函数可算是纯函数的一种。
纯函数的特性:
对于相同的输入，永远会得到相同的输出没有任何可观察的副作用不依赖外部环境的状态。 JS中某些对数组的一些方法(函数)就有纯和非纯的分别：
纯函数：
var arr = [1,2,3,4]; console.log(arr.slice(0,2)); // [1, 2] console.log(arr); // [1, 2, 3, 4] slice是纯函数，它没有改变原来的数组arr。
非纯函数：
var arr = [1,2,3,4]; console.log(arr.splice(0,2)); // [1, 2] console.log(arr); // [3, 4] splice改变了原来的数组arr，是非纯的函数。
以上面两个例子对比:
我们的目的是想通过调用一个函数后，获得一个截取原数组arr的结果，但并不想改变原数组arr。非纯函数splice随便就把外部变量或状态（原数组arr）修改，会导致很多预期之外的结果，这样的副作用不是我们所期望的。在函数式编程范式中，我们当然希望使用纯函数slice，它不会修改原数组，没有副作用。 看一个函数会依赖外部环境的状态的示例：
例1：
var price = 69.99; function discount(){ return price * .8; } console.log(discount()); // 55.992 console.log(price); // 69.99 例1的discount方法引用了外部状态price，如果修改了外部状态price，会轻松影响discount方法返回的值，对于大型应用程序会增强系统复杂性和维护的难度。
解决这个问题的方法是把价格当作参数传入函数：
例2：
var price = 69." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/b45195cac3a0ce2578ff97471264f7ee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-27T10:18:22+08:00" />
<meta property="article:modified_time" content="2023-04-27T10:18:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaScript学习（九） —— 函数式编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><strong>百科定义:</strong> 函数式编程(Functional Programming)是种编程范式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。</p> 
</blockquote> 
<center> 
 <img width="270" height="160" src="https://images2.imgbox.com/8f/30/WWxvh9vB_o.png"> 
</center> 
<p><code><font color="#603"><strong>写在前头：</strong></font><font color="#606">本人之前并没有过多了解过函数式编程，也很少发散思维和总结。直到最近开始写技术文章，写到函数式编程这个主题时，阅览了大量大神写的文章后才恍然，发现实战项目中很多模块用到了函数式编程。写这篇博文的过程也是自己系统学习这种编程范式的过程，用自己所学的知识尽力把函数式编程涉及到的知识点都说明白。</font></code></p> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><ul><li><a href="#_8" rel="nofollow">一、纯函数</a></li><li><a href="#Currying_71" rel="nofollow">二、函数柯里化(Currying)</a></li><li><a href="#_95" rel="nofollow">三、函数组合</a></li><li><a href="#_139" rel="nofollow">四、一个实际例子</a></li><li><a href="#_183" rel="nofollow">五、一些通用函数库</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="_8"></a>一、纯函数</h4> 
<p>要弄清楚函数式编程的具体实现和实际使用方法，需要先弄清楚<strong>纯函数</strong>的概念。我们一直说的<strong>函数式</strong>编程中的<strong>函数</strong>指的是<strong>数学中的函数</strong>，类似我们高中学过的关于自变量x的函数f(x)、g(x)还有复合函数f(gx)等概念。这样的数学函数可算是纯函数的一种。</p> 
<blockquote> 
 <p><strong>纯函数的特性:</strong></p> 
 <ul><li>对于相同的输入，永远会得到相同的输出</li><li>没有任何可观察的副作用</li><li>不依赖外部环境的状态。</li></ul> 
</blockquote> 
<p>JS中某些对数组的一些方法(函数)就有<strong>纯</strong>和<strong>非纯</strong>的分别：</p> 
<p><strong>纯函数：</strong></p> 
<pre><code class="prism language-json"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// [1, 2]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>  	<span class="token comment">// [1, 2, 3, 4]</span>
</code></pre> 
<p><code>slice</code>是纯函数，它没有改变原来的数组<code>arr</code>。</p> 
<p><strong>非纯函数：</strong></p> 
<pre><code class="prism language-json"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// [1, 2]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>  	<span class="token comment">// [3, 4]</span>
</code></pre> 
<p><code>splice</code>改变了原来的数组<code>arr</code>，是非纯的函数。</p> 
<p>以上面两个例子对比:</p> 
<ul><li>我们的目的是想通过调用一个函数后，获得一个截取原数组<code>arr</code>的结果，但并不想改变原数组arr。</li><li>非纯函数<code>splice</code>随便就把外部变量或状态（原数组<code>arr</code>）修改，会导致很多预期之外的结果，这样的副作用不是我们所期望的。</li><li>在函数式编程范式中，我们当然希望使用纯函数<code>slice</code>，它不会修改原数组，没有副作用。</li></ul> 
<p>看一个函数会依赖外部环境的状态的示例：</p> 
<p><strong>例1：</strong></p> 
<pre><code class="prism language-json"><span class="token keyword">var</span> price <span class="token operator">=</span> <span class="token number">69.99</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> price <span class="token operator">*</span> <span class="token number">.8</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">discount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 55.992</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>  	<span class="token comment">// 69.99</span>
</code></pre> 
<p>例1的<code>discount</code>方法引用了外部状态<code>price</code>，如果修改了外部状态<code>price</code>，会轻松影响<code>discount</code>方法返回的值，对于大型应用程序会增强系统复杂性和维护的难度。</p> 
<p>解决这个问题的方法是把价格当作参数传入函数：</p> 
<p><strong>例2：</strong></p> 
<pre><code class="prism language-json"><span class="token keyword">var</span> price <span class="token operator">=</span> <span class="token number">69.99</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> p <span class="token operator">*</span> <span class="token number">.8</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">discount</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 55.992</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>  	<span class="token comment">// 69.99</span>
</code></pre> 
<p>例1例2虽然结果都一样，区别在于是否把价格当作参数传入，函数内部是否有形参接收。形参是按值传递，发生了一次复制行为，返回的结果不影响函数外的状态。例1属于非纯函数，例2是纯函数。</p> 
<p><strong>使用纯函数的目的：</strong></p> 
<p>本人认为纯函数可以理解为最小功能的单元，可比喻为拼插玩具（乐高）的基本单位。我们所实现的一些复杂需求就由这些纯函数组合而成。后面的<strong>函数组合</strong>将详细说明。</p> 
<h4><a id="Currying_71"></a>二、函数柯里化(Currying)</h4> 
<p>之前<a href="https://blog.csdn.net/sonicwater/article/details/113181981">《闭包》</a>中提到过柯里化。假设有两个函数A和B，当函数A作为函数B的返回值被缓存在一个变量中，函数A引用了函数B作用域中的变量，其展现形态就是一个闭包。这种特性可作为函数式编程的一种体现。</p> 
<p><strong>举例:</strong> 下面是一个计算折扣价格的例子：</p> 
<pre><code class="prism language-json"><span class="token comment">// 缓存8折优惠后的价格</span>
<span class="token keyword">var</span> discount80 <span class="token operator">=</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token number">.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 缓存9折优惠后的价格</span>
<span class="token keyword">var</span> discount90 <span class="token operator">=</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token number">.9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 优惠价格Currying</span>
<span class="token keyword">function</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token parameter">percent</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">price</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> price <span class="token operator">*</span> percent<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">discount80</span><span class="token punctuation">(</span><span class="token number">69.99</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 55.992</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">discount90</span><span class="token punctuation">(</span><span class="token number">69.99</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 62.991</span>
</code></pre> 
<p>柯里化对于函数式编程的意义在于，它可以缓存调用函数先传一部分参数的结果，然后再调用时传入另一部分参数，第一次调用缓存可以理解为对某个最终结果的预加载。第二次调用缓存的函数引用得到最终结果。</p> 
<h4><a id="_95"></a>三、函数组合</h4> 
<p>函数式编程的另一种体现是函数中的某个参数也是一个函数。写过很多年代码的人肯定听过<strong>函数是第一等公民</strong>这句话。它是指函数可以赋值给一个变量（函数表达式），也可以当成一个参数传递给另一个函数。还有在另一个函数体内被当作结果返回，就是刚才说的函数柯里化。</p> 
<p>当一个函数被当成参数传递给另一个函数时，就如文章开头提到的高中数学的 <code>f(g(x))</code> 这种形态。</p> 
<p>用JS代码表示：</p> 
<pre><code class="prism language-json"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">func</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 30</span>
  <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这个例子无非是在一个函数体内调用了传进来的参数函数，没有太多意义。我们想介绍的是<strong>函数组合</strong>。</p> 
<p>下面是一个简单的函数组合实现，只接收两个参数的函数，从右到左顺序组合函数。</p> 
<pre><code class="prism language-json"><span class="token keyword">function</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> g</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>它是怎么用的：</p> 
<pre><code class="prism language-json"><span class="token keyword">function</span> <span class="token function">add10</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> num <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">add20</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> num <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>add10<span class="token punctuation">,</span> add20<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">res</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 35</span>
</code></pre> 
<p>将 <code>add10</code>、<code>add20</code> 两个纯函数组合，并将返回函数缓存起来。</p> 
<h4><a id="_139"></a>四、一个实际例子</h4> 
<p>介绍完<strong>纯函数</strong>、<strong>函数柯里化</strong> 和 <strong>函数组合</strong>，如果把这些结合起来能做什么？</p> 
<p>现在有个这样的需求：有个折扣柯里化方法，有个保留价格小数位数的柯里化方法，将这两个方法组合计算出一个打了9折后保留2位小数的函数。随便代入一个价格，计算出最终结果。</p> 
<pre><code class="prism language-json"><span class="token comment">// 缓存9折优惠后的价格</span>
<span class="token keyword">var</span> discount90 <span class="token operator">=</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token number">.9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 缓存保留2位小数后的价格</span>
<span class="token keyword">var</span> toFixed2 <span class="token operator">=</span> <span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 优惠价格Currying</span>
<span class="token keyword">function</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token parameter">percent</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">price</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> price <span class="token operator">*</span> percent<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 保留小数Currying</span>
<span class="token keyword">function</span> <span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">price</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> price<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 函数组合</span>
<span class="token keyword">function</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> g</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 缓存一个打了9折且保留2位小数的组合函数</span>
<span class="token keyword">var</span> final_price <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>toFixed2<span class="token punctuation">,</span>discount90<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 调用得到最后结果</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">final_price</span><span class="token punctuation">(</span><span class="token number">69.99</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 62.99</span>
</code></pre> 
<ul><li>优惠价格函数 <code>discount</code> 和 保留小数位数 <code>toFixed</code> 两个方法用到了<strong>函数柯里化</strong></li><li>缓存两个柯里化的返回结果的方法 <code>discount90</code> 和 <code>toFixed2</code> 是两个 <strong>纯函数</strong></li><li><code>compose</code> 组合了 <code>discount90</code> 和 <code>toFixed2</code> 函数</li></ul> 
<h4><a id="_183"></a>五、一些通用函数库</h4> 
<p><a href="http://underscorejs.org/" rel="nofollow">underscore</a>、<a href="https://ramdajs.com/" rel="nofollow">ramda</a>、<a href="https://lodash.com/" rel="nofollow">lodash</a> 等JS库都支持了函数式编程的范式，它们提供的API其实都大同小异，我们可以在项目中引入这些第三方库，写某些场景的业务代码时可适当使用函数式编程范式。</p> 
<p>JS给数组实例提供了 <code>reverse</code> 和 <code>sort</code> 方法，但是这两个方法会改变原数组，它们是非纯函数，所以如果想先后调用这两个方法，需要先实现一个复制原数组的方法。</p> 
<pre><code class="prism language-json"><span class="token comment">// 定义数组</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 定义升序排序函数</span>
<span class="token keyword">var</span> <span class="token function-variable function">diffAsc</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 缓存升序排序方法</span>
<span class="token keyword">var</span> sortAsc <span class="token operator">=</span> <span class="token function">sort</span><span class="token punctuation">(</span>diffAsc<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 函数组合</span>
<span class="token keyword">function</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span>g<span class="token punctuation">,</span>h</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token function">h</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 定义复制数组方法</span>
<span class="token keyword">function</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义数组排序柯里化方法</span>
<span class="token keyword">function</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义数组翻转方法</span>
<span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 缓存组合函数，注意后面还有个()</span>
<span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>reverse<span class="token punctuation">,</span>sortAsc<span class="token punctuation">,</span>copy<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">res</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [3, 2, 1]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 3, 2] 没有改变原数组</span>
</code></pre> 
<p>这里 <code>compose</code> 方法只是一种简单实现，它的扩张性不好，只固定三层嵌套函数。</p> 
<p>好吧，我们直接看 <code>ramda.js</code> 是怎么实现的：</p> 
<pre><code class="prism language-json"><span class="token comment">// 引入 ramda 依赖</span>
<span class="token keyword">var</span> <span class="token constant">R</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ramda'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 定义数组</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 定义升序排序函数</span>
<span class="token keyword">var</span> <span class="token function-variable function">diffAsc</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 缓存组合了 R.reverse 和 R.sort 的函数</span>
<span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">compose</span><span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">.</span>reverse<span class="token punctuation">,</span><span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>diffAsc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">res</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [3, 2, 1]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 3, 2] 没有改变原数组</span>
</code></pre> 
<p><strong>注意：</strong></p> 
<ul><li><code>R.compose</code> 是从右往左执行函数组合。</li><li><code>R.reverse</code> 和 <code>R.sort</code> 是纯函数，它们复制了原数组，返回了一个新数组。</li><li>ramdajs 中很多方法类似 <code>R.sort</code> 这样。它们本身都是支持柯里化的，即 <code>R.sort( diffAsc, arr )</code> 和 <code>R.sort(diffAsc)(arr)</code> 是等效的，所以在使用组合函数 <code>R.compose</code> 时，里面的参数可以这样传 <code>R.sort(diffAsc)</code></li></ul> 
<p><strong>最后总结：</strong></p> 
<p>函数式编程诞生的年头已经不短了，我在写业务代码实现一些比较复杂的功能时，不知不觉地使用了这种范式，但没有完全严格遵守规范（实现过程中还有很多不足），通过写这篇文章也能总结出自己的不足。</p> 
<p>对于前端开发来说，JS能很强地支持函数式编程范式，我们无比幸运。充分掌握这个技能并把它用在对的场景是我们应该努力追寻的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/437ae014c1fdb0e861a9d1db9cc4470d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">软件测试技术（四）白盒测试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b5e16162d8d4e4cda7bd52b56dbed45d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue用使用异步&#43;reduce实现循环调用接口（上一个接口调用完毕再调用下一个接口）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>