<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>网络唤醒原理浅析(Wake On LAN) - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="网络唤醒原理浅析(Wake On LAN)" />
<meta property="og:description" content="原理 将唤醒魔术包发送的被唤醒机器的网卡上，魔术包指AMD公司开发的唤醒数据包，具有远程唤醒的网卡都支持这个标准，用16进制表示如下：
6对“FF”前缀&#43;16次重复MAC地址,举个例子假如我的网卡MAC地址是：AA:BB:CC:DD:EE:FF
那么魔术包就是:
0xFFFFFFFFFFAABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11 但是传送的时候必须封包成二进制格式才可以传送，简单来说，我们抽2个区段分析：
FFFFFFFFFFF 转成： 11111111 11111111 11111111 11111111 11111111 11111111
AABBCCDDEEFF11 转成：‭10101010 10111011 11001100 11011101 11101110 11111111 00010001‬
那么封包后就是把每个字节连接在一起：
11111111 11111111 11111111 11111111 11111111 11111111 10101010 10111011 11001100 11011101 11101110 11111111 00010001‬ ……..10101010 10111011 11001100 11011101 11101110 11111111 00010001‬（第16次） 开发实现 关键代码（Java）:
private String Wake(String name, String host, String mac, int port) { try { byte[] macBytes = getMacBytes(mac);//转成字节类型 byte[] bytes = new byte[6 &#43; 16 * macBytes." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/9b086063f60c7e6210181d89258b8ded/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-23T11:39:26+08:00" />
<meta property="article:modified_time" content="2023-11-23T11:39:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网络唤醒原理浅析(Wake On LAN)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>原理</h3> 
<p>将唤醒魔术包发送的被唤醒机器的网卡上，魔术包指AMD公司开发的唤醒数据包，具有远程唤醒的网卡都支持这个标准，用16进制表示如下：</p> 
<p><strong>6对“FF”</strong>前缀+16次重复MAC地址,举个例子假如我的网卡MAC地址是：<strong>AA:BB:CC:DD:EE:FF</strong><br> 那么魔术包就是:</p> 
<pre><code>0xFFFFFFFFFFAABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11AABBCCDDEEFF11</code></pre> 
<p>但是传送的时候必须封包成二进制格式才可以传送，简单来说，我们抽2个区段分析：<br> FFFFFFFFFFF 转成： 11111111 11111111 11111111 11111111 11111111 11111111</p> 
<p>AABBCCDDEEFF11 转成：‭10101010 10111011 11001100 11011101 11101110 11111111 00010001‬</p> 
<p>那么封包后就是把每个字节连接在一起：</p> 
<pre><code>11111111 11111111 11111111 11111111 11111111  11111111 10101010 10111011 11001100 11011101 11101110 11111111 00010001‬
……..10101010 10111011 11001100 11011101 11101110 11111111 00010001‬（第16次）</code></pre> 
<h3>开发实现</h3> 
<p>关键代码（Java）:</p> 
<pre><code>private String Wake(String name, String host, String mac, int port) {
       try {
           byte[] macBytes = getMacBytes(mac);//转成字节类型
           byte[] bytes = new byte[6 + 16 * macBytes.length];
           for (int i = 0; i &lt; 6; i++) {
               bytes[i] = (byte) 0xff;
           }
           for (int i = 6; i &lt; bytes.length; i += macBytes.length) {
               System.arraycopy(macBytes, 0, bytes, i, macBytes.length); //放入16个MAC地址
           }
           InetAddress address = InetAddress.getByName(host);
           DatagramPacket packet = new DatagramPacket(bytes, bytes.length, address, port);
           DatagramSocket socket = new DatagramSocket();
           socket.send(packet);
           socket.close();
           return "wol_package_sent_success";
       } catch (Exception e) {
           return "wol_package_sent_fail";
       }
   }</code></pre> 
<p></p> 
<pre><code>private static byte[] getMacBytes(String mac) throws IllegalArgumentException {
        byte[] bytes = new byte[6];
        String[] hex = mac.split("(\\:|\\-)");
        if (hex.length != 6) {
            throw new IllegalArgumentException("Invalid MAC address.");
        }
        try {
            for (int i = 0; i &lt; 6; i++) {
                bytes[i] = (byte) Integer.parseInt(hex[i], 16);
            }
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid hex digit in MAC address.");
        }
        return bytes;
    }</code></pre> 
<h3>数据包流向示意图</h3> 
<h3>局域网</h3> 
<p></p> 
<p class="img-center"><img alt="" height="367" src="https://images2.imgbox.com/a9/05/NZgR96Z8_o.png" width="800"></p> 
<p></p> 
<ol><li>魔术包通过手机或者电脑发送；</li><li>数据包经过路由器广播到每台机器；</li><li>被唤醒的电脑收到魔术包并且匹配成功，执行唤醒；</li><li>经过试验发现，如果电脑是待机状态，可以通过主机名或者具体IP如：192.168.1.200唤醒，如果是关机了则没有办法，我想应该是待机时候路由器分配给这个电脑的IP地址没有消失；</li></ol> 
<h3>公网</h3> 
<p></p> 
<p class="img-center"><img alt="" height="342" src="https://images2.imgbox.com/bf/1b/MtbUnJwa_o.png" width="800"></p> 
<p></p> 
<ol><li>魔术包通过路由器的域名：<a href="https://link.zhihu.com/?target=http%3A//mypc.router.net" rel="nofollow" title="http://mypc.router.net">http://mypc.router.net</a> 发送到路由器；</li><li>路由器收到数据，通过端口转发到相应的IP地址，192.168.1.100和端口9，告诉这台机器可以唤醒，ARP绑定必须存在，这个是因为很多无法远程唤醒的关键所在；看过另一种处理就是转发地址改成192.168.1.255 子网广播地址，端口不变也是9，好像就不用ARP绑定，这种方法理论上行得通，我这边暂时就不试验，试过的同学可以告诉我;</li><li>被唤醒的电脑收到魔术包并且匹配成功，执行唤醒；</li></ol> 
<h3>思考</h3> 
<p>可以看到局域网和公网唤醒存在差别：</p> 
<ol><li>局域网被唤醒的IP地址是广播地址：192.168.1.255，路由器收到后通过广播，数据包一定可以发送192.168.1.100这台机器；</li><li>公网唤醒我们无办法填写具体的内网地址，只能配置路由器的公网IP，然后通过数据转发到具体的电脑IP地址，由于不是广播地址，也由于路由器ARP映射表在电脑关机后一定时间会丢失，所以路由器没有办法知道192.168.1.100是MAC所对应那台机器，所以魔术包被丢弃，所以要么增加ARP绑定，要么添加端口转发规则到广播地址，困扰多年无法远程唤醒的问题解决。</li></ol> 
<p>参考链接:<a href="https://zhuanlan.zhihu.com/p/29100480" rel="nofollow" title="网络唤醒原理浅析(Wake On LAN) - 知乎">网络唤醒原理浅析(Wake On LAN) - 知乎</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7a094e470efcb57a9036e85c07fe6ddc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【前端】实际开发案例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df8510d95943e8fe8e8b512db8fc9775/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux虚拟机安装和开发环境配置(Ubuntu 22.04)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>