<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>为什么 select count(*) from t，在 InnoDB 引擎中比 MyISAM 慢？ - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="为什么 select count(*) from t，在 InnoDB 引擎中比 MyISAM 慢？" />
<meta property="og:description" content="统计一张表的总数量，是我们开发中常有的业务需求，通常情况下，我们都是使用 select count(*) from t SQL 语句来完成。随着业务数据的增加，你会发现这条语句执行的速度越来越慢，为什么它会变慢呢？
为什么会变慢？想要得到答案就需要知道 MySQL 是如何统计总数量的，先说一个前提吧，count(*) 的具体实现是由存储引擎实现的，也就是说不同的存储引擎实现的方式不一样。标题：为什么select count( * ) from t，在 InnoDB 引擎中比 MyISAM 慢？也是高频面试题。
InnoDB和MyISAM 是我们常用的 MySQL 存储引擎，所以主要对比一下 count(*) 在 InnoDB 和 MyISAM 中的实现：
在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count() from t 时，直接返回总数据。
在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count() from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。
知道了 InnoDB 和 MyISAM 引擎 count() 实现之后，为什么select count() from t，在 InnoDB 引擎中比 MyISAM 慢？应该有答案了吧，但是这个结论需要有一个前提，就是统计 SQL 不带过滤条件。如果 统计数量 SQL 语句为：select count(*) from t where x = 23，那么在 MyISAM 中就不一定比 InnoDB 快了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/bfd43a174e4f79b8d692075f078fcb54/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-03T10:43:17+08:00" />
<meta property="article:modified_time" content="2020-09-03T10:43:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">为什么 select count(*) from t，在 InnoDB 引擎中比 MyISAM 慢？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>统计一张表的总数量，是我们开发中常有的业务需求，通常情况下，我们都是使用 select count(*) from t SQL 语句来完成。随着业务数据的增加，你会发现这条语句执行的速度越来越慢，为什么它会变慢呢？</p> 
<p>为什么会变慢？想要得到答案就需要知道 MySQL 是如何统计总数量的，先说一个前提吧，count(*) 的具体实现是由存储引擎实现的，也就是说不同的存储引擎实现的方式不一样。标题：为什么select count( * ) from t，在 InnoDB 引擎中比 MyISAM 慢？也是高频面试题。</p> 
<p>InnoDB和MyISAM 是我们常用的 MySQL 存储引擎，所以主要对比一下 count(*) 在 InnoDB 和 MyISAM 中的实现：</p> 
<p>在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(<em>) from t 时，直接返回总数据。<br> 在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(</em>) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。<br> 知道了 InnoDB 和 MyISAM 引擎 count(<em>) 实现之后，为什么select count(</em>) from t，在 InnoDB 引擎中比 MyISAM 慢？应该有答案了吧，但是这个结论需要有一个前提，就是统计 SQL 不带过滤条件。如果 统计数量 SQL 语句为：select count(*) from t where x = 23，那么在 MyISAM 中就不一定比 InnoDB 快了。</p> 
<p>InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p> 
<p>不妨用一个例子来说明一下，假设现在 t 表中有 10000 条数据，现在有三个用户同时访问的会话：</p> 
<p>会话 A 先启动事务并查询一次表的总行数。<br> 会话 B 启动事务，插入一行后记录后，查询表的总行数。<br> 会话 C 先启动一个单独的语句，插入一行记录后，查询表的总行数。<br> 会话执行流程图<br> <img src="https://images2.imgbox.com/8d/8f/d47s3YUH_o.png" alt="在这里插入图片描述"></p> 
<p>假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。可以看出在最后时刻，三个会话返回的总行数不一样。</p> 
<p>出现不一样的结果跟 InnoDB 存储引擎有关系，在默认隔离级别可重复读的情况下，通过多版本并发控制（MVCC）来实现，每一行记录都需要判断自己是否对这个会话可见，因此在统计总数量时，InnoDB 只好把数据一行一行的读取出来判断，只有当前会话可见的才纳入统计中。所以同一时刻不同会话查询到的数量就不一样。</p> 
<p>InnoDB 引擎在 count(<em>)语句上也做了优化，我们知道，在 InnoDB 存储引擎中是以索引组织表的方式存储数据，主键索引树上叶子节点存放在所有的数据，而普通索引树的叶子节点是主键值，所以普通索引树会比主键索引树小很多，但是数量是一样的，也就是说遍历主键索引树和普通索引树得到的结果都是一样的。MySQL 就利用了这一特性，在 InnoDB 中执行 select count(</em>) from t 语句时，MySQL 优化器会找到最小的那棵索引树来遍历，这样可能就可以减少加载次数，在一定程度上提升了 count(*)的执行效率。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6191e9c9db2e84d44f0a40249f819035/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">五分钟做一个简单的响应式Godot GUI</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dc90f4c1cc3f6151343e074cbbd96078/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构顺序查找中对“哨兵“理解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>