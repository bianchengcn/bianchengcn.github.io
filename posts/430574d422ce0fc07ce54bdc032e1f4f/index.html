<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据分析二 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据分析二" />
<meta property="og:description" content="一、数据处理 当数据量较大时，将数据所有信息输出到控制台中会显得过于冗杂，可通过查看部分数据信息，简要了解数据的特性。
（1）查看数据前5行和尾部倒数5行数据，列名和索引信息，数据行列形状
csv.head()#查看前几行 csv.tail()#查看后几行 csv.columns#查看列名 csv.index#查看索引 csv.shape#查看形状 (2)查看各列数据描述性统计信息，如最小值、最大值、均值、标准差等
csv.describe() （3）查看数据是否有缺失及每列数据的类型
csv.info() 缺失值处理
对Pandas做数据时不可避免会因为一些原因出现缺失值NaN（Not a number），比如两个DataFrame对象进行运算时对于无法匹配的位置就会出现缺失值。通过数据信息查看可知数据中存在缺失值，比如dataA、dataC、dataE各存在2个NaN，dataB、dataD、各存在1个NaN。
（1）Pandas包中isnull()和notnull()方法用于判断数据是否为缺失值，若是缺失值则isnull()返回值为True，notnull()返回值为False。
csv.isnull() (2）由于isnull()和notnull()方法判断缺失值生成的是所有数据的True/False矩阵，对于庞大的Dataframe数据，很难一眼看出缺失值位置，可在df_csvload.isnull()矩阵基础上结合数据转置方法.T和筛选满足True值条件列方法.any()，查找出含有NaN值所在的行。
csv.isnull().T.any().T]#查看NAN值所在行 （3）对缺失值的处理的方法有删除和填充，此处通过DataFrame.dropna()方法将所有值都为缺失值的行删除，DataFrame.fillna()方法在列方向上对缺失值前值填充。
csv = csv.dropna(axis=0,how=&#39;all&#39;)#NAN值删除 行所有为NAN删除 csv.fillna(method=&#39;ffill&#39;,axis=0,inplace=True)#NAN值填充 列方向前值填充 csv[csv.isnull().values==True]#查看NAN值删除填充后值 二、数据重塑 一、stack
stack的计算机术语是“栈”，那么应用到DataFrame上，可以理解为将所有的列全部进行“入栈”操作(push)。可以看到，我们的DataFrame有以下列：[&#39;语文&#39;,&#39;英语&#39;,&#39;数学&#39;,&#39;物理&#39;]，把它们全部入栈，就是挨着把这些列一个个的压进去，最终就形成了一个新的索引列：[&#39;学科&#39;]
我们可以把stack操作叫做压缩，stack压缩操作带来的效果是：
由列变成了行：[&#39;语文&#39;,&#39;英语&#39;,&#39;数学&#39;,&#39;物理&#39;]这些列的数据，全部都变成了每一行。数据由原来的“宽格式”变成了“厚格式”：也即全部的列宽度都压缩到了行厚度上面，全部的列名称组成了一列新的索引。 stack操作的时候，默认会滤除缺失NaN数据
二、unstack
unstack是stack的逆操作：出栈把“栈”里面的数据全部弹出来(pop)
我们可以把unstack操作叫做解压，同理unstack解压操作带来的效果就刚好和stack相反：
由行变成了列：[&#39;学科&#39;]索引列里面的每行数据，全部都变成了单独的一列。数据由原来的“厚格式”变成了“宽格式”：也即全部的行厚度都释放到了列宽度上面，索引列中的全部成员都被分解成了单独的一列。 四、pivot
pivot---数据透视。这是excel的一大杀器！
（一）、unstack实现无索引解压
前面讲过了，unstack操作的效果是：索引列中的全部成员都被分解成了单独的一列。所以，unstack操作一般是要求要有索引列。但是有些时候，数据是没有明显的索引列的，
（二）、pivot实现无索引解压
上面的过程稍显复杂，于是Pandas定义一种快捷方法pivot来实现
df=df.pivot(index=,columns=) pivot本质上就是unstack的一种快捷方式，并不是一种新的重塑方法。二者的等价关系是：
pivot(index=&#39;目标索引列&#39;,columns=&#39;需要解压的列&#39;])
==等价于==
set_index([&#39;目标索引列&#39;,&#39;需要解压的列&#39;]).unstack(&#39;需要解压的列&#39;)
（三）、melt
pivot是unstack的快捷方式，那stack有没有类似的快捷等价方式呢？有，那就是melt。
df=df.melt(id_vars=[&#39;学生&#39;],var_name=&#39;科目&#39;,value_name=&#39;成绩&#39;) var_name参数用于指定压缩后的新列名称，value_name参数用于相应的数据列名称，通过这个操作，一步就直接到位
三、数据规整 数据连接
根据单个或者多个键(列)将不同的DataFrame的行进行连接
类似数据的连接操作
pd.merge:(left, right, how=‘inner’,on=None,left_on=None, right_on=None )
left:合并时左边的DataFrame
right:合并时右边的DataFrame
how:合并的方式,默认’inner’, ‘outer’, ‘left’, ‘right’
on:需要合并的列名,必须两边都有的列名，并以 left 和 right 中的列名的交集作为连接键" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/430574d422ce0fc07ce54bdc032e1f4f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-02T20:26:52+08:00" />
<meta property="article:modified_time" content="2023-09-02T20:26:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据分析二</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、数据处理</h2> 
<p>当数据量较大时，将数据所有信息输出到控制台中会显得过于冗杂，可通过查看部分数据信息，简要了解数据的特性。</p> 
<p>（1）查看数据前5行和尾部倒数5行数据，列名和索引信息，数据行列形状</p> 
<pre><code class="language-python">csv.head()#查看前几行   
csv.tail()#查看后几行
csv.columns#查看列名
csv.index#查看索引
csv.shape#查看形状</code></pre> 
<p>(2)查看各列数据描述性统计信息，如最小值、最大值、均值、标准差等</p> 
<pre><code class="language-python">csv.describe()</code></pre> 
<p>（3）查看数据是否有缺失及每列数据的类型</p> 
<pre><code class="language-python">csv.info()</code></pre> 
<p>缺失值处理<br> 对Pandas做数据时不可避免会因为一些原因出现缺失值NaN（Not a number），比如两个DataFrame对象进行运算时对于无法匹配的位置就会出现缺失值。通过数据信息查看可知数据中存在缺失值，比如dataA、dataC、dataE各存在2个NaN，dataB、dataD、各存在1个NaN。</p> 
<p>（1）Pandas包中isnull()和notnull()方法用于判断数据是否为缺失值，若是缺失值则isnull()返回值为True，notnull()返回值为False。</p> 
<pre><code class="language-python">csv.isnull()</code></pre> 
<p>(2）由于isnull()和notnull()方法判断缺失值生成的是所有数据的True/False矩阵，对于庞大的Dataframe数据，很难一眼看出缺失值位置，可在df_csvload.isnull()矩阵基础上结合数据转置方法.T和筛选满足True值条件列方法.any()，查找出含有NaN值所在的行。</p> 
<pre><code class="language-python">csv.isnull().T.any().T]#查看NAN值所在行</code></pre> 
<p>（3）对缺失值的处理的方法有删除和填充，此处通过DataFrame.dropna()方法将所有值都为缺失值的行删除，DataFrame.fillna()方法在列方向上对缺失值前值填充。</p> 
<pre><code class="language-python">
csv = csv.dropna(axis=0,how='all')#NAN值删除 行所有为NAN删除
csv.fillna(method='ffill',axis=0,inplace=True)#NAN值填充 列方向前值填充
csv[csv.isnull().values==True]#查看NAN值删除填充后值

</code></pre> 
<h2>二、数据重塑</h2> 
<p><strong>一、stack</strong></p> 
<p>stack的计算机术语是“栈”，那么应用到DataFrame上，可以理解为将所有的列全部进行“入栈”操作(push)。可以看到，我们的DataFrame有以下列：['语文','英语','数学','物理']，把它们全部入栈，就是挨着把这些列一个个的压进去，最终就形成了一个新的索引列：['学科']</p> 
<p><strong>我们可以把stack操作叫做压缩</strong>，stack压缩操作带来的效果是：</p> 
<ol><li>由列变成了行：['语文','英语','数学','物理']这些列的数据，全部都变成了每一行。</li><li>数据由原来的“宽格式”变成了“厚格式”：也即全部的列宽度都压缩到了行厚度上面，全部的列名称组成了一列新的索引。</li></ol> 
<p><strong>stack操作的时候，默认会滤除缺失NaN数据</strong></p> 
<p><strong>二、unstack</strong></p> 
<p>unstack是stack的逆操作：出栈把“栈”里面的数据全部弹出来(pop)</p> 
<p><strong>我们可以把</strong>unstack<strong>操作叫做解压，</strong>同理unstack解压操作带来的效果就刚好和stack相反：</p> 
<ol><li>由行变成了列：['学科']索引列里面的每行数据，全部都变成了单独的一列。</li><li>数据由原来的“厚格式”变成了“宽格式”：也即全部的行厚度都释放到了列宽度上面，索引列中的全部成员都被分解成了单独的一列。</li></ol> 
<p><strong>四、pivot</strong></p> 
<p>pivot---数据透视。这是excel的一大杀器！</p> 
<p><strong>（一）、unstack实现无索引解压</strong></p> 
<p>前面讲过了，unstack操作的效果是：<strong>索引列中的全部成员都被分解成了单独的一列</strong>。所以，unstack操作一般是要求要有索引列。但是有些时候，数据是没有明显的索引列的，</p> 
<p><strong>（二）、pivot实现无索引解压</strong></p> 
<p>上面的过程稍显复杂，于是Pandas定义一种快捷方法pivot来实现</p> 
<pre><code class="language-python">   df=df.pivot(index=,columns=)</code></pre> 
<p><strong>pivot本质上就是unstack的一种快捷方式，并不是一种新的重塑方法</strong>。二者的等价关系是：</p> 
<blockquote> 
 <p>pivot(index='目标索引列',columns='需要解压的列'])<br> ==等价于==<br> set_index(['目标索引列','需要解压的列']).unstack('需要解压的列')</p> 
</blockquote> 
<p><strong>（三）、melt</strong></p> 
<p>pivot是unstack的快捷方式，那stack有没有类似的快捷等价方式呢？有，那就是melt。</p> 
<pre><code class="language-python"> df=df.melt(id_vars=['学生'],var_name='科目',value_name='成绩')</code></pre> 
<p> var_name参数用于指定压缩后的新列名称，value_name参数用于相应的数据列名称，通过这个操作，一步就直接到位</p> 
<h2>三、数据规整</h2> 
<p>数据连接<br> 根据单个或者多个键(列)将不同的DataFrame的行进行连接</p> 
<p>类似数据的连接操作</p> 
<p>pd.merge:(left, right, how=‘inner’,on=None,left_on=None, right_on=None )</p> 
<p>left:合并时左边的DataFrame</p> 
<p>right:合并时右边的DataFrame</p> 
<p>how:合并的方式,默认’inner’, ‘outer’, ‘left’, ‘right’</p> 
<p>on:需要合并的列名,必须两边都有的列名，并以 left 和 right 中的列名的交集作为连接键</p> 
<p>left_on: left Dataframe中用作连接键的列<br> 关于how=‘inner’ ‘outer’ ‘left’ ‘right’<br> ‘inner’ 是把两个表中相同列名中的相同的键索引进行连接 不会出现nan<br> ‘outer’ 是把两个表中相同的列名中的所有对应关系都写入新表进行连接 会出现nan<br> ‘left’ 是把左边的表作为基准 进行连接 就是说两个表相同的列名 最后保存下来的键会全部是左边的表中的<br> ‘right’ 同理</p> 
<p><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f74c324d28bb4fc29f30c49218df460c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx 同一个端口支持http和https配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/61aa3cebbfa5520975f77fe95442e4b8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【随想】复杂与简单</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>