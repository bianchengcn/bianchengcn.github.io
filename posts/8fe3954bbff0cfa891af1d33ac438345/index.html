<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity  DrawCall详解 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity  DrawCall详解" />
<meta property="og:description" content="在实际项目开发中，提起unity优化，肯定是有DrawCall的相关内容的，下面就讲解一下什么是DrawCall以及如何对DrawCall进行优化操作。
一、什么是DrawCall？
在unity中，每次CPU准备数据并通知GPU的过程就称之为一个DrawCall。
具体过程就是：设置颜色--&gt;绘图方式--&gt;顶点坐标--&gt;绘制--&gt;结束，所以在绘制过程中，如果能在一次DrawCall完成所有绘制就会大大提高运行效率，进而达到优化的目的。
二、DrawCall为什么会影响游戏运行效率？
说道为什么会影响效率，就首先要了解一下他的工作原理：为了CPU和GPU可以进行并行工作，就需要一个命令缓冲区，就是由CPU向其中添加命令，然后又GPU从中读取命令，这样就实现了通过CPU准备数据，通知GPU进行渲染。
在每次调用DrawCall之前，CPU需要向GPU发送很多内容，主要是包括数据，渲染状态（就是设置对象需要的材质纹理等），命令等。CPU进行的操作具体就是：
准备渲染对象，然后将渲染对象从硬盘加载到内存，然后从内存加载到显存，进而方便GPU高速处理设置每个对象的渲染状态，也就是设置对象的材质、纹理、着色器等输出渲染图元，然后向GPU发送DrawCall命令，并将渲染图元传递给GPU 所以如果DrawCall数量过多就会导致CPU进行大量计算，进而导致CPU的过载，影响游戏运行效率。
三、如何优化DrawCall？
1.关于图集、材质、层级的处理，减少DrawCall
想看这些如何进行优化，就需要对他们的工作原理进行理解一下。下面我们以NGUI为例，讲解一下他们之间的关系：
NGUI主要是有三大模块组成：UIPanel，UIWidget，UIDrawcall组成，其中UIPanel是用来管理UIWidget控件和UIDrawCall，而UIWidget是所有组件的基类。
在NGUI框架中，会有一个静态的list用来存放所有的Panel，然后每个单独的Panel下会保存自己的UIWidget和UIDrawCall，就是在每次绘制的时候panle会遍历自己下面的所有层级下的子物体，直到查找结束，或者遇到新的panel会跳出当前分支，继续寻找其他分支，直到全部查找结束。所以说在实际运行中，每次都会为一个UIWidget绘制一个DrawCall，如果这时候连续的多个UIWidget使用的材质和纹理一致，就会公用一个DrawCall，下面给大家看下具体的情形：
这是使用不同材质和纹理的情况 这是使用相同的材质和纹理的情况​​​​​​ 所以并不是好多人的认知是只要同一个图集就会占用同一个DrawCall，通过上图分析发现不光是要使用同一个图集，还要使用同样的材质在同一个panel下才可以，否则就会重新进行调用一次DrawCall。另外需要注意的是，如果使用同一个图集、材质，但是中间夹杂了其他的渲染状态，也会导致重新调用一次DrawCall。
另外还需要注意一点就是在panel下如果动态的物体，就是为了实现某种效果，需要UI 进行位置移动，这种情况下，最好做成动态分离，因为只要panle下UI有移动，panle就会对清空之前的保存的UIWidget和UIDrawCall，重新进行渲染，这样就会造成性能浪费，有的同学会说这样不是增加了DrawCall吗，但是相对于每次都重新绘制，应该还是会更加节省性能的吧，你说呢?
所以说在对UI进行界面排布就需要对图集和层级做好规划，进而减少DrawCall次数。
2.关于批处理
批处理从字面意思就是一块处理多个物体的意思，但是是什么样的都可以进行批处理吗？答案就是使用同一个材质的物体才可以。unity中有个两种批处理方式，动态批处理和静态批处理。对于动态批处理来说，好处就是一切都是自动处理的，并且物体是可以移动的，但是限制颇多，具体有哪些限制下面会进行分析。对于静态批处理来说，好处就是自由度很高，限制条件少，但是它会占用更多的内存，并且经过批处理的物体不可以在进行移动。
首先说一下动态批处理，条件是物体使用同一个材质，并且满足对应的特定条件，unity就会自动为我们做动态批处理。
这里可以看到动态批处理中，四个物体但是只占用了三个DrawCall，就是unity进行了动态批处理，两个cube只占用了一个DrawCall。
下面说下动态批处理限制：
顶点属性最大限制900,使用lightmap的物体不行进行批处理使用MultiplePass的shader也不会进行批处理接受实时阴影的物体也不会进行批处理 下面说下静态批处理， 静态批处理前提当然也是使用了同一个材质，然后就是讲对应的对象设置为static：
这时你会发现DrallCall变为1了，这就是静态批处理的作用，但是这时候你会发现VBO Total比刚才大了，这就是静态批处理坏处，通过内存来换取性能，下面我们看下官方的解释：
如果在静态批处理前有一些物体共享了相同的网格（例如这里的两个箱子），那么每一个物体都会有一个该网格的复制品，即一个网格会变成多个网格被发送给GPU。在上面的例子看来，就是VBO的大小明显增大了。如果这类使用同一网格的对象很多，那么这就是一个问题了，这种时候我们可能需要避免使用静态批处理，这意味着牺牲一定的渲染性能。例如，如果在一个使用了1000个重复树模型的森林中使用静态批处理，那么结果就会产生1000倍的内存，这会造成严重的内存影响。
3.减少实时光的使用以及阴影效果
同样的设置，但是如果你将灯光的阴影效果打开，你会发现DrawCall大幅增加：
所以在项目中，如果想让场景更加完美，可以使用lightmap满足你想要的阴影效果。
综上所述就是要对图集进行和层级处理要做好整体规划，尽量将材质纹理合并，对于灯光的根据当前情况做好相应处理。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8fe3954bbff0cfa891af1d33ac438345/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-03T11:23:44+08:00" />
<meta property="article:modified_time" content="2019-01-03T11:23:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity  DrawCall详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在实际项目开发中，提起unity优化，肯定是有DrawCall的相关内容的，下面就讲解一下什么是DrawCall以及如何对DrawCall进行优化操作。</p> 
<p>一、什么是DrawCall？</p> 
<p>        在unity中，每次CPU准备数据并通知GPU的过程就称之为一个DrawCall。</p> 
<p>        具体过程就是：设置颜色--&gt;绘图方式--&gt;顶点坐标--&gt;绘制--&gt;结束，所以在绘制过程中，如果能在一次DrawCall完成所有绘制就会大大提高运行效率，进而达到优化的目的。</p> 
<p>二、DrawCall为什么会影响游戏运行效率？</p> 
<p style="text-indent:50px;">说道为什么会影响效率，就首先要了解一下他的工作原理：为了CPU和GPU可以进行并行工作，就需要一个命令缓冲区，就是由CPU向其中添加命令，然后又GPU从中读取命令，这样就实现了通过CPU准备数据，通知GPU进行渲染。</p> 
<p style="text-indent:50px;">在每次调用DrawCall之前，CPU需要向GPU发送很多内容，主要是包括数据，渲染状态（就是设置对象需要的材质纹理等），命令等。CPU进行的操作具体就是：</p> 
<ul><li>准备渲染对象，然后将渲染对象从硬盘加载到内存，然后从内存加载到显存，进而方便GPU高速处理</li><li>设置每个对象的渲染状态，也就是设置对象的材质、纹理、着色器等</li><li>输出渲染图元，然后向GPU发送DrawCall命令，并将渲染图元传递给GPU</li></ul> 
<p style="text-indent:50px;">所以如果DrawCall数量过多就会导致CPU进行大量计算，进而导致CPU的过载，影响游戏运行效率。</p> 
<p>三、如何优化DrawCall？</p> 
<blockquote> 
 <p>1.关于图集、材质、层级的处理，减少DrawCall</p> 
</blockquote> 
<p style="text-indent:50px;">想看这些如何进行优化，就需要对他们的工作原理进行理解一下。下面我们以NGUI为例，讲解一下他们之间的关系：</p> 
<p style="text-indent:50px;">NGUI主要是有三大模块组成：UIPanel，UIWidget，UIDrawcall组成，其中UIPanel是用来管理UIWidget控件和UIDrawCall，而UIWidget是所有组件的基类。</p> 
<p style="text-indent:50px;">在NGUI框架中，会有一个静态的list用来存放所有的Panel，然后每个单独的Panel下会保存自己的UIWidget和UIDrawCall，就是在每次绘制的时候panle会遍历自己下面的所有层级下的子物体，直到查找结束，或者遇到新的panel会跳出当前分支，继续寻找其他分支，直到全部查找结束。所以说在实际运行中，每次都会为一个UIWidget绘制一个DrawCall，如果这时候连续的多个UIWidget使用的材质和纹理一致，就会公用一个DrawCall，下面给大家看下具体的情形：</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="333" src="https://images2.imgbox.com/b8/93/lsiHRXni_o.png" width="571"> 
  <figcaption>
    这是使用不同材质和纹理的情况 
  </figcaption> 
 </figure> 
</div> 
<p> </p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="329" src="https://images2.imgbox.com/b2/90/lrlxzCfr_o.png" width="577"> 
  <figcaption>
    这是使用相同的材质和纹理的情况​​​​​​ 
  </figcaption> 
 </figure> 
</div> 
<p style="text-indent:50px;">所以并不是好多人的认知是只要同一个图集就会占用同一个DrawCall，通过上图分析发现不光是要使用同一个图集，还要使用同样的材质在同一个panel下才可以，否则就会重新进行调用一次DrawCall。另外需要注意的是，如果使用同一个图集、材质，但是中间夹杂了其他的渲染状态，也会导致重新调用一次DrawCall。</p> 
<p style="text-indent:50px;">另外还需要注意一点就是在panel下如果动态的物体，就是为了实现某种效果，需要UI 进行位置移动，这种情况下，最好做成动态分离，因为只要panle下UI有移动，panle就会对清空之前的保存的UIWidget和UIDrawCall，重新进行渲染，这样就会造成性能浪费，有的同学会说这样不是增加了DrawCall吗，但是相对于每次都重新绘制，应该还是会更加节省性能的吧，你说呢?</p> 
<p style="text-indent:50px;">所以说在对UI进行界面排布就需要对图集和层级做好规划，进而减少DrawCall次数。</p> 
<blockquote> 
 <p style="text-indent:0;">2.关于批处理</p> 
</blockquote> 
<p style="text-indent:50px;">批处理从字面意思就是一块处理多个物体的意思，但是是什么样的都可以进行批处理吗？答案就是使用同一个材质的物体才可以。unity中有个两种批处理方式，动态批处理和静态批处理。对于动态批处理来说，好处就是一切都是自动处理的，并且物体是可以移动的，但是限制颇多，具体有哪些限制下面会进行分析。对于静态批处理来说，好处就是自由度很高，限制条件少，但是它会占用更多的内存，并且经过批处理的物体不可以在进行移动。</p> 
<p style="text-indent:50px;">首先说一下动态批处理，条件是物体使用同一个材质，并且满足对应的特定条件，unity就会自动为我们做动态批处理。</p> 
<p><img alt="" class="has" height="521" src="https://images2.imgbox.com/5b/d2/9B4OUWWB_o.png" width="1200"></p> 
<p>这里可以看到动态批处理中，四个物体但是只占用了三个DrawCall，就是unity进行了动态批处理，两个cube只占用了一个DrawCall。</p> 
<p>下面说下动态批处理限制：</p> 
<ul><li>顶点属性最大限制900,</li><li>使用lightmap的物体不行进行批处理</li><li>使用MultiplePass的shader也不会进行批处理</li><li>接受实时阴影的物体也不会进行批处理</li></ul> 
<p style="text-indent:0;">下面说下静态批处理， 静态批处理前提当然也是使用了同一个材质，然后就是讲对应的对象设置为static：</p> 
<p style="text-indent:0;"><img alt="" class="has" height="519" src="https://images2.imgbox.com/62/56/OtijzPPh_o.png" width="1200"></p> 
<p>这时你会发现DrallCall变为1了，这就是静态批处理的作用，但是这时候你会发现VBO Total比刚才大了，这就是静态批处理坏处，通过内存来换取性能，下面我们看下官方的解释：</p> 
<p style="text-indent:50px;">如果在静态批处理前有一些物体共享了相同的网格（例如这里的两个箱子），那么每一个物体都会有一个该网格的复制品，即一个网格会变成多个网格被发送给GPU。在上面的例子看来，就是VBO的大小明显增大了。如果这类使用同一网格的对象很多，那么这就是一个问题了，这种时候我们可能需要避免使用静态批处理，这意味着牺牲一定的渲染性能。例如，如果在一个使用了1000个重复树模型的森林中使用静态批处理，那么结果就会产生1000倍的内存，这会造成严重的内存影响。<br>  </p> 
<blockquote> 
 <p style="text-indent:0;">3.减少实时光的使用以及阴影效果</p> 
</blockquote> 
<p style="text-indent:0;">同样的设置，但是如果你将灯光的阴影效果打开，你会发现DrawCall大幅增加：</p> 
<p style="text-indent:0;"><img alt="" class="has" height="466" src="https://images2.imgbox.com/97/84/w4ZkdkEx_o.png" width="1200"></p> 
<p style="text-indent:50px;">所以在项目中，如果想让场景更加完美，可以使用lightmap满足你想要的阴影效果。</p> 
<p style="text-indent:50px;">综上所述就是要对图集进行和层级处理要做好整体规划，尽量将材质纹理合并，对于灯光的根据当前情况做好相应处理。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8a69326c4a36efee5ad838bcbf52c7f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决MySQL开机提示 “High Severity Error”问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4d60350a0e8993bb9828680fd1e3fb4b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">windows在注册表中删除了HKEY_CLASSES_ROOT\.exe导致无法打开.exe文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>