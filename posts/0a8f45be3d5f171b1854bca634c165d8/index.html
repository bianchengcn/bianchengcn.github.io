<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>eigen基础操作 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="eigen基础操作" />
<meta property="og:description" content="Matrix基本使用 Eigen概述 - Go吧LpengSu | Blog (yueyuebird-su.github.io)
Eigen 学习笔记（一）_逐梦者-CSDN博客_eigen
Eigen中Matrix 与Vector相似
Matrix&lt;typename Scalar, //类型 int RowsAtCompileTime, int ColsAtCompileTime, int Options = 0, //默认是列优先 int MaxRowsAtCompileTime = RowsAtCompileTime, int MaxColsAtCompileTime = ColsAtCompileTime&gt; 基本运算 支持相同维数矩阵加减
支持乘除标量数
乘法（*）是矩阵乘法，不是对应元素相乘
基本方法 求转置、共轭矩阵、伴随矩阵 m.transpose(); m.conjugate(); m.adjoint(); 注意： 不能是 m=m.transpose();//因为会在转置运算结束之前就开始把结果写进a 所以必须是： b=a.transpose(); 其他用法 v.dot(w); //点乘 v.cross(w);//叉乘 Eigen::Matrix2d mat; mat &lt;&lt; 1, 2, 3, 4; cout &lt;&lt; &#34;Here is mat.sum(): &#34; &lt;&lt; mat.sum() &lt;&lt; endl; cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/0a8f45be3d5f171b1854bca634c165d8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-24T23:29:32+08:00" />
<meta property="article:modified_time" content="2022-02-24T23:29:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">eigen基础操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Matrix_0"></a>Matrix基本使用</h2> 
<p><a href="https://yueyuebird-su.github.io/2020/11/16/Eigen/" rel="nofollow">Eigen概述 - Go吧LpengSu | Blog (yueyuebird-su.github.io)</a></p> 
<p><a href="https://blog.csdn.net/f_zyj/article/details/82531991?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-1.control">Eigen 学习笔记（一）_逐梦者-CSDN博客_eigen</a></p> 
<p>Eigen中Matrix 与Vector相似</p> 
<pre><code class="prism language-c++">Matrix&lt;typename Scalar, //类型
       int RowsAtCompileTime,
       int ColsAtCompileTime,
       int Options = 0,  //默认是列优先
       int MaxRowsAtCompileTime = RowsAtCompileTime,
       int MaxColsAtCompileTime = ColsAtCompileTime&gt;

</code></pre> 
<h3><a id="_18"></a>基本运算</h3> 
<p>支持相同维数矩阵加减</p> 
<p>支持乘除标量数</p> 
<p>乘法（*）是矩阵乘法，不是对应元素相乘</p> 
<h3><a id="_26"></a>基本方法</h3> 
<h4><a id="_28"></a>求转置、共轭矩阵、伴随矩阵</h4> 
<pre><code class="prism language-c++">m.transpose();
m.conjugate();
m.adjoint();

注意：
不能是
m=m.transpose();//因为会在转置运算结束之前就开始把结果写进a
所以必须是：
b=a.transpose(); 
</code></pre> 
<h4><a id="_44"></a>其他用法</h4> 
<pre><code class="prism language-c++">v.dot(w); //点乘
v.cross(w);//叉乘
</code></pre> 
<pre><code class="prism language-c++">Eigen::Matrix2d mat;
  mat &lt;&lt; 1, 2,
         3, 4;
  cout &lt;&lt; "Here is mat.sum():       " &lt;&lt; mat.sum()       &lt;&lt; endl;
  cout &lt;&lt; "Here is mat.prod():      " &lt;&lt; mat.prod()      &lt;&lt; endl;
  cout &lt;&lt; "Here is mat.mean():      " &lt;&lt; mat.mean()      &lt;&lt; endl;
  cout &lt;&lt; "Here is mat.minCoeff():  " &lt;&lt; mat.minCoeff()  &lt;&lt; endl;
  cout &lt;&lt; "Here is mat.maxCoeff():  " &lt;&lt; mat.maxCoeff()  &lt;&lt; endl;
  cout &lt;&lt; "Here is mat.trace():     " &lt;&lt; mat.trace()     &lt;&lt; endl;//矩阵的迹等价于mat对角化后对角线元素之和a.diagonal().sum()

</code></pre> 
<blockquote> 
 <pre><code>Here is mat.sum():       10
Here is mat.prod():      24
Here is mat.mean():      2.5
Here is mat.minCoeff():  1
Here is mat.maxCoeff():  4
Here is mat.trace():     5
</code></pre> 
</blockquote> 
<p><a href="http://eigen.tuxfamily.org/dox/classEigen_1_1MatrixBase.html#ac7a03a61014f37ddd2fe61ebac0c9539" rel="nofollow">Eigen: Eigen::MatrixBase&lt; Derived &gt; Class Template Reference</a></p> 
<h4><a id="_75"></a>访问元素</h4> 
<pre><code class="prism language-c++">	MatrixXf m(2, 2);
	m = MatrixXf::Random(2, 2);
	cout &lt;&lt; m(1, 1) &lt;&lt; endl;
	cout &lt;&lt; m[0][0] &lt;&lt; endl;  //这样是错误的，对于matrix必须是括号访问
	VectorXd v(3);
	v = Vector3d::Random(3);
	cout &lt;&lt; v[0];
	cout &lt;&lt; v(1);
</code></pre> 
<pre><code class="prism language-c++">Matrix3f m = Matrix3f::Random();
  std::ptrdiff_t i, j;
  float minOfM = m.minCoeff(&amp;i,&amp;j);   //将m矩阵中最小数的位置传到i j ；把最小数传到minOfm
  cout &lt;&lt; "Here is the matrix m:\n" &lt;&lt; m &lt;&lt; endl;
  cout &lt;&lt; "Its minimum coefficient (" &lt;&lt; minOfM 
       &lt;&lt; ") is at position (" &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; ")\n\n";
</code></pre> 
<p>另外，Eigen提供了MatrixXf::Index ，</p> 
<pre><code>MatrixXf::Index rownum,colnum;//可以存储行列号
</code></pre> 
<h3><a id="Array_105"></a>Array（数组）使用</h3> 
<blockquote> 
 <p>如果你需要做线性代数运算，如矩阵乘法，那么你应该使用矩阵;如果需要进行系数方面的操作，那么应该使用数组。</p> 
</blockquote> 
<pre><code class="prism language-c++">Array&lt;float,3,3&gt;a,b;
```
a*b;//此处是a与b各个元素相乘

</code></pre> 
<pre><code>//array与Matrix不能混用，需要转换类型
.array();
.matrix();
</code></pre> 
<pre><code class="prism language-c++">int main()
{
  MatrixXf m(2,2);
  MatrixXf n(2,2);
  MatrixXf result(2,2);
 
  m &lt;&lt; 1,2,
       3,4;
  n &lt;&lt; 5,6,
       7,8;
 
  result = m * n;
  cout &lt;&lt; "-- Matrix m*n: --" &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
    //Eigen allows assigning array expressions to matrix variables
  result = m.array() * n.array();
  cout &lt;&lt; "-- Array m*n: --" &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
  result = m.cwiseProduct(n);
  cout &lt;&lt; "-- With cwiseProduct: --" &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
  result = m.array() + 4;
  cout &lt;&lt; "-- Array m + 4: --" &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
}
</code></pre> 
<h3><a id="block_146"></a>block分块</h3> 
<pre><code class="prism language-c++">int main()
{
  Eigen::MatrixXf m(4,4),a(2,2);
  m &lt;&lt;  1, 2, 3, 4,
        5, 6, 7, 8,
        9,10,11,12,
       13,14,15,16;
  cout &lt;&lt; "Block in the middle" &lt;&lt; endl;
  cout &lt;&lt; m.block&lt;2,2&gt;(1,1) &lt;&lt; endl &lt;&lt; endl;
      
  for (int i = 1; i &lt;= 3; ++i)
  {
    cout &lt;&lt; "Block of size " &lt;&lt; i &lt;&lt; "x" &lt;&lt; i &lt;&lt; endl;
    cout &lt;&lt; m.block(0,0,i,i) &lt;&lt; endl &lt;&lt; endl;
  }
     
  m.block&lt;2,2&gt;(1,1)=a; //可以赋值   
}
</code></pre> 
<blockquote> 
 <pre><code>Block in the middle
6  7
10 11

Block of size 1x1
1

Block of size 2x2
1 2
5 6

Block of size 3x3
1  2  3
5  6  7
9 10 11
</code></pre> 
</blockquote> 
<pre><code class="prism language-c++">void testblock() {
	Matrix&lt;float, 2, 2&gt; m;
	m = Matrix&lt;float, 2, 2&gt;::Constant(12);
	cout &lt;&lt; m &lt;&lt; endl;    //输出2*2的都是12的矩阵
}
</code></pre> 
<pre><code class="prism language-c++">//取某行或某列操作
m.col(2) += 3 * m.col(0);
</code></pre> 
<p><img src="https://images2.imgbox.com/54/95/rFc69cNp_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Vector_211"></a>对于Vector</h4> 
<pre><code class="prism language-c++">int main()
{
  Eigen::ArrayXf v(6);
  v &lt;&lt; 1, 2, 3, 4, 5, 6;
  cout &lt;&lt; "v.head(3) =" &lt;&lt; endl &lt;&lt; v.head(3) &lt;&lt; endl &lt;&lt; endl;
  cout &lt;&lt; "v.tail&lt;3&gt;() = " &lt;&lt; endl &lt;&lt; v.tail&lt;3&gt;() &lt;&lt; endl &lt;&lt; endl;
  v.segment(1,4) *= 2;
  cout &lt;&lt; "after 'v.segment(1,4) *= 2', v =" &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
}
</code></pre> 
<blockquote> 
 <pre><code>v.head(3) =
1
2
3

v.tail&lt;3&gt;() = 
4
5
6

after 'v.segment(1,4) *= 2', v =
1
4
6
8
10
6
</code></pre> 
</blockquote> 
<h3><a id="_249"></a>赋值方法</h3> 
<p>1.“&lt;&lt;”+逗号赋值法 前提：<mark>待赋值矩阵必须大小确定</mark></p> 
<pre><code class="prism language-c++">RowVectorXd vec1(3);
vec1 &lt;&lt; 1, 2, 3;
std::cout &lt;&lt; "vec1 = " &lt;&lt; vec1 &lt;&lt; std::endl;
 
RowVectorXd vec2(4);
vec2 &lt;&lt; 1, 4, 9, 16;
std::cout &lt;&lt; "vec2 = " &lt;&lt; vec2 &lt;&lt; std::endl;
 
RowVectorXd joined(7);
joined &lt;&lt; vec1, vec2;
std::cout &lt;&lt; "joined = " &lt;&lt; joined &lt;&lt; std::endl;
</code></pre> 
<p>2.特殊赋值</p> 
<pre><code class="prism language-c++">Array33f::Zero();
MatrixXf::Ones(3,2);
MatrixXf::Constant(5,2,1.58);
MatrixXf mat = MatrixXf::Random(2, 3);
</code></pre> 
<pre><code class="prism language-c++">ArrayXXf table(10, 4);
table.col(0) = ArrayXf::LinSpaced(10, 0, 90);  //0--90  取10个数
table.col(1) = M_PI / 180 * table.col(0);
table.col(2) = table.col(1).sin();
table.col(3) = table.col(1).cos();
std::cout &lt;&lt; "  Degrees   Radians      Sine    Cosine\n";
std::cout &lt;&lt; table &lt;&lt; std::endl;
</code></pre> 
<h3><a id="Reductions_visitors_and_broadcasting_292"></a><strong>Reductions, visitors and broadcasting</strong></h3> 
<pre><code class="prism language-c++">int main()
{
  VectorXf v(2);
  MatrixXf m(2,2), n(2,2);
  
  v &lt;&lt; -1,
       2;
  
  m &lt;&lt; 1,-2,
       -3,4;
 
  cout &lt;&lt; "v.squaredNorm() = " &lt;&lt; v.squaredNorm() &lt;&lt; endl;   //计算平方范数      5 
  cout &lt;&lt; "v.norm() = " &lt;&lt; v.norm() &lt;&lt; endl;                 //计算平方范数的根   2.23607
  cout &lt;&lt; "v.lpNorm&lt;1&gt;() = " &lt;&lt; v.lpNorm&lt;1&gt;() &lt;&lt; endl;       //求取矩阵一范数   3
  cout &lt;&lt; "v.lpNorm&lt;Infinity&gt;() = " &lt;&lt; v.lpNorm&lt;Infinity&gt;() &lt;&lt; endl;  //求取无穷范数    2
 
  cout &lt;&lt; endl;
  cout &lt;&lt; "m.squaredNorm() = " &lt;&lt; m.squaredNorm() &lt;&lt; endl;
  cout &lt;&lt; "m.norm() = " &lt;&lt; m.norm() &lt;&lt; endl;
  cout &lt;&lt; "m.lpNorm&lt;1&gt;() = " &lt;&lt; m.lpNorm&lt;1&gt;() &lt;&lt; endl;
  cout &lt;&lt; "m.lpNorm&lt;Infinity&gt;() = " &lt;&lt; m.lpNorm&lt;Infinity&gt;() &lt;&lt; endl;
}
</code></pre> 
<pre><code class="prism language-c++">void test03() {
	ArrayXXf a(2, 2);
	a &lt;&lt; 1, 2,
		3, 4;
	cout &lt;&lt; "(a &gt; 0).all()   = " &lt;&lt; (a &gt; 0).all() &lt;&lt; endl;    //1
	cout &lt;&lt; "(a &gt; 0).any()   = " &lt;&lt; (a &gt; 0).any() &lt;&lt; endl;    //1
	cout &lt;&lt; "(a &gt; 0).count() = " &lt;&lt; (a &gt; 0).count() &lt;&lt; endl;  //4
	cout &lt;&lt; endl;
}
</code></pre> 
<h4><a id="colwise_and_broadcasting_339"></a>colwise() and broadcasting</h4> 
<pre><code class="prism language-c++">void test04() {
	Eigen::MatrixXf mat(2, 4);
	mat &lt;&lt; 1, 2, 6, 9,
		3, 1, 7, 2;

	std::cout &lt;&lt; "Column's maximum: " &lt;&lt; std::endl
		&lt;&lt; mat.colwise().maxCoeff() &lt;&lt; std::endl;  //
    //如果单纯mat.maxCoeff();返回的是整个mat最大值，此时返回值只有9；
    //但是有了colwise(),则为按列求取最大值，返回值为各列最大值  3 2 7 9 
}
</code></pre> 
<p>colwise还可以实现如下功能</p> 
<pre><code class="prism language-c++">Eigen::MatrixXf mat(2,4);
Eigen::VectorXf v(2);
  
mat &lt;&lt; 1, 2, 6, 9,
         3, 1, 7, 2;
         
v &lt;&lt; 0,
     1;
       
//add v to each column of m
mat.colwise() += v;
//1 2 6 9
//4 2 8 3
</code></pre> 
<p>col-wise同理</p> 
<p>需要注意的是：“+”后面的那个必须是Vector，否则程序报错</p> 
<h4><a id="broadcasting_376"></a>broadcasting与其他操作可以结合</h4> 
<pre><code class="prism language-c++">int main()
{
  Eigen::MatrixXf m(2,4);
  Eigen::VectorXf v(2);
  
  m &lt;&lt; 1, 23, 6, 9,
       3, 11, 7, 2;
       
  v &lt;&lt; 2,
       3;
 
  MatrixXf::Index index;
  // find nearest neighbour
  (m.colwise() - v).colwise().squaredNorm().minCoeff(&amp;index);
 
  cout &lt;&lt; "Nearest neighbour is column " &lt;&lt; index &lt;&lt; ":" &lt;&lt; endl;  //0
  cout &lt;&lt; m.col(index) &lt;&lt; endl;    //1  3
}
</code></pre> 
<h3><a id="Map_403"></a>Map</h3> 
<p>Map中提供了Eigen与C++基本数组转换的方法，即通过指针与所占内存空间进行转换</p> 
<pre><code class="prism language-c++">void testMap02() {
	int data[] = { 1,2,3,4,5,6,7,8,9 };
	Map&lt;RowVectorXi&gt; v(data, 4);
	cout &lt;&lt; "The mapped vector v is: " &lt;&lt; v &lt;&lt; "\n";
	new (&amp;v) Map&lt;RowVectorXi&gt;(data + 4, 5);
	cout &lt;&lt; "Now v is: " &lt;&lt; v &lt;&lt; "\n";
}
</code></pre> 
<p>目前还不知道如何将Map与std::vector直接转换</p> 
<h3><a id="_423"></a>矩阵内部重叠问题</h3> 
<p>Eigen中用aliasing描述这一问题</p> 
<p>1.在以下例子中重叠没有问题：</p> 
<pre><code class="prism language-c++">mat.bottomRightCorner(2,2) = mat.topLeftCorner(2,2);  //相当于将矩阵自身左上角四个元素赋值给右下角
</code></pre> 
<p>2.但是当<code>a = a.transpose();</code>时就会因为重叠出现非编译错误</p> 
<p>所以如何解决aliasing问题？</p> 
<p>我们可以使用eval()函数：</p> 
<pre><code class="prism language-c++">a = a.transpose().eval();//原理大概是预先取一块内存空间，暂存a.transpose()结果，然后再复制给等式左边
</code></pre> 
<p>当然对于转置，Eigen提供了：</p> 
<pre><code class="prism language-c++">a.transposeInPlace();//在原位置直接实现转置
</code></pre> 
<h4><a id="_451"></a>其他常用方法的重叠解决方法</h4> 
<p><img src="https://images2.imgbox.com/71/fb/FeL1xXh8_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_456"></a>总结</h4> 
<p>1.alias对于标量计算、array和Matrrix加法是没有威胁的</p> 
<p>2.当你使用矩阵乘法时，他默认会发生重叠。当你肯定重叠不会产生影响时，则可以使用<strong>noalias()</strong></p> 
<pre><code class="prism language-c++">MatrixXf matA(2,2), matB(2,2); 
matA &lt;&lt; 2, 0,  0, 2;
 
// Simple but not quite as efficient
matB = matA * matA;
cout &lt;&lt; matB &lt;&lt; endl &lt;&lt; endl;
 
// More complicated but also more efficient
matB.noalias() = matA * matA;
cout &lt;&lt; matB;  
//两个B一样
</code></pre> 
<p>3.其他情况下，Eigen都默认不会重叠，所以需要判断，视情况加.eval();</p> 
<p>4.从版本3.3之后，对于矩阵乘法，如果矩阵shape改变并且乘积结果不是直接赋值给左边，则也默认不会重叠！！</p> 
<pre><code class="prism language-c++">MatrixXf A(2,2), B(3,2);
B &lt;&lt; 2, 0,  0, 3, 1, 1;
A &lt;&lt; 2, 0, 0, -2;
A = (B * A).cwiseAbs();  //由于B*A后面跟了方法，不是直接赋值，所以此处发生重叠，结果错误
//必须是：
A = (B * A).eval().cwiseAbs();
cout &lt;&lt; A;
</code></pre> 
<h3><a id="ColMajorRowMajor_492"></a>ColMajor&amp;RowMajor</h3> 
<pre><code class="prism language-c++">void ColRowMajor() {
	Matrix&lt;int, 3, 3, ColMajor&gt; m;
	m &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9;
	for (int i = 0; i &lt; 9; i++) {
		cout &lt;&lt; *(m.data() + i) &lt;&lt; endl;//结果是：1 4 7 2 5 8 3 6 9
	}
}
</code></pre> 
<p>如何选择：一般选择行存储，则按行遍历更快；Eigen默认是列，里面很多算法都是列优先，所以我们在选择时最好还是按照列优先</p> 
<h2><a id="_508"></a>线性代数和分解</h2> 
<p><img src="https://images2.imgbox.com/1c/ff/X7YchXl8_o.png" alt="在这里插入图片描述"></p> 
<p>上表都是矩阵分解的方法，第一列是类名，第二列是类成员函数。这些类都有solve函数以及inverse函数</p> 
<pre><code class="prism language-c++">//以下形式便于理解类型
ColPivHouseholderQR&lt;Matrix3f&gt; dec(A);
Vector3f x = dec.solve(b);
</code></pre> 
<pre><code class="prism language-c++">HouseholderQR&lt;MatrixXf&gt; qr(50,50);
MatrixXf A = MatrixXf::Random(50,50);
qr.compute(A); // no dynamic memory allocation
qr.inverse();
</code></pre> 
<p>//一般用以下方法求解<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          A 
         
        
          x 
         
        
          = 
         
        
          b 
         
        
       
         Ax=b 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span></span></p> 
<pre><code class="prism language-c++">Matrix2f x = A.ldlt().solve(b);
</code></pre> 
<p>一般用以下方法求<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          A 
         
         
         
           − 
          
         
           1 
          
         
        
       
      
        A^{-1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></p> 
<pre><code>A.colPivHouseholderQr().inverse();
</code></pre> 
<p>检验显示：<code>m.colPivHouseholderQr().inverse()</code>求解逆矩阵比<code>m.inverse()</code> 更准确</p> 
<h3><a id="__545"></a>特征值 特征向量</h3> 
<pre><code class="prism language-c++">void eigenvalues() {
	Matrix2f A;
	A &lt;&lt; 1, 2, 2, 3;
	cout &lt;&lt; "Here is the matrix A:\n" &lt;&lt; A &lt;&lt; endl;
	SelfAdjointEigenSolver&lt;Matrix2f&gt; eigensolver(A);
	if (eigensolver.info() != Success) abort();
	cout &lt;&lt; "The eigenvalues of A are:\n" &lt;&lt; eigensolver.eigenvalues() &lt;&lt; endl;  //特征值
	cout &lt;&lt; "Here's a matrix whose columns are eigenvectors of A \n"
		&lt;&lt; "corresponding to these eigenvalues:\n"
		&lt;&lt; eigensolver.eigenvectors() &lt;&lt; endl;  //特征向量
}
</code></pre> 
<p>注意：此时的特征值 特征向量不是从大到小排列</p> 
<pre><code class="prism language-c++">EigenSolver&lt;MatrixXf&gt; solver(covMat);
featureValue = solver.pseudoEigenvalueMatrix().diagonal();
featureVector = solver.pseudoEigenvectors();
</code></pre> 
<h2><a id="_571"></a>稀疏矩阵</h2> 
<p>稀疏矩阵（Sparse Martix）需要include以下头文件<br> <img src="https://images2.imgbox.com/87/91/quAYG54O_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_580"></a>几何模块</h2> 
<pre><code class="prism language-c++">#include &lt;Eigen/Geometry&gt; 
</code></pre> 
<h3><a id="AlignedBox_586"></a>AlignedBox</h3> 
<p>这一模块用于包围盒操作</p> 
<pre><code class="prism language-c++">Eigen::AlignedBox&lt; Scalar, AmbientDim &gt;//&lt;float,3&gt;
</code></pre> 
<p>简单实例：<br> <img src="https://images2.imgbox.com/89/e0/e2W9ixg2_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c++">void testAlignedBox() {
	AlignedBox2d myAlignedBox;
	Vector2d m;
	m &lt;&lt; 1, 0.5;
	myAlignedBox.extend(m);
	m &lt;&lt; 2, 2;
	myAlignedBox.extend(m);
	cout &lt;&lt;"max():"&lt;&lt;myAlignedBox.max() &lt;&lt; endl;//返回最大的corner
	m &lt;&lt; 3, 4;
	cout &lt;&lt; "exteriorDistance():" &lt;&lt; myAlignedBox.exteriorDistance(m) //外部一个向量m与包围盒距离
		&lt;&lt; "squaredExteriorDistance():" &lt;&lt; myAlignedBox.squaredExteriorDistance(m) &lt;&lt; endl;//外部一向量与包围盒距离平方
	

	//再构建一个alignedBox
	AlignedBox2d myAlignedBox2,myalignedBox3;
	Vector2d b;
	b &lt;&lt; 0.5, 0.5;
	myAlignedBox2.extend(b);
	b &lt;&lt; 1.5, 1.5;
	myAlignedBox2.extend(b);
	myalignedBox3 = myAlignedBox2.intersection(myAlignedBox);//1 2 做交集  此外，intersects（）返回的是bool值
	cout &lt;&lt; myalignedBox3.BottomLeft &lt;&lt; endl;
	b &lt;&lt; 1.25, 1;
	cout &lt;&lt;"contains (0 or 1):"&lt;&lt; myalignedBox3.contains(b) &lt;&lt; endl;//看b是否在myalignedBox3中，参数也可以是box
	cout &lt;&lt; "diagonal():" &lt;&lt; myalignedBox3.diagonal() &lt;&lt; endl;//对角线向量

	cout &lt;&lt; "random sample:" &lt;&lt; myAlignedBox.sample() &lt;&lt; endl;//以均匀分布抽样的边界框内的随机点

	cout &lt;&lt; "sizes():" &lt;&lt; myalignedBox3.sizes() &lt;&lt; endl;//myalignBox3的长宽//vector
}
</code></pre> 
<p>cornerType:<br> <img src="https://images2.imgbox.com/18/7a/LKQqSVhX_o.png" alt="在这里插入图片描述"></p> 
<p>transform和translate稍后再看</p> 
<h3><a id="AngleAxis_636"></a><strong>AngleAxis</strong></h3> 
<p>注意：AngleAxis运用时：Axis的轴需要<strong>归一化</strong></p> 
<blockquote> 
 <p>首先，Eigen在MatrixBase中定义了</p> 
 <p>UnitX(); UnitY(); UnitZ(); UnitW(); 作为默认的四个轴</p> 
 <p>例如：<code>Vector3d::UnitX();</code> 必须是固定大小的</p> 
</blockquote> 
<h2><a id="_650"></a>附录</h2> 
<h3><a id="_652"></a>将特征值特征向量按特征值大小排列</h3> 
<pre><code class="prism language-c++">using eigMatrix = Eigen::Matrix&lt;float, Eigen::Dynamic, Eigen::Dynamic&gt;;
using eigVector = Eigen::Matrix&lt;float, Eigen::Dynamic, 1&gt;;
using stdTupleEigen = std::tuple&lt;float, eigMatrix&gt;;
using stdVectorTuple = std::vector&lt;stdTupleEigen&gt;;
void sortEigenVectorByValues(eigVector&amp; eigenValues, eigMatrix&amp; eigenVectors)
{
	stdVectorTuple eigenValueAndVector;
	int size = static_cast&lt;int&gt;(eigenValues.size());  //强制转换

	eigenValueAndVector.reserve(size);
	for (int i = 0; i &lt; size; ++i)
		eigenValueAndVector.push_back(stdTupleEigen(eigenValues[i], eigenVectors.col(i)));

	// 使用标准库中的sort，按从大到小排序
	std::sort(eigenValueAndVector.begin(), eigenValueAndVector.end(),
		[&amp;](const stdTupleEigen&amp; a, const stdTupleEigen&amp; b) -&gt; bool {
			return std::get&lt;0&gt;(a) &gt; std::get&lt;0&gt;(b);
		});

	for (int i = 0; i &lt; size; ++i) {
		eigenValues[i] = std::get&lt;0&gt;(eigenValueAndVector[i]); // 排序后的特征值
		eigenVectors.col(i).swap(std::get&lt;1&gt;(eigenValueAndVector[i])); // 排序后的特征向量
	}
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e45725f57a30c3e968129c2c59c9ba25/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Shell脚本中读取文件每一行的方法总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/148005ec36bd37d283c72e1d8fb9947a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UI网站大合集</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>