<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis-Lua脚本详解 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis-Lua脚本详解" />
<meta property="og:description" content="如果我们想逻辑性的一起执行多条指令，在执行过程不被别的请求打断，那么Redis提供了Lua脚本，Redis服务器会单线程原子性执行lua脚本，保证了在执行过程中不会被其他请求打断。
通过Lua脚本执行多个指令 if redis.call(&#34;get&#34;,KEYS[1]) == ARGV[1] then
return redis.call(&#34;del&#34;,KEYS[1])
else
return 0
end
解析：如果通过key获取的数据与第一个入参相等，则将该key删除，并且返回，否则返回0。
将上面的脚本转换成Redis可以识别的格式，采用EVAL指令，如下
127.0.0.1:6379&gt; set name dog
OK
127.0.0.1:6379&gt; eval &#39;if redis.call(&#34;get&#34;,KEYS[1]) == ARGV[1] then return redis.call(&#34;del&#34;,KEYS[1]) else return 0 end&#39; 1 name dog
(integer) 1
127.0.0.1:6379&gt; eval &#39;if redis.call(&#34;get&#34;,KEYS[1]) == ARGV[1] then return redis.call(&#34;del&#34;,KEYS[1]) else return 0 end&#39; 1 name dog
(integer) 0
解析：第二次执行返回0的原因是第一次已经把它删除了。
例如Redission中实现分布式锁就是利用执行Lua脚本，所以保证了设置key&#43;过期时间 原子性，如下所示：
&#34;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &#34; &#43; &#34;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1); &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/217e7ecbd4ccb74e20747afdd3a1352f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-24T17:19:52+08:00" />
<meta property="article:modified_time" content="2022-03-24T17:19:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis-Lua脚本详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;">如果我们想逻辑性的一起执行多条指令，在执行过程不被别的请求打断，那么Redis提供了Lua脚本，Redis服务器会单线程原子性执行lua脚本，保证了在执行过程中不会被其他请求打断。</p> 
<h4 style="margin-left:0cm;">通过Lua脚本执行多个指令</h4> 
<blockquote> 
 <p style="margin-left:0cm;"><strong><span style="color:#333333;">if</span></strong><span style="color:#333333;"> redis.call(</span><span style="color:#dd1144;">"get"</span><span style="color:#333333;">,KEYS[1]) == ARGV[1] </span><strong><span style="color:#333333;">then</span></strong></p> 
 <p style="margin-left:0cm;">    <span style="color:#0086b3;">return</span><span style="color:#333333;"> redis.call(</span><span style="color:#dd1144;">"del"</span><span style="color:#333333;">,KEYS[1])</span></p> 
 <p style="margin-left:0cm;"><strong><span style="color:#333333;">else</span></strong></p> 
 <p style="margin-left:0cm;">    <span style="color:#0086b3;">return</span><span style="color:#333333;"> 0</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">end</span></p> 
</blockquote> 
<p style="margin-left:0cm;">解析：如果通过key获取的数据与第一个入参相等，则将该key删除，并且返回，否则返回0。</p> 
<p style="margin-left:0cm;">将上面的脚本转换成Redis可以识别的格式，采用EVAL指令，如下</p> 
<blockquote> 
 <p style="margin-left:0cm;"><span style="color:#333333;">127.0.0.1:6379&gt; </span><span style="color:#0086b3;">set</span><span style="color:#333333;"> name dog</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">OK</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">127.0.0.1:6379&gt; </span><span style="color:#0086b3;">eval</span> <span style="color:#dd1144;">'if redis.call("get",KEYS[1]) == ARGV[1] then return redis.call("del",KEYS[1]) else return 0 end'</span><span style="color:#333333;"> 1 name dog</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">(</span><span style="color:#0086b3;">integer</span><span style="color:#333333;">) 1</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">127.0.0.1:6379&gt; </span><span style="color:#0086b3;">eval</span> <span style="color:#dd1144;">'if redis.call("get",KEYS[1]) == ARGV[1] then return redis.call("del",KEYS[1]) else return 0 end'</span><span style="color:#333333;"> 1 name dog</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">(</span><span style="color:#0086b3;">integer</span><span style="color:#333333;">) 0</span></p> 
</blockquote> 
<p style="margin-left:0cm;">解析：第二次执行返回0的原因是第一次已经把它删除了。</p> 
<p style="margin-left:0cm;">例如Redission中实现分布式锁就是利用执行Lua脚本，所以保证了设置key+过期时间 原子性，如下所示：</p> 
<blockquote> 
 <p style="margin-left:0cm;">"if (redis.call('exists', KEYS[1]) == 0) then " +  "redis.call('hset', KEYS[1], ARGV[2], 1); " +            "redis.call('pexpire', KEYS[1], ARGV[1]); " + "return nil; " +  "end; " + "if        (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +  "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +  "redis.call('pexpire', KEYS[1], ARGV[1]); " +  "return nil; " + "end; " +   "return redis.call('pttl', KEYS[1]);"</p> 
</blockquote> 
<h4 style="margin-left:0cm;">SCRIPT LOAD 和 EVALSHA指令</h4> 
<p style="margin-left:0cm;">上述lua脚本可能存在一个风险，如果某个lua脚本的内容长，而且客户端频繁操作，如果每次都需要传递那么大的脚本，必然存在浪费网络流量，所以Redis提供SCRIPT LOAD 和 EVALSHA指令</p> 
<p style="margin-left:0cm;">1) SCRIPT LOAD 指令用于将客户端提供的 lua 脚本上传到服务器但不执行，上传后会返回脚本的唯一ID，这个唯一ID是用来获取服务器缓存的这段lua脚本，如下：</p> 
<blockquote> 
 <p style="margin-left:0cm;"><span style="color:#333333;">127.0.0.1:6379&gt; <strong>script load</strong> </span><span style="color:#dd1144;">'local curVal = redis.call("get", KEYS[1]); if curVal == false then curVal = 0 else curVal = tonumber(curVal) end; curVal = curVal * tonumber(ARGV[1]); redis.call("set", KEYS[1], curVal); return curVal'"be4f93d8a5379e5e5b768a74e77c8a4eb0434441"</span></p> 
</blockquote> 
<p style="margin-left:0cm;">将得到一个ID <span style="color:#dd1144;">be4f93d8a5379e5e5b768a74e77c8a4eb0434441</span></p> 
<p style="margin-left:0cm;">2）EVALSHA指令用来执行该Lua脚本，例如：</p> 
<blockquote> 
 <p style="margin-left:0cm;"><span style="color:#333333;">127.0.0.1:6379&gt; evalsha be4f93d8a5379e5e5b768a74e77c8a4eb0434441 1 notexistskey 5</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">(</span><span style="color:#0086b3;">integer</span><span style="color:#333333;">) 0</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">127.0.0.1:6379&gt; evalsha be4f93d8a5379e5e5b768a74e77c8a4eb0434441 1 notexistskey 5</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">(</span><span style="color:#0086b3;">integer</span><span style="color:#333333;">) 0</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">127.0.0.1:6379&gt; </span><span style="color:#0086b3;">set</span><span style="color:#333333;"> foo 1</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">OK</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">127.0.0.1:6379&gt; evalsha be4f93d8a5379e5e5b768a74e77c8a4eb0434441 1 foo 5</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">(</span><span style="color:#0086b3;">integer</span><span style="color:#333333;">) 5</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">127.0.0.1:6379&gt; evalsha be4f93d8a5379e5e5b768a74e77c8a4eb0434441 1 foo 5</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">(</span><span style="color:#0086b3;">integer</span><span style="color:#333333;">) 25</span></p> 
</blockquote> 
<p style="margin-left:0cm;">解析：前俩句由于redis不存在 key <span style="color:#333333;">notexistskey </span><span style="color:#333333;">值为</span><span style="color:#333333;">5</span><span style="color:#333333;">的情况，所有返回</span><span style="color:#333333;">0。</span></p> 
<h4 style="margin-left:0cm;">错误处理函数pcall()与call()</h4> 
<p style="margin-left:0cm;">1）pcall(f)函数运行在保护模式下，如果f出现错误，调用pcall()返回false和错误消息。</p> 
<p style="margin-left:0cm;">2）call(f)函数，如果f出现错误时只会向上抛出异常。</p> 
<h4 style="margin-left:0cm;">脚本死循环</h4> 
<p style="margin-left:0cm;">从上面可知Redis能够执行脚本，但是如果该脚本存在一点，导致发生了死循环或者是执行时间特别特别长，那么会导致后续的请求无法被处理。Redis为了解决这个问题，它提供了<strong>script kill</strong> 指令用于动态结束一个执行时间超时的 lua 脚本。但是 <strong>script kill</strong> 的执行有一个重要的前提条件，那就是当前正在执行的脚本没有对 Redis 的内部数据状态进行修改，因为 Redis 不允许 <strong>script kill</strong> 破坏脚本执行的原子性。例如脚本内部使用了redis.call("set", key, value) 修改了内部的数据，那么 script kill 执行时服务器会返回错误。</p> 
<h4 style="margin-left:0cm;">Script Kill 的原理</h4> 
<p style="margin-left:0cm;">Lua 脚本引擎功能太强大了，它提供了各种钩子函数，它允许在内部虚拟机执行指令时运行钩子代码。比如每执行 N 条指令执行一次某个钩子函数，Redis 正是使用了这个钩子函数。如下图36</p> 
<p style="text-align:center;"><img alt="" class="has" height="400" src="https://images2.imgbox.com/fd/38/kWCq6HvI_o.jpg" width="350"></p> 
<h4 style="margin-left:0cm;"></h4> 
<p> Redis在钩子函数里会去处理客户端的请求，并且只有在发现 Lua 脚本执行超时之后才会去处理请求，这个超时时间默认是5秒。所以当脚本卡死后，执行kill命令，会出现执行时间比较长的现象。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e036e33b2c8dfe27c3cd78987e1eeede/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">内部 IP 地址泄露/在Web服务器上发现不必要的文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d118da2aea67d42a01aa7286b9745017/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">业务逻辑漏洞--注册-登录-改密码页面总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>