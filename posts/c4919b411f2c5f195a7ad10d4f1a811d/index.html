<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言常见的字符串函数及模拟实现 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言常见的字符串函数及模拟实现" />
<meta property="og:description" content="1.模拟strlen()实现原理 我们知道定义字符数组时,可以有以下两种形式：
char a[]=&#34;abcd&#34;; char a[]={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;}; 两者的区别是第一种末尾会带一个&#39;\0&#39;，而第二种不会带，所以可以扫描字符数组每一个字符，如果扫描到&#39;\0&#39;,扫描结束
具体模拟strlen函数如下： int my_strlen(char* base) { int length = 0; while ((*base&#43;&#43;)!=&#39;\0&#39;) { length&#43;&#43;; } return length; } 当传的是 char a[]=&#34;abcd&#34; 这种形式时，会得出正确的结果
当传的是 char a[]={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;} 这种形式时，会返回一个不确定的值，原因是这种定义下没有&#39;\0&#39;
在对以上进行优化
有可以知道：
while(a) 表示当a!=0时执行循环，其等价于while(a!=0)。
//模拟strlen()函数 int my_strlen(char* base) { int length = 0; while (*base&#43;&#43;) { length&#43;&#43;; } return length; } char a[]={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;} 这种形式时,返回一个随机值 int my_strlen(char* base) { int length = 0; while (*base&#43;&#43;) { length&#43;&#43;; } return length; } int main() { char ch[] = {&#39;a&#39;,&#39;b&#39;,&#39;s&#39;,&#39;f&#39;,&#39;2&#39;}; //char ch[] = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c4919b411f2c5f195a7ad10d4f1a811d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-28T17:01:13+08:00" />
<meta property="article:modified_time" content="2022-01-28T17:01:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言常见的字符串函数及模拟实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1.模拟strlen()实现原理</h3> 
<p>我们知道定义字符数组时,可以有以下两种形式：</p> 
<pre><code class="language-cpp">char a[]="abcd";
char a[]={'a','b','c','d'};</code></pre> 
<p>两者的区别是第一种末尾会带一个<span style="color:#fe2c24;">'\0'</span><span style="color:#0d0016;">，而第二种不会带，所以可以扫描字符数组每一个字符，如果扫描到</span><span style="color:#fe2c24;">'\0'</span><span style="color:#0d0016;">,扫描结束</span></p> 
<ul><li> <h3>具体模拟strlen函数如下：</h3> </li></ul> 
<pre><code class="language-cpp">int my_strlen(char* base) {
	int length = 0;
	while ((*base++)!='\0') {
		
		length++;
	}
	return length;
}</code></pre> 
<p>当传的是 char a[]="abcd"  这种形式时，会得出正确的结果<br> 当传的是 char a[]={'a','b','c','d'} 这种形式时，会返回一个不确定的值，原因是这种定义下没有'\0'</p> 
<p>在对以上进行优化</p> 
<p>有可以知道：</p> 
<p> while(a) 表示当a!=0时执行循环，其等价于while(a!=0)。<br>  </p> 
<pre><code class="language-cpp">//模拟strlen()函数
int my_strlen(char* base) {
	int length = 0;
	while (*base++) {
		
		length++;
	}
	return length;
}</code></pre> 
<p></p> 
<ul><li>char a[]={'a','b','c','d'} 这种形式时,返回一个随机值</li></ul> 
<pre><code class="language-cpp">int my_strlen(char* base) {
	int length = 0;
	while (*base++) {
		
		length++;
	}
	return length;
}
int main() {
	char ch[] = {'a','b','s','f','2'};
	//char ch[] = "afaew";
	int length=my_strlen(ch);
	int length1 = strlen(ch);
	printf("%d\n%d", length,length1);
	
}</code></pre> 
<p></p> 
<p></p> 
<ul><li> char a[]="abcd"  这种形式时,返回字符串的长度</li></ul> 
<pre><code class="language-cpp">int my_strlen(char* base) {
	int length = 0;
	while (*base++) {
		
		length++;
	}
	return length;
}
int main() {
	//char ch[] = {'a','b','s','f','2'};
	char ch[] = "afaew";
	int length=my_strlen(ch);
	int length1 = strlen(ch);
	printf("%d\n%d", length,length1);
	
}</code></pre> 
<h2>2.模拟strstr()实现原理</h2> 
<p><strong>strstr()函数用来检索子串在字符串中首次出现的位置，其原型为：</strong></p> 
<p><strong>                    char *strstr( char *str, char * substr );</strong></p> 
<p><strong>返回值</strong>：返回字符串str中第一次出现子串的地址；如果没有检索到子串，则返回NULL</p> 
<pre><code class="language-cpp">char* my_strstr(const char * p1, const char * p2) {
	assert(p1);
	assert(p2);
	char * curr = p1;  //用来记录扫描的位置
	char * s2 ;   //用来扫描第二个字符串
	char* s1 ;  //用来扫描第一个字符串
	
	if (!(*p1)) {
		return p1;
	}
	while (*curr) {
		s1 = curr;
		s2 = p2;

		//从cur位置，p2位置开始
		while ((*s1) &amp;&amp; (*s2) &amp;&amp; (*s1) == (*s2)) {
			s1++;
			s2++;
		}
		//若s2指向为空，则找到返回第一次找到的元素地址
		if (!(*s2)) {
			return curr;
		}
		curr++;
	}
    //找不到返回NULL
    return NULL;

}</code></pre> 
<p>测试如下：</p> 
<pre><code class="language-cpp">    char* str1 = "hello alibaba !";
	char* str2 = "ali";
	char* resultadd=my_strstr(str1, str2);
	char* primi = strstr(str1, str2);
	printf("%s\n%s", resultadd,primi);</code></pre> 
<p>输出：</p> 
<p><img alt="" height="80" src="https://images2.imgbox.com/cd/1f/WomGXxnt_o.png" width="422"></p> 
<h2></h2> 
<h2>3.模拟strcmp()实现原理</h2> 
<p>  3.1. 函数原型</p> 
<p>           <strong> int strcmp(const char *s1,const char *s2);</strong><br>   3.2.函数功能：比较两个字符串大小</p> 
<ul><li>当两个字符串相同时，返回0</li><li>当两个字符串不同时，返回第一对字符不相等时的Ascii码差值</li></ul> 
<p>  3.3模拟实现如下</p> 
<pre><code class="language-cpp">int my_strcmp( char* str1, char * str2) {
	
	while ( *str1 == *str2) {
		if (!*str1) {
			return 0;
		}
		str1++;
		str2++;
	}
	return *str1 - *str2;
}

int main() {
	char* str1 = "abcde";
	char* str2 = "dbcde";
	int result=my_strcmp(str1, str2);
	printf("%d", result);
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="56" src="https://images2.imgbox.com/8e/64/lvFt6SxO_o.png" width="322"></p> 
<p></p> 
<h2>4.模拟strcpy()实现原理</h2> 
<p>  4.1. 函数原型</p> 
<p>          <span style="color:#fe2c24;"><strong> char *strcpy(char *dest, const char *src)</strong></span></p> 
<p>  4.2.函数功能：把 src 所指向的字符串复制到 dest。</p> 
<ul><li><strong>需要注意的是如果目标数组 dest 不够大，而源字符串的长度又太长，会出错</strong></li></ul> 
<p>  4.3模拟实现如下</p> 
<pre><code class="language-cpp">char* my_strcpy( char* dest, char* src) {
	assert(dest);
	assert(src);
	char* p1 = dest;
	char* p2 = src;
	int len = strlen(dest);
	while (len) {
		*(p1++) = *(p2++);
		len--;
	}
	return p1;
}
int main()
{
	char str1[] = "hello";
	char str2 []= "world";
	
	char* res=my_strcpy(str1, str2);
	printf("%s\n", str1);

}</code></pre> 
<h2>5.模拟strcat()实现原理</h2> 
<p>  5.1. 函数原型</p> 
<p>          <span style="color:#fe2c24;"><strong> char *strcat(char *dest, const char *src)</strong> </span></p> 
<p>  5.2.函数功能：把 <strong>src</strong> 所指向的字符串追加到 <strong>dest</strong> 所指向的字符串的结尾。</p> 
<ul><li><strong>需要注意的也是如果目标数组 dest 不够大，而源字符串的长度又太长，会出错</strong></li></ul> 
<p>  5.3模拟实现如下</p> 
<pre><code class="language-cpp">void my_strcat(char *copStr,char *folStr) {
	char* temp = copStr;
	while (*temp)
		temp++;
	while (*folStr) 
		*temp++ = *folStr++;
	return ;
}

int main() {
	char copyStr[10] =  "abcd" ;
	char* p = copyStr;
	char* folStr = "efgh";
	my_strcat(copyStr, folStr);
	while (*p) {
		printf("%c", *p++);
		
	}

}</code></pre> 
<p>输出:</p> 
<p><img alt="" height="55" src="https://images2.imgbox.com/16/7f/Ng9oIn2M_o.png" width="328"></p> 
<h2> 6.strtok()函数      </h2> 
<p>  6.1. 函数原型</p> 
<p>         <span style="color:#fe2c24;"> <strong> </strong>char * strtok (char * src, const char * sep);</span></p> 
<p>  6.2.函数功能：</p> 
<ul><li>  功能：作用于字符串src，以sep中的字符为分界符，将src切分成一个个子串；如果，src为空值 NULL，则函数保存的指针将在在下一次调用中将作为起始位置。</li><li> 返回值：分隔符匹配到的第一个子串</li></ul> 
<p>  6.3使用如下</p> 
<pre><code class="language-cpp">int main() {
	char arr[] = "localhost://8080:web/happy.jsp";
	char* p = "/:.";
	char* result;
	for (result = strtok(arr, p); result != NULL; result = strtok(NULL, p) ){
		printf("%s\n",result);
	}
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/c2/de/4O4ZTBno_o.png" width="400"></p> 
<h2>7.strerror()函数 </h2> 
<p>  7.1.函数原型<strong>：</strong></p> 
<p><strong>           <span style="color:#fe2c24;">       </span></strong><span style="color:#fe2c24;">char * strerror(int enum);</span><br>   7.2.函数功能：</p> 
<ul><li>strerror()用来依参数errnum 的错误代码来查询其错误原因的描述字符串, 然后将该字符串指针返回</li></ul> 
<p>  7.3.返回值<strong>：</strong></p> 
<ul><li>返回描述错误原因的字符串指针</li></ul> 
<pre><code class="language-cpp">int main() {
	FILE* file = fopen("test.txt", "r");
	if (!file) {
		printf("%s\n", strerror(errno));
	}
	else {
		printf("success!");
	}
	/*char ch = 'w';
	int res = islower(ch);
	printf("%d", res);*/
}
</code></pre> 
<p>当返回指针为空时输出错误码对应的信息：</p> 
<p><img alt="" height="63" src="https://images2.imgbox.com/b2/6e/BKQYb2mV_o.png" width="508"></p> 
<p></p> 
<h4>水平有限，如有不正，请指点。</h4> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/47d6e279f3f3fdf170e72768f14c0402/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java socket 解析自定义包头</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/84c7106946f4434a6d5f4ae1cbc8875f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cesium 实现雷达波</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>