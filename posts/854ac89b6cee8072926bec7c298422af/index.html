<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Spring】八种常见Bean加载方式 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Spring】八种常见Bean加载方式" />
<meta property="og:description" content="🚩本文已收录至专栏：Spring家族学习之旅
一.引入 (1) 概述 ​ 关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是由spring维护对象的生命周期，所以bean的加载可以从大的方面划分成2种形式：
已知类通过（类名.class）交给spring管理已知类名通过（类名字符串）并交给spring管理。 两种形式内部其实都一样，都是通过spring的BeanDefinition对象初始化spring的bean。
bean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是spring管控的bean@Import注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有@Bean相关的定义，会被一同加载spring开放出了若干种可编程控制的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean 本文介绍八种常见的bean加载方式：
xmlxml&#43;注解注解@Import导入使用register方法编程形式注册@Import导入实现ImportSelector接口的类@Import导入实现ImportBeanDefinitionRegistrar接口的类@Import导入实现BeanDefinitionRegistryPostProcessor接口的类 此外还介绍一些相关涉及知识
@Bean定义FactoryBean接口@ImportResource@Configuration注解的proxyBeanMethods属性 (2) 环境搭建 在开始讲解之前，我们需要先介绍一下测试所用的环境。
创建Maven工程，可以选择导入如下Spring坐标用于测试 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 演示加载第三方bean--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; 创建一些用于后续示例演示的bean
二.八种加载方式 (1) XML方式 ​ 最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是提供类名，然后spring就可以管理了。所以第一种方式就是给出bean的类名，至于内部就是通过反射机制加载成class。
创建Spring的xml配置文件，通过其中的 &lt;bean/&gt;标签加载bean，我们可以在其中声明加载自己创建的bean,也可以加载第三方开发的bean。 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;&gt; &lt;!--xml方式声明 自己 开发的bean--&gt; &lt;bean class=&#34;com.guanzhi.bean.Cat&#34;/&gt; &lt;bean class=&#34;com.guanzhi.bean.Dog&#34;/&gt; &lt;!--xml方式声明 第三方 开发的bean--&gt; &lt;bean class=&#34;com.alibaba.druid.pool.DruidDataSource&#34;/&gt; &lt;/beans&gt; 我们可以测试一下是否成功加载了这些bean public class App { public static void main(String[] args) { // 加载配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/854ac89b6cee8072926bec7c298422af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-30T13:28:19+08:00" />
<meta property="article:modified_time" content="2023-03-30T13:28:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Spring】八种常见Bean加载方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>🚩本文已收录至专栏：<a href="https://blog.csdn.net/m0_66570338/category_12227955.html">Spring家族学习之旅</a></p> 
</blockquote> 
<h2><a id="_2"></a>一.引入</h2> 
<h3><a id="1__4"></a>(1) 概述</h3> 
<p>​ 关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是<strong>由spring维护对象的生命周期</strong>，所以bean的加载可以从大的方面划<strong>分成2种形式</strong>：</p> 
<ul><li><strong>已知类</strong>通过（<code>类名.class</code>）交给spring管理</li><li><strong>已知类名</strong>通过（<code>类名字符串</code>）并交给spring管理。</li></ul> 
<p>两种形式内部其实都一样，都是通过spring的<code>BeanDefinition</code>对象初始化spring的bean。</p> 
<ol><li>bean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是spring管控的bean</li><li>@Import注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有@Bean相关的定义，会被一同加载</li><li>spring开放出了若干种可编程控制的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean</li></ol> 
<p>本文介绍八种常见的bean加载方式：</p> 
<ol><li>xml</li><li>xml+注解</li><li>注解</li><li>@Import导入</li><li>使用register方法编程形式注册</li><li>@Import导入实现ImportSelector接口的类</li><li>@Import导入实现ImportBeanDefinitionRegistrar接口的类</li><li>@Import导入实现BeanDefinitionRegistryPostProcessor接口的类</li></ol> 
<p>此外还介绍一些相关涉及知识</p> 
<ol><li>@Bean定义FactoryBean接口</li><li>@ImportResource</li><li>@Configuration注解的proxyBeanMethods属性</li></ol> 
<h3><a id="2__34"></a>(2) 环境搭建</h3> 
<p>在开始讲解之前，我们需要先介绍一下测试所用的环境。</p> 
<ol><li>创建Maven工程，可以选择导入如下Spring坐标用于测试</li></ol> 
<pre><code class="prism language-xml">		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.3.9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!--     演示加载第三方bean--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.1.16<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<ol start="2"><li>创建一些用于后续示例演示的bean<br> <img src="https://images2.imgbox.com/90/3b/YaS72zWi_o.png" alt="在这里插入图片描述"></li></ol> 
<h2><a id="_58"></a>二.八种加载方式</h2> 
<h3><a id="1_XML_60"></a>(1) XML方式</h3> 
<p>​ 最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是<strong>提供类名</strong>，然后spring就可以管理了。所以第一种方式就是给出bean的类名，至于内部就是通过反射机制加载成class。</p> 
<ol><li>创建Spring的xml配置文件，通过其中的 <code>&lt;bean/&gt;</code>标签加载bean，我们可以在其中声明<strong>加载自己创建的bean,也可以加载第三方开发的bean</strong>。</li></ol> 
<pre><code class="prism language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
    
    &lt;!--xml方式声明 自己 开发的bean--&gt;
    &lt;bean class="com.guanzhi.bean.Cat"/&gt;
    &lt;bean class="com.guanzhi.bean.Dog"/&gt;

    &lt;!--xml方式声明 第三方 开发的bean--&gt;
    &lt;bean class="com.alibaba.druid.pool.DruidDataSource"/&gt;
    
&lt;/beans&gt;
</code></pre> 
<ol start="2"><li>我们可以测试一下是否成功加载了这些bean</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 加载配置文件</span>
        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取所有已加载bean的名称</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印查看</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>启动我们可以发现成功加载到了上述配置的三个bean<br> <img src="https://images2.imgbox.com/83/8f/khJvcGMJ_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="2_XML_102"></a>(2) XML+注解方式</h3> 
<p>​ 由于方式一种需要将spring管控的bean全部写在xml文件中，对于程序员来说非常不友好，所以就有了第二种方式。<strong>哪一个类要受到spring管控加载成bean，就在这个类的上面加一个注解</strong>，还可以顺带起一个bean的名字（id）。这里<strong>可以使用的注解有@Component以及三个衍生注解@Service、@Controller、@Repository</strong>。</p> 
<ol><li>例如我们可以在上述Cat类和Mouse类中加上注解</li></ol> 
<pre><code class="prism language-JAVA">package com.guanzhi.bean;

@Component("tom")
public class Cat {
}
</code></pre> 
<pre><code class="prism language-JAVA">package com.guanzhi.bean;

@Service
public class Mouse {
}
</code></pre> 
<p>​ 当然，由于我们无法在第三方提供的技术源代码中去添加上述4个注解，因此当你<strong>需要加载第三方开发的bean</strong>的时候可以使用下列方式定义注解式的bean。<strong>将<code>@Bean</code>定义在一个方法上方，当前方法的返回值就可以交给spring管控</strong>，注意，<strong>这个方法所在的类一定要定义在@Configuration修饰的类</strong>中。</p> 
<pre><code class="prism language-JAVA">package com.guanzhi.config;

@Configuration
public class DbConfig {
    @Bean
    public DruidDataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        return ds;
    }
}
</code></pre> 
<p>​ 2. 仅仅如此还是不够，上面提供的<strong>只是bean的声明，spring并没有感知到这些东西</strong>。想让spring感知到这些声明，必须设置spring去检查这些类。我们可以通过下列<strong>xml配置设置spring去检查哪些包</strong>，发现定了对应注解，就将对应的类纳入spring管控范围，声明成bean。</p> 
<pre><code class="prism language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
    "&gt;
    &lt;!--指定扫描加载bean的位置--&gt;
    &lt;context:component-scan base-package="com.guanzhi.bean,com.guanzhi.config"/&gt;
&lt;/beans&gt;
</code></pre> 
<p><img src="https://images2.imgbox.com/f6/06/1djocXwR_o.png" alt="在这里插入图片描述"></p> 
<ol start="3"><li>同样我们可以测试一下是否成功加载了这些bean</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 加载配置文件</span>
        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取所有已加载bean的名称</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印查看</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>启动我们可以发现成功加载到了上述配置的三个bean<br> <img src="https://images2.imgbox.com/e4/7e/Xq2zSfCC_o.png" alt="在这里插入图片描述"></li></ol> 
<p>方式二声明bean的方式是目前企业中较为常见的bean的声明方式，但是也有缺点。方式一中，通过一个配置文件，你可以查阅当前spring环境中定义了多少个或者说多少种bean，但是方式二<strong>没有任何一个地方可以查阅整体信息，只有当程序运行起来才能感知到加载了多少个bean</strong>。</p> 
<h3><a id="3__182"></a>(3) 注解方式声明配置类</h3> 
<p>​ 方式二已经完美的简化了bean的声明，以后再也不用写茫茫多的配置信息了。仔细观察xml配置文件，会发现这个文件中<strong>只剩了扫描包</strong>这句话，于是就有人提出，<strong>使用java类替换掉这种固定格式</strong>的配置，所以下面这种格式就出现了。</p> 
<ol><li>定义一个类并使用<code>@ComponentScan</code>替代原始xml配置中的包扫描这个动作，其实功能基本相同。</li></ol> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token string">"com.guanzhi.bean"</span><span class="token punctuation">,</span><span class="token string">"com.guanzhi.config"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>同样我们可以测试一下是否成功加载了这些bean</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 加载配置文件</span>
        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取所有已加载bean的名称</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印查看</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>启动我们可以发现成功加载了这些bean<br> <img src="https://images2.imgbox.com/e0/ec/M7WcoEau_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="4_Import_214"></a>(4) @Import注解注入</h3> 
<p>​ 使用扫描的方式加载bean是企业级开发中常见的bean的加载方式，但是由于扫描的时候不仅可以加载到你要的东西，还有可能加载到各种各样的乱七八糟的东西。</p> 
<p>​ 有人就会奇怪，会有什么问题呢？比如你扫描了com.guanzhi.service包，后来因为业务需要，又扫描了com.guanzhi.dao包，你发现com.guanzhi包下面只有service和dao这两个包，这就简单了，直接扫描com.guanzhi就行了。但是万万没想到，十天后你加入了一个外部依赖包，里面也有com.guanzhi包，这下便加载了许多不需要的东西。</p> 
<p>​ 所以我们需要一种<strong>精准制导的加载方式</strong>，使用<code>@Import</code>注解就可以解决你的问题。它可以加载所有的一切，<strong>只需要在注解的参数中写上加载的类对应的.class</strong>即可。有人就会觉得，还要自己手写，多麻烦，不如扫描好用。 但是他可以指定加载啊，好的命名规范配合@ComponentScan可以解决很多问题，但是@Import注解拥有其重要的应用场景。有没有想过假如你要加载的bean没有使用@Component修饰呢？这下就无解了，而@Import就无需考虑这个问题。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token class-name">Dog</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>被导入的bean无需使用注解声明为bean</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此形式可以有效的降低源代码与Spring技术的耦合度，在spring技术底层及诸多框架的整合中大量使用</p> 
<p>除了加载bean，还可以使用@Import注解<strong>加载配置类</strong>。其实本质上是一样的。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">Dbconfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="5_bean_245"></a>(5) 编程形式注册bean</h3> 
<p>​ 前面介绍的加载bean的方式都是在<strong>容器启动阶段完成</strong>bean的加载，下面这种方式就比较特殊了，可以在<strong>容器初始化完成后手动加载bean</strong>。通过这种方式可以实现<strong>编程式控制bean的加载</strong>。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">AnnotationConfigApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//上下文容器对象已经初始化完毕后，手工加载bean</span>
        ctx<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">Mouse</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ctx<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ctx<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>​ 其实这种方式坑还是挺多的，比如容器中已经有了某种类型的bean，再加载会不会覆盖呢？这都是要思考和关注的问题。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">AnnotationConfigApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//上下文容器对象已经初始化完毕后，手工加载bean</span>
        ctx<span class="token punctuation">.</span><span class="token function">registerBean</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token class-name">Cat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ctx<span class="token punctuation">.</span><span class="token function">registerBean</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token class-name">Cat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ctx<span class="token punctuation">.</span><span class="token function">registerBean</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token class-name">Cat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行可以发现，后加载的覆盖了之前加载的<br> <img src="https://images2.imgbox.com/cf/55/a1sPHtL4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6_ImportSelector_280"></a>(6) 导入实现ImportSelector接口的类</h3> 
<p>​ 在方式五中，我们感受了bean的加载可以进行编程化的控制，添加if语句就可以实现bean的加载控制了。但是毕竟是在容器初始化后实现bean的加载控制，那是否可以在<strong>容器初始化过程中进行控制</strong>呢？答案是必须的。<strong>实现ImportSelector接口的类可以设置加载的bean的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyImportSelector</span> <span class="token keyword">implements</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">{<!-- --></span> 
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> metadata<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 各种条件的判定，判定完毕后，决定是否装载指定的bean</span>
        <span class="token comment">// 判断是否满足xx条件，满足则加载xx，否则xx</span>
        <span class="token keyword">boolean</span> flag <span class="token operator">=</span> metadata<span class="token punctuation">.</span><span class="token function">hasAnnotation</span><span class="token punctuation">(</span><span class="token string">"org.springframework.context.annotation.Configuration"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token string">"com.guanzhi.bean.Dog"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token string">"com.guanzhi.bean.Cat"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>在配置类中导入</p> 
<pre><code class="prism language-java"><span class="token comment">//@Configuration</span>
<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">MyImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编写测试类</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行可以发现，根据MyImportSelector中的判断条件，如果在SpringConfig加上Configuration注解得打印com.guanzhi.bean.Cat，否则打印com.guanzhi.bean.Dog。如此我们便实现了Bean的动态加载。</p> 
<h3><a id="7_ImportBeanDefinitionRegistrar_326"></a>(7) 导入实现ImportBeanDefinitionRegistrar接口的类</h3> 
<p>​ 方式六中提供了给定类全路径类名控制bean加载的形式，如果对spring的bean的加载原理比较熟悉的小伙伴知道，其实bean的加载不是一个简简单单的对象，<strong>spring中定义了一个叫做BeanDefinition的东西，它才是控制bean初始化加载的核心</strong>。BeanDefinition接口中给出了若干种方法，可以控制bean的相关属性。说个最简单的，创建的对象是单例还是非单例，在BeanDefinition中定义了scope属性就可以控制这个。</p> 
<p>如果你感觉方式六没有给你开放出足够的对bean的控制操作，那么方式七你值得拥有。我们可以通过定义一个类，然后实现<code>ImportBeanDefinitionRegistrar</code>接口的方式定义bean，并且还可以让你<strong>对bean的初始化进行更加细粒度的控制</strong>.</p> 
<p><img src="https://images2.imgbox.com/c7/7f/BcP2svyR_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRegistrar</span> <span class="token keyword">implements</span> <span class="token class-name">ImportBeanDefinitionRegistrar</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> metadata<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">BeanDefinition</span> beanDefinition <span class="token operator">=</span> 	
            <span class="token class-name">BeanDefinitionBuilder</span><span class="token punctuation">.</span><span class="token function">rootBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">,</span>beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在配置类中导入</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">MyRegistrar</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>测试</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="8_BeanDefinitionRegistryPostProcessor_369"></a>(8) 导入实现BeanDefinitionRegistryPostProcessor接口的类</h3> 
<p>​ 上述七种方式都是在容器初始化过程中进行bean的加载或者声明，但是这里有一个bug。这么多种方式，它们之间如果有冲突怎么办？谁能有最终裁定权？这是个好问题，当某种类型的bean被接二连三的使用各种方式加载后，在你对所有加载方式的加载顺序没有完全理解清晰之前，你还真不知道最后谁说了算。</p> 
<p>​ BeanDefinitionRegistryPostProcessor，看名字知道，BeanDefinition意思是bean定义，Registry注册的意思，Post后置，Processor处理器，全称bean定义后处理器,在所有bean注册都加载完后，它是最后一个运行的,实现对容器中bean的最终裁定.</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanDefinitionRegistry</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">BeanDefinition</span> beanDefinition <span class="token operator">=</span> 
            <span class="token class-name">BeanDefinitionBuilder</span><span class="token punctuation">.</span><span class="token function">rootBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"Dog"</span><span class="token punctuation">,</span>beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>使用与上述一致</p> 
<h2><a id="_389"></a>三.相关补充</h2> 
<h3><a id="1_FactroyBean_391"></a>(1) FactroyBean接口</h3> 
<p>​ spring提供了一个接口<code>FactoryBean</code>，也可以用于声明bean，只不过<strong>实现了FactoryBean接口的类造出来的对象不是当前类的对象，而是FactoryBean接口泛型指定类型的对象</strong>。如下列，造出来的bean并不是DogFactoryBean，而是Dog。这有什么用呢？它可以帮助我们在对象初始化前做一些事情。</p> 
<pre><code class="prism language-JAVA">// 创建一个类实现FactoryBean接口
public class DogFactoryBean implements FactoryBean&lt;Dog&gt; {
    @Override
    public Dog getObject() throws Exception {
        Dog dog = new Dog();
        // 扩展要做的其他事情.....
        return dog;
    }
    @Override
    public Class&lt;?&gt; getObjectType() {
        return Dog.class;
    }
    // 是否为单例
    @Override
    public boolean isSingleton() {
        return true;
    }
}
</code></pre> 
<p>​ 有人说，注释中的代码写入Dog的构造方法不就行了吗？干嘛这么费劲转一圈，还写个类，还要实现接口，多麻烦啊。还真不一样，你可以理解为Dog是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。<strong>只不过根据情况不同，初始化动作不同而已</strong>。如果写入Dog，或许初始化动作A当前并不能满足你的需要，这个时候你就要做一个DogB的方案了。如此，你就要做两个Dog类。而使用FactoryBean接口就可以完美解决这个问题。</p> 
<p>​ <strong>通常实现了FactoryBean接口的类使用@Bean的形式进行加载</strong>，当然也可以使用@Component去声明DogFactoryBean，只要被扫描加载到即可。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token string">"com.guanzhi.bean"</span><span class="token punctuation">,</span><span class="token string">"com.guanzhi.config"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">DogFactoryBean</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DogFactoryBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2_XMLbean_430"></a>(2) 注解导入XML配置的bean</h3> 
<p>​ 由于早起开发的系统大部分都是采用xml的形式配置bean，现在的企业级开发基本上不用这种模式了。但是如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。<strong>新开发的用注解格式，之前开发的是xml格式</strong>。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。spring提供了一个注解可以解决这个问题，<code>@ImportResource</code>，在<strong>配置类上直接写上要被融合的xml配置文件名</strong>即可，算的上一种兼容性解决方案。</p> 
<pre><code class="prism language-JAVA">@Configuration
@ComponentScan("com.guanzhi")
@ImportResource("applicationContext.xml")
public class SpringConfig {
}
</code></pre> 
<h3><a id="3_proxyBeanMethods_442"></a>(3) proxyBeanMethods属性</h3> 
<p>​ 前面的例子中用到了@Configuration这个注解，它<strong>可以保障配置类中使用方法创建的bean的唯一性</strong>，使我们得到的对象是从容器中获取的而不是重新创建的。只需为@Configuration注解设置<strong>proxyBeanMethods属性值为true</strong>即可，由于此属性<strong>默认值为true</strong>，所以很少看见明确书写的，除非想放弃此功能。</p> 
<pre><code class="prism language-JAVA">@Configuration(proxyBeanMethods = true)
public class SpringConfig {
    @Bean
    public Cat cat(){
        return new Cat();
    }
}
</code></pre> 
<p>​ 下面通过容器再调用上面的cat方法时，得到的就是同一个对象了。注意，<strong>必须使用spring容器对象调用此方法才有保持bean唯一性的特性</strong>。此特性在很多底层源码中有应用，在MQ中也应用了此特性。</p> 
<pre><code class="prism language-JAVA">public class App {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);

        SpringConfig springConfig = ctx.getBean("springConfig", SpringConfig.class);
        System.out.println(springConfig.cat());
        System.out.println(springConfig.cat());
        System.out.println(springConfig.cat());
    }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/a5/07/ZqVHWVKY_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af844ae8560c841833953eaa2d7cc690/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle用户密码过期，修改永不过期</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/37b89d1e5af00486da27c49b8141d227/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">chatdoc读文献</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>