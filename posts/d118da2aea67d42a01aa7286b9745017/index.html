<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>业务逻辑漏洞--注册-登录-改密码页面总结 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="业务逻辑漏洞--注册-登录-改密码页面总结" />
<meta property="og:description" content="SRC漏洞挖掘过程中遇到登录框时，总是感觉自己测试不完全，东一榔头西一棒子，想起什么来测什么。
感觉这样不太行，显得不专业，于是乎总结一下，在以后的测试过程中可以作为笔记提示。
以下按照顺序测试：
注册页面
注册页面批量注册
注册覆盖（重复注册他人账号）
短信邮件炸弹
手机验证码是否可爆破（老生常谈，Burpsuite抓包爆破四位验证码）
图片验证码是否可绕过（验证码缺失、验证码失效数据包重放、万能验证码0000、验证码空绕过、验证码前端获取(极少数情况)）
登录页面
弱密码、无验证码爆破、万能密码（后台登录，用户登录次数限制）
手机验证码登录是否可以进行短信炸弹
url跳转漏洞（主要用来钓鱼，对于绕过和利用百度搜索已有大量文章，不赘述）
登录处是否可绕过（对于大多数没有cookie的网站）
用户名枚举（观察返回包提示或者返回包参数变化）
忘记密码
手机验证码是否可爆破
修改密码流程是否可跳过
任意用户密码重置
短信邮件炸弹
注册页面批量注册
这种网站注册页面，没有手机短信验证码，那么，我们可以考虑，是否可以批量注册呢？
对于批量注册的前提是：该页面处没有图形验证码或者图形验证码失效！该页面注册处没有图形验证码。
注册页面虽然需要输入姓名和身份证号，但是并未对姓名和身份证号去做核对，输入任意的姓名和身份证号即可。
测试过程：注册提交时Burpsuite抓包
先用正确的信息注册，记住注册成功时服务器返回的数据，知道注册成功是返回什么
然后使用刚才的数据包遍历修改手机号，账号等参数发送，观察回复的数据包状态
注册覆盖（重复注册他人账号）
对于注册页面覆盖注册是指原来用一个手机号已经注册了账号，但是由于漏洞，导致可以再利用该手机号进行注册，并且会将之前注册的记录覆盖！
当我们用已经注册了的账号准备再注册时，发现会提示该手机号码已经存在！
我们抓包，发现后端检测该手机号已经注册了的话，会返回 true。如果检测该手机号没注册的话，会返回false。
修改回传参数，达到重复注册目的。
短信邮件炸弹
其实这就是个限流的问题——也就是限制某个接口的时间窗口内的请求数。
很多项目都少不了给用户手机号或者邮箱账号发短信邮件之类的，但是很多发送短信都是借助于第三方接口来发送短信的，这样一来，发送的短信就是有限制的，收费的哦。如果系统做的不太好，有些小漏洞，被白帽子发现还好，要是被那些黑帽子发现了，少则几千，严重者可能导致公司倒闭啊。即使不被黑帽子攻击，有些恶意的用户也可能系统进行破坏。
此处推荐一篇文章
也可使用Burpsuite抓包爆破，西门吹雪大佬有过一个抓包给手机号后依次添加空格的实例
防范措施：
限制每个手机号的每日发送次数，超过次数则拒发送，提示超过当日次数。每个ip限制最大限制次数。超过次数则拒发送，提示超过ip当日发送最大次数。限制每个手机号发送的时间间隔，比如两分钟，没超过2分钟，不允许发送，提示操作频繁。发送短信增加图片验证码，服务端和输入验证码对比，不一致则拒绝发送。 登录处是否可绕过
不可靠的前端校验
还是会有许多的网站他们没有严格进行身份校验，他们往往是通过依靠帐号密码登陆后发送后回传的JSON数据来判断用户身份是否正确，这就暴露出了很大的漏洞，这种漏洞利用起来就相当的容易，往往只需要一个安全界的神器 BURP 就可以完成身份验证的绕过，在登录的时候输入正确的账户以及随意的密码，将报文拦截下来，然后选择 burp 里面的拦截返回包的功能，捕捉返回的状态码。
任意用户密码重置
几乎所有需要登录的网站都有一个忘记密码然后重置密码的功能，如果网站在密码重置功能处的代码不够严谨，将可能造成任意密码重置的逻辑漏洞。
1、 验证码失效，导致攻击者可以通过爆破其他用户手机验证码来实现任意用户密码重置
·2、验证码未绑定用户：也就是我们可以利用自己的手机号来进行成功验证手机验证码，然而在提交修改密码处提交其他人的手机号，来实现修改其他人的密码
·3、修改接收验证码的手机或邮箱：当我们修改密码时，输入正确的用户名，点击发送验证码，抓包，发现数据包中有该用户名对应的手机或者邮箱，我们将其修改为自己的手机或邮箱来接收验证码。输入我们收到的验证码，即可实现对该用户的密码进行重置。(这里还存在一个信息泄露，即知道用户名就能知道该用户对于的手机或邮箱)
·4、跳过验证步骤：网站对修改密码的步骤，没有做校验，导致可以直接输入最终修改密码的链接，直接跳转到该页面，然后输入新密码达到重置密码的目的。首先使用我们自己的账号走一次流程，获取每个步骤的页面链接，然后记录页面3对应的输入新密码的链接，重置他人用户时，获取验证码后，直接输入密码修改页面链接到新密码的界面，输入密码重置成功。
5、 cookie值的替换：重置密码走到最后一步的时候仅判断唯一的用户标识cookie，并没有判断该cookie有没有通过之前重置密码过程的验证，导致可替换cookie重置他人用户密码。重置自己用户密码到达最后阶段，抓到数据包，并在第一阶段重新获取其他用户cookie，替换cookie到我们抓取的数据包中，发包测试。
个性签名：你有一个苹果，我有一个苹果，我们交换一下，一人还是只有一个苹果；你有一种思想，我有一种思想，我们交换一下，一个人就有两种思想。
如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，博主在此感谢！
独学而无友，则孤陋而寡闻，开源、分享、白嫖！
参考至：https://www.cnblogs.com/qiuzhiyu/p/12530698.html" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/d118da2aea67d42a01aa7286b9745017/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-24T22:35:08+08:00" />
<meta property="article:modified_time" content="2022-03-24T22:35:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">业务逻辑漏洞--注册-登录-改密码页面总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>SRC漏洞挖掘过程中遇到登录框时，总是感觉自己测试不完全，东一榔头西一棒子，想起什么来测什么。</p> 
<p>感觉这样不太行，显得不专业，于是乎总结一下，在以后的测试过程中可以作为笔记提示。</p> 
<p>以下按照顺序测试：</p> 
<p>注册页面</p> 
<p>注册页面批量注册<br> 注册覆盖（重复注册他人账号）<br> 短信邮件炸弹<br> 手机验证码是否可爆破（老生常谈，Burpsuite抓包爆破四位验证码）<br> 图片验证码是否可绕过（验证码缺失、验证码失效数据包重放、万能验证码0000、验证码空绕过、验证码前端获取(极少数情况)）<br> 登录页面</p> 
<p>弱密码、无验证码爆破、万能密码（后台登录，用户登录次数限制）<br> 手机验证码登录是否可以进行短信炸弹<br> url跳转漏洞（主要用来钓鱼，对于绕过和利用百度搜索已有大量文章，不赘述）<br> 登录处是否可绕过（对于大多数没有cookie的网站）<br> 用户名枚举（观察返回包提示或者返回包参数变化）<br> 忘记密码</p> 
<p>手机验证码是否可爆破<br> 修改密码流程是否可跳过<br> 任意用户密码重置<br> 短信邮件炸弹</p> 
<p>注册页面批量注册</p> 
<p>这种网站注册页面，没有手机短信验证码，那么，我们可以考虑，是否可以批量注册呢？</p> 
<p>对于批量注册的前提是：该页面处没有图形验证码或者图形验证码失效！该页面注册处没有图形验证码。</p> 
<p>注册页面虽然需要输入姓名和身份证号，但是并未对姓名和身份证号去做核对，输入任意的姓名和身份证号即可。</p> 
<p>测试过程：注册提交时Burpsuite抓包</p> 
<p>先用正确的信息注册，记住注册成功时服务器返回的数据，知道注册成功是返回什么</p> 
<p>然后使用刚才的数据包遍历修改手机号，账号等参数发送，观察回复的数据包状态</p> 
<p>注册覆盖（重复注册他人账号）</p> 
<p>对于注册页面覆盖注册是指原来用一个手机号已经注册了账号，但是由于漏洞，导致可以再利用该手机号进行注册，并且会将之前注册的记录覆盖！</p> 
<p>当我们用已经注册了的账号准备再注册时，发现会提示该手机号码已经存在！</p> 
<p>我们抓包，发现后端检测该手机号已经注册了的话，会返回 true。如果检测该手机号没注册的话，会返回false。</p> 
<p>修改回传参数，达到重复注册目的。</p> 
<p>短信邮件炸弹</p> 
<p>其实这就是个限流的问题——也就是限制某个接口的时间窗口内的请求数。</p> 
<p>很多项目都少不了给用户手机号或者邮箱账号发短信邮件之类的，但是很多发送短信都是借助于第三方接口来发送短信的，这样一来，发送的短信就是有限制的，收费的哦。如果系统做的不太好，有些小漏洞，被白帽子发现还好，要是被那些黑帽子发现了，少则几千，严重者可能导致公司倒闭啊。即使不被黑帽子攻击，有些恶意的用户也可能系统进行破坏。</p> 
<p>此处推荐一篇文章</p> 
<p>也可使用Burpsuite抓包爆破，西门吹雪大佬有过一个抓包给手机号后依次添加空格的实例</p> 
<p>防范措施：</p> 
<ol><li>限制每个手机号的每日发送次数，超过次数则拒发送，提示超过当日次数。</li><li>每个ip限制最大限制次数。超过次数则拒发送，提示超过ip当日发送最大次数。</li><li>限制每个手机号发送的时间间隔，比如两分钟，没超过2分钟，不允许发送，提示操作频繁。</li><li>发送短信增加图片验证码，服务端和输入验证码对比，不一致则拒绝发送。</li></ol> 
<p>登录处是否可绕过</p> 
<p>不可靠的前端校验</p> 
<p>还是会有许多的网站他们没有严格进行身份校验，他们往往是通过依靠帐号密码登陆后发送后回传的JSON数据来判断用户身份是否正确，这就暴露出了很大的漏洞，这种漏洞利用起来就相当的容易，往往只需要一个安全界的神器 BURP 就可以完成身份验证的绕过，在登录的时候输入正确的账户以及随意的密码，将报文拦截下来，然后选择 burp 里面的拦截返回包的功能，捕捉返回的状态码。</p> 
<p>任意用户密码重置</p> 
<p>几乎所有需要登录的网站都有一个忘记密码然后重置密码的功能，如果网站在密码重置功能处的代码不够严谨，将可能造成任意密码重置的逻辑漏洞。</p> 
<p>1、 验证码失效，导致攻击者可以通过爆破其他用户手机验证码来实现任意用户密码重置</p> 
<p>·2、验证码未绑定用户：也就是我们可以利用自己的手机号来进行成功验证手机验证码，然而在提交修改密码处提交其他人的手机号，来实现修改其他人的密码</p> 
<p>·3、修改接收验证码的手机或邮箱：当我们修改密码时，输入正确的用户名，点击发送验证码，抓包，发现数据包中有该用户名对应的手机或者邮箱，我们将其修改为自己的手机或邮箱来接收验证码。输入我们收到的验证码，即可实现对该用户的密码进行重置。(这里还存在一个信息泄露，即知道用户名就能知道该用户对于的手机或邮箱)</p> 
<p>·4、跳过验证步骤：网站对修改密码的步骤，没有做校验，导致可以直接输入最终修改密码的链接，直接跳转到该页面，然后输入新密码达到重置密码的目的。首先使用我们自己的账号走一次流程，获取每个步骤的页面链接，然后记录页面3对应的输入新密码的链接，重置他人用户时，获取验证码后，直接输入密码修改页面链接到新密码的界面，输入密码重置成功。</p> 
<p>5、 cookie值的替换：重置密码走到最后一步的时候仅判断唯一的用户标识cookie，并没有判断该cookie有没有通过之前重置密码过程的验证，导致可替换cookie重置他人用户密码。重置自己用户密码到达最后阶段，抓到数据包，并在第一阶段重新获取其他用户cookie，替换cookie到我们抓取的数据包中，发包测试。</p> 
<p>个性签名：你有一个苹果，我有一个苹果，我们交换一下，一人还是只有一个苹果；你有一种思想，我有一种思想，我们交换一下，一个人就有两种思想。</p> 
<p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，博主在此感谢！</p> 
<p>独学而无友，则孤陋而寡闻，开源、分享、白嫖！</p> 
<p>参考至：https://www.cnblogs.com/qiuzhiyu/p/12530698.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/217e7ecbd4ccb74e20747afdd3a1352f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis-Lua脚本详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f962703dddecf5c09d46cb29edd9fc5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">点击按钮改变颜色 模型动画暂停继续功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>