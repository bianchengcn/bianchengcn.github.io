<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常见排序算法总结 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常见排序算法总结" />
<meta property="og:description" content="目录
1.直接插入排序
2.希尔排序
3. 简单选择排序
4. 堆排序
5.冒泡排序
6. 快速排序
7. 2路归并
8.基数排序
9.数据测试
10.算法的稳定性
11.表格
1.直接插入排序 从前往后，每次在前面已经排好序的数组里找到自己的位置并插入；
public void sort(int[] arr) { for(int i=0;i&lt;arr.length;i&#43;&#43;){ for(int j=i-1;j&gt;=0;j--){ if(arr[j]&gt;arr[j&#43;1]) { swap(arr,j,j&#43;1); }else{ break; } } } } 2.希尔排序 从len/2的间隔开始每次折半，每一次的排序，按照间隔将间隔特定距离的数按照直接插入排好；
public void sort(int[] arr,int k) { if(k==0) return; for(int j=k;j&lt;arr.length;j&#43;=k){ for(int q=j-k;q&gt;=0;q-=k){ if(arr[q]&gt;arr[q&#43;k]){ swap(arr,q,q&#43;k); } } } sort(arr,k/2); } 3. 简单选择排序 每次选择未排序中的最小值，插入到已经排序的数列的末尾
public void sort(int[] arr) { for (int i = 0; i &lt; arr." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8adf517bdfce913a0ed7ff3c1d9950ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-01T00:02:53+08:00" />
<meta property="article:modified_time" content="2023-09-01T00:02:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常见排序算法总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#1.%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">1.直接插入排序</a></p> 
<p id="2.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#2.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" rel="nofollow">2.希尔排序</a></p> 
<p id="3.%20%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#3.%20%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">3. 简单选择排序</a></p> 
<p id="4.%20%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#4.%20%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">4. 堆排序</a></p> 
<p id="5.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#5.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" rel="nofollow">5.冒泡排序</a></p> 
<p id="6.%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#6.%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" rel="nofollow">6. 快速排序</a></p> 
<p id="7.%202%E8%B7%AF%E5%BD%92%E5%B9%B6-toc" style="margin-left:40px;"><a href="#7.%202%E8%B7%AF%E5%BD%92%E5%B9%B6" rel="nofollow">7. 2路归并</a></p> 
<p id="8.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#8.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" rel="nofollow">8.基数排序</a></p> 
<p id="9.%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#9.%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95" rel="nofollow">9.数据测试</a></p> 
<p id="10.%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7-toc" style="margin-left:40px;"><a href="#10.%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7" rel="nofollow">10.算法的稳定性</a></p> 
<p id="11.%E8%A1%A8%E6%A0%BC-toc" style="margin-left:40px;"><a href="#11.%E8%A1%A8%E6%A0%BC" rel="nofollow">11.表格</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<p><img alt="" height="671" src="https://images2.imgbox.com/17/2d/5Is0y7Pi_o.png" width="880"></p> 
<h3 id="1.%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" style="background-color:transparent;">1.直接插入排序</h3> 
<p>从前往后，每次在前面已经排好序的数组里找到自己的位置并插入；</p> 
<pre><code class="language-java">  public void sort(int[] arr) {
        for(int i=0;i&lt;arr.length;i++){
            for(int j=i-1;j&gt;=0;j--){
                if(arr[j]&gt;arr[j+1]) {
                    swap(arr,j,j+1);
                }else{
                    break;
                }
            }
        }
    }</code></pre> 
<h3 id="2.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">2.希尔排序</h3> 
<p>从len/2的间隔开始每次折半，每一次的排序，按照间隔将间隔特定距离的数按照直接插入排好；</p> 
<pre><code class="language-java"> public void sort(int[] arr,int k) {
        if(k==0) return;

        for(int j=k;j&lt;arr.length;j+=k){
            for(int q=j-k;q&gt;=0;q-=k){
                if(arr[q]&gt;arr[q+k]){
                    swap(arr,q,q+k);
                }
            }
        }

        sort(arr,k/2);
    }</code></pre> 
<h3 id="3.%20%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">3. 简单选择排序</h3> 
<p>每次选择未排序中的最小值，插入到已经排序的数列的末尾</p> 
<pre><code class="language-java"> public void sort(int[] arr) {
        for (int i = 0; i &lt; arr.length; i++) {
            int index=getMinIndex(arr,i);
            swap(arr,i,index);
        }
    }

    private int getMinIndex(int[] arr, int i) {
        int min_index=i;
        int min=arr[i];
        for (int j = i; j &lt;arr.length; j++) {
           if(arr[j]&lt;min){
               min_index=j;
               min=arr[j];
           }
        }
        return min_index;
    }</code></pre> 
<h3 id="4.%20%E5%A0%86%E6%8E%92%E5%BA%8F">4. 堆排序</h3> 
<p>利用数组实现最小堆，最大堆，注意最大堆最小堆的开头第一个节点序号只能为1不能为0；</p> 
<pre><code class="language-java">public void sort(int[] arr) {
        List&lt;Integer&gt; res=new ArrayList&lt;&gt;();
        int k=0;
        while(k&lt;arr.length){
            for(int i=arr.length-k;i&gt;1;i--){
                sort(arr,i);
            }
            res.add(arr[0]);
            swap(arr,0,arr.length-1-k);
            k++;
        }
        int j=0;
        for(int i=0;i&lt;arr.length;i++){
            arr[j++]=res.get(i);
        }
    }

    public void sort(int[] arr, int j) {
        while(j&gt;1){
            int k=j/2*2;
            if(k+1&lt;=j &amp;&amp; getNode(arr,k+1)&lt;getNode(arr,k)){
                k=k+1;
            }
            if(k&lt;=j &amp;&amp; getNode(arr,j/2)&lt;getNode(arr,k)){
                k=j/2;
            }
            swap(arr,j/2-1,k-1);
            j/=2;
        }
    }

    private int getNode(int[] arr,int i) {
        return arr[i-1];
    }</code></pre> 
<h3 id="5.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">5.冒泡排序</h3> 
<p>依此交换相邻两个元素使得前一个元素小于后一个，如果某一趟没有交换则结束；</p> 
<pre><code class="language-java">public void sort(int[] arr) {
        for(int j=1;j&lt;=arr.length-1;j++){
            boolean flag=false;
            for (int i = arr.length-1; i &gt;=1; i--) {
                if(arr[i-1]&gt;arr[i]){
                    swap(arr,i-1,i);
                    flag=true;
                }

            }
            if(!flag) break;
        }

    }</code></pre> 
<h3 id="6.%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">6. 快速排序</h3> 
<p>选定一个基准值，左边的小于基准值，右边的大于基准值，基准值插中间；</p> 
<pre><code class="language-java"> private void sort(int[] arr, int i, int j) {
        if(i&gt;=j) return ;
        int index=arr[i];
        int left=i,right=j;
        while(left&lt;right){
            while(left&lt;right &amp;&amp; arr[right]&gt;=index){
                right--;
            }
            if(left&lt;right){
                arr[left]=arr[right];
                left++;
            }

            while(left&lt;right &amp;&amp; arr[left]&lt;=index){
                left++;
            }
            if(left&lt;right){
                arr[right]=arr[left];
                right--;
            }

        }
        arr[left]=index;
        index =left;

        sort(arr,i,index-1);
        sort(arr,index+1,j);
    }</code></pre> 
<h3 id="7.%202%E8%B7%AF%E5%BD%92%E5%B9%B6">7. 2路归并</h3> 
<p>折半递归，合并折半的两个有序的链表</p> 
<pre><code class="language-java"> private void sort(int[] arr,int i,int j){
        if(i&gt;=j) return;
        int k=(j-i+1)/2;
        sort(arr,i,i+k-1);
        sort(arr,i+k,j);
        merge(arr,i,k,j);
    }

    private void merge(int[] arr, int i, int k, int j) {
        int s1=i,s2=i+k,e1=i+k-1,e2=j;
        int [] res=new int[j-i+1];
        int q=0;
        while(s1&lt;=e1 &amp;&amp; s2&lt;=e2){
            if(arr[s1]&lt;arr[s2]){
                res[q++]=arr[s1];
                s1++;
            }else{
                res[q++]=arr[s2];
                s2++;
            }
        }
        while(s1&lt;=e1 ){
                res[q++]=arr[s1];
                s1++;
        }
        while(s2&lt;=e2){
                res[q++]=arr[s2];
                s2++;
        }
        q=0;
        while(i&lt;=j){
            arr[i]=res[q];
            q++;
            i++;
        }
    }</code></pre> 
<h3 id="8.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">8.基数排序</h3> 
<ol><li>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。<br> 分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中<br> 收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]<br> 对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束</li></ol> 
<h3 id="9.%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95">9.数据测试</h3> 
<pre><code class="language-java"> public static void main(String[] args) {
        int n=10000;
        int[] arr=new int[n];
        int[] brr=new int[n];
        for(int i=0;i&lt;n;i++){
            arr[i]= new Random().nextInt(1000);
            brr[i]=arr[i];
        }
//        System.out.println(Arrays.toString(arr));
//        System.out.println(Arrays.toString(brr));
        Arrays.sort(arr);
//        System.out.println(Arrays.toString(arr));



//        SortMath s= new DirectInsert();
//        SortMath s= new XierSort();
//        SortMath s= new DirectChoose();
//        SortMath s= new DuiSort();
//        SortMath s= new BoomSort();
//        SortMath s= new RapidSort();
//        SortMath s=new CombbineSort();
//        SortMath s=new BaseSort();
        SortMath []t=new SortMath[]{    new DirectInsert(), new XierSort(),
                                        new DirectChoose(),new DuiSort(),
                                        new BoomSort(),new RapidSort(),
                                        new CombbineSort(),new BaseSort()};
        TreeMap&lt;Long,String&gt; te=new TreeMap&lt;&gt;();
        for(SortMath p:t){
            long start=System.currentTimeMillis();
            SortMath s=p;
            s.sort(brr);
            long end =System.currentTimeMillis();
            System.out.println("排序算法："+p.getClass().getName());
            System.out.println("用时："+(end-start));
            for(int i=0;i&lt;n;i++){
                if(arr[i]!=brr[i]){
                    System.out.println("error");
                    System.out.println(Arrays.toString(arr));
                }
            }
            System.out.println("correct!!!");
            te.put(end-start,p.getClass().getName());
        }
        for(Long p:te.keySet()){
            System.out.println(te.get(p)+"----"+p);
        }



    }</code></pre> 
<h3 id="10.%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">10.算法的稳定性</h3> 
<p>        排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</p> 
<h3 id="11.%E8%A1%A8%E6%A0%BC">11.表格</h3> 
<p><img alt="" height="365" src="https://images2.imgbox.com/91/2a/8vnM9fG7_o.png" width="630"></p> 
<p>参考：</p> 
<p>1. <a href="https://baijiahao.baidu.com/s?id=1602011058247698952&amp;wfr=spider&amp;for=pc" rel="nofollow" title="https://baijiahao.baidu.com/s?id=1602011058247698952&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1602011058247698952&amp;wfr=spider&amp;for=pc</a></p> 
<p>2.<a href="https://www.cnblogs.com/hokky/p/8529042.html" rel="nofollow" title="https://www.cnblogs.com/hokky/p/8529042.html">https://www.cnblogs.com/hokky/p/8529042.html</a></p> 
<p>3.<a href="https://blog.csdn.net/pass_JMC/article/details/126716655" title="11种排序算法的简单实鉴和简单性能测试_排序算法测试_oraen的博客-CSDN博客">11种排序算法的简单实鉴和简单性能测试_排序算法测试_oraen的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd5ba8e93de501beecb8685a378f6c73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">程序员推荐 Python编程：从入门到实践</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6aa83441465d4892798eaecff980e02e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Img标签的src地址自动拼接本地域名（localhost:8080）导致图片不显示问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>