<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>语义分析和中间代码生成 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="语义分析和中间代码生成" />
<meta property="og:description" content="中间语言 后缀式 图表示法 三地址代码 赋值语句的翻译 下面给出一个以三地址代码为中间语言的赋值语句的S属性文法
那个 || 表示连接上 不是表示或
比如 S-&gt;id := E 的语义规则 表示 S的三地址代码是由E的三地址代码再连接上一个 gen函数返回值
gen返回的是一段三地址代码
E.place = newtemp
表示先产生一个临时变量用于存放之后的运算结果，然后存储到E.place中
lookup查找在符号表中是否出现
newtemp 是临时变量，用于存储以后的运算结果
E.place 放的是运算结果的 名字 / 地址
最后 E -&gt; id 表示的是 E的结果单元 E.place 就是 变量 id的结果单元， 单独一个变量，没有三地址代码，所以是 E.code = ’ ’
所以，他的语义动作就是调用 lookup函数，在符号表中查找变量标识符 id , 如果找到了,lookup就返回变量标识符的入口
数组元素引用的翻译 编译程序会对数组名和下标表达式列表进行分析和翻译，在目标程序或中间语言程序插入计算出要访问的数组元素的地址的代码
编译程序会生成两组计算数组元素地址的代码，一部分是红色的可变部分的代码，一部分是蓝色的不变部分的代码
不变部分所涉及的信息在数组声明的时候就确定了
Elist 表示表达式列表，放在 [ ]中，作为下标表达式列表
id[Elist] 叫做数组元素的引用，有时也叫做下表变量
Elist.ndim 表示处理到了第几维
带数组元素的赋值语句的翻译 L.place ’ [ ’ L.offset ’ [ ’ ’ := ’ E." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/57bde573bfe3d1301c3e15c856c11731/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-15T22:19:58+08:00" />
<meta property="article:modified_time" content="2021-05-15T22:19:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">语义分析和中间代码生成</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>中间语言</h3> 
<p><img src="https://images2.imgbox.com/5f/81/nPWFbpdT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cf/87/QeyCRrul_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_3"></a>后缀式</h4> 
<p><img src="https://images2.imgbox.com/c8/db/3BJXtqW8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/35/b5/Om3MIR3e_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d1/9c/EtuxVG2u_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/98/ae/DmcgAD2b_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_8"></a>图表示法</h4> 
<p><img src="https://images2.imgbox.com/0c/0c/Icpyysop_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4b/f6/CRdUk1eT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2b/24/SpmgB8LS_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/25/9d/tB9dAOlg_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_14"></a>三地址代码</h4> 
<p><img src="https://images2.imgbox.com/6d/65/3GkyD2a6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/78/1c/3QDFUalb_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/60/e2/jXiJaJpk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/42/a2/7Wkx7slY_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/20/8a/m76aYLdw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/77/ce/NePKWMqK_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_21"></a>赋值语句的翻译</h4> 
<p><img src="https://images2.imgbox.com/81/0e/EGrCLBFK_o.png" alt="在这里插入图片描述"><br> 下面给出一个以三地址代码为中间语言的赋值语句的S属性文法<br> <img src="https://images2.imgbox.com/0e/f1/33ZBdpKn_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a7/6e/UqbVcVPL_o.png" alt="在这里插入图片描述"><br> 那个 || 表示连接上 不是表示或<br> 比如 S-&gt;id := E 的语义规则 表示 S的三地址代码是由E的三地址代码再连接上一个 gen函数返回值<br> gen返回的是一段三地址代码</p> 
<p>E.place = newtemp<br> 表示先产生一个临时变量用于存放之后的运算结果，然后存储到E.place中</p> 
<p><img src="https://images2.imgbox.com/e7/dd/e7xwITGZ_o.png" alt="在这里插入图片描述"><br> lookup查找在符号表中是否出现<br> newtemp 是临时变量，用于存储以后的运算结果<br> E.place 放的是运算结果的 名字 / 地址<br> <img src="https://images2.imgbox.com/cd/7d/z8ZKW7QM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3d/20/6jeGuaiz_o.png" alt="在这里插入图片描述"><br> 最后 E -&gt; id 表示的是 E的结果单元 E.place 就是 变量 id的结果单元， 单独一个变量，没有三地址代码，所以是 E.code = ’ ’<br> 所以，他的语义动作就是调用 lookup函数，在符号表中查找变量标识符 id , 如果找到了,lookup就返回变量标识符的入口</p> 
<h4><a id="_42"></a>数组元素引用的翻译</h4> 
<p>编译程序会对数组名和下标表达式列表进行分析和翻译，在目标程序或中间语言程序插入计算出要访问的数组元素的地址的代码<br> <img src="https://images2.imgbox.com/86/61/yUxfpt66_o.png" alt="在这里插入图片描述"><br> 编译程序会生成两组计算数组元素地址的代码，一部分是红色的可变部分的代码，一部分是蓝色的不变部分的代码<br> 不变部分所涉及的信息在数组声明的时候就确定了<br> <img src="https://images2.imgbox.com/d3/3b/CsjVkAPR_o.png" alt="在这里插入图片描述"><br> Elist 表示表达式列表，放在 [ ]中，作为下标表达式列表<br> id[Elist] 叫做数组元素的引用，有时也叫做下表变量</p> 
<p><img src="https://images2.imgbox.com/aa/43/y5ogF43w_o.png" alt="在这里插入图片描述"><br> Elist.ndim 表示处理到了第几维</p> 
<p><img src="https://images2.imgbox.com/53/21/7u2WSJeD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ce/82/dVz3TyS6_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_57"></a>带数组元素的赋值语句的翻译</h5> 
<p><img src="https://images2.imgbox.com/66/c4/6IB6jO0c_o.png" alt="在这里插入图片描述"></p> 
<p>L.place ’ [ ’ L.offset ’ [ ’ ’ := ’ E.place<br> 这条语句赋值号的左边是一个变址访问，利用 L.place 记录的地址计算的不变部分 和 L.offset记录的可变部分做变址访问，访问到的单元就是接受E.place 结果的数组元素<br> <img src="https://images2.imgbox.com/f6/ac/x1LrsOhv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b9/6a/CvfXZdbx_o.png" alt="在这里插入图片描述"><br> Elist.place 记录从左到右分析完的下标列表，计算出来的可变部分的前一阶段的值，这个值总是随着下标列表的不断识别分析，从左到右，逐步的做乘法加法，乘法加法累计计算出来，总是把 Elist 乘以 这一维的个数，再加上这一维表达式的值，就这样像滚雪球一样把可变部分的值计算出来<br> 最后把数组名表示符 id 的信息记录在 Elist.array 中</p> 
<p>这就是数组元素分析，刚开始的语义动作<br> <img src="https://images2.imgbox.com/26/3b/VxdKAmif_o.png" alt="在这里插入图片描述"><br> 随着数组元素分析的进行，<br> 假设我们现在处理到了第m 维<br> 前面分析完的各种信息都在 Elist1 里面， 现在 第 m 维分析完了后内容到了 E<br> Elist1.place 就是前面 m-1 维的计算结果 ,是这一部分<img src="https://images2.imgbox.com/99/06/noCKyfZh_o.png" alt="()"></p> 
<p><img src="https://images2.imgbox.com/bf/29/Qb2dIemo_o.png" alt="在这里插入图片描述"><br> 随着一维一维的分析，最终会分析完碰到右括号<br> Elist.array 记录了数组名，这个数组名就是那个 首地址base<br> C 是数组声明时就确定了不变得常量部分(对应绿色部分)</p> 
<p><img src="https://images2.imgbox.com/b3/a6/XwNzcfY8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/83/d0/mzvzn7VF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/60/4f/cMhb1WgF_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_86"></a>类型转换</h4> 
<p>当程序中出现不同类型的值得运算时，编译器需要要么拒绝这种运算，要么产生有关类型转换的指令，使得最后目标代码中参与运算的数据类型是一致的</p> 
<p>int* 表示整形的乘法</p> 
<p><img src="https://images2.imgbox.com/a7/29/RzNTKpHO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d7/a2/JmdcfFup_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f9/3b/HyEcPSF4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1a/f1/nILTmYWr_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_96"></a>布尔表达式的翻译</h3> 
<p>i rop i 表示 关系运算可以构成布尔表达式<br> rop 关系运算符，可以是 &gt; , &gt;= , &lt;= , &lt; , == ， &lt;&gt;（不等于）<br> <img src="https://images2.imgbox.com/a9/7d/hLkddvQD_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a8/0e/fjzYOkPx_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/af/d9/5JIPALYJ_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_103"></a>数值表示法的翻译模式</h5> 
<p><img src="https://images2.imgbox.com/a1/ad/v1aEZiVX_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ed/a2/KPNAUMYm_o.png" alt="在这里插入图片描述"><br> emit 表示向输出文件发送一条指令<br> E1.place 里面放的是 E1 这一子表达式的运算结果的地址<br> <img src="https://images2.imgbox.com/37/80/r4e0T1d9_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/42/1e/UYYIPQbV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/86/4f/FVZKOzrD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fe/50/FZO2muHi_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_113"></a>带优化的布尔表达式翻译模式</h5> 
<p><img src="https://images2.imgbox.com/1c/02/TdUURhFz_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f7/9d/7ddMHCfF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/24/2f/z01ws9Vv_o.png" alt="在这里插入图片描述"><br> E1.true = E.true 意思是 E1如果为真，那么就不要计算E2了，直接跳到 E为 true 的地方<br> E1为假，应该将来跳转执行到E2的代码，所以我们E1.false产生一个新标号，将来这个标号，就像 gen(E1.false ‘L’) 一样， 要放到 E2的代码之前，标志着 E2 的开头， 这样 执行到 如果 E1为 false ，程序就会跳转到这个标号这里<br> <img src="https://images2.imgbox.com/14/54/Pfr2eOXQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/12/c9/bOxaU1oA_o.png" alt="在这里插入图片描述"><br> 对于非运算， 只要把 E1 和 E 的 布尔属性翻转一下，无需改变其代码，就可以了<br> <img src="https://images2.imgbox.com/70/51/sNpzVDmu_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7e/1f/debLDKhb_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/bb/70/jz1EuSMz_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/65/43/hb4uGh9f_o.png" alt="在这里插入图片描述"><br> 从根节点 E 开始， 自上而下计算出整个语法树的布尔集成属性，每个节点都有一个 （真标号，假标号） 代表为真、假 要跳转的地方<br> <img src="https://images2.imgbox.com/a0/03/yKddxHGC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f9/b3/TAdrkUhN_o.png" alt="在这里插入图片描述"><br> 上图翻译是多遍扫描</p> 
<p>建立语法树<br> 计算各节点布尔值<br> 自下而上生成代码<br> <img src="https://images2.imgbox.com/87/4f/ONs9lrBl_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_135"></a>布尔表达式一边扫描翻译模式</h5> 
<p>那个 p 是 四元式的标号， 表示跳转到这个四元式<br> <img src="https://images2.imgbox.com/29/93/LnyxwdvW_o.png" alt="在这里插入图片描述"><br> nextquard是输出序列中，下一个四元式的下标， 将要放进输出序列的四元式的位置<br> <img src="https://images2.imgbox.com/2f/c7/FQKhfIbx_o.png" alt="在这里插入图片描述"><br> 一遍扫描最大的问题就是在其准备填入跳转时可能无法立即知道，需要分析完更大的语法单位才能回填<br> <img src="https://images2.imgbox.com/85/4b/4gqR5Qw9_o.png" alt="在这里插入图片描述"><br> 需要回填的分成两组，制作两个链表，一个是跳真的，一个是跳假的<br> 实际上目前这个四元式，需要回填的那些，因为不知道要跳到哪，所以他第四个位置，跳转地址是空着的，我们就可以先利用起来，作为链表next指针用<br> 最后的链尾放上0标志</p> 
<p>同一个链表的中都是需要回填到同一个位置的<br> <img src="https://images2.imgbox.com/f9/dd/zczxLdCG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/04/cd/UVO6C1ej_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b2/a1/fDkfT5zD_o.png" alt="在这里插入图片描述"><br> 注意为了使我们的翻译模式能够和自下而上的语法分析结合起来，需要把语义动作放在产生式的右边，使得语义动作的执行时机能够统一到这规约完成的时候进行<br> <img src="https://images2.imgbox.com/27/c5/P83S95Y4_o.png" alt="在这里插入图片描述"><br> 对于 E - &gt; E1 or E2 在扫描到or的时候，就知道 E1的fallist 的下一个地址位置就是 E2 的开头<br> 所以在准备分析 E2前， 需要有个语义动作，记录E2的地址<br> 然后我们可以通过嵌入 ε 产生式 ， 将那些嵌入在产生式中间的语义动作移动到 产生式的后边<br> <img src="https://images2.imgbox.com/fa/f8/Vjkxg1MB_o.png" alt="在这里插入图片描述"><br> M.quard 记录了下一个将要生成的四元式的下标，也就是E2的第一个四元式的下标<br> 之所以 esclispe 规约到 M 是为了获得一个执行语义动作的时机，把E2的第一个四元式的位置记录下来<br> <img src="https://images2.imgbox.com/0f/8d/8YCkPldM_o.png" alt="在这里插入图片描述"><br> 我们使用的是自下而上的语法分析，当我们要设计翻译模式时，我们假设这个产生式已经分析完了<br> <img src="https://images2.imgbox.com/79/d5/q6tzuO5l_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ee/1b/DGfyMiHQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e6/17/5ODMZ5Wr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fc/19/kmHo3YPr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/63/a5/Bu6Lh5rh_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e9/c7/ZsvQKCHl_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_166"></a>控制语句</h3> 
<p><img src="https://images2.imgbox.com/8b/53/J2gYE1ye_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="if_169"></a>if语句的属性文法</h4> 
<p><img src="https://images2.imgbox.com/bd/35/Nn3rm9kQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f6/74/XlvkhrNO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9d/f3/dCEnjgtP_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6a/c7/3qu67YGP_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="while_174"></a>while语句的属性文法</h4> 
<p>S,begin 是综合属性<br> S.next 是继承属性<br> E.true E.false 都是继承属性</p> 
<p><img src="https://images2.imgbox.com/77/c9/dgYbRqWt_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e3/56/4xnEHBvZ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_181"></a>控制语句的属性计算示例</h4> 
<p><img src="https://images2.imgbox.com/13/12/FvOOrQws_o.png" alt="在这里插入图片描述"><br> 每个符号都给一个 (S.begin,S.next) 的标识 或者是 (E.true, E.false)<br> 对于S 只有是个循环语句的时候才会用到 S.begin ，不是循环这里填 -</p> 
<p><img src="https://images2.imgbox.com/05/44/XU5c0IWC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/72/76/brbUdHrU_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0b/6c/TQF95biV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d1/1a/m59oH9lt_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3a/8c/Gn1Mw5Yr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/64/d8/cZwhAlE8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/05/ca/jDSb675f_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_194"></a>一遍扫描翻译控制语句</h4> 
<p><img src="https://images2.imgbox.com/71/95/0O88UiPl_o.png" alt="在这里插入图片描述"><br> L表示的是由 分号分割的S的列表，也就是语句列表<br> <img src="https://images2.imgbox.com/b7/12/DQTmzjtN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/91/df/CXNuZdVx_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/22/ee/b2FAgwmi_o.png" alt="在这里插入图片描述"><br> M的语义动作就是记录下一个四元式的下标，把他记录到 M.quard属性里面<br> N的动作是产生 S1 和 S2之间的跳转指令的动作，使得执行完S1之后可以执行 if then else 的后面的语句，但是这个时候还不知道if then else后面的语句的地址是什么，所以我们需要产生一个回填链表，等到以后合适的时机回填，这个链表就只有一个四元式， emit(j,-,-,-)那个目的地址还不知道，等待以后回填<br> <img src="https://images2.imgbox.com/7e/f7/vQem98bE_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e4/20/Nu2PBpVc_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/36/b2/V5jMb3hJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f1/88/pZZ7UidG_o.png" alt="在这里插入图片描述"><br> 当分析碰到 分号 时， 应该将分号前所有语句中， 也就是说这个L当中的需要回填的四元式可以回填了，因为如果分号前还有一些四元式需要回填的，那么一定是去这些语句的后继语句的，而此时可以确定，这些所谓的后继语句就是马上要开始分析的分号后面的S的代码<br> <img src="https://images2.imgbox.com/96/a2/PzYHwhJ6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e3/12/SFNwPN1m_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/34292bfab3b96c40b5667dc3598fc9ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux中安装redis-5.0.2</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47c38e020c925a1712e6a93802fd4de9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">函数本科c语言程序设计完整题库,自考“C语言程序设计”模拟试题十三</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>