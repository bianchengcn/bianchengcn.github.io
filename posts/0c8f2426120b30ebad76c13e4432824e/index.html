<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot 学习记录(三): jpa - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot 学习记录(三): jpa" />
<meta property="og:description" content="上篇学习了mybaits的使用，既可以通过注解方式实现，也可以使用常见的xml配置方式实现
这篇我们继续学习数据库访问层jpa，集各家所长，各取所需吧
一，第一步当然还是引入相关依赖包，在pom.xml中继续添加：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt;二，jpa底层是由Hibernate来实现的，需要在application.properties中添加相关配置 #jpa spring.jpa.properties.hibernate.hbm2ddl.auto=update spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.show-sql= true spring.jackson.serialization.indent_output=true这里说明一下： hibernate.hbm2ddl.auto参数的作用主要用于：自动创建|更新|验证数据库表结构,有四个值： create： 每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表， 哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop ：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库）， 以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。 要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 validate ：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值 另外新建sql脚本，命名schema.sql，并放在classpath下面，那么在应用启动的时候会在结束前读取脚本，执行命令三，测试，我们新建实体类UserInfo，启动查看是否自动创建了table package com.example.entity; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.Table; import javax.persistence.Transient; @Entity @Table(name=&#34;user_info&#34;) public class UserInfo { @Id @GeneratedValue private long id; private String name; private String gender; /** 不映射成数据表 */ @Transient private String status; public long getId() { return id; } public void setId(long id) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/0c8f2426120b30ebad76c13e4432824e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-04-07T15:31:44+08:00" />
<meta property="article:modified_time" content="2017-04-07T15:31:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot 学习记录(三): jpa</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>上篇学习了mybaits的使用，既可以通过注解方式实现，也可以使用常见的xml配置方式实现</p> 
<p>这篇我们继续学习数据库访问层jpa，集各家所长，各取所需吧</p> 
<p>一，第一步当然还是引入相关依赖包，在pom.xml中继续添加：</p> 
<pre><code class="language-html">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>二，jpa底层是由Hibernate来实现的，需要在application.properties中添加相关配置 
<pre><code class="language-html">#jpa
spring.jpa.properties.hibernate.hbm2ddl.auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect
spring.jpa.show-sql= true
spring.jackson.serialization.indent_output=true</code></pre>这里说明一下： 
<pre><code class="language-plain">hibernate.hbm2ddl.auto参数的作用主要用于：自动创建|更新|验证数据库表结构,有四个值：

create： 每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，
哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。
create-drop ：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。
update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），
以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。
要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。
validate ：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值

另外新建sql脚本，命名schema.sql，并放在classpath下面，那么在应用启动的时候会在结束前读取脚本，执行命令</code></pre>三，测试，我们新建实体类UserInfo，启动查看是否自动创建了table 
<br> 
<pre><code class="language-java">package com.example.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.Transient;

@Entity
@Table(name="user_info")
public class UserInfo {

	@Id
	@GeneratedValue
	private long id;
	
	private String name;
	
	private String gender;
	
	/** 不映射成数据表 */
	@Transient
	private String status;

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getGender() {
		return gender;
	}

	public void setGender(String gender) {
		this.gender = gender;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
		
}
</code></pre> 
<p>四，启动查看，数据库创建了空的table，user_info</p> 
<p>五，加入schema.sql脚本，重新启动</p> 
<p><span style="background-color:rgb(240,240,240)">insert into user_info (name,gender) values('initname','M');</span></p> 
<p>再查看数据库，此时已成功插入一条初始化数据，这里需要注意两点：</p> 
<p>1，开始我引入的spring-boot-starter-parent版本是1.3.8的，前面都没问题，</p> 
<p>引入jpa后项目就报错了，查看本地仓库，依赖包也下载下来了，不知道什么原因，</p> 
<p>于是更改parent版本为1.3.6，成功启动</p> 
<p>2，执行schema.sql脚本，前提是已经创建好了table，自动创建table是应用第一次启动结束后才会创建</p> 
<p>而读取脚本文件是在应用启动结束前，如果没有创建table就加入脚本文件，会找不到table报错，另外每次重启都会执行一次。<br> <br> </p> 
<p>六，创建UserInfoRepository 继承Repository接口，基本方法已经有实现，继承后能直接使用</p> 
<p>这也是使用jpa的便利之处：</p> 
<pre><code class="language-java">package com.example.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.example.entity.UserInfo;

public interface UserInfoRepository extends JpaRepository&lt;UserInfo, Long&gt;{

}
</code></pre> 
<p>七，创建UserController，这里简化了代码，没有使用service层，仅供测试用</p> 
<pre><code class="language-java">package com.example.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import com.example.entity.UserInfo;
import com.example.repository.UserInfoRepository;

@RestController
public class UserController {
	
	@Autowired
	private UserInfoRepository userRepository;
	
	@RequestMapping(value="/user/save",method=RequestMethod.GET)
	public void save(){
		UserInfo user = new UserInfo();
		user.setGender("F");
		user.setName("wendy");
		userRepository.save(user);
	}
	
}</code></pre>八，查看控制台打印sql语句： 
<pre><code class="language-html">2017-04-07 17:09:01.728  INFO 516 --- [nio-8088-exec-1] o.a.c.c.C.[.[localhost].[/spring-boot]   : Initializing Spring FrameworkServlet 'dispatcherServlet'
2017-04-07 17:09:01.729  INFO 516 --- [nio-8088-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2017-04-07 17:09:01.761  INFO 516 --- [nio-8088-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 32 ms
Hibernate: insert into user_info (gender, name) values (?, ?)
</code></pre>九，除了封装好的方法，我们也可以自定义查询，jpa会根据方法名自动创建sql语句 
<p>如，在UserInfoRepository中添加方法：</p> 
<pre><code class="language-java">package com.example.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.example.entity.UserInfo;

public interface UserInfoRepository extends JpaRepository&lt;UserInfo, Long&gt;{

	UserInfo findById(long id);
	
	UserInfo findByName(String name);
}
</code></pre>在UserController中新增测试方法： 
<pre><code class="language-java">	@RequestMapping(value="/user/id",method=RequestMethod.GET)
	public UserInfo findById(long id){
		return userRepository.findById(id);
	}
	
	@RequestMapping(value="/user/name",method=RequestMethod.GET)
	public UserInfo findByName(String name){
		return userRepository.findByName(name);
	}</code></pre> 
<p>测试返回结果如下：</p> 
<p><img src="https://images2.imgbox.com/b7/1c/K8CxAI0W_o.png" alt=""><img src="https://images2.imgbox.com/6f/1c/C9mLq6js_o.png" alt=""><br> </p> 
<p>再查看控制台打印的sql语句：</p> 
<pre><code class="language-html">Hibernate: select userinfo0_.id as id1_0_, userinfo0_.gender as gender2_0_, userinfo0_.name as name3_0_ from user_info userinfo0_ where userinfo0_.id=?
Hibernate: select userinfo0_.id as id1_0_, userinfo0_.gender as gender2_0_, userinfo0_.name as name3_0_ from user_info userinfo0_ where userinfo0_.name=?
</code></pre> 
<p>十，很多时候我们需要根据业务需求写sql语句，下面我们来看如何使用注解写sql语句</p> 
<p>如，在UserInfoRepository中添加方法：</p> 
<pre><code class="language-java">/**
	 * 自定义查询语句
	 * @param id
	 * @return
	 */
	@Query("select gender from UserInfo where id=?1")
	String userGender(long id);
	
	/**
	 * 自定义更新语句
	 * @param firstname
	 * @param lastname
	 * @return
	 */
	@Transactional
	@Modifying 
	@Query("update UserInfo set name =:name where id =:id")
	int updateName(@Param("name")String name,@Param("id")Long id);</code></pre>这里需要注意： 
<p>1，查询表名UserInfo对应的是实体类名，不是数据库表名</p> 
<p>2，更新数据库操作，需要添加事务注解@Transactional，否则会报错：</p> 
<p>javax.persistence.TransactionRequiredException<br> 3，其他用法可以参见博客：<a target="_blank" href="http://jishiweili.iteye.com/blog/2088265" rel="nofollow noopener noreferrer">http://jishiweili.iteye.com/blog/2088265</a></p> 
<p>在UserController中新增测试方法：</p> 
<pre><code class="language-java">	/**
	 * 使用注解写查询语句
	 * @param id
	 * @return
	 */
	@RequestMapping(value="/gender",method=RequestMethod.GET)
	public String getGender(long id){
		return userRepository.userGender(id);
	}
	
	/**
	 * 使用注解生成自定义方法
	 * @param id
	 * @return
	 */
	@RequestMapping(value="/update",method=RequestMethod.POST)
	public String update(@RequestBody UserInfo userInfo){
		String name = userInfo.getName();
		Long id = userInfo.getId();
		int count = userRepository.updateName(name,id);
		return "成功更新"+count+"条数据";
	}
	</code></pre> 
<p>启动测试：</p> 
<p><span style="color:rgb(80,80,80); font-family:OpenSans,Helvetica,Arial,sans-serif; white-space:pre-wrap; background-color:rgb(250,250,250)">http://localhost:8088/spring-boot/gender?id=1 ========== 返回结果：M</span></p> 
<p><span style="color:rgb(80,80,80); font-family:OpenSans,Helvetica,Arial,sans-serif; white-space:pre-wrap; background-color:rgb(250,250,250)"><span style="color:rgb(80,80,80); font-family:OpenSans,Helvetica,Arial,sans-serif; white-space:pre-wrap; background-color:rgb(250,250,250)">http://localhost:8088/spring-boot/update === params:{"name":"acc","id":"2"} ======= 返回结果：成功更新1条数据</span><br> </span></p> 
<p><br> </p> 
<p>===============================================================================================</p> 
<p>jpa的使用就初步演示到这里，下篇我们继续学习日志框架，SpringBoot 学习记录(四): slf4j+logback</p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> <br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/781ca43dec05f1d26dbfb96db9d910fd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jQuery中的$(window).load()与$(document).ready()</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de15ec32a45f63ebd42f51efd2dc0167/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一. 先了解 Markdown 是什么</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>