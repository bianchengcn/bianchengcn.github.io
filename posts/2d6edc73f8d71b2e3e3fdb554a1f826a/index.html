<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于Findbugs的一些常见报错的翻译和处理方式 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于Findbugs的一些常见报错的翻译和处理方式" />
<meta property="og:description" content="在Lab5中要求使用 CheckStyle 和 FindBugs 工具对经过人工走查的 Lab4 代码进行自动的静态代码分析。在使用FindBugs的过程中，出现了一些难以理解的报错，经查阅资料，了解了错误的原因以及一些大致的解决办法。
下面是关于FindBugs的一些常见报错的翻译和处理方法：
一、Security 关于代码安全性防护
1.Dm: Hardcoded constant database password(DMI_CONSTANT_DB_PASSWORD)
代码中创建DB的密码时采用了写死的密码。
2.Dm: Empty database password(DMI_EMPTY_DB_PASSWORD)
创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。
3.HRS: HTTP cookie formed from untrustedinput (HRS_REQUEST_PARAMETER_TO_COOKIE)
此代码使用不受信任的HTTP参数构造一个HTTP Cookie。
4.HRS: HTTP Response splittingvulnerability (HRS_REQUEST_PARAMETER_TO_HTTP_HEADER)
在代码中直接把一个HTTP的参数写入一个HTTP头文件中，HTTP的响应因此暴露了漏洞。
5.SQL: Nonconstant string passed toexecute method on an SQL statement (SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE)
该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。
6.XSS: JSP reflected cross site scriptingvulnerability (XSS_REQUEST_PARAMETER_TO_JSP_WRITER)
在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。
二、Experimental
1.LG: Potential lost logger changes due toweak reference in OpenJDK (LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE)
OpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。–logger配置改变，它就会丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2d6edc73f8d71b2e3e3fdb554a1f826a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-21T16:05:02+08:00" />
<meta property="article:modified_time" content="2018-06-21T16:05:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于Findbugs的一些常见报错的翻译和处理方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="background-color:#ffffff;">在Lab5中要求使用 CheckStyle 和 FindBugs 工具对经过人工走查的 Lab4 代码进行自动的静态代码分析。在使用FindBugs的过程中，出现了一些难以理解的报错，经查阅资料，了解了错误的原因以及一些大致的解决办法。</span></p> 
<p><span style="background-color:#ffffff;">下面是关于FindBugs的一些常见报错的翻译和处理方法：</span></p> 
<p></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一、</span><strong><span style="color:#000000;">Security </span><span style="color:#000000;">关于代码安全性防护</span></strong></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">1.Dm: Hardcoded constant database password(DMI_CONSTANT_DB_PASSWORD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">代码中创建</span><span style="color:#000000;">DB</span><span style="color:#000000;">的密码时采用了写死的密码。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">2.Dm: Empty database password(DMI_EMPTY_DB_PASSWORD)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">3.HRS: HTTP cookie formed from untrustedinput (HRS_REQUEST_PARAMETER_TO_COOKIE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此代码使用不受信任的</span><span style="color:#000000;">HTTP</span><span style="color:#000000;">参数构造一个</span><span style="color:#000000;">HTTP Cookie</span><span style="color:#000000;">。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">4.HRS: HTTP Response splittingvulnerability (HRS_REQUEST_PARAMETER_TO_HTTP_HEADER)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在代码中直接把一个</span><span style="color:#000000;">HTTP</span><span style="color:#000000;">的参数写入一个</span><span style="color:#000000;">HTTP</span><span style="color:#000000;">头文件中，</span><span style="color:#000000;">HTTP</span><span style="color:#000000;">的响应因此暴露了漏洞。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">5.SQL: Nonconstant string passed toexecute method on an SQL statement (SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">该方法以字符串的形式来调用</span><span style="color:#000000;">SQLstatement</span><span style="color:#000000;">的</span><span style="color:#000000;">execute</span><span style="color:#000000;">方法，它似乎是动态生成</span><span style="color:#000000;">SQL</span><span style="color:#000000;">语句的方法。这会更容易受到</span><span style="color:#000000;">SQL</span><span style="color:#000000;">注入攻击。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">6.XSS: JSP reflected cross site scriptingvulnerability (XSS_REQUEST_PARAMETER_TO_JSP_WRITER)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在代码中在</span><span style="color:#000000;">JSP</span><span style="color:#000000;">输出中直接写入一个</span><span style="color:#000000;">HTTP</span><span style="color:#000000;">参数，这会造成一个跨站点的脚本漏洞。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#000000;">二、</span><span style="color:#000000;">Experimental</span></strong></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">1.LG: Potential lost logger changes due toweak reference in OpenJDK (LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">OpenJDK</span><span style="color:#000000;">的引入了一种潜在的不兼容问题，特别是，</span><span style="color:#000000;">java.util.logging.Logger</span><span style="color:#000000;">的行为改变时。它现在使用内部弱引用，而不是强引用。</span><span style="color:#000000;">–logger</span><span style="color:#000000;">配置改变，它就会丢失对</span><span style="color:#000000;">logger</span><span style="color:#000000;">的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对</span><span style="color:#000000;">logger</span><span style="color:#000000;">配置将会丢失。例如：</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">public static void initLogging() throwsException {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> Logger logger =Logger.getLogger("edu.umd.cs");</span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> logger.addHandler(newFileHandler()); // call to change logger configuration</span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> logger.setUseParentHandlers(false);// another call to change logger configuration</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">}</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">该方法结束时</span><span style="color:#000000;">logger</span><span style="color:#000000;">的引用就丢失了，如果你刚刚结束调用</span><span style="color:#000000;">initLogging</span><span style="color:#000000;">方法后进行垃圾回收，</span><span style="color:#000000;">logger</span><span style="color:#000000;">的配置将会丢失（因为只有保持记录器弱引用）。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">public static void main(String[] args)throws Exception {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> initLogging(); // adds a filehandler to the logger</span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> System.gc(); // logger configurationlost</span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> Logger.getLogger("edu.umd.cs").info("Somemessage"); // this isn't logged to the file as expected</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">}</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">2.OBL: Method may fail to clean up streamor resource (OBL_UNSATISFIED_OBLIGATION)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动。</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一般来说，如果一个方法打开一个流或其他资源，该方法应该使用</span><span style="color:#000000;">try / finally</span><span style="color:#000000;">块来确保在方法返回之前流或资源已经被清除了。这种错误模式基本上和</span><span style="color:#000000;">OS_OPEN_STREAM</span><span style="color:#000000;">和</span><span style="color:#000000;">ODR_OPEN_DATABASE_RESOURCE</span><span style="color:#000000;">错误模式相同，但是是在不同在静态分析技术。我们正为这个错误模式的效用收集反馈意见。</span></span></p> 
<p><br>  </p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#000000;">三、</span><span style="color:#000000;">Bad practice</span><span style="color:#000000;">代码实现中的一些坏习惯</span></strong></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">1.AM: Creates an empty jar file entry(AM_CREATES_EMPTY_JAR_FILE_ENTRY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">调用</span><span style="color:#000000;">putNextEntry()</span><span style="color:#000000;">方法写入新的</span><span style="color:#000000;"> jar </span><span style="color:#000000;">文件条目时立即调用</span><span style="color:#000000;">closeEntry()</span><span style="color:#000000;">方法。这样会造成</span><span style="color:#000000;">JarFile</span><span style="color:#000000;">条目为空。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">2.AM: Creates an empty zip file entry(AM_CREATES_EMPTY_ZIP_FILE_ENTRY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">调用</span><span style="color:#000000;">putNextEntry()</span><span style="color:#000000;">方法写入新的</span><span style="color:#000000;"> zip </span><span style="color:#000000;">文件条目时立即调用</span><span style="color:#000000;">closeEntry()</span><span style="color:#000000;">方法。这样会造成</span><span style="color:#000000;">ZipFile</span><span style="color:#000000;">条目为空。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">3.BC: Equals method should not assumeanything about the type of its argument(BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">equals(Object o)</span><span style="color:#000000;">方法不能对参数</span><span style="color:#000000;">o</span><span style="color:#000000;">的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为</span><span style="color:#000000;"> null</span><span style="color:#000000;">，并且是表示与此对象相同的类型的对象时，结果才为</span><span style="color:#000000;"> true</span><span style="color:#000000;">。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">4.BC: Random object created and used onlyonce (DMI_RANDOM_USED_ONLY_ONCE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">随机创建对象只使用过一次就抛弃</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">5.BIT: Check for sign of bitwise operation(BIT_SIGNED_CHECK)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">检查位操作符运行是否合理</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">((event.detail &amp; SWT.SELECTED) &gt; 0)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">If SWT.SELECTED is a negative number, thisis a candidate for a bug. Even when SWT.SELECTED is not negative, it seems goodpractice to use '!= 0' instead of '&gt; 0'.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">6.CN: Class implements Cloneable but doesnot define or use clone method (CN_IDIOM)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">按照惯例，实现此接口的类应该使用公共方法重写</span><span style="color:#000000;"> Object.clone</span><span style="color:#000000;">（它是受保护的），以获得有关重写此方法的详细信息。此接口不</span><span style="color:#000000;">包含</span><span style="color:#000000;"> clone </span><span style="color:#000000;">方法。因此，因为某个对象实现了此接口就克隆它是不可能的</span><span style="color:#000000;">,</span><span style="color:#000000;">应该实现此接口的类应该使用公共方法重写</span><span style="color:#000000;"> Object.clone</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">7.CN: clone method does not callsuper.clone() (CN_IDIOM_NO_SUPER_CALL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一个非</span><span style="color:#000000;">final</span><span style="color:#000000;">类型的类定义了</span><span style="color:#000000;">clone()</span><span style="color:#000000;">方法而没有调用</span><span style="color:#000000;">super.clone()</span><span style="color:#000000;">方法。例如：</span><span style="color:#000000;">B</span><span style="color:#000000;">扩展自</span><span style="color:#000000;">A</span><span style="color:#000000;">，如果</span><span style="color:#000000;">B</span><span style="color:#000000;">中</span><span style="color:#000000;">clone</span><span style="color:#000000;">方法调用了</span><span style="color:#000000;">spuer.clone</span><span style="color:#000000;">（），而</span><span style="color:#000000;">A</span><span style="color:#000000;">中的</span><span style="color:#000000;">clone</span><span style="color:#000000;">没有调用</span><span style="color:#000000;">spuer.clone()</span><span style="color:#000000;">，就会造成结果类型不准确。要求</span><span style="color:#000000;">A</span><span style="color:#000000;">的</span><span style="color:#000000;">clone</span><span style="color:#000000;">方法中调用</span><span style="color:#000000;">spuer.clone()</span><span style="color:#000000;">方法。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">8.CN: Class defines clone() but doesn'timplement Cloneable (CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类中定义了</span><span style="color:#000000;">clone</span><span style="color:#000000;">方法但是它没有实现</span><span style="color:#000000;">Cloneable</span><span style="color:#000000;">接口</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">9.Co: Abstract class defines covariantcompareTo() method (CO_ABSTRACT_SELF)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">抽象类中定义了多个</span><span style="color:#000000;">compareTo()</span><span style="color:#000000;">方法，正确的是覆写</span><span style="color:#000000;">Comparable</span><span style="color:#000000;">中的</span><span style="color:#000000;">compareTo</span><span style="color:#000000;">方法，方法的参数为</span><span style="color:#000000;">Object</span><span style="color:#000000;">类型，如下例：</span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">int compareTo(T o)  </span><span style="color:#000000;">比较此对象与指定对象的顺序。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">10.Co: Covariant compareTo() methoddefined (CO_SELF_NO_OBJECT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类中定义了多个</span><span style="color:#000000;">compareTo()</span><span style="color:#000000;">方法，正确的是覆写</span><span style="color:#000000;">Comparable</span><span style="color:#000000;">中的</span><span style="color:#000000;">compareTo</span><span style="color:#000000;">方法，方法的参数为</span><span style="color:#000000;">Object</span><span style="color:#000000;">类型</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">11.DE: Method might drop exception(DE_MIGHT_DROP)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法可能抛出异常</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">12.DE: Method might ignore exception (DE_MIGHT_IGNORE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法可能忽略异常</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">13.DMI: Don't use removeAll to clear acollection (DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">不要用</span><span style="color:#000000;">removeAll</span><span style="color:#000000;">方法去</span><span style="color:#000000;">clear</span><span style="color:#000000;">一个集合</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">14.DP: Classloaders should only be createdinside doPrivileged block (DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">类加载器只能建立在特殊的方法体内</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">15.Dm: Method invokes System.exit(...)(DM_EXIT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在方法中调用</span><span style="color:#000000;">System.exit(...)</span><span style="color:#000000;">语句，考虑用</span><span style="color:#000000;">RuntimeException</span><span style="color:#000000;">来代替</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">16.Dm: Method invokes dangerous methodrunFinalizersOnExit (DM_RUN_FINALIZERS_ON_EXIT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在方法中调用了</span><span style="color:#000000;">System.runFinalizersOnExit</span><span style="color:#000000;">或者</span><span style="color:#000000;">Runtime.runFinalizersOnExit</span><span style="color:#000000;">方法，因为这样做是很危险的。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">17.ES: Comparison of String parameterusing == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">用</span><span style="color:#000000;">==</span><span style="color:#000000;">或者</span><span style="color:#000000;">!=</span><span style="color:#000000;">方法去比较</span><span style="color:#000000;">String</span><span style="color:#000000;">类型的参数</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">18.ES: Comparison of String objects using== or != (ES_COMPARING_STRINGS_WITH_EQ)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">用</span><span style="color:#000000;">==</span><span style="color:#000000;">或者！</span><span style="color:#000000;">=</span><span style="color:#000000;">去比较</span><span style="color:#000000;">String</span><span style="color:#000000;">类型的对象</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">19.Eq: Abstract class defines covariantequals() method (EQ_ABSTRACT_SELF)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">20.Eq: Equals checks for noncompatibleoperand (EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">equals</span><span style="color:#000000;">方法检查不一致的操作。两个类根本就是父子关系而去调用</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法去判读对象是否相等。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">public boolean equals(Object o) {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  if (o instanceof Foo)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    returnname.equals(((Foo)o).name);</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  else if (o instanceof String)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    return name.equals(o);</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  else return false;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">21.Eq: Class defines compareTo(...) anduses Object.equals() (EQ_COMPARETO_USE_OBJECT_EQUALS)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类中定义了</span><span style="color:#000000;">compareTo</span><span style="color:#000000;">方法但是继承了</span><span style="color:#000000;">Object</span><span style="color:#000000;">中的</span><span style="color:#000000;">compareTo</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">22.Eq: equals method fails for subtypes(EQ_GETCLASS_AND_CLASS_CONSTANT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类中的</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法可能被子类中的方法所破坏，当使用类似于</span><span style="color:#000000;">Foo.class == o.getClass()</span><span style="color:#000000;">的判断时考虑用</span><span style="color:#000000;">this.getClass() == o.getClass()</span><span style="color:#000000;">来替换</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">23.Eq: Covariant equals() method defined(EQ_SELF_NO_OBJECT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类中定义了多个</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法。正确的做法是覆写</span><span style="color:#000000;">Object</span><span style="color:#000000;">中的</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法，它的参数为</span><span style="color:#000000;">Object</span><span style="color:#000000;">类型的对象。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">24.FI: Empty finalizer should be deleted(FI_EMPTY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">为空的</span><span style="color:#000000;">finalizer</span><span style="color:#000000;">方法应该删除。一下关于</span><span style="color:#000000;">finalizer</span><span style="color:#000000;">的内容省略</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">25.GC: Unchecked type in generic call(GC_UNCHECKED_TYPE_IN_GENERIC_CALL)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">This call to a generic collection methodpasses an argument while compile type Object where a specific type from thegeneric type parameters is expected. Thus, neither the standard Java typesystem nor static analysis can provide useful information on whether the objectbeing passed as a parameter is of an appropriate type.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">26.HE: Class defines equals() but nothashCode() (HE_EQUALS_NO_HASHCODE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">方法定义了</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法却没有定义</span><span style="color:#000000;">hashCode</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">27.HE: Class defines hashCode() but notequals() (HE_HASHCODE_NO_EQUALS)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;"> </span><span style="color:#000000;">类定义了</span><span style="color:#000000;">hashCode</span><span style="color:#000000;">方法去没有定义</span><span style="color:#000000;">equal</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">28.HE: Class defines equals() and usesObject.hashCode() (HE_EQUALS_USE_HASHCODE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一个类覆写了</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法，没有覆写</span><span style="color:#000000;">hashCode</span><span style="color:#000000;">方法，使用了</span><span style="color:#000000;">Object</span><span style="color:#000000;">对象的</span><span style="color:#000000;">hashCode</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">29.HE: Class inherits equals() and usesObject.hashCode() (HE_INHERITS_EQUALS_USE_HASHCODE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">子类继承了父类的</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法却使用了</span><span style="color:#000000;">Object</span><span style="color:#000000;">的</span><span style="color:#000000;">hashCode</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">30.IC: Superclass uses subclass duringinitialization (IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">子类在父类未初始化之前使用父类对象实例</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">public class CircularClassInitialization {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        staticclass InnerClassSingleton extends CircularClassInitialization {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">static InnerClassSingleton singleton = newInnerClassSingleton();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        }       </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        staticCircularClassInitialization foo = InnerClassSingleton.singleton;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">}</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">31.IMSE: Dubious catching ofIllegalMonitorStateException (IMSE_DONT_CATCH_IMSE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">捕捉违法的监控状态异常，例如当没有获取到对象锁时使用其</span><span style="color:#000000;">wait</span><span style="color:#000000;">和</span><span style="color:#000000;">notify</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">32.ISC: Needless instantiation of classthat only supplies static methods (ISC_INSTANTIATE_STATIC_CLASS)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">为使用静态方法而创建一个实例对象。调用静态方法时只需要使用类名</span><span style="color:#000000;">+</span><span style="color:#000000;">静态方法名就可以了。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">33.It: Iterator next() method can't throwNoSuchElementException (IT_NO_SUCH_ELEMENT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">迭代器的</span><span style="color:#000000;">next</span><span style="color:#000000;">方法不能够抛出</span><span style="color:#000000;">NoSuchElementException</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">34.J2EE: Store of non serializable objectinto HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在</span><span style="color:#000000;">HttpSession</span><span style="color:#000000;">对象中保存非连续的对象</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">35.JCIP: Fields of immutable classesshould be final (JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> The class is annotated withnet.jcip.annotations.Immutable, and the rules for that annotation require thatall fields are final. .</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">36.NP: Method with Boolean return typereturns explicit null (NP_BOOLEAN_RETURN_NULL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">返回值为</span><span style="color:#000000;">boolean</span><span style="color:#000000;">类型的方法直接返回</span><span style="color:#000000;">null</span><span style="color:#000000;">，这样会导致空指针异常</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">37.NP: equals() method does not check fornull argument (NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">变量调用</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法时没有进行是否为</span><span style="color:#000000;">null</span><span style="color:#000000;">的判断</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">38.NP: toString method may return null(NP_TOSTRING_COULD_RETURN_NULL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">toString</span><span style="color:#000000;">方法可能返回</span><span style="color:#000000;">null</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">39.Nm: Class names should start with anupper case letter (NM_CLASS_NAMING_CONVENTION)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">类的名称以大写字母名称开头</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">40.Nm: Class is not derived from anException, even though it is named as such (NM_CLASS_NOT_EXCEPTION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类的名称中含有</span><span style="color:#000000;">Exception</span><span style="color:#000000;">但是却不是一个异常类的子类，这种名称会造成混淆</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">41.Nm: Confusing method names(NM_CONFUSING)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">令人迷惑的方面命名</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">42.Nm: Field names should start with alower case letter (NM_FIELD_NAMING_CONVENTION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">非</span><span style="color:#000000;">final</span><span style="color:#000000;">类型的字段需要遵循驼峰命名原则</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">43.Nm: Use of identifier that is a keywordin later versions of Java (NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">验证是否是</span><span style="color:#000000;">java</span><span style="color:#000000;">预留关键字</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">44.Nm: Use of identifier that is a keywordin later versions of Java (NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">验证是否时</span><span style="color:#000000;">java</span><span style="color:#000000;">中的关键字</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">45.Nm: Method names should start with alower case letter (NM_METHOD_NAMING_CONVENTION)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法名称以小写字母开头</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">46.Nm: Class names shouldn't shadow simplename of implemented interface (NM_SAME_SIMPLE_NAME_AS_INTERFACE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">实现同一接口实现类不能使用相同的名称，即使它们位于不同的包中</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">47.Nm: Class names shouldn't shadow simplename of superclass (NM_SAME_SIMPLE_NAME_AS_SUPERCLASS)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">继承同一父类的子类不能使用相同的名称，即使它们位于不同的包中</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">48.Nm: Very confusing method names (butperhaps intentional) (NM_VERY_CONFUSING_INTENTIONAL)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">49.Nm: Method doesn't override method insuperclass due to wrong package for parameter (NM_WRONG_PACKAGE_INTENTIONAL)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">import alpha.Foo;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">public class A {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  public int f(Foo x) { return 17; }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">}</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">import beta.Foo;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">public class B extends A {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  public int f(Foo x) { return 42; }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  public int f(alpha.Foo x) { return27; }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">}</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">50.ODR: Method may fail to close databaseresource (ODR_OPEN_DATABASE_RESOURCE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法中可能存在关闭数据连接失败的情况</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">51.OS: Method may fail to close stream(OS_OPEN_STREAM)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法中可能存在关闭流失败的情况</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">52.OS: Method may fail to close stream onexception (OS_OPEN_STREAM_EXCEPTION_PATH)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法中可能存在关闭流时出现异常情况</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">53.RC: Suspicious reference comparison toconstant (RC_REF_COMPARISON_BAD_PRACTICE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">当两者为不同类型的对象时使用</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法来比较它们的值是否相等，而不是使用</span><span style="color:#000000;">==</span><span style="color:#000000;">方法。例如比较的两者为</span><span style="color:#000000;">java.lang.Integer,java.lang.Float</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">54.RC: Suspicious reference comparison ofBoolean values (RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用</span><span style="color:#000000;">== </span><span style="color:#000000;">或者</span><span style="color:#000000;"> !=</span><span style="color:#000000;">操作符来比较两个</span><span style="color:#000000;"> Boolean</span><span style="color:#000000;">类型的对象，建议使用</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">55.RR: Method ignores results ofInputStream.read() (RR_NOT_CHECKED)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">InputStream.read</span><span style="color:#000000;">方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">56.RR: Method ignores results ofInputStream.skip() (SR_NOT_CHECKED)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">InputStream.skip()</span><span style="color:#000000;">方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户跳过少量字符请求的情况</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">57.RV: Method ignores exceptional returnvalue (RV_RETURN_VALUE_IGNORED_BAD_PRACTICE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法忽略返回值的异常信息</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">58.SI: Static initializer creates instancebefore all static final fields assigned (SI_INSTANCE_BEFORE_FINALS_ASSIGNED)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在所有的</span><span style="color:#000000;">static final</span><span style="color:#000000;">字段赋值之前去使用静态初始化的方法创建一个类的实例。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">59.Se: Non-serializable value stored intoinstance field of a serializable class (SE_BAD_FIELD_STORE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">非序列化的值保存在声明为序列化的的非序列化字段中</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">60.Se: Comparator doesn't implementSerializable (SE_COMPARATOR_SHOULD_BE_SERIALIZABLE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">Comparator</span><span style="color:#000000;">接口没有实现</span><span style="color:#000000;">Serializable</span><span style="color:#000000;">接口</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">61.Se: Serializable inner class(SE_INNER_CLASS)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">序列化内部类</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">62.Se: serialVersionUID isn't final(SE_NONFINAL_SERIALVERSIONID)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">关于</span><span style="color:#000000;">UID</span><span style="color:#000000;">类的检查内容省略</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">63.Se: Class is Serializable but itssuperclass doesn't define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">子类序列化时父类没有提供一个</span><span style="color:#000000;">void</span><span style="color:#000000;">的构造函数</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">64.Se: Class is Externalizable but doesn'tdefine a void constructor (SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">Externalizable </span><span style="color:#000000;">实例类没有定义一个</span><span style="color:#000000;">void</span><span style="color:#000000;">类型的构造函数</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">65.Se: The readResolve method must bedeclared with a return type of Object. (SE_READ_RESOLVE_MUST_RETURN_OBJECT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">readResolve</span><span style="color:#000000;">从流中读取类的一个实例，此方法必须声明返回一个</span><span style="color:#000000;">Object</span><span style="color:#000000;">类型的对象</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">66.Se: Transient field that isn't set bydeserialization. (SE_TRANSIENT_FIELD_NOT_RESTORED)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">This class contains a field that isupdated at multiple places in the class, thus it seems to be part of the stateof the class. However, since the field is marked as transient and not set inreadObject or readResolve, it will contain the default value in anydeserialized instance of the class.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">67.SnVI: Class is Serializable, butdoesn't define serialVersionUID (SE_NO_SERIALVERSIONID)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一个类实现了</span><span style="color:#000000;">Serializable</span><span style="color:#000000;">接口但是没有定义</span><span style="color:#000000;">serialVersionUID</span><span style="color:#000000;">类型的变量。序列化运行时使用一个称为</span><span style="color:#000000;"> serialVersionUID </span><span style="color:#000000;">的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的</span><span style="color:#000000;"> serialVersionUID </span><span style="color:#000000;">与对应的发送者的类的版本号不同，则反序列化将会导致</span><span style="color:#000000;"> InvalidClassException</span><span style="color:#000000;">。可序列化类可以通过声明名为</span><span style="color:#000000;"> "serialVersionUID" </span><span style="color:#000000;">的字段（该字段必须是静态</span><span style="color:#000000;"> (static)</span><span style="color:#000000;">、最终</span><span style="color:#000000;"> (final) </span><span style="color:#000000;">的</span><span style="color:#000000;"> long </span><span style="color:#000000;">型字段）显式声明其自己的</span><span style="color:#000000;"> serialVersionUID</span><span style="color:#000000;">：</span><span style="color:#000000;"> </span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> ANY-ACCESS-MODIFIER static finallong serialVersionUID = 42L;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">68.UI: Usage of GetResource may be unsafeif class is extended (UI_INHERITANCE_UNSAFE_GETRESOURCE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">当一个类被子类继承后不要使用</span><span style="color:#000000;">this.getClass().getResource(...)</span><span style="color:#000000;">来获取资源</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#000000;">四、</span><span style="color:#000000;">Correctness</span><span style="color:#000000;">关于代码正确性相关方面的</span></strong></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">1.BC: Impossible cast (BC_IMPOSSIBLE_CAST)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">不可能的类转换，执行时会抛出</span><span style="color:#000000;">ClassCastException</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">2.BC: Impossible downcast(BC_IMPOSSIBLE_DOWNCAST)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">父类在向下进行类型转换时抛出</span><span style="color:#000000;">ClassCastException</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">3.BC: Impossible downcast of toArray()result (BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">集合转换为数组元素时发生的类转换错误。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">This code is casting the result of callingtoArray() on a collection to a type more specific than Object[], as in: </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">String[]getAsArray(Collection&lt;String&gt; c) {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  return (String[]) c.toArray();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">This will usually fail by throwing aClassCastException. The toArray() of almost all collections return an Object[].They can't really do anything else, since the Collection object has noreference to the declared generic type of the collection. </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">The correct way to do get an array of aspecific type from a collection is to use c.toArray(new String[]); orc.toArray(new String[c.size()]); (the latter is slightly more efficient). </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">4.BC: instanceof will always return false(BC_IMPOSSIBLE_INSTANCEOF)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">采用</span><span style="color:#000000;">instaneof</span><span style="color:#000000;">方法进行比较时总是返回</span><span style="color:#000000;">false</span><span style="color:#000000;">。前提是保证它不是由于某些逻辑错误造成的。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">5.BIT: Incompatible bit masks (BIT_AND)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">错误的使用</span><span style="color:#000000;">&amp;</span><span style="color:#000000;">位操作符，例如</span><span style="color:#000000;">(e &amp; C)</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">6.BIT: Check to see if ((...) &amp; 0) ==0 (BIT_AND_ZZ)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">检查恒等的逻辑错误</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">7.BIT: Incompatible bit masks (BIT_IOR)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">错误的使用</span><span style="color:#000000;">|</span><span style="color:#000000;">位操作符，例如</span><span style="color:#000000;">(e | C)</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">8.BIT: Check for sign of bitwise operation(BIT_SIGNED_CHECK_HIGH_BIT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">检查逻辑运算符操作返回的标识。例如</span><span style="color:#000000;">((event.detail&amp; SWT.SELECTED) &gt; 0)</span><span style="color:#000000;">，建议采用</span><span style="color:#000000;">!=0</span><span style="color:#000000;">代替</span><span style="color:#000000;">&gt;0</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">9.BOA: Class overrides a methodimplemented in super class Adapter wrongly (BOA_BADLY_OVERRIDDEN_ADAPTER)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">子类错误的覆写父类中用于适配监听其他事件的方法，从而导致当触发条件发生时不能被监听者调用</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">10.Bx: Primitive value is unboxed andcoerced for ternary operator (BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在三元运算符操作时如果没有对值进行封装或者类型转换。例如：</span><span style="color:#000000;">b ? e1 : e2</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">11.DLS: Dead store of class literal (DLS_DEAD_STORE_OF_CLASS_LITERAL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">以类的字面名称方式为一个字段赋值后再也没有去使用它，在</span><span style="color:#000000;">1.4jdk</span><span style="color:#000000;">中它会自动调用静态的初始化方法，而在</span><span style="color:#000000;">jdk1.5</span><span style="color:#000000;">中却不会去执行。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">12.DLS: Overwritten increment(DLS_OVERWRITTEN_INCREMENT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">覆写增量增加错误</span><span style="color:#000000;">i = i++</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">13.DMI: Bad constant value for month(DMI_BAD_MONTH)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">hashNext</span><span style="color:#000000;">方法调用</span><span style="color:#000000;">next</span><span style="color:#000000;">方法。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">14.DMI: Collections should not containthemselves (DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">集合没有包含他们自己本身。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">15.DMI: Invocation of hashCode on an array(DMI_INVOKING_HASHCODE_ON_ARRAY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">数组直接使用</span><span style="color:#000000;">hashCode</span><span style="color:#000000;">方法来返回哈希码。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">int [] a1 = new int[]{1,2,3,4};</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        System.out.println(a1.hashCode());</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        System.out.println(java.util.Arrays.hashCode(a1));</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">16.DMI: Double.longBitsToDouble invoked onan int (DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">17.DMI: Vacuous call to collections(DMI_VACUOUS_SELF_COLLECTION_CALL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">集合的调用不能被感知。例如</span><span style="color:#000000;">c.containsAll(c)</span><span style="color:#000000;">总是返回</span><span style="color:#000000;">true</span><span style="color:#000000;">，而</span><span style="color:#000000;">c.retainAll(c)</span><span style="color:#000000;">的返回值不能被感知。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">18.Dm: Can't use reflection to check forpresence of annotation without runtime retention(DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">Unless an annotation has itself beenannotated with @Retention(RetentionPolicy.RUNTIME), the annotation can't beobserved using reflection (e.g., by using the isAnnotationPresent method). .</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">19.Dm: Useless/vacuous call to EasyMockmethod (DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">While ScheduledThreadPoolExecutor inheritsfrom ThreadPoolExecutor, a few of the inherited tuning methods are not usefulfor it. In particular, because it acts as a fixed-sized pool using corePoolSizethreads and an unbounded queue, adjustments to maximumPoolSize have no usefuleffect.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">20.EC: equals() used to compare array andnonarray (EC_ARRAY_AND_NONARRAY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">数组对象使用</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法和非数组对象进行比较。即使比较的双方都是数组对象也不应该使用</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法，而应该比较它们的内容是否相等使用</span><span style="color:#000000;">java.util.Arrays.equals(Object[],Object[]);</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">21.EC: equals(...) used to compareincompatible arrays (EC_INCOMPATIBLE_ARRAY_COMPARE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用</span><span style="color:#000000;">equls</span><span style="color:#000000;">方法去比较类型不相同的数组。例如：</span><span style="color:#000000;">String[] and StringBuffer[], or String[] andint[]</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">22.EC: Call to equals() with null argument(EC_NULL_ARG)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">调用</span><span style="color:#000000;">equals</span><span style="color:#000000;">的对象为</span><span style="color:#000000;">null</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">23.EC: Call to equals() comparingunrelated class and interface (EC_UNRELATED_CLASS_AND_INTERFACE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法比较不相关的类和接口</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">24.EC: Call to equals() comparingdifferent interface types (EC_UNRELATED_INTERFACES)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">调用</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法比较不同类型的接口</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">25.EC: Call to equals() comparingdifferent types (EC_UNRELATED_TYPES)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">调用</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法比较不同类型的类</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">26.EC: Using pointer equality to comparedifferent types (EC_UNRELATED_TYPES_USING_POINTER_EQUALITY)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">This method uses using pointer equality tocompare two references that seem to be of different types. The result of thiscomparison will always be false at runtime.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">27.Eq: equals method always returns false(EQ_ALWAYS_FALSE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法返回值总是</span><span style="color:#000000;">false</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">28.Eq: equals method always returns true(EQ_ALWAYS_TRUE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">equals</span><span style="color:#000000;">方法返回值总是</span><span style="color:#000000;">true</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">29.Eq: equals method compares class namesrather than class objects (EQ_COMPARING_CLASS_NAMES)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法去比较一个类的实例和类的类型</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">30.Eq: Covariant equals() method definedfor enum (EQ_DONT_DEFINE_EQUALS_FOR_ENUM)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">This class defines an enumeration, andequality on enumerations are defined using object identity. Defining acovariant equals method for an enumeration value is exceptionally bad practice,since it would likely result in having two different enumeration values thatcompare as equals using the covariant enum method, and as not equal whencompared normally. Don't do it.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">31.Eq: equals() method defined thatdoesn't override equals(Object) (EQ_OTHER_NO_OBJECT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类中定义的</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法时不要覆写</span><span style="color:#000000;">equals</span><span style="color:#000000;">（</span><span style="color:#000000;">Object</span><span style="color:#000000;">）方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">32.Eq: equals() method defined thatdoesn't override Object.equals(Object) (EQ_OTHER_USE_OBJECT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类中定义的</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法时不要覆写</span><span style="color:#000000;">Object</span><span style="color:#000000;">中的</span><span style="color:#000000;">equals</span><span style="color:#000000;">（</span><span style="color:#000000;">Object</span><span style="color:#000000;">）方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">33.Eq: equals method overrides equals insuperclass and may not be symmetric (EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">34.Eq: Covariant equals() method defined,Object.equals(Object) inherited (EQ_SELF_USE_OBJECT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类中定义了一组</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法，但是都是继承的</span><span style="color:#000000;">java.lang.Object class</span><span style="color:#000000;">中的</span><span style="color:#000000;">equals(Object)</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">35.FE: Doomed test for equality to NaN(FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">This code checks to see if a floatingpoint value is equal to the special Not A Number value (e.g., if (x ==Double.NaN)). However, because of the special semantics of NaN, no value isequal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false.To check to see if a value contained in x is the special Not A Number value,use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision).</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">36.FS: Format string placeholderincompatible with passed argument (VA_FORMAT_STRING_BAD_ARGUMENT)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">错误使用参数类型来格式化字符串</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">37.FS: The type of a supplied argumentdoesn't match format specifier (VA_FORMAT_STRING_BAD_CONVERSION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">指定的格式字符串和参数类型不匹配，例如：</span><span style="color:#000000;">String.format("%d","1")</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">38.FS: MessageFormat supplied where printfstyle format expected (VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">但用</span><span style="color:#000000;">String</span><span style="color:#000000;">的</span><span style="color:#000000;">format</span><span style="color:#000000;">方法时实际调用了ＭｅｓｓａｇｅＦｏｒｍａｔ中干的格式化方法而引起格式化结果出错。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">39.FS: More arguments are passed than areactually used in the format string (VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用</span><span style="color:#000000;">String</span><span style="color:#000000;">的</span><span style="color:#000000;">format</span><span style="color:#000000;">方法时有非法的参数也经过了格式化操作。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">40.FS: Illegal format string(VA_FORMAT_STRING_ILLEGAL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">格式化</span><span style="color:#000000;">String</span><span style="color:#000000;">对象语句错误</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">41.FS: Format string references missingargument (VA_FORMAT_STRING_MISSING_ARGUMENT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">String</span><span style="color:#000000;">的</span><span style="color:#000000;">format</span><span style="color:#000000;">操作缺少必要的参数。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">42.FS: No previous argument for formatstring (VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">格式字符串定义错误，例如：</span><span style="color:#000000;">formatter.format("%&lt;s%s", "a", "b"); </span><span style="color:#000000;">抛出</span><span style="color:#000000;">MissingFormatArgumentException</span><span style="color:#000000;">异常</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">43.GC: No relationship between genericparameter and method argument (GC_UNRELATED_TYPES)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">This call to a generic collection methodcontains an argument with an incompatible class from that of the collection'sparameter (i.e., the type of the argument is neither a supertype nor a subtypeof the corresponding generic type argument). Therefore, it is unlikely that thecollection contains any objects that are equal to the method argument usedhere. Most likely, the wrong value is being passed to the method.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">In general, instances of two unrelatedclasses are not equal. For example, if the Foo and Bar classes are not relatedby subtyping, then an instance of Foo should not be equal to an instance ofBar. Among other issues, doing so will likely result in an equals method thatis not symmetrical. For example, if you define the Foo class so that a Foo canbe equal to a String, your equals method isn't symmetrical since a String canonly be equal to a String. </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">In rare cases, people do definenonsymmetrical equals methods and still manage to make their code work.Although none of the APIs document or guarantee it, it is typically the casethat if you check if a Collection&lt;String&gt; contains a Foo, the equalsmethod of argument (e.g., the equals method of the Foo class) used to performthe equality checks. </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">44.HE: Signature declares use ofunhashable class in hashed construct(HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">A method, field or class declares ageneric signature where a non-hashable class is used in context where ahashable class is required. A class that declares an equals method but inheritsa hashCode() method from Object is unhashable, since it doesn't fulfill therequirement that equal objects have equal hashCodes.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">45.HE: Use of class without a hashCode()method in a hashed data structure (HE_USE_OF_UNHASHABLE_CLASS)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">A class defines an equals(Object) methodbut not a hashCode() method, and thus doesn't fulfill the requirement thatequal objects have equal hashCodes. An instance of this class is used in a hashdata structure, making the need to fix this problem of highest importance.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">46.ICAST: integral value cast to doubleand then passed to Math.ceil (ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">integral</span><span style="color:#000000;">的值转换为</span><span style="color:#000000;">double</span><span style="color:#000000;">后使用了</span><span style="color:#000000;">Math.ceil</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">47.ICAST: int value cast to float and thenpassed to Math.round (ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">int </span><span style="color:#000000;">类型的值转换为</span><span style="color:#000000;">float</span><span style="color:#000000;">类型之后调用了</span><span style="color:#000000;">Math.round</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">48.IJU: JUnit assertion in run method willnot be noticed by JUnit (IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在</span><span style="color:#000000;">JUnit</span><span style="color:#000000;">中的断言在</span><span style="color:#000000;">run</span><span style="color:#000000;">方法中不会被告知</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">49.IJU: TestCase declares a bad suitemethod (IJU_BAD_SUITE_METHOD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在一个</span><span style="color:#000000;">JUnit</span><span style="color:#000000;">类中声明的一个</span><span style="color:#000000;">suite()</span><span style="color:#000000;">方法必须声明为</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">public static junit.framework.Test suite()</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">或者</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">public static junit.framework.TestSuitesuite()</span><span style="color:#000000;">的形式。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">50.IL: A collection is added to itself(IL_CONTAINER_ADDED_TO_ITSELF)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">集合本身作为</span><span style="color:#000000;">add</span><span style="color:#000000;">方法的参数，这样会引起内容溢出。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">51.IL: An apparent infinite loop(IL_INFINITE_LOOP)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法的自调用引起的死循环</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">52.IM: Integer multiply of result ofinteger remainder (IM_MULTIPLYING_RESULT_OF_IREM)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">和整数余数进行乘法运算。例如：</span><span style="color:#000000;">i % 60 * 1000 </span><span style="color:#000000;">是进行</span><span style="color:#000000;">(i % 60) * 1000</span><span style="color:#000000;">运算而不是</span><span style="color:#000000;"> i % (60 * 1000)</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">53.INT: Bad comparison of nonnegativevalue with negative constant (INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">保证非负数和负数进行比较</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">54.INT: Bad comparison of signed byte(INT_BAD_COMPARISON_WITH_SIGNED_BYTE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">比较有符合数，要先把有符号数转换为无符合数再进行比较</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">55.IO: Doomed attempt to append to anobject output stream (IO_APPENDING_TO_OBJECT_OUTPUT_STREAM)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">宣布试图在对象的输出流处添加元素，如果你希望能够添加进一个对象的输出流中必须保证对象的输出流处于打开状态。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">56.IP: A parameter is dead upon entry to amethod but overwritten (IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">The initial value of this parameter isignored, and the parameter is overwritten here. This often indicates a mistakenbelief that the write to the parameter will be conveyed back to the caller.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">传入参数的值被忽略，但是对传入值进行了修改，并返回给了调用者</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">57.MF: Class defines field that masks asuperclass field (MF_CLASS_MASKS_FIELD)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">子类中定义了和父类中同名的字段。在调用时会出错</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">58.MF: Method defines a variable thatobscures a field (MF_METHOD_MASKS_FIELD)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">在方法中定义的局部变量和类变量或者父类变量同名，从而引起字段混淆。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">59.NP: Null pointer dereference(NP_ALWAYS_NULL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">对象赋为</span><span style="color:#000000;">null</span><span style="color:#000000;">值后</span><span style="color:#000000;">没有被重新赋值</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">60.NP: Null pointer dereference in methodon exception path (NP_ALWAYS_NULL_EXCEPTION)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">A pointer which is null on an exceptionpath is dereferenced here.  This will lead to a NullPointerException whenthe code is executed.  Note that because FindBugs currently does not pruneinfeasible exception paths, this may be a false warning.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">Also note that FindBugs considers thedefault case of a switch statement to be an exception path, since the defaultcase is often infeasible.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">空指针引用上调用去除引用方法，将发生空指针异常</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">61.NP: Method does not check for nullargument (NP_ARGUMENT_MIGHT_BE_NULL)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法没有判断参数是否为空</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">62.NP: close() invoked on a value that isalways null (NP_CLOSING_NULL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一个为空的对象调用</span><span style="color:#000000;">close</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">63.NP: Null value is guaranteed to bedereferenced (NP_GUARANTEED_DEREF)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">There is a statement or branch that ifexecuted guarantees that a value is null at this point, and that value that isguaranteed to be dereferenced (except on forward paths involving runtimeexceptions).</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在正常的</span><span style="color:#000000;">null</span><span style="color:#000000;">判断分支上，对象去除引用操作是受保护的不允许的</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">64.NP: Value is null and guaranteed to bedereferenced on exception path (NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">There is a statement or branch on anexception path that if executed guarantees that a value is null at this point,and that value that is guaranteed to be dereferenced (except on forward pathsinvolving runtime exceptions).</span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> </span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">65.NP: Method call passes null to anonnull parameter (NP_NONNULL_PARAM_VIOLATION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">方法中为</span><span style="color:#000000;">null</span><span style="color:#000000;">的参数没有被重新赋值</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        voidtest(){<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">String ss = null;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">sya(ss);</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        }       </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        publicvoid sya(String ad){<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">ad.getBytes();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">66.NP: Method may return null, but isdeclared @NonNull (NP_NONNULL_RETURN_VIOLATION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">方法声明了返回值不能为空，但是方法中有可能返回</span><span style="color:#000000;">null</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">67.NP: A known null value is checked tosee if it is an instance of a type (NP_NULL_INSTANCEOF)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">检查一个为</span><span style="color:#000000;">null</span><span style="color:#000000;">的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">68.NP: Possible null pointer dereference(NP_NULL_ON_SOME_PATH)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">对象可能没有重新赋值</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">69.NP: Possible null pointer dereferencein method on exception path (NP_NULL_ON_SOME_PATH_EXCEPTION)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">A reference value which is null on someexception control path is dereferenced here.  This may lead to aNullPointerException when the code is executed.  Note that becauseFindBugs currently does not prune infeasible exception paths, this may be afalse warning.</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">Also note that FindBugs considers thedefault case of a switch statement to be an exception path, since the defaultcase is often infeasible.</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在异常</span><span style="color:#000000;">null</span><span style="color:#000000;">值处理分支调用的方法上，可能存在对象去除引用操作</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">70.NP: Method call passes null for nonnullparameter (NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">方法参数中声明为</span><span style="color:#000000;">nonnull</span><span style="color:#000000;">类型的参数为</span><span style="color:#000000;">null</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">void test(){<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">String ss = null;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">sya(ss);</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        }       </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        publicvoid sya(@nonnull String ad){<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">ad.getBytes();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">71.NP: Store of null value into fieldannotated NonNull (NP_STORE_INTO_NONNULL_FIELD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">为一个已经声明为不能为</span><span style="color:#000000;">null</span><span style="color:#000000;">值的属性赋值为</span><span style="color:#000000;">null</span><span style="color:#000000;">。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">72.Nm: Class defines equal(Object); shouldit be equals(Object)? (NM_BAD_EQUAL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类中定义了一个</span><span style="color:#000000;">equal</span><span style="color:#000000;">方法但是却不是覆写的</span><span style="color:#000000;">Object</span><span style="color:#000000;">对象的</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">73.Nm: Class defines hashcode(); should itbe hashCode()? (NM_LCASE_HASHCODE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类中定义了一个</span><span style="color:#000000;">hashCode</span><span style="color:#000000;">方法但是却不是覆写的</span><span style="color:#000000;">Object</span><span style="color:#000000;">中的</span><span style="color:#000000;">hashCode</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">74.Nm: Class defines tostring(); should itbe toString()? (NM_LCASE_TOSTRING)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类中定义了一个</span><span style="color:#000000;">toString</span><span style="color:#000000;">方法但是却不是覆写的</span><span style="color:#000000;">Object</span><span style="color:#000000;">中的</span><span style="color:#000000;">toString</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">75.Nm: Apparent method/constructorconfusion (NM_METHOD_CONSTRUCTOR_CONFUSION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">构造方法定义混乱，保证一个标准的构造函数。</span><span style="color:#000000;">例如：</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        SA(){   }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        voidSA(){<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">76.Nm: Very confusing method names (NM_VERY_CONFUSING)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">混乱的方法命名，如</span><span style="color:#000000;">getName</span><span style="color:#000000;">和</span><span style="color:#000000;">getname</span><span style="color:#000000;">方法同时出现的时候</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">77.Nm: Method doesn't override method insuperclass due to wrong package for parameter (NM_WRONG_PACKAGE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法因为取了不同包中的同名的对象而没有正确覆写父类中的同名方法</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">import alpha.Foo;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">public class A {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  public int f(Foo x) { return 17; }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">}</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">----</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">import beta.Foo;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">public class B extends A {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  public int f(Foo x) { return 42; }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">}</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">78.QBA: Method assigns boolean literal inboolean expression (QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">再</span><span style="color:#000000;">if</span><span style="color:#000000;">或者</span><span style="color:#000000;">while</span><span style="color:#000000;">表达式中使用</span><span style="color:#000000;">boolean</span><span style="color:#000000;">类型的值时应该使用</span><span style="color:#000000;">==</span><span style="color:#000000;">去判断，而不是采用</span><span style="color:#000000;">=</span><span style="color:#000000;">操作</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">79.RC: Suspicious reference comparison(RC_REF_COMPARISON)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">比较两个对象值是否相等时应该采用</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法，而不是</span><span style="color:#000000;">==</span><span style="color:#000000;">方法</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">80.RE: Invalid syntax for regularexpression (RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">对正则表达式使用了错误的语法，会抛出未经检查的异常，表明正则表达式模式中的语法错误。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">81.RE: File.separator used for regularexpression (RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用正则表达式使用了错误的文件分隔符，在</span><span style="color:#000000;">windows</span><span style="color:#000000;">系统中正则表达式不会匹配</span><span style="color:#000000;">’\’</span><span style="color:#000000;">而应该使用</span><span style="color:#000000;">'\\'</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">82.RV: Random value from 0 to 1 is coercedto the integer 0 (RV_01_TO_INT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">从</span><span style="color:#000000;">0</span><span style="color:#000000;">到</span><span style="color:#000000;">1</span><span style="color:#000000;">随机值被强制为整数值</span><span style="color:#000000;">0</span><span style="color:#000000;">。在强制得到一个整数之前，你可能想得到多个随机值。或使用</span><span style="color:#000000;">Random.nextInt</span><span style="color:#000000;">（</span><span style="color:#000000;">n</span><span style="color:#000000;">）的方法。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">83.RV: Bad attempt to compute absolutevalue of signed 32-bit hashcode (RV_ABSOLUTE_VALUE_OF_HASHCODE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是</span><span style="color:#000000;">Integer.MIN_VALUE</span><span style="color:#000000;">的，那么结果将是负数（因为</span><span style="color:#000000;">Math.abs</span><span style="color:#000000;">（</span><span style="color:#000000;">Integer.MIN_VALUE</span><span style="color:#000000;">的）</span><span style="color:#000000;">== Integer.MIN_VALUE</span><span style="color:#000000;">的）。</span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在</span><span style="color:#000000;">2^ 32</span><span style="color:#000000;">值之外字符串有一个</span><span style="color:#000000;">Integer.MIN_VALUE</span><span style="color:#000000;">的</span><span style="color:#000000;">hashCode</span><span style="color:#000000;">包括</span><span style="color:#000000;">“polygenelubricants”</span><span style="color:#000000;">，</span><span style="color:#000000;">“GydZG_”</span><span style="color:#000000;">和</span><span style="color:#000000;">“</span><span style="color:#000000;">，</span><span style="color:#000000;">”DESIGNING WORKHOUSES “</span><span style="color:#000000;">。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">84.RV: Bad attempt to compute absolutevalue of signed 32-bit random integer (RV_ABSOLUTE_VALUE_OF_RANDOM_INT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此代码生成一个随机的符号整数，然后计算该随机整数的绝对值。如果随机数生成数绝对值为</span><span style="color:#000000;">Integer.MIN_VALUE</span><span style="color:#000000;">的，那么结果将是负数（因为</span><span style="color:#000000;">Math.abs</span><span style="color:#000000;">（</span><span style="color:#000000;">Integer.MIN_VALUE</span><span style="color:#000000;">的）</span><span style="color:#000000;">== Integer.MIN_VALUE</span><span style="color:#000000;">的）。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">85.RV: Exception created and droppedrather than thrown (RV_EXCEPTION_NOT_THROWN)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此代码创建一个异常（或错误）的对象，但不会用它做任何事情。例如：</span><span style="color:#000000;">if (x &lt; 0)</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  newIllegalArgumentException("x must be nonnegative");</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">这可能是程序员的意图抛出创建的异常：</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">if (x &lt; 0)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  throw new IllegalArgumentException("xmust be nonnegative");</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">86.RV: Method ignores return value(RV_RETURN_VALUE_IGNORED)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">该方法的返回值应该进行检查。这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。例如：</span><span style="color:#000000;">String dateString= getHeaderField(name);</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">dateString.trim();</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">程序员似乎以为</span><span style="color:#000000;">trim</span><span style="color:#000000;">（）方法将更新</span><span style="color:#000000;">dateString</span><span style="color:#000000;">引用的字符串。但由于字符串是不可改变的，</span><span style="color:#000000;">trim</span><span style="color:#000000;">（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正：</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">String dateString = getHeaderField(name);</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">dateString = dateString.trim();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">87.RpC: Repeated conditional tests(RpC_REPEATED_CONDITIONAL_TEST)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">该代码包含对同一个条件试验了两次，两边完全一样例如：（如</span><span style="color:#000000;">X == 0 | | x == 0</span><span style="color:#000000;">）。可能第二次出现是打算判断别的不同条件（如</span><span style="color:#000000;">X == 0 | | y== 0</span><span style="color:#000000;">）。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">88.SA: Double assignment of field(SA_FIELD_DOUBLE_ASSIGNMENT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">方法中的字段包含了双重任务，例如：</span><span style="color:#000000;"> </span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> int x;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  public void foo() {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">   x = x = 17;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">这种为变量赋值是无用的，并可能表明一个逻辑错误或拼写错误。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">89.SA: Self assignment of field(SA_FIELD_SELF_ASSIGNMENT)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法中包含自己对自己赋值的字段。例如：</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">int x;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  public void foo() {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    x = x;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">90.SA: Self comparison of field withitself (SA_FIELD_SELF_COMPARISON)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">字段自己进行自比较可能表明错误或逻辑错误。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">91.SA: Self comparison of value withitself (SA_LOCAL_SELF_COMPARISON)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">92.SA: Nonsensical self computationinvolving a variable (e.g., x &amp; x) (SA_LOCAL_SELF_COMPUTATION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此方法对同一变量执行了荒谬的计算（如</span><span style="color:#000000;">x&amp;x</span><span style="color:#000000;">或</span><span style="color:#000000;">x-x</span><span style="color:#000000;">）操作。由于计算的性质，这一行动似乎没有意义，并可能表明错误或逻辑错误。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">93.SF: Dead store due to switch statementfall through (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在</span><span style="color:#000000;">swtich</span><span style="color:#000000;">中先前的</span><span style="color:#000000;">case</span><span style="color:#000000;">值因为</span><span style="color:#000000;">swtich</span><span style="color:#000000;">执行失败而被覆写，这就像是忘记使用</span><span style="color:#000000;">break</span><span style="color:#000000;">推出或者没有使用</span><span style="color:#000000;">return</span><span style="color:#000000;">语句放回先前的值一样。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">94.SF: Dead store due to switch statementfall through to throw (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在</span><span style="color:#000000;">swtich</span><span style="color:#000000;">中因为出现异常而忽略了对</span><span style="color:#000000;">case</span><span style="color:#000000;">值的保存。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">95.SIC: Deadly embrace of non-static innerclass and thread local (SIC_THREADLOCAL_DEADLY_EMBRACE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">如果是一个静态内部类。实际上，在内部类和当前线程有死锁的可能。由于内部类不是静态的，它保留了对外部类的引用。如果线程包含对一个内部类实例的引用，那么内外实例的实例都可以被获取，这样就不具备垃圾会回收的资格。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">96.SIO: Unnecessary type check done usinginstanceof operator (SIO_SUPERFLUOUS_INSTANCEOF)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在进行</span><span style="color:#000000;">instanceof</span><span style="color:#000000;">操作时进行没有必要的类型检查</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">97.STI: Unneeded use of currentThread()call, to call interrupted() (STI_INTERRUPTED_ON_CURRENTTHREAD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此方法调用</span><span style="color:#000000;">Thread.currentThread</span><span style="color:#000000;">（）调用，只需调用</span><span style="color:#000000;">interrupted</span><span style="color:#000000;">（）方法。由于</span><span style="color:#000000;">interrupted</span><span style="color:#000000;">（）是一个静态方法，</span><span style="color:#000000;"> Thread.interrupted</span><span style="color:#000000;">（）更简单易用。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">98.STI: Static Thread.interrupted() methodinvoked on thread instance (STI_INTERRUPTED_ON_UNKNOWNTHREAD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">调用不是当前线程对象的</span><span style="color:#000000;">Thread.interrupted()</span><span style="color:#000000;">方法，由于</span><span style="color:#000000;">interrupted</span><span style="color:#000000;">（）方法是静态的，</span><span style="color:#000000;">interrupted</span><span style="color:#000000;">方法将会调用一个和作者原计划不同的对象。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">99.Se: Method must be private in order forserialization to work (SE_METHOD_MUST_BE_PRIVATE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">这个类实现了</span><span style="color:#000000;">Serializable</span><span style="color:#000000;">接口，并定义自定义序列化的方法</span><span style="color:#000000;">/</span><span style="color:#000000;">反序列化。但由于这种方法不能声明为</span><span style="color:#000000;">private</span><span style="color:#000000;">，将被序列化</span><span style="color:#000000;">/</span><span style="color:#000000;">反序列化的</span><span style="color:#000000;">API</span><span style="color:#000000;">忽略掉。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">100.Se: The readResolve method must not bedeclared as a static method. (SE_READ_RESOLVE_IS_STATIC)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">为使</span><span style="color:#000000;">readResolve</span><span style="color:#000000;">方法得到序列化机制的识别，不能作为一个静态方法来声明。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">101.UMAC: Uncallable method defined inanonymous class (UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">在匿名类中定义了一个既没有覆写超类中方法也不能直接调用的方法。因为在其他类的方法不能直接引用匿名类声明的方法，似乎这种方法不能被调用，这种方法可能只是没有任何作用的代码，但也可能覆写超类中声明。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">102.UR: Uninitialized read of field inconstructor (UR_UNINIT_READ)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">此构造方法中使用了一个尚未赋值的字段或属性。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        Stringa;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        publicSA() {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">String abc = a;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">System.out.println(abc);</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">103.UR: Uninitialized read of field methodcalled from constructor of superclass(UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如：</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">abstract class A {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  int hashCode;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  abstract Object getValue();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  A() {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    hashCode =getValue().hashCode();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">class B extends A {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  Object value;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  B(Object v) {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    this.value = v;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  Object getValue() {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    return value;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  }</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">当</span><span style="color:#000000;">B</span><span style="color:#000000;">是创建时，</span><span style="color:#000000;">A</span><span style="color:#000000;">的构造函数将在</span><span style="color:#000000;">B</span><span style="color:#000000;">为</span><span style="color:#000000;">value</span><span style="color:#000000;">赋值之前触发，然而在</span><span style="color:#000000;">A</span><span style="color:#000000;">的初始化方法调用</span><span style="color:#000000;">getValue</span><span style="color:#000000;">方法时</span><span style="color:#000000;">value</span><span style="color:#000000;">这个变量还没有被初始化。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">104.USELESS_STRING: Invocation of toStringon an array (DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">该代码调用上匿名数组的</span><span style="color:#000000;">toString</span><span style="color:#000000;">（）方法，产生的结果形如</span><span style="color:#000000;">[@ 16f0472</span><span style="color:#000000;">并没有实际的意义。考虑使用</span><span style="color:#000000;">Arrays.toString</span><span style="color:#000000;">方法来转换成可读的字符串，提供该数组的内容数组。例如：</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">String[] a = { "a" };</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">System.out.println(a.toString());</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">//</span><span style="color:#000000;">正确的使用为</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">System.out.println(Arrays.toString(a));</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">105.USELESS_STRING: Invocation of toStringon an array (DMI_INVOKING_TOSTRING_ON_ARRAY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">该代码调用上数组的</span><span style="color:#000000;">toString</span><span style="color:#000000;">（）方法，产生的结果形如</span><span style="color:#000000;">[@ 16f0472</span><span style="color:#000000;">并不能显示数组的真实内容。考虑使用</span><span style="color:#000000;">Arrays.toString</span><span style="color:#000000;">方法来转换成可读的字符串，提供该数组的内容数组</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">106.UwF: Field only ever set to null(UWF_NULL_FIELD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">字段的值总是为</span><span style="color:#000000;">null</span><span style="color:#000000;">值，所有读取该字段的值都为</span><span style="color:#000000;">null</span><span style="color:#000000;">。检查错误，如果它确实没有用就删除掉。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">107.UwF: Unwritten field(UWF_UNWRITTEN_FIELD</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">此字段是永远不会写入值。所有读取将返回默认值。检查错误（如果它被初始化？），如果它确实没有用就删除掉。</span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#000000;">五：</span><span style="color:#000000;">Performance</span><span style="color:#000000;">关于代码性能相关方面的</span></strong></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">1.Bx: Primitive value is boxed and thenimmediately unboxed (BX_BOXING_IMMEDIATELY_UNBOXED)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">对原始值进行装箱，然后立即取消装箱。这可能是在一个未要求装箱的地方进行了手动装箱，从而迫使编译器进行立即撤消装箱的操作</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">2.Bx: Primitive value is boxed thenunboxed to perform primitive coercion(BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如：</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">new Double(d).intValue()</span><span style="color:#000000;">应该直接进行强制转换例如：</span><span style="color:#000000;">(int) d</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">3.Bx: Method allocates a boxed primitivejust to call toString (DM_BOXED_PRIMITIVE_TOSTRING)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">仅仅为了调用封装类的</span><span style="color:#000000;">toString()</span><span style="color:#000000;">而对原始类型进行封装操作。比这种方法更有效的是调用封装类的</span><span style="color:#000000;">toString(…)</span><span style="color:#000000;">方法例如：</span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">new Integer(1).toString()    </span><span style="color:#000000;">替换为</span><span style="color:#000000;">   Integer.toString(1)</span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">new Long(1).toString()    </span><span style="color:#000000;">替换为</span><span style="color:#000000;">   Long.toString(1) </span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">new Float(1.0).toString()    </span><span style="color:#000000;">替换为</span><span style="color:#000000;">   Float.toString(1.0) </span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">new Double(1.0).toString()    </span><span style="color:#000000;">替换为</span><span style="color:#000000;">   Double.toString(1.0) </span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">new Byte(1).toString()    </span><span style="color:#000000;">替换为</span><span style="color:#000000;">   Byte.toString(1) </span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">new Short(1).toString()    </span><span style="color:#000000;">替换为</span><span style="color:#000000;">   Short.toString(1) </span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">new Boolean(true).toString()    </span><span style="color:#000000;">替换为</span><span style="color:#000000;">   Boolean.toString(true)</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">4.Bx: Method invokes inefficientfloating-point Number constructor; use static valueOf instead(DM_FP_NUMBER_CTOR)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用</span><span style="color:#000000;">new Double(double)</span><span style="color:#000000;">方法总是会创建一个新的对象，然而使用</span><span style="color:#000000;">Double.valueOf(double)</span><span style="color:#000000;">方法可以把值保存在编辑器或者</span><span style="color:#000000;">class library</span><span style="color:#000000;">、</span><span style="color:#000000;">JVM</span><span style="color:#000000;">中。使用存储值的方式来避免对象的分配可以或得更好的代码性能</span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">除非类必须符合</span><span style="color:#000000;">Java 1.5</span><span style="color:#000000;">以前的</span><span style="color:#000000;">JVM</span><span style="color:#000000;">，否则请使用自动装箱或</span><span style="color:#000000;">valueOf</span><span style="color:#000000;">（）方法创建</span><span style="color:#000000;">Double</span><span style="color:#000000;">和</span><span style="color:#000000;">Float</span><span style="color:#000000;">实例。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">5.Bx: Method invokes inefficient Numberconstructor; use static valueOf instead (DM_NUMBER_CTOR)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用</span><span style="color:#000000;">new Integer(int)</span><span style="color:#000000;">方法总是会创建一个新的对象，然而使用</span><span style="color:#000000;">Integer.valueOf(int)</span><span style="color:#000000;">方法可以把值保存在编辑器或者</span><span style="color:#000000;">class library</span><span style="color:#000000;">、</span><span style="color:#000000;">JVM</span><span style="color:#000000;">中。使用存储值的方式来避免对象的分配可以或得更好的代码性能</span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">除非类必须符合</span><span style="color:#000000;">Java 1.5</span><span style="color:#000000;">以前的</span><span style="color:#000000;">JVM</span><span style="color:#000000;">，否则请使用自动装箱或</span><span style="color:#000000;">valueOf</span><span style="color:#000000;">（）方法创建</span><span style="color:#000000;">Long, Integer, Short, Character, Byte</span><span style="color:#000000;">实例。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">6.Dm: The equals and hashCode methods ofURL are blocking (DMI_BLOCKING_METHODS_ON_URL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用</span><span style="color:#000000;">equals</span><span style="color:#000000;">和</span><span style="color:#000000;">hashCode</span><span style="color:#000000;">方法来对</span><span style="color:#000000;">url</span><span style="color:#000000;">进行资源标识符解析时会引起堵塞。考虑使用</span><span style="color:#000000;">java.net.URI</span><span style="color:#000000;">来代替。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">7.Dm: Maps and sets of URLs can beperformance hogs (DMI_COLLECTION_OF_URLS)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">方法或者字段使用</span><span style="color:#000000;">url</span><span style="color:#000000;">的</span><span style="color:#000000;">map/set</span><span style="color:#000000;">集合。因为</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法或者</span><span style="color:#000000;">hashCode</span><span style="color:#000000;">方法来进行资源标识符解析时都会引起堵塞。考虑使用</span><span style="color:#000000;">java.net.URI</span><span style="color:#000000;">来代替。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">8.Dm: Method invokes inefficient Booleanconstructor; use Boolean.valueOf(...) instead (DM_BOOLEAN_CTOR)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用</span><span style="color:#000000;">new</span><span style="color:#000000;">方法创建一个</span><span style="color:#000000;">java.lang.Boolean</span><span style="color:#000000;">类型能够的实例对象是浪费空间的，因为</span><span style="color:#000000;">Boolean</span><span style="color:#000000;">对象是不可变的而且只有两个有用的值。使用</span><span style="color:#000000;">Boolean.valueOf()</span><span style="color:#000000;">或者</span><span style="color:#000000;">Java1.5</span><span style="color:#000000;">中的自动装箱功能来创建一个</span><span style="color:#000000;">Boolean</span><span style="color:#000000;">实例。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">9.Dm: Explicit garbage collection;extremely dubious except in benchmarking code (DM_GC)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者</span><span style="color:#000000;">finalize</span><span style="color:#000000;">方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">10.Dm: Use the nextInt method of Randomrather than nextDouble to generate a random integer (DM_NEXTINT_VIA_NEXTDOUBLE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;"> </span><span style="color:#000000;">如果</span><span style="color:#000000;">r</span><span style="color:#000000;">是一个</span><span style="color:#000000;">java.util.Random</span><span style="color:#000000;">对象，你可以使</span><span style="color:#000000;">r.nextInt(n)</span><span style="color:#000000;">生成一个</span><span style="color:#000000;">0</span><span style="color:#000000;">到</span><span style="color:#000000;">n-1</span><span style="color:#000000;">之前的随机数，而不是使用</span><span style="color:#000000;">(int)(r.nextDouble() * n)</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">11.Dm: Method invokes inefficient newString(String) constructor (DM_STRING_CTOR)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用</span><span style="color:#000000;">java.lang.String(String)</span><span style="color:#000000;">构造函数会浪费内存因为这种构造方式和</span><span style="color:#000000;">String</span><span style="color:#000000;">作为参数在功能上容易混乱。只是使用</span><span style="color:#000000;">String</span><span style="color:#000000;">直接作为参数的形式</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">12.Dm: Method invokes toString() method ona String (DM_STRING_TOSTRING)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">调用</span><span style="color:#000000;">String.toString()</span><span style="color:#000000;">是多余的操作，只要使用</span><span style="color:#000000;">String</span><span style="color:#000000;">就可以了。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">13.Dm: Method invokes inefficient newString() constructor (DM_STRING_VOID_CTOR)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用没有参数的构造方法去创建新的</span><span style="color:#000000;">String</span><span style="color:#000000;">对象是浪费内存空间的，因为这样创建会和空字符串</span><span style="color:#000000;">“”</span><span style="color:#000000;">混淆。</span><span style="color:#000000;">Java</span><span style="color:#000000;">中保证完成相同的构造方法会产生描绘相同的</span><span style="color:#000000;">String</span><span style="color:#000000;">对象。所以你只要使用空字符串来创建就可以了。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">14.ITA: Method uses toArray() withzero-length array argument (ITA_INEFFICIENT_TO_ARRAY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">当使用集合的</span><span style="color:#000000;">toArray()</span><span style="color:#000000;">方法时使用数组长度为</span><span style="color:#000000;">0</span><span style="color:#000000;">的数组作为参数。比这更有效的一种方法是</span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">myCollection.toArray(newFoo[myCollection.size()])</span><span style="color:#000000;">，如果数组的长度足够大就可以直接把集合中的内容包装到数组中直接返回从而避免了第二次创建一个新的数组来存放集合中值。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">15.SBSC: Method concatenates strings using+ in a loop (SBSC_USE_STRINGBUFFER_CONCATENATION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在循环中构建一个</span><span style="color:#000000;">String</span><span style="color:#000000;">对象时从性能上讲使用</span><span style="color:#000000;">StringBuffer</span><span style="color:#000000;">来代替</span><span style="color:#000000;">String</span><span style="color:#000000;">对象</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">例如：</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">// This is bad</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  String s = "";</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  for (int i = 0; i &lt;field.length; ++i) {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    s = s + field[i];</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> </span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  // This is better</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  StringBuffer buf = newStringBuffer();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  for (int i = 0; i &lt;field.length; ++i) {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    buf.append(field[i]);</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  String s = buf.toString();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">16.SS: Unread field: should this field bestatic? (SS_SHOULD_BE_STATIC)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类中所包含的</span><span style="color:#000000;">final</span><span style="color:#000000;">属性字段在编译器中初始化为静态的值。考虑在定义时就把它定义为</span><span style="color:#000000;">static</span><span style="color:#000000;">类型的。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">17.UM: Method calls static Math classmethod on a constant value (UM_UNNECESSARY_MATH)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在方法中使用了</span><span style="color:#000000;">java.lang.Math</span><span style="color:#000000;">的静态方法代替常量来使用，使用常量速度和准确度会更好。</span><span style="color:#000000;">以下为</span><span style="color:#000000;">Math</span><span style="color:#000000;">中的方法产生的值。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">Method Parameter </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">abs -any- </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">acos 0.0 or 1.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">asin 0.0 or 1.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">atan 0.0 or 1.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">atan2 0.0 cbrt 0.0 or 1.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">ceil -any- </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">cos 0.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">cosh 0.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">exp 0.0 or 1.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">expm1 0.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">floor -any- </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">log 0.0 or 1.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">log10 0.0 or 1.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">rint -any- </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">round -any- </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">sin 0.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">sinh 0.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">sqrt 0.0 or 1.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">tan 0.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">tanh 0.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">toDegrees 0.0 or 1.0 </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">toRadians 0.0</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">18.UPM: Private method is never called(UPM_UNCALLED_PRIVATE_METHOD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">定义为</span><span style="color:#000000;">Private</span><span style="color:#000000;">类型方法从未被调用，应该被删除。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">19.UrF: Unread field (URF_UNREAD_FIELD)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">类中定义的属性从未被调用，建议删除。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">20.UuF: Unused field (UUF_UNUSED_FIELD)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">类中定义的属性从未被使用，建议删除。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">21.WMI: Inefficient use of keySet iteratorinstead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">当方法中接受一个</span><span style="color:#000000;">Map</span><span style="color:#000000;">类型的参数时，使用</span><span style="color:#000000;">keySet</span><span style="color:#000000;">的迭代器比使用</span><span style="color:#000000;">entrySet</span><span style="color:#000000;">的迭代器效率要高。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#000000;">六：</span><span style="color:#000000;">Internationalization</span><span style="color:#000000;">关于代码国际化相关方面的</span></strong></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">Dm: Consider using Locale parameterizedversion of invoked method (DM_CONVERT_CASE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">String.toUpperCase( Locale l )</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">String.toLowerCase( Locale l )</span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#000000;">七：</span><span style="color:#000000;">Multithreadedcorrectness</span><span style="color:#000000;">关于代码多线程正确性相关方面的</span></strong></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">1.DL: Synchronization on Boolean couldlead to deadlock (DL_SYNCHRONIZATION_ON_BOOLEAN)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">该代码同步一个封装的原始常量，例如一个</span><span style="color:#000000;">Boolean</span><span style="color:#000000;">类型。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">private static Boolean inited =Boolean.FALSE;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">...</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  synchronized(inited) { </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    if (!inited) {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">       init();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">       inited =Boolean.TRUE;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">       }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">     }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">...</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">2.DL: Synchronization on boxed primitivecould lead to deadlock (DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">该代码同步一个封装的原始常量，例如一个</span><span style="color:#000000;">Integer</span><span style="color:#000000;">类型。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">private static Integer count = 0;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">...</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  synchronized(count) { </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">     count++;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">     }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">...</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">由于</span><span style="color:#000000;">Integer</span><span style="color:#000000;">对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">3.DL: Synchronization on interned Stringcould lead to deadlock (DL_SYNCHRONIZATION_ON_SHARED_CONSTANT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">同步</span><span style="color:#000000;">String</span><span style="color:#000000;">类型的常量时，由于它被</span><span style="color:#000000;">JVM</span><span style="color:#000000;">中多个其他的对象所共有，这样在其他代码中会引起死锁。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">4.DL: Synchronization on boxed primitivevalues (DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">同步一个显然不是共有封装的原始值，例如一个</span><span style="color:#000000;">Integer</span><span style="color:#000000;">类型的对象。例如：</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">private static final Integer fileLock =new Integer(1);</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">...</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  synchronized(fileLock) { </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">     .. do something ..</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">     }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">...</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">它最后被定义为以下方式来代替：</span><span style="color:#000000;">private staticfinal Object fileLock = new Object();</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> </span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">5.Dm: Monitor wait() called on Condition(DM_MONITOR_WAIT_ON_CONDITION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">方法中以</span><span style="color:#000000;">java.util.concurrent.locks.Condition</span><span style="color:#000000;">对象调用</span><span style="color:#000000;">wait</span><span style="color:#000000;">（）。等待一个条件发生时应该使用在</span><span style="color:#000000;">Condition</span><span style="color:#000000;">接口中定义的</span><span style="color:#000000;">await()</span><span style="color:#000000;">方法。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">6.Dm: A thread was created using thedefault empty run method (DM_USELESS_THREAD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">这个方法没有通过</span><span style="color:#000000;">run</span><span style="color:#000000;">方法或者具体声明</span><span style="color:#000000;">Thread</span><span style="color:#000000;">类，也没有通过一个</span><span style="color:#000000;">Runnable</span><span style="color:#000000;">对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">7.ESync: Empty synchronized block(ESync_EMPTY_SYNC)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">该代码包含一个空的同步块：</span><span style="color:#000000;">synchronized() {}</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">8.IS: Inconsistent synchronization(IS2_INCONSISTENT_SYNC)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">不合理的同步</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">9.IS: Field not guarded against concurrentaccess (IS_FIELD_NOT_GUARDED)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">域不是良好的同步访问</span><span style="color:#000000;">---</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> </span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> </span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此字段被标注为</span><span style="color:#000000;">net.jcip.annotations.GuardedBy</span><span style="color:#000000;">，但可以在某种程度上违反注释而去访问</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">10.JLM: Synchronization performed on Lock(JLM_JSR166_LOCK_MONITORENTER)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">实现</span><span style="color:#000000;">java.util.concurrent.locks.Lock</span><span style="color:#000000;">的对象调用了同步的方法。应该这样处理，对象被锁定</span><span style="color:#000000;">/</span><span style="color:#000000;">解锁时使用</span><span style="color:#000000;">acquire</span><span style="color:#000000;">（）</span><span style="color:#000000;">/ release</span><span style="color:#000000;">（）方法而不是使用同步的方法。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">11.LI: Incorrect lazy initialization ofstatic field (LI_LAZY_INIT_STATIC)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">静态域不正确的延迟初始化</span><span style="color:#000000;">--</span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">这种方法包含了一个不同步延迟初始化的非</span><span style="color:#000000;">volatile</span><span style="color:#000000;">静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">12.LI: Incorrect lazy initialization andupdate of static field (LI_LAZY_INIT_UPDATE_STATIC)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程</span><span style="color:#000000;">bug</span><span style="color:#000000;">，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。</span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为</span><span style="color:#000000;">static</span><span style="color:#000000;">字段时它可能会更好。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">13.ML: Method synchronizes on an updatedfield (ML_SYNC_ON_UPDATED_FIELD)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">14.MSF: Mutable servlet field(MSF_MUTABLE_SERVLET_FIELD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一个</span><span style="color:#000000;">web</span><span style="color:#000000;">服务一般只能创建一个</span><span style="color:#000000;">servlet</span><span style="color:#000000;">或者</span><span style="color:#000000;">jsp</span><span style="color:#000000;">的实例（例如：</span><span style="color:#000000;">treates</span><span style="color:#000000;">是一个单利类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">15.MWN: Mismatched notify()(MWN_MISMATCHED_NOTIFY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此方法调用</span><span style="color:#000000;">Object.notify</span><span style="color:#000000;">（）或</span><span style="color:#000000;">Object.notifyAll</span><span style="color:#000000;">（）而没有获取到该对象的对象锁。调用</span><span style="color:#000000;">notify</span><span style="color:#000000;">（）或</span><span style="color:#000000;">notifyAll</span><span style="color:#000000;">（）而没有持有该对象的对象锁，将导致</span><span style="color:#000000;">IllegalMonitorStateException</span><span style="color:#000000;">异常。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">16.MWN: Mismatched wait()(MWN_MISMATCHED_WAIT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此方法调用</span><span style="color:#000000;">Object.wait()</span><span style="color:#000000;">而没有获取到该对象的对象锁。调用</span><span style="color:#000000;">wait</span><span style="color:#000000;">（）而没有持有该对象的对象锁，将导致</span><span style="color:#000000;">IllegalMonitorStateException</span><span style="color:#000000;">异常。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">17.NP: Synchronize and null check on thesame field. (NP_SYNC_AND_NULL_CHECK_FIELD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出</span><span style="color:#000000;">NullPointerException</span><span style="color:#000000;">异常。最好是在另一个代码块中进行同步。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">18.No: Using notify() rather thannotifyAll() (NO_NOTIFY_NOT_NOTIFYALL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">调用</span><span style="color:#000000;">notify</span><span style="color:#000000;">（）而不是</span><span style="color:#000000;">notifyAll</span><span style="color:#000000;">（）方法。</span><span style="color:#000000;"> Java</span><span style="color:#000000;">的监控器通常用于多个条件。调用</span><span style="color:#000000;">notify</span><span style="color:#000000;">（）只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">19.RS: Class's readObject() method issynchronized (RS_READOBJECT_SYNC)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">序列化类中定义了同步的</span><span style="color:#000000;">readObject</span><span style="color:#000000;">（）。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的</span><span style="color:#000000;">readObject</span><span style="color:#000000;">（）进行同步。如果的</span><span style="color:#000000;">readObject</span><span style="color:#000000;">（）方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">20.Ru: Invokes run on a thread (did youmean to start it instead?) (RU_INVOKE_RUN)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">这种方法显式调用一个对象的</span><span style="color:#000000;">run</span><span style="color:#000000;">（）。一般来说，类是实现</span><span style="color:#000000;">Runnable</span><span style="color:#000000;">接口的，因为在一个新的线程他们将有自己的</span><span style="color:#000000;">run</span><span style="color:#000000;">（）方法，在这种情况下</span><span style="color:#000000;">Thread.start</span><span style="color:#000000;">（）方法调用是正确的。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">21.SC: Constructor invokes Thread.start()(SC_START_IN_CTOR)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">22.SP: Method spins on field(SP_SPIN_ON_FIELD)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求）</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">23.STCAL: Call to static Calendar(STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">即使</span><span style="color:#000000;">JavaDoc</span><span style="color:#000000;">对此不包含暗示，而</span><span style="color:#000000;">Calendars</span><span style="color:#000000;">本身在多线程中使用就是不安全的。探测器发现当调用</span><span style="color:#000000;">Calendars</span><span style="color:#000000;">的实例时将会获得一个静态对象。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">Calendar rightNow =Calendar.getInstance();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">24.STCAL: Call to static DateFormat(STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在官方的</span><span style="color:#000000;">JavaDoc</span><span style="color:#000000;">，</span><span style="color:#000000;">DateFormats</span><span style="color:#000000;">多线程使用本事就是不安全的。探测器发现调用一个</span><span style="color:#000000;">DateFormat</span><span style="color:#000000;">的实例将会获得一个静态对象。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">myString =DateFormat.getDateInstance().format(myDate);</span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> </span></p> 
<p><span style="background-color:#ffffff;color:#000000;"> </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">25.STCAL: Static Calendar(STCAL_STATIC_CALENDAR_INSTANCE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">Calendar</span><span style="color:#000000;">在多线程中本身就是不安全的，如果在线程范围中共享一个</span><span style="color:#000000;">Calendarde </span><span style="color:#000000;">实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在</span><span style="color:#000000;">sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()</span><span style="color:#000000;">中会抛出</span><span style="color:#000000;">ArrayIndexOutOfBoundsExceptions orIndexOutOfBoundsExceptions</span><span style="color:#000000;">异常。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">26.STCAL: Static DateFormat(STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">DateFormat </span><span style="color:#000000;">在多线程中本身就是不安全的，如果在线程范围中共享一个</span><span style="color:#000000;">DateFormat</span><span style="color:#000000;">的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">27.SWL: Method calls Thread.sleep() with alock held (SWL_SLEEP_WITH_LOCK_HELD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">当持有对象时调用</span><span style="color:#000000;">Thread.sleep</span><span style="color:#000000;">（）。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用</span><span style="color:#000000;">wait</span><span style="color:#000000;">（）是一个更好的主意，释放对象的持有以允许其他线程运行。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">28.UG: Unsynchronized get method,synchronized set method (UG_SYNC_SET_UNSYNC_GET)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">这个类包含类似命名的</span><span style="color:#000000;">get</span><span style="color:#000000;">和</span><span style="color:#000000;">set</span><span style="color:#000000;">方法。在</span><span style="color:#000000;">set</span><span style="color:#000000;">方法是同步方法和</span><span style="color:#000000;">get</span><span style="color:#000000;">方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的</span><span style="color:#000000;">get</span><span style="color:#000000;">方法不一定返回对象一致状态。</span><span style="color:#000000;"> GET</span><span style="color:#000000;">方法应该同步。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">29.UL: Method does not release lock on allpaths (UL_UNRELEASED_LOCK)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法获得了当前的对象所，但是在方法中始终没有释放它。一个正确的示例如下：</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  Lock l = ...;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    l.lock();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    try {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        // dosomething</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    } finally {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        l.unlock();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">30.UL: Method does not release lock on allexception paths (UL_UNRELEASED_LOCK_EXCEPTION_PATH)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下：</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  Lock l = ...;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    l.lock();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    try {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        // dosomething</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    } finally {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        l.unlock();</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">31.UW: Unconditional wait (UW_UNCOND_WAIT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">方法中包含调用</span><span style="color:#000000;">java.lang.Object.wait</span><span style="color:#000000;">（），而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待</span><span style="color:#000000;">;</span><span style="color:#000000;">先前任何通知将被忽略。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">32.VO: A volatile reference to an array doesn'ttreat the array elements as volatile (VO_VOLATILE_REFERENCE_TO_ARRAY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用</span><span style="color:#000000;">java.util.concurrent</span><span style="color:#000000;">包中的数组的原子性特性</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">33.WL: Sychronization on getClass ratherthan class literal (WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">实例的方法中同步</span><span style="color:#000000;">this.getClass()</span><span style="color:#000000;">，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名</span><span style="color:#000000;">.getClass()</span><span style="color:#000000;">。例如，</span><span style="color:#000000;">java.awt.Label</span><span style="color:#000000;">的代码：</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">     private static finalString base = "label";</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">     private static intnameCounter = 0;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">     StringconstructComponentName() {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        synchronized(getClass()) {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">           return base + nameCounter++;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">     }</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">Label</span><span style="color:#000000;">中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为：</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    private static final Stringbase = "label";</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">     private static intnameCounter = 0;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">     StringconstructComponentName() {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        synchronized(Label.class) {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">           return base + nameCounter++;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">     }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">34.WS: Class's writeObject() method issynchronized but nothing else is (WS_WRITEOBJECT_SYNC)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">这个类有一个</span><span style="color:#000000;">writeObject</span><span style="color:#000000;">（）方法是同步的，但是这个类中没有其他的同步方法。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">35.Wa: Condition.await() not in loop(WA_AWAIT_NOT_IN_LOOP)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">方法没有在循环中调用</span><span style="color:#000000;">java.util.concurrent.await()</span><span style="color:#000000;">。如果对象是用于多种条件，打算调用</span><span style="color:#000000;">wait()</span><span style="color:#000000;">方法的条件可能不是实际发生的。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">36.Wa: Wait not in loop (WA_NOT_IN_LOOP)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">这种方法包含调用</span><span style="color:#000000;">java.lang.Object.wait</span><span style="color:#000000;">（），而这并不是一个循环。如果监视器用于多个条件，打算调用</span><span style="color:#000000;">wait()</span><span style="color:#000000;">方法的条件可能不是实际发生的。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#000000;">八：</span><span style="color:#000000;">Maliciouscodevulnerability</span><span style="color:#000000;">关于恶意破坏代码相关方面的</span></strong></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">1.EI: May expose internal representationby returning reference to mutable object (EI_EXPOSE_REP)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">返回一个易变对象引用并把它保存在对象字段中时会暴露对象内部的字段描述，如果接受不守信任的代码访问或者没有检查就去改变易变对象的会涉及对象的安全和其他重要属性的安全。返回一个对象的新副本，在很多情况下更好的办法。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">2.EI2: May expose internal representationby incorporating reference to mutable object (EI_EXPOSE_REP2)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">3.FI: Finalizer should be protected, notpublic (FI_PUBLIC_SHOULD_BE_PROTECTED)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一个类中的</span><span style="color:#000000;">finalize</span><span style="color:#000000;">（）方法必须声明为</span><span style="color:#000000;">protected</span><span style="color:#000000;">，而不能为</span><span style="color:#000000;">public</span><span style="color:#000000;">类型</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">4.MS: Public static method may exposeinternal representation by returning array (MS_EXPOSE_REP)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一个</span><span style="color:#000000;">public</span><span style="color:#000000;">类型的静态方法返回一个数组，可能引用内部属性的暴露。任何代码调用此方法都可以自由修改底层数组。一个解决办法是返回一个数组的副本。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">5.MS: Field should be both final andpackage protected (MS_FINAL_PKGPROTECT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一个静态字段可能被恶意代码或另外一个包所改变的。字段可以放到</span><span style="color:#000000;">protected</span><span style="color:#000000;">包中也可以定义为</span><span style="color:#000000;">final</span><span style="color:#000000;">类型的以避免此问题。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">6.MS: Field is a mutable array(MS_MUTABLE_ARRAY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一个定义为</span><span style="color:#000000;">final</span><span style="color:#000000;">类型的静态字段引用一个数组时它可以被恶意代码或在另其他包中所使用。这些代码可以自由修改数组的内容。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">7.MS: Field is a mutable Hashtable(MS_MUTABLE_HASHTABLE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一个定义为</span><span style="color:#000000;">final</span><span style="color:#000000;">类型的静态字段引用一个</span><span style="color:#000000;">Hashtable</span><span style="color:#000000;">时可以被恶意代码或者在其他包中被调用，这些方法可以修改</span><span style="color:#000000;">Hashtable</span><span style="color:#000000;">的值。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">8.MS: Field should be moved out of aninterface and made package protected (MS_OOI_PKGPROTECT)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">将域尽量不要定义在接口中，并声明为包保护</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在接口中定义了一个</span><span style="color:#000000;">final</span><span style="color:#000000;">类型的静态字段，如数组或哈希表等易变对象。这些对象可以被恶意代码或者在其他包中被调用，为了解决这个问题，需要把它定义到一个具体的实体类中并且声明为保护类型以避免这种错误。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">9.MS: Field should be package protected(MS_PKGPROTECT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">一个静态字段是可以改变的恶意代码或其他的包访问修改。可以把这种类型的字段声明为</span><span style="color:#000000;">final</span><span style="color:#000000;">类型的以防止这种错误。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#000000;">十：</span><span style="color:#000000;">Dodgy</span><span style="color:#000000;">关于代码运行期安全方面的</span></strong></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">1.XSS: Servlet reflected cross site scriptingvulnerability (XSS_REQUEST_PARAMETER_TO_SEND_ERROR)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在代码中在</span><span style="color:#000000;">Servlet</span><span style="color:#000000;">输出中直接写入一个</span><span style="color:#000000;">HTTP</span><span style="color:#000000;">参数，这会造成一个跨站点的脚本漏洞。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">2.XSS: Servlet reflected cross sitescripting vulnerability (XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">代码直接写入参数的</span><span style="color:#000000;">HTTP</span><span style="color:#000000;">服务器错误页（使用</span><span style="color:#000000;">HttpServletResponse.sendError</span><span style="color:#000000;">）。表达了类似的不受信任的输入会引起跨站点脚本漏洞。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">3.BC: Questionable cast to abstractcollection (BC_BAD_CAST_TO_ABSTRACT_COLLECTION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在代码投把一个集合强制类型转换为一个抽象的集合（如</span><span style="color:#000000;">list</span><span style="color:#000000;">，</span><span style="color:#000000;">set</span><span style="color:#000000;">或</span><span style="color:#000000;">map</span><span style="color:#000000;">）。保证该对象类型和将要转换的类型是一致的。如果你只是想要便利一个集合，那么你就不必将它转换为</span><span style="color:#000000;">Set</span><span style="color:#000000;">或</span><span style="color:#000000;">List</span><span style="color:#000000;">。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">4.BC: Questionable cast to concretecollection (BC_BAD_CAST_TO_CONCRETE_COLLECTION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">代码把抽象的集合（如</span><span style="color:#000000;">List</span><span style="color:#000000;">，</span><span style="color:#000000;">Set</span><span style="color:#000000;">，或</span><span style="color:#000000;">Collection</span><span style="color:#000000;">）强制转换为具体落实类型（如一个</span><span style="color:#000000;">ArrayList</span><span style="color:#000000;">或</span><span style="color:#000000;">HashSet</span><span style="color:#000000;">）。这可能不正确，也可能使您的代码很脆弱，因为它使得难以在今后的切换指向其他具体实现。除非你有特别理由这样做，否则只需要使用抽象的集合类。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">5.BC: Unchecked/unconfirmed cast(BC_UNCONFIRMED_CAST)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">强制类型转换操作没有经过验证，而且不是所有的此种类型装换过的类都可以再强制类型转换为原类型。在代码中需要进行逻辑判断以保证可以进行这样的操作。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">6.BC: instanceof will always return true(BC_VACUOUS_INSTANCEOF)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">instanceof</span><span style="color:#000000;">测试将始终返回真（除非被测试的值为空）。虽然这是安全，确保它是不是说明一些误解或其他一些逻辑错误。如果你真的想测试是空的价值，也许会更清楚这样做的更好空试验，而不是一个</span><span style="color:#000000;">instanceof</span><span style="color:#000000;">测试。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">7.BSHIFT: Unsigned right shift cast toshort/byte (ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">无符号数右移后进行转换为</span><span style="color:#000000;">short</span><span style="color:#000000;">或者</span><span style="color:#000000;">byte</span><span style="color:#000000;">类型时可能会丢弃掉高位的值，这样的结果就是有符合数和无符号数无法区分（这取决于移位大小）</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">8.CI: Class is final but declaresprotected field (CI_CONFUSED_INHERITANCE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">这个类被声明为</span><span style="color:#000000;">final</span><span style="color:#000000;">的，而是字段属性却声明为保护类型的。由于是</span><span style="color:#000000;">final</span><span style="color:#000000;">类，它不能再被继承，而再声明为保护类型的很容易造成混淆。为了从外部能正确的使用它应该把它们声明为</span><span style="color:#000000;">private</span><span style="color:#000000;">或者</span><span style="color:#000000;">public</span><span style="color:#000000;">类型。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">9.DB: Method uses the same code for twobranches (DB_DUPLICATE_BRANCHES)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">10.DB: Method uses the same code for twoswitch clauses (DB_DUPLICATE_SWITCH_CLAUSES)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">他的方法使用相同的代码来实现两个</span><span style="color:#000000;">switch</span><span style="color:#000000;">的声明条款。这可能是重复代码的情况，但可能也显示出编码的错误。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">11.DLS: Dead store to local variable(DLS_DEAD_LOCAL_STORE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">12.DLS: Useless assignment in returnstatement (DLS_DEAD_LOCAL_STORE_IN_RETURN)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">13.DLS: Dead store of null to localvariable (DLS_DEAD_LOCAL_STORE_OF_NULL)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">把一个本地变量赋值为</span><span style="color:#000000;">null</span><span style="color:#000000;">值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是</span><span style="color:#000000;">Java SE 6.0</span><span style="color:#000000;">，这已不再需要。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">14.DMI: Code contains a hard codedreference to an absolute pathname (DMI_HARDCODED_ABSOLUTE_FILENAME)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此代码包含文件对象为一个绝对路径名（例如，新的文件（</span><span style="color:#000000;">“/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”</span><span style="color:#000000;">）</span><span style="color:#000000;">;</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">15.DMI: Non serializable object written toObjectOutput (DMI_NONSERIALIZABLE_OBJECT_WRITTEN)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">代码中让一个非序列化的对象出现在</span><span style="color:#000000;">ObjectOutput.writeObject()</span><span style="color:#000000;">方法中，这样会引起一个错误。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">16.DMI: Invocation of substring(0), whichreturns the original value (DMI_USELESS_SUBSTRING)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此代码调用了</span><span style="color:#000000;">subString(0)</span><span style="color:#000000;">方法，它将返回原来的值。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">17.Eq: Class doesn't override equals insuperclass (EQ_DOESNT_OVERRIDE_EQUALS)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">子类定义了一个新的</span><span style="color:#000000;">equals</span><span style="color:#000000;">方法但是却不是覆写了父类本省的</span><span style="color:#000000;">equals()</span><span style="color:#000000;">方法。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">18.FE: Test for floating point equality(FE_FLOATING_POINT_EQUALITY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此操作比较两个浮点值是否相等。由于浮点运算可能会涉及到舍入，计算</span><span style="color:#000000;">float</span><span style="color:#000000;">和</span><span style="color:#000000;">double</span><span style="color:#000000;">值可能不准确。如果要求值必须准确，如货币值，可以考虑使用固定精度类型，如</span><span style="color:#000000;">BigDecimal</span><span style="color:#000000;">类型的值来比较</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">19.FS: Non-Boolean argument formattedusing %b format specifier (VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">使用</span><span style="color:#000000;">%b</span><span style="color:#000000;">去格式化</span><span style="color:#000000;">Boolean</span><span style="color:#000000;">类型的值不正确的但是它不会抛出异常，任何非空的值都会输出</span><span style="color:#000000;">true</span><span style="color:#000000;">，任何为空的值都会输出</span><span style="color:#000000;">false</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">20.IC: Initialization circularity(IC_INIT_CIRCULARITY)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在引用两个相互调用为环状</span><span style="color:#000000;">static</span><span style="color:#000000;">方法去初始化一个实例时是错误的。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">21.ICAST: integral division result cast todouble or float (ICAST_IDIV_CAST_TO_DOUBLE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">整形数除法强制转换为</span><span style="color:#000000;">double</span><span style="color:#000000;">或者</span><span style="color:#000000;">float</span><span style="color:#000000;">类型。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">int x = 2;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">int y = 5;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">// Wrong: yields result 0.0</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">double value1 =  x / y;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">// Right: yields result 0.4</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">double value2 =  x / (double) y;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">22.ICAST: Result of integer multiplicationcast to long (ICAST_INTEGER_MULTIPLY_CAST_TO_LONG)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">整形数做乘法运算结果转换为</span><span style="color:#000000;">long</span><span style="color:#000000;">值时如果采用</span></span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">long convertDaysToMilliseconds(int days) {return 1000*3600*24*days; } </span><span style="color:#000000;">结果会因为超出整形的范围而出错。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">如果使用：</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">long convertDaysToMilliseconds(int days) {return 1000L*3600*24*days; } </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">或者：</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">static final long MILLISECONDS_PER_DAY =24L*3600*1000;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        longconvertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY;} </span></p> 
<p><span style="background-color:#ffffff;color:#000000;">都可以避免此问题。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">23.IM: Computation of average couldoverflow (IM_AVERAGE_COMPUTATION_COULD_OVERFLOW)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">代码中使用</span><span style="color:#000000;">x % 2 == 1</span><span style="color:#000000;">的方法去验证运算是否存在余数的情况，但是如果出现负数的情况就不起作用了。使用</span><span style="color:#000000;">x &amp; 1 == 1, orx % 2 != 0</span><span style="color:#000000;">来代替</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">24.INT: Vacuous comparison of integervalue (INT_VACUOUS_COMPARISON)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">整形数进行比较结果总是不变。例如：</span><span style="color:#000000;">x &lt;=Integer.MAX_VALUE</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">25.MTIA: Class extends Servlet class anduses instance variables (MTIA_SUSPECT_SERVLET_INSTANCE_FIELD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">这个类扩展从</span><span style="color:#000000;">Servlet</span><span style="color:#000000;">类，并使用实例的成员变量。由于只有一个</span><span style="color:#000000;">Servlet</span><span style="color:#000000;">类的实例，并在多线程方式使用，这种模式有可能存在问题。考虑只使用方法的局部变量。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">26.MTIA: Class extends Struts Action classand uses instance variables (MTIA_SUSPECT_STRUTS_INSTANCE_FIELD)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">类扩展自</span><span style="color:#000000;">Struts</span><span style="color:#000000;">的</span><span style="color:#000000;">Action</span><span style="color:#000000;">类并使用这个实例的成员变量，因为在</span><span style="color:#000000;">Struts</span><span style="color:#000000;">框架中只存在一个</span><span style="color:#000000;">Action</span><span style="color:#000000;">实例对象并且使用在多线程的情况下很可能会出现问题。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">27.NP: Dereference of the result of readLine()without nullcheck (NP_DEREFERENCE_OF_READLINE_VALUE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">对</span><span style="color:#000000;">readLine()</span><span style="color:#000000;">的结果值没有进行判空操作就去重新赋值，这样的操作可以会抛出空指针异常。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">28.NP: Immediate dereference of the resultof readLine() (NP_IMMEDIATE_DEREFERENCE_OF_READLINE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">对</span><span style="color:#000000;">readLine()</span><span style="color:#000000;">的结果立即赋值，这样的操作可以会抛出空指针异常。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">29.NP: Possible null pointer dereferencedue to return value of called method (NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">30.NP: Parameter must be nonnull but ismarked as nullable (NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">参数值在任何情况下都不能为空，但是有明确的注释它可以为空。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">31.NS: Potentially dangerous use ofnon-short-circuit logic (NS_DANGEROUS_NON_SHORT_CIRCUIT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">代码中使用（</span><span style="color:#000000;">&amp; or |</span><span style="color:#000000;">）代替（</span><span style="color:#000000;">&amp;&amp; or ||</span><span style="color:#000000;">）操作，这会造成潜在的危险。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">32.NS: Questionable use ofnon-short-circuit logic (NS_NON_SHORT_CIRCUIT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">代码中使用（</span><span style="color:#000000;">&amp; or |</span><span style="color:#000000;">）代替（</span><span style="color:#000000;">&amp;&amp; or ||</span><span style="color:#000000;">）操作，会引起不安全的操作</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">33.PZLA: Consider returning a zero lengtharray rather than null (PZLA_PREFER_ZERO_LENGTH_ARRAYS)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">考虑返回一个零长度的数组，而不是</span><span style="color:#000000;">null</span><span style="color:#000000;">值</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">34.QF: Complicated, subtle or wrongincrement in for-loop (QF_QUESTIONABLE_FOR_LOOP)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">确定这个循环是正确的变量递增，看起来，另一个变量被初始化，检查的循环。这是由于</span><span style="color:#000000;">for</span><span style="color:#000000;">循环中太复杂的定义造成的。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">35.RCN: Redundant comparison of non-nullvalue to null (RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法中包含一个不能为空的赋值还包含一个可以为空的赋值。冗余比较非空值为空。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">36.RCN: Redundant comparison of two nullvalues (RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">方法中对两个</span><span style="color:#000000;">null</span><span style="color:#000000;">值进行比较</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">37.RCN: Redundant nullcheck of value knownto be non-null (RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">方法中对不为空的值进行为空的判断。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">38.REC: Exception is caught when Exceptionis not thrown (REC_CATCH_EXCEPTION)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">在</span><span style="color:#000000;">try/catch</span><span style="color:#000000;">块中捕获异常，但是异常没有在</span><span style="color:#000000;">try</span><span style="color:#000000;">语句中抛出而</span><span style="color:#000000;">RuntimeException</span><span style="color:#000000;">又没有明确的被捕获</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">39.RI: Class implements same interface assuperclass (RI_REDUNDANT_INTERFACES)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">子类和父类都实现了同一个接口，这种定义是多余的。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">40.RV: Method discards result of readLineafter checking if it is nonnull (RV_DONT_JUST_NULL_CHECK_READLINE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">readLine</span><span style="color:#000000;">方法的结果不为空时被抛弃</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">41.RV: Remainder of 32-bit signed randominteger (RV_REM_OF_RANDOM_INT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">此代码生成一个随机的符号整数，然后计算另一个值的。由于随机数可以是负数，所以其余操作的结果也可以是负面的。考虑使用</span><span style="color:#000000;">Random.nextInt</span><span style="color:#000000;">（</span><span style="color:#000000;">int</span><span style="color:#000000;">）方法代替。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">42.SA: Double assignment of local variable(SA_LOCAL_DOUBLE_ASSIGNMENT)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">为一个局部变量两次赋值，这样是没有意义的。例如：</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">public void foo() {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    int x,y;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    x = x = 17;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">43.SA: Self assignment of local variable(SA_LOCAL_SELF_ASSIGNMENT)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">局部变量使用自身给自己赋值</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">public void foo() {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    int x = 3;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">    x = x;</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">  }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">44.SF: Switch statement found where onecase falls through to the next case (SF_SWITCH_FALLTHROUGH)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">Switch</span><span style="color:#000000;">语句中一个分支执行后又执行了下一个分支。通常</span><span style="color:#000000;">case</span><span style="color:#000000;">后面要跟</span><span style="color:#000000;">break </span><span style="color:#000000;">或者</span><span style="color:#000000;">return</span><span style="color:#000000;">语句来跳出。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">45.SF: Switch statement found wheredefault case is missing (SF_SWITCH_NO_DEFAULT)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">Switch</span><span style="color:#000000;">没有默认情况下执行的</span><span style="color:#000000;">case</span><span style="color:#000000;">语句。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">46.Se: private readResolve method notinherited by subclasses (SE_PRIVATE_READ_RESOLVE_NOT_INHERITED)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">声明为</span><span style="color:#000000;">private</span><span style="color:#000000;">的序列化方法被子类继承</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">47.UCF: Useless control flow(UCF_USELESS_CONTROL_FLOW)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">没有任何作用的条件语句。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">if (argv.length == 0) {<!-- --></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        //TODO: handle this case</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">        }</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">48.UCF: Useless control flow to next line(UCF_USELESS_CONTROL_FLOW_NEXT_LINE)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">无效的条件控制语句，注意</span><span style="color:#000000;">if (argv.length ==1);</span><span style="color:#000000;">以</span><span style="color:#000000;">“;”</span><span style="color:#000000;">结尾，下面的语句无论是否满足都会运行。</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">if (argv.length == 1);</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">       System.out.println("Hello, " + argv[0]);</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">49.UwF: Field not initialized inconstructor (UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR)</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">字段从来没有在任何构造函数初始化，对象被创建后值为空。如果该字段未被定义就重新赋值会产生一个空指针异常。</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">50.XFB: Method directly allocates aspecific implementation of xml interfaces (XFB_XML_FACTORY_BYPASS)</span></p> 
<p><span style="background-color:#ffffff;"><span style="color:#000000;">方法自定义了一种</span><span style="color:#000000;">XML</span><span style="color:#000000;">接口的实现类。最好是使用官方提供的工厂类来创建这些对象，以便可以在运行期中改变。例如：</span></span></p> 
<p><span style="background-color:#ffffff;color:#000000;">javax.xml.parsers.DocumentBuilderFactory</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">javax.xml.parsers.SAXParserFactory</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">javax.xml.transform.TransformerFactory</span></p> 
<p><span style="background-color:#ffffff;color:#000000;">org.w3c.dom.Document.createXXXX</span></p> 
<p><span style="background-color:#ffffff;"> </span></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f985bab0b85c8e800bc7593ad603105/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nRF51822：在 macOS 下使用 SEGGER Embedded Studio（SES）搭建开发环境</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9acd5801af0731a012f09b1d5578c361/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jQuery的$(document).ready() 与$(window).load 区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>