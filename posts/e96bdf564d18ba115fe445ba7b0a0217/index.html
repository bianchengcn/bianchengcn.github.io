<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2021年经典大厂面试题——算法与数据结构版（含答案） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2021年经典大厂面试题——算法与数据结构版（含答案）" />
<meta property="og:description" content="经典大厂面试题 题目 请问，Object作为HashMap的key的话，对Object有什么要求吗？请问 hashset 存的数是有序的吗？输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径二叉树的搜索区间现在有一个单向链表，谈一谈，如何判断链表中是否出现了环随机链表的复制找出数组中和为S的一对组合，找出一组就行求一个数组中连续子向量的最大和谈一谈，如何得到一个数据流中的中位数？你知道哪些排序算法，这些算法的时间复杂度分别是多少，解释一下快排？请你解释一下，内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法。说一说，heap和stack有什么区别。请你设计一个算法，用来压缩一段URL？谈一谈，id全局唯一且自增，如何实现？一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数，请说一下你的思路并手写代码请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素判断一个链表是否为回文链表，说出你的思路并手写代码 答案 请问，Object作为HashMap的key的话，对Object有什么要求吗？ 考察点：哈希表
参考回答： 要求 Object 中 hashcode 不能变。
解读： 什么是hashcode。Java语言中，Object对象有个特殊的方法：hashcode(), hashcode()表示的是JVM虚拟机为这个Object对象分配的一个int类型的数值，JVM会使用对象的hashcode值来提高对HashMap、Hashtable哈希表存取对象的使用效率。
关于Object对象的hashCode()返回值，网上对它就是一个简单的描述：“JVM根据某种策略生成的”.
什么是JVM。Java虚拟机（Java Virtual Machine 简称JVM）。通常来说，高级语言运行在不同的平台上，需要编译为不同的语言，但是如果不同的平台都有虚拟机，由虚拟机来执行Java语言，就不需要编译为不同的语言，这也就解释了为什么Java可以跨平台运行。
请问 hashset 存的数是有序的吗？ 参考回答： Hashset 是无序的。
解读：什么事hashset。hashset储存的是唯一的对象，没有下标，只能通过增强for，或者迭代器进行遍历。当出现相同的对象，会合并，只储存一个空间。
//遍历方法一： Iterator&lt;news&gt; it=set.iterator(); while(it.hasNext()){ News n=it.next(); } ----------------------------------------- //遍历方法二： for(News n:set){ printf(n); } 输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径 剑指Offer JZ24 二叉树中和为某一值的路径
/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) { vector&lt;int&gt; path; vector&lt;vector&lt;int&gt; &gt;res; if(root==NULL)return res; Find(root,path,expectNumber,res); return res; } void Find(TreeNode* root,vector&lt;int&gt;&amp; p,int sum,vector&lt;vector&lt;int&gt;&gt; &amp;res){ p." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/e96bdf564d18ba115fe445ba7b0a0217/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-16T12:59:02+08:00" />
<meta property="article:modified_time" content="2023-10-16T12:59:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2021年经典大厂面试题——算法与数据结构版（含答案）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_1"></a>经典大厂面试题</h2> 
<p><img src="https://images2.imgbox.com/1a/8a/FgscRzkU_o.jpg" alt="在这里插入图片描述"></p> 
<h2><a id="_4"></a>题目</h2> 
<ul><li>请问，Object作为HashMap的key的话，对Object有什么要求吗？</li><li>请问 hashset 存的数是有序的吗？</li><li>输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径</li><li>二叉树的搜索区间</li><li>现在有一个单向链表，谈一谈，如何判断链表中是否出现了环</li><li>随机链表的复制</li><li>找出数组中和为S的一对组合，找出一组就行</li><li>求一个数组中连续子向量的最大和</li><li>谈一谈，如何得到一个数据流中的中位数？</li><li>你知道哪些排序算法，这些算法的时间复杂度分别是多少，解释一下快排？</li><li>请你解释一下，内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法。</li><li>说一说，heap和stack有什么区别。</li><li>请你设计一个算法，用来压缩一段URL？</li><li>谈一谈，id全局唯一且自增，如何实现？</li><li>一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数，请说一下你的思路并手写代码</li><li>请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</li><li>判断一个链表是否为回文链表，说出你的思路并手写代码</li></ul> 
<h2><a id="_24"></a>答案</h2> 
<h3><a id="ObjectHashMapkeyObject_26"></a>请问，Object作为HashMap的key的话，对Object有什么要求吗？</h3> 
<p>考察点：哈希表<br> 参考回答： 要求 Object 中 hashcode 不能变。<br> 解读： 什么是hashcode。Java语言中，Object对象有个特殊的方法：hashcode(), hashcode()表示的是JVM虚拟机为这个Object对象分配的一个int类型的数值，JVM会使用对象的hashcode值来提高对HashMap、Hashtable哈希表存取对象的使用效率。<br> 关于Object对象的hashCode()返回值，网上对它就是一个简单的描述：“JVM根据某种策略生成的”.<br> 什么是JVM。Java虚拟机（Java Virtual Machine 简称JVM）。通常来说，高级语言运行在不同的平台上，需要编译为不同的语言，但是如果不同的平台都有虚拟机，由虚拟机来执行Java语言，就不需要编译为不同的语言，这也就解释了为什么Java可以跨平台运行。</p> 
<h3><a id="_hashset__33"></a>请问 hashset 存的数是有序的吗？</h3> 
<p>参考回答： Hashset 是无序的。<br> 解读：什么事hashset。hashset储存的是唯一的对象，没有下标，只能通过增强for，或者迭代器进行遍历。当出现相同的对象，会合并，只储存一个空间。</p> 
<pre><code>//遍历方法一：
Iterator&lt;news&gt; it=set.iterator();
while(it.hasNext()){
	News n=it.next();
	
}
-----------------------------------------
//遍历方法二：
for(News n:set){
	printf(n);
}
</code></pre> 
<h3><a id="_54"></a>输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径</h3> 
<p>剑指Offer JZ24 二叉树中和为某一值的路径</p> 
<pre><code class="prism language-cpp"><span class="token comment">/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> <span class="token function">FindPath</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span><span class="token keyword">int</span> expectNumber<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> path<span class="token punctuation">;</span>    
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span>res<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token punctuation">;</span>
        <span class="token function">Find</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>path<span class="token punctuation">,</span>expectNumber<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">Find</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> sum<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token operator">&amp;</span>res<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        p<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">==</span>root<span class="token operator">-&gt;</span>val<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>root<span class="token operator">-&gt;</span>left<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token function">Find</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>sum<span class="token operator">-</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token function">Find</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>sum<span class="token operator">-</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//回溯</span>
        p<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_92"></a>二叉树的搜索区间</h3> 
<p>给定两个值 k1 和 k2（k1 &lt; k2）和一个二叉查找树的根节点。找到树中所有值在 k1 到 k2 范围内的节点。即打印所有x (k1 &lt;= x &lt;= k2) 其中 x 是二叉查找树的中的节点值。返回所有升序的节点值。</p> 
<p>利用中序遍历，得到节点值递增的数组。在从数组中选择满足条件的数。</p> 
<h3><a id="_98"></a>现在有一个单向链表，谈一谈，如何判断链表中是否出现了环</h3> 
<p>LeetCode.141.环形链表</p> 
<p>方法一：哈希</p> 
<p>最容易想到的方法是<br> 遍历所有节点，<br> 每次遍历到一个节点时，判断该节点此前是否被访问过。<br> 可以使用哈希表来存储所有已经访问过的节点。<br> 每次到达一个节点的时候<br> 判断：<br> 如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。<br> 重复这一过程，直到我们遍历完整个链表即可</p> 
<p>方法二：快慢指针</p> 
<ol><li>设置一个快慢指针fast和slow，开始时slow和fast都指向链表的头节点head。然后slow每次移动一步（slow-&gt;next），fast每次移动两步（fast-&gt;next-&gt;next），在链表中遍历。</li><li>如果链表无环，fast指针在移动过程一定先遇到终点，到达终点的标志是（fast-&gt;next=NULL)(奇数个节点)||(fast-&gt;next-&gt;next=NULL（偶数个节点）），直接返回false，表示链表无环。</li><li>如果有环slow和fast一定会相遇，并且是在NULL第一个入环的节点处相遇（证明略），slow==fast直接返回true。</li></ol> 
<pre><code class="prism language-c">bool <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> head<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> fast<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        slow <span class="token operator">=</span> slow<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        fast <span class="token operator">=</span> fast<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_139"></a>随机链表的复制</h3> 
<p><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" rel="nofollow">题目—leetcode138. 复制带随机指针的链表</a></p> 
<p>解法一： 使用hash存储原结点和克隆结点的映射关系，通过映射关系处理克隆结点的random指针。</p> 
<p>代码一：java语言</p> 
<pre><code class="prism language-java"><span class="token comment">/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">copyRandomList</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// map方法，空间复杂度O(n)</span>
        <span class="token class-name">Node</span> node <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token comment">// 使用hash表存储旧结点和新结点的映射---key:旧节点，val:新节点</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Node</span> clone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>clone<span class="token punctuation">)</span><span class="token punctuation">;</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//第二次遍历</span>
        node <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//根据key旧节点，找到val新节点，完善next指针</span>
            map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//根据key旧节点，找到val新节点，完善random指针</span>
            map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>random <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>random<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//遍历指针后移</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//根据旧节点，找到新节点</span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码二：cpp语言</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    Node<span class="token operator">*</span> <span class="token function">copyRandomList</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        unordered_map<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token punctuation">,</span> Node<span class="token operator">*</span><span class="token operator">&gt;</span> link<span class="token punctuation">;</span>
        Node<span class="token operator">*</span> pNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>pNode <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            link<span class="token punctuation">[</span>pNode<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>pNode<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pNode <span class="token operator">=</span> pNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        pNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>pNode <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            link<span class="token punctuation">[</span>pNode<span class="token punctuation">]</span><span class="token operator">-&gt;</span>next <span class="token operator">=</span> link<span class="token punctuation">[</span>pNode<span class="token operator">-&gt;</span>next<span class="token punctuation">]</span><span class="token punctuation">;</span>
            link<span class="token punctuation">[</span>pNode<span class="token punctuation">]</span><span class="token operator">-&gt;</span>random <span class="token operator">=</span> link<span class="token punctuation">[</span>pNode<span class="token operator">-&gt;</span>random<span class="token punctuation">]</span><span class="token punctuation">;</span>
            pNode <span class="token operator">=</span> pNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> link<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="S_218"></a>找出数组中和为S的一对组合，找出一组就行</h3> 
<p>类似LeetCode39题</p> 
<h5><a id="LeetCode39_httpsleetcodecncomproblemscombinationsum_222"></a><a href="https://leetcode-cn.com/problems/combination-sum/" rel="nofollow">LeetCode.39. 组合总和</a></h5> 
<p>从数组中找出所有组合为s的数</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayDeque</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Deque</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> candidates<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> target<span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * @param candidates 候选数组
     * @param begin      搜索起点
     * @param len        冗余变量，是 candidates 里的属性，可以不传
     * @param target     每减去一个元素，目标值变小
     * @param path       从根结点到叶子结点的路径，是一个栈
     * @param res        结果集列表
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// target 为负数和 0 的时候不再产生新的孩子结点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 重点理解这里从 begin 开始搜索的语意</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            path<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 注意：由于每一个元素可以重复使用，下一轮搜索的起点依然是 i，这里非常容易弄错</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len<span class="token punctuation">,</span> target <span class="token operator">-</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 状态重置</span>
            path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_282"></a>求一个数组中连续子向量的最大和</h3> 
<h3><a id="_286"></a>谈一谈，如何得到一个数据流中的中位数？</h3> 
<h3><a id="_287"></a>你知道哪些排序算法，这些算法的时间复杂度分别是多少，解释一下快排？</h3> 
<h3><a id="stackheap_static_area__288"></a>请你解释一下，内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法。</h3> 
<p>区:专门用来保存对象的实例(new 创建的对象和数组)，实际上也只是保存对象实例的属性值，属性的类型和对象本身的类型标记等，并不保存对象的方法（方法是指令，保存在Stack中）</p> 
<p>1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)<br> 2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身.<br> 3.一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。<br> 栈区:对象实例在Heap 中分配好以后，需要在Stack中保存一个4字节的Heap内存地址，用来定位该对象实例在Heap 中的位置，便于找到该对象实例。<br> 1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中<br> 2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。<br> 3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。<br> 4.由编译器自动分配释放 ，存放函数的参数值，局部变量的值等．<br> 静态区/方法区:<br> 1.方法区又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。<br> 2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。<br> 3.全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</p> 
<p>附：</p> 
<p>堆和栈是程序运行的关键，应该将其理解清楚。</p> 
<p>栈是运行时的单位，而堆是存储时的单位。</p> 
<p>堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个4btye的引用（堆栈分离的好处）。</p> 
<p><strong>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗</strong>？</p> 
<p>第一，从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。<br> 第二，堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。<br> 第三，栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。<br> 第四，面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。</p> 
<h3><a id="heapstack_324"></a>说一说，heap和stack有什么区别。</h3> 
<h3><a id="URL_325"></a>请你设计一个算法，用来压缩一段URL？</h3> 
<h3><a id="id_326"></a>谈一谈，id全局唯一且自增，如何实现？</h3> 
<h3><a id="N0n_1_327"></a>一个长度为N的整形数组，数组中每个元素的取值范围是[0,n## 1],判断该数组否有重复的数，请说一下你的思路并手写代码</h3> 
<h3><a id="kk_328"></a>请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</h3> 
<h3><a id="_329"></a>判断一个链表是否为回文链表，说出你的思路并手写代码</h3> 
<p>回文链表具有对称性，可以用快慢指针求解。</p> 
<p>快指针一次走两步，慢指针一次走一步，快指针指向末尾时，慢指针刚好指向链表中间，也就是前半部分链表的尾节点，返回慢指针，用慢指针获取后半分链表的头节点，并反转。具体如下：</p> 
<h4><a id="_335"></a>思路</h4> 
<p>整个流程可以分为以下<strong>五个步骤</strong>：</p> 
<ol><li>找到前半部分链表的尾节点。</li><li>反转后半部分链表。</li><li>判断是否回文。</li><li>恢复链表。</li><li>返回结果。</li></ol> 
<p>执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。</p> 
<p>我们也可以使用<strong>快慢指针</strong>在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</p> 
<p>若链表有奇数个节点，则中间的节点应该看作是前半部分。</p> 
<p>步骤二可以使用「<a href="https://leetcode-cn.com/problems/reverse-linked-list/" rel="nofollow">206. 反转链表</a>」问题中的解决方法来反转链表的后半部分。</p> 
<p>步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p> 
<p>步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p> 
<h4><a id="_357"></a>代码</h4> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    bool <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span><span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 找到前半部分链表的尾节点并反转后半部分链表</span>
        <span class="token class-name">ListNode</span><span class="token operator">*</span> firstHalfEnd <span class="token operator">=</span> <span class="token function">endOfFirstHalf</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ListNode</span><span class="token operator">*</span> secondHalfStart <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>firstHalfEnd<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 判断是否回文</span>
        <span class="token class-name">ListNode</span><span class="token operator">*</span> p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token class-name">ListNode</span><span class="token operator">*</span> p2 <span class="token operator">=</span> secondHalfStart<span class="token punctuation">;</span>
        bool result <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>result <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p1<span class="token operator">-&gt;</span>val <span class="token operator">!=</span> p2<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                result <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            p1 <span class="token operator">=</span> p1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            p2 <span class="token operator">=</span> p2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>        

        <span class="token comment">// 还原链表并返回结果</span>
        firstHalfEnd<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>secondHalfStart<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//返回结果</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span><span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ListNode</span><span class="token operator">*</span> prev <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
        <span class="token class-name">ListNode</span><span class="token operator">*</span> curr <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">ListNode</span><span class="token operator">*</span> nextTemp <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            curr<span class="token operator">-&gt;</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>
            prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
            curr <span class="token operator">=</span> nextTemp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">endOfFirstHalf</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span><span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ListNode</span><span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token class-name">ListNode</span><span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> nullptr <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            fast <span class="token operator">=</span> fast<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            slow <span class="token operator">=</span> slow<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> 
<h4><a id="_417"></a>反转单链表</h4> 
<p><img src="https://images2.imgbox.com/0a/49/P69WizLC_o.png" alt=""></p> 
<pre><code class="prism language-cpp"><span class="token comment">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		ListNode<span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		ListNode<span class="token operator">*</span> curr <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			ListNode<span class="token operator">*</span> next <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			curr<span class="token operator">-&gt;</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>
			prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
			curr <span class="token operator">=</span> next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token keyword">return</span> prev<span class="token punctuation">;</span>        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b40d8f12bf4ed078af805558f5268fb9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">面向C&#43;&#43;模块的开源 IFC SDK</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ca13e8e55095b5213e7ac9bb3613d554/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QT属性动画--设置样式属性(其他属性)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>