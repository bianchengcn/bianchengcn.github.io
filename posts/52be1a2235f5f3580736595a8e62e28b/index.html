<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二叉树的递归和非递归实现前序、中序、后序、层次遍历 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二叉树的递归和非递归实现前序、中序、后序、层次遍历" />
<meta property="og:description" content="二叉树的遍历方式一般有前序、中序、后序三种方式。其中每种方式都可以由递归和非递归实现，非递归主要借助于栈来实现，还可以借助队列实现层级遍历。下面的代码在vs2019编译通过，其中的栈和队列是自己简单实现的。实现思路和代码如下：
#include &lt;iostream&gt; #define _CRT_SECURE_NO_WARNINGS #define STACK_SIZE 100 #define QUEUE_SIZE 100 typedef struct Btree { char data; struct Btree* lChild; struct Btree* rChild; }Btree, *PBtree; //循环队列 class Myqueue { private: PBtree queue[QUEUE_SIZE]; int front, rear; public: Myqueue() { rear = front = 0; } bool IsEmpty() { return rear == front ? true : false; } bool enQueue(const PBtree T) { if ((rear &#43; 1) % QUEUE_SIZE == front) { return false; } queue[rear] = T; rear = (rear &#43; 1) % QUEUE_SIZE; return true; } PBtree deQueue() { if ( rear == front) { return NULL; } PBtree p = queue[front]; front = (front &#43; 1) % QUEUE_SIZE;	return p; } }; //栈 class MyStack { private: PBtree stack[STACK_SIZE]; int top; public: MyStack() { top = -1; } bool IsEmpty() { return -1 == top ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/52be1a2235f5f3580736595a8e62e28b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-04T01:28:41+08:00" />
<meta property="article:modified_time" content="2019-08-04T01:28:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二叉树的递归和非递归实现前序、中序、后序、层次遍历</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>二叉树的遍历方式一般有前序、中序、后序三种方式。其中每种方式都可以由递归和非递归实现，非递归主要借助于栈来实现，还可以借助队列实现层级遍历。下面的代码在vs2019编译通过，其中的栈和队列是自己简单实现的。实现思路和代码如下：</p> 
<pre><code>#include &lt;iostream&gt;
#define  _CRT_SECURE_NO_WARNINGS
#define  STACK_SIZE 100
#define  QUEUE_SIZE 100


typedef struct Btree {
	char data;
	struct Btree* lChild;
	struct Btree* rChild;
}Btree, *PBtree;

//循环队列
class Myqueue
{
private:
	PBtree queue[QUEUE_SIZE];
	int front, rear;

public:
	Myqueue()
	{
		rear = front = 0;
	}

	bool IsEmpty()
	{
		return rear == front ? true : false;
	}

	bool enQueue(const PBtree T)
	{
		if ((rear + 1) % QUEUE_SIZE == front) 
		{
			return false;
		}
		queue[rear] = T;
		rear = (rear + 1) % QUEUE_SIZE;
		return true;
	}

	PBtree deQueue()
	{
		if ( rear == front)
		{
			return NULL;
		}
		PBtree p = queue[front];
		front = (front + 1) % QUEUE_SIZE;	
		return p;
	}

};

//栈
class MyStack
{
private:
	PBtree stack[STACK_SIZE];
	int top;
public:
	MyStack()
	{
		top = -1;
	}

	bool IsEmpty()
	{
		return -1 == top ? true : false;
	}

	bool push(const PBtree T)
	{
		if (STACK_SIZE - 1 == top )
		{
			return false;
		}
		stack[++top] = T;
		return true;
	}

	PBtree pop()
	{
		if (-1 == top)
		{
			return NULL;				 
		}
		return stack[top--];
	}

};


//采用前序创建二叉树
void CreateTree(PBtree *T)
{
    char data;
	scanf_s("%c", &amp;data);
	if (data == '#')
	{
		*T = NULL;
		return;
	}
	else
	{
		*T = (PBtree)malloc(sizeof(Btree));
		if (!*T)
		{
			exit(-1);
		}
		(*T)-&gt;data = data;
		CreateTree(&amp;(*T)-&gt;lChild);
		CreateTree(&amp;(*T)-&gt;rChild);
	}
}

//递归前序遍历 
//比较简单 按照根-左-右顺序访问即可
void PreOrder(PBtree T)
{
	if (T)
	{
		printf("--%c--", T-&gt;data);
		PreOrder(T-&gt;lChild);
		PreOrder(T-&gt;rChild);
	}
}

//非递归前序遍历
//思路：初始将根节点入栈，栈不空就继续循环，出栈访问栈顶元素（根结点），再看右子树
//不空入栈，再看左子树，不空入栈（根据栈先入后出的特点）
void PreOrderNoRecursion(const PBtree T)
{
	if (!T) return;
	MyStack stack;
	PBtree p = T;
	stack.push(p);
	while (!stack.IsEmpty())
	{
		p = stack.pop();
		printf("--%c--", p-&gt;data);
		if (p-&gt;rChild)
		{
			stack.push(p-&gt;rChild);
		}
		if (p-&gt;lChild)
		{
			stack.push(p-&gt;lChild);
		}
	}

}

//递归中序遍历
//左-根-右
void InOrder(PBtree T)
{
	if(T)
	{
		InOrder(T-&gt;lChild);
		printf("--%c--", T-&gt;data);
		InOrder(T-&gt;rChild);
	}
}


//非递归中序遍历
//思路：左子树入栈遍历到最左边，栈不空，则退栈访问栈顶元素(根结点)，再将右子树入栈
//继续循环，注意循环条件为栈不空或者指针不空
void InOrderNoRecursion(const PBtree T)
{
	MyStack stack;
	PBtree p = T;

	while (!stack.IsEmpty() || p != NULL)
	{
		while(p) //if(p) 
		{
			stack.push(p);
			p = p-&gt;lChild;
		}
		if(!stack.IsEmpty())//else  
		{
			p = stack.pop();//
            printf("--%c--", p-&gt;data);
			p = p-&gt;rChild;
		}			
	}
}

//递归后序遍历
//左-右-根
void PostOrder(PBtree T)
{
	if (T)
	{
		PostOrder(T-&gt;lChild);
		PostOrder(T-&gt;rChild);
		printf("--%c--", T-&gt;data);
	}
}

//非递归后序遍历（方法较多，这里选取最容易理解的一种）
//非递归后序遍历和非递归前序遍历存在联系，仔细观察可以得到如下规律：
//1栈：调整前序非递归遍历的入栈顺序为  先左后右
//2栈：将前序遍历的访问操作存入2栈，然后输出2栈即可
void PostOrderNoRecursion(const PBtree T)
{
	if (!T) return;
	MyStack stack1;
	MyStack stack2;
	
	PBtree p = T;
	stack1.push(p);

	while (!stack1.IsEmpty())
	{
		p = stack1.pop();
		stack2.push(p);

		if (p-&gt;lChild)
		{
			stack1.push(p-&gt;lChild);
		}
		if (p-&gt;rChild)
		{
			stack1.push(p-&gt;rChild);
		}
	}
	
	while (!stack2.IsEmpty())
	{
		p = stack2.pop();
		printf("--%c--", p-&gt;data);
	}

}


//层次遍历,借助队列实现
//根先入队，出队访问，并按照从左到右依次将子树入队即可，队空退出循环
void LevelOrder(const PBtree T)
{
	Myqueue queue;
	PBtree p = T;
	queue.enQueue(p);
	while (!queue.IsEmpty())
	{
		p = queue.deQueue();
		printf("--%c--", p-&gt;data);
		if (p-&gt;lChild)
		{
			queue.enQueue(p-&gt;lChild);
		}
		if (p-&gt;rChild)
		{
			queue.enQueue(p-&gt;rChild);
		}
	}
}


int main()
{
	printf("please input string in PreOrder(# is null)!\n");
	//abc##d##e#f##
    /*            a
	            /   \
        	   b     e
 	          / \     \
	         c   d     f                   
    */

	PBtree T;
	CreateTree(&amp;T);

	printf("\n PreOrder-Recursion:\n");
	PreOrder(T);
    printf("\n PreOrder-No-Recursion:\n");
	PreOrderNoRecursion(T);
	
	printf("\n InOrder-Recursion:\n");
	InOrder(T);
	printf("\n InOrder-No-Recursion:\n");
	InOrderNoRecursion(T);

	printf("\n PostOrder-Recursion:\n");
	PostOrder(T);
	printf("\n PostOrder-No-Recursion:\n");
	PostOrderNoRecursion(T);

	printf("\n LevelOrder:\n");
	LevelOrder(T);

	return 0;
}


</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a784a245fd73dca1af56385abd4c4918/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pc端富文本编辑的字符串在手机端适配</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/25b72050d775c36fbf978324e57e4e1c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《Java开发实战经典》.(李兴华).[PDF]&amp;ckook百度网盘链接</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>