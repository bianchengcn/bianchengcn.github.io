<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>代码随想录算法训练营|day18 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="代码随想录算法训练营|day18" />
<meta property="og:description" content="第六章 二叉树 513.找树左下角的值112.路径总和113.路径总和ii106.从中序与后序遍历序列构造二叉树105.从前序与中序遍历序列构造二叉树代码随想录文章详解总结 513.找树左下角的值 (1)递归：复用求最大深度
先递归遍历左子树，后右子树，所以当取到最大深度时，返回对应的节点值
func findBottomLeftValue(root *TreeNode) int { if root == nil { return 0 } height := 0 leftVal := 0 var getDepth func(root *TreeNode, depth int) getDepth = func(root *TreeNode, depth int) { if root == nil { return } depth&#43;&#43; getDepth(root.Left, depth) getDepth(root.Right, depth) if depth &gt; height { height = depth leftVal = root.Val } } getDepth(root, 0) return leftVal } (2)迭代：最后一层第一个值" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/1e23b0e45fe03ba9eca73c92340b6bf9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-28T09:16:39+08:00" />
<meta property="article:modified_time" content="2024-01-28T09:16:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">代码随想录算法训练营|day18</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>第六章 二叉树</h4> 
 <ul><li><a href="#513httpsleetcodecnproblemsfindbottomlefttreevaluedescription_1" rel="nofollow">513.找树左下角的值</a></li><li><a href="#112httpsleetcodecnproblemspathsumdescription_55" rel="nofollow">112.路径总和</a></li><li><a href="#113iihttpsleetcodecnproblemspathsumiidescription_98" rel="nofollow">113.路径总和ii</a></li><li><a href="#106httpsleetcodecnproblemsconstructbinarytreefrominorderandpostordertraversaldescription_166" rel="nofollow">106.从中序与后序遍历序列构造二叉树</a></li><li><a href="#105httpsleetcodecnproblemsconstructbinarytreefrompreorderandinordertraversaldescription_191" rel="nofollow">105.从前序与中序遍历序列构造二叉树</a></li><li><a href="#_218" rel="nofollow">代码随想录文章详解</a></li><li><a href="#_222" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="513httpsleetcodecnproblemsfindbottomlefttreevaluedescription_1"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/" rel="nofollow">513.找树左下角的值</a></h2> 
<p>(1)递归<font face="隶属" size="3" color="#003399">：复用求最大深度</font><br> 先递归遍历左子树，后右子树，所以当取到最大深度时，返回对应的节点值</p> 
<pre><code>func findBottomLeftValue(root *TreeNode) int {
    if root == nil {
        return 0
    }
    height := 0
    leftVal := 0
    var getDepth func(root *TreeNode, depth int)
    getDepth = func(root *TreeNode, depth int) {
        if root == nil {
            return
        }
        depth++
        getDepth(root.Left, depth)
        getDepth(root.Right, depth)
        if depth &gt; height {
            height = depth  
            leftVal = root.Val
        }
    }
    getDepth(root, 0)
    return  leftVal
}
</code></pre> 
<p>(2)迭代<font face="隶属" size="3" color="#003399">：最后一层第一个值</font></p> 
<pre><code>func findBottomLeftValue(root *TreeNode) int {
    if root == nil {
        return 0
    }
    queue := []*TreeNode{root}
    res := 0
    for len(queue) &gt; 0 {
        size := len(queue)
        for i:= 0; i &lt; size; i++ {
            node := queue[0]
            if i == 0 {
                res = node.Val
            }
            queue = queue[1:]
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue,node.Right)
            }
        }
    }
    return res
}
</code></pre> 
<h2><a id="112httpsleetcodecnproblemspathsumdescription_55"></a><a href="https://leetcode.cn/problems/path-sum/description/" rel="nofollow">112.路径总和</a></h2> 
<p><a href="https://leetcode.cn/problems/binary-tree-paths/description/" rel="nofollow">求二叉树所有路径的变体</a><br> (1)递归<font face="隶属" size="3" color="#003399">：递归判断<mark>当前节点</mark>到<mark>叶子节点</mark>之和是否为targetSum</font></p> 
<pre><code>func hasPathSum(root *TreeNode, targetSum int) bool {
    if root == nil {
        return false
    }

    if root.Left == nil &amp;&amp; root.Right == nil {
        return targetSum == root.Val
    }
    return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)
}
</code></pre> 
<p>(2)层序遍历<font face="隶属" size="3" color="#003399">：<mark>nodeQueue</mark>存储了根节点到包括当前节点的所有节点，<mark>sumQueue</mark>记录了根节点到该节点之和</font></p> 
<pre><code>func hasPathSum(root *TreeNode, targetSum int) bool {
    if root == nil {
        return false
    }
    nodeQueue := []*TreeNode{root}
    sumQueue := []int{root.Val}
    for i := 0; i &lt; len(nodeQueue); i++ {
        node, sum := nodeQueue[i], sumQueue[i]
        if node.Left == nil &amp;&amp; node.Right == nil {
            if sum == targetSum  {
                return true
            }
            continue
        }
        if node.Left != nil {
            nodeQueue = append(nodeQueue, node.Left)
            sumQueue = append(sumQueue, sum + node.Left.Val)
        }
        if node.Right != nil {
            nodeQueue = append(nodeQueue, node.Right)
            sumQueue = append(sumQueue, sum + node.Right.Val)
        }
    }
    return false
}
</code></pre> 
<h2><a id="113iihttpsleetcodecnproblemspathsumiidescription_98"></a><a href="https://leetcode.cn/problems/path-sum-ii/description/" rel="nofollow">113.路径总和ii</a></h2> 
<p>(1)递归<font face="隶属" size="3" color="#003399">：<mark>初始化</mark>记录路径；终止条件；递归左右子树</font></p> 
<pre><code>func pathSum(root *TreeNode, targetSum int) [][]int {
    res := make([][]int, 0)
    path := []int{}
    var help func(root *TreeNode, targetSum int) 
    help = func(root *TreeNode, targetSum int) {
        if root == nil {
            return
        }
        path = append(path, root.Val)
        targetSum -= root.Val
        if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; targetSum == 0{
            res = append(res, path)
        }
        help(root.Left, targetSum)
        help(root.Right, targetSum)
    }
    help(root, targetSum)
    return res
}
</code></pre> 
<p>(2)层序遍历：<br> <font face="隶属" size="3" color="#003399">遍历时对path变量使用append方法，会修改底层数组，进而会影响到pathQueue中的其它路径。需要为每个路径<mark>创建一个新的切片副本</mark>。</font></p> 
<pre><code>type group struct {
	Node *TreeNode
	Val  []int
}

func pathSum(root *TreeNode, targetSum int) [][]int {
	var res [][]int
	if root == nil {
		return res
	}

	queue := []*group{<!-- -->{root, []int{root.Val}}}
	for len(queue) &gt; 0 {
		node := queue[0].Node
		valArr := queue[0].Val
		queue = queue[1:]
		sum := 0
		for _, val := range valArr {
			sum += val
		}
		if node.Left == nil &amp;&amp; node.Right == nil &amp;&amp; sum == targetSum {
			res = append(res, valArr)
		}

		valArrCp := make([]int, len(valArr))
		copy(valArrCp, valArr)

		if node.Left != nil {
			valArr1 := valArrCp
			valArr1 = append(valArr1, node.Left.Val)
			queue = append(queue, &amp;group{node.Left, valArr1})
		}
		if node.Right != nil {
			valArr2 := valArrCp
			valArr2 = append(valArr2, node.Right.Val)
			queue = append(queue, &amp;group{node.Right, valArr2})
		}
	}
	return res
}
</code></pre> 
<h2><a id="106httpsleetcodecnproblemsconstructbinarytreefrominorderandpostordertraversaldescription_166"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" rel="nofollow">106.从中序与后序遍历序列构造二叉树</a></h2> 
<p>(1)递归<font face="隶属" size="3" color="#003399">：找到<mark>后序数组</mark>中<mark>最后一个元素</mark>在<mark>中序数组</mark>中的位置。递归右子树和左子树</font></p> 
<pre><code>func buildTree(inorder []int, postorder []int) *TreeNode {
    var build func(inorderLeft, inorderRight int) *TreeNode 
    build = func(inorderLeft, inorderRight int) *TreeNode {
        if inorderLeft &gt; inorderRight {
            return nil
        }
        rootVal := postorder[len(postorder) - 1]
        postorder = postorder[:len(postorder) - 1]
        root := &amp;TreeNode{Val:rootVal}
        i := 0
        for i = 0; i &lt; len(inorder); i++ {
            if inorder[i] == rootVal {
                break
            }
        }
        root.Right = build(i + 1, inorderRight)
        root.Left = build(inorderLeft, i - 1)
        return root
    }
    return build(0, len(inorder) - 1)
}
</code></pre> 
<h2><a id="105httpsleetcodecnproblemsconstructbinarytreefrompreorderandinordertraversaldescription_191"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" rel="nofollow">105.从前序与中序遍历序列构造二叉树</a></h2> 
<p>(1)递归<font face="隶属" size="3" color="#003399">：找到<mark>前序数组</mark>中<mark>第一个元素</mark>在<mark>中序数组</mark>中的位置。递归左子树和右子树</font></p> 
<pre><code>func buildTree(preorder []int, inorder []int) *TreeNode {
    var build func(inorderLeft, inorderRight int) *TreeNode 
    build = func(inorderLeft, inorderRight int) *TreeNode{
        if inorderLeft &gt; inorderRight {
            return nil
        }
        rootVal := preorder[0]
        root := &amp;TreeNode{Val : rootVal}
        preorder = preorder[1:]

        i := 0
        for i = 0; i &lt; len(inorder); i++ {
            if inorder[i] == rootVal {
                break
            }
        }
        root.Left = build(inorderLeft, i - 1)
        root.Right = build(i + 1, inorderRight)
        return root
    }
    return build(0, len(inorder) - 1)
}
</code></pre> 
<h2><a id="_218"></a>代码随想录文章详解</h2> 
<p><a href="https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html" rel="nofollow">513.找树左下角的值</a><br> <a href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html" rel="nofollow">112.路径总和 | 113.路径总和ii</a><br> <a href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html" rel="nofollow">106.从中序与后序遍历序列构造二叉树 | 105.从前序与中序遍历序列构造二叉树</a></p> 
<h2><a id="_222"></a>总结</h2> 
<p>递归求解通常需要公共变量提取，创建无返回值函数，或者返回值为bool<br> 注意切片扩容，导致结果出错，<a href="https://blog.csdn.net/kevin_tech/article/details/122485977">切片深拷贝、浅拷贝</a><br> 感谢代码随想录练习营大佬们的帮助和解答</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd534c63b4f0c0ed5126ef400031618a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">操作系统（6）----线程相关</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/955c4e504b33b7b68f1c1729914b9fc2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C语言】（8）宏定义</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>