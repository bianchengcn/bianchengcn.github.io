<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Js异步编程 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Js异步编程" />
<meta property="og:description" content=" JavaScript (JS) 是一种单线程执行的编程语言，因此在处理复杂或耗时的任务时，如果采用同步编程方式，则会让浏览器或服务器阻塞，导致用户体验变差或性能下降。
异步编程可以解决这个问题。它使得可以同时处理多个任务，不需要等待某些操作完成再执行下一个操作，而是立即将控制权返回给调用者。当相应的操作完成时，异步函数会调用回调函数或Promise对象的then()方法，并在事件队列中排队等待执行，从而实现非阻塞式的并发执行。
以下是两种异步编程实现的方式：
一.Promise.all 实现 methodExec() { // 1.定义一个Array存储调用方法后的数据 const promiseArray = [] // 2.将要异步执行的两个方法添加到Array中 promiseArray.push( fun1(), fun2() ) // 3.使用 Promise.all() &#43; .then() 等待方法返回结果都返回，然后获取异步调用的方法的信息 Promise.all(promiseArray).then((result) =&gt; { console.log(result[0]) console.log(result[1]) }) } async methodExec() { // await等待Promise.all()返回全部数据，方法和效果跟上面一模一样 let [fun1Data,fun2Data] = await Promise.all([fun1(),fun2()]); } 二.async/await 实现 // async 是一个关键字，定义异步函数 async methodExec() { // 定义变量接收方法fun1()和fun2()的返回值，此时fun1()的执行不阻塞fun2() let fun1Promise = fun1() let fun2Promise = fun2() // await 是一个关键字，可以等到fun1Promise和fun2Promise接受到返回值后才赋值到fun1Data和fun2Data let fun1Data = await fun1Promise; let fun2Data = await fun2Promise; } " />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/70d81e78dde30e56ab342567047ad146/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-24T19:52:17+08:00" />
<meta property="article:modified_time" content="2023-05-24T19:52:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Js异步编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>JavaScript (JS) 是一种单线程执行的编程语言，因此在处理复杂或耗时的任务时，如果采用同步编程方式，则会让浏览器或服务器阻塞，导致用户体验变差或性能下降。</p> 
<p>异步编程可以解决这个问题。它使得可以同时处理多个任务，不需要等待某些操作完成再执行下一个操作，而是立即将控制权返回给调用者。当相应的操作完成时，异步函数会调用回调函数或Promise对象的then()方法，并在事件队列中排队等待执行，从而实现非阻塞式的并发执行。</p> 
<p>以下是两种异步编程实现的方式：</p> 
<h2>一.Promise.all 实现</h2> 
<pre><code class="language-javascript">methodExec() {
    // 1.定义一个Array存储调用方法后的数据
    const promiseArray = []
    // 2.将要异步执行的两个方法添加到Array中
    promiseArray.push(
    	fun1(),
	    fun2()
    )
    // 3.使用 Promise.all() + .then() 等待方法返回结果都返回，然后获取异步调用的方法的信息
    Promise.all(promiseArray).then((result) =&gt; {
        console.log(result[0])
        console.log(result[1])
    })
}</code></pre> 
<pre><code class="language-javascript">async methodExec() {
    // await等待Promise.all()返回全部数据，方法和效果跟上面一模一样
    let [fun1Data,fun2Data] = await Promise.all([fun1(),fun2()]);
}</code></pre> 
<h2>二.async/await 实现</h2> 
<pre><code class="language-javascript">// async 是一个关键字，定义异步函数
async methodExec() {
    // 定义变量接收方法fun1()和fun2()的返回值，此时fun1()的执行不阻塞fun2()
    let fun1Promise = fun1()
    let fun2Promise = fun2()
    // await 是一个关键字，可以等到fun1Promise和fun2Promise接受到返回值后才赋值到fun1Data和fun2Data
    let fun1Data = await fun1Promise;
    let fun2Data = await fun2Promise;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0caada8ee6790c637cbe93e2beccdfeb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">软件测试面试题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bbebdffd8aa27d8c432f827458fe0069/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vscode参数输入</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>