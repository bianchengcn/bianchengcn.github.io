<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>对于java反射的一些学习理解和认知 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="对于java反射的一些学习理解和认知" />
<meta property="og:description" content="1. 反射（Reflection）的概念
反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所属的属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。
功能：
反射是java中一种强大的机制. Java反射机制主要提供了以下功能：
1.运行时判断任意一个对象所属的类；
2.运行时构造任意一个类的对象；
3.运行时判断任意一个类所具有的成员变量和方法；
4.在运行时调用任意一个对象的方法，生成动态代理。
反射简单的解释就是,把类中的成分,映射到相应的类,达到用这些类操作框架.
2. Class 类
Java 程序在运行时，系统会对所有的对象进行所谓的运行时类型标识，用来保存这些信息的类就是 Class 类。Class 类封装一个对象和接口运行时的状态。
从Java源程序到java程序运行要经历一个曲折的过程: 源程序javac编译源程序,得到.class文件.jvm从硬盘读取.class文件,并且把.class文件转化成字节码存入内存读取这些字节码,得到程序运行效果
在第三个步骤的, jvm从硬盘读取.class文件,并且把.class文件转化成字节码存入内存,其中每一份字节码就是一个Class对象,Class相当于字节码的类(类似于Person是人的类).要得到Class类,通常有3种方式:
类名.class
对象名.getClass()
Class. forName(完整的类名)—在反射中比较常用
反射的作用是把类中的成分,映射到相应的类,也就是说类中的方法,字段,构造函数,数组等都有映射的类,它们对应的就是Method , Field, Constructor, Array。
Class类中的getFields , getConstructors,和getMethods方法返回public修饰的字段,构造函数和方法的数组,其中包括父类的公有成员.
Class类中的getDeclareFields , getDeclareMethods和getDeclareConstructors方法返回类中声明的全部字段,方法和构造函数,包含私有的和受保护的,但是不包括父类的成员。
3、通过案例来一步一步熟悉JAVA反射机制
//实例1、通过一个对象获取完整的包名和类名 package cn.cast.reflect; class Demo{ } public class test01 { public static void main(String[] args) { Demo demo=new Demo(); System.out.println(demo.getClass().getName()); } } 运行结果： cn.cast.reflect.Demo（所有类的对象都是Class的实例） package cn.cast.reflect; /* * 实例2、Class类的实例化 * 由于Class类没有构造方法，所以实例化Class类的方式有点特殊，有三种方式： * 对象." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5a77edefca8af5b4c4a252466253a9ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-07-21T15:17:18+08:00" />
<meta property="article:modified_time" content="2015-07-21T15:17:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">对于java反射的一些学习理解和认知</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>1. 反射（Reflection）的概念</strong></p> 
<p>反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所属的属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p> 
<p>功能：</p> 
<p>反射是java中一种强大的机制. Java反射机制主要提供了以下功能：</p> 
<p>1.运行时判断任意一个对象所属的类；</p> 
<p>2.运行时构造任意一个类的对象；</p> 
<p>3.运行时判断任意一个类所具有的成员变量和方法；</p> 
<p>4.在运行时调用任意一个对象的方法，生成动态代理。</p> 
<p>反射简单的解释就是,把类中的成分,映射到相应的类,达到用这些类操作框架.</p> 
<p><strong>2. Class 类</strong></p> 
<p>Java 程序在运行时，系统会对所有的对象进行所谓的运行时类型标识，用来保存这些信息的类就是 Class 类。Class 类封装一个对象和接口运行时的状态。</p> 
<p>从Java源程序到java程序运行要经历一个曲折的过程: <br> 源程序javac编译源程序,得到.class文件.jvm从硬盘读取.class文件,并且把.class文件转化成字节码存入内存读取这些字节码,得到程序运行效果</p> 
<p>在第三个步骤的, jvm从硬盘读取.class文件,并且把.class文件转化成字节码存入内存,其中每一份字节码就是一个Class对象,Class相当于字节码的类(类似于Person是人的类).要得到Class类,通常有3种方式:</p> 
<ol><li><p>类名.class</p></li><li><p>对象名.getClass()</p></li><li><p>Class. forName(完整的类名)—在反射中比较常用</p></li></ol> 
<p>反射的作用是把类中的成分,映射到相应的类,也就是说类中的<strong>方法,字段,构造函数,数组</strong>等都有映射的类,它们对应的就是<strong>Method , Field, Constructor, Array</strong>。</p> 
<p>Class类中的getFields , getConstructors,和getMethods方法返回public修饰的字段,构造函数和方法的数组,其中包括父类的公有成员.</p> 
<p>Class类中的getDeclareFields , getDeclareMethods和getDeclareConstructors方法返回类中声明的全部字段,方法和构造函数,包含私有的和受保护的,但是不包括父类的成员。</p> 
<p><strong>3、通过案例来一步一步熟悉JAVA反射机制</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//实例1、通过一个对象获取完整的包名和类名</span>
package cn.cast.reflect;
class Demo{

}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> test01 {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        Demo demo=<span class="hljs-keyword">new</span> Demo();
        System.<span class="hljs-keyword">out</span>.println(demo.getClass().getName());
    }
}

运行结果：
cn.cast.reflect.Demo（所有类的对象都是Class的实例）</code></pre> 
<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">package</span> cn.<span class="hljs-keyword">cast</span>.reflect;
<span class="hljs-comment">/*
 * 实例2、Class类的实例化
 * 由于Class类没有构造方法，所以实例化Class类的方式有点特殊，有三种方式：
 *  对象.getClass( )
 *  类.Class
 *  forName( )
 *  
 *  重点掌握forName()方法，因为它可以在类不确定的情况下实例化Class，更具灵活性
 *
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> test02 {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) {
        <span class="hljs-comment">//方式一：对象.getClass( )</span>
        Demo demo=<span class="hljs-keyword">new</span> Demo();
        Class&lt;?&gt; c1=demo.getClass();
        System.<span class="hljs-keyword">out</span>.println(c1);

        <span class="hljs-comment">//方式2：类.Class</span>
        <span class="hljs-comment">//Class&lt;?&gt; c2=Demo.class;</span>
        Class c2=Demo.<span class="hljs-keyword">class</span>;
        System.<span class="hljs-keyword">out</span>.println(c2);

        <span class="hljs-comment">//方式三：forName( )</span>
        Class&lt;?&gt; c3=<span class="hljs-literal">null</span>;
        <span class="hljs-comment">//forName()方法会抛出异常</span>
        <span class="hljs-keyword">try</span> {
            c3=Class.forName(<span class="hljs-string">"cn.cast.reflect.Demo"</span>);
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        }
        System.<span class="hljs-keyword">out</span>.println(c3);
    }
}

运行结果：
<span class="hljs-keyword">class</span> cn.<span class="hljs-keyword">cast</span>.reflect.Demo
<span class="hljs-keyword">class</span> cn.<span class="hljs-keyword">cast</span>.reflect.Demo
<span class="hljs-keyword">class</span> cn.<span class="hljs-keyword">cast</span>.reflect.Demo
</code></pre> 
<pre class="prettyprint"><code class=" hljs cs">package cn.cast.reflect;

<span class="hljs-comment">/*
 *Class类的应用
 *  Class类中有一个方法叫做newInstance( ),它可以用来创建一个Class类对象的新实例
 *  怎么说呢？Class对象包含的内容就是反射好的那个类，我们要构造那个类的新实例（新对象）
 * 实例3：Class类的无参构造对象
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> test03 {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        <span class="hljs-comment">//实例化Class对象，forname()方法抛出异常</span>
        Class&lt;?&gt; c=<span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//填写完整的包名和类名</span>
            c=Class.forName(<span class="hljs-string">"java.lang.String"</span>);
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        }

        <span class="hljs-comment">//生成一个String的引用</span>
        String s=<span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//将构造好的对象向下转型为Demo类</span>
            <span class="hljs-comment">//newInstance()方法会抛出异常</span>
            s=(String)c.newInstance();
        } <span class="hljs-keyword">catch</span> (InstantiationException e) {
            <span class="hljs-comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        } <span class="hljs-keyword">catch</span> (IllegalAccessException e) {
            <span class="hljs-comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        }
        System.<span class="hljs-keyword">out</span>.println(s.length());

    }
}

运行结果：
<span class="hljs-number">0</span>
</code></pre> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> cn.cast.reflect;

<span class="hljs-keyword">import</span> java.lang.reflect.Constructor;

<span class="hljs-comment">/*
 * 实例4、Class类的有参构造对象
 * 因为String类用的比较多，便于理解
 * 这里需要注意的是，构造方法需要使用getConstructor( )方法获得
 * 至于参数类型则是：原有类型.class
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test04</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> Exception {
        Class&lt;?&gt; c = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            c = Class.forName(<span class="hljs-string">"java.lang.String"</span>);
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        }
        <span class="hljs-keyword">char</span>[] ch = { <span class="hljs-string">'H'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span> };

        String s = <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// 需要获得Class类对象的有参构造方法，参数的写法：类型.class</span>
        Constructor&lt;?&gt; con = c.getConstructor(<span class="hljs-keyword">char</span>[].class);
        <span class="hljs-comment">// 用这个构造方法构造一个新的字符串对象，参数为一个char数组</span>
        s = (String) con.newInstance(ch);
        System.out.println(<span class="hljs-string">"构造的字符串为："</span> + s);
    }
}

运行结果：
Hello
</code></pre> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> cn.cast.reflect;

<span class="hljs-keyword">import</span> java.lang.reflect.Constructor;
<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-comment">/*
 * 获取类的结构
 * 实例5、获取类的构造方法
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test05</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> Exception{
        Class&lt;?&gt; c=<span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            c=Class.forName(<span class="hljs-string">"java.lang.Boolean"</span>);
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        }
        <span class="hljs-comment">//这里getConstrutors()方法返回的是一个Constructor数组</span>
        Constructor&lt;?&gt; [] cons=c.getConstructors();
        <span class="hljs-comment">//打印</span>
        System.out.println(Arrays.toString(cons));

    }
}

运行结果：
[<span class="hljs-keyword">public</span> java.lang.<span class="hljs-title">Boolean</span>(<span class="hljs-keyword">boolean</span>), 
<span class="hljs-keyword">public</span> java.lang.<span class="hljs-title">Boolean</span>(java.lang.String)]</code></pre> 
<pre class="prettyprint"><code class=" hljs cs">package cn.cast.reflect;

import java.util.Arrays;

<span class="hljs-comment">/*
 * 实例6：取得类所实现的接口
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> test06 {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        Class&lt;?&gt; c=<span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            c=Class.forName(<span class="hljs-string">"java.lang.Boolean"</span>);
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        }
        Class&lt;?&gt; []<span class="hljs-keyword">in</span>=c.getInterfaces();
        System.<span class="hljs-keyword">out</span>.println(Arrays.toString(<span class="hljs-keyword">in</span>));
    }
}

运行结果：
[<span class="hljs-keyword">interface</span> java.io.Serializable, <span class="hljs-keyword">interface</span> java.lang.Comparable]

</code></pre> 
<pre class="prettyprint"><code class=" hljs cs">package cn.cast.reflect;
<span class="hljs-comment">/*
 * 实例7：取得父类
 */</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> test07 {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws Exception {
        Class&lt;?&gt; c=<span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            c=Class.forName(<span class="hljs-string">"java.lang.Boolean"</span>);
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        }
        <span class="hljs-comment">//这里不能用数组接收了</span>
        Class&lt;?&gt; su=c.getSuperclass();
        System.<span class="hljs-keyword">out</span>.println(su);
    }
}

运行结果：
class java.lang.Object</code></pre> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> cn.cast.reflect;

<span class="hljs-keyword">import</span> java.lang.reflect.Method;

<span class="hljs-comment">/*
 * 实例8：取得类的全部方法
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test08</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        Class&lt;?&gt; c=<span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            c=c.forName(<span class="hljs-string">"java.lang.Boolean"</span>);
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        }
        Method[] m=c.getMethods();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m.length;i++){
            System.out.println(m[i]);
        }

    }
}

运行结果：
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> java.lang.Boolean.<span class="hljs-title">hashCode</span>()
<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> java.lang.Boolean.<span class="hljs-title">equals</span>(java.lang.Object)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> java.lang.String java.lang.Boolean.<span class="hljs-title">toString</span>(<span class="hljs-keyword">boolean</span>)
<span class="hljs-keyword">public</span> java.lang.String java.lang.Boolean.<span class="hljs-title">toString</span>()
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> java.lang.Boolean.<span class="hljs-title">compare</span>(<span class="hljs-keyword">boolean</span>,<span class="hljs-keyword">boolean</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> java.lang.Boolean.<span class="hljs-title">compareTo</span>(java.lang.Object)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> java.lang.Boolean.<span class="hljs-title">compareTo</span>(java.lang.Boolean)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> java.lang.Boolean java.lang.Boolean.<span class="hljs-title">valueOf</span>(<span class="hljs-keyword">boolean</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> java.lang.Boolean java.lang.Boolean.<span class="hljs-title">valueOf</span>(java.lang.String)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> java.lang.Boolean.<span class="hljs-title">booleanValue</span>()
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> java.lang.Boolean.<span class="hljs-title">getBoolean</span>(java.lang.String)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> java.lang.Boolean.<span class="hljs-title">parseBoolean</span>(java.lang.String)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> java.lang.Class java.lang.Object.<span class="hljs-title">getClass</span>()
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> java.lang.Object.<span class="hljs-title">notify</span>()
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> java.lang.Object.<span class="hljs-title">notifyAll</span>()
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> java.lang.Object.<span class="hljs-title">wait</span>(<span class="hljs-keyword">long</span>,<span class="hljs-keyword">int</span>) <span class="hljs-keyword">throws</span> java.lang.InterruptedException
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> java.lang.Object.<span class="hljs-title">wait</span>() <span class="hljs-keyword">throws</span> java.lang.InterruptedException
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> java.lang.Object.<span class="hljs-title">wait</span>(<span class="hljs-keyword">long</span>) <span class="hljs-keyword">throws</span> java.lang.InterruptedException

</code></pre> 
<pre class="prettyprint"><code class=" hljs cs">package cn.cast.reflect;

import java.lang.reflect.Field;

<span class="hljs-comment">/*
 * 实例9：取得本类的全部属性
 */</span>
class Person{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> test09 {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        Class &lt;?&gt; c=<span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            c=Class.forName(<span class="hljs-string">"cn.cast.reflect.Person"</span>);
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        }
        Field[] f=c.getDeclaredFields();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;f.length;i++){
            System.<span class="hljs-keyword">out</span>.println(f[i]);
        }
    }
}

运行结果：
<span class="hljs-keyword">private</span> java.lang.String cn.cast.reflect.Person.name
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cn.cast.reflect.Person.age

<span class="hljs-title">getDeclaredFielsd</span>()方法可以获取全部属性，<span class="hljs-title">getFields</span>()只能获取公共属性</code></pre> 
<pre class="prettyprint"><code class=" hljs cs">package cn.cast.reflect;

import java.lang.reflect.Field;

<span class="hljs-comment">/*
 * 实例10：获取本类中属性的值
 */</span>
class Person1{
    <span class="hljs-keyword">public</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Person1</span>(String name, <span class="hljs-keyword">int</span> age) {
        super();
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> test10 {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws Exception {
        Person1 p= <span class="hljs-keyword">new</span> Person1(<span class="hljs-string">"wangchen"</span>,<span class="hljs-number">18</span>);
        Class&lt;?&gt; c=p.getClass();
        <span class="hljs-comment">//获取公共属性的值</span>
        Field f1=c.getField(<span class="hljs-string">"name"</span>);
        <span class="hljs-comment">//get(p)表明要获取的哪个对象的值</span>
        String str=(String) f1.<span class="hljs-keyword">get</span>(p);

        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"姓名："</span>+str);

        <span class="hljs-comment">//获取私有属性的值</span>
        Field f2=c.getDeclaredField(<span class="hljs-string">"age"</span>);
        <span class="hljs-comment">//age是私有属性，所以要设置安全检查为true</span>
        f2.setAccessible(<span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">int</span> age=(<span class="hljs-keyword">int</span>)f2.<span class="hljs-keyword">get</span>(p);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"年龄是："</span>+age);


    }
}

运行结果：
姓名：wangchen
年龄是：<span class="hljs-number">18</span>
</code></pre> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> cn.cast.reflect;

<span class="hljs-keyword">import</span> java.lang.reflect.Field;

<span class="hljs-comment">/*
 * 实例11：通过反射修改属性
 */</span>
class Person2{
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-keyword">public</span> <span class="hljs-title">Person2</span>(String name) {
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"姓名是"</span> + <span class="hljs-keyword">this</span>.name;
    }

}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test11</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> Exception {
        Person2 p=<span class="hljs-keyword">new</span> Person2(<span class="hljs-string">"wangchen"</span>);
        System.out.println(p);

        Class&lt;?&gt; c=p.getClass();

        <span class="hljs-comment">//定义要修改的属性</span>
        Field f=c.getDeclaredField(<span class="hljs-string">"name"</span>);
        f.setAccessible(<span class="hljs-keyword">true</span>);
        <span class="hljs-comment">//修改属性，传入要设置的对象和值</span>
        f.set(p, <span class="hljs-string">"xiaohua"</span>);
        System.out.println(p);

    }
}

运行结果：
姓名是wangchen
姓名是xiaohua

</code></pre> 
<pre class="prettyprint"><code class=" hljs cs">package cn.cast.reflect;

import java.lang.reflect.Method;

<span class="hljs-comment">/*
 * 实例12：通过反射调用方法
 */</span>
class Person3{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-keyword">int</span> i){
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"数字："</span>+i);

    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span>(String str){
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"说："</span>+str);
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> test12 {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws Exception {
        Person3 p=<span class="hljs-keyword">new</span> Person3();
        Class&lt;?&gt; c=p.getClass();

        <span class="hljs-comment">//GetMethod()方法需要传方法名和类型（数据类型.class）</span>
        Method m1=c.getMethod(<span class="hljs-string">"print"</span>, <span class="hljs-keyword">int</span>.class);
        <span class="hljs-comment">//invoke（）表示调用的意思，需要传对象和参数</span>
        m1.invoke(p, <span class="hljs-number">10</span>);

        Method m2=c.getMethod(<span class="hljs-string">"say"</span>, String.class);
        <span class="hljs-comment">//这里的null不由对象调用，也就是静态方法</span>
        m2.invoke(<span class="hljs-keyword">null</span>, <span class="hljs-string">"hehe"</span>);
    }
}

运行结果：
姓名是wangchen
姓名是xiaohua
</code></pre> 
<pre class="prettyprint"><code class=" hljs cs">package cn.cast.reflect;

import java.lang.reflect.Array;

<span class="hljs-comment">/*
 * 实例13：通过反射操作数组
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> test13 {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        <span class="hljs-keyword">int</span> [] arr={<!-- --><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
        Class&lt;?&gt; c=arr.getClass().getComponentType();<span class="hljs-comment">//返回的是数组元素的class</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"数组类型："</span>+c.getName());
        <span class="hljs-keyword">int</span> len=Array.getLength(arr);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"数组长度："</span>+len);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"遍历数组："</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++){
            System.<span class="hljs-keyword">out</span>.println(Array.<span class="hljs-keyword">get</span>(arr, i));
        }
        System.<span class="hljs-keyword">out</span>.println();
        <span class="hljs-comment">//修改数组 </span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"修改前的第一个元素： "</span> + Array.<span class="hljs-keyword">get</span>(arr, <span class="hljs-number">0</span>));
        Array.<span class="hljs-keyword">set</span>(arr, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"修改后的第一个元素： "</span> + Array.<span class="hljs-keyword">get</span>(arr, <span class="hljs-number">0</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++){
            System.<span class="hljs-keyword">out</span>.println(Array.<span class="hljs-keyword">get</span>(arr, i));
        }
    }
}

运行结果：
数组类型：<span class="hljs-keyword">int</span>
数组长度：<span class="hljs-number">5</span>
遍历数组：
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">4</span>
<span class="hljs-number">5</span>

修改前的第一个元素： <span class="hljs-number">1</span>
修改后的第一个元素： <span class="hljs-number">3</span>
<span class="hljs-number">3</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">4</span>
<span class="hljs-number">5</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c177c3a047a276bd5196f3428711d20/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【linux下编程】MakeFile</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0d9784b7e9086fe4f61559bafc345fc8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">论编程学习方法的重要性</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>