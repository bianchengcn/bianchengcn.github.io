<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>后端 给前端返回图片url_接口返回的是一个图片文件而不是url 前端如何显示？... - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="后端 给前端返回图片url_接口返回的是一个图片文件而不是url 前端如何显示？..." />
<meta property="og:description" content="请求后端接口 返回的时一张图片 如何在img中显示?
preview里查看就是显示一张图片
console.log(img):
.]
用blob createObjectURL转换成地址后前端img还是访问不到的效果
结果
代码
this._http.doGet(this, &#39;createQRCode&#39;, {id: this.lessonId}, (res) =&gt; {
var img = document.createElement(&#39;img&#39;)
const myBlob = new window.Blob([res.data], {type: &#39;image/jpeg&#39;})
console.log(myBlob)
const qrUrl = window.URL.createObjectURL(myBlob)
img.src = qrUrl
img.onload = function () {
window.URL.revokeObjectURL(qrUrl)
}
const imgDiv = document.querySelector(&#39;.qr-div&#39;)
imgDiv.appendChild(img)
})
首先需要设置axios responseType: &#39;blob&#39;
然后直接createObjectURL即可
const qrUrl = window.URL.createObjectURL(res.data)
var img = document.createElement(&#39;img&#39;)
img.src = qrUrl
img.onload = function () {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/a048603dc248a106b8bb439a6626484a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-20T00:07:14+08:00" />
<meta property="article:modified_time" content="2020-12-20T00:07:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">后端 给前端返回图片url_接口返回的是一个图片文件而不是url 前端如何显示？...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>请求后端接口 返回的时一张图片 如何在img中显示?</p> 
 <p>preview里查看就是显示一张图片</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>console.log(img):</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>.]</p> 
 <p>用blob createObjectURL转换成地址后前端img还是访问不到的效果</p> 
 <p>结果</p> 
 <p>代码</p> 
 <p>this._http.doGet(this, 'createQRCode', {id: this.lessonId}, (res) =&gt; {<!-- --></p> 
 <p>var img = document.createElement('img')</p> 
 <p>const myBlob = new window.Blob([res.data], {type: 'image/jpeg'})</p> 
 <p>console.log(myBlob)</p> 
 <p>const qrUrl = window.URL.createObjectURL(myBlob)</p> 
 <p>img.src = qrUrl</p> 
 <p>img.onload = function () {<!-- --></p> 
 <p>window.URL.revokeObjectURL(qrUrl)</p> 
 <p>}</p> 
 <p>const imgDiv = document.querySelector('.qr-div')</p> 
 <p>imgDiv.appendChild(img)</p> 
 <p>})</p> 
 <p>首先需要设置axios responseType: 'blob'</p> 
 <p>然后直接createObjectURL即可</p> 
 <p>const qrUrl = window.URL.createObjectURL(res.data)</p> 
 <p>var img = document.createElement('img')</p> 
 <p>img.src = qrUrl</p> 
 <p>img.onload = function () {<!-- --></p> 
 <p>window.URL.revokeObjectURL(qrUrl)</p> 
 <p>}</p> 
 <p>const imgDiv = document.querySelector('.qr-div')</p> 
 <p>imgDiv.appendChild(img)</p> 
 <p>url、base64、blob，三者之间的转化</p> 
 <p>对于vue项目，我们使用axiso来发送请求，如果传递二进制图片时出现乱码，这个是什么问题？</p> 
 <p>答：</p> 
 <p>axios 默认返回的是 json 文本形式，二进制图片数据被强制转换成了 json 文本形式。</p> 
 <p>解决方案：</p> 
 <p>我们在 axios 里面，responseType 默认返回数据类型是 json，将其改为返回数据类型 blob。</p> 
 <p>export function miniprogramQrcode (params) {<!-- --></p> 
 <p>return axios.post(</p> 
 <p>env.MI_URL + '/XXXX/XXX/XXXX',</p> 
 <p>params,</p> 
 <p>// 将responseType的默认json改为blob</p> 
 <p>{<!-- --></p> 
 <p>responseType: 'blob',</p> 
 <p>emulateJSON: true</p> 
 <p>}).then(res =&gt; {<!-- --></p> 
 <p>if (res.data) {<!-- --></p> 
 <p>return Promise.resolve(res.data)</p> 
 <p>} else {<!-- --></p> 
 <p>throw res</p> 
 <p>}</p> 
 <p>}).catch(err =&gt; {<!-- --></p> 
 <p>return Promise.reject(err)</p> 
 <p>})</p> 
 <p>}</p> 
 <p>接下来，就是处理blob对象，将其显示在前端页面</p> 
 <p>createMiniQrcode (blob) {<!-- --></p> 
 <p>let img = document.createElement('img')</p> 
 <p>img.onload = function (e) {<!-- --></p> 
 <p>// 元素的onload 事件触发后将销毁URL对象, 释放内存。</p> 
 <p>window.URL.revokeObjectURL(img.src)</p> 
 <p>}</p> 
 <p>// 浏览器允许使用URL.createObjectURL()方法，针对 Blob 对象生成一个临时 URL。</p> 
 <p>// 这个 URL 以blob://开头,表明对应一个 Blob 对象。</p> 
 <p>img.src = window.URL.createObjectURL(blob)</p> 
 <p>document.querySelector('.imgQrCode').appendChild(img)</p> 
 <p>}</p> 
 <p>图片在后端的存储方式有哪些？</p> 
 <p>答：</p> 
 <p>一般来说，图片在后端的存储方式分为两种</p> 
 <p>(1)可以将图片以独立文件的形式存储在服务器的指定文件夹中，再将路径存入数据库字段中;</p> 
 <p>(2)将图片转换成二进制流，直接存储到数据库的 Image 类型字段中.</p> 
 <p>对于第一种存储方式，我们前端直接将存储路径赋值给 src 属性即可轻松显示。</p> 
 <p>对于第二种存储方式，我们前端需要将其二进制流交由 blob 对象处理，然后通过 blob 的 API 生成临时 URL 赋值给 src 属性来显示。</p> 
 <p>图片的三种表现形式url、base64、blob，三者之间是否可以转化？</p> 
 <p>答： 可以</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>1. url 转 base64</p> 
 <p>// 原理： 利用canvas.toDataURL的API转化成base64</p> 
 <p>urlToBase64(url) {<!-- --></p> 
 <p>return new Promise ((resolve,reject) =&gt; {<!-- --></p> 
 <p>let image = new Image();</p> 
 <p>image.onload = function() {<!-- --></p> 
 <p>let canvas = document.createElement('canvas');</p> 
 <p>canvas.width = this.naturalWidth;</p> 
 <p>canvas.height = this.naturalHeight;</p> 
 <p>// 将图片插入画布并开始绘制</p> 
 <p>canvas.getContext('2d').drawImage(image, 0, 0);</p> 
 <p>// result</p> 
 <p>let result = canvas.toDataURL('image/png')</p> 
 <p>resolve(result);</p> 
 <p>};</p> 
 <p>// CORS 策略，会存在跨域问题https://stackoverflow.com/questions/20424279/canvas-todataurl-securityerror</p> 
 <p>image.setAttribute("crossOrigin",'Anonymous');</p> 
 <p>image.src = url;</p> 
 <p>// 图片加载失败的错误处理</p> 
 <p>image.onerror = () =&gt; {<!-- --></p> 
 <p>reject(new Error('图片流异常'));</p> 
 <p>};</p> 
 <p>}</p> 
 <p>调用</p> 
 <p>let imgUrL = `http://XXX.jpg`</p> 
 <p>this.getDataUri(imgUrL).then(res =&gt; {<!-- --></p> 
 <p>// 转化后的base64图片地址</p> 
 <p>console.log('base64', res)</p> 
 <p>})</p> 
 <p>2. base64 转 blob</p> 
 <p>// 原理：利用URL.createObjectURL为blob对象创建临时的URL</p> 
 <p>base64ToBlob ({b64data = '', contentType = '', sliceSize = 512} = {}) {<!-- --></p> 
 <p>return new Promise((resolve, reject) =&gt; {<!-- --></p> 
 <p>// 使用 atob() 方法将数据解码</p> 
 <p>let byteCharacters = atob(b64data);</p> 
 <p>let byteArrays = [];</p> 
 <p>for (let offset = 0; offset &lt; byteCharacters.length; offset += sliceSize) {<!-- --></p> 
 <p>let slice = byteCharacters.slice(offset, offset + sliceSize);</p> 
 <p>let byteNumbers = [];</p> 
 <p>for (let i = 0; i &lt; slice.length; i++) {<!-- --></p> 
 <p>byteNumbers.push(slice.charCodeAt(i));</p> 
 <p>}</p> 
 <p>// 8 位无符号整数值的类型化数组。内容将初始化为 0。</p> 
 <p>// 如果无法分配请求数目的字节，则将引发异常。</p> 
 <p>byteArrays.push(new Uint8Array(byteNumbers));</p> 
 <p>}</p> 
 <p>let result = new Blob(byteArrays, {<!-- --></p> 
 <p>type: contentType</p> 
 <p>})</p> 
 <p>result = Object.assign(result,{<!-- --></p> 
 <p>// jartto: 这里一定要处理一下 URL.createObjectURL</p> 
 <p>preview: URL.createObjectURL(result),</p> 
 <p>name: `图片示例.png`</p> 
 <p>});</p> 
 <p>resolve(result)</p> 
 <p>})</p> 
 <p>}</p> 
 <p>调用</p> 
 <p>let base64 = base64.split(',')[1]</p> 
 <p>this.base64ToBlob({b64data: base64, contentType: 'image/png'}).then(res =&gt; {<!-- --></p> 
 <p>// 转后后的blob对象</p> 
 <p>console.log('blob', res)</p> 
 <p>})</p> 
 <p>3. blob 转 base64</p> 
 <p>// 原理：利用fileReader的readAsDataURL，将blob转为base64</p> 
 <p>blobToBase64(blob) {<!-- --></p> 
 <p>return new Promise((resolve, reject) =&gt; {<!-- --></p> 
 <p>const fileReader = new FileReader();</p> 
 <p>fileReader.onload = (e) =&gt; {<!-- --></p> 
 <p>resolve(e.target.result);</p> 
 <p>};</p> 
 <p>// readAsDataURL</p> 
 <p>fileReader.readAsDataURL(blob);</p> 
 <p>fileReader.onerror = () =&gt; {<!-- --></p> 
 <p>reject(new Error('文件流异常'));</p> 
 <p>};</p> 
 <p>});</p> 
 <p>}</p> 
 <p>调用</p> 
 <p>this.blobToBase64(blob).then(res =&gt; {<!-- --></p> 
 <p>// 转化后的base64</p> 
 <p>console.log('base64', res)</p> 
 <p>})</p> 
 <p>在互联网环境中，大访问量，数据库速度和性能方面很重要。一般在数据库存储图片的做法比较少，更多的是将图片路径存储在数据库中，展示图片的时候只需要连接磁盘路径把图片载入进来即可。因为图片是属于大字段。一张图片可能1m到几m。这样的大字段数据会加重数据库的负担，拖慢数据库。在大并发访问的情况下很重要。这是一个经验。去看看dba对数据库性能调优方面的分析都能得到这个答案的：就是图片不要存储在数据库中。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d26d061a21ca1f00ec72856695a62bee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jenkins教程菜鸟_jenkins新手入门教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c19883d5466a07096fdd3c683eb45cd1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cad怎么查找未闭合_CAD应该怎么测量图形？未封闭、不规则的图形要这样测量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>