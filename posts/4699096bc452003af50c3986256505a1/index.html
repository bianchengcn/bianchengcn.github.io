<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端面试基础知识总结 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端面试基础知识总结" />
<meta property="og:description" content="ES6部分 1.let const var 区别 1.let const 具有块级作用域,不存在变量提升2 const是常量,const 定义的基本数据不能改变,但是定义的对象可以通过对象的方法去添加删除.3.let 在统一作用域下面不能重复声明4.var 具有跨级作用域,具有变量声明的提升5.var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错 2.使用箭头函数需要注意什么 1.箭头函数的this不是指向window，而是理他最近的父级作用域（指向是可变的）
3.怎么改变箭头函数中this的指向 call apply bind的区别
1.call apply接受参数的方式不一样,apply接收多个参数组成的数组,call接受的时候若干个参数的列表.
2.bind：不立即执行。而apply、call 立即执行。
bind方法是直接返回一个新的函数，需要手动去调用才能执行。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-W7Jn5HYZ-1630144418153)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210823152034043.png)]
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BqHlWUzm-1630144418154)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210823152053208.png)]
4.模板字符串,模板对象 ${} ``
5.模块的导入导出 export const a
import {a} from “…/…/”
export default a
import a from “…/…/”
使用export 直接导出,导入的时候要加{} ,可以导出多个,导入多个
使用export default 导出,只能导出一个,导入是不需要{}
6.for…of for…in 两者之间的区别 for…in 可以遍历数组,对象.遍历数组的时候输出的是元素的索引,遍历对象的话输出的是对象的键名
for…of 不能遍历对象,会报错,遍历数组的时候输出的是数组的值
7.解构赋值 应用:实现两个变量的值的交换
let a = 1;let b = 2; [a,b] = [b,a]; 8.展开运算符 …" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/4699096bc452003af50c3986256505a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-28T17:54:33+08:00" />
<meta property="article:modified_time" content="2021-08-28T17:54:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端面试基础知识总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="ES6_0"></a>ES6部分</h2> 
<h2><a id="1let_const_var__2"></a>1.let const var 区别</h2> 
<blockquote> 
 <ul><li>1.let const 具有块级作用域,不存在变量提升</li><li>2 const是常量,const 定义的基本数据不能改变,但是定义的对象可以通过对象的方法去添加删除.</li><li>3.let 在统一作用域下面不能重复声明</li><li>4.var 具有跨级作用域,具有变量声明的提升</li><li>5.var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错</li></ul> 
</blockquote> 
<h2><a id="2_10"></a>2.使用箭头函数需要注意什么</h2> 
<blockquote> 
 <p>1.箭头函数的this不是指向window，而是理他最近的父级作用域（指向是可变的）</p> 
</blockquote> 
<h2><a id="3this_14"></a>3.怎么改变箭头函数中this的指向</h2> 
<blockquote> 
 <p>call apply bind的区别</p> 
 <p>1.call apply接受参数的方式不一样,apply接收多个参数组成的数组,call接受的时候若干个参数的列表.</p> 
 <p>2.bind：不立即执行。而apply、call 立即执行。</p> 
 <pre><code class="prism language-text">bind方法是直接返回一个新的函数，需要手动去调用才能执行。
</code></pre> 
 <p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-W7Jn5HYZ-1630144418153)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210823152034043.png)]</p> 
 <p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BqHlWUzm-1630144418154)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210823152053208.png)]</p> 
</blockquote> 
<h2><a id="4_32"></a>4.模板字符串,模板对象</h2> 
<blockquote> 
 <p>${} ``</p> 
</blockquote> 
<h2><a id="5_36"></a>5.模块的导入导出</h2> 
<blockquote> 
 <p>export const a</p> 
 <p>import {a} from “…/…/”</p> 
 <p>export default a</p> 
 <p>import a from “…/…/”</p> 
 <p>使用export 直接导出,导入的时候要加{} ,可以导出多个,导入多个</p> 
 <p>使用export default 导出,只能导出一个,导入是不需要{}</p> 
</blockquote> 
<h2><a id="6forof_forin__50"></a>6.for…of for…in 两者之间的区别</h2> 
<blockquote> 
 <ol><li> <p>for…in 可以遍历数组,对象.遍历数组的时候输出的是元素的索引,遍历对象的话输出的是对象的键名</p> </li><li> <p>for…of 不能遍历对象,会报错,遍历数组的时候输出的是数组的值</p> </li></ol> 
</blockquote> 
<h2><a id="7_58"></a>7.解构赋值</h2> 
<blockquote> 
 <p>应用:实现两个变量的值的交换</p> 
 <pre><code class="prism language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>

</code></pre> 
</blockquote> 
<h2><a id="8_68"></a>8.展开运算符</h2> 
<blockquote> 
 <p>…</p> 
</blockquote> 
<h2><a id="9promise_72"></a>9.promise的应用</h2> 
<blockquote> 
 <h4><a id="1promise_74"></a>1.什么是promise</h4> 
 <p>Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大</p> 
 <h4><a id="2promise_78"></a>2.如何使用promise</h4> 
 <h4><a id="3promise_82"></a>3.promise有哪些实例方法</h4> 
 <blockquote> 
  <h5><a id="1Promiseall_84"></a>1.Promise.all()</h5> 
  <p><code>Promise.all</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例</p> 
  <p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况</p> 
  <blockquote> 
   <p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成0数组，传递给<code>p</code>的回调函数。</p> 
   <p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p> 
  </blockquote> 
  <h5><a id="Promiserace_94"></a>.Promise.race()</h5> 
  <blockquote> 
   <p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数</p> 
  </blockquote> 
 </blockquote> 
 <h4><a id="4promise_98"></a>4.promise的特点</h4> 
 <blockquote> 
  <ol><li>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果</li></ol> 
 </blockquote> 
</blockquote> 
<h2><a id="10Set_Map_105"></a>10.Set Map(应用在哪些地方)</h2> 
<blockquote></blockquote> 
<h2><a id="11Promise_SetTimeout_asyncawait_109"></a>11.Promise SetTimeout async/await的区别一级执行顺序</h2> 
<blockquote> 
 <p>1.事件循环中分为宏任务队列和微任务队列</p> 
 <p>用来解决多层嵌套的回调方法</p> 
 <p>2.其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行</p> 
 <p>3.promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行</p> 
 <p>4.async函数表示函数里面可能会有异步方法，await后面跟一个表达式</p> 
 <p>5.async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码</p> 
 <p>微任务&gt;宏任务</p> 
 <p>微任务:then promise.then，proness.nextTick</p> 
 <p>宏任务:Promise settimeout setInterval</p> 
</blockquote> 
<h2><a id="12Promise_then__129"></a>12.Promise构造函数是同步执行还是异步执行，那么 then 方法呢？</h2> 
<blockquote> 
 <p>promise构造函数是同步执行的，then方法是异步执行的</p> 
</blockquote> 
<h2><a id="13_promisecatch_133"></a>13 .promise有几种状态，什么时候会进入catch？</h2> 
<blockquote> 
 <p>三个状态：pending、fulfilled、reject</p> 
 <p>两个过程：padding -&gt; fulfilled、padding -&gt; rejected</p> 
 <p>当pending为rejectd时，会进入catch</p> 
</blockquote> 
<h2><a id="14_141"></a>14.普通函数和箭头函数的区别</h2> 
<blockquote></blockquote> 
<h2><a id="js_145"></a>js部分</h2> 
<h2><a id="_1JS_147"></a># 1.JS的基本数据类型和引用数据类型有哪些，两者区别</h2> 
<blockquote> 
 <p>基本数据类型-&gt;string、number、Boolean、null、undefined、symbol</p> 
 <p>引用数据类型-&gt;array、object、function</p> 
 <p>基本数据类型是保存在栈内存中，操作的是值，改变源数据不会影响新的变量</p> 
 <p>引用数据类型保存在堆内存中，操作的是地址，改变其中一个会影响另一个</p> 
 <p>引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。</p> 
</blockquote> 
<h2><a id="2_159"></a>2.数据类型中为假的有哪些</h2> 
<blockquote> 
 <p>false undefined 0 NaN 空字符串 null</p> 
</blockquote> 
<h2><a id="3nullundefined_163"></a>3.null和undefined的区别</h2> 
<blockquote> 
 <p>Null：代表空对象指针。现在没有，将来可能会有</p> 
 <p>undefined：空，未定义。现在没有，将来也不会有（Js中独有的数据类型）</p> 
</blockquote> 
<h2><a id="4_169"></a>4.检测数据类型的几种方式，</h2> 
<blockquote> 
 <p>typeof、instanceof、constructor、Object.prototype.toString.call()</p> 
 <p>typeof只针对基本数据类型，遇到引用数据类型是不起作用的（无法细分对象）都是Object</p> 
 <blockquote> 
  <p>typeOf 可以用来判断 function string number boolean undefined</p> 
 </blockquote> 
 <pre><code class="prism language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> name<span class="token operator">:</span><span class="token string">"john"</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"语文"</span><span class="token punctuation">,</span><span class="token string">"数学"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// typeof(Person) =&gt; function</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token string">'我是字符串'</span> <span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token number">66</span> <span class="token punctuation">;</span>    <span class="token comment">// number</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">;</span>   <span class="token comment">// boolean</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>  <span class="token comment">// undefined</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>   <span class="token comment">// object</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\d{5,20}$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
 <p>instanceof用来判断对象和函数，不适合判断字符串和数字,</p> 
 <p>可以用来判断Object array function 正则</p> 
 <pre><code class="prism language-js">a <span class="token keyword">instanceof</span> <span class="token class-name">B</span> 判断<span class="token constant">A</span>是不是<span class="token constant">B</span>的实例

<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token string">'我是字符串'</span> <span class="token punctuation">;</span>   　　<span class="token comment">// console.log( arr instanceof String ) =&gt; false</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token number">66</span> <span class="token punctuation">;</span>      　　 <span class="token comment">// console.log( arr instanceof Number ) =&gt;false</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">;</span>     　　 <span class="token comment">// console.log( arr instanceof Boolean ) =&gt;false</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"语文"</span><span class="token punctuation">,</span><span class="token string">"数学"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>　　 <span class="token comment">// console.log( arr instanceof Array ) =&gt;true</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> name<span class="token operator">:</span><span class="token string">"john"</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 　　 <span class="token comment">// console.log( arr instanceof Object ) =&gt;true</span>
<span class="token keyword">var</span> <span class="token function-variable function">arr</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//console.log(arr instanceof Function)=&gt;true</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>      <span class="token comment">// console.log(arr instanceof Object)=&gt;false</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// console.log(arr instanceof Object)=&gt;false</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\d{5,20}$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>    <span class="token comment">// console.log(arr instanceof RegExp)=&gt;true</span>
</code></pre> 
 <p>constructor是Object其中的一个属性。默认指向实例的构造函数</p> 
 <p>通过Object.prototype.toString方法，判断某个对象值属于哪种内置类型</p> 
 <pre><code class="prism language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token string">'我是字符串'</span> <span class="token punctuation">;</span>   <span class="token comment">//[object String]</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token number">66</span> <span class="token punctuation">;</span>        <span class="token comment">//[object Number]</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">;</span>       <span class="token comment">//[object Boolean]</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"语文"</span><span class="token punctuation">,</span><span class="token string">"数学"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//[object Array]</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> name<span class="token operator">:</span><span class="token string">"john"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//[object Object]</span>
<span class="token keyword">var</span> <span class="token function-variable function">arr</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//[object Function]</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>      <span class="token comment">//[object Undefined]</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>         <span class="token comment">//[object Null]</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\d{5,20}$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>     <span class="token comment">//[object RegExp]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
</blockquote> 
<h2><a id="5innerHTMLinnerText_232"></a>5.innerHTML和innerText区别</h2> 
<blockquote> 
 <p>innerHTML可以获取结构和文本</p> 
 <p>innerText只获取文本内容</p> 
</blockquote> 
<h2><a id="6_238"></a>6.数组常用的一些方法有哪些</h2> 
<blockquote> 
 <p>​ push()向数组末尾添加数据<br> 　　pop()删除数组最后一项<br> 　　unshift()向数组首位添加新内容<br> 　　shift()删除数组的第一项<br> 　　slice()按照条件查找出其中的部分内容<br> 　　splice()对数组进行增删改<br> 　　join()用指定的分隔符对数组拼接<br> 　　concat()用于连接两个或多个数组<br> 　　indexOf()/lastIndexOf()当前值在数组中第一次/最后一次出现的位置索引<br> 　　includes()判断一个数组是否包含指定的值<br> 　　sort()对数组进行排序<br> 　　reverse()把数组倒过来排列<br> 　　forEach()循环遍历数组每一项</p> 
</blockquote> 
<h2><a id="7_254"></a>7.重绘和回流（重排）区别，什么情况会触发重排和重绘</h2> 
<blockquote> 
 <p>### 什么是重绘</p> 
 <p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</p> 
 <p>#### 什么是回流</p> 
 <p>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。</p> 
 <p></p> 
 <p>当页面元素(宽高，位置)发生改变，回导致页面重排，浏览器会根据新位置进行重新渲染</p> 
 <p>回流必将引起重绘，而重绘不一定会引起回流。重绘相对于回流性能消耗较低</p> 
 <p></p> 
 <p>任何改变用来构建渲染树的信息都会导致一次重排或重绘</p> 
 <p>比如添加、删除、更新DOM节点，通过display: none隐藏，调整样式属性，调整窗口大小，滚动等等</p> 
</blockquote> 
<h2><a id="8_276"></a>8.请解释什么是暂时性死区</h2> 
<blockquote> 
 <p>let 和 const 声明的变量不存在变量提升，其作用域都是块级作用域，凡是在声明变量之前使用变量就会报错，</p> 
 <p>所以，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</p> 
</blockquote> 
<h2><a id="9HTML_282"></a>9.如何添加HTML元素的事件，有几种方法</h2> 
<blockquote> 
 <p>标签之中直接添加 οnclick=“fn()”</p> 
 <p>JS添加 btn.onclick = method</p> 
 <p>绑定事件 obj.addEventListener(‘click’, method, false)</p> 
</blockquote> 
<h2><a id="10_290"></a>10.什么是闭包，有什么优缺点</h2> 
<blockquote> 
 <p>在Js中当函数套函数，子函数使用了父函数的参数或者变量，并且子函数被外界所使用（没有释放），</p> 
 <p>此时父函数的参数和变量，是不会被浏览器垃圾回收机制立马收回，这个时候父级形成了闭包环境。</p> 
 <p>优点：</p> 
 <p>保护—闭包会形成私有作用域，保护里面的私有变量不受外界干扰</p> 
 <p>存储—闭包可以把父函数的参数或变量存储起来</p> 
 <p>缺点：</p> 
 <p>相对于普通函数要消耗内存，闭包使用不当将会在IE(IE9之前)中造成内存泄漏</p> 
</blockquote> 
<h2><a id="11_308"></a>11.什么是原型，什么是原型链，两者关系</h2> 
<blockquote> 
 <p>我们每声明一个对象的时候,他都存在一个内部属性prototype 这个prototype就是这个对象的原型</p> 
 <p></p> 
 <p>原型(prototype)：函数自带的属性,函数的实例化对象找不到某个属性或者方法，一定会去构造函数的原型下去找</p> 
 <p>原型链(<strong>proto</strong>)：实例化对象身上自带一个属性</p> 
 <p>原型关系链：函数的实例化对象找不到某个属性或方法，一定会去构造函数的原型下去找，如果还没有会去原型下的原型链查找，直到找到Object.prototype为止</p> 
 <p>两者关系：实例化对象的原型链 === 构造函数的原型</p> 
</blockquote> 
<h2><a id="12this_322"></a>12.简述this不同情况下的指向问题</h2> 
<blockquote> 
 <p>1）全局下的this是window<br> 　　　　2）单纯的函数名+括号执行，this是window<br> 　　　　3）匿名函数自执行，this是window<br> 　　　　4）定时器中的this是window<br> 　　　　5）事件触发，触发谁this就是谁<br> 　　　　6）对象方法中，.前面是谁 this就指向谁<br> 　　　　7）构造函数中this是实例化对象<br> 　　　　8）严格模式下this是undefined<br> 　　　　9）箭头函数中this指向上一级<br> 　　　　10）箭头函数中this暴露在外面就指向window</p> 
</blockquote> 
<h2><a id="13_335"></a>13.浅拷贝和深拷贝，实现的几种方式</h2> 
<blockquote> 
 <p>浅拷贝只复制某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存</p> 
 <p>深拷贝会开辟一个新的栈，新对象跟原对象不共享内存，修改新对象不影响原对象</p> 
 <p>简单来说假如B复制了A，当修改A时候B如果跟着改变就是浅拷贝，B没有改变则为深拷贝</p> 
 <p>浅拷贝实现方式：</p> 
 <p>Object.assign()、Array.prototype.concat()、Array.prototype.slice()</p> 
 <p>深拷贝实现方式：</p> 
 <p>JSON.parse(JSON.stringify())、手写递归,$.extend()</p> 
 <p>​ Object.assign({},“要拷贝的对象”) 能实现深拷贝</p> 
 <p>​ 对象和数组只有一层是 扩展运算符可以实现深拷贝</p> 
 <p>​ 数组的合并 a.concat(b)</p> 
 <p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vzrPmYtO-1630144418156)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210823150350761.png)]</p> 
 <p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-I1iIoPVu-1630144418157)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210823150607209.png)]</p> 
</blockquote> 
<h2><a id="14_361"></a>14.什么时候会用到闭包</h2> 
<h2><a id="15_363"></a>15.什么是重绘,什么是回流</h2> 
<blockquote> 
 <p>什么是回流？</p> 
 <p>当一个元素自身的宽高，布局，显示或隐藏，或元素内部的文字结构发生变化，导致需要重新构建页面的时候，就产生了回流</p> 
 <p>什么是重绘？</p> 
 <p>当一个元素自身的宽高，布局，及显示或隐藏没有改变，而只是改变了元素的外观风格的时候，就产生了重绘</p> 
 <p>什么时候会进行回流？</p> 
 <p>1.添加或者删除可见的DOM元素的时候</p> 
 <p>2.元素的位置发生改变</p> 
 <p>3.元素的尺寸发生改变</p> 
 <p>4.内容改变</p> 
 <p>5.页面第一次渲染的时候</p> 
 <p>什么时候会进行重绘？</p> 
 <p>列举一些相关的CSS样式：color、background、background-size、visibility、box-shadow</p> 
</blockquote> 
<h2><a id="16_389"></a>16.防抖和节流</h2> 
<blockquote> 
 <p>防抖和节流都是为了解决一些频繁触发的事件而做出的不同的操作</p> 
 <p>防抖:就是在触发事件后n秒内函数只能执行一次,如果在n秒内函数又被触发了,那就会重新计算函数执行时间,()</p> 
 <pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">defounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token keyword">var</span> t<span class="token operator">=</span><span class="token keyword">null</span>
 <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
         <span class="token function">clearInterval</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
     t<span class="token operator">=</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>
         <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>delay<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p>节流: 是连续被触发的时间在n秒内只执行一次,函数执行的时间间隔是相同的</p> 
 <pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token keyword">var</span> begin<span class="token operator">=</span><span class="token number">0</span>
 <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
     <span class="token keyword">var</span> curtime<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">gettime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>curtime<span class="token operator">-</span>begin<span class="token operator">&gt;</span>delay<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
         <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">)</span>
         begin<span class="token operator">=</span>cur
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
</blockquote> 
<h2><a id="17arguments_424"></a>17.arguments是什么,特性</h2> 
<blockquote> 
 <p>当调用函数的时候，传入的实参数量大于函数定义时的形参数量，这种情况下是没办法直接获得未命名值的引用（实参比形参多）。这个时候可以通过arguments来获取到所有的实参</p> 
 <pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// arguments 就是函数的所有实参</span>
     <span class="token comment">// 形参 形式上的参数</span>
     <span class="token function">fun</span><span class="token punctuation">(</span><span class="token string">'tom'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span>name<span class="token operator">:</span><span class="token string">"arry"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
 <p>注意: arguments是伪数组,除了length属性之外<strong>数组的其他属性，arguments几乎是没有的！</strong></p> 
 <p>最后还需要注意一点：<strong>ES6中箭头函数里是无法使用arguments的！！！</strong></p> 
 <p>箭头函数的arguemnts 是父级作用域的arguemnts。<br> 所以看箭头函数有没有，就看箭头函数的父级作用域有没有</p> 
</blockquote> 
<h2><a id="Vue_444"></a>Vue部分</h2> 
<h2><a id="1vuevue_446"></a>1.对vue的理解,vue有什么特点</h2> 
<blockquote> 
 <p>1.vue是一款MVVM框架，基于双向绑定数据，当数据发生变化时候，vue自身会进行一些运算</p> 
 <p>2.特点:双向数据绑定,数据驱动.组件化,模块友好</p> 
</blockquote> 
<h2><a id="2Vue_452"></a>2.简述Vue双向数据绑定的原理</h2> 
<blockquote> 
 <p>主要是通过Object对象的defineProperty属性，重写data的set和get函数来实现的,实现对data数据的监听</p> 
 <p>vue是通过数据劫持的方式来做数据绑定，最核心的方法就是通过Object.defineProperty()来实现对属性的劫持</p> 
 <p>在设置或者获取的时候我们就可以在get或者set方法里加入其他的触发函数，达到监听数据变动的目的</p> 
</blockquote> 
<h2><a id="3mvvm_460"></a>3.什么是mvvm</h2> 
<blockquote> 
 <p>MVVM是Model-View-ViewModel的缩写</p> 
 <p>Model层代表数据模型</p> 
 <p>View代表组件视图，负责将数据模型转化成UI展现出来</p> 
 <p>ViewModel是一个同步 View 和 Model 的对象（双向绑定）</p> 
 <p>在MVVM中，View和Model之间并没有直接的联系，而是通过ViewModel进行交互，</p> 
 <p>Model和ViewModel之间的交互是双向的，因此 通过视图操作数据，也能通过数据操作视图</p> 
</blockquote> 
<h2><a id="4vuekeepalive_474"></a>4.说一下vue的生命周期，当使用keep-alive属性时，会增加哪两个生命周期</h2> 
<blockquote> 
 <p>1.befoeCreate created beforemount mounted beforeupdate updated beforeDestroy destoryed</p> 
 <p>2.在被keep-alive包含的组件/路由中，会多出两个生命周期的钩子:</p> 
 <p>activated 与 deactivated</p> 
</blockquote> 
<h2><a id="5vue_482"></a>5.<strong>列举vue的几种常用指令</strong></h2> 
<blockquote> 
 <p>v-if、v-show、v-for、v-on、v-bind、v-model、v-once</p> 
</blockquote> 
<h2><a id="6vuevifvshow_486"></a>6.vue中v-if和v-show的区别</h2> 
<blockquote> 
 <p>v-if和v-show都是用来控制元素的渲染</p> 
 <p>v-if是根据后面数据的真假，来判断DOM的添加删除等操作</p> 
 <p>v-show只是在修改元素的css样式（display属性值）</p> 
 <p>v-if如果初始渲染条件为真，就渲染，反之就不渲染</p> 
 <p>v-show不管初始条件是否为真，都会被渲染</p> 
 <p>v-if有更高的切换消耗，不适合做频繁的切换</p> 
 <p>v-show有更高的初始渲染消耗，适合做频繁的切换</p> 
</blockquote> 
<h2><a id="7vuekey_502"></a>7.vue中key值的作用</h2> 
<blockquote> 
 <p>key的作用主要是为了更高效的更新虚拟dom,原理就是vue在patch的过程中通过key可以精准判断两个节点是否是同一个,从而避免频繁的更新不同的dom元素,减少dom的操作量,提高性能</p> 
 <p>使用key，vue会基于key的变化重新排列元素顺序，并且移除key不存在的元素</p> 
 <h4><a id="key_508"></a>key的作用就是更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的</h4> 
</blockquote> 
<h2><a id="8data_510"></a>8.组件中data为什么是函数</h2> 
<blockquote> 
 <p>如果data是一个对象,根据js Object是引用数据类型,这样没复用一次组件,每个组件的data都是指向内存的同一个地址,一个组件内数据改变其他也会被改变的</p> 
 <p>data是一个函数,复用组件时会开辟一个独立的对象,每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响</p> 
 <p><strong>JavaScript只有函数构成作用域(注意理解作用域，只有函数{}构成作用域,对象的{}以及if(){}都不构成作用域),data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。</strong></p> 
 <p>不是必须是函数的,也可以是对象的,源码中最后过滤出来的就是对象,写函数的原因是因为保证了这个对象是独立的,如果可以保证你写的对象是唯一的,不会被别的地方引用到,也可以写对象不用谢函数</p> 
</blockquote> 
<h2><a id="9vuecomputedwatch_522"></a>9.vue中computed和watch的区别</h2> 
<blockquote> 
 <h4><a id="computed_526"></a>computed是计算属性</h4> 
 <p>1.支持缓存，只有依赖数据发生改变，才会重新进行计算</p> 
 <p>2.不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p> 
 <p>3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过的数据通过计算得到的</p> 
 <p>4.如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</p> 
 <p>5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p> 
 <h4><a id="watch_538"></a>watch是侦听属性</h4> 
 <p>1.不支持缓存，数据变，直接会触发相应的操作；</p> 
 <p>2.watch支持异步；</p> 
 <p>3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p> 
 <p>4.当一个属性发生变化时，需要执行对应的操作；一对多</p> 
 <p>computed能够监听vue数据上的变化，页面上来就执行一次，每改变一次数据就又触发，在操作数据的时候，会派生出另一个事情</p> 
 <p>watch当指定数据发生变化时候触发。一开始不会触发，只有指定的数据发生变化就又触发一次</p> 
 <p>watch可以deep深度添加，computed不可以</p> 
</blockquote> 
<h2><a id="10vue_556"></a>10.说一下vue组件之间的传递</h2> 
<blockquote> 
 <p>1.父级传递子级：</p> 
 <p>首先在子组件上加一个v-bind:自定义属性,等于父级的数据，子组件通过props方法接收数据</p> 
 <p>2.子级传递父级：</p> 
 <p>在子组件上绑定一个自定义事件，并且传入父级的“事件”处理函数</p> 
 <p>在子组件内部使用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          e 
         
        
          m 
         
        
          i 
         
        
          t 
         
        
          监 
         
        
          听 
         
        
          这 
         
        
          个 
         
        
          自 
         
        
          定 
         
        
          义 
         
        
          事 
         
        
          件 
         
        
          ， 
         
        
          t 
         
        
          h 
         
        
          i 
         
        
          s 
         
        
          . 
         
        
       
         emit监听这个自定义事件，this. 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">监</span><span class="mord cjk_fallback">听</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">义</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span></span>emit(‘自定义事件名’,参数)</p> 
 <p>3.兄弟组件之间传递</p> 
 <p>eventbus</p> 
 <p>this.<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          e 
         
        
          m 
         
        
          i 
         
        
          t 
         
        
          ( 
         
        
          ) 
         
        
          去 
         
        
          触 
         
        
          发 
         
        
          t 
         
        
          h 
         
        
          i 
         
        
          s 
         
        
          . 
         
        
       
         emit()去触发 this. 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">去</span><span class="mord cjk_fallback">触</span><span class="mord cjk_fallback">发</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span></span>on()去接收</p> 
 <p>4.this.$refs.属性名可以获取到组件的实例</p> 
 <p>​</p> 
</blockquote> 
<h2><a id="11vfor_vif_why_578"></a>11.v-for v-if能一块使用吗 why</h2> 
<blockquote> 
 <p>当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中,将会影响速度，尤其是当之需要渲染很小一部分的时候。</p> 
</blockquote> 
<h2><a id="12_vue_582"></a>12 .vue页面在加载父子组件的时候生命周期执行顺序</h2> 
<blockquote> 
 <p>加载渲染过程</p> 
 <p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p> 
 <p>子组件更新过程<br> 　　父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p> 
 <p>父组件更新过程<br> 　　父beforeUpdate-&gt;父updated</p> 
 <p>销毁过程<br> 　　父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p> 
</blockquote> 
<h2><a id="13vuerouterroute_597"></a>13.vue中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         r 
        
       
         o 
        
       
         u 
        
       
         t 
        
       
         e 
        
       
         r 
        
       
         和 
        
       
      
        router和 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord cjk_fallback">和</span></span></span></span></span>route区别</h2> 
<blockquote> 
 <p>$router 相当于是路由器,管理各个路由对象之间的跳转</p> 
 <p>常用方法:this.<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          r 
         
        
          o 
         
        
          u 
         
        
          t 
         
        
          e 
         
        
          r 
         
        
          . 
         
        
          p 
         
        
          u 
         
        
          s 
         
        
          h 
         
        
          ( 
         
        
          ) 
         
        
          t 
         
        
          h 
         
        
          i 
         
        
          s 
         
        
          . 
         
        
       
         router.push() this. 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span></span>router.replace() this.$router.go()</p> 
 <p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          r 
         
        
          o 
         
        
          u 
         
        
          t 
         
        
          e 
         
        
          是 
         
        
          路 
         
        
          由 
         
        
          对 
         
        
          象 
         
        
          , 
         
        
          通 
         
        
          过 
         
        
          t 
         
        
          h 
         
        
          i 
         
        
          s 
         
        
          . 
         
        
       
         route是路由对象,通过this. 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span></span>route可以访问到相对应的路由信息</p> 
 <p>params query path name</p> 
</blockquote> 
<h2><a id="14_vue_607"></a>14. vue路由跳转传参的几种类型</h2> 
<blockquote> 
 <p>this.$route.push(“xxxxx”)</p> 
 <p>this.$route.push(name:“xxx”,params:"")</p> 
 <p>相当于post请求,传递的参数不会跟在url后面,可以通过this,$route.params()获取到参数</p> 
 <p>this.$route.push(path:"",query:"")</p> 
 <p>相当于get请求,传递的参数会跟在url后面,可以通过this.$route.query()获取</p> 
 <p>path 和params不能同时传递 ,会忽略params传递的参数</p> 
</blockquote> 
<h2><a id="15Vue_watch_621"></a>15.Vue watch的用法</h2> 
<blockquote> 
 <p>1.watch对应一个对象,建是观察值的表达式,值是相应的回调方法,值可以是方法名,可以是对象</p> 
 <p>如果我们想让值最初时候watch就执行就用到了 <code>handler</code>和<code>immediate</code>属性</p> 
 <pre><code class="prism language-js">　　　watch<span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
　　　　　　　　<span class="token function">example0</span><span class="token punctuation">(</span><span class="token parameter">curVal<span class="token punctuation">,</span>oldVal</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
　　　　　　　　　　console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>curVal<span class="token punctuation">,</span>oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
　　　　　　　　<span class="token punctuation">}</span><span class="token punctuation">,</span>
　　　　　　　　example1<span class="token operator">:</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token comment">//值可以为methods的方法名</span>
　　　　　　　　example2<span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
　　　　　　　　　<span class="token comment">//注意：当观察的数据为对象或数组时，curVal和oldVal是相等的，因为这两个形参指向的是同一个数据对象</span>
　　　　　　　　　　<span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">curVal<span class="token punctuation">,</span>oldVal</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
　　　　　　　　　　　　console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>curVal<span class="token punctuation">,</span>oldVal<span class="token punctuation">)</span>
　　　　　　　　　　<span class="token punctuation">}</span><span class="token punctuation">,</span>
　　　　　　　　　　deep<span class="token operator">:</span><span class="token boolean">true</span>
　　　　　　　　<span class="token punctuation">}</span>
　　　　　　<span class="token punctuation">}</span><span class="token punctuation">,</span>
　　　　　　methods<span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
　　　　　　　　<span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">curVal<span class="token punctuation">,</span>oldVal</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
　　　　　　　　　　conosle<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>curVal<span class="token punctuation">,</span>oldVal<span class="token punctuation">)</span>
　　　　　　　　<span class="token punctuation">}</span>
　　　　　　<span class="token punctuation">}</span>

</code></pre> 
</blockquote> 
<h2><a id="16ObjectdefinePropertyProxy_651"></a>16.Object.defineProperty和Proxy区别</h2> 
<blockquote> 
 <pre><code class="prism language-js">  <span class="token comment">// vue2.0的响应式</span>
   <span class="token keyword">let</span> p<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  <span class="token comment">//添加新属性的时候捕获不到,删除已存在的也捕获不到</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span>
      configurable<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"有人读取name时,我会被调用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">return</span> person<span class="token punctuation">.</span>name
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"有人修改name是,我会被调用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          person<span class="token punctuation">.</span>name<span class="token operator">=</span>value
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
 <pre><code class="prism language-js"><span class="token comment">// vue 3.0的响应式</span>
     <span class="token comment">// proxy()</span>
     <span class="token comment">// 第一个参数 p代理的目标 </span>
     <span class="token comment">// 第二个参数 对代理对象的操作,不能为null,可以设置{}</span>
     <span class="token comment">// p映射person</span>
     <span class="token comment">//    代理对象     目标对象</span>
     <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
         <span class="token function">get</span><span class="token punctuation">(</span>targar<span class="token punctuation">,</span>propName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
             <span class="token comment">// target 是指目标对象，property 是被获取的属性名</span>
             console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"读取了p的某个属性"</span><span class="token punctuation">,</span>targar<span class="token punctuation">,</span>targar<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token keyword">return</span> targar<span class="token punctuation">[</span>propName<span class="token punctuation">]</span>
         <span class="token punctuation">}</span><span class="token punctuation">,</span>
         <span class="token function">set</span><span class="token punctuation">(</span>targar<span class="token punctuation">,</span>propName<span class="token punctuation">,</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
             console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"修改了p的某个属性"</span><span class="token punctuation">,</span>targar<span class="token punctuation">,</span>targar<span class="token punctuation">,</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
             targar<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token operator">=</span>newValue
         <span class="token punctuation">}</span><span class="token punctuation">,</span>
         <span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token parameter">targar<span class="token punctuation">,</span>propName</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
             console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"删除了p的某个属性"</span><span class="token punctuation">,</span>targar<span class="token punctuation">,</span>targar<span class="token punctuation">,</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token keyword">return</span> <span class="token keyword">delete</span> targar<span class="token punctuation">[</span>propName<span class="token punctuation">]</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre> 
 <p>Proxy的优势如下:</p> 
 <p>Object.defineProperty需要通过对对象的遍历去做出属性的改变,不能新增属性,或删除属性</p> 
 <p>1.Proxy可以直接监听对象⽽⾮属性 ,增删改查都可以。</p> 
 <p>2.Proxy可以直接监听数组的变化 。</p> 
 <p>3.Proxy有多达13种拦截⽅法,不限于apply、ownKeys、deleteProperty、has等等是 Object.defineProperty 不具备的 。</p> 
 <p>4.Proxy返回的是⼀个新对象,我们可以只操作新的对象达到⽬的,⽽ Object.defineProperty 只能遍历对象属性直接修改</p> 
</blockquote> 
<h2><a id="_17Vue_709"></a># 17.你对Vue项目进行了哪些优化</h2> 
<blockquote> 
 <p>不在模板里面写过多表达式</p> 
 <p>循环调用子组件时添加key</p> 
 <p>频繁切换的使用v-show，不频繁切换的使用v-if</p> 
 <p>尽量少用float，可以用flex</p> 
 <p>按需加载，可以用require或者import()按需加载需要的组件</p> 
</blockquote> 
<h2><a id="18vue_723"></a>18.怎么在vue中使用动画</h2> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RKJU7N9f-1630144418158)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210821143223920.png)]</p> 
<h2><a id="19nextTick_727"></a>19.nextTick的理解()</h2> 
<blockquote> 
 <p>为什么说在this.$nextTick里面可以拿到dom更新后的值呢？</p> 
 <p>一般来说nextTick，就是在dom渲染完了之后才会执行</p> 
 <blockquote> 
  <ol><li>执行完当前宏任务script，立即执行微任务</li><li>微任务执行完毕后进行页面渲染</li><li>页面渲染完毕，开始执行$nextTick</li></ol> 
 </blockquote> 
</blockquote> 
<h2><a id="20vueprops_737"></a>20.vue中父组件向子组件传递数据,子组件为什么不能修改props数据</h2> 
<blockquote> 
 <p>组件是可复用的，假设该子组件被复用了n次，当某一个组件意外地更改了其接受到的props数据 ----&gt; 意味着，同时更改了父组件中相对应的属性值 ----&gt; 意外地更改其它(n-1)个子组件中的 props数据，引起混乱</p> 
 <p>但有存在某些情况：必须对父组件传递过来的props进行转换处理，<strong>利用computed计算属性对数据进行处理。</strong></p> 
</blockquote> 
<h2><a id="21_743"></a>21.介绍下什么是单页面应用</h2> 
<blockquote> 
 <p>单页面 :指只有一个主页面的应用，一开始只需加载一次 <code>js,css</code> 等相关资源。所有的内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅刷新局部资源。</p> 
</blockquote> 
<h2><a id="22__vueuniapp_747"></a>22. vue,小程序,uni-app的生命周期</h2> 
<blockquote> 
 <pre><code>  vue：
  beforeCreate（创建前）
  created（创建后）
  beforeMount(载入前),（挂载）
  mounted（载入后）
  beforeUpdate（更新前）
  updated（更新后）
  beforeDestroy（销毁前）
  destroyed（销毁后）
  小程序,uni-app： 
  1. onLoad：首次进入页面加载时触发，可以在 onLoad 的参数中获取打开当前页面路径中的参数。
  2. onShow：加载完成后、后台切到前台或重新进入页面时触发
  3. onReady：页面首次渲染完成时触发
  4. onHide：从前台切到后台或进入其他页面触发
  5. onUnload：页面卸载时触发
  6. onPullDownRefresh：监听用户下拉动作
  7. onReachBottom：页面上拉触底事件的处理函数
  8. onShareAppMessage：用户点击右上角转发
</code></pre> 
</blockquote> 
<h2><a id="23uniappH5_768"></a>23.uniapp进行条件编译的两种方法？小程序端和H5的代表值是什么？</h2> 
<blockquote> 
 <pre><code>  通过 #ifdef、#ifndef 的方式
  H5 ： H5
  MP-WEIXIN ： 微信小程序
</code></pre> 
</blockquote> 
<h2><a id="thisnextTick_775"></a>this.$nextTick()的作用，什么时候会使用到</h2> 
<blockquote> 
 <p>this.$nextTick这个方法作用是当数据被修改后使用这个方法会回调获取更新后的dom再渲染出来</p> 
</blockquote> 
<h2><a id="css_777"></a>css部分</h2> 
<h2><a id="1CSS_779"></a>1.如何通过CSS绘制一个三角形</h2> 
<p>https://github.com/noxussj/Interview-Questions/issues/16</p> 
<pre><code class="prism language-css"><span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
<span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
<span class="token property">border</span><span class="token punctuation">:</span> 50px solid<span class="token punctuation">;</span>
<span class="token property">border-color</span><span class="token punctuation">:</span> green transparent transparent transparent<span class="token punctuation">;</span>
<span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>
</code></pre> 
<h2><a id="2CSS_791"></a>2.谈谈你对CSS选择器以及优先级的理解</h2> 
<blockquote> 
 <p>!important &gt; 内联样式 &gt; ID选择器 &gt; 类选择器 &gt; （标签选择器、伪类选择器、属性选择器）</p> 
</blockquote> 
<h2><a id="3CSSCSS3_795"></a>3.CSS和CSS3有什么区别？</h2> 
<blockquote> 
 <p>css3新增了一些新的特性</p> 
 <p>border-radius</p> 
 <p>border-boxshadow</p> 
 <p>border-image</p> 
 <p>transform</p> 
 <p>box-sizing</p> 
 <p>display</p> 
</blockquote> 
<h2><a id="4_811"></a>4.怪异盒模型和标准盒模型区别</h2> 
<blockquote> 
 <p>可以把所有HTML标签都理解成一个盒子模型</p> 
 <p>盒子模型主要由4个部分组成：content、padding、border、margin</p> 
 <p><strong>标准盒模型（W3C盒模型） content-box</strong></p> 
 <ul><li>盒子的尺寸 = content</li></ul> 
 <p><strong>怪异盒模型（IE盒模型） border-box</strong></p> 
 <ul><li>盒子的尺寸 = content + padding + border</li></ul> 
</blockquote> 
<h2><a id="5css3_827"></a>5.用css3可以实现哪些过渡效果</h2> 
<blockquote> 
 <p>动画 animation:动画名字 动画时间 动画方向</p> 
 <pre><code class="prism language-css"> <span class="token atrule"><span class="token rule">@keyframs</span> 名字</span><span class="token punctuation">{<!-- --></span>     <span class="token selector">from :</span><span class="token punctuation">{<!-- --></span><span class="token property">left</span><span class="token punctuation">:</span>0px<span class="token punctuation">}</span><span class="token selector">,     to:</span><span class="token punctuation">{<!-- --></span><span class="token property">left</span><span class="token punctuation">:</span>200px<span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre> 
 <p>过渡,transition(一般跟在hover后面)</p> 
 <p>转换 transform:</p> 
 <blockquote> 
  <p>转换函数 :位移 translate</p> 
  <p>​ 缩放 scale</p> 
  <p>​ 旋转 rotate</p> 
 </blockquote> 
</blockquote> 
<h2><a id="6_845"></a>6.水平垂直居中的几种方式</h2> 
<pre><code class="prism language-css"><span class="token selector">利用绝对定位.box</span><span class="token punctuation">{<!-- --></span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>    <span class="token property">bottom</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span>auto        <span class="token punctuation">}</span><span class="token selector">利用弹性布局.box</span><span class="token punctuation">{<!-- --></span>    <span class="token property">position</span><span class="token punctuation">:</span>flex<span class="token punctuation">;</span>    <span class="token property">justify-content</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span>    <span class="token property">align-item</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c36fb762480829a8dfdf211083d11689/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">将科学计数法表示的DataFrame数据转换为浮点数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9e52ba3647014607420838f41d444726/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">两万多字诠释python最经典基础算法之100题【内含思路、程序和答案】【python初学者必备】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>