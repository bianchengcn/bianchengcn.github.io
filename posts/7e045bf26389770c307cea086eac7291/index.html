<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VueUse文档个人翻译——核心方法一览 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VueUse文档个人翻译——核心方法一览" />
<meta property="og:description" content="前言 为什么要用VueUse VueUse是一款优秀的函数工具集，得到了Vue官方的认可
组合式 API 提供的逻辑复用能力孵化了一些非常棒的社区项目，比如 VueUse，一个不断成长的工具型组合式函数集合。
——Vue.js文档之为什么要有组合式 API？
另外，Element Plus也使用了VueUse，可见它是可靠的。
可惜的是，这玩应没有中文文档，而且它的文档还专门解释了短期内不会有翻译计划（🐮🍺）。
为了方便我自己和更多小伙伴使用这个工具，我将在这里持续更新VueUse的个人翻译。
翻译范围 本文将翻译VueUse的核心方法的简介一览，这可能比翻译每个方法的使用还更有价值，因为很多时候我们的时间是浪费在寻找我们想要的Function。
同时我会尽可能描述这些方法的使用场景、与原生方法的区别。
本文基于10.0.2版本（2023年4月14日发布），由于VueUse还在不断发展，如果有小伙伴发现我的内容已经过时，欢迎指出，我会尽快更新。​
类别 VueUse的核心方法（Core Function）分成12类，分别是：
State - 状态，共13个Element - HTML元素，共15个Browser - 浏览器，共41个Sensors - 传感器（鼠标、键盘、电池、屏幕等），共37个Network - 网络，共3个Animation - 动画，共9个Component - 组件，共16个Watch - 监听，共13个Reactivity - 响应性，共20个Array - 数组，共13个Time - 时间，共2个Utilities - 工具类，共25 可以看到这些方法覆盖了日常开发的大部分场景，相信熟悉它们能大幅提升我们的开发效率。
State 状态 由于笔者使用Nuxt开发，对State需求较小，这部分将留到后面翻译（最近加班实在太多了）。
Elements 元素 HTML元素相关的方法。
useActiveElement - 响应性的document.activeElement
也就是在原生方法的基础上实现了响应性。
useDocumentVisibility - 响应性的document.visibilityState
可以用来监听浏览器窗口可见性的变化。
useDraggable - 使元素可拖拽
useDropZone - 创建一个区域，文件可以拖拽到这个区域中
类似Element UI的Upload组件的效果。
useElementBounding - 一个HTML元素的响应性的边界信息" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/7e045bf26389770c307cea086eac7291/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-15T12:53:03+08:00" />
<meta property="article:modified_time" content="2023-04-15T12:53:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VueUse文档个人翻译——核心方法一览</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<h3><a id="VueUse_1"></a>为什么要用VueUse</h3> 
<p><code>VueUse</code>是一款优秀的函数工具集，得到了<code>Vue</code>官方的认可</p> 
<blockquote> 
 <p>组合式 API 提供的逻辑复用能力孵化了一些非常棒的社区项目，比如 VueUse，一个不断成长的工具型组合式函数集合。<br> ——Vue.js文档之<a href="https://cn.vuejs.org/guide/extras/composition-api-faq.html#better-logic-reuse" rel="nofollow">为什么要有组合式 API？</a></p> 
</blockquote> 
<p>另外，Element Plus也使用了<code>VueUse</code>，可见它是可靠的。<br> 可惜的是，这玩应没有中文文档，而且它的文档还专门解释了短期内不会有翻译计划（🐮🍺）。<br> 为了方便我自己和更多小伙伴使用这个工具，我将在这里持续更新<code>VueUse</code>的个人翻译。</p> 
<h3><a id="_9"></a>翻译范围</h3> 
<p>本文将翻译<code>VueUse</code>的核心方法的简介一览，这可能比翻译每个方法的使用还更有价值，因为很多时候我们的时间是浪费在寻找我们想要的<code>Function</code>。<br> 同时我会尽可能描述这些方法的使用场景、与原生方法的区别。<br> 本文基于10.0.2版本（2023年4月14日发布），由于<code>VueUse</code>还在不断发展，如果有小伙伴发现我的内容已经过时，欢迎指出，我会尽快更新。​</p> 
<h2><a id="_13"></a>类别</h2> 
<p><code>VueUse</code>的核心方法（<code>Core Function</code>）分成12类，分别是：</p> 
<ol><li><code>State</code> - 状态，共13个</li><li><code>Element</code> - HTML元素，共15个</li><li><code>Browser</code> - 浏览器，共41个</li><li><code>Sensors</code> - 传感器（鼠标、键盘、电池、屏幕等），共37个</li><li><code>Network</code> - 网络，共3个</li><li><code>Animation</code> - 动画，共9个</li><li><code>Component</code> - 组件，共16个</li><li><code>Watch</code> - 监听，共13个</li><li><code>Reactivity</code> - 响应性，共20个</li><li><code>Array</code> - 数组，共13个</li><li><code>Time</code> - 时间，共2个</li><li><code>Utilities</code> - 工具类，共25</li></ol> 
<p>可以看到这些方法覆盖了日常开发的大部分场景，相信熟悉它们能大幅提升我们的开发效率。</p> 
<h2><a id="State__29"></a>State 状态</h2> 
<p>由于笔者使用<code>Nuxt</code>开发，对<code>State</code>需求较小，这部分将留到后面翻译（最近加班实在太多了）。</p> 
<h2><a id="Elements__33"></a>Elements 元素</h2> 
<p><code>HTML</code>元素相关的方法。</p> 
<ol><li> <p><code>useActiveElement</code> - 响应性的<code>document.activeElement</code><br> 也就是在原生方法的基础上实现了响应性。</p> </li><li> <p><code>useDocumentVisibility</code> - 响应性的<code>document.visibilityState</code><br> 可以用来监听浏览器窗口可见性的变化。</p> </li><li> <p><code>useDraggable</code> - 使元素可拖拽</p> </li><li> <p><code>useDropZone</code> - 创建一个区域，文件可以拖拽到这个区域中<br> 类似Element UI的Upload组件的效果。</p> </li><li> <p><code>useElementBounding</code> - 一个HTML元素的响应性的边界信息<br> 元素的大小及其相对于可视区域的位置。</p> </li><li> <p><code>useElementSize</code> - 一个HTML元素的响应性的长宽<br> 这个数据在上面<code>useElementBounding</code>中也有。</p> </li><li> <p><code>useElementVisibility</code> - 一个元素是否在可视区域（Viewport）内<br> 前面<code>useDocumentVisibility</code>是监听整个窗口是否可见；现在这个方法是监听一个HTML元素是否可见。</p> </li><li> <p><code>useIntersectionObserver</code> - 一个元素是否在一个区域的可视范围内<br> 它与<code>useElementVisibility</code>的区别是：它的区域可以是你自己设定的区域，例如一小块可以滚动的区域；而<code>useElementVisibility</code>的区域是整个浏览器的可视区域。</p> </li><li> <p><code>useMouseInElement</code> - 鼠标指针相对一个元素的位置（其实也返回鼠标在可视区域中的位置），响应性的</p> </li><li> <p><code>useMutationObserver</code> - 监听DOM树的变化<br> 虽然<code>Vue</code>有生命周期钩子可以用，但是这个方法可以具体监听到某个元素的渲染情况，粒度更细。</p> </li><li> <p>先去加班了…</p> </li></ol> 
<h2><a id="Browser__65"></a>Browser 浏览器</h2> 
<p>加完班就来…</p> 
<h2><a id="V100_69"></a>V10.0更新说明</h2> 
<blockquote> 
 <p>153次commits，41位贡献者，8个新方法</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca71b7c892cd227850ce1e1f544b4317/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【透过实验看Access、Trunk、Hybird原理】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/169106a185d40d20d8f9c0978a242c09/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Redis常用知识笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>