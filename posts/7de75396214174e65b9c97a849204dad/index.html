<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——算法的时间复杂度 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——算法的时间复杂度" />
<meta property="og:description" content="🌇个人主页：_麦麦_
📚今日名言：生命中曾经有过的所有灿烂，都终究需要用寂寞来偿还。——《百年孤独》
目录
一、前言
二、正文
1.算法效率
1.1如何衡量一个算法的好坏
1.2算法的复杂度
2. 时间复杂度
2.1时间复杂度的概念
2.3 常见时间复杂度计算举例
三、结语
一、前言 小伙伴们好呀，今天为大家带来的是算法的相关知识，主要围绕算法的效率和时间复杂度并伴有一定的题目练习，希望能够为读者们带来一定的收获。
二、正文 1.算法效率 1.1如何衡量一个算法的好坏 相信在座的小伙伴们一定见识了许多题目，也一定想出了相应的解决方案。不可否认的是，在面对同一道题目，同一个需求，不同的人也会写出不同的解决方案，那么到底如何如何评判这些解决方案的好坏呢？
有的小伙伴可能会说这还不简单嘛，之间看谁的算法跑的快，也就是依据时间效率的高低来评判算法的好坏。不过在实际中，由于算法的运行环境不同，例如在不同的设备上同一算法的时间效率都可能是不一样的，更遑论是不同的算法了。显然，用时间效率来衡量一个算法的好坏是不可能的，那么有什么更好的方法呢？
1.2算法的复杂度 算法在编写成可执行程序后，运行时需要耗费时间资源和空间（内存）资源。因此衡量一个算法的好坏主要是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。
时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算器发展的早起，计算机的存储容量很小，所以对空间复杂度很是在乎，但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今应经不需要特别关注一个算法的空间复杂度。
2. 时间复杂度 2.1时间复杂度的概念 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上是不能算出来的，只有把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是都可以上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。
即：找到某条基本语句与问题规模N之间的数学表达式，就是算出来该算法的时间复杂度。
说了这么多，纸上得来终觉浅，下面给小伙伴们举一些计算时间复杂度的例子，帮助大家更好地理解时间复杂度这一概念。
//请计算一下Func1中&#43;&#43;count语句总共执行了多少次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N; &#43;&#43;i) { for (int j = 0; j &lt; N; &#43;&#43;j) { &#43;&#43;count; } } for (int k = 0; k &lt; 2 * N; &#43;&#43;k) { &#43;&#43;count; } int M = 10; while (M--) { &#43;&#43;count; } printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/7de75396214174e65b9c97a849204dad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-19T17:47:44+08:00" />
<meta property="article:modified_time" content="2023-02-19T17:47:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——算法的时间复杂度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="125" src="https://images2.imgbox.com/ff/0a/SlemPZWi_o.gif" width="1000"></p> 
<blockquote> 
 <p>🌇个人主页：_麦麦_</p> 
 <p style="text-align:center;">📚今日名言：<strong>生命中曾经有过的所有灿烂，都终究需要用寂寞来偿还。</strong>——《百年孤独》</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" height="540" src="https://images2.imgbox.com/87/d6/VSTAYumn_o.jpg" width="1000"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80" rel="nofollow">一、前言</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%AD%A3%E6%96%87-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E6%AD%A3%E6%96%87" rel="nofollow">二、正文</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87" rel="nofollow">        1.算法效率</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F" rel="nofollow">                1.1如何衡量一个算法的好坏</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.2%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.2%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">                1.2算法的复杂度</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%C2%A0%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%C2%A0%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">        2. 时间复杂度</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">                2.1时间复杂度的概念</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%C2%A0%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%C2%A0%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B" rel="nofollow">                2.3 常见时间复杂度计算举例</a></p> 
<p id="%E4%B8%89%E3%80%81%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%BB%93%E8%AF%AD" rel="nofollow">三、结语</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80">一、前言</h2> 
<blockquote> 
 <p>        小伙伴们好呀，今天为大家带来的是算法的相关知识，主要围绕<strong><span style="color:#fe2c24;">算法的效率</span></strong><span style="color:#494949;">和</span><strong><span style="color:#fe2c24;">时间复杂度</span></strong>并伴有一定的题目练习，希望能够为读者们带来一定的收获。</p> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/75/35/dmObrzYz_o.gif" width="100"></p> 
</blockquote> 
<h3 id="%E4%BA%8C%E3%80%81%E6%AD%A3%E6%96%87">二、正文</h3> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87">        1.算法效率</h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F">                1.1如何衡量一个算法的好坏</h4> 
<blockquote> 
 <p>        相信在座的小伙伴们一定见识了许多题目，也一定想出了相应的解决方案。不可否认的是，在面对同一道题目，同一个需求，不同的人也会写出不同的解决方案，那么到底如何如何评判这些解决方案的好坏呢？</p> 
 <p>        有的小伙伴可能会说这还不简单嘛，之间看谁的算法跑的快，也就是依据时间效率的高低来评判算法的好坏。不过在实际中，由于算法的运行环境不同，例如<span style="background-color:#dad5e9;">在不同的设备上同一算法的时间效率都可能是不一样的，更遑论是不同的算法</span>了。显然，用时间效率来衡量一个算法的好坏是不可能的，那么有什么更好的方法呢？</p> 
</blockquote> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.2%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6">                1.2算法的复杂度</h4> 
<blockquote> 
 <p>         算法在编写成可执行程序后，运行时需要耗费时间资源和空间（内存）资源。因此衡量一个算法的好坏主要是从<span style="color:#333333;">时间</span>和<span style="color:#333333;">空间</span>两个维度来衡量的，即<strong><span style="color:#fe2c24;">时间复杂度</span></strong>和<strong><span style="color:#fe2c24;">空间复杂度</span></strong>。</p> 
 <p>        时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算器发展的早起，计算机的存储容量很小，所以对空间复杂度很是在乎，但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今应经不需要特别关注一个算法的空间复杂度。</p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%C2%A0%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">        2. 时间复杂度</h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5">                2.1时间复杂度的概念</h4> 
<blockquote> 
 <p>       时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上是不能算出来的，只有把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是都可以上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。<strong><span style="color:#fe2c24;">一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度</span></strong>。</p> 
 <p>        即：找到某条基本语句与问题规模N之间的数学表达式，就是算出来该算法的时间复杂度。</p> 
 <p>        说了这么多，纸上得来终觉浅，下面给小伙伴们举一些计算时间复杂度的例子，帮助大家更好地理解时间复杂度这一概念。</p> 
</blockquote> 
<pre><code class="language-cs">//请计算一下Func1中++count语句总共执行了多少次？
void Func1(int N)
{
    int count = 0;
    for (int i = 0; i &lt; N; ++i)
    {
        for (int j = 0; j &lt; N; ++j)
        {
            ++count;
        }
    }

    for (int k = 0; k &lt; 2 * N; ++k)
    {
        ++count;
    }
    int M = 10;
    while (M--)
    {
        ++count;
    }
    printf("%d\n", count);
}</code></pre> 
<blockquote> 
 <p>         看过上面的代码，相信你们一定能够很轻易的算出Fun1执行的基本操作次数是一个关于N的函数：F(N)=N²+2N+10</p> 
 <p>●N=10          F(N)=130</p> 
 <p>●N=100        F(N)=10210</p> 
 <p>●N=1000      F(N)=1002010</p> 
 <p>注：实际中我们计算时间复杂度时，我们其实<span style="background-color:#dad5e9;">并不一定要计算精确的执行次数，而只需要大概执行次数</span>，具体操作是怎样呢，接下来我们引入<strong><span style="color:#fe2c24;">大O的渐进表达法</span></strong></p> 
</blockquote> 
<p>                2.2大O的渐进表示法</p> 
<blockquote> 
 <p>大O符号：适用于描述函数渐进行为的数学符号</p> 
 <p>推导大O阶方法：</p> 
 <p><span style="background-color:#fbd4d0;">1.用常数1取代运行时间中所有的加法常数</span></p> 
 <p><span style="background-color:#fbd4d0;">2.在修改后的运行次数函数中，只保留最高阶项</span></p> 
 <p><span style="background-color:#fbd4d0;">3.如果最高阶项存在且不为1，则去除与这个项目相乘的常数，得到的结果就是大O阶</span></p> 
 <p>        因此，在上面的例子中，采取大O的渐进表示法以后，Fun1的时间复杂度为：F（N²）</p> 
 <p>●N=10          F(N)=130</p> 
 <p>●N=100        F(N)=10210</p> 
 <p>●N=1000      F(N)=1002010</p> 
 <p>        通过上面我们会发现大O的渐进表示法去掉了哪些对结果影响不大的项，简洁明了的表示出了执行次数。不过随着算法的深入，我们会发现有些算法的时间复杂度并不是唯一确定的，而是存在着最好、平均和最坏情况： </p> 
 <p><span style="background-color:#ffd7b9;">●最坏情况</span>：任意输入规模的最大运行次数（上界）</p> 
 <p><span style="color:#333333;"><span style="background-color:#ffd7b9;">●平均情况</span></span>：任意输入规模的期望运行次数</p> 
 <p><span style="background-color:#ffd7b9;">●最好情况</span>：任意输入闺蜜的最小运行次数（下界）</p> 
 <p>        例如：在一个长度为N的数组中搜查一个数据x</p> 
 <p>●最坏情况：N次找到</p> 
 <p>●平均情况：N/2次找到</p> 
 <p>●最好情况：1次找到</p> 
 <p>        在<strong><span style="color:#fe2c24;">实际中一般关注的是算法的最坏运行情况</span></strong>，所以数组中搜索数据的时间复杂度为O（N）。</p> 
 <p>         之所以以最坏情况来作为算法的时间复杂度，在这里其实是应用了信息学中的“<span style="color:#fe2c24;"><strong>预期管理</strong></span>”，就好比情人节那天，你要与你的男/女朋友约会，而约会时间可能是17点、18点、19点，那么相信大多数的人都会选择19点，如果刚刚好19点来就挺守时的嘛，如果早来，还可以提前准备，给他/她一些惊喜。相反，如果你将约定时间定位17点或者18点，一旦无法在约定时间前来，就是放鸽子了，可能会产生意料之外的各种特殊情况……</p> 
 <p>        因此，<strong><span style="color:#fe2c24;">采取最坏情况作为时间复杂度的算法跑起来只有惊喜和预期，不可能比预期更坏</span></strong>。</p> 
</blockquote> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%C2%A0%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B">                2.3 常见时间复杂度计算举例</h4> 
<p>●实例1</p> 
<pre><code class="language-cs">// 计算Func2的时间复杂度
void Func2(int N)
{
 int count = 0;
 for (int k = 0; k &lt; 2 * N ; ++ k)
 {
 ++count;
 }
 int M = 10;
 while (M--)
 {
 ++count;
 }
 printf("%d\n", count);
}</code></pre> 
<blockquote> 
 <p>       通过计算，F（N）=2N+10，因此该算法的时间复杂度为O（N） </p> 
</blockquote> 
<p>●实例2</p> 
<pre><code class="language-cs">// 计算Func3的时间复杂度
void Func3(int N, int M)
{
 int count = 0;
 for (int k = 0; k &lt; M; ++ k)
 {
 ++count;
 }
 for (int k = 0; k &lt; N ; ++ k)
 {
 ++count;
 }
 printf("%d\n", count);
}
</code></pre> 
<blockquote> 
 <p>        通过计算，在一般情况下，也就是M和N均为未知数的情况下，F（N）=M+N，所以O（N）=M+N </p> 
 <p>注：如果题目中说M远大于N，那么O(N)=M</p> 
</blockquote> 
<p>●实例3</p> 
<pre><code class="language-cs">// 计算Func4的时间复杂度
void Func4(int N)
{
 int count = 0;
 for (int k = 0; k &lt; 100; ++ k)
 {
 ++count;
 }
 printf("%d\n", count);
}</code></pre> 
<blockquote> 
 <p>        通过计算我们发现无论N取何值，F（N）始终等于一个常数也就是 ，根据 大O阶方法的一条，用1来代表所有常数，也就是该时间复杂度为O（1）</p> 
</blockquote> 
<p>●实例4</p> 
<pre><code class="language-cs">// 计算strchr的时间复杂度
const char * strchr ( const char * str, int character );</code></pre> 
<blockquote> 
 <p>        对库函数有过一定了解的同学一定知道“strchr”这个函数会依次对str指针+1，如果找到目的字符便会返回其指针，找不到便会返回空指针。而这里就会存在最好、最坏和平均情况，因此该函数的时间复杂度为O(N)</p> 
 <p>注：未指定未知数的情况下默认为N</p> 
</blockquote> 
<p>●实例5</p> 
<pre><code class="language-cs">// 计算BubbleSort的时间复杂度
void BubbleSort(int* a, int n)
{
 assert(a);
 for (size_t end = n; end &gt; 0; --end)
 {
     for (size_t i = 1; i &lt; end; ++i)
     {
         if (a[i-1] &gt; a[i])
         {
             Swap(&amp;a[i-1], &amp;a[i]);
             exchange = 1;
         }
     }
 }
}</code></pre> 
<blockquote> 
 <p>        最好情况：O(N)——无须排序</p> 
 <p>        最坏情况：O(N²)——全部交换</p> 
 <p>相信最坏情况的时间复杂度大家应该可以很轻易的想出来，但是最坏情况可能就有些复杂了。我们都知道冒泡排序共有两个流程，一个是趟数，一个是每趟交换的次数。那么时间复杂度就是总的交换次数。在看过博主之前推文对冒泡排序的小伙伴应该十分了解在冒泡排序最坏的情况下中，首趟交换的次数是最多的，为元素个数减，即N-1，之后虽趟数的增加，每趟交换的次数以1的速度递减。那么总的趟数计算的话其实就是一个高中很简单的等差数列求和，即（首项+尾项）*项数/2，代入N-1，可得F(N)=N*(N-1)/2，所以O(N)=N²。</p> 
</blockquote> 
<p> ●实例6</p> 
<pre><code class="language-cs">// 计算BinarySearch的时间复杂度——二分查找
int BinarySearch(int* a, int n, int x)
{
    assert(a);
    int begin = 0;
    int end = n - 1;
    // [begin, end]：begin和end是左闭右闭区间，因此有=号
    while (begin &lt;= end)
    {
        int mid = begin + ((end - begin) &gt;&gt; 1);
        if (a[mid] &lt; x)
            begin = mid + 1;
        else if (a[mid] &gt; x)
            end = mid - 1;
        else
            return mid;
    }
    return -1;
}</code></pre> 
<blockquote> 
 <p>        二分查找又称折半查找法，是一种通过中间值与目标值进行比较，进而对数值进行筛选，循环往复来查找目标值的方法。</p> 
 <p>        最好情况下，也就是第一次就找到目标值，此时时间复杂度为O(1)</p> 
 <p>        最坏情况下，就是将数组不断二分直至长度为1为止，此时可能找到目标值也可能没有目标值。因此F(N)=log以2为底的对数，大部分情况下简写为logN，所以O(N)=logN。</p> 
</blockquote> 
<p>●实例7</p> 
<pre><code class="language-cs">// 计算阶乘递归Fac的时间复杂度
long long Fac(size_t N)
{
    if (0 == N)
        return 1;

    return Fac(N - 1) * N;
}</code></pre> 
<p style="text-align:center;"><img alt="" height="318" src="https://images2.imgbox.com/21/98/zB42mMFU_o.png" width="1000">  </p> 
<blockquote> 
 <p>         有时候，我们可能在脑海中无法形象的，一下子的得出时间复杂度，这时候就可以通过<strong><span style="color:#fe2c24;">画图来帮助自己理清思路</span></strong>，进而得出时间复杂度。通过上图，我们可以发现在最坏的情况下基本操作进行了N次，时间复杂度为O(N)</p> 
</blockquote> 
<p>● 实例8</p> 
<pre><code class="language-cs">// 计算斐波那契递归Fib的时间复杂度
long long Fib(size_t N)
{
 if(N &lt; 3)
 return 1;
 
 return Fib(N-1) + Fib(N-2);
}</code></pre> 
<p style="text-align:center;"><img alt="" height="261" src="https://images2.imgbox.com/b8/01/Gnypf0WP_o.png" width="1000"> </p> 
<blockquote> 
 <p>        我们发现这其实是一个等比数列求和，虽然右边有一些数提前递归结束，但是随着N的增大，是可以忽略不计的。因此该时间复杂度为O(2^N) </p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E7%BB%93%E8%AF%AD">三、结语</h2> 
<blockquote> 
 <p>         到此为止，关于算法的时间复杂度的学习就告一段落了。</p> 
 <p>         关注我 <strong>_麦麦_</strong>分享更多干货：<a href="https://blog.csdn.net/m0_73953114?spm=1010.2135.3001.5343" title="_麦麦_的博客_CSDN博客-领域博主">_麦麦_的博客_CSDN博客-领域博主</a><br>          大家的「<strong>关注❤️ + 点赞👍 + 收藏⭐</strong>」就是我创作的最大动力！谢谢大家的支持，我们下期见！</p> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/f5/ac/6MDCkIuQ_o.gif" width="100"></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6071afa9906b794bf550a05c5610417c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nodemon的安装和使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a6a33e6f850495a997e86d03fa50ce0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows使用ssh协议远程连接ubuntu linux系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>