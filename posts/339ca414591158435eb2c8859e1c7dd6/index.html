<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>字节二面：Spring Boot Redis 可重入分布式锁实现原理？ - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="字节二面：Spring Boot Redis 可重入分布式锁实现原理？" />
<meta property="og:description" content="我是码哥，可以叫我靓仔。
书接上回，码哥上一篇《纠正误区：这才是 SpringBoot Redis 分布式锁的正确实现方式》分享了分布式锁如何从错误到残缺，再到青铜版本的高性能 Redis 分布式锁代码实战，让你一飞冲天。
这是我们最常用的分布式锁方案，今天码哥给你来一个进阶。
Chaya：「码哥，上次的分布式锁版本虽然好，但是不支持可重入获取锁，还差一点点意思。」
Chaya 别急，今日码哥给你带来一个高性能可重入 Redis 分布式锁解决方案，直捣黄龙，一笑破苍穹。
什么是可重入锁 当一个线程执行一段代码成功获取锁之后，继续执行时，又遇到加锁的代码，可重入性就就保证线程能继续执行，而不可重入就是需要等待锁释放之后，再次获取锁成功，才能继续往下执行。
public synchronized void a() { b(); } public synchronized void b() { // doWork } 假设 X 线程在 a 方法获取锁之后，继续执行 b 方法，如果此时不可重入，线程就必须等待锁释放，再次争抢锁。
锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~
可重入锁实现原理 Chaya：「Redis String 数据结构无法满足可重入锁，key 表示锁定的资源，value 是客户端唯一标识，可重入没地方放了。」
我们可以使用 Redis hash 结构实现，key 表示被锁的共享资源， hash 结构的 fieldKey 存储客户端唯一标识，fieldKey 的 value 则保存加锁的次数。
图 5-26 加锁原理 可重入锁加锁的过程中有以下场景需要考虑。
锁已经被 A 客户端获取，客户端 B 获取锁失败。
锁已经被客户端 A 获取，客户端 A 多次执行获取锁操作。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/339ca414591158435eb2c8859e1c7dd6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-30T08:39:44+08:00" />
<meta property="article:modified_time" content="2024-01-30T08:39:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">字节二面：Spring Boot Redis 可重入分布式锁实现原理？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>我是码哥，可以叫我靓仔。</p> 
 <p>书接上回，码哥上一篇<a href="" rel="nofollow">《纠正误区：这才是 SpringBoot Redis 分布式锁的正确实现方式》</a>分享了分布式锁如何从错误到残缺，再到青铜版本的高性能 Redis 分布式锁代码实战，让你一飞冲天。</p> 
 <p>这是我们最常用的分布式锁方案，今天码哥给你来一个进阶。</p> 
 <blockquote> 
   
  <p>Chaya：「码哥，上次的分布式锁版本虽然好，但是不支持可重入获取锁，还差一点点意思。」</p> 
 </blockquote> 
 <p>Chaya 别急，今日码哥给你带来一个高性能可重入 Redis 分布式锁解决方案，直捣黄龙，一笑破苍穹。</p> 
 <h3>什么是可重入锁 </h3> 
 <p>当一个线程执行一段代码成功获取锁之后，继续执行时，又遇到加锁的代码，可重入性就就保证线程能继续执行，而不可重入就是需要等待锁释放之后，再次获取锁成功，才能继续往下执行。</p> 
 <pre class="has"><code class="language-go">public synchronized void a() {
    b();
}
public synchronized void b() {
    // doWork
}</code></pre> 
 <p>假设 X 线程在 a 方法获取锁之后，继续执行 b 方法，如果此时<strong>不可重入</strong>，线程就必须等待锁释放，再次争抢锁。</p> 
 <p>锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~</p> 
 <h3>可重入锁实现原理 </h3> 
 <blockquote> 
   
  <p>Chaya：「Redis String 数据结构无法满足可重入锁，key 表示锁定的资源，value 是客户端唯一标识，可重入没地方放了。」</p> 
 </blockquote> 
 <p>我们可以使用 Redis hash 结构实现，key 表示被锁的共享资源， hash 结构的 fieldKey 存储客户端唯一标识，fieldKey 的 value 则保存加锁的次数。</p> 
 <img src="https://images2.imgbox.com/ee/8f/BUz6Rhzi_o.png" alt="3717b8e387d4ced667adeccdc7b22d60.png"> 
 <figcaption>
   图 5-26 
 </figcaption> 
 <h4>加锁原理</h4> 
 <p>可重入锁加锁的过程中有以下场景需要考虑。</p> 
 <ol><li><p>锁已经被 A 客户端获取，客户端 B 获取锁失败。</p></li><li><p>锁已经被客户端 A 获取，客户端 A 多次执行获取锁操作。</p></li><li><p>锁没有被其他客户端获取，那么此刻获取锁的客户端可以获取成功。</p></li></ol> 
 <p>按照之前的经验，多个操作的原子性可以用 lua 脚本实现。可重入锁加锁 lua 脚本如下。</p> 
 <pre class="has"><code class="language-go">if ((redis.call('exists', KEYS[1]) == 0) or
   (redis.call('hexists', KEYS[1], ARGV[2]) == 1)) then
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
  return nil;
end;
return redis.call('pttl', KEYS[1]);</code></pre> 
 <ul><li><p><code>KEYS[1]</code>是 lockKey 表示获取的锁资源，比如 <code>lock:168</code>。</p></li><li><p><code>ARGV[1]</code> 表示表示锁的有效时间（单位毫秒）。</p></li><li><p><code>ARGV[2]</code> 表示客户端唯一标识，在 Redisson 中使用 <code>UUID:ThreadID</code>。</p></li></ul> 
 <p>下面我来接下是这段脚本的逻辑。</p> 
 <ol><li><p>锁不存在或者锁存在且值与客户端唯一标识匹配，则执行 <code>'hincrby'</code> 和 <code>pexpire</code>指令，接着 <code>return nil</code>。表示的含义就是锁不存在就设置锁并设置锁重入计数值为 1，设置过期时间；锁存在且唯一标识匹配表明当前加锁请求是锁重入请求，锁从如计数 +1，重新锁超时时间。</p></li></ol> 
 <ul><li><p><code>redis.call('exists', KEYS[1]) == 0</code>判断锁是否存在，0 表示不存在。</p></li><li><p><code>redis.call('hexists', KEYS[1], ARGV[2]) == 1)</code>锁存在的话，判断 hash 结构中 fieldKey 与客户端的唯一标识是否相等。相等表示当前加锁请求是锁重入。</p></li><li><p><code>redis.call('hincrby', KEYS[1], ARGV[2], 1)</code>将存储在 hash 结构的 <code>ARGV[2]</code> 的值 +1，不存在则支持成 1。</p></li><li><p><code>redis.call('pexpire', KEYS[1], ARGV[1])</code>对 <code>KEYS[1]</code> 设置超时时间。</p></li></ul> 
 <p>锁存在，但是唯一标识不匹配，表明锁被其他线程持有，调用 <code>pttl</code>返回锁剩余的过期时间。</p> 
 <blockquote> 
   
  <p>Chaya：「“脚本执行结果返回 nil、锁剩余过期时间有什么目的？”」</p> 
 </blockquote> 
 <p>当且仅当返回 <code>nil</code>才表示加锁成功；客户端需要感知锁是否成功的结果。</p> 
 <h4>解锁原理</h4> 
 <p>解锁逻辑复杂一些，不仅要保证不能删除别人的锁。还要确保，重入次数为 0 才能解锁。</p> 
 <p>解锁代码执行方式与加锁类似，三个返回值含义如下。</p> 
 <ul><li><p>1 代表解锁成功，锁被释放。</p></li><li><p>0 代表可重入次数被减 1。</p></li><li><p><code>nil</code> 代表其他线程尝试解锁，解锁失败。</p></li></ul> 
 <pre class="has"><code class="language-go">if (redis.call('hexists', KEYS[1], ARGV[2]) == 0) then
    return nil;
end;
local counter = redis.call('hincrby', KEYS[1], ARGV[2], -1);
if (counter &gt; 0) then
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return 0;
else
    redis.call('del', KEYS[1]);
    return 1;
end;
return nil;</code></pre> 
 <ul><li><p><code>KEYS[1]</code>是 lockKey，表示锁的资源，比如 <code>lock:order:pay</code>。</p></li><li><p><code>ARGV[1]</code>，锁的超时时间。</p></li><li><p><code>ARGV[2]</code>，Hash 表的 FieldKey。</p></li></ul> 
 <p>首先使用 <code>hexists</code> 判断 Redis 的 Hash 表是否存在 <code>fileKey</code>，如果不存在则直接返回 <code>nil</code>解锁失败。</p> 
 <p>若存在的情况下，且唯一标识匹配，使用 <code>hincrby</code> 对 fileKey 的值 -1，然后判断计算之后可重入次数。当前值 &gt; 0 表示持有的锁存在重入情况，重新设置超时时间，返回值 1；</p> 
 <p>若值小于等于 0，表明锁释放了，执行 <code>del</code>释放锁。</p> 
 <blockquote> 
   
  <p>Chaya：“可重入锁很好，依然存在的一个问题是：加锁后，业务逻辑执行耗时超过了 lockKey 的过期时间，lockKey 会被 Reids 删除。”</p> 
 </blockquote> 
 <p>这个时间不能瞎写，一般要根据在测试环境多次测试，然后压测多轮之后，比如计算出接口平均执行时间 200 ms。那么锁的<strong>超时时间就放大为平均执行时间的 3~5 倍。</strong></p> 
 <blockquote> 
   
  <p>Chaya：“锁的超时时间怎么计算合适呢？”</p> 
 </blockquote> 
 <p>这个时间不能瞎写，一般要根据在测试环境多次测试，然后压测多轮之后，比如计算出接口平均执行时间 200 ms。那么锁的<strong>超时时间就放大为平均执行时间的 3~5 倍。</strong></p> 
 <blockquote> 
   
  <p>Chaya：“为啥要放大呢？”</p> 
 </blockquote> 
 <p>因为如果锁的操作逻辑中有网络 IO 操作、JVM FullGC 等，线上的网络不会总一帆风顺，我们要给网络抖动留有缓冲时间。</p> 
 <blockquote> 
   
  <p>Chaya：“有没有完美的方案呢？不管时间怎么设置都不大合适。”</p> 
 </blockquote> 
 <p>我们可以让获得锁的线程开启一个<strong>守护线程</strong>，用来给当前客户端快要过期的锁续航，续命的前提是，得判断是不是当前进程持有的锁，如果不是就不进行续。</p> 
 <p><strong>如果快要过期，但是业务逻辑还没执行完成，自动对这个锁进行续期，重新设置过期时间。</strong></p> 
 <img src="https://images2.imgbox.com/8e/27/1Sg9jemp_o.png" alt="12691df129a78f683dffbe110c4955d3.png"> 
 <figcaption>
   图 5-27 
 </figcaption> 
 <p>这就是下一篇我要说的超神方案，加入看门狗机制实现锁自动续期。不过锁自动续期比较复杂，今天的 Redis 可重入分布式锁王者方案已经可以让你称霸武林，接下来上实战。</p> 
 <h3>可重入分布式锁实战 </h3> 
 <p>关于 Spring Boot 的环境搭建以及普通分布式锁实战详见上一篇<a href="" rel="nofollow">《纠正误区：这才是 SpringBoot Redis 分布式锁的正确实现方式》</a>。今天直接上可重入锁核心代码。</p> 
 <h4>ReentrantDistributedLock</h4> 
 <p>可重入锁由<code>ReentrantDistributedLock</code>标识，它实现 <code>Lock</code>接口，构造方法实现 <code>resourceName</code> 和 <code>StringRedisTemplate</code> 的属性设置。</p> 
 <p>客户端唯一标识使用<code>uuid:threadId</code> 组成。</p> 
 <pre class="has"><code class="language-go">public class ReentrantDistributedLock implements Lock {

    /**
     * 锁超时时间，默认 30 秒
     */
    protected long internalLockLeaseTime = 30000;

    /**
     * 标识 id
     */
    private final String id = UUID.randomUUID().toString();

    /**
     * 资源名称
     */
    private final String resourceName;

    private final List&lt;String&gt; keys = new ArrayList&lt;&gt;(1);


    /**
     * Redis 客户端
     */
    private final StringRedisTemplate redisTemplate;

    public ReentrantDistributedLock(String resourceName, StringRedisTemplate redisTemplate) {
        this.resourceName = resourceName;
        this.redisTemplate = redisTemplate;
        keys.add(resourceName);
    }
}</code></pre> 
 <h4>加锁 tryLock、lock</h4> 
 <p><code>tryLock</code> 以阻塞等待 <code>waitTime</code> 时间的方式来尝试获取锁。获取成功则返回 true，反之 false。</p> 
 <p>与 <code>tryLock</code>不同的是， <code>lock</code> 一直尝试自旋阻塞等待获取分布式锁，直到获取成功为止。而 <code>tryLock</code> 只会阻塞等待 <code>waitTime</code> 时间。</p> 
 <pre class="has"><code class="language-go">@Override
public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
    long time = unit.toMillis(waitTime);
    long current = System.currentTimeMillis();
    long threadId = Thread.currentThread().getId();
    // lua 脚本获取锁
    Long ttl = tryAcquire(leaseTime, unit, threadId);
    // lock acquired
    if (ttl == null) {
        return true;
    }

    time -= System.currentTimeMillis() - current;
    // 等待时间用完，获取锁失败
    if (time &lt;= 0) {
        return false;
    }
    // 自旋获取锁
    while (true) {
        long currentTime = System.currentTimeMillis();
        ttl = tryAcquire(leaseTime, unit, threadId);
        // lock acquired
        if (ttl == null) {
            return true;
        }

        time -= System.currentTimeMillis() - currentTime;
        if (time &lt;= 0) {
            return false;
        }
    }
}

@Override
public void lock(long leaseTime, TimeUnit unit) {
    long threadId = Thread.currentThread().getId();
    Long ttl = tryAcquire(leaseTime, unit, threadId);
    // lock acquired
    if (ttl == null) {
        return;
    }
    do {
        ttl = tryAcquire(leaseTime, unit, threadId);
        // lock acquired
    } while (ttl != null);
}

private Long tryAcquire(long leaseTime, TimeUnit unit, long threadId) {
    // 执行 lua 脚本
    DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(LuaScript.reentrantLockScript(), Long.class);
    return redisTemplate.execute(redisScript, keys, String.valueOf(unit.toMillis(leaseTime)), getRequestId(threadId));
}

private String getRequestId(long threadId) {
    return id + ":" + threadId;
}</code></pre> 
 <h4>解锁 unlock</h4> 
 <pre class="has"><code class="language-go">public void unlock() {
        long threadId = Thread.currentThread().getId();

        // 执行 lua 脚本
        DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(LuaScript.reentrantUnlockScript(), Long.class);
        Long opStatus = redisTemplate.execute(redisScript, keys, String.valueOf(internalLockLeaseTime), getRequestId(threadId));

        if (opStatus == null) {
            throw new IllegalMonitorStateException("attempt to unlock lock, not locked by current thread by node id: "
                    + id + " thread-id: " + threadId);
        }


    }</code></pre> 
 <h4>LuaScript</h4> 
 <p>这个脚本就是在讲解可重入分布式锁原理具体逻辑已经解释过，这里就不再重复分析。</p> 
 <pre class="has"><code class="language-go">public class LuaScript {

    private LuaScript() {

    }

    /**
     * 可重入分布式锁加锁脚本
     *
     * @return 当且仅当返回 `nil`才表示加锁成功；返回锁剩余过期时间是让客户端感知锁是否成功。
     */
    public static String reentrantLockScript() {
        return "if ((redis.call('exists', KEYS[1]) == 0) " +
                "or (redis.call('hexists', KEYS[1], ARGV[2]) == 1)) then " +
                "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
                "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                "return nil; " +
                "end; " +
                "return redis.call('pttl', KEYS[1]);";
    }

    /**
     * 可重入分布式锁解锁脚本
     *
     * @return 当且仅当返回 `nil`才表示解锁成功；
     */
    public static String reentrantUnlockScript() {
        return "if (redis.call('hexists', KEYS[1], ARGV[2]) == 0) then " +
                "return nil;" +
                "end; " +
                "local counter = redis.call('hincrby', KEYS[1], ARGV[2], -1); " +
                "if (counter &gt; 0) then " +
                "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                "return 0; " +
                "else " +
                "redis.call('del', KEYS[1]); " +
                "return 1; " +
                "end; " +
                "return nil;";
    }
}</code></pre> 
 <h4>RedisLockClient</h4> 
 <p>最后，还需要提供一个客户端给方便使用。</p> 
 <pre class="has"><code class="language-go">@Component
public class RedisLockClient {

    @Autowired
    private StringRedisTemplate redisTemplate;

    /**
     * 获取可重入分布式锁
     * @param name
     * @return
     */
    public Lock getReentrantLock(String name) {
        return new ReentrantDistributedLock(name, redisTemplate);
    }

}</code></pre> 
 <p>单元测试走一个，验证下分布式锁是否支持可重入。</p> 
 <pre class="has"><code class="language-go">@Slf4j
@SpringBootTest(classes = RedisApplication.class)
public class RedisLockTest {

    @Autowired
    private RedisLockClient redisLockClient;

    @Test
    public void testTryReentrantLockSuccess() throws InterruptedException {
        Lock lock = redisLockClient.getReentrantLock("order:pay");
        try {
            boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
            if (!isLock) {
                log.warn("加锁失败");
                return;
            }
            // 重复加锁
            reentrant(lock);

            log.info("业务逻辑执行完成");
        } finally {
            lock.unlock();
        }

    }

    private void reentrant(Lock lock) throws InterruptedException {
        try {
            boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
            if (!isLock) {
                log.warn("加锁失败");
                return;
            }

            log.info("业务逻辑执行完成");
        } finally {
            lock.unlock();
        }
    }

}</code></pre> 
 <p>有两个点需要注意。</p> 
 <ol><li><p>释放锁的代码一定要放在 <code>finally{}</code> 块中。否则一旦执行业务逻辑过程中抛出异常，程序就无法执行释放锁的流程。只能干等着锁超时释放。</p></li><li><p>加锁的代码应该写在 <code>try {}</code> 代码中，放在 try 外面的话，如果执行加锁异常（客户端网络连接超时），但是实际指令已经发送到服务端并执行，就会导致没有机会执行解锁的代码。</p></li></ol> 
 <blockquote> 
   
  <p>CHaya：“码哥，这个方案确实很王者，大开眼界，接下来的超神版可以实现看门狗自动续期么？”</p> 
 </blockquote> 
 <p>鉴于篇幅有限，今天就跟大家介绍 Redis 可重入分布式锁王者方案，关注我，下一篇给你分享、超神版分布式锁解决方案。</p> 
 <p>下期见~</p> 
 <p>往期推荐</p> 
 <p> <a href="" rel="nofollow"> </a></p> 
 <p><a href="" rel="nofollow">纠正误区：这才是 SpringBoot Redis 分布式锁的正确实现方式</a></p> 
 <a href="" rel="nofollow"> </a> 
 <p> <a href="" rel="nofollow"> </a></p> 
 <p><a href="" rel="nofollow">Tomcat 架构设计 25 年后依旧能打！我学到了什么？</a></p> 
 <a href="" rel="nofollow"> </a> 
 <p> <a href="" rel="nofollow"> </a></p> 
 <p><a href="" rel="nofollow">3 万字 + 40 张图 ｜ Redis  霸道面试题（2024 版本）</a></p> 
 <a href="" rel="nofollow"> </a> 
 <p> <a href="" rel="nofollow"> </a></p> 
 <p><a href="" rel="nofollow">Tomcat 架构原理解析到架构设计借鉴</a></p> 
 <a href="" rel="nofollow"> </a> 
 <p> <a href="" rel="nofollow"> </a></p> 
 <p><a href="" rel="nofollow">深入解析 Redis 执行命令流程：I/O 事件、文件事件和客户端交互</a></p> 
 <a href="" rel="nofollow"> </a> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a5f2a1813806e8ba9ce99db4d84e4be/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HCIP---OSPF实验1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3efd9298219b5c27509a35f0d8b8bc8f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">F - Dragon Ball I ——最短路</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>