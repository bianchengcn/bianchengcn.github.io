<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringCloud之Nacos的学习、快速上手 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringCloud之Nacos的学习、快速上手" />
<meta property="og:description" content="1、什么是Nacos Nacos是阿里的一个开源产品，是针对微服务架构中的服务发现、配置管理、服务治理的综合型解决方案，用来实现配置中心和服务注册中心。
Nacos 快速开始
2、安装运行nacos nacos下载地址
下载地址: https://github.com/alibaba/nacos/releases
zip为Windows压缩包 tar.gz为linux压缩包
个人百度网盘分享链接：https://pan.baidu.com/s/1RTNA0Gx5chpyb-HXCOuJuw?pwd=8848 提取码：8848 下载解压后运行nacos 进入bin目录 执行下面命令即可 -m为启动模式，设置为单机模式运行
startup.cmd -m standalone
如果不想每次输入-m standalone可以右键startup.cmd使用文本打开修改配置即可
这样我们只需要双击startup.bat文件即可自动在单机模式下运行nacos
默认端口8848 浏览器访问localhost:8848/nacos即可进入nacos控制台 账号密码默认都是nacos
3、Nacos注册中心的使用 将微服务注册到nacos
准备了两个微服务分别是订单微服务和商品微服务
需要引入的依赖为
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 3.1在application.yml文件中需要配置服务名称和nacos连接地址 注意：服务名称不能重复 服务名称不能没有 重复则nacos视为一个服务 没有nacos扫描不到则服务列表不显示
spring: application: name: product-service cloud: nacos: discovery: server-addr: localhost:8848 3.2在启动类是加上注解@EnableDiscoveryClient(不加也可以) @SpringBootApplication @EnableDiscoveryClient public class OrderServer { public static void main(String[] args) { SpringApplication.run(OrderServer.class,args); } } 启动两个微服务
观察nacos控制台在服务列表可以看到刚刚启动的两个微服务
4、Nacos注册中心的原理 Nacos将服务可以分为服务消费者和服务提供者 在我的项目中现在有订单和商品微服务，在订单服务中需要调用商品服务查询商品信息" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3148d36a9d567c53a8e2ab1945567d8f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-20T11:27:57+08:00" />
<meta property="article:modified_time" content="2024-01-20T11:27:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringCloud之Nacos的学习、快速上手</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1、什么是Nacos</h2> 
<p><strong>Nacos</strong>是阿里的一个开源产品，是针对<a href="https://so.csdn.net/so/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84&amp;spm=1001.2101.3001.7020" title="微服务架构">微服务架构</a>中的服务发现、配置管理、服务治理的综合型解决方案，用来实现配置中心和服务注册中心。</p> 
<p><a href="https://nacos.io/zh-cn/docs/quick-start.html" rel="nofollow" title="Nacos 快速开始">Nacos 快速开始</a></p> 
<h2>2、安装运行nacos</h2> 
<blockquote> 
 <p>nacos下载地址</p> 
 <p>下载地址: https://github.com/alibaba/nacos/releases<br> zip为Windows压缩包        tar.gz为linux压缩包</p> 
</blockquote> 
<p>个人百度网盘分享链接：https://pan.baidu.com/s/1RTNA0Gx5chpyb-HXCOuJuw?pwd=8848 <br> 提取码：8848 </p> 
<p>下载解压后运行nacos    进入bin目录  执行下面命令即可        -m为启动模式，设置为<strong>单机模式</strong>运行</p> 
<blockquote> 
 <p>startup.cmd -m standalone</p> 
</blockquote> 
<p>如果不想每次输入-m standalone可以右键startup.cmd使用文本打开修改配置即可</p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/fa/30/EFkbqFrC_o.png" width="944"></p> 
<p>这样我们只需要双击startup.bat文件即可自动在单机模式下运行nacos</p> 
<p><img alt="" height="331" src="https://images2.imgbox.com/5e/ea/cb6mUq8K_o.png" width="483"></p> 
<p>默认端口8848        </p> 
<p>浏览器访问localhost:8848/nacos即可进入nacos控制台        账号密码默认都是nacos</p> 
<p><img alt="" height="458" src="https://images2.imgbox.com/04/b0/ShfIQWBp_o.png" width="697"></p> 
<h2>3、Nacos注册中心的使用</h2> 
<p>将微服务注册到nacos</p> 
<p>准备了两个微服务分别是<strong>订单微服务</strong>和<strong>商品微服务</strong></p> 
<p>需要引入的依赖为</p> 
<pre><code class="language-XML">&lt;dependency&gt;
   &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
   &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
   &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<h3>3.1在application.yml文件中需要配置服务名称和nacos连接地址        </h3> 
<h4>注意：服务名称不能重复        服务名称不能没有</h4> 
<p>重复则nacos视为一个服务        没有nacos扫描不到则服务列表不显示</p> 
<pre><code class="language-java">spring:
  application:
    name: product-service
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848</code></pre> 
<p><img alt="" height="460" src="https://images2.imgbox.com/9f/a6/Hn310hL1_o.png" width="813"></p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/2c/e0/dA1r4daa_o.png" width="869"></p> 
<h3>3.2在启动类是加上注解@EnableDiscoveryClient(不加也可以)</h3> 
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient
public class OrderServer {
    public static void main(String[] args) {
        SpringApplication.run(OrderServer.class,args);
    }
}</code></pre> 
<p>启动两个微服务</p> 
<p>观察nacos控制台在服务列表可以看到刚刚启动的两个微服务</p> 
<p><img alt="" height="515" src="https://images2.imgbox.com/65/78/J7rMw2Ap_o.png" width="1200"></p> 
<h2>4、Nacos注册中心的原理</h2> 
<p>Nacos将服务可以分为<strong>服务消费者</strong>和<strong>服务提供者     </strong>   </p> 
<p>在我的项目中现在有订单和商品微服务，在订单服务中需要调用商品服务查询商品信息</p> 
<p>则可以将<strong>订单微服务称为服务消费者</strong>，将<strong>商品微服务称为服务提供者</strong></p> 
<h3><strong>4.1服务注册流程：</strong></h3> 
<p>1、product-service服务向nacos注册中心进行服务注册，同时对nacos上现有的已经存在的服务进行服务拉取,并将拉取到的服务列表缓存到本地列表</p> 
<p>2、注册成功后定时向nacos发送心跳，告诉nacos这个服务正常运行</p> 
<p>3、同时，order-service服务也执行上述操作，注册服务、拉取服务、缓存服务到本地、定时发送心跳</p> 
<p><img alt="" height="560" src="https://images2.imgbox.com/1f/ea/wfraiw14_o.png" width="1200"></p> 
<h3> 4.2服务怎么从注册中心获取呢</h3> 
<pre><code class="language-java">@RestController
@Slf4j
public class NacosController {

    //注入服务发现接口
    @Autowired
    private DiscoveryClient discoveryClient;

    @GetMapping("test")
    public void test(){
        //获取服务名称为product-service的服务，得到的是一个List的实例集合
        //因为有可能有多个实例
        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances("order-service");
        //获取第一个实例，也就是获取的实例列表中的第一个实例
        ServiceInstance serviceInstance = instances.get(0);
        //获取这个实例的端口
        int port = serviceInstance.getPort();
        //获取这个实例的访问地址
        String host = serviceInstance.getHost();
        log.info("获取服务名为order-service的第一个服务：{}",serviceInstance);
        log.info("获取服务名为order-service的第一个服务port：{}",port);
        log.info("获取服务名为order-service的第一个服务host：{}",host);
    }
}</code></pre> 
<p>我们对这个接口进行访问</p> 
<p><img alt="" height="308" src="https://images2.imgbox.com/4c/66/dN6hM0Th_o.png" width="1179"></p> 
<h3>4.3对接口进行调用</h3> 
<p>在需要调用的服务的启动类上加上@Bean交给Spring管理</p> 
<pre><code class="language-java">@SpringBootApplication
public class OrderServer {
    public static void main(String[] args) {
        SpringApplication.run(OrderServer.class,args);
    }
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
</code></pre> 
<p>然后在我们的order-service业务中进行调用</p> 
<pre><code class="language-java">@Service
@Slf4j
public class OrderServiceImpl implements IOrderService {

    @Autowired
    private OrderDao orderDao;
    @Autowired
    private RestTemplate restTemplate;
    @Autowired
    private DiscoveryClient discoveryClient;
    @Override
    public void createOrder(Long productId,Long userId) {
        log.info("接收到{}号商品的下单请求,接下来调⽤商品微服务查询此商品信息",
                productId);
        //远程调⽤商品微服务,查询商品信息
        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances("product-service");
        ServiceInstance serviceInstance = instances.get(0);
        int port = serviceInstance.getPort();
        String host = serviceInstance.getHost();
        Product product = restTemplate.getForObject("http://" + host + ":" + port + "/product/" + productId, Product.class);
        log.info("查询到{}号商品的信息,内容是:{}", productId,JSON.toJSONString(product));
        
    }
}
</code></pre> 
<p>我们写一个方法执行上面的逻辑即可</p> 
<pre><code class="language-java">@RestController
@Slf4j
public class OrderController {
    @Autowired
    private IOrderService orderService;

    @RequestMapping("/save")
    public void order(Long pid,Long uid){
        return orderService.createOrder(pid, uid);
    }
}</code></pre> 
<p><img alt="" height="54" src="https://images2.imgbox.com/a4/fc/cv00GcQO_o.png" width="397"></p> 
<p>当我们访问这个接口后，查看控制台</p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/7a/0c/knUN8U5E_o.png" width="1200"></p> 
<p>已经成功调用商品服务</p> 
<p>当然这样服务调用很麻烦，所以后面我们会使用openfeign替换</p> 
<h3>4.4当nacos检测到某个服务出现问题</h3> 
<p>此时我们查看nacos控制台</p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/74/c8/5ENnwySJ_o.png" width="1200"></p> 
<p>两个服务都正常</p> 
<p>当我们停掉product-service服务        当大概十五秒后查看nacos可以看到商品服务成为了不健康实例        这是因为nacos十五秒没有收到这个服务发送的心跳就认为这个服务是不健康的</p> 
<p><img alt="" height="412" src="https://images2.imgbox.com/b3/6e/KEuqDymt_o.png" width="1200"></p> 
<p>再大概过十五秒        发现商品服务已经没有了，这是因为nacos超过三十秒没有感知到这个服务，则这个服务则会被Nacos剔除。</p> 
<p><img alt="" height="371" src="https://images2.imgbox.com/2c/e5/N2riDzmg_o.png" width="1200"></p> 
<p></p> 
<h3>4.5关闭Nacos服务会怎么样</h3> 
<p>当Nacos意外停止时，还能调用服务吗</p> 
<p>我们将商品服务和订单服务重新都启动起来</p> 
<p>这时候我们关闭Nacos的控制台</p> 
<p><img alt="" height="259" src="https://images2.imgbox.com/6d/c3/QDjKCYPh_o.png" width="1026"></p> 
<p>这时候我们访问localhost:8848/nacos已经访问不到了，但是此时我们调用服务会怎么样呢？</p> 
<p>我们继续调用刚才的/save方法</p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/08/e1/A7z5xSMX_o.png" width="1200"></p> 
<p>可以看到仍然获取到了商品信息，即调用到了商品服务的接口</p> 
<p>这是因为当nacos关闭时，但是本地缓存的依然存在（在上面我们说了每次获取到服务列表后会将服务列表缓存到本地），所以才能仍然获取到这个实例的信息并进行调用。</p> 
<p></p> 
<p>但是当我们关闭商品服务后，测试获取商品服务的实例</p> 
<pre><code class="language-java">@RestController
@Slf4j
public class NacosController {

    @Autowired
    private DiscoveryClient discoveryClient;

    @GetMapping("test")
    public void test(){
        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances("product-service");
        ServiceInstance serviceInstance = instances.get(0);
        int port = serviceInstance.getPort();
        String host = serviceInstance.getHost();
        log.info("获取服务名为product-service的第一个服务：{}",serviceInstance);
        log.info("获取服务名为product-service的第一个服务port：{}",port);
        log.info("获取服务名为product-service的第一个服务host：{}",host);
    }
}</code></pre> 
<p>访问test接口</p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/65/17/684Yg9ru_o.png" width="1200"></p> 
<p>可以看到即使商品服务关闭了，但是仍能获取到商品服务的实例，这是因为缓存到本地之后，没有了nacos的推送更新，导致只从缓存中获取实例信息，就会导致我们后面业务调用异常<img alt="" height="343" src="https://images2.imgbox.com/e3/7b/0SbOKevX_o.png" width="1151"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3004ca5e69b54dfbc1fc6623b932c710/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">redisson的延时队列机制简述</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e3adbd87f271b3a22eee6dc3755d6138/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Docker-解决Debian9阿里云源 apt update时需要公钥的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>