<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue使用websocket实现实时数据推送，发布订阅重连单点登录功能 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue使用websocket实现实时数据推送，发布订阅重连单点登录功能" />
<meta property="og:description" content="需求：使用websocket不借助插件实现发布，订阅，网络断开重连，单点登录后挤号的功能
1.单点登录（同一账号同一时间只有一个在线，禁止多用户登录） 实现：在用户登录之后获取到token令牌并且存入到本地，可以判断token令牌是否失效来让用户退出登录，websocket的操作是让用户登录后连接到websocket并且发送指令，这边发送的指令是后端给的，之后前端进行接受消息，如果消息是退出登录的直接让他清空本地并且跳转到登录页就行
1.登录获取token令牌并且存储到localStorage
2.在layout也就是页面主体框架拿到token并且去连接websocket
3.连接成功后直接发送指令，之后再去监听返给前端的消息之后实现退出操作
url = `${protocol}://websocket的地址，要后端给?token=${token}`;，
这个我举个例子，连接地址应该是这样的：ws://127.0.0.1:8080?token=362466325，
ws.send(`msg:${this.data.id}`);这个也是后端定的要把账户的id给他，这样去监听登录
重连，之后消息返回loginOut后做退出登录的操作，如果链接因为各种原因关闭了，直接去请求重连。
retryCount: 0,
maxRetryCount: 5,
retryInterval: 2000, // 重试间隔时间，单位：毫秒
注意！！websocket不能设置请求头携带token好像，试了很多次都不行，用ws插件也不行，只能拼接token给后端了，有更好的方法可以在评论区联系我
let ws; let url = &#34;&#34;; export default { mounted() { this.connectWebsocket(); }, methods: { connectWebsocket() { let protocol = &#34;ws&#34;; if (typeof WebSocket === &#34;undefined&#34;) { console.log(&#34;您的浏览器不支持WebSocket&#34;); return; } else { if (window.location.protocol == &#34;https:&#34;) { protocol = &#34;wss&#34;; } let token = localStorage.getItem(&#34;token&#34;); url = `${protocol}://websocket的地址，要后端给?token=${token}`; // 打开一个ws ws = new WebSocket(url); ws." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/16c4798e7b26c62085317dbb2c613328/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-20T09:23:56+08:00" />
<meta property="article:modified_time" content="2023-11-20T09:23:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue使用websocket实现实时数据推送，发布订阅重连单点登录功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>需求：使用websocket不借助插件实现发布，订阅，网络断开重连，单点登录后挤号的功能</p> 
</blockquote> 
<h3>1.单点登录（同一账号同一时间只有一个在线，禁止多用户登录）</h3> 
<blockquote> 
 <p> 实现：在用户登录之后获取到token令牌并且存入到本地，可以判断token令牌是否失效来让用户退出登录，websocket的操作是让用户登录后连接到websocket并且发送指令，这边发送的指令是后端给的，之后前端进行接受消息，如果消息是退出登录的直接让他清空本地并且跳转到登录页就行</p> 
 <p>1.登录获取token令牌并且存储到localStorage</p> 
 <p>2.在layout也就是页面主体框架拿到token并且去连接websocket</p> 
 <p>3.连接成功后直接发送指令，之后再去监听返给前端的消息之后实现退出操作</p> 
</blockquote> 
<p>     url = `${protocol}://websocket的地址，要后端给?token=${token}`;，</p> 
<p>这个我举个例子，<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">连接地址应该是这样的：ws://127.0.0.1:8080?token=362466325，</span></span></p> 
<blockquote> 
 <p> ws.send(`msg:${this.data.id}`);这个也是后端定的要把账户的id给他，这样去监听登录</p> 
 <p>重连，之后消息返回loginOut后做退出登录的操作，如果链接因为各种原因关闭了，直接去请求重连。</p> 
 <p> retryCount: 0,</p> 
 <p> maxRetryCount: 5,</p> 
 <p> retryInterval: 2000, // 重试间隔时间，单位：毫秒</p> 
 <p><span style="color:#fe2c24;"><span style="background-color:#fff5e6;">注意！！websocket不能设置请求头携带token好像，试了很多次都不行，用ws插件也不行，只能拼接token给后端了，有更好的方法可以在评论区联系我</span></span></p> 
</blockquote> 
<pre><code class="language-javascript">let ws;
let url = "";
export default { 
 mounted() {
    this.connectWebsocket();
  },
  methods: {
    connectWebsocket() {
      let protocol = "ws";

      if (typeof WebSocket === "undefined") {
        console.log("您的浏览器不支持WebSocket");
        return;
      } else {
        if (window.location.protocol == "https:") {
          protocol = "wss";
        }
        let token = localStorage.getItem("token");
        url = `${protocol}://websocket的地址，要后端给?token=${token}`;
        // 打开一个ws
        ws = new WebSocket(url);
        ws.onopen = () =&gt; {
          // 发送数据
          console.log("ws已连接！！");
          ws.send(`msg:${this.data.id}`);
          // this.$message.success("ws已连接！！");
        };
        // 发生错误时
        ws.onerror = (evt) =&gt; {
          console.log("ws错误：", evt);
        };
        // 关闭连接
        ws.onclose = (event) =&gt; {
          console.warn("WebSocket 已关闭");
          console.log("关闭代码：", event.code);
          console.log("关闭原因：", event.reason);
          // 处理连接断开事件
          this.handleWebSocketClose();
        };
        ws.onmessage = (evt) =&gt; {
          if (evt.data == "loginOut") {
            // 此时要做清空数据的操作
            this.$message.warning("您的帐号在另一地点登录，您已被迫下线!!");
            this.$router.replace("/");
            localStorage.clear();
            ws.close();
            ws.onclose = () =&gt; {
              console.log("ws断开连接成功");
            };
          }
          console.log(evt, "接收到的消息");
        };
        this.$bus.$emit("Websocket", ws);
      }
    },
    handleWebSocketClose() {
      if (this.retryCount &lt; this.maxRetryCount) {
        console.log(`正在尝试第 ${this.retryCount + 1} 次重连...`);
        setTimeout(() =&gt; {
          this.connectWebsocket();
          this.retryCount++;
        }, this.retryInterval);
      } else {
        console.error("WebSocket 连接失败，已达到最大重试次数");
      }
    },
}
}</code></pre> 
<h3>2.发布订阅</h3> 
<p><span style="color:#fe2c24;"><span style="background-color:#fefcd8;">注意！！这边每次发布的时候都应该重新连一个新的消息</span></span>，不然和之前的登录的消息搞混了就不好了，特别是在做操作的时候，比如el-table的编辑操作这些，每次关闭弹窗肯定要关闭websocket，如果和登录的消息搞混了，关闭弹窗就不能实时接收到单点登录传来的消息了</p> 
<p>这个connectWebsocket和上面的不是一个，这个是需要实时推送页面的websocket连接，不会影响全局的单点登录的。</p> 
<pre><code class="language-javascript">&lt;script&gt;
let websocket;
let url = "";
    export default {
connectWebsocket(data) {
      let protocol = "ws";

      if (typeof WebSocket === "undefined") {
        console.log("您的浏览器不支持WebSocket");
        return;
      } else {
        if (window.location.protocol == "https:") {
          protocol = "wss";
        }
        let token = localStorage.getItem("token");
        url = `${protocol}://后端的给的地址?token=${token}`;
        // 打开一个websocket
        websocket = new WebSocket(url);
        websocket.onopen = () =&gt; {
          // 发送数据
          // console.log("websocket已连接！！");
          websocket.send(data);
          this.$message.success("websocket已连接！！");
        };
        // 发生错误时
        websocket.onerror = (evt) =&gt; {
          console.log("websocket错误：", evt);
        };
        // 关闭连接
        websocket.onclose = (event) =&gt; {
          console.warn("WebSocket 已关闭");
          console.log("关闭代码：", event.code);
          console.log("关闭原因：", event.reason);
          // 处理连接断开事件
          this.handleWebSocketClose(data);
        };
      }
    },
    handleWebSocketClose(data) {
      if (this.retryCount &lt; this.maxRetryCount) {
        console.log(`正在尝试第 ${this.retryCount + 1} 次重连...`);
        setTimeout(() =&gt; {
          this.connectWebsocket(data);
          this.retryCount++;
        }, this.retryInterval);
      } else {
        this.$message.error("WebSocket 连接失败!!");
        console.error("WebSocket 连接失败，已达到最大重试次数");
      }
    },
}
&lt;/script&gt;
</code></pre> 
<h4><strong>2.1模拟编辑操作需要发布消息</strong></h4> 
<p><strong>1.点击编辑后打开并且实时接收</strong></p> 
<pre><code class="language-javascript">    updData(row) {
      this.connectWebsocket(`data_imei:${row.id}`);
      websocket.onmessage = (evt) =&gt; {
    //如果收到的消息是msgUpd
    if(evt.data=='msgUpd'){
  let data = JSON.parse(evt.data);
    //把得到的数据进行json转换之后再给tableData进行展示就行
    let tableData.unshift(data)
    //也不能一直接受吧，那数据得多少啊，定义一下接收到多少条后截取
      if (tableData.length &gt; 500) {
           tableData.splice(500);
          }
        }
    }
}</code></pre> 
<p><strong>2.关闭弹窗后需要断开连接</strong></p> 
<pre><code class="language-javascript">  closeWebSocket() {
      if (websocket != null) {
        websocket.close();
        websocket.onclose = () =&gt; {
          console.log("websocket断开连接成功");
        };
      }
    },</code></pre> 
<p><strong>3.在离开websocket推送页面后也关闭连接</strong></p> 
<pre><code class="language-javascript">  destroyed() {
    if (websocket != null) {
      websocket.close();
      websocket.onclose = () =&gt; {
        console.log("websocket断开连接成功");
      };
    }
  },</code></pre> 
<p>文章到此结束，希望对你所有帮助~~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e7ec3a10c823ae09e554f510017ae7d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">定时器相关方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c5daf39b0cd087be15b8e62e1575890/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">考情实况系列：把控考场节奏，从容拿下Datacom HCIE认证</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>