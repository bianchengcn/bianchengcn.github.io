<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>冯诺依曼结构、哈佛结构、改进型哈佛结构 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="冯诺依曼结构、哈佛结构、改进型哈佛结构" />
<meta property="og:description" content="冯诺依曼结构
冯·诺依曼结构，又称为普林斯顿体系结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。取指令和取操作数都在同一总线上，通过分时复用的方式进行；缺点是在高速运行时，不能达到同时取指令和取操作数，从而形成了传输过程的瓶颈。由于程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同。
冯·诺依曼结构处理器具有以下几个特点：
必须有一个存储器；
必须有一个控制器；
必须有一个运算器，用于完成算术运算和逻辑运算；
必须有输入和输出设备，用于进行人机通信。
冯·诺依曼的主要贡献就是提出并实现了“存储程序”的概念。由于指令和数据都是二进制码，指令和操作数的地址又密切相关，因此，当初选择这种结构是自然的。但是，这种指令和数据共享同一总线的结构，使得信息流的传输成为限制计算机性能的瓶颈，影响了数据处理速度的提高。
在典型情况下，完成一条指令需要3个步骤，即：取指令、指令译码和执行指令。从指令流的定时关系也可看出冯·诺依曼结构与哈佛结构处理方式的差别。举一个最简单的对存储器进行读写操作的指令，指令1至指令3均为存、取数指令，对冯·诺依曼结构处理器，由于取指令和存取数据要从同一个存储空间存取，经由同一总线传输，因而它们无法重叠执行，只有一个完成后再进行下一个。
例如最常见的卷积运算中， 一条指令同时取两个操作数， 在流水线处理时， 同时还有一个取指操作， 如果程序和数据通过一条总线访问， 取指和取数必会产生冲突， 而这对大运算量的循环的执行效率是很不利的。
哈佛结构
哈佛结构是一种将程序指令存储和数据存储分开的存储器结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问，目的是为了减轻程序运行时的访存瓶颈。
哈佛结构能基本上解决取指和取数的冲突问题。
哈佛结构的中央处理器首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据，并进行下一步的操作（通常是执行）。程序指令储存和数据储存分开，数据和指令的储存可以同时进行，可以使指令和数据有不同的数据宽度，如Microchip公司的PIC16芯片的程序指令是14位宽度，而数据是8位宽度。
如果采用哈佛结构处理以上同样的3条存取数指令，由于取指令和存取数据分别经由不同的存储空间和不同的总线，使得各条指令可以重叠执行，这样，也就克服了数据流传输的瓶颈，提高了运算速度。
哈佛结构处理器有两个明显的特点：
(1).使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；
(2).使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。
改进型哈佛结构
改进型哈佛结构虽然也使用两个不同的存储器：程序存储器和数据存储器，但它把两个存储器的地址总线合并了，数据总线也进行了合并，即原来的哈佛结构需要４条不同的总线，改进后需要两条总线。
改进的哈佛结构，其结构特点为：
(1).使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；
(2).具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；
(3).两条总线由程序存储器和数据存储器分时共用。
改进型哈佛结构其结构特点为：
使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存，以便实现并行处理；
具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；
两条总线由程序存储器和数据存储器分时共用。
各结构对比分析
总结
总得来说，哈佛机构的高性能体现在在单片机、DSP芯片平台上运行的程序种类和花样较少，因为各个电子娱乐产品中的软件升级比较少，应用程序可以用汇编作为内核，最高效率的利用流水线技术，获得最高的效率。
冯诺依曼结构主要是基于电脑购买者对电脑的使用途径不同—-各种娱乐型用户、各种专业开发用户等，且安装的软件的种类繁多，升级频繁，多种软件同时运行时处理的优先级比较模糊，因特尔芯片不具备彻底智能分配各程序优先级和流水线的机制，机械的分配优先和流水线反而容易使用户不便。
冯氏结构简单、易实现、成本低，但效率偏低；哈佛结构效率高但复杂，对外围设备的连接与处理要求高，十分不适合外围存储器的扩展。现在的处理器，依托CACHE的存在，已经很好的将二者统一起来了。现在的处理器虽然外部总线上看是诺依曼结构的，但是由于内部CACHE的存在，因此实际上内部来看已经类似改进型哈佛结构的了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/49f4703c45bf2ce3f19de623ff8b5800/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-22T18:22:43+08:00" />
<meta property="article:modified_time" content="2021-04-22T18:22:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">冯诺依曼结构、哈佛结构、改进型哈佛结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>冯诺依曼结构</p> 
<p>冯·诺依曼结构，又称为普林斯顿体系结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。取指令和取操作数都在同一总线上，通过分时复用的方式进行；缺点是在高速运行时，不能达到同时取指令和取操作数，从而形成了传输过程的瓶颈。由于程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同。</p> 
<ul><li> <p>冯·诺依曼结构处理器具有以下几个特点：</p> </li><li> <p>必须有一个存储器；</p> <p>必须有一个控制器；</p> <p>必须有一个运算器，用于完成算术运算和逻辑运算；</p> <p>必须有输入和输出设备，用于进行人机通信。</p> </li><li> <p>冯·诺依曼的主要贡献就是提出并实现了“存储程序”的概念。由于指令和数据都是二进制码，指令和操作数的地址又密切相关，因此，当初选择这种结构是自然的。但是，这种指令和数据共享同一总线的结构，使得信息流的传输成为限制计算机性能的瓶颈，影响了数据处理速度的提高。</p> </li><li> <p>在典型情况下，完成一条指令需要3个步骤，即：取指令、指令译码和执行指令。从指令流的定时关系也可看出冯·诺依曼结构与哈佛结构处理方式的差别。举一个最简单的对存储器进行读写操作的指令，指令1至指令3均为存、取数指令，对冯·诺依曼结构处理器，由于取指令和存取数据要从同一个存储空间存取，经由同一总线传输，因而它们无法重叠执行，只有一个完成后再进行下一个。</p> </li><li> <p>例如最常见的卷积运算中， 一条指令同时取两个操作数， 在流水线处理时， 同时还有一个取指操作， 如果程序和数据通过一条总线访问， 取指和取数必会产生冲突， 而这对大运算量的循环的执行效率是很不利的。</p> </li></ul> 
<p><img alt="" height="577" src="https://images2.imgbox.com/d3/7b/NKGqQQSl_o.png" width="1007"><br> 哈佛结构</p> 
<p>哈佛结构是一种将程序指令存储和数据存储分开的存储器结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问，目的是为了减轻程序运行时的访存瓶颈。</p> 
<p>哈佛结构能基本上解决取指和取数的冲突问题。</p> 
<p>哈佛结构的中央处理器首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据，并进行下一步的操作（通常是执行）。程序指令储存和数据储存分开，数据和指令的储存可以同时进行，可以使指令和数据有不同的数据宽度，如Microchip公司的PIC16芯片的程序指令是14位宽度，而数据是8位宽度。</p> 
<p>如果采用哈佛结构处理以上同样的3条存取数指令，由于取指令和存取数据分别经由不同的存储空间和不同的总线，使得各条指令可以重叠执行，这样，也就克服了数据流传输的瓶颈，提高了运算速度。</p> 
<ul><li> <p>哈佛结构处理器有两个明显的特点：</p> </li><li> <p>(1).使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；</p> </li><li> <p>(2).使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。</p> </li></ul> 
<p><img alt="" height="694" src="https://images2.imgbox.com/8c/9f/Adi1E9PK_o.png" width="1200"><br> 改进型哈佛结构</p> 
<p>改进型哈佛结构虽然也使用两个不同的存储器：程序存储器和数据存储器，但它把两个存储器的地址总线合并了，数据总线也进行了合并，即原来的哈佛结构需要４条不同的总线，改进后需要两条总线。</p> 
<ul><li> <p>改进的哈佛结构，其结构特点为：</p> </li><li> <p>(1).使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；</p> </li><li> <p>(2).具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；</p> </li><li> <p>(3).两条总线由程序存储器和数据存储器分时共用。</p> </li></ul> 
<p><img alt="" height="732" src="https://images2.imgbox.com/e3/16/9LuHyaCr_o.png" width="1068"><br> 改进型哈佛结构其结构特点为：<br> 使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存，以便实现并行处理；<br> 具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；<br> 两条总线由程序存储器和数据存储器分时共用。<br> 各结构对比分析</p> 
<p><img alt="" height="220" src="https://images2.imgbox.com/5d/a6/4LpfHdN7_o.png" width="721"><br><img alt="" height="350" src="https://images2.imgbox.com/1c/47/OJE74R9y_o.png" width="732"><br><img alt="" height="364" src="https://images2.imgbox.com/b0/31/DPAibu8j_o.png" width="676"><br> 总结</p> 
<p>总得来说，哈佛机构的高性能体现在在单片机、DSP芯片平台上运行的程序种类和花样较少，因为各个电子娱乐产品中的软件升级比较少，应用程序可以用汇编作为内核，最高效率的利用流水线技术，获得最高的效率。<br> 冯诺依曼结构主要是基于电脑购买者对电脑的使用途径不同—-各种娱乐型用户、各种专业开发用户等，且安装的软件的种类繁多，升级频繁，多种软件同时运行时处理的优先级比较模糊，因特尔芯片不具备彻底智能分配各程序优先级和流水线的机制，机械的分配优先和流水线反而容易使用户不便。<br> 冯氏结构简单、易实现、成本低，但效率偏低；哈佛结构效率高但复杂，对外围设备的连接与处理要求高，十分不适合外围存储器的扩展。现在的处理器，依托CACHE的存在，已经很好的将二者统一起来了。现在的处理器虽然外部总线上看是诺依曼结构的，但是由于内部CACHE的存在，因此实际上内部来看已经类似改进型哈佛结构的了。<br>  </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d1210ed2a05c47c910c8f213eb7d2d8b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue &#43; websocket &#43; element  Notification 消息推送</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/12c0352669679a72880f74e627d54436/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">kali更新源失败解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>