<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>哈希表（C&#43;&#43;实现） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="哈希表（C&#43;&#43;实现）" />
<meta property="og:description" content="关于Hash Table， 总结如下：
散列表能够实现通过key 对元素的快速访问。 而且易于扩展。 对元素能够实现快速访问（搜索等字典操作）， 这是Hash Table 较之于链表的优势所在， 二者均易于扩展。 而易于扩展这个dynamic的结构（使用链接法的时候）又是较之于array的优势所在。 因为数组时不易于扩展的。 使用散列表， 我们需要使用Hash function。 散列函数是对关键字和散列表元提供映射的函数。 常见的Hash function 有如下几种：
（1）直接寻址法。 取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key &#43; b，其中a和b为常数（这种散列函数叫做自身函数）
（2）除法散列法， 关键字k 除以m 取余数， 将关键字k 映射到m个slots 中的一个上， 即 h(k) = k mod m， 一般取m 为素数。
（3）乘法散列法： 包含两步：
step 1:用关键字k 乘上常数A（0&lt;A &lt;1）, 并提取kA d的小数部分。
step 2: 用m 乘以这个小数部分的值， 再往下取整，
总之， 散列函数为： h(k) = floor(m(kA mod 1))。 乘法散列的好处就是m 可以是2的某个次幂。 而不只是素数了。
（4） 折叠法： 将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。
等等还有好多散列函数。
散列函数的性能直接影响着散列表数据结构的性能。 当散列函数把太少或太多关键字映射到单个散列表元上时，散列表的使用效率会大大降低。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c1deadd8eedfaa6f394e6216a52868c8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-23T17:42:22+08:00" />
<meta property="article:modified_time" content="2018-11-23T17:42:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">哈希表（C&#43;&#43;实现）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>关于Hash Table， 总结如下：</p> 
<p>散列表能够实现通过key 对元素的快速访问。 而且易于扩展。 对元素能够实现快速访问（搜索等字典操作）， 这是Hash Table 较之于链表的优势所在， 二者均易于扩展。 而易于扩展这个dynamic的结构（使用链接法的时候）又是较之于array的优势所在。  因为数组时不易于扩展的。 </p> 
<p> </p> 
<p>使用散列表， 我们需要使用Hash function。 散列函数是对关键字和散列表元提供映射的函数。 常见的Hash function 有如下几种：</p> 
<p>（1）直接寻址法。  取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，其中a和b为常数（这种散列函数叫做自身函数）</p> 
<p>（2）除法散列法， 关键字k 除以m 取余数， 将关键字k 映射到m个slots 中的一个上， 即 h(k) = k mod m， 一般取m 为素数。</p> 
<p>（3）乘法散列法： 包含两步：</p> 
<p>          step 1:用关键字k 乘上常数A（0&lt;A &lt;1）, 并提取kA d的小数部分。</p> 
<p>           step 2: 用m 乘以这个小数部分的值， 再往下取整，</p> 
<p>        总之， 散列函数为： h(k) = floor(m(kA mod 1))。 乘法散列的好处就是m 可以是2的某个次幂。 而不只是素数了。</p> 
<p>（4） 折叠法： 将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。</p> 
<p>等等还有好多散列函数。</p> 
<p> </p> 
<p>散列函数的性能直接影响着散列表数据结构的性能。 当散列函数把太少或太多关键字映射到单个散列表元上时，散列表的使用效率会大大降低。</p> 
<p>性能最好的散列函数被称为完全散列函数。即保证所有可能的关键字都会分别映射到唯一的散列表元编号上。</p> 
<p>通常很难找到一个完全散列函数。 不完全的散列函数就会导致冲突的发生。 冲突是散列表的一个缺点之一。</p> 
<p>一般而言， 冲突是无法避免的。 因为关键字的域是无穷的， 而映射到的表中， 表的大小是一定的， 不可能是无穷大的。</p> 
<p> </p> 
<p>既然无法避免冲突， 那么我们就要解决冲突， 解决办法有如下几种：</p> 
<p>方法一： 开放寻址法（open addressing）：</p> 
<p>所有的元素都在散列表中。 不会像链接法那样， 这里没有链表， 也没有链表存放在散列表外。 缺点是散列表可能被插满了。 而且此时的Hash Table也不容易扩展， 即不是dynamic的了。 我们希望我们的散列函数实现均匀散列（uniform hashing）， 即每个关键字等可能的插入到slot 中。 但是这只是理想， 通常情况下， 会出现cluste的现象。 出现冲突的时候， 有三种方法用于探查开放寻址中的探查序列：（1）Linear probing（线性探查）（2）二次探查 （3）双重探查。</p> 
<p> </p> 
<p>方法二： 链接法（chaining）。 不难看出此时我们的Hash Table 变成了dynamic的了。 使用允许一个散列表元放置多个元素的方法，这时实际上散列表就是一个链表数组</p> 
<p> </p> 
<p>基于链接法的C++代码如下：</p> 
<p>hashtable.h</p> 
<pre class="has"><code class="language-cpp">#ifndef HASHTABLE_H
#define HASHTABLE_H

#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;

using namespace std;

class Hash
{
private:
    struct item
    {
        string name;
        string drink;
        item* next;

        item(): name("empty"), drink("empty"), next(nullptr) {}
        item(string n, string d): name(n), drink(d), next(nullptr) {}
    };
    static const int tableSize = 10;  // 存储量可改变
    item* HashTable[tableSize];

public:
    int hashFunction(string key);
    Hash();
    ~Hash();
    void AddItem(string name, string drink);
    int NumberOfItemsInIndex(int index);
    void PrintTable();
    void PrintItemsInIndex(int index);
    void FindDrink(string name);
    void RemoveItem(string name);

};

#endif // HASHTABLE_H
</code></pre> 
<p>hashtable.cpp</p> 
<pre class="has"><code class="language-cpp">#include "hashtable.h"

Hash::Hash()
{
    for (int i = 0; i &lt; tableSize; ++i)
    {
        HashTable[i] = new item();
        HashTable[i]-&gt;name = "empty";
        HashTable[i]-&gt;drink = "empty";
        HashTable[i]-&gt;next = nullptr;
    }
}

Hash::~Hash()
{

}

int Hash::hashFunction(string key)
{
    int sum = 0;
    int index;

    for (size_t i = 0; i &lt; key.size(); ++i)
    {
        sum += static_cast&lt;int&gt;(key[i]);
    }

    index = sum % tableSize;

    cout &lt;&lt; "key[0] = " &lt;&lt; key[0] &lt;&lt; endl;
    cout &lt;&lt; "key[0] = " &lt;&lt; static_cast&lt;int&gt;(key[0]) &lt;&lt; endl;
    cout &lt;&lt; "key[1] = " &lt;&lt; key[1] &lt;&lt; endl;
    cout &lt;&lt; "key[2] = " &lt;&lt; key[2] &lt;&lt; endl;
    cout &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; endl;
    cout &lt;&lt; "index = " &lt;&lt; index &lt;&lt; endl &lt;&lt; endl;

    return index;
}

void Hash::AddItem(string name, string drink)
{
    int index = hashFunction(name);

    if (HashTable[index]-&gt;name == "empty")
    {
        HashTable[index]-&gt;name = name;
        HashTable[index]-&gt;drink = drink;
    }
    else
    {
        item* p = HashTable[index];
        item* n = new item(name, drink);

        while (p-&gt;next != nullptr)
        {
            p = p-&gt;next;
        }
        p-&gt;next = n;
    }
}

int Hash::NumberOfItemsInIndex(int index)
{
    int count = 0;
    if (HashTable[index]-&gt;name == "empty")
    {
        return count;
    }
    else
    {
        count++;
        item* p = HashTable[index];
        while (p-&gt;next != nullptr)
        {
            count++;
            p = p-&gt;next;
        }
    }
    return count;
}

void Hash::PrintTable()
{
    int number;
    for (int i = 0; i &lt; tableSize; ++i)
    {
        cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; ": " &lt;&lt; endl;
        number = NumberOfItemsInIndex(i);
        cout &lt;&lt; "index = " &lt;&lt; i &lt;&lt; ": " &lt;&lt; endl;
        cout &lt;&lt; HashTable[i]-&gt;name &lt;&lt; ", " &lt;&lt; HashTable[i]-&gt;drink &lt;&lt; endl;
        cout &lt;&lt; "# of items = " &lt;&lt; number &lt;&lt; endl &lt;&lt; endl;
    }
}

void Hash::PrintItemsInIndex(int index)
{
    item* p = HashTable[index];
    if (p-&gt;name == "empty")
    {
        cout &lt;&lt; "index = " &lt;&lt; index &lt;&lt; "is empty";
    }
    else
    {
        cout &lt;&lt; "index " &lt;&lt; index &lt;&lt; " contains the following items \n";
        while (p != nullptr)
        {
            cout &lt;&lt; p-&gt;name &lt;&lt; ", " &lt;&lt; p-&gt;drink &lt;&lt;endl;
            p = p-&gt;next;
        }
    }
}

void Hash::FindDrink(string name)
{
    int index = hashFunction(name);
    bool FindName = false;

    string drink;
    item* p = HashTable[index];
    while (p != nullptr)
    {
        if (p-&gt;name == name)
        {
            FindName = true;
            drink = p-&gt;drink;
        }
        p = p-&gt;next;
    }
    if (FindName)
    {
        cout &lt;&lt; "Favorite drink " &lt;&lt; drink &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; name &lt;&lt; "'s info was not fount in the hash table.\n";
    }
}

void Hash::RemoveItem(string name)
{
    int index = hashFunction(name);

    item* delPtr;
    item* p1;
    item* p2;

    // case0: bucket is empty
    if (HashTable[index]-&gt;name == "empty" &amp;&amp;
        HashTable[index]-&gt;drink == "empty")
    {
        cout &lt;&lt; name &lt;&lt; " was not found in the hash table" &lt;&lt; endl;
    }
    // case1: only one item contained in the bucket, and that item has matching name
    else if (HashTable[index]-&gt;name == name &amp;&amp;
             HashTable[index]-&gt;next == nullptr)
    {
        HashTable[index]-&gt;name = "empty";
        HashTable[index]-&gt;drink = "empty";
        cout &lt;&lt; name &lt;&lt; " was removed from the hash table" &lt;&lt; endl;
    }
    // case 2: match is located in the first item in the bucket and there are more items in the bucket
    else if (HashTable[index]-&gt;name == name)
    {
        delPtr = HashTable[index];
        HashTable[index] = HashTable[index]-&gt;next;
        delete delPtr;
        cout &lt;&lt; name &lt;&lt; " was removed from the hash table" &lt;&lt; endl;
    }
    // case 3: the bucket contains items, but first item is not a match
    else
    {
        p1 = HashTable[index]-&gt;next;
        p2 = HashTable[index];
        while (p1 != nullptr &amp;&amp; p1-&gt;name != name)
        {
            p2 = p1;
            p1 = p1-&gt;next;
        }
        // case 3.1: no match
        if (p1 == nullptr)
        {
            cout &lt;&lt; name &lt;&lt; " was not found in the hash table. \n";
        }
        //case 3.2: match is found
        else
        {
            delPtr = p1;
            p1 = p1-&gt;next;
            p2-&gt;next = p1;
            delete delPtr;
            cout &lt;&lt; name &lt;&lt; " was removed from the hash table" &lt;&lt; endl;
        }
    }
}
</code></pre> 
<p>main.cpp</p> 
<pre class="has"><code>#include "hashtable.cpp"

int main()
{
    Hash hash;
    string name1 = " ";
    string name2 = " ";
    hash.PrintTable();

    hash.AddItem("Paul", "Locha");
    hash.AddItem("Kim", "Iced Mocha");
    hash.AddItem("Anni", "Strawberry Smoothy");
    hash.AddItem("Sara", "Passion Tea");
    hash.AddItem("Mike", "Tea");
    hash.AddItem("steve", "Apple cider");
    hash.AddItem("Sill", "Root beer");
    hash.AddItem("Bill", "Lochs");
    hash.AddItem("Susan", "Cola");
    hash.AddItem("Joe", "Green Tea");

    hash.PrintTable();
    hash.PrintItemsInIndex(0);

    while (name1 != "exit")
    {
        cout &lt;&lt; "search for: ";
        cin &gt;&gt; name1;
        if (name1 != "exit")
        {
            hash.FindDrink(name1);
        }
    }

    cout &lt;&lt; endl;

    while (name2 != "exit")
    {
        cout &lt;&lt; "Remove: ";
        cin &gt;&gt; name2;
        if (name2 != "exit")
        {
            hash.RemoveItem(name2);
        }
    }

    hash.PrintTable();
    hash.PrintItemsInIndex(0);

    return 0;
}
</code></pre> 
<p> </p> 
<p>部分运行结果如下：</p> 
<p><img alt="" class="has" height="1034" src="https://images2.imgbox.com/7b/aa/2glTTvBF_o.png" width="677"></p> 
<p> </p> 
<p><img alt="" class="has" height="1034" src="https://images2.imgbox.com/97/c7/T8uBIOYU_o.png" width="677"></p> 
<p> </p> 
<p><img alt="" class="has" height="1034" src="https://images2.imgbox.com/b4/69/pncoAQdA_o.png" width="677"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/17193eb11f91f95419573e5ec285bc1d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">advanced installer详细做包教程：预安装，开机自启等</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4382ec996b5f512e526e1661136c91ca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;    C2678  二进制“小于” 没有找到接受“const XXX”类型的左操作数的运算符(或没有可接受的转换)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>