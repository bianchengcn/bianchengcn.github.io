<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>cv::Mat与Base64转换（含图片压缩解压等流程） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="cv::Mat与Base64转换（含图片压缩解压等流程）" />
<meta property="og:description" content="测试流程就是：图片-&gt;压缩图片-&gt;base64-&gt;解压图片-&gt;图片
(注意压缩会失真的，可以不压缩，但是base64会比较大)
main.cpp #include &#34;stdafx.h&#34; #include &lt;Windows.h&gt; #include &#34;base64.h&#34; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/opencv.hpp&gt; #include &lt;vector&gt; #include &lt;cstdio&gt; using namespace std; using namespace cv; #define MAX_SIZE_BASE64 100000 int main() { long t1 = GetTickCount(); string source_data, source_data_encode; Mat srcImage, grayImage,dstImage; //读取图片1 srcImage = imread(&#34;image.jpg&#34;); dstImage = srcImage.clone(); imshow(&#34;【原图】&#34;, srcImage); //MAT转base64 int quality = 50;	//压缩比率0～100 vector&lt;int&gt; compress_params; compress_params.push_back(IMWRITE_JPEG_QUALITY); compress_params.push_back(quality); std::vector&lt;unsigned char&gt; buf(MAX_SIZE_BASE64, 0);	//vector要分配内存,否则imencode会崩 cv::imencode(&#34;.jpg&#34;, dstImage, buf, compress_params); source_data." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c34e4642aeaab65f8cf45ff488f05e2d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-26T15:58:46+08:00" />
<meta property="article:modified_time" content="2022-05-26T15:58:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">cv::Mat与Base64转换（含图片压缩解压等流程）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>测试流程就是：图片-&gt;压缩图片-&gt;base64-&gt;解压图片-&gt;图片</p> 
<p>(注意压缩会失真的，可以不压缩，但是base64会比较大)</p> 
<p>main.cpp   </p> 
<pre><code class="language-cpp">#include "stdafx.h"
#include &lt;Windows.h&gt; 
#include "base64.h"
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;opencv2/opencv.hpp&gt;
 
#include &lt;vector&gt;
#include &lt;cstdio&gt;
 
using namespace std;
using namespace cv;
 
 
#define MAX_SIZE_BASE64 100000
int main()
{
	long t1 = GetTickCount();


	string source_data, source_data_encode;
	Mat srcImage, grayImage,dstImage;
	//读取图片1
	srcImage = imread("image.jpg");
	dstImage = srcImage.clone();
	imshow("【原图】", srcImage);

	//MAT转base64
	int quality = 50;	//压缩比率0～100
	vector&lt;int&gt; compress_params;
	compress_params.push_back(IMWRITE_JPEG_QUALITY);
	compress_params.push_back(quality);

	std::vector&lt;unsigned char&gt; buf(MAX_SIZE_BASE64, 0);		//vector要分配内存,否则imencode会崩
	cv::imencode(".jpg", dstImage, buf, compress_params);
	source_data.insert(source_data.begin(), buf.begin(), buf.end());
	Base64::Encode(source_data, &amp;source_data_encode);
	
	printf("len: %d \n", source_data_encode.length());

	//base64写入文件
	FILE * fp = NULL;
	fp = fopen( "data.txt", "a+" );
	if ( fp == NULL )
	return -1;
	int res=fprintf( fp, "%s\n" ,source_data_encode.c_str());
	fclose(fp);

	//base64转MAT
	Base64::Decode(source_data_encode, &amp;source_data);
	std::vector&lt;unsigned char&gt; buf2(source_data.begin(), source_data.end());
	dstImage = cv::imdecode(cv::Mat(buf2), CV_LOAD_IMAGE_COLOR);
	
	long t2 = GetTickCount();
	printf("time: %d \n", t2-t1);


	//原图1
	imshow("【转Base64再转MAT】", dstImage);
	waitKey(0);


	vector&lt;uchar&gt;().swap(buf);	//释放vector内存
	vector&lt;uchar&gt;().swap(buf2);	//释放vector内存

	return 0;
}</code></pre> 
<p></p> 
<p>base64.h</p> 
<pre><code>#pragma once

/*****base64.h*****/
#ifndef BASE64_H
#define BASE64_H

#include &lt;string&gt;
#include &lt;opencv2/opencv.hpp&gt;

const char kBase64Alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
"abcdefghijklmnopqrstuvwxyz"
"0123456789+/";

class Base64 {
public:
	static bool Encode(const std::string &amp;in, std::string *out) {
		int i = 0, j = 0;
		size_t enc_len = 0;
		unsigned char a3[3];
		unsigned char a4[4];

		out-&gt;resize(EncodedLength(in));

		int input_len = in.size();
		std::string::const_iterator input = in.begin();

		while (input_len--) {
			a3[i++] = *(input++);
			if (i == 3) {
				a3_to_a4(a4, a3);

				for (i = 0; i &lt; 4; i++) {
					(*out)[enc_len++] = kBase64Alphabet[a4[i]];
				}

				i = 0;
			}
		}

		if (i) {
			for (j = i; j &lt; 3; j++) {
				a3[j] = '\0';
			}

			a3_to_a4(a4, a3);

			for (j = 0; j &lt; i + 1; j++) {
				(*out)[enc_len++] = kBase64Alphabet[a4[j]];
			}

			while ((i++ &lt; 3)) {
				(*out)[enc_len++] = '=';
			}
		}

		return (enc_len == out-&gt;size());
	}

	static bool Encode(const char *input, size_t input_length, char *out, size_t out_length) {
		int i = 0, j = 0;
		char *out_begin = out;
		unsigned char a3[3];
		unsigned char a4[4];

		size_t encoded_length = EncodedLength(input_length);

		if (out_length &lt; encoded_length) return false;

		while (input_length--) {
			a3[i++] = *input++;
			if (i == 3) {
				a3_to_a4(a4, a3);

				for (i = 0; i &lt; 4; i++) {
					*out++ = kBase64Alphabet[a4[i]];
				}

				i = 0;
			}
		}

		if (i) {
			for (j = i; j &lt; 3; j++) {
				a3[j] = '\0';
			}

			a3_to_a4(a4, a3);

			for (j = 0; j &lt; i + 1; j++) {
				*out++ = kBase64Alphabet[a4[j]];
			}

			while ((i++ &lt; 3)) {
				*out++ = '=';
			}
		}

		return (out == (out_begin + encoded_length));
	}

	static bool Decode(const std::string &amp;in, std::string *out) {
		int i = 0, j = 0;
		size_t dec_len = 0;
		unsigned char a3[3];
		unsigned char a4[4];

		int input_len = in.size();
		std::string::const_iterator input = in.begin();

		out-&gt;resize(DecodedLength(in));

		while (input_len--) {
			if (*input == '=') {
				break;
			}

			a4[i++] = *(input++);
			if (i == 4) {
				for (i = 0; i &lt; 4; i++) {
					a4[i] = b64_lookup(a4[i]);
				}

				a4_to_a3(a3, a4);

				for (i = 0; i &lt; 3; i++) {
					(*out)[dec_len++] = a3[i];
				}

				i = 0;
			}
		}

		if (i) {
			for (j = i; j &lt; 4; j++) {
				a4[j] = '\0';
			}

			for (j = 0; j &lt; 4; j++) {
				a4[j] = b64_lookup(a4[j]);
			}

			a4_to_a3(a3, a4);

			for (j = 0; j &lt; i - 1; j++) {
				(*out)[dec_len++] = a3[j];
			}
		}

		return (dec_len == out-&gt;size());
	}

	static bool Decode(const char *input, size_t input_length, char *out, size_t out_length) {
		int i = 0, j = 0;
		char *out_begin = out;
		unsigned char a3[3];
		unsigned char a4[4];

		size_t decoded_length = DecodedLength(input, input_length);

		if (out_length &lt; decoded_length) return false;

		while (input_length--) {
			if (*input == '=') {
				break;
			}

			a4[i++] = *(input++);
			if (i == 4) {
				for (i = 0; i &lt; 4; i++) {
					a4[i] = b64_lookup(a4[i]);
				}

				a4_to_a3(a3, a4);

				for (i = 0; i &lt; 3; i++) {
					*out++ = a3[i];
				}

				i = 0;
			}
		}

		if (i) {
			for (j = i; j &lt; 4; j++) {
				a4[j] = '\0';
			}

			for (j = 0; j &lt; 4; j++) {
				a4[j] = b64_lookup(a4[j]);
			}

			a4_to_a3(a3, a4);

			for (j = 0; j &lt; i - 1; j++) {
				*out++ = a3[j];
			}
		}

		return (out == (out_begin + decoded_length));
	}

	static int DecodedLength(const char *in, size_t in_length) {
		int numEq = 0;

		const char *in_end = in + in_length;
		while (*--in_end == '=') ++numEq;

		return ((6 * in_length) / 8) - numEq;
	}

	static int DecodedLength(const std::string &amp;in) {
		int numEq = 0;
		int n = in.size();

		for (std::string::const_reverse_iterator it = in.rbegin(); *it == '='; ++it) {
			++numEq;
		}

		return ((6 * n) / 8) - numEq;
	}

	inline static int EncodedLength(size_t length) {
		return (length + 2 - ((length + 2) % 3)) / 3 * 4;
	}

	inline static int EncodedLength(const std::string &amp;in) {
		return EncodedLength(in.length());
	}

	inline static void StripPadding(std::string *in) {
		while (!in-&gt;empty() &amp;&amp; *(in-&gt;rbegin()) == '=') in-&gt;resize(in-&gt;size() - 1);
	}

	static std::string base64Decode(const char* Data, int DataByte) {
		//解码表
		const char DecodeTable[] =
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			62, // '+'
			0, 0, 0,
			63, // '/'
			52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // '0'-'9'
			0, 0, 0, 0, 0, 0, 0,
			0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
			13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // 'A'-'Z'
			0, 0, 0, 0, 0, 0,
			26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
			39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // 'a'-'z'
		};
		std::string strDecode;
		int nValue;
		int i = 0;
		while (i &lt; DataByte) {
			if (*Data != '\r' &amp;&amp; *Data != '\n') {
				nValue = DecodeTable[*Data++] &lt;&lt; 18;
				nValue += DecodeTable[*Data++] &lt;&lt; 12;
				strDecode += (nValue &amp; 0x00FF0000) &gt;&gt; 16;
				if (*Data != '=') {
					nValue += DecodeTable[*Data++] &lt;&lt; 6;
					strDecode += (nValue &amp; 0x0000FF00) &gt;&gt; 8;
					if (*Data != '=') {
						nValue += DecodeTable[*Data++];
						strDecode += nValue &amp; 0x000000FF;
					}
				}
				i += 4;
			}
			else {
				Data++;
				i++;
			}
		}
		return strDecode;
	}


	static std::string base64Encode(const unsigned char* Data, int DataByte) {
		//编码表
		const char EncodeTable[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		//返回值
		std::string strEncode;
		unsigned char Tmp[4] = { 0 };
		int LineLength = 0;
		for (int i = 0; i &lt; (int)(DataByte / 3); i++) {
			Tmp[1] = *Data++;
			Tmp[2] = *Data++;
			Tmp[3] = *Data++;
			strEncode += EncodeTable[Tmp[1] &gt;&gt; 2];
			strEncode += EncodeTable[((Tmp[1] &lt;&lt; 4) | (Tmp[2] &gt;&gt; 4)) &amp; 0x3F];
			strEncode += EncodeTable[((Tmp[2] &lt;&lt; 2) | (Tmp[3] &gt;&gt; 6)) &amp; 0x3F];
			strEncode += EncodeTable[Tmp[3] &amp; 0x3F];
			if (LineLength += 4, LineLength == 76) { strEncode += "\r\n"; LineLength = 0; }
		}
		//对剩余数据进行编码
		int Mod = DataByte % 3;
		if (Mod == 1) {
			Tmp[1] = *Data++;
			strEncode += EncodeTable[(Tmp[1] &amp; 0xFC) &gt;&gt; 2];
			strEncode += EncodeTable[((Tmp[1] &amp; 0x03) &lt;&lt; 4)];
			strEncode += "==";
		}
		else if (Mod == 2) {
			Tmp[1] = *Data++;
			Tmp[2] = *Data++;
			strEncode += EncodeTable[(Tmp[1] &amp; 0xFC) &gt;&gt; 2];
			strEncode += EncodeTable[((Tmp[1] &amp; 0x03) &lt;&lt; 4) | ((Tmp[2] &amp; 0xF0) &gt;&gt; 4)];
			strEncode += EncodeTable[((Tmp[2] &amp; 0x0F) &lt;&lt; 2)];
			strEncode += "=";
		}


		return strEncode;
	}

	//imgType 包括png bmp jpg jpeg等opencv能够进行编码解码的文件
	static std::string Mat2Base64(const cv::Mat &amp;img, std::string imgType) {
		//Mat转base64
		std::string img_data;
		std::vector&lt;uchar&gt; vecImg;
		std::vector&lt;int&gt; vecCompression_params;
		vecCompression_params.push_back(CV_IMWRITE_JPEG_QUALITY);
		vecCompression_params.push_back(90);
		imgType = "." + imgType;
		cv::imencode(imgType, img, vecImg, vecCompression_params);
		img_data = base64Encode(vecImg.data(), vecImg.size());
		return img_data;
	}


	static cv::Mat Base2Mat(std::string &amp;base64_data) {
		cv::Mat img;
		std::string s_mat;
		s_mat = base64Decode(base64_data.data(), base64_data.size());
		std::vector&lt;char&gt; base64_img(s_mat.begin(), s_mat.end());
		img = cv::imdecode(base64_img, CV_LOAD_IMAGE_COLOR);
		return img;
	}

private:
	static inline void a3_to_a4(unsigned char * a4, unsigned char * a3) {
		a4[0] = (a3[0] &amp; 0xfc) &gt;&gt; 2;
		a4[1] = ((a3[0] &amp; 0x03) &lt;&lt; 4) + ((a3[1] &amp; 0xf0) &gt;&gt; 4);
		a4[2] = ((a3[1] &amp; 0x0f) &lt;&lt; 2) + ((a3[2] &amp; 0xc0) &gt;&gt; 6);
		a4[3] = (a3[2] &amp; 0x3f);
	}

	static inline void a4_to_a3(unsigned char * a3, unsigned char * a4) {
		a3[0] = (a4[0] &lt;&lt; 2) + ((a4[1] &amp; 0x30) &gt;&gt; 4);
		a3[1] = ((a4[1] &amp; 0xf) &lt;&lt; 4) + ((a4[2] &amp; 0x3c) &gt;&gt; 2);
		a3[2] = ((a4[2] &amp; 0x3) &lt;&lt; 6) + a4[3];
	}

	static inline unsigned char b64_lookup(unsigned char c) {
		if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') return c - 'A';
		if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') return c - 71;
		if (c &gt;= '0' &amp;&amp; c &lt;= '9') return c + 4;
		if (c == '+') return 62;
		if (c == '/') return 63;
		return 255;
	}
};

#endif // BASE64_H</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e42e9cd01541bb17ebea2e53514131ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">maven安装笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/78b8a69217660d9a001a0ea7ea4af03c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue 搭建H5项目及适配</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>