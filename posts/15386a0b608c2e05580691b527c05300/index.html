<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue2生命周期 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue2生命周期" />
<meta property="og:description" content="本文目录 vue2生命周期常见生命周期：一、beforeCreate二、created三、beforeMounted四、mounted五、beforeUpdate六、updated七、beforeDestroy八、destroyed keep-alive九、activated十、deactivated 其他：十一、errorCaptured vue2生命周期 所有生命周期钩子的 this 上下文将自动绑定至实例中，因此你可以访问 data、computed 和 methods。这意味着你不应该使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。因为箭头函数绑定了父级上下文，所以 this 不会指向预期的组件实例，并且this.fetchTodos 将会是 undefined。
不要在选项 property 或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。
常见生命周期： 一、beforeCreate 第一个生命周期钩子，在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。此时实例的data和methods等配置还未初始化，无法调用，只能使用一些默认事件。
二、created 在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。模板还没有编译，也就是我们还不能获取到DOM。
三、beforeMounted 该在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子函数在模板渲染之前调用，也就是DOM节点挂载到真实DOM树之前调用。此模板进行编译，会调用render函数生成vDom，也就是虚拟DOM，此时我们同样无法获取DOM节点。此时我们同样是无法获取DOM节点的，因为此时只存在VDOM，还在JS级别。
四、mounted 实例被挂载后调用，这时 el 被新创建的 vm. e l 替换了。如果根实例挂载到了一个文档内的元素上，当 m o u n t e d 被调用时 v m ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/15386a0b608c2e05580691b527c05300/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-16T08:42:38+08:00" />
<meta property="article:modified_time" content="2023-03-16T08:42:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue2生命周期</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>本文目录</h4> 
 <ul><li><a href="#vue2_2" rel="nofollow">vue2生命周期</a></li><li><a href="#_9" rel="nofollow">常见生命周期：</a></li><li><ul><li><a href="#beforeCreate_10" rel="nofollow">一、beforeCreate</a></li><li><a href="#created_15" rel="nofollow">二、created</a></li><li><a href="#beforeMounted_20" rel="nofollow">三、beforeMounted</a></li><li><a href="#mounted_25" rel="nofollow">四、mounted</a></li><li><a href="#beforeUpdate_35" rel="nofollow">五、beforeUpdate</a></li><li><a href="#updated_44" rel="nofollow">六、updated</a></li><li><a href="#beforeDestroy_57" rel="nofollow">七、beforeDestroy</a></li><li><a href="#destroyed_64" rel="nofollow">八、destroyed</a></li></ul> 
  </li><li><a href="#keepalive_68" rel="nofollow">keep-alive</a></li><li><ul><li><a href="#activated_70" rel="nofollow">九、activated</a></li><li><a href="#deactivated_74" rel="nofollow">十、deactivated</a></li></ul> 
  </li><li><a href="#_77" rel="nofollow">其他：</a></li><li><ul><li><a href="#errorCaptured_79" rel="nofollow">十一、errorCaptured</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="vue2_2"></a>vue2生命周期</h2> 
<p><img src="https://images2.imgbox.com/10/15/bDEv0W0m_o.png" alt="本文是对vue2.x 与vue3.x相关功能做的对比大列表"></p> 
<blockquote> 
 <p>所有生命周期钩子的 this 上下文将自动绑定至实例中，因此你可以访问 data、computed 和 methods。这意味着你不应该使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。因为箭头函数绑定了父级上下文，所以 this 不会指向预期的组件实例，并且this.fetchTodos 将会是 undefined。</p> 
</blockquote> 
<blockquote> 
 <p>不要在选项 property 或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。</p> 
</blockquote> 
<h2><a id="_9"></a>常见生命周期：</h2> 
<h3><a id="beforeCreate_10"></a>一、beforeCreate</h3> 
<p><img src="https://images2.imgbox.com/2d/50/kFbegcVO_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>第一个生命周期钩子，在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。此时实例的data和methods等配置还未初始化，无法调用，只能使用一些默认事件。</p> 
</blockquote> 
<h3><a id="created_15"></a>二、created</h3> 
<p><img src="https://images2.imgbox.com/31/04/Poa57OCS_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。模板还没有编译，也就是我们还不能获取到DOM。</p> 
</blockquote> 
<h3><a id="beforeMounted_20"></a>三、beforeMounted</h3> 
<p><img src="https://images2.imgbox.com/83/bd/wEJC8Z0L_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>该在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子函数在模板渲染之前调用，也就是DOM节点挂载到真实DOM树之前调用。此模板进行编译，会调用render函数生成vDom，也就是虚拟DOM，此时我们同样无法获取DOM节点。此时我们同样是无法获取DOM节点的，因为此时只存在VDOM，还在JS级别。</p> 
</blockquote> 
<h3><a id="mounted_25"></a>四、mounted</h3> 
<p><img src="https://images2.imgbox.com/c1/1c/KMgvPT3R_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>实例被挂载后调用，这时 el 被新创建的 vm.<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          e 
         
        
          l 
         
        
          替换了。如果根实例挂载到了一个文档内的元素上，当 
         
        
          m 
         
        
          o 
         
        
          u 
         
        
          n 
         
        
          t 
         
        
          e 
         
        
          d 
         
        
          被调用时 
         
        
          v 
         
        
          m 
         
        
          . 
         
        
       
         el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm. 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord cjk_fallback">替换了。如果根实例挂载到了一个文档内的元素上，当</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord cjk_fallback">被调用时</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">m</span><span class="mord">.</span></span></span></span></span>el 也在文档内。</p> 
</blockquote> 
<p><font color="red"> 注意 mounted 不会保证所有的子组件也都被挂载完成。</font>如果你希望等到整个视图都渲染完毕再执行某些操作，可以在 mounted 内部使用 vm.$nextTick</p> 
<blockquote> 
 <p>执行该钩子函数时，我们的模板编译好了，而且挂载到真实DOM树上面去了，也就是我们的页面可以显示了。（该钩子在服务器端渲染期间不被调用。）</p> 
</blockquote> 
<h3><a id="beforeUpdate_35"></a>五、beforeUpdate</h3> 
<p><img src="https://images2.imgbox.com/0d/07/LRKGAqL8_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。</p> 
</blockquote> 
<blockquote> 
 <p>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。</p> 
</blockquote> 
<blockquote> 
 <p>该钩子函数在data数据发生变化之后调用，此时data里面的数据已经是最新的了，但是页面上DOM还没有更新最新的数据。</p> 
</blockquote> 
<h3><a id="updated_44"></a>六、updated</h3> 
<p><img src="https://images2.imgbox.com/26/61/o2QoUtZ0_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。</p> 
</blockquote> 
<blockquote> 
 <p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。</p> 
</blockquote> 
<p><font color="red">注意，updated 不会保证所有的子组件也都被重新渲染完毕。</font>如果你希望等到整个视图都渲染完毕，可以在 updated 里使用 vm.$nextTick</p> 
<blockquote> 
 <p>该钩子函数会在data数据更新之后执行，而且此时页面也渲染更新完成了，显示的就是最新的数据。</p> 
</blockquote> 
<p><font color="red">注意：不要在updated中修改data数据，很容易造成死循环。</font></p> 
<h3><a id="beforeDestroy_57"></a>七、beforeDestroy</h3> 
<p><img src="https://images2.imgbox.com/7d/ce/TjkQFGK3_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>实例销毁之前调用。在这一步，实例仍然完全可用。</p> 
</blockquote> 
<p><em>我们通常会在这个钩子函数里面解除一些全局或者自定义事件。</em></p> 
<h3><a id="destroyed_64"></a>八、destroyed</h3> 
<p><img src="https://images2.imgbox.com/78/59/61mRsaMV_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p> 
</blockquote> 
<h2><a id="keepalive_68"></a>keep-alive</h2> 
<h3><a id="activated_70"></a>九、activated</h3> 
<blockquote> 
 <p>被 <font color="red"> <strong>keep-alive</strong></font> 缓存的组件<font color="red"> <strong>激活</strong></font>时调用。</p> 
</blockquote> 
<h3><a id="deactivated_74"></a>十、deactivated</h3> 
<blockquote> 
 <p>被<font color="red"> <strong>keep-alive</strong></font> 缓存的组件<font color="red"> <strong>失活</strong></font>时调用。</p> 
</blockquote> 
<h2><a id="_77"></a>其他：</h2> 
<h3><a id="errorCaptured_79"></a>十一、errorCaptured</h3> 
<blockquote> 
 <p>在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d74d74824d85ea49a876971de4b794bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">状态机按键消抖</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/72a593c0c10a33c518dca184eaca0825/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络 | 网络层讲解 | IP协议 | 分片处理与网段划分</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>