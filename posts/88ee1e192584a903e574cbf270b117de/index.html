<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常见算法及其时间复杂度总结 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常见算法及其时间复杂度总结" />
<meta property="og:description" content="提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
常见算法及其时间复杂度总结 前言一、O(1)二、O(logn)三、O(n)四、O(nlogn)五、O(n^2)六、O(n^3)七、O(2^n)八、O(n!)九、O(n^n^)总结 前言 记录一些常见算法时间复杂度
O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2 ) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn)
一、O(1) 常见算法：数组随机存取、固定大小的循环、获取链表的长度或头尾节点、简单算术运算或位运算（&#43;、-、*、/、&amp;、|、~、^）、哈希散列表查找（unordered_map、unordered_set）
数组随机存取：数组具有
二、O(logn) 表示log2n
常见算法：for或while以i*2或i/2进行变化、二分查找、平衡二叉树查找（map、set）、分治算法
三、O(n) 常见算法：线性查找、以变量为迭代指标遍历、求和、计数、拷贝、阶乘算法、链表合并（max(m,n)）、计数排序、桶排序、广度优先搜索算法、深度优先搜索算法
四、O(nlogn) 常见算法：堆排序、快速排序、归并排序、希尔排序、计数排序、基数排序、C&#43;±std::sort()
堆排序：大根堆、小根堆，属于二叉排序树/二叉搜索树/二叉查找树
快速排序：自上而下将数据进行分治
归并排序：自下而上将数据分治为小粒度，再进行合并
C&#43;&#43;标准库的std::sort()：通常是使用快速排序、归并排序或堆排序等。
五、O(n^2) 常见算法：两层循环嵌套、冒泡排序、选择排序、插入排序、希尔排序、矩阵乘法朴素算法、求解线性方程组的高斯消元法
冒泡排序：两层循环，外层i正常遍历0 ~ n-1，内层j从0 ~ n-1-i，内层每一轮使j&#43;1处数据&gt;j处数据（如不满足则交换两位置数据）
选择排序：两层循环，外层i正常遍历0 ~ n-1，内层j从i&#43;1 ~ n，内层每轮确定一个最小的数的位置，将之与i处的数据交换
插入排序：两层循环，外层i正常遍历1 ~ n-1，内层j从 i起往前遍历，确保j-1处的数据&lt;j处的数据（如不满足则交换两位置数据）
六、O(n^3) 常见算法：三层循环嵌套、常规矩阵乘法、Floyd-Warshall 算法、求解线性方程组的高斯消元法
七、O(2^n) 常见算法：斐波那契递归、递归组合生成算法、动态规划的指数级实现
八、O(n!) 常见算法：全排列生成算法、旅行商问题暴力破解算法、递归字典序生成算法
九、O(nn) 常见算法：暴力搜索算法、递归全排列算法、递归子集生成算法、递归布尔表达式求解算法
总结 附上别处的总结图片对比参考：
稳定的排序算法：冒泡排序、插入排序、归并排序、基数排序
不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序
各排序算法优化：
快速排序：
快排若默认选取第一个/最后一个作为标定点则时间复杂度在基本有序的原始数据上接近O(n2)，此时可以选用随机标定点，时间复杂度为O(nlogn)对数据量低于20的递归部分采用插入排序 归并排序：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/88ee1e192584a903e574cbf270b117de/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-03T19:44:11+08:00" />
<meta property="article:modified_time" content="2023-08-03T19:44:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常见算法及其时间复杂度总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>常见算法及其时间复杂度总结</h4> 
 <ul><li><a href="#_7" rel="nofollow">前言</a></li><li><a href="#O1_14" rel="nofollow">一、O(1)</a></li><li><a href="#Ologn_18" rel="nofollow">二、O(logn)</a></li><li><a href="#On_22" rel="nofollow">三、O(n)</a></li><li><a href="#Onlogn_25" rel="nofollow">四、O(nlogn)</a></li><li><a href="#On2_32" rel="nofollow">五、O(n^2)</a></li><li><a href="#On3_38" rel="nofollow">六、O(n^3)</a></li><li><a href="#O2n_41" rel="nofollow">七、O(2^n)</a></li><li><a href="#On_44" rel="nofollow">八、O(n!)</a></li><li><a href="#Onn_47" rel="nofollow">九、O(n^n^)</a></li><li><a href="#_52" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_7"></a>前言</h2> 
<p>记录一些常见算法时间复杂度<br> <strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup> ) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</strong></p> 
<hr> 
<h2><a id="O1_14"></a>一、O(1)</h2> 
<p>常见算法：数组随机存取、固定大小的循环、获取链表的长度或头尾节点、简单算术运算或位运算（+、-、*、/、&amp;、|、~、^）、哈希散列表查找（unordered_map、unordered_set）<br> 数组随机存取：数组具有</p> 
<h2><a id="Ologn_18"></a>二、O(logn)</h2> 
<p>表示log2n<br> 常见算法：for或while以i*2或i/2进行变化、二分查找、平衡二叉树查找（map、set）、分治算法</p> 
<h2><a id="On_22"></a>三、O(n)</h2> 
<p>常见算法：线性查找、以变量为迭代指标遍历、求和、计数、拷贝、阶乘算法、链表合并（max(m,n)）、计数排序、桶排序、广度优先搜索算法、深度优先搜索算法</p> 
<h2><a id="Onlogn_25"></a>四、O(nlogn)</h2> 
<p>常见算法：堆排序、快速排序、归并排序、希尔排序、计数排序、基数排序、C+±std::sort()<br> 堆排序：大根堆、小根堆，属于二叉排序树/二叉搜索树/二叉查找树<br> 快速排序：自上而下将数据进行分治<br> 归并排序：自下而上将数据分治为小粒度，再进行合并<br> C++标准库的std::sort()：通常是使用快速排序、归并排序或堆排序等。</p> 
<h2><a id="On2_32"></a>五、O(n^2)</h2> 
<p>常见算法：两层循环嵌套、冒泡排序、选择排序、插入排序、希尔排序、矩阵乘法朴素算法、求解线性方程组的高斯消元法<br> 冒泡排序：两层循环，外层i正常遍历0 ~ n-1，内层j从0 ~ n-1-i，内层每一轮使j+1处数据&gt;j处数据（如不满足则交换两位置数据）<br> 选择排序：两层循环，外层i正常遍历0 ~ n-1，内层j从i+1 ~ n，内层每轮确定一个最小的数的位置，将之与i处的数据交换<br> 插入排序：两层循环，外层i正常遍历1 ~ n-1，内层j从 i起往前遍历，确保j-1处的数据&lt;j处的数据（如不满足则交换两位置数据）</p> 
<h2><a id="On3_38"></a>六、O(n^3)</h2> 
<p>常见算法：三层循环嵌套、常规矩阵乘法、Floyd-Warshall 算法、求解线性方程组的高斯消元法</p> 
<h2><a id="O2n_41"></a>七、O(2^n)</h2> 
<p>常见算法：斐波那契递归、递归组合生成算法、动态规划的指数级实现</p> 
<h2><a id="On_44"></a>八、O(n!)</h2> 
<p>常见算法：全排列生成算法、旅行商问题暴力破解算法、递归字典序生成算法</p> 
<h2><a id="Onn_47"></a>九、O(n<sup>n</sup>)</h2> 
<p>常见算法：暴力搜索算法、递归全排列算法、递归子集生成算法、递归布尔表达式求解算法</p> 
<hr> 
<h2><a id="_52"></a>总结</h2> 
<p>附上别处的总结图片对比参考：</p> 
<p><img src="https://images2.imgbox.com/86/c3/oWRMZEoK_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/15/5d/Df2IHx2l_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/75/2f/nT0GnNSk_o.png" alt="八大排序算法复杂度"><br> <img src="https://images2.imgbox.com/a0/b3/GjG23WJo_o.png" alt="算法时间复杂度"><br> <img src="https://images2.imgbox.com/59/32/Eq5JHed8_o.png" alt="内存外存排序算法 "><br> <img src="https://images2.imgbox.com/f2/36/heSHPVYS_o.png" alt="线性非线性排序算法"><br> 稳定的排序算法：冒泡排序、插入排序、归并排序、基数排序<br> 不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</p> 
<p>各排序算法优化：</p> 
<p>快速排序：</p> 
<ol><li>快排若默认选取第一个/最后一个作为标定点则时间复杂度在基本有序的原始数据上接近O(n<sup>2</sup>)，此时可以选用随机标定点，时间复杂度为O(nlogn)</li><li>对数据量低于20的递归部分采用插入排序</li></ol> 
<p>归并排序：</p> 
<ol><li>对数据量低于20的递归部分采用插入排序</li></ol> 
<p>冒泡排序 ：</p> 
<ol><li>使用标志位判断排序终点</li></ol> 
<p>插入排序：</p> 
<ol><li>向前查找时使用二分查找提高效率</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f88f925819e62a6b2bcc6141349d6d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">WEB集群——tomcat</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d262f2272bca7ce2bbfc6a4d98070df5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GAN系列之普通GAN</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>