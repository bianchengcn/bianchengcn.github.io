<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qat&#43;&#43;，轻量级开源C&#43;&#43; Web框架 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qat&#43;&#43;，轻量级开源C&#43;&#43; Web框架" />
<meta property="og:description" content="目录
一.简介
二.编译Oat&#43;&#43;
1.环境
2.编译/安装
三.试用
1.创建一个 CMake 项目
2.自定义客户端请求响应
3.将请求Router到服务器
4.用浏览器验证
一.简介 Oat&#43;&#43;是一个面向C&#43;&#43;的现代Web框架
官网地址：https://oatpp.io
github地址：https://github.com/oatpp/oatpp
Oat&#43;&#43;具有如下特性：
●随处运行
Oat&#43;&#43;没有任何依赖性，可以很容易地移植到各种支持的平台上（Linux、BSD、MacOS、OpenWRT、Windows）。
●构建健壮的api
使用Oat&#43;&#43;的Simple-API，很容易就能构建出灵活而健壮的High-Level API。
●高并发
使用Oat&#43;&#43;的Async-API，可以在单个服务器上处理超过500万个并发连接。
●访问数据库
Oat&#43;&#43; ORM提供了一种简单而统一的方式来访问数据库。
●保持代码一致
Oat&#43;&#43;在整个代码中依靠对象映射（Object-Mapping）来确保API和数据模型的一致性。详见：更多
●生成API文档
使用Swagger-UI和OpenAPI 3.0.0自动记录endpoints。详见：更多
Qat&#43;&#43;可以应用于多种不同的领域，比如构建运行在嵌入式设备的REST API，构建微服务和高负载的云应用程序。目前主要的应用案例是IOT和Robotics。
那么在实践中该如何选择Oat&#43;&#43;的API类型呢？
优先选择Simple API，因为它开发得更加完善。如果是并发任务，就可以考虑使用Async API了，Async API通常用于以下几种场景：
●文件上传、下载
●向大量客户端推流
●Websocket聊天服务器
说起Web开发，大多数人会想到 Java、Python、Golang ... ，因为用它们实现的主流Web框架有很多：Java有非常知名的Spring全家桶，Python有大而全的Django、小而精的Flask、高性能的Tornado，Golang也有快速灵活的Gin、Echo等框架。
不过现在做C/C&#43;&#43;开发的同学可以收回羡慕的眼神啦，Oat&#43;&#43;作为C/C&#43;&#43; Web框架的后起之秀，还是非常值得研究的。
二.编译Oat&#43;&#43; 这里以Windows为例，其他平台可参考官网。
1.环境 Window 10
Visual Studio 2017（官网测试用的就是这个版本）
CMake 3.25.1（推荐用最新版）
2.编译/安装 以管理员权限打开“VS 2017的开发人员命令提示符”窗口
否则安装的时候会报如下错误：
git clone https://github.com/oatpp/oatpp.git cd oatpp MD build cd build cmake ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/acba674c4a5ef2f28f26b157d5c6029d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-14T16:01:56+08:00" />
<meta property="article:modified_time" content="2024-01-14T16:01:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qat&#43;&#43;，轻量级开源C&#43;&#43; Web框架</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E7%AE%80%E4%BB%8B" rel="nofollow">一.简介</a></p> 
<p id="%E4%BA%8C.%E7%BC%96%E8%AF%91Oat%2B%2B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E7%BC%96%E8%AF%91Oat%2B%2B" rel="nofollow">二.编译Oat++</a></p> 
<p id="1.%E7%8E%AF%E5%A2%83-toc" style="margin-left:40px;"><a href="#1.%E7%8E%AF%E5%A2%83" rel="nofollow">1.环境</a></p> 
<p id="2.%E7%BC%96%E8%AF%91%2F%E5%AE%89%E8%A3%85-toc" style="margin-left:40px;"><a href="#2.%E7%BC%96%E8%AF%91%2F%E5%AE%89%E8%A3%85" rel="nofollow">2.编译/安装</a></p> 
<p id="%E4%B8%89.%E8%AF%95%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E8%AF%95%E7%94%A8" rel="nofollow">三.试用</a></p> 
<p id="1.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20CMake%20%E9%A1%B9%E7%9B%AE-toc" style="margin-left:40px;"><a href="#1.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20CMake%20%E9%A1%B9%E7%9B%AE" rel="nofollow">1.创建一个 CMake 项目</a></p> 
<p id="2.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94-toc" style="margin-left:40px;"><a href="#2.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94" rel="nofollow">2.自定义客户端请求响应</a></p> 
<p id="3.%E5%B0%86%E8%AF%B7%E6%B1%82Router%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#3.%E5%B0%86%E8%AF%B7%E6%B1%82Router%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">3.将请求Router到服务器</a></p> 
<p id="4.%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%AA%8C%E8%AF%81-toc" style="margin-left:40px;"><a href="#4.%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%AA%8C%E8%AF%81" rel="nofollow">4.用浏览器验证</a></p> 
<hr id="hr-toc"> 
<p><img alt="" height="373" src="https://images2.imgbox.com/bb/1d/ZxP85QLX_o.jpg" width="719"></p> 
<h2 id="%E4%B8%80.%E7%AE%80%E4%BB%8B">一.简介</h2> 
<p>Oat++是一个面向C++的现代Web框架<br> 官网地址：<a class="link-info" href="https://oatpp.io" rel="nofollow" title="https://oatpp.io">https://oatpp.io</a><br> github地址：<a class="link-info" href="https://github.com/oatpp/oatpp" title="https://github.com/oatpp/oatpp">https://github.com/oatpp/oatpp</a><br> Oat++具有如下特性：<br> ●随处运行<br> Oat++没有任何依赖性，可以很容易地移植到各种支持的平台上（Linux、BSD、MacOS、OpenWRT、Windows）。<br> ●构建健壮的api<br> 使用Oat++的Simple-API，很容易就能构建出灵活而健壮的High-Level API。<br> ●高并发<br> 使用Oat++的Async-API，可以在单个服务器上处理超过500万个并发连接。<br> ●访问数据库<br> Oat++ ORM提供了一种简单而统一的方式来访问数据库。<br> ●保持代码一致<br> Oat++在整个代码中依靠对象映射（Object-Mapping）来确保API和数据模型的一致性。详见：<a class="link-info" href="https://oatpp.io/docs/components/dto/" rel="nofollow" title="更多">更多</a><br> ●生成API文档<br> 使用Swagger-UI和OpenAPI 3.0.0自动记录endpoints。详见：<a class="link-info" href="https://oatpp.io/docs/components/api-controller/#endpoint-annotation-and-api-documentation" rel="nofollow" title="更多">更多</a><br> Qat++可以应用于多种不同的领域，比如构建运行在嵌入式设备的REST API，构建微服务和高负载的云应用程序。目前主要的应用案例是IOT和Robotics。<br> 那么在实践中该如何选择Oat++的API类型呢？<br> 优先选择Simple API，因为它开发得更加完善。如果是并发任务，就可以考虑使用Async API了，Async API通常用于以下几种场景：<br> ●文件上传、下载<br> ●向大量客户端推流<br> ●Websocket聊天服务器<br> 说起Web开发，大多数人会想到 Java、Python、Golang ... ，因为用它们实现的主流Web框架有很多：Java有非常知名的Spring全家桶，Python有大而全的Django、小而精的Flask、高性能的Tornado，Golang也有快速灵活的Gin、Echo等框架。<br> 不过现在做C/C++开发的同学可以收回羡慕的眼神啦，Oat++作为C/C++ Web框架的后起之秀，还是非常值得研究的。</p> 
<h2 id="%E4%BA%8C.%E7%BC%96%E8%AF%91Oat%2B%2B">二.编译Oat++</h2> 
<p>这里以Windows为例，其他平台可参考官网。</p> 
<h3 id="1.%E7%8E%AF%E5%A2%83">1.环境</h3> 
<p>Window 10<br> Visual Studio 2017（官网测试用的就是这个版本）<br> CMake 3.25.1（推荐用最新版）</p> 
<h3 id="2.%E7%BC%96%E8%AF%91%2F%E5%AE%89%E8%A3%85">2.编译/安装</h3> 
<p>以管理员权限打开“VS 2017的开发人员命令提示符”窗口<br> 否则安装的时候会报如下错误：<br><img alt="" height="89" src="https://images2.imgbox.com/b6/53/AQ2UmPkb_o.jpg" width="765"></p> 
<pre><code>git clone https://github.com/oatpp/oatpp.git
cd oatpp
MD build
cd build
cmake ..
cmake --build . --target INSTALL</code></pre> 
<p>常用CMake参数表</p> 
<table><thead><tr><th>参数</th><th style="width:68px;">默认值</th><th style="width:433px;">说明</th></tr></thead><tbody><tr><td><code>CMAKE_BUILD_TYPE</code></td><td style="width:68px;"><code>Debug</code></td><td style="width:433px;">编译类型</td></tr><tr><td><code>BUILD_SHARED_LIBS</code></td><td style="width:68px;"><code>OFF</code></td><td style="width:433px;">默认值为<code>OFF</code>，此时 Oat++ 被编译Wie静态库.</td></tr><tr><td><code>OATPP_BUILD_TESTS</code></td><td style="width:68px;"><code>ON</code></td><td style="width:433px;">如果设置为OFF，表示不编译tests</td></tr><tr><td><code>OATPP_DISABLE_ENV_OBJECT_COUNTERS</code></td><td style="width:68px;"><code>OFF</code></td><td style="width:433px;">如果设置为ON, 不统计oatpp对象(不检测内存泄漏)，可以提升性能<br><strong>注意:</strong> 不要用OFF去编译或运行 tests, 因为tests不检测内存泄漏.</td></tr><tr><td><code>OATPP_DISABLE_POOL_ALLOCATIONS</code></td><td style="width:68px;"><code>OFF</code></td><td style="width:433px;">如果设置为ON，不使用 oatpp memory-pools.</td></tr><tr><td><code>OATPP_COMPAT_BUILD_NO_THREAD_LOCAL</code></td><td style="width:68px;"><code>OFF</code></td><td style="width:433px;">编译时禁用<code>thread_local</code>特性，详见 <a href="https://github.com/oatpp/oatpp/issues/81" title="#81">#81</a>.</td></tr></tbody></table> 
<p> 几分钟就能编译安装完成，无报错。安装路径是：C:/Program Files (x86)/oatpp/lib/oatpp-1.3.0/oatpp<br> 下图是执行cmake ..时的打印信息：<br><img alt="" height="811" src="https://images2.imgbox.com/4b/78/K2et4Wmy_o.jpg" width="979"></p> 
<h2 id="%E4%B8%89.%E8%AF%95%E7%94%A8">三.试用</h2> 
<h3 id="1.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20CMake%20%E9%A1%B9%E7%9B%AE">1.创建一个 CMake 项目</h3> 
<p>CMakeLists.txt 配置如下：</p> 
<pre><code>cmake_minimum_required(VERSION 3.1)
project(HelloWorld)
 
set(CMAKE_CXX_STANDARD 11)
set(SOURCE_FILES main.cpp handler.h)
 
# 查找 oatpp 依赖
find_package(oatpp REQUIRED)
 
add_executable(${PROJECT_NAME} ${SOURCE_FILES})
 
# 将目标文件与库文件进行链接
target_link_libraries(${PROJECT_NAME} oatpp::oatpp)</code></pre> 
<h3 id="2.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94">2.自定义客户端请求响应</h3> 
<p><strong>handler.h</strong></p> 
<pre><code class="language-cpp">#ifndef HANDLER_H
#define HANDLER_H
 
#include "oatpp/web/server/HttpRequestHandler.hpp"
 
#define O_UNUSED(x) (void)x;
 
// 自定义请求处理程序
class Handler : public oatpp::web::server::HttpRequestHandler
{
public:
    // 处理传入的请求，并返回响应
    std::shared_ptr&lt;OutgoingResponse&gt; handle(const std::shared_ptr&lt;IncomingRequest&gt;&amp; request) override {
        O_UNUSED(request);
 
        return ResponseFactory::createResponse(Status::CODE_200, "Hello, World!");
    }
};
 
#endif // HANDLER_H</code></pre> 
<h3 id="3.%E5%B0%86%E8%AF%B7%E6%B1%82Router%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">3.将请求Router到服务器</h3> 
<p><strong>main.cpp</strong></p> 
<pre><code class="language-cpp">#include "oatpp/web/server/HttpConnectionHandler.hpp"
#include "oatpp/network/tcp/server/ConnectionProvider.hpp"
#include "oatpp/network/Server.hpp"
#include "handler.h"
 
void run()
{
    // 为 HTTP 请求创建路由器
    auto router = oatpp::web::server::HttpRouter::createShared();
 
    // 路由 GET - "/HelloWorld" 请求到处理程序
    router-&gt;route("GET", "/HelloWorld", std::make_shared&lt;Handler&gt;());
 
    // 创建 HTTP 连接处理程序
    auto connectionHandler = oatpp::web::server::HttpConnectionHandler::createShared(router);
 
    // 创建 TCP 连接提供者
    auto connectionProvider = oatpp::network::tcp::server::ConnectionProvider::createShared({"localhost", 8000, oatpp::network::Address::IP_4});
 
    // 创建服务器，它接受提供的 TCP 连接并将其传递给 HTTP 连接处理程序
    oatpp::network::Server server(connectionProvider, connectionHandler);
 
    // 打印服务器端口
    OATPP_LOGI("MyApp", "Server running on port %s", connectionProvider-&gt;getProperty("port").getData());
 
    // 运行服务器
    server.run();
}
 
int main()
{
    // 初始化 oatpp 环境
    oatpp::base::Environment::init();
 
    // 运行应用
    run();
 
    // 销毁 oatpp 环境
    oatpp::base::Environment::destroy();
 
    return 0;
}</code></pre> 
<h3 id="4.%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%AA%8C%E8%AF%81">4.用浏览器验证</h3> 
<p>运行上面的服务器程序</p> 
<p><img alt="" height="73" src="https://images2.imgbox.com/d6/ff/A50xdext_o.jpg" width="545"></p> 
<p>在浏览器中访问http://localhost:8000/HelloWorld，就会显示“Hello，World!”</p> 
<p><img alt="" height="160" src="https://images2.imgbox.com/86/a8/KpL9GgeU_o.jpg" width="554"><br> 参考链接：<a class="link-info" href="https://waleon.blog.csdn.net/article/details/120376280" rel="nofollow" title="https://waleon.blog.csdn.net/article/details/120376280">https://waleon.blog.csdn.net/article/details/120376280</a><br> 原文链接：<a href="https://blog.csdn.net/caoshangpa/article/details/135578294" title="Qat++，轻量级开源C++ Web框架-CSDN博客">Qat++，轻量级开源C++ Web框架-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8dee79149188ee1d2a60242d13119d2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Github 2024-01-14 Go开源项目日报 Top10</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1463ac3e53f8671a427a6742c6bae32b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【RPC】序列化：对象怎么在网络中传输？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>