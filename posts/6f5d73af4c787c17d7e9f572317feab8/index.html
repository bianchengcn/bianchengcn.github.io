<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【每日选择题】11~20天做选择题汇总 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【每日选择题】11~20天做选择题汇总" />
<meta property="og:description" content="day 11 4 月23 日测验 1.下面哪个标识符是合法的？(D)
A &#34;9HelloWorld&#34;
B &#34;_Hello World&#34;
C &#34;Hello*World&#34;
D &#34;Hello$World&#34;
标识符只能是数字字母下划线组成的，而且不能以数字开头
2.以下java程序代码，执行后的结果是（C）
java.util.HashMap map=new java.util.HashMap(); map.put(&#34;name&#34;,null); map.put(&#34;name&#34;,&#34;Jack&#34;); System.out.println(map.size()); A 0
B null
C 1
D 2
Map中键只能出现一次，是惟一的，当出现相同的key时，会覆盖之前的key
3.Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述错误的是(C)
A ArrayList和LinkedList均实现了List接口
B ArrayList的访问速度比LinkedList快
C 添加和删除元素时，ArrayList的表现更佳
D HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值
4.以下描述正确的是(B)
A CallableStatement是PreparedStatement的父接口
B PreparedStatement是CallableStatement的父接口
C CallableStatement是Statement的父接口
D PreparedStatement是Statement的父接口
PreparedStatement 是CallableStatement 的父接口, Statement 是PreparedStatement 的父接口
5.下列程序的运行结果（B）
public static void main(String args[]) { Thread t = new Thread() { public void run() { pong(); } }; t." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/6f5d73af4c787c17d7e9f572317feab8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-05T23:29:07+08:00" />
<meta property="article:modified_time" content="2021-06-05T23:29:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【每日选择题】11~20天做选择题汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <hr> 
<h2 id="day%2012%C2%A0%20%C2%A04%20%E6%9C%8824%C2%A0%E6%97%A5%E6%B5%8B%E9%AA%8C">day 11   4 月23 日测验</h2> 
<hr> 
<p><strong>1.下面哪个标识符是合法的？(D)</strong><br> A "9HelloWorld"<br> B "_Hello World"<br> C "Hello*World"<br> D "Hello$World"</p> 
<blockquote> 
 <p><span style="color:#3399ea;">标识符只能是数字字母下划线组成的，而且不能以数字开头</span></p> 
</blockquote> 
<p><strong>2.以下java程序代码，执行后的结果是（C）</strong></p> 
<pre><code class="language-java">java.util.HashMap map=new java.util.HashMap();
map.put("name",null);
map.put("name","Jack");
System.out.println(map.size());</code></pre> 
<p>A 0<br> B null<br> C 1<br> D 2</p> 
<blockquote> 
 <p><span style="color:#3399ea;">Map中键只能出现一次，是惟一的，当出现相同的key时，会覆盖之前的key</span></p> 
</blockquote> 
<p> </p> 
<p><strong>3.Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述错误的是(C)</strong><br> A ArrayList和LinkedList均实现了List接口<br> B ArrayList的访问速度比LinkedList快<br> C 添加和删除元素时，ArrayList的表现更佳<br> D HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值</p> 
<blockquote> 
 <p><img alt="" height="699" src="https://images2.imgbox.com/be/91/e0JVgAGJ_o.png" width="1200"></p> 
</blockquote> 
<p> </p> 
<p><strong>4.以下描述正确的是(B)</strong><br> A CallableStatement是PreparedStatement的父接口<br> B PreparedStatement是CallableStatement的父接口<br> C CallableStatement是Statement的父接口<br> D PreparedStatement是Statement的父接口</p> 
<blockquote> 
 <p><span style="color:#3399ea;">PreparedStatement 是CallableStatement 的父接口, Statement 是PreparedStatement 的父接口</span></p> 
</blockquote> 
<p> </p> 
<p>5.下列程序的运行结果（B）</p> 
<pre><code class="language-java">public static void main(String args[]) {
    Thread t = new Thread() {
        public void run() {
            pong();
        }
    };
    t.run();
    System.out.print("ping");
}
static void pong() {
    System.out.print("pong");
}</code></pre> 
<p>A pingpong<br> B pongping<br> C pingpong和pongping都有可能<br> D 都不输出</p> 
<blockquote> 
 <p><span style="color:#3399ea;">调用的是t线程的run方法知识一个普通的代码，顺序是按照代码出现的顺序执行的</span></p> 
</blockquote> 
<p><strong>6.下列关于容器集合类的说法正确的是？(C)</strong><br> A LinkedList继承自List<br> B AbstractSet继承自Set<br> C HashSet继承自AbstractSet<br> D WeakMap继承自HashMap</p> 
<blockquote> 
 <p><span style="color:#3399ea;">LinkedList 继承自AbstractSequentialList 实现了List 、Deque 、Cloneable 、java.io.Serializable 接<br> 口<br> AbstractSet 继承自AbstractCollection ，实现了set 接口<br> HashSet 继承自AbstractSet ，实现了set 、Cloneable 、java.io.Serializable 接口</span></p> 
</blockquote> 
<p> </p> 
<p><strong>7.ArrayList list = new ArrayList(20);中的list扩充几次(A)</strong><br> A 0<br> B 1<br> C 2<br> D 3</p> 
<blockquote> 
 <p>ArrayList的底层是数组，如果没有指定长度，则默认大小是10，若指定了大小，则初始大小就是指定值</p> 
</blockquote> 
<p> </p> 
<p>8.以下程序的输出结果是？(B)</p> 
<pre><code class="language-java">public class Example {
    String str = new String("good");
    char[] ch = { 'a', 'b', 'c' };
    public static void main(String args[]) {
        Example ex = new Example();
        ex.change(ex.str, ex.ch);
        System.out.print(ex.str + " and ");
        System.out.print(ex.ch);
    }
    public static void change(String str, char ch[])
    {
        str = "test ok";
        ch[0] = 'g';
    }
}</code></pre> 
<p>A good and abc<br> B good and gbc<br> C test ok and abc<br> D test ok and gbc</p> 
<blockquote> 
 <p><span style="color:#3399ea;">调用change 的方法时，向该方法的str 传入了"good" 的地址，向该方法的数组传入了{'a','b','c'} 的地址，修改str ，将其指<br> 向"test ok" ，但此时ex.str 依旧指向的是"good" .<br> 修改ch 指向的数组的元素， ex.ch 指向的也是该数组，所以看到的是跟着变。</span></p> 
</blockquote> 
<p> </p> 
<p>9.下面的方法，当输入为2的时候返回值是多少?（D）</p> 
<pre><code class="language-java">public static int getValue(int i) {
    int result = 0;
    switch (i) {
    case 1:
        result = result + i;
    case 2:
        result = result + i * 2;
    case 3:
        result = result + i * 3;
    }
    return result;
}</code></pre> 
<p>A 0<br> B 2<br> C 4<br> D 10</p> 
<blockquote> 
 <p><span style="color:#3399ea;">switch 中如果没有break 会把后边的语句都执行，即第7、9 行代码都会执行到。</span></p> 
</blockquote> 
<p> </p> 
<p><strong>10.下列关于Java 并发的说法中正确的是(B)</strong><br> A CopyOnWriteArrayList 适用于写多读少的并发场景<br> B ReadWriteLock 适用于读多写少的并发场景<br> C ConcurrentHashMap 的写操作不需要加锁，读操作需要加锁<br> D 只要在定义int 类型的成员变量i 的时候加上volatile 关键字，那么多线程并发执行i++ 这<br> 样的操作的时候就是线程安全的了</p> 
<blockquote> 
 <p><span style="color:#3399ea;">copyonwritearraylist 适用于写少读多的并发场景<br> readwritelock : 读写锁，要求写写互斥、读写互斥，读读可以并发执行，在读多写少的情况下可以提高效率<br> concurrenthashmap 是同步的HashMap ，读写都需要加锁<br> volatile 只保证多线程操作的可见性，不保证原子性</span></p> 
</blockquote> 
<p> </p> 
<hr> 
<p> </p> 
<h2 id="day%2011%C2%A0%20%C2%A04%20%E6%9C%8823%C2%A0%E6%97%A5%E6%B5%8B%E9%AA%8C">day 12   4 月24 日测验</h2> 
<hr> 
<pre><code class="language-java">java.util.HashMap map=new java.util.HashMap();
map.put("name",null);
map.put("name","Jack");
System.out.println(map.size());</code></pre> 
<p><br> A "9HelloWorld"<br> B "_Hello World"<br> C "Hello*World"<br> D "Hello$World"</p> 
<blockquote> 
 <p>标识符有数字、美元( $ )、下划线( _ ) ，且不能以数字开头，不能使用已有的关键字 </p> 
</blockquote> 
<p><strong>2.以下java程序代码，执行后的结果是（C）</strong></p> 
<pre><code class="language-java">java.util.HashMap map=new java.util.HashMap();
map.put("name",null);
map.put("name","Jack");
System.out.println(map.size());</code></pre> 
<p>A .0     B.null    C. 1    D.2</p> 
<blockquote> 
 <p>map&lt;key,value&gt;中的key是不能重复的，当插入map中已有的key时，会自动覆盖已有的key</p> 
</blockquote> 
<p> </p> 
<p><strong>3.Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述错误的是(C)</strong><br> A ArrayList和LinkedList均实现了List接口<br> B ArrayList的访问速度比LinkedList快<br> C 添加和删除元素时，ArrayList的表现更佳<br> D HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值</p> 
<blockquote> 
 <p>删除和插入元素，LinkedList表现更佳，ArrayList删除和插入元素时，会将后面的元素进行移动，效率不高</p> 
</blockquote> 
<p> </p> 
<p><strong>4.以下描述正确的是(B)</strong><br> A CallableStatement是PreparedStatement的父接口<br> B PreparedStatement是CallableStatement的父接口<br> C CallableStatement是Statement的父接口<br> D PreparedStatement是Statement的父接口</p> 
<blockquote> 
 <p>Statement是PreParedStatement的父接口，</p> 
 <p>PrePareStatement是CallableStatement的父接口</p> 
</blockquote> 
<p> </p> 
<p>5.下列程序的运行结果(B)</p> 
<pre><code class="language-java">public static void main(String args[]) {
    Thread t = new Thread() {
        public void run() {
            pong();
        }
    };
    t.run();
    System.out.print("ping");
}
static void pong() {
    System.out.print("pong");
}</code></pre> 
<p>A pingpong<br> B pongping<br> C pingpong和pongping都有可能<br> D 都不输出</p> 
<blockquote> 
 <p>调用的是t的run方法，所以程序会按照顺序执行</p> 
 <p>如果调用的是t的start方法，则 pingpong和pongping都有可能</p> 
</blockquote> 
<p> </p> 
<p><strong>6.下列关于容器集合类的说法正确的是？(C)</strong></p> 
<p>A LinkedList继承自List</p> 
<p>B AbstractSet继承自Set<br> C HashSet继承自AbstractSet<br> D WeakMap继承自HashMap</p> 
<blockquote> 
 <p>LinkedList 继承自AbstractSequentialList 实现了List 、Deque 、Cloneable 、java.io.Serializable 接<br> 口<br> AbstractSet 继承自AbstractCollection ，实现了set 接口<br> HashSet 继承自AbstractSet ，实现了set 、Cloneable 、java.io.Serializable 接口</p> 
 <p><img alt="" height="696" src="https://images2.imgbox.com/e9/33/XTYMPkjV_o.png" width="753"></p> 
</blockquote> 
<p> </p> 
<p><strong>7.ArrayList list = new ArrayList(20);中的list扩充几次(A)</strong><br> A 0<br> B 1<br> C 2<br> D 3</p> 
<blockquote> 
 <p>ArrayList默认大小是10.如果初始化指定大小则初始就是指定的大小，ArrayList扩容每次1.5倍</p> 
</blockquote> 
<p> </p> 
<p>8.以下程序的输出结果是？(B)</p> 
<pre><code class="language-java">public class Example {
    String str = new String("good");
    char[] ch = { 'a', 'b', 'c' };
    public static void main(String args[]) {
        Example ex = new Example();
        ex.change(ex.str, ex.ch);
        System.out.print(ex.str + " and ");
        System.out.print(ex.ch);
    }
    public static void change(String str, char ch[]){
        str = "test ok";
        ch[0] = 'g';
    }
}</code></pre> 
<p>A good and abc<br> B good and gbc<br> C test ok and abc<br> D test ok and gbc</p> 
<p> </p> 
<p>9.下面的方法，当输入为2的时候返回值是多少?(D)</p> 
<pre><code class="language-java">public static int getValue(int i) {
    int result = 0;
    switch (i) {
    case 1:
        result = result + i;
    case 2:
        result = result + i * 2;
    case 3:
        result = result + i * 3;
    }
    return result;
}</code></pre> 
<p>A 0<br> B 2<br> C 4<br> D 10</p> 
<blockquote> 
 <p>switch中没有break，则会从开始的case一直执行完</p> 
</blockquote> 
<p> </p> 
<p><strong>10.下列关于Java并发的说法中正确的是（B）</strong><br> A CopyOnWriteArrayList适用于写多读少的并发场景<br> B ReadWriteLock适用于读多写少的并发场景<br> C ConcurrentHashMap的写操作不需要加锁，读操作需要加锁<br> D 只要在定义int类型的成员变量i的时候加上volatile关键字，那么多线程并发执行i++这样的操作的时候就是线程安全的了</p> 
<blockquote> 
 <p>copyonwritearraylist 适用于写少读多的并发场景<br> readwritelock : 读写锁，要求写写互斥、读写互斥，读读可以并发执行，在读多写少的情况下可以提高效率<br> concurrenthashmap 是同步的HashMap ，读写都需要加锁<br> volatile 只保证多线程操作的可见性，不保证原子性</p> 
</blockquote> 
<p> </p> 
<hr> 
<h2 id="day%2013%C2%A0%20%C2%A04%20%E6%9C%8826%C2%A0%E6%97%A5%E6%B5%8B%E9%AA%8C">day 13   4 月26 日测验</h2> 
<hr> 
<p><strong>1.下面有关JVM内存，说法错误的是？(C)</strong><br> A 程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的<br> B Java方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的<br> C 方法区用于存储JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程隔离的<br> D 原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的</p> 
<blockquote> 
 <p><span style="color:#3399ea;">方法区、堆是线程共享的，栈是线程私有的</span></p> 
</blockquote> 
<p> </p> 
<p><strong>2.下列程序段的输出结果是：（ B）</strong></p> 
<pre><code class="language-java">public void complicatedexpression_r(){
    int x=20, y=30;
    boolean b;
    b = x &gt; 50 &amp;&amp; y &gt; 60 || x &gt; 50 &amp;&amp; y &lt; -60 || x &lt; -50 &amp;&amp; y &gt; 60 || x &lt; -50 &amp;&amp; y &lt; -60;
    System.out.println(b);
}</code></pre> 
<p>A true<br> B false<br> C 1<br> D 0</p> 
<blockquote> 
 <p><span style="color:#3399ea;">运算规则，先算&amp;&amp; ，再算||</span></p> 
</blockquote> 
<p> </p> 
<p><strong>3.输入流将数据从文件，标准输入或其他外部输入设备中加载道内存，在 java 中其对应于抽象类（）及其子类。（A）</strong><br> A java.io.InputStream<br> B java.io.OutputStream<br> C java.os.InputStream<br> D java.os.OutputStream</p> 
<blockquote> 
 <p><span style="color:#3399ea;">输入输出流在io包中，输入流inputStream,输出流outputStream</span></p> 
</blockquote> 
<p>4.以下程序的输出结果是(A)</p> 
<pre><code class="language-java">public class Print{
    static boolean out(char c){
        System.out.println(c);
        return true;
    }
    public static void main(String[] argv){
        int i = 0;
        for(out('A');out('B') &amp;&amp; (i&lt;2);out('C')){
            i++;
            out('D');
        }
    }
}</code></pre> 
<p>A ABDCBDCB<br> B BCDABCD<br> C 编译错误<br> D 运行错误</p> 
<blockquote> 
 <p><span style="color:#3399ea;">out方法永远返回true，所以for循环取决于i，for循环了两次</span></p> 
</blockquote> 
<p> </p> 
<p><strong>5.下面关于程序编译说法正确的是（C）</strong><br> A java语言是编译型语言，会把java程序编译成二进制机器指令直接运行<br> B java编译出来的目标文件与具体操作系统有关<br> C java在运行时才进行翻译指令<br> D java编译出来的目标文件，可以运行在任意jvm上</p> 
<blockquote> 
 <p>java编译成的是字节码文件。被JVM翻译成机器码</p> 
 <p>java源文件生成的是.class文件，与系统无关</p> 
 <p>机器码和字节码是两个概念，javac编译生成的是.class字节码文件，java运行是将字节码文件翻译成机器码</p> 
 <p>JVM的版本会影响</p> 
</blockquote> 
<p> </p> 
<p>6.（A）仅包含方法定义和常量值。<br> A 接口<br> B 变量<br> C 单元<br> D 成员</p> 
<p> </p> 
<p>7下面程序的运行结果：(B)</p> 
<pre><code class="language-java">public static void main(String args[]) {
    Thread t=new Thread(){
        public void run(){
            dianping();
        }
    };
    t.run();
    System.out.print("dazhong");
}
static void dianping(){
    System.out.print("dianping");
}</code></pre> 
<p>A dazhongdianping<br> B dianpingdazhong<br> C a和b都有可能<br> D dianping循环输出，dazhong夹杂在中间</p> 
<p> </p> 
<blockquote> 
 <p><span style="color:#3399ea;">线程调用run()方法只是一行普通的代码，代码执行的顺序是按照代码的顺序的</span></p> 
 <p><span style="color:#3399ea;">只有当调用线程的start()方法是才会两种情况都有可能出现</span></p> 
</blockquote> 
<p> </p> 
<p><strong>8.默认类型等价表示是哪一项(C)</strong></p> 
<pre><code class="language-java">public interface IService {
    String NAME="default";
}</code></pre> 
<p>A public String NAME="default";<br> B public static String NAME="default";<br> C public static final String NAME="default";<br> D private String NAME="default";</p> 
<blockquote> 
 <p><span style="color:#3399ea;">接口中的属性只能用public static final来修饰</span></p> 
</blockquote> 
<p><strong>9.有以下类定义：</strong></p> 
<pre><code class="language-java">abstract class Animal{
    abstract void say();
}
public class Cat extends Animal{
    public Cat(){
        System.out.printf("I am a cat");
    }
    public static void main(String[] args) {
        Cat cat=new Cat();
    }
}</code></pre> 
<p>运行后：(B)</p> 
<p>A I am a cat<br> B Animal能编译，Cat不能编译<br> C Animal不能编译，Cat能编译<br> D 编译能通过，但是没有输出结果</p> 
<blockquote> 
 <p><span style="color:#3399ea;">继承抽象类必须重写抽象类中的所有方法，或者子类也是抽象类</span></p> 
 <p><span style="color:#3399ea;">所以这个题有两种改法</span></p> 
 <p><span style="color:#3399ea;">1.在Cat中重写Animal中的say方法</span></p> 
 <p><span style="color:#3399ea;">2.将Cat设置成抽象类</span></p> 
</blockquote> 
<p>10.类Test1定义如下</p> 
<pre><code class="language-java">public class Test1{//1
    public float aMethod(float a,float b){}//2
    //3
}//4</code></pre> 
<p>将以下哪种方法插入行3是不合法的。(C)<br> A public int aMethod(int a,int b){}<br> B private float aMethod(int a,int b,int c){}<br> C public float aMethod(float a,float b){}<br> D public float aMethod(float a,float b,float c){}</p> 
<blockquote> 
 <p><span style="color:#3399ea;">方法重载时要求参数类型或个数不一致，对返回值没有要求</span></p> 
</blockquote> 
<p> </p> 
<hr> 
<h2 id="day%2014%C2%A0%20%C2%A04%20%E6%9C%8827%C2%A0%E6%97%A5%E6%B5%8B%E9%AA%8C">day 14   4 月27 日测验</h2> 
<hr> 
<p><strong>1.在Java中，以下关于方法重载和方法重写描述正确的是？(D)</strong><br> A 方法重载和方法的重写实现的功能相同<br> B 方法重载出现在父子关系中，方法重写是在同一类中<br> C 方法重载的返回值类型必须一致，参数项必须不同<br> D 方法重写的返回值类型必须相同或相容。</p> 
<blockquote> 
 <p><span style="color:#4da8ee;">方法重载是同一个类中的两个函数，要求参数类型或参数个数不相同，对返回值类型没有要求</span></p> 
 <p><span style="color:#4da8ee;">方法重写是父类子类中的，要求返回值类型必须相同或相容</span></p> 
</blockquote> 
<p><strong>2.下列哪些语句关于内存回收的说明是正确的? ( B)</strong><br> A 程序员必须创建一个线程来释放内存</p> 
<p>B 内存回收程序负责释放无用内存<br> C 内存回收程序允许程序员直接释放内存<br> D 内存回收程序可以在指定的时间释放内存对象</p> 
<p> </p> 
<p><strong>3._（A）___技术是一种可以使音频，视频和其他多媒体信息在 Internet 及 Intranet 上以实时的，无需下载等待的方式进行播放的技术。</strong><br> A 流媒体<br> B 多媒体<br> C 复合媒体<br> D 音视媒体</p> 
<p> </p> 
<p><strong>4.在 java 中 , 以下 __C___ 类的对象以键 - 值的方式存储对象</strong><br> A java,util.List<br> B java,util.ArrayList<br> C java,util.HashMap<br> D java,util.LinkedList</p> 
<p> </p> 
<p><strong>5.下列语句正确的是：(D)</strong><br> A 形式参数可被字段修饰符修饰<br> B 形式参数不可以是对象<br> C 形式参数为方法被调用时真正被传递的参数<br> D 形式参数可被视为local variable</p> 
<blockquote> 
 <p><span style="color:#4da8ee;">形式参数只能用final 修饰符，其它任何修饰符都会引起编译器错误<br> 形式参数为方法被声明时的参数</span></p> 
</blockquote> 
<p> </p> 
<p><strong>6.下列哪种情况可以终止当前线程的运行？(D)</strong><br> A 当一个优先级高的线程进入就绪状态时<br> B 当该线程调用sleep()方法时<br> C 当创建一个新线程时<br> D 抛出一个异常时</p> 
<blockquote> 
 <p><span style="color:#4da8ee;">AB只会让线程阻塞，暂时停止，不会终止，线程异常或者线程正常结束才会终止当前线程</span></p> 
</blockquote> 
<p> </p> 
<p><strong>7.A派生出子类B，B派生出子类C，并且在java源代码中有如下声明：(A)</strong></p> 
<pre><code class="language-java">1.A a0=new A();
2.A a1=new B();
3.A a2=new C();</code></pre> 
<p>以下哪个说法是正确的？<br> A 第1行,第2行和第3行的声明都是正确的<br> B 第1,2,3行都能通过编译，但第2,3行运行时出错<br> C 第1,2行能通过编译，但第3行编译出错<br> D 只有第1行能通过编译</p> 
<p> </p> 
<p><strong>8.在java7中,下列哪个说法是正确的:(D)</strong><br> A ConcurrentHashMap使用synchronized关键字保证线程安全<br> B HashMap实现了Collection接口<br> C Arrays.asList方法返回java.util.ArrayList对象<br> D SimpleDateFormat对象是线程不安全的</p> 
<blockquote> 
 <p><span style="color:#4da8ee;">HashMap在单线程中使用synchronize大大提高效率，在多线程中使用hashTable来确保安全，hashTable使用synchronize关键字来确保线程安全，但是synchronize是对整张表加锁，在保证安全的同时效率大大降低，ConcurrentHashMap使用分段加锁机制来确保安全</span></p> 
 <p><span style="color:#4da8ee;">Arrays.asList 方法返回java.util.ArraysList 对象</span></p> 
</blockquote> 
<p> </p> 
<p><strong>9.给定代码：</strong></p> 
<pre><code class="language-java">public class SwitchTest{//1
    public static void main(String[] args) {//2
        System.out.println("value="+switchit(4));//3
    }//4
    public static int switchit(int x) {
        int j=1;
        switch (x) {
            case 1:j++;
            case 2:j++;
            case 3:j++;
            case 4:j++;
            case 5:j++;
            default:j++;
        }
        return j+x;
    }
}</code></pre> 
<p> </p> 
<p><strong>第三行将输出什么？(B)</strong><br> A value=6<br> B value=8<br> C value=3<br> D value=5<br> E value=4</p> 
<p> </p> 
<p><strong>10.关于以下程序段，正确的说法是：（）</strong></p> 
<pre><code class="language-java">String s1="abc"+"def";//1
String s2=new String（s1);//2
if(s1.equals(s2))//3
    System.out.println(".equals succeeded");//4
if(s1==s2)//5
    System.out.println("==succeeded");//6</code></pre> 
<p> </p> 
<p> </p> 
<hr> 
<h2 id="day%2015%C2%A0%20%C2%A04%20%E6%9C%8828%C2%A0%E6%97%A5%E6%B5%8B%E9%AA%8C">day 15   4 月28 日测验</h2> 
<hr> 
<p>1.用命令方式运行以下代码的运行结果是（C）</p> 
<pre><code class="language-java">public class f{
    public static void main(String[] args){
        String foo1 = args[1];
        String foo2 = args[2];
        String foo3 = args[3];
    }
}</code></pre> 
<p>命令: java f a b c</p> 
<p>A 程序编译错误<br> B a b c<br> C 程序运行错误<br> D f</p> 
<p>2.若有定义语句： int a=10 ; double b=3.14 ; 则表达式 'A'+a+b 值的类型是（C）</p> 
<p>A char<br> B int<br> C double<br> D float</p> 
<blockquote> 
 <p><span style="color:#4da8ee;">有浮点数的运算结果都是浮点数</span></p> 
</blockquote> 
<p> </p> 
<p>3.指出下列程序运行的结果（B）</p> 
<blockquote> 
 <pre><code class="language-java">public class Example{
    String str = new String("good");
    char[ ] ch = { 'a' , 'b' , 'c' };
    public static void main(String args[]){
        Example ex = new Example();
        ex.change(ex.str,ex.ch);
        System.out.print(ex.str + " and ");
        System.out.print(ex.ch);
    }
    public void change(String str,char ch[ ]){
        str = "test ok";
        ch[0] = 'g';
    }
}</code></pre> 
 <p>A good and abc<br> B good and gbc<br> C test ok and abc<br> D test ok and gbc</p> 
</blockquote> 
<p><strong>4.下列说法正确的是(B)</strong><br> A 在类方法中可用this来调用本类的类方法<br> B 在类方法中调用本类的类方法可直接调用<br> C 在类方法中只能调用本类的类方法<br> D 在类方法中绝对不能调用实例方法</p> 
<blockquote> 
 <p>类方法可以通过实例调用实例方法，通过类名调用其他类的类方法，本类的类方法可以直接调用</p> 
</blockquote> 
<p> </p> 
<p><strong>5.可将语句块或方法设为同步使用的语句是（A）</strong><br> A synchronized<br> B static<br> C abstract<br> D final</p> 
<p> </p> 
<p><strong>6.已知如下类说明：（D）</strong></p> 
<pre><code class="language-java">public class Test{
    private float f=1.0f;
    int m=12;
    static int n=1;
    public static void main(String args[]){
        Test t=new Test();
    }
}</code></pre> 
<p><strong>如下哪些使用是正确的（）</strong><br> A t.f = 1.0<br> B this.n<br> C Test.m<br> D Test.n</p> 
<blockquote> 
 <p><span style="color:#4da8ee;">实例边变量要通过实例调用，类变量通过类名或实例调用</span></p> 
</blockquote> 
<p>7.有以下代码:</p> 
<pre><code class="language-java">class A{
    public A(String str){
    }
}
public class Test{
    public static void main(String[] args) {
        A classa=new A("he");
        A classb=new A("he");
        System.out.println(classa==classb);
    }
}</code></pre> 
<p>请问输出的结果是:(A)<br> A false<br> B true<br> C 报错<br> D 以上选项都不正确</p> 
<p> </p> 
<p><strong>8.以下哪项不属于java类加载过程？(B)</strong><br> A 生成java.lang.Class对象<br> B int类型对象成员变量赋予默认值<br> C 执行static块代码<br> D 类方法解析</p> 
<blockquote> 
 <p><span style="color:#4da8ee;">成员变量的赋值是在对象创建的时候</span></p> 
 <p> </p> 
</blockquote> 
<p><strong>9.如果一个方法或变量是"private"访问级别，那么它的访问范围是:（D）</strong><br> A 在当前类，或者子类中<br> B 在当前类或者它的父类中<br> C 在当前类，或者它所有的父类中<br> D 在当前类中</p> 
<p>10.java中下面哪个能创建并启动线程（C）</p> 
<pre><code class="language-java">public class MyRunnable implements Runnable {
    public void run() {
    //some code here
    }
}</code></pre> 
<p>A new Runnable(MyRunnable).start()<br> B new Thread(MyRunnable).run()<br> C new Thread(new MyRunnable()).start()<br> D new MyRunnable().start()</p> 
<p> </p> 
<hr> 
<h2 id="day%2016%C2%A0%20%C2%A04%20%E6%9C%8829%C2%A0%E6%97%A5%E6%B5%8B%E9%AA%8C">day 16   4 月29 日测验</h2> 
<hr> 
<p><strong>1.如果希望监听TCP端口9000，服务器端应该怎样创建socket?(B)</strong><br> A new Socket("localhost",9000);<br> B new ServerSocket(9000);<br> C new Socket(9000);<br> D new ServerSocket("localhost",9000);</p> 
<blockquote> 
 <p><span style="color:#3399ea;">服务端监听ServerSocket ss = new ServerSocket(int port)<br> 客户端连接Soceket s = new Socket(String host,int port)<br> 网络编程服务器端只需要监听客户端的端口</span></p> 
 <p><span style="color:#3399ea;">new Socket("localhost",9000);　//客户端连接端口 <br> new ServerSocket(9000);　//服务器端监听端口</span></p> 
</blockquote> 
<p> </p> 
<p><strong>2.下列哪个类的声明是正确的？(D)</strong><br> A abstract final class HI{}<br> B abstract private move(){}<br> C protected private number;<br> D public abstract class Car{}<br>  </p> 
<blockquote> 
 <p><span style="color:#3399ea;">final和abstract不能同时用来修饰类，</span></p> 
 <p><span style="color:#3399ea;">因为abstract用来修饰类表示类是抽象类，可以被继承</span></p> 
 <p><span style="color:#3399ea;">而final用来修饰类，表示这个类是最终类，不能被继承</span></p> 
 <p><span style="color:#3399ea;">abstract用来修饰方法表示是抽象方法，抽象方法不能有方法体，而且抽象方法不能是私有的，因为抽象方法需要在其他类中重写，所以不能是私有的</span></p> 
</blockquote> 
<p> </p> 
<p> </p> 
<p>3.java 接口的修饰符可以为（D）<br> A private<br> B protected<br> C final<br> D abstract</p> 
<p> </p> 
<p>4.jre 判断程序是否执行结束的标准是（A）<br> A 所有的前台线程执行完毕<br> B 所有的后台线程执行完毕<br> C 所有的线程执行完毕<br> D 和以上都无关</p> 
<blockquote> 
 <p><span style="color:#3399ea;">后台线程不会阻止进程的终止。属于某个进程的所有前台线程都终止后，该进程就会被终止。所有剩余的后台线程都会停止且不会完成。</span></p> 
</blockquote> 
<p> </p> 
<p>5.s=( )//s 的值是什么？(E)</p> 
<pre><code class="language-java">int i=5;
int s=(i++)+(++i)+(i--)+(--i);</code></pre> 
<p>A 28<br> B 25<br> C 21<br> D 26<br> E 24<br> F 23</p> 
<p> </p> 
<p>6.如下语句通过算术运算和逻辑运算之后i和 j的结果是（D ）</p> 
<pre><code class="language-java">int i=0;
int j=0;
if((++i&gt;0)||(++j&gt;0))
{
    //打印出i和j的值。
}</code></pre> 
<p>A i=0;j=0<br> B i=1;j=1<br> C i=0;j=1<br> D i=1;j=0</p> 
<blockquote> 
 <p><span style="color:#3399ea;">对于或运算（A||B）如果A是正确则不会继续往后执行，直接结果就是正确</span></p> 
</blockquote> 
<p> </p> 
<p>7.下面不属于Object类中方法的是:(B)<br> A hashCode()<br> B finally()<br> C wait()<br> D toString()</p> 
<blockquote> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/d5/e0/lAbJOl7U_o.png" width="969"></p> 
</blockquote> 
<p> </p> 
<p>8.下列哪项不属于jdk1.6垃圾收集器？(D)<br> A Serial收集器<br> B parNew收集器<br> C CMS收集器<br> D G1收集器</p> 
<blockquote> 
 <p><span style="color:#3399ea;">1.Serial收集器 <br> 单线程收集器，收集时会暂停所有工作线程（我们将这件事情称之为Stop The World，下称STW），使用复制收集算法，虚拟机运行在Client模式时的默认新生代收集器。 <br><br> 2.ParNew收集器 <br> ParNew 收集器就是Serial的多线程版本，除了使用多条收集线程外，其余行为包括算法、STW、对象分配规则、回收策略等都与Serial收集器一摸一样。对 应的这种收集器是虚拟机运行在Server模式的默认新生代收集器，在单CPU的环境中，ParNew收集器并不会比Serial收集器有更好的效果。 <br><br> 3.Parallel Scavenge收集器 <br> Parallel Scavenge收集器（下称PS收集器）也是一个多线程收集器，也是使用复制算法，但它的对象分配规则与回收策略都与ParNew收集器有所不同，它是 以吞吐量最大化（即GC时间占总运行时间最小）为目标的收集器实现，它允许较长时间的STW换取总吞吐量最大化。 <br><br> 4.Serial Old收集器 <br> Serial Old是单线程收集器，使用标记－整理算法，是老年代的收集器，上面三种都是使用在新生代收集器。 <br><br> 5.Parallel Old收集器 <br> 老年代版本吞吐量优先收集器，使用多线程和标记－整理算法，JVM 1.6提供，在此之前，新生代使用了PS收集器的话，老年代除Serial Old外别无选择，因为PS无法与CMS收集器配合工作。 <br><br> 6.CMS（Concurrent Mark Sweep）收集器 <br> CMS 是一种以最短停顿时间为目标的收集器，使用CMS并不能达到GC效率最高（总体GC时间最小），但它能尽可能降低GC时服务的停顿时间，这一点对于实时或 者高交互性应用（譬如证券交易）来说至关重要，这类应用对于长时间STW一般是不可容忍的。CMS收集器使用的是标记－清除算法，也就是说它在运行期间会 产生空间碎片，所以虚拟机提供了参数开启CMS收集结束后再进行一次内存压缩。 </span></p> 
</blockquote> 
<p> </p> 
<p> </p> 
<p>9.instanceof运算符能够用来判断一个对象是否为:(C)<br> A 一个类的实例<br> B 一个实现指定接口的类的实例<br> C 全部正确<br> D 一个子类的实例</p> 
<blockquote> 
 <p><span style="color:#3399ea;"><strong>instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例</strong></span></p> 
 <pre><code class="language-java">interface A{
	
}
class B implements A{
	 
}
class C extends B{
	 
}
public class Iinstanceof {

	public static void main(String[] args) {
		A ab=new B();
		A ac=new C();
		B bc=new C();
		B bb=new B();
		C cc=new C();
		//对象实现一个接口，用这个对象和这个接口进行instanceof判断，都为true。
		System.out.println("ab instanceof A="+(ab instanceof A));
		System.out.println("ac instanceof A="+(ac instanceof A));
		System.out.println("bc instanceof A="+(bc instanceof A));
		System.out.println("bb instanceof A="+(bb instanceof A));
		System.out.println("cc instanceof A="+(cc instanceof A));
		//对象和父类进行instanceof判断，都为true
		System.out.println("ab instanceof B="+(ab instanceof B));
		System.out.println("ac instanceof B="+(ac instanceof B));
		System.out.println("bc instanceof B="+(bc instanceof B));
		System.out.println("bb instanceof B="+(bb instanceof B));
		System.out.println("cc instanceof B="+(cc instanceof B));
		//对象和他的子类进行instanceof判断为false
		System.out.println("ab instanceof C="+(ab instanceof C));
		System.out.println("ac instanceof C="+(ac instanceof C));
		System.out.println("bc instanceof C="+(bc instanceof C));
		System.out.println("bb instanceof C="+(bb instanceof C));
		System.out.println("cc instanceof C="+(cc instanceof C));
	}
}</code></pre> 
 <p> </p> 
</blockquote> 
<p> </p> 
<p>10.对于java类型变量char c,short s,float f,double d,表达式c*s+f+d的结果类型为（D）<br> A float<br> B char<br> C short<br> D double</p> 
<p> </p> 
<p> </p> 
<hr> 
<h2>day 17   5 月7 日测验</h2> 
<hr> 
<p>1.以下哪项是类实例化的语句？(D)<br> A varName ClassName=new varName();<br> B ClassName varName=new ClassName(new ClassName);<br> C ClassName varName=ClassName();<br> D ClassName varName=new ClassName();</p> 
<p> </p> 
<p>2.下列关于 java 语言的特点，描述错误的是（C）<br> A java是跨平台的编程语言<br> B java支持分布式计算<br> C java是面向过程的编程语言<br> D java支持多线程</p> 
<p> </p> 
<p>3.当你编译和运行下面的代码时，会出现下面选项中的哪种情况？(B)</p> 
<pre><code class="language-java">public class Pvf{
    static boolean Paddy;
    public static void main(String args[]){
        System.out.println(Paddy);
    }
}</code></pre> 
<p>A 编译时错误<br> B 编译通过并输出结果false<br> C 编译通过并输出结果true<br> D 编译通过并输出结果null</p> 
<blockquote> 
 <p>局部变量必须初始化，成员变量和类变量不需要初始化，他们具有默认值：</p> 
 <ul><li>整型(byte、int、short、long):0</li><li>浮点型(double、float):0.0</li><li>布尔型(boolean):false</li><li>字符型(char):\u0000</li><li>引用类型(String):null</li></ul> 
</blockquote> 
<p> </p> 
<p>4.以下叙述正确的是(D)<br> A 实例方法可直接调用超类的实例方法<br> B 实例方法可直接调用超类的类方法、<br> C 实例方法可直接调用子类的实例方法<br> D 实例方法可直接调用本类的实例方法</p> 
<blockquote> 
 <p><span style="color:#3399ea;">实例方法调用超类的方法，超类的方法必须是public或protected</span></p> 
 <p><span style="color:#3399ea;">实例方法可直接调用实例方法可静态方法</span></p> 
 <p><span style="color:#3399ea;">静态方法调用实例方法必须使用实例调用，调用静态方法可直接调用</span></p> 
</blockquote> 
<p> </p> 
<p>5.Java 语言用以下哪个类来把基本类型数据封装为对象（A）<br> A 包装类<br> B Class<br> C Math<br> D Object</p> 
<p> </p> 
<p>6.c变量a是一个64位有符号的整数，初始值用16进制表示为：0Xf000000000000000； 变量b是一个64位有符号的整数，初始值用16进制表示为：<br> 0x7FFFFFFFFFFFFFFF。 则a-b的结果用10进制表示为多少？（C）<br> A 1<br> B -(2^62+2^61+2^60+1)<br> C 2^62+2^61+2^60+1<br> D 2^59+(2^55+2^54+…+2^2+2^1+2^0)</p> 
<p> </p> 
<p>7.HashSet子类依靠()方法区分重复元素。(C)<br> A toString(),equals()<br> B clone(),equals()<br> C hashCode(),equals()<br> D getClass(),clone()</p> 
<p> </p> 
<p>8.以下代码在编译和运行过程中会出现什么情况(A)</p> 
<pre><code class="language-java">public class TestDemo{
    private int count;
    public static void main(String[] args) {
        TestDemo test=new TestDemo(88);
        System.out.println(test.count);
    }
    TestDemo(int a) {
        count=a;
    }
}</code></pre> 
<p>A 编译运行通过，输出结果是88<br> B 编译时错误，count变量定义的是私有变量<br> C 编译时错误，System.out.println方法被调用时test没有被初始化<br> D 编译和执行时没有输出结果</p> 
<p> </p> 
<p>9.以下程序执行的结果是：(C)</p> 
<pre><code class="language-java">class X{
    Y y=new Y();
    public X(){
        System.out.print("X");
    }
}
class Y{
    public Y(){
        System.out.print("Y");
    }
}
public class Z extends X{
    Y y=new Y();
    public Z(){
        System.out.print("Z");
    }
    public static void main(String[] args) {
        new Z();
    }
}</code></pre> 
<p>A ZYXX<br> B ZYXY<br> C YXYZ<br> D XYZX</p> 
<p>10.有这么一段程序：</p> 
<pre><code class="language-java">public class Test{
    public String name="abc";
    public static void main(String[] args){
        Test test=new Test();
        Test testB=new Test();
        System.out.println(test.equals(testB)+","+test.name.equals(testB.name));
    }
}</code></pre> 
<p>请问以上程序执行的结果是（）<br> A true,true<br> B true,false<br> C false,true<br> D false,false</p> 
<blockquote> 
 <p>第一个比较的是两个Test的对象是否一致，一个是test一个是TestB，分别在堆的两块内存空间，所以是false。</p> 
 <p>第二个比较的时候name的值是否一致，都是abc，true</p> 
</blockquote> 
<p> </p> 
<p> </p> 
<p> </p> 
<hr> 
<h2>day 18   5 月8 日测验</h2> 
<hr> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<hr> 
<h2>day 19   5 月10 日测验</h2> 
<hr> 
<p> </p> 
<p> </p> 
<p> </p> 
<hr> 
<h2>day 20   5 月11 日测验</h2> 
<hr> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7a1414e1292f6182295284ee4b8bf489/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java网络编程入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b0005882218758541a279c2a88bebb99/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue3 TypeScript 配置 Vuex4</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>