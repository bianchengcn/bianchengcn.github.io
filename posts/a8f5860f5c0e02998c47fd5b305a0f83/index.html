<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java 面向对象编程——继承 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java 面向对象编程——继承" />
<meta property="og:description" content="目录
第五章、继承
一、继承
1.继承的格式
2.继承中的构造方法
3.父类的引用指向子类对象
4.总结
二、重写
1.方法的重写
2.重写时的super
3.重写与重载的区别
4.练习
第五章、继承 一、继承 通过extends关键字可以实现继承子类可以通过继承获取父类的属性和方法，也可以定义自己独有的属性和方法。继承单一性: 一个子类只能有一个父类(1个儿子只能有一个爸爸)，但一个父类可以有多个子类。继承： 子类继承父类---&gt;代码的复用性 1.主要作用： 子类可以通过继承获取父类的属性和方法
2.特性：单一继承性，一个子类只能有一个父类
1.继承的格式 格式： class Son extents Father extends:关键字 /** * 子类 * @author JeffLee * */ public class SubClass extends SuperClass{ ​ public static void main(String[] args) { ​ new SubClass().SuperInfo(); //子类对象调用了子类中继承的SuperInfo方法。 } } //父类 class SuperClass { String name; int age; public void SuperInfo() { System.out.println(&#34;SuperInfo....&#34;); } } ​ 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/a8f5860f5c0e02998c47fd5b305a0f83/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-19T22:03:24+08:00" />
<meta property="article:modified_time" content="2022-08-19T22:03:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java 面向对象编程——继承</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E7%BB%A7%E6%89%BF" rel="nofollow">第五章、继承</a></p> 
<p id="%E4%B8%80%E3%80%81%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E7%BB%A7%E6%89%BF" rel="nofollow">一、继承</a></p> 
<p id="1.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F-toc" style="margin-left:80px;"><a href="#1.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F" rel="nofollow">1.继承的格式</a></p> 
<p id="2.%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">2.继承中的构造方法</a></p> 
<p id="3.%E7%88%B6%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#3.%E7%88%B6%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1" rel="nofollow">3.父类的引用指向子类对象</a></p> 
<p id="4.%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#4.%E6%80%BB%E7%BB%93" rel="nofollow">4.总结</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%87%8D%E5%86%99-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E9%87%8D%E5%86%99" rel="nofollow">二、重写</a></p> 
<p id="1.%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99-toc" style="margin-left:80px;"><a href="#1.%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99" rel="nofollow">1.方法的重写</a></p> 
<p id="2.%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84super-toc" style="margin-left:80px;"><a href="#2.%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84super" rel="nofollow">2.重写时的super</a></p> 
<p id="3.%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#3.%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">3.重写与重载的区别</a></p> 
<p id="4.%E7%BB%83%E4%B9%A0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#4.%E7%BB%83%E4%B9%A0%EF%BC%9A" rel="nofollow">4.练习</a></p> 
<hr> 
<h2 id="%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E7%BB%A7%E6%89%BF">第五章、继承</h2> 
<h3 id="%E4%B8%80%E3%80%81%E7%BB%A7%E6%89%BF">一、继承</h3> 
<ul><li><strong>通过extends关键字可以实现继承</strong></li><li><strong>子类可以通过继承获取父类的属性和方法，也可以定义自己独有的属性和方法。</strong></li><li><strong>继承单一性: 一个子类只能有一个父类(1个儿子只能有一个爸爸)，但一个父类可以有多个子类。</strong></li><li><strong>继承： 子类继承父类---&gt;代码的复用性</strong></li></ul> 
<p><strong>1.主要作用： 子类可以通过继承获取父类的属性和方法</strong></p> 
<p><strong>2.特性：单一继承性，一个子类只能有一个父类</strong></p> 
<h4 id="1.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F">1.继承的格式</h4> 
<pre><code class="language-java">格式： class Son extents Father extends:关键字

/**
* 子类
* @author JeffLee
*
*/
public class SubClass extends SuperClass{
​
        public static void main(String[] args) {
​
              new SubClass().SuperInfo();
            //子类对象调用了子类中继承的SuperInfo方法。
     }
}
//父类
class SuperClass {     
     String name;
     int age;
     
     public void SuperInfo() {
           System.out.println("SuperInfo....");
      }
}
​</code></pre> 
<p></p> 
<h4 id="2.%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">2.继承中的构造方法</h4> 
<ul><li> <p>1.当存在继承关系时，执行子类的任意构造方法时 要先去执行父类的无参构造方法，再执行子类的构造方法</p> </li><li> <p>2.当存在继承关系时，父类必须得有无参构造方法，否则会报错。</p> </li><li> <p>3.执行时先执行父类的无参构造，后执行子类</p> </li><li> <p>4.super关键字----&gt;父类对象;结合this---&gt;当前对象；</p> </li><li> <p>5.this();------&gt;当前类的构造方法 super();-----&gt;表示父类的构造方法</p> </li><li> <p>对于执行子类构造方法时先去调用父类的构造方法，可以理解为，编译器给每一个子类的构造方法都都加了super（）执行父类的无参构造方法，当我们显式的为子类构造方法提供了super(）的结构.</p> </li></ul> 
<pre><code class="language-java">package com.hqyj.oop.extend;
​
/*
父类：
​
 */
public class Father {
​
    String name;
    int age;
​
    public Father() {
        System.out.println("父类的无参构造方法....");
    }
    public Father(int x) {
        System.out.println("父类的一个参数构造方法....");
    }
​
    public void showFather(){
        System.out.println("showfather....");
    }
}
​
/*
子类：
​
 */
public class Son  extends Father{
​
    public  Son() {
        super(1);    //相当于加一个super（）；
        System.out.println("执行了子类的无参构造方法");
    }
​
    public  Son(int x) {
        System.out.println("子类的一个参数的构造方法");
    }
    public void showson(){
        System.out.println("sonshow");
​
​
    }
}
​
/*
继承中的构造方法   
 */
public class TestExtend2 {
​
    public static void main(String[] args) {
​
        Son son = new Son();  //实例化了son对象
        //会执行父类的无参构造方法
​
    }
}</code></pre> 
<h4 id="3.%E7%88%B6%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1">3.父类的引用指向子类对象</h4> 
<ul><li> <p>父类的引用可以指向子类的对象，也叫做子类对象向上造型为父类类型。 当</p> </li><li> <p>父类的引用指向子类对象时，父类的引用只能访问父类的属性和方法。</p> </li></ul> 
<pre><code class="language-java">public class TestExtend3  {
    public static void main(String[] args) {
        //new SubClass(1);  //创建子类的对象
​
        //子类的引用指向子类对象
        SubClass sub = new SubClass();
        sub.showsuper();
        sub.showSub();
​
​
        //多态：
        SuperClass superClass1 = new SuperClass(); //父类的引用指向父类对象
        //子类类型向上造型成为了父类类型,
        superClass1.showsuper();
​
        SuperClass superClass2 = new SubClass();
        //父类的引用指向子类对象,父类的引用只能使用父类的属性和方法
        superClass2.showsuper();
    }
}
​
/*
子类（基类）
 */
public class SubClass extends SuperClass{
​
    public SubClass() {
        System.out.println("子类无参构造方法");
    }
    public SubClass(int x) {
        System.out.println("子类一个参构造方法");
    }
    public void showSub(){
        System.out.println("Subshow....");
    }
​
}
/*
父类（超类）
 */
public class SuperClass {
    String name;
​
    public SuperClass() {
        System.out.println("父类的无参构造方法");
    }
    public SuperClass(int  x) {
        System.out.println("父类的一个参构造方法");
    }
    public  void showsuper() {
​
        System.out.println("showsuper.......");
    }
}
​</code></pre> 
<h4 id="4.%E6%80%BB%E7%BB%93">4.总结</h4> 
<p><span style="color:#fe2c24;"><strong>    继承：</strong></span></p> 
<ul><li> <p>1.通过extends关键字实现继承，子类继承父类，子类可以获取父类的属性和方法</p> </li><li> <p>2.子类可以定义自己的独有的方法，功能扩展</p> </li><li> <p>3.单一继承性，一个子类只有一个父类</p> </li><li> <p>4.可以多层继承，一个子类可以有一个父类，一个父类可以另一个父类</p> </li></ul> 
<p></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>继承中的构造方法：</strong></span></p> 
<ul><li> <p>1.在继承关系中，执行子类的构造方法时，会先执行父类的无参构造方法， 如果父类没有无参构造方法就会出现编译错误</p> </li><li> <p>2.super关键字：指代父类对象 super（）；表示执行了父类的无参构造方法； super（参数）：表示执行了父类的对应参数构造方法</p> </li><li> <p>3.在继承结构中，编译器会默认在子类的构造方法中第一行，加一个super（）， 因此会在执行子类的构造方法时，先去执行父类的无参构造方法</p> </li><li> <p>4.当我们显式的写出了任意的super()，那么编译器不会再提供super（）</p> </li><li> <p>5.super（）必须放在构造方法的第一行</p> </li><li> <p>6.可以用super（）调用父类的方法，表示父类引用</p> </li></ul> 
<p><span style="color:#fe2c24;"><strong>父类的引用指向子类对象：</strong></span></p> 
<ul><li> <p>1.父类的引用指向子类对象时，只能调用父类的属性和方法。</p> </li></ul> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81%E9%87%8D%E5%86%99">二、重写</h3> 
<h4 id="1.%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99">1.方法的重写</h4> 
<ul><li> <p>子类可以重写(覆盖)父类中定义的方法，即方法名和参数列表与父类方法相同，但方法体不同</p> </li><li> <p>当子类对象重写的方法被调用时，无论引用是父类还是子类都执行重写后的方法。</p> </li></ul> 
<h4 id="2.%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84super">2.重写时的super</h4> 
<pre><code class="language-java">@Override
public void show() {
    super.show();//可以使用父类的关键字super调用父类的show方法
    System.out.println("Subshow!");
}</code></pre> 
<h4 id="3.%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB">3.重写与重载的区别</h4> 
<ul><li> <p>重载</p> </li></ul> 
<ol><li>发生在编译期</li><li>方法名相同，但参数列表不同</li><li>调用时根据方法名和参数列表去判断</li></ol> 
<ul><li> <p>重写</p> </li></ul> 
<ol><li>发生在运行期</li><li>前提是: 存在继承关系时，子类重写的方法与父类完全一致</li><li>调用时根据引用指向的对象类型去判断</li></ol> 
<h4 id="4.%E7%BB%83%E4%B9%A0%EF%BC%9A">4.练习</h4> 
<p>1.新建一个类Shape(图形类)。实现功能：</p> 
<p>        计算面积（area）的功能：输出字符串area.....</p> 
<p>        计算周长（perimeter）的功能：输出字符串perimeter.....</p> 
<p>2.新建一个Circle(圆类)继承Shape类，重写他的Area方法和perimeter方法，实现计算圆的面积和周长的功能</p> 
<p>3.新建一个Square（正方形类）继承Shape类，重写他的Area方法和perimeter方法，实现计算圆的面积和周长的功能。</p> 
<p>4.新建测试类TestShape,测试正方形和圆的功能。</p> 
<pre><code class="language-java">//Shaper.java


public class Shape {

    public void area(double x){
        System.out.println("area.....");
    }
    public void perimeter(double x){
        System.out.println("perimeter.....");
    }

}


</code></pre> 
<pre><code class="language-java">//Circle.java


public class Circle  extends  Shape{
    @Override
    public void area(double x) {
        System.out.println("圆的面积为："+3.14*x*x);

    }

    @Override
    public void perimeter(double x) {
        System.out.println("圆的周长为："+2*3.14*x);

    }
}


</code></pre> 
<pre><code class="language-java">//Square.java



public class Square extends  Shape{

    @Override
    public void area(double x) {
        System.out.println("正方形的面积为："+x*x);
    }

    @Override
    public void perimeter(double x) {
        System.out.println("正方形的周长为："+4*x);
    }
}


</code></pre> 
<pre><code class="language-java">//TestShape


public class TestShape {

    public static void main(String[] args) {
        Shape circle = new Circle();
        circle.area(2);
        circle.perimeter(2);

        Shape square = new Square();
        square.area(2);
        square.perimeter(2);
    }

}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ba9a3eaa0b98784f820eb8256f8c4ae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">WPS 字符串拼接详解（concat、concatenate）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/73b29b6cdcbaf9aa037fd6f2715cbdc7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端学习笔记二.布局方式的选择与Flex布局示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>