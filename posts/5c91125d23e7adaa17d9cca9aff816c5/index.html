<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring 5 AutowireCapableBeanFactory -- resolveDependency源码分析(二) - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring 5 AutowireCapableBeanFactory -- resolveDependency源码分析(二)" />
<meta property="og:description" content="Spring 5 AutowireCapableBeanFactory – resolveDependency源码分析(一)
Spring 5 AutowireCapableBeanFactory – resolveDependency源码分析(二)
相关源码注释 ApplicationContext Spring 5 DefaultResourceLoader 源码注释
Spring 5 AbstractApplicationContext 源码注释
BeanFactory Spring 5 SimpleAliasRegistry 源码注释
Spring 5 DefaultSingletonBeanRegistry 源码注释
Spring 5 FactoryBeanRegistrySupport 源码注释
Spring 5 AbstractBeanFactory 源码注释
Spring 5 AbstractAutowireCapableBeanFactory 源码注释
Spring 5 DefaultLisbaleBeanFactory 源码注释
resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter); 针对desciptor所包装的对象类型是[stream,数组,Collection类型且对象类型是接口,Map]的情况，进行解析与依赖类型匹配的 候选Bean对象，并将其封装成相应的依赖类型对象:
获取包装的参数/字段的声明的(非通用)类型【变量 type】【当decriptor所包装的对象是Stream类型】: 如果描述符是Stream依赖项描述符: 查找与valueType匹配的候选bean对象;构建成Map，key=bean名,val=Bean对象【变量 matchingBeans】自动注入匹配成功的候选Bean名集合不为null,将所有的自动注入匹配成功的候选Bean名添加到autowiredBeanNames取出除Bean对象为NullBean以外的所有候选Bean名称的Bean对象【变量 stream】如果decriptor需要排序,根据matchingBean构建排序比较器，交由steam进行排序返回已排好序且已存放除Bean对象为NullBean以外的所有候选Bean名称的Bean对象的stream对象【变量 stream】 【当decriptor所包装的对象是数组类型】： 如果依赖类型是数组类型: 获取type的元素Class对象【变量 componentType】获取decriptor包装的参数/字段所构建出来的ResolvableType对象【变量 resolvableType】让resolvableType解析出的对应的数组Class对象，如果解析失败，就引用type【变量 resolvedArrayType】如果resolvedArrayType与type不是同一个Class对象,componentType就引用resolvableType解析处理的元素Class对象如果没有元素Class对象，就返回null，表示获取不到候选bean对象查找与valueType匹配的候选bean对象;构建成Map，key=bean名,val=Bean对象【变量 matchingBeans】如果没有候选Bean对象,返回null，表示获取不到候选bean对象自动注入匹配成功的候选Bean名集合不为null,将所有的自动注入匹配成功的候选Bean名添加到autowiredBeanNames如果有传入类型转换器就引用传入的类型转换器，否则获取此BeanFactory使用的类型转换器将所有候选Bean对象转换为resolvedArrayType类型【变量 result】如果result是数组实例: 构建依赖比较器,用于对matchingBean的所有bean对象进行优先级排序【变量 comparator】如果比较器不为null,使用comparator对result数组进行排序 返回该候选对象数组【result】 【如果依赖类型属于Collection类型 且 依赖类型是否接口】: 将descoptor所包装的参数/字段构建出来的ResolvableType对象解析成Collectionl类型，然后解析出其 泛型参数的Class对象【变量 elementType】如果元素类型为null,返回null，表示获取不到候选bean对象查找与valueType匹配的候选bean对象;构建成Map，key=bean名,val=Bean对象【变量 matchingBeans】如果没有候选bean对象，返回null，表示获取不到候选bean对象自动注入匹配成功的候选Bean名集合不为null,将所有的自动注入匹配成功的候选Bean名添加到autowiredBeanNames如果有传入类型转换器就引用传入的类型转换器，否则获取此BeanFactory使用的类型转换器将所有候选Bean对象转换为resolvedArrayType类型【变量 result】如果result是List实例: 构建依赖比较器,用于对matchingBean的所有bean对象进行优先级排序【变量 comparator】如果比较器不为null,使用comparator对result数组进行排序 返回该候选对象数组【result】 【如果依赖类型是Map类型】： 将descoptor所包装的参数/字段构建出来的ResolvableType对象解析成Map类型【变量 mapType】解析出第1个泛型参数的Class对象,即key的Class对象【变量 keyType】如果keyType不是String类型,返回null，表示获取不到候选bean对象解析出第2个泛型参数的Class对象,即value的Class对象【变量 valueType】如果keyType为null，即解析不出value的Class对象或者是根本没有value的Class对象, 返回null，表示获取不到候选bean对象查找与valueType匹配的候选bean对象;构建成Map，key=bean名,val=Bean对象【变量 matchingBeans】如果没有候选bean对象,返回null，表示获取不到候选bean对象自动注入匹配成功的候选Bean名集合不为null,将所有的自动注入匹配成功的候选Bean名添加到autowiredBeanNames返回候选的Bean对象Map【matchingBeans】 /** * 针对desciptor所包装的对象类型是[stream,数组,Collection类型且对象类型是接口,Map]的情况，进行解析与依赖类型匹配的 * 候选Bean对象，并将其封装成相应的依赖类型对象 * @param descriptor 依赖项的描述符(字段/方法/构造函数) * @param beanName 声明给定依赖项的bean名 * @param autowiredBeanNames 一个集合，所有自动装配的bean名(用于解决给定依赖关系)都应添加." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5c91125d23e7adaa17d9cca9aff816c5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-05T15:09:46+08:00" />
<meta property="article:modified_time" content="2020-09-05T15:09:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring 5 AutowireCapableBeanFactory -- resolveDependency源码分析(二)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><a href="https://blog.csdn.net/qq_30321211/article/details/108358105">Spring 5 AutowireCapableBeanFactory – resolveDependency源码分析(一)</a><br> <a href="https://blog.csdn.net/qq_30321211/article/details/108361995">Spring 5 AutowireCapableBeanFactory – resolveDependency源码分析(二)</a></p> 
</blockquote> 
<h2><a id="_3"></a>相关源码注释</h2> 
<h3><a id="ApplicationContext_4"></a>ApplicationContext</h3> 
<blockquote> 
 <p><a href="https://blog.csdn.net/qq_30321211/article/details/108377606">Spring 5 DefaultResourceLoader 源码注释</a><br> <a href="https://blog.csdn.net/qq_30321211/article/details/108377551">Spring 5 AbstractApplicationContext 源码注释</a></p> 
</blockquote> 
<h3><a id="BeanFactory_7"></a>BeanFactory</h3> 
<blockquote> 
 <p><a href="https://blog.csdn.net/qq_30321211/article/details/108377035">Spring 5 SimpleAliasRegistry 源码注释</a><br> <a href="https://blog.csdn.net/qq_30321211/article/details/108376942">Spring 5 DefaultSingletonBeanRegistry 源码注释</a><br> <a href="https://blog.csdn.net/qq_30321211/article/details/108376502">Spring 5 FactoryBeanRegistrySupport 源码注释</a><br> <a href="https://blog.csdn.net/qq_30321211/article/details/108376363">Spring 5 AbstractBeanFactory 源码注释</a><br> <a href="https://blog.csdn.net/qq_30321211/article/details/108376204">Spring 5 AbstractAutowireCapableBeanFactory 源码注释</a><br> <a href="https://blog.csdn.net/qq_30321211/article/details/108367733">Spring 5 DefaultLisbaleBeanFactory 源码注释</a></p> 
</blockquote> 
<h2><a id="resolveMultipleBeansdescriptor_beanName_autowiredBeanNames_typeConverter_16"></a>resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</h2> 
<p>针对desciptor所包装的对象类型是[stream,数组,Collection类型且对象类型是接口,Map]的情况，进行解析与依赖类型匹配的 候选Bean对象，并将其封装成相应的依赖类型对象:</p> 
<ol><li>获取包装的参数/字段的声明的(非通用)类型【变量 type】</li><li>【当decriptor所包装的对象是Stream类型】: 
  <ol><li>如果描述符是Stream依赖项描述符: 
    <ol><li>查找与valueType匹配的候选bean对象;构建成Map，key=bean名,val=Bean对象【变量 matchingBeans】</li><li>自动注入匹配成功的候选Bean名集合不为null,将所有的自动注入匹配成功的候选Bean名添加到autowiredBeanNames</li><li>取出除Bean对象为NullBean以外的所有候选Bean名称的Bean对象【变量 stream】</li><li>如果decriptor需要排序,根据matchingBean构建排序比较器，交由steam进行排序</li><li>返回已排好序且已存放除Bean对象为NullBean以外的所有候选Bean名称的Bean对象的stream对象【变量 stream】</li></ol> </li></ol> </li><li>【当decriptor所包装的对象是数组类型】： 
  <ol><li>如果依赖类型是数组类型: 
    <ol><li>获取type的元素Class对象【变量 componentType】</li><li>获取decriptor包装的参数/字段所构建出来的ResolvableType对象【变量 resolvableType】</li><li>让resolvableType解析出的对应的数组Class对象，如果解析失败，就引用type【变量 resolvedArrayType】</li><li>如果resolvedArrayType与type不是同一个Class对象,componentType就引用resolvableType解析处理的元素Class对象</li><li>如果没有元素Class对象，就返回null，表示获取不到候选bean对象</li><li>查找与valueType匹配的候选bean对象;构建成Map，key=bean名,val=Bean对象【变量 matchingBeans】</li><li>如果没有候选Bean对象,返回null，表示获取不到候选bean对象</li><li>自动注入匹配成功的候选Bean名集合不为null,将所有的自动注入匹配成功的候选Bean名添加到autowiredBeanNames</li><li>如果有传入类型转换器就引用传入的类型转换器，否则获取此BeanFactory使用的类型转换器</li><li>将所有候选Bean对象转换为resolvedArrayType类型【变量 result】</li><li>如果result是数组实例: 
      <ol><li>构建依赖比较器,用于对matchingBean的所有bean对象进行优先级排序【变量 comparator】</li><li>如果比较器不为null,使用comparator对result数组进行排序</li></ol> </li><li>返回该候选对象数组【result】</li></ol> </li></ol> </li><li>【如果依赖类型属于Collection类型 且 依赖类型是否接口】: 
  <ol><li>将descoptor所包装的参数/字段构建出来的ResolvableType对象解析成Collectionl类型，然后解析出其 泛型参数的Class对象【变量 elementType】</li><li>如果元素类型为null,返回null，表示获取不到候选bean对象</li><li>查找与valueType匹配的候选bean对象;构建成Map，key=bean名,val=Bean对象【变量 matchingBeans】</li><li>如果没有候选bean对象，返回null，表示获取不到候选bean对象</li><li>自动注入匹配成功的候选Bean名集合不为null,将所有的自动注入匹配成功的候选Bean名添加到autowiredBeanNames</li><li>如果有传入类型转换器就引用传入的类型转换器，否则获取此BeanFactory使用的类型转换器</li><li>将所有候选Bean对象转换为resolvedArrayType类型【变量 result】</li><li>如果result是List实例: 
    <ol><li>构建依赖比较器,用于对matchingBean的所有bean对象进行优先级排序【变量 comparator】</li><li>如果比较器不为null,使用comparator对result数组进行排序</li></ol> </li><li>返回该候选对象数组【result】</li></ol> </li><li>【如果依赖类型是Map类型】： 
  <ol><li>将descoptor所包装的参数/字段构建出来的ResolvableType对象解析成Map类型【变量 mapType】</li><li>解析出第1个泛型参数的Class对象,即key的Class对象【变量 keyType】</li><li>如果keyType不是String类型,返回null，表示获取不到候选bean对象</li><li>解析出第2个泛型参数的Class对象,即value的Class对象【变量 valueType】</li><li>如果keyType为null，即解析不出value的Class对象或者是根本没有value的Class对象, 返回null，表示获取不到候选bean对象</li><li>查找与valueType匹配的候选bean对象;构建成Map，key=bean名,val=Bean对象【变量 matchingBeans】</li><li>如果没有候选bean对象,返回null，表示获取不到候选bean对象</li><li>自动注入匹配成功的候选Bean名集合不为null,将所有的自动注入匹配成功的候选Bean名添加到autowiredBeanNames</li><li>返回候选的Bean对象Map【matchingBeans】</li></ol> </li></ol> 
<pre><code class="prism language-java"><span class="token comment">/**
	 * 针对desciptor所包装的对象类型是[stream,数组,Collection类型且对象类型是接口,Map]的情况，进行解析与依赖类型匹配的
	 * 候选Bean对象，并将其封装成相应的依赖类型对象
	 * @param descriptor 依赖项的描述符(字段/方法/构造函数)
	 * @param beanName 声明给定依赖项的bean名
	 * @param autowiredBeanNames 一个集合，所有自动装配的bean名(用于解决给定依赖关系)都应添加.即自动注入匹配成功的候选Bean名集合。
	 *                           【当autowiredBeanNames不为null，会将所找到的所有候选Bean对象添加到该集合中,以供调用方使用】
	 * @param typeConverter 用于填充数组和集合的TypeConverter
	 * @return 由候选Bean对象组成对象，该对象与descriptor的依赖类型相同;如果descriptor的依赖类型不是
	 * [stream,数组,Collection类型且对象类型是接口,Map],又或者解析不出相应的依赖类型，又或者拿不到候选Bean对象都会导致返回null
	 */</span>
	<span class="token annotation punctuation">@Nullable</span>
	<span class="token keyword">private</span> Object <span class="token function">resolveMultipleBeans</span><span class="token punctuation">(</span>DependencyDescriptor descriptor<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> String beanName<span class="token punctuation">,</span>
			<span class="token annotation punctuation">@Nullable</span> Set<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> autowiredBeanNames<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> TypeConverter typeConverter<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

		<span class="token comment">//获取包装的参数/字段的声明的(非通用)类型</span>
		<span class="token keyword">final</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> type <span class="token operator">=</span> descriptor<span class="token punctuation">.</span><span class="token function">getDependencyType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//如果描述符是Stream依赖项描述符</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>descriptor <span class="token keyword">instanceof</span> <span class="token class-name">StreamDependencyDescriptor</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//查找与valueType匹配的候选bean对象;构建成Map，key=bean名,val=Bean对象</span>
			Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> matchingBeans <span class="token operator">=</span> <span class="token function">findAutowireCandidates</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> type<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//自动注入匹配成功的候选Bean名集合不为null</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>autowiredBeanNames <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//将所有的自动注入匹配成功的候选Bean名添加到autowiredBeanNames</span>
				autowiredBeanNames<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>matchingBeans<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//取出除Bean对象为NullBean以外的所有候选Bean名称的Bean对象</span>
			Stream<span class="token generics function"><span class="token punctuation">&lt;</span>Object<span class="token punctuation">&gt;</span></span> stream <span class="token operator">=</span> matchingBeans<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
					<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>name <span class="token operator">-</span><span class="token operator">&gt;</span>
			<span class="token comment">//将name解析为该Bean工厂的Bean实例</span>
			descriptor<span class="token punctuation">.</span><span class="token function">resolveCandidate</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token comment">//只要收集bean对象不为NullBean对象</span>
					<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>bean <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token operator">!</span><span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">NullBean</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果decriptor需要排序</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>StreamDependencyDescriptor<span class="token punctuation">)</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOrdered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//根据matchingBean构建排序比较器，交由steam进行排序</span>
				stream <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token function">adaptOrderComparator</span><span class="token punctuation">(</span>matchingBeans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//返回已排好序且已存放除Bean对象为NullBean以外的所有候选Bean名称的Bean对象的stream对象</span>
			<span class="token keyword">return</span> stream<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//如果依赖类型是数组类型</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//获取type的元素Class对象</span>
			Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> componentType <span class="token operator">=</span> type<span class="token punctuation">.</span><span class="token function">getComponentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//获取decriptor包装的参数/字段所构建出来的ResolvableType对象</span>
			ResolvableType resolvableType <span class="token operator">=</span> descriptor<span class="token punctuation">.</span><span class="token function">getResolvableType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//让resolvableType解析出的对应的数组Class对象，如果解析失败，就引用type</span>
			Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> resolvedArrayType <span class="token operator">=</span> resolvableType<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果resolvedArrayType与type不是同一个Class对象</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedArrayType <span class="token operator">!=</span> type<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//componentType就引用resolvableType解析处理的元素Class对象</span>
				componentType <span class="token operator">=</span> resolvableType<span class="token punctuation">.</span><span class="token function">getComponentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//如果没有元素Class对象，就返回null，表示获取不到候选bean对象</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>componentType <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//MultiElemetDesciptor:具有嵌套元素的多元素声明的依赖描述符，表示集合/数组依赖</span>
			<span class="token comment">//查找与valueType匹配的候选bean对象;构建成Map，key=bean名,val=Bean对象</span>
			Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> matchingBeans <span class="token operator">=</span> <span class="token function">findAutowireCandidates</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> componentType<span class="token punctuation">,</span>
					<span class="token keyword">new</span> <span class="token class-name">MultiElementDescriptor</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果没有候选Bean对象</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>matchingBeans<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//返回null，表示获取不到候选bean对象</span>
				<span class="token keyword">return</span> null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//自动注入匹配成功的候选Bean名集合不为null</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>autowiredBeanNames <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//将所有的自动注入匹配成功的候选Bean名添加到autowiredBeanNames</span>
				autowiredBeanNames<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>matchingBeans<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//如果有传入类型转换器就引用传入的类型转换器，否则获取此BeanFactory使用的类型转换器</span>
			TypeConverter converter <span class="token operator">=</span> <span class="token punctuation">(</span>typeConverter <span class="token operator">!=</span> null <span class="token operator">?</span> typeConverter <span class="token operator">:</span> <span class="token function">getTypeConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//将所有候选Bean对象转换为resolvedArrayType类型</span>
			Object result <span class="token operator">=</span> converter<span class="token punctuation">.</span><span class="token function">convertIfNecessary</span><span class="token punctuation">(</span>matchingBeans<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> resolvedArrayType<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果result是数组实例</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//构建依赖比较器,用于对matchingBean的所有bean对象进行优先级排序</span>
				Comparator<span class="token generics function"><span class="token punctuation">&lt;</span>Object<span class="token punctuation">&gt;</span></span> comparator <span class="token operator">=</span> <span class="token function">adaptDependencyComparator</span><span class="token punctuation">(</span>matchingBeans<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//如果比较器不为null</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>comparator <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token comment">//使用comparator对result数组进行排序</span>
					Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> result<span class="token punctuation">,</span> comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//返回该候选对象数组</span>
			<span class="token keyword">return</span> result<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//如果依赖类型属于Collection类型 且 依赖类型是否接口</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Collection<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> type<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//将descoptor所包装的参数/字段构建出来的ResolvableType对象解析成Collectionl类型，然后</span>
			<span class="token comment">// 解析出其泛型参数的Class对象</span>
			Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> elementType <span class="token operator">=</span> descriptor<span class="token punctuation">.</span><span class="token function">getResolvableType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">resolveGeneric</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果元素类型为null</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>elementType <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//返回null，表示获取不到候选bean对象</span>
				<span class="token keyword">return</span> null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//查找与valueType匹配的候选bean对象;构建成Map，key=bean名,val=Bean对象</span>
			Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> matchingBeans <span class="token operator">=</span> <span class="token function">findAutowireCandidates</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> elementType<span class="token punctuation">,</span>
					<span class="token keyword">new</span> <span class="token class-name">MultiElementDescriptor</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果没有候选bean对象，</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>matchingBeans<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//返回null，表示获取不到候选bean对象</span>
				<span class="token keyword">return</span> null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//自动注入匹配成功的候选Bean名集合不为null</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>autowiredBeanNames <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//将所有的自动注入匹配成功的候选Bean名添加到autowiredBeanNames</span>
				autowiredBeanNames<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>matchingBeans<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//如果有传入类型转换器就引用传入的类型转换器，否则获取此BeanFactory使用的类型转换器</span>
			TypeConverter converter <span class="token operator">=</span> <span class="token punctuation">(</span>typeConverter <span class="token operator">!=</span> null <span class="token operator">?</span> typeConverter <span class="token operator">:</span> <span class="token function">getTypeConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//将所有候选Bean对象转换为resolvedArrayType类型</span>
			Object result <span class="token operator">=</span> converter<span class="token punctuation">.</span><span class="token function">convertIfNecessary</span><span class="token punctuation">(</span>matchingBeans<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果result是List实例</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token keyword">instanceof</span> <span class="token class-name">List</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//构建依赖比较器,用于对matchingBean的所有bean对象进行优先级排序</span>
				Comparator<span class="token generics function"><span class="token punctuation">&lt;</span>Object<span class="token punctuation">&gt;</span></span> comparator <span class="token operator">=</span> <span class="token function">adaptDependencyComparator</span><span class="token punctuation">(</span>matchingBeans<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//如果比较器不为null</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>comparator <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token comment">//使用comparator对result数组进行排序</span>
					<span class="token punctuation">(</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//返回该候选对象数组</span>
			<span class="token keyword">return</span> result<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//如果依赖类型是Map类型</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">==</span> type<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//将descoptor所包装的参数/字段构建出来的ResolvableType对象解析成Map类型</span>
			ResolvableType mapType <span class="token operator">=</span> descriptor<span class="token punctuation">.</span><span class="token function">getResolvableType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//解析出第1个泛型参数的Class对象,即key的Class对象</span>
			Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> keyType <span class="token operator">=</span> mapType<span class="token punctuation">.</span><span class="token function">resolveGeneric</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果keyType不是String类型</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">!=</span> keyType<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//返回null，表示获取不到候选bean对象</span>
				<span class="token keyword">return</span> null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//解析出第2个泛型参数的Class对象,即value的Class对象</span>
			Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> valueType <span class="token operator">=</span> mapType<span class="token punctuation">.</span><span class="token function">resolveGeneric</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果keyType为null，即解析不出value的Class对象或者是根本没有value的Class对象</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>valueType <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//返回null，表示获取不到候选bean对象</span>
				<span class="token keyword">return</span> null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//查找与valueType匹配的候选bean对象;构建成Map，key=bean名,val=Bean对象</span>
			Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> matchingBeans <span class="token operator">=</span> <span class="token function">findAutowireCandidates</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> valueType<span class="token punctuation">,</span>
					<span class="token keyword">new</span> <span class="token class-name">MultiElementDescriptor</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果没有候选bean对象</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>matchingBeans<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//返回null，表示获取不到候选bean对象</span>
				<span class="token keyword">return</span> null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//自动注入匹配成功的候选Bean名集合不为null</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>autowiredBeanNames <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//将所有的自动注入匹配成功的候选Bean名添加到autowiredBeanNames</span>
				autowiredBeanNames<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>matchingBeans<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//返回候选的Bean对象Map</span>
			<span class="token keyword">return</span> matchingBeans<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//返回null，表示获取不到候选bean对象</span>
			<span class="token keyword">return</span> null<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="StreamDependencyDescriptor_235"></a>StreamDependencyDescriptor</h3> 
<p>用于访问多个元素的流依赖项描述符标记，一般表示stream类型依赖</p> 
<pre><code class="prism language-java"><span class="token comment">/**
	 * A dependency descriptor marker for stream access to multiple elements.
	 * &lt;p&gt;用于访问多个元素的流依赖项描述符标记，一般表示stream类型依赖&lt;/p&gt;
	 */</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StreamDependencyDescriptor</span> <span class="token keyword">extends</span> <span class="token class-name">DependencyDescriptor</span> <span class="token punctuation">{<!-- --></span>

		<span class="token comment">/**
		 * 是否需要排序标记
		 */</span>
		<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> ordered<span class="token punctuation">;</span>

		<span class="token comment">/**
		 * 新建一个StreamDependencyDescriptor实例
		 * @param original 从其创建副本的原始描述符
		 * @param ordered 是否需要排序标记
		 */</span>
		<span class="token keyword">public</span> <span class="token function">StreamDependencyDescriptor</span><span class="token punctuation">(</span>DependencyDescriptor original<span class="token punctuation">,</span> <span class="token keyword">boolean</span> ordered<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//拷贝originald的属性</span>
			<span class="token keyword">super</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>ordered <span class="token operator">=</span> ordered<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">/**
		 * 是否需要排序
		 */</span>
		<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isOrdered</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ordered<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="findAutowireCandidatesbeanName_type_descriptor_268"></a>findAutowireCandidates(beanName, type, descriptor);</h3> 
<p>查找与type匹配的候选bean对象,构建成Map，key=bean名,val=Bean对象【在自动装配指定bean期间调用】:</p> 
<ol><li>获取requiredType的所有bean名,包括父级工厂中定义的名称【变量 candidateNames】</li><li>定义用于保存匹配requiredType的bean名和其实例对象的Map，即匹配成功的候选Map【变量 result】</li><li>【从 存放着手动显示注册的依赖项类型-相应的自动装配值的缓存【resolvableDependencies】中匹配候选】: 
  <ol><li>遍历resolvableDependencies,元素classObjectEntry: 
    <ol><li>取出依赖项类型【变量 autowiringType】</li><li>如果autowiringType是属于requiredType的实例: 
      <ol><li>取出autowiringType对应的实例对象【变量 autowiringValue】</li><li>根据requiredType解析autowiringValue,并针对autowiringValue是ObjectFactory的情况进行解析,将解析出来的值 重新赋值给autowiringValue</li><li>如果autowiringValue是requiredType类型,就根据autowiringValue构建出唯一 ID与autowiringValue绑定到result中,然后跳槽循环</li></ol> </li></ol> </li></ol> </li><li>【常规匹配候选(beanDefinition是否允许依赖注入,泛型类型是否匹配,限定符注解 /限定符信息是否匹配)】: 
  <ol><li>遍历candidateNames,元素candidate: 
    <ol><li>如果beanName与candidateName所对应的Bean对象不是同一个且candidate可以自动注入, 添加一个条目在result中:一个bean实例(如果可用)或仅一个已解析的类型</li></ol> </li></ol> </li><li>【找不到候选时，就采用将回退模式(在回退模式下，候选Bean具有无法解析的泛型 || 候选Bean的Class 对象是Properties类对象时，都允许成为该描述符的可自动注入对象)尽可能的匹配到候选，一般情况 下不会出现回退情况,除非代码非常糟糕】: 
  <ol><li>如果result为空: 
    <ol><li>requiredType是否是数组/集合类型的标记【变量multiple】</li><li>获取desciptord的一个旨在用于回退匹配变体【遍历 fallbackDescriptor】</li><li>【先尝试匹配候选bean名符合允许回退匹配的依赖描述符的自动依赖条件且(依赖类型不是集合/数组 或者描述符指定限定符)的候选Bean对象】: 
      <ol><li>遍历candidateNames,元素candidate: 
        <ol><li>如果beanName与candidateName所对应的Bean对象不是同一个 且 candidate可以自动注入 且 (type不是数组/集合类型或者 desciptor有@Qualifier注解或qualifier标准修饰), 就添加一个条目在result中:一个bean实例(如果可用)或仅一个已解析的类型</li></ol> </li></ol> </li><li>【降低匹配精度:满足下面条件即可】【除beanName符合描述符依赖类型不是数组/集合，beanName与candidateName所对应的Bean对象不是同一个，descriptor不是集合依赖或者beanName与candidate不相同，候选bean名符合允许回退匹配的依赖描述符的自动依赖条件】 
      <ol><li>如果result为空且requiredType不是数组/集合类型或者</li><li>遍历candidateNames,元素candidate: 
        <ol><li>如果beanName与candidateName所对应的Bean对象不是同一个 且 (descriptor不是 MultiElementDescriptor实例(即集合依赖)或者beanName不等于candidate) 且 candidate可以自动注入,添加一个条目在result中:一个bean实例(如果可用) 或仅一个已解析的类型</li></ol> </li></ol> </li></ol> </li></ol> </li><li>返回匹配成功的后续Bean对象【result】</li></ol> 
<pre><code class="prism language-java"><span class="token comment">/**
	 * &lt;p&gt;存放着手动显示注册的依赖项类型-相应的自动装配值的缓存&lt;/p&gt;
	 * &lt;p&gt;手动显示注册指直接调用{@link #registerResolvableDependency(Class, Object)}&lt;/p&gt;
	 * Map from dependency type to corresponding autowired value.
	 * &lt;p&gt;从依赖项类型映射到相应的自动装配值&lt;/p&gt;
	 * */</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> Object<span class="token operator">&gt;</span> resolvableDependencies <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
	 * &lt;p&gt;查找与type匹配的候选bean对象,构建成Map，key=bean名,val=Bean对象【在自动装配指定bean期间调用】
	 * &lt;/p&gt;
	 * Find bean instances that match the required type.
	 * Called during autowiring for the specified bean.
	 * &lt;p&gt;查找与所需类型匹配的bean实例。在自动装配指定bean期间调用&lt;/p&gt;
	 * @param beanName the name of the bean that is about to be wired
	 *                 -- 即将被连线的bean名，要依赖的bean名(不是指desciptor的所包装的Field/MethodParamater的依赖类型的bean名，
	 *                 			而是指需要Field/MethodParamter所对应的bean对象来构建的Bean对象的Bean名)
	 * @param requiredType the actual type of bean to look for
	 * (may be an array component type or collection element type)
	 *                     -- 要查找的bean的实际类型(可以是数组组件或集合元素类型),descriptor的依赖类型
	 * @param descriptor the descriptor of the dependency to resolve
	 *                   -- 要解析的依赖项的描述符
	 * @return a Map of candidate names and candidate instances that match
	 * the required type (never {@code null})
	 * -- 匹配所需类型的候选名称和候选实例的映射(从不为null)
	 * @throws BeansException in case of errors -- 如果有错误
	 * @see #autowireByType
	 * @see #autowireConstructor
	 */</span>
	<span class="token keyword">protected</span> Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> <span class="token function">findAutowireCandidates</span><span class="token punctuation">(</span>
			<span class="token annotation punctuation">@Nullable</span> String beanName<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> requiredType<span class="token punctuation">,</span> DependencyDescriptor descriptor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//获取requiredType的所有bean名,包括父级工厂中定义的名称</span>
		String<span class="token punctuation">[</span><span class="token punctuation">]</span> candidateNames <span class="token operator">=</span> BeanFactoryUtils<span class="token punctuation">.</span><span class="token function">beanNamesForTypeIncludingAncestors</span><span class="token punctuation">(</span>
				<span class="token keyword">this</span><span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> descriptor<span class="token punctuation">.</span><span class="token function">isEager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//定义用于保存匹配requiredType的bean名和其实例对象的Map，即匹配成功的候选Map</span>
		Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>candidateNames<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//从 存放着手动显示注册的依赖项类型-相应的自动装配值的缓存 中匹配候选</span>
		<span class="token comment">//遍历 从依赖项类型映射到相应的自动装配值缓存</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> Object<span class="token operator">&gt;</span> classObjectEntry <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resolvableDependencies<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//取出依赖项类型</span>
			Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> autowiringType <span class="token operator">=</span> classObjectEntry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果autowiringType是属于requiredType的实例</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>autowiringType<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>requiredType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//取出autowiringType对应的实例对象</span>
				Object autowiringValue <span class="token operator">=</span> classObjectEntry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//根据requiredType解析autowiringValue,并针对autowiringValue是ObjectFactory的情况进行解析</span>
				autowiringValue <span class="token operator">=</span> AutowireUtils<span class="token punctuation">.</span><span class="token function">resolveAutowiringValue</span><span class="token punctuation">(</span>autowiringValue<span class="token punctuation">,</span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//如果autowiringValue是requiredType类型</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>requiredType<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>autowiringValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token comment">//objectUtils.identityToString:可得到(obj的全类名+'@'+obj的hashCode的十六进制字符串),如果obj为null，返回空字符串</span>
					<span class="token comment">//根据autowiringValue构建出唯一ID与autowiringValue绑定到result中</span>
					result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ObjectUtils<span class="token punctuation">.</span><span class="token function">identityToString</span><span class="token punctuation">(</span>autowiringValue<span class="token punctuation">)</span><span class="token punctuation">,</span> autowiringValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token comment">//跳槽循环</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//常规匹配候选</span>
		<span class="token comment">//遍历candidateNames</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>String candidate <span class="token operator">:</span> candidateNames<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//如果beanName与candidateName所对应的Bean对象不是同一个 且 candidate可以自动注入</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSelfReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> candidate<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isAutowireCandidate</span><span class="token punctuation">(</span>candidate<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//添加一个条目在result中:一个bean实例(如果可用)或仅一个已解析的类型</span>
				<span class="token function">addCandidateEntry</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> candidate<span class="token punctuation">,</span> descriptor<span class="token punctuation">,</span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//找不到候选时，就采用将回退模式尽可能的匹配到候选，一般情况下不会出现回退情况,除非代码非常糟糕</span>
		<span class="token comment">//result为空</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//requiredType是否是数组/集合类型的标记</span>
			<span class="token keyword">boolean</span> multiple <span class="token operator">=</span> <span class="token function">indicatesMultipleBeans</span><span class="token punctuation">(</span>requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// Consider fallback matches if the first pass failed to find anything...</span>
			<span class="token comment">// 如果第一遍未找到任何内容，请考虑进行回退匹配</span>
			<span class="token comment">// 在允许回退的情况下，候选Bean具有无法解析的泛型 || 候选Bean的Class对象是Properties类对象时，</span>
			<span class="token comment">//   都允许成为 该描述符的可自动注入对象</span>
			<span class="token comment">//获取desciptord的一个旨在用于回退匹配变体</span>
			DependencyDescriptor fallbackDescriptor <span class="token operator">=</span> descriptor<span class="token punctuation">.</span><span class="token function">forFallbackMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//先尝试匹配候选bean名符合允许回退匹配的依赖描述符的自动依赖条件且(依赖类型不是集合/数组或者描述符指定限定符)的候选Bean对象</span>
			<span class="token comment">//遍历candidateNames</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>String candidate <span class="token operator">:</span> candidateNames<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//getAutowireCandidateResolver()得到是QualifierAnnotationAutowireCandidateResolver实例,hasQualifier方法才有真正的限定符语义。</span>
				<span class="token comment">//如果beanName与candidateName所对应的Bean对象不是同一个 且 candidate可以自动注入 且 (type不是数组/集合类型或者</span>
				<span class="token comment">// desciptor有@Qualifier注解或qualifier标准修饰)</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSelfReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> candidate<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isAutowireCandidate</span><span class="token punctuation">(</span>candidate<span class="token punctuation">,</span> fallbackDescriptor<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
						<span class="token punctuation">(</span><span class="token operator">!</span>multiple <span class="token operator">||</span> <span class="token function">getAutowireCandidateResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasQualifier</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token comment">//添加一个条目在result中:一个bean实例(如果可用)或仅一个已解析的类型</span>
					<span class="token function">addCandidateEntry</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> candidate<span class="token punctuation">,</span> descriptor<span class="token punctuation">,</span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//匹配 除beanName符合描述符依赖类型不是数组/集合</span>
			<span class="token comment">// 且 如果beanName与candidateName所对应的Bean对象不是同一个</span>
			<span class="token comment">// 且 (descriptor不是集合依赖或者beanName与candidate不相同)</span>
			<span class="token comment">// 且 候选bean名符合允许回退匹配的依赖描述符的自动依赖条件</span>
			<span class="token comment">//如果result为空且requiredType不是数组/集合类型或者</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>multiple<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// Consider self references as a final pass...</span>
				<span class="token comment">// but in the case of a dependency collection, not the very same bean itself.</span>
				<span class="token comment">// 将自我推荐视为最终通过</span>
				<span class="token comment">// 但是对于依赖项集合，不是相同的bean本身</span>
				<span class="token comment">//遍历candidateNames</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>String candidate <span class="token operator">:</span> candidateNames<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token comment">//如果beanName与candidateName所对应的Bean对象不是同一个 且 (descriptor不是MultiElementDescriptor实例(即集合依赖)或者</span>
					<span class="token comment">// beanName不等于candidate) 且 candidate可以自动注入</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSelfReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> candidate<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
							<span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>descriptor <span class="token keyword">instanceof</span> <span class="token class-name">MultiElementDescriptor</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>beanName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>candidate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
							<span class="token function">isAutowireCandidate</span><span class="token punctuation">(</span>candidate<span class="token punctuation">,</span> fallbackDescriptor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						<span class="token comment">///添加一个条目在result中:一个bean实例(如果可用)或仅一个已解析的类型</span>
						<span class="token function">addCandidateEntry</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> candidate<span class="token punctuation">,</span> descriptor<span class="token punctuation">,</span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="BeanFactoryUtilsbeanNamesForTypeIncludingAncestors_410"></a>BeanFactoryUtils.beanNamesForTypeIncludingAncestors</h4> 
<p>获取给定类型的所有bean名,包括父级工厂中定义的名称:</p> 
<ol><li>如果lbf为null，抛出异常</li><li>获取与type（包括子类）匹配的bean名称【变量 result】,根据includeNonSingletons来决定是否包含原型+单例 还是 只包含单例,根据allowEargerInit决定是否初始化lazy-init单例和由FactoryBeans创建的对象 以进行类型检查</li><li>如果lbf是HierarchicalBeanFactory: 
  <ol><li>将lbf强转HierarchicalBeanFactory对象【变量 hbf】</li><li>如果hbf的父工厂是LisableBeanFactory对象: 
    <ol><li>递归该方法获取父工厂里type的所有bean名,包括父级工厂中定义的名称</li><li>将result结果与parentResult合并重新赋值给result</li></ol> </li></ol> </li><li>返回result</li></ol> 
<pre><code class="prism language-java"><span class="token comment">/**
	 * &lt;p&gt;获取给定类型的所有bean名,包括父级工厂中定义的名称 &lt;/p&gt;
	 * Get all bean names for the given type, including those defined in ancestor
	 * factories. Will return unique names in case of overridden bean definitions.
	 * &lt;p&gt;获取给定类型的所有bean名,包括父级工厂中定义的名称。如果覆盖了BeanDefinition，
	 * 将返回唯一名称&lt;/p&gt;
	 * &lt;p&gt;Does consider objects created by FactoryBeans if the "allowEagerInit"
	 * flag is set, which means that FactoryBeans will get initialized. If the
	 * object created by the FactoryBean doesn't match, the raw FactoryBean itself
	 * will be matched against the type. If "allowEagerInit" is not set,
	 * only raw FactoryBeans will be checked (which doesn't require initialization
	 * of each FactoryBean).
	 * &lt;p&gt;如果设置了'allowEagerInit'标记，是否考虑了由FactoryBeans创建的对象，这意味着将
	 * 初始化FactoryBeans。如果与FactoryBean创建的对象不匹配，则原始FactoryBean本身将
	 * 与该类型匹配.如果未设置'allowEagerInit',将仅检查原始FactoryBean(不需要初始化每个
	 * FactoryBean)&lt;/p&gt;
	 * @param lbf the bean factory -- bean工厂
	 * @param includeNonSingletons whether to include prototype or scoped beans too
	 * or just singletons (also applies to FactoryBeans)
	 *  -- 是否也包含原始或范围内的bean还是仅包含单例（也适用于FactoryBeans）
	 * @param allowEagerInit whether to initialize &lt;i&gt;lazy-init singletons&lt;/i&gt; and
	 * &lt;i&gt;objects created by FactoryBeans&lt;/i&gt; (or by factory methods with a
	 * "factory-bean" reference) for the type check. Note that FactoryBeans need to be
	 * eagerly initialized to determine their type: So be aware that passing in "true"
	 * for this flag will initialize FactoryBeans and "factory-bean" references.
	 *  -- 是否初始化lazy-init单例和由FactoryBeans(或带有"factory-bean"引用的工厂方法)创建
	 *     的对象以进行类型检查。注意，必须急切初始化FactoryBean以确定它们的类型：因此请注意，
	 *     为此标志传递'true'将初始化FactoryBean和'factory-bean'引用
	 * @param type the type that beans must match -- bean必须匹配的类型
	 * @return the array of matching bean names, or an empty array if none
	 * @see ListableBeanFactory#getBeanNamesForType(Class, boolean, boolean)
	 */</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">beanNamesForTypeIncludingAncestors</span><span class="token punctuation">(</span>
			ListableBeanFactory lbf<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> type<span class="token punctuation">,</span> <span class="token keyword">boolean</span> includeNonSingletons<span class="token punctuation">,</span> <span class="token keyword">boolean</span> allowEagerInit<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//如果bean工厂为null，抛出异常</span>
		Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>lbf<span class="token punctuation">,</span> <span class="token string">"ListableBeanFactory must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//获取与type（包括子类）匹配的bean名称,根据includeNonSingletons来决定是否包含原型+单例 还是 只包含单例,根据allowEargerInit</span>
		<span class="token comment">// 决定是否初始化lazy-init单例和由FactoryBeans创建的对象以进行类型检查</span>
		String<span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> lbf<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> includeNonSingletons<span class="token punctuation">,</span> allowEagerInit<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//HierarchicalBeanFactory 提供父容器的访问功能</span>
		<span class="token comment">//如果lbf是HierarchicalBeanFactory</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>lbf <span class="token keyword">instanceof</span> <span class="token class-name">HierarchicalBeanFactory</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//将lbf强转HierarchicalBeanFactory对象</span>
			HierarchicalBeanFactory hbf <span class="token operator">=</span> <span class="token punctuation">(</span>HierarchicalBeanFactory<span class="token punctuation">)</span> lbf<span class="token punctuation">;</span>
			<span class="token comment">//ListableBeanFactory：扩展BeanFactory使其支持迭代Ioc容器持有的Bean对象。注意如果</span>
			<span class="token comment">// 	ListableBeanFactory同时也是HierarchicalBeanFactory，那么大多数情况下，</span>
			<span class="token comment">// 	只迭代当前Ioc容器持有的Bean对象，不会在体系结构中想父级递归迭代</span>
			<span class="token comment">//如果hbf的父工厂是LisableBeanFactory对象</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>hbf<span class="token punctuation">.</span><span class="token function">getParentBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">ListableBeanFactory</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//递归该方法获取父工厂里type的所有bean名,包括父级工厂中定义的名称</span>
				String<span class="token punctuation">[</span><span class="token punctuation">]</span> parentResult <span class="token operator">=</span> <span class="token function">beanNamesForTypeIncludingAncestors</span><span class="token punctuation">(</span>
						<span class="token punctuation">(</span>ListableBeanFactory<span class="token punctuation">)</span> hbf<span class="token punctuation">.</span><span class="token function">getParentBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> includeNonSingletons<span class="token punctuation">,</span> allowEagerInit<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//将result结果与parentResult合并</span>
				result <span class="token operator">=</span> <span class="token function">mergeNamesWithParent</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> parentResult<span class="token punctuation">,</span> hbf<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">/**
	 * &lt;p&gt;将给定的bean名结果与给定的父结果合并:
	 *  &lt;ol&gt;
	 *   &lt;li&gt;如果parentResult是空数组，直接返回result&lt;/li&gt;
	 *   &lt;li&gt;定义一个合并后的bean名结果集，初始化长度为result数组长度+parentResult数组长度【变量 merged】&lt;/li&gt;
	 *   &lt;li&gt;将result全部添加到merged中&lt;/li&gt;
	 *   &lt;li&gt;遍历parentResult,元素为beanName:
	 *    &lt;ol&gt;
	 *     &lt;li&gt;如果merged没包含beanName 且  hbf没包含给定beanName时,将beanName添加到merged中&lt;/li&gt;
	 *    &lt;/ol&gt;
	 *   &lt;/li&gt;
	 *   &lt;li&gt;将merged装换成数组返回出去&lt;/li&gt;
	 *  &lt;/ol&gt;
	 * &lt;/p&gt;
	 * Merge the given bean names result with the given parent result.
	 * &lt;p&gt;将给定的bean名结果与给定的父结果合并&lt;/p&gt;
	 * @param result the local bean name result -- 本地bean名结果
	 * @param parentResult the parent bean name result (possibly empty) -- 父bean名称结果(可能为空)
	 * @param hbf the local bean factory -- 本地bean工厂
	 * @return the merged result (possibly the local result as-is) -- 合并结果(可能是本地结果)
	 * @since 4.3.15
	 */</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">mergeNamesWithParent</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> result<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> parentResult<span class="token punctuation">,</span> HierarchicalBeanFactory hbf<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//如果parentResult是空数组，直接返回result</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>parentResult<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> result<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//定义一个合并后的bean名结果集，初始化长度为result数组长度+parentResult数组长度</span>
		List<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> merged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>length <span class="token operator">+</span> parentResult<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//将result全部添加到merged中</span>
		merged<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//遍历parentResult</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>String beanName <span class="token operator">:</span> parentResult<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//如果merged没包含beanName 且  hbf没包含给定beanName</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>merged<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hbf<span class="token punctuation">.</span><span class="token function">containsLocalBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//将beanName添加到merged中</span>
				merged<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//将merged装换成数组返回出去</span>
		<span class="token keyword">return</span> StringUtils<span class="token punctuation">.</span><span class="token function">toStringArray</span><span class="token punctuation">(</span>merged<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="ObjectUtilsidentityToStringautowiringValue_523"></a>ObjectUtils.identityToString(autowiringValue)</h4> 
<p>可得到(obj的全类名+’@’+obj的hashCode的十六进制字符串),如果obj为null，返回空字符串</p> 
<pre><code class="prism language-java"><span class="token comment">/**
	 * &lt;p&gt;可得到(obj的全类名+'@'+obj的hashCode的十六进制字符串),如果obj为null，返回空字符串&lt;/p&gt;
	 * Return a String representation of an object's overall identity.
	 * &lt;p&gt;返回对象整体身份的String表现形式&lt;/p&gt;
	 * @param obj the object (may be {@code null}) -- 对象（可以为{@code null}）
	 * @return the object's identity as String representation,
	 * or an empty String if the object was {@code null}
	 * 		-- 对象的身份，以String表现形式；如果对象为{@code null}则为空字符串
	 */</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">identityToString</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//如果对象为null</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//返回 空字符串</span>
			<span class="token keyword">return</span> EMPTY_STRING<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//拼接obj的全类名+'@'+obj的hashCode的十六进制字符串，然后返回出去</span>
		<span class="token keyword">return</span> obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"@"</span> <span class="token operator">+</span> <span class="token function">getIdentityHexString</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="isSelfReferencebeanName_candidate_545"></a>isSelfReference(beanName, candidate)</h4> 
<p>可以理解为beanName与candidateName所对应的Bean对象是不是同一个</p> 
<pre><code class="prism language-java"><span class="token comment">/**
	 * &lt;p&gt;可以理解为beanName与candidateName所对应的Bean对象是不是同一个&lt;/p&gt;
	 * &lt;p&gt;自引用：beanName和candidateName是否都是指向同一个Bean对象，至少beanName所指bean对象是candidateName的合并后
	 * RootBeanDefinition对象里的FactoryBean对象&lt;/p&gt;
	 * Determine whether the given beanName/candidateName pair indicates a self reference,
	 * i.e. whether the candidate points back to the original bean or to a factory method
	 * on the original bean.
	 * &lt;p&gt;确定给定beanName/candidateName Pair 是否表示自引用,即候选对象是指向原始bean
	 * 或者指向原始bean的工厂方法&lt;/p&gt;
	 */</span>
	<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isSelfReference</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> String beanName<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> String candidateName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//如果beanName和candidateName都不会null</span>
		<span class="token comment">// 且 beanName与candidateName相等 或者 (该工厂有candidateName的BeanDefinition对象 且 candidateName的合并后BeanDefinition对象的FactoryBean名与beanName相等)</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>beanName <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> candidateName <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>
				<span class="token punctuation">(</span>beanName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>candidateName<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token function">containsBeanDefinition</span><span class="token punctuation">(</span>candidateName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
						beanName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token function">getMergedLocalBeanDefinition</span><span class="token punctuation">(</span>candidateName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFactoryBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="isAutowireCandidatecandidate_descriptor_566"></a>isAutowireCandidate(candidate, descriptor)</h4> 
<blockquote> 
 <p><a href="https://blog.csdn.net/qq_30321211/article/details/108362842">Spring 5 DefaultListableBeanFactory-- isAutowireCandidate源码分析</a></p> 
</blockquote> 
<h4><a id="AutowireCandidateResolver_569"></a>AutowireCandidateResolver</h4> 
<blockquote> 
 <p><a href="https://blog.csdn.net/qq_30321211/article/details/108359093">Spring 5 AutowireCandidateResolver源码注释</a></p> 
</blockquote> 
<h4><a id="addCandidateEntryresult_candidate_descriptor_requiredType_572"></a>addCandidateEntry(result, candidate, descriptor, requiredType);</h4> 
<p>在候选映射中添加一个条目:一个bean实例(如果可用)或仅一个已解析的类型，以防止在选择主要候选对象之前太早初始化bean:</p> 
<ol><li>如果desciprtor是MultiElementDescriptor的实例【集合类型依赖】: 
  <ol><li>获取candidateName的该工厂的Bean实例【变量 beanInstance】</li><li>如果beanInstance不是NullBean实例,将candidateName和其对应的实例绑定到candidates中</li></ol> </li><li>如果beanName是在该BeanFactory的单例对象的高速缓存Map集合中 或者 (descriptor是SteamDependencyDesciptor实例【Stream类型依赖】且 该实例有排序标记): 
  <ol><li>获取candidateName的该工厂的Bean实例【变量 beanInstance】</li><li>如果beanInstance是NullBean实例,会将candidateName和null绑定到candidates中；否则将candidateName和其对应的实例绑定到candidates中</li></ol> </li><li>否则(一般就是指candidatName所对应的bean不是单例):将candidateName和其对应的Class对象绑定到candidates中</li></ol> 
<pre><code class="prism language-java"><span class="token comment">/**
	 * &lt;p&gt;
	 *  在候选映射中添加一个条目:一个bean实例(如果可用)或仅一个已解析的类型，以防止在选择主要
	 *  候选对象之前太早初始化bean:
	 * &lt;/p&gt;
	 * Add an entry to the candidate map: a bean instance if available or just the resolved
	 * type, preventing early bean initialization ahead of primary candidate selection.
	 * &lt;p&gt;在候选映射中添加一个条目:一个bean实例(如果可用)或仅一个已解析的类型，以防止在选择主要
	 * 候选对象之前太早初始化bean&lt;/p&gt;
	 */</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addCandidateEntry</span><span class="token punctuation">(</span>Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> candidates<span class="token punctuation">,</span> String candidateName<span class="token punctuation">,</span>
			DependencyDescriptor descriptor<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> requiredType<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//MultiElementDesciptor:具有嵌套元素的多元素声明的依赖描述符，表示集合/数组依赖</span>
		<span class="token comment">//如果desciprtor是MultiElementDescriptor的实例</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>descriptor <span class="token keyword">instanceof</span> <span class="token class-name">MultiElementDescriptor</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//获取candidateName的该工厂的Bean实例</span>
			Object beanInstance <span class="token operator">=</span> descriptor<span class="token punctuation">.</span><span class="token function">resolveCandidate</span><span class="token punctuation">(</span>candidateName<span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果beanInstance不是NullBean实例</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>beanInstance <span class="token keyword">instanceof</span> <span class="token class-name">NullBean</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//将candidateName和其对应的实例绑定到candidates中</span>
				candidates<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>candidateName<span class="token punctuation">,</span> beanInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//StreamDependencyDescriptor:用于访问多个元素的流依赖项描述符标记，即属性依赖是 stream类型且</span>
		<span class="token comment">//如果beanName是在该BeanFactory的单例对象的高速缓存Map集合中 或者 (descriptor是SteamDependencyDesciptor实例 且 该实例有排序标记)</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">containsSingleton</span><span class="token punctuation">(</span>candidateName<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>descriptor <span class="token keyword">instanceof</span> <span class="token class-name">StreamDependencyDescriptor</span> <span class="token operator">&amp;&amp;</span>
				<span class="token punctuation">(</span><span class="token punctuation">(</span>StreamDependencyDescriptor<span class="token punctuation">)</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOrdered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//获取candidateName的该工厂的Bean实例</span>
			Object beanInstance <span class="token operator">=</span> descriptor<span class="token punctuation">.</span><span class="token function">resolveCandidate</span><span class="token punctuation">(</span>candidateName<span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果beanInstance是NullBean实例,会将candidateName和null绑定到candidates中；否则将candidateName和其对应的实例绑定到candidates中</span>
			candidates<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>candidateName<span class="token punctuation">,</span> <span class="token punctuation">(</span>beanInstance <span class="token keyword">instanceof</span> <span class="token class-name">NullBean</span> <span class="token operator">?</span> null <span class="token operator">:</span> beanInstance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//candidateName所对应的bean不是单例</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//将candidateName和其对应的Class对象绑定到candidates中</span>
			candidates<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>candidateName<span class="token punctuation">,</span> <span class="token function">getType</span><span class="token punctuation">(</span>candidateName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="MultiElementDescriptor_621"></a>MultiElementDescriptor</h3> 
<pre><code class="prism language-java"><span class="token comment">/**
	 * A dependency descriptor for a multi-element declaration with nested elements.
	 * &lt;p&gt;具有嵌套元素的多元素声明的依赖描述符，表示集合/数组依赖&lt;/p&gt;
	 */</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MultiElementDescriptor</span> <span class="token keyword">extends</span> <span class="token class-name">NestedDependencyDescriptor</span> <span class="token punctuation">{<!-- --></span>

		<span class="token comment">/**
		 * 新建一个StreamDependencyDescriptor实例
		 * @param original 从其创建副本的原始描述符
		 */</span>
		<span class="token keyword">public</span> <span class="token function">MultiElementDescriptor</span><span class="token punctuation">(</span>DependencyDescriptor original<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//拷贝originald的属性</span>
			<span class="token keyword">super</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="descriptorresolveCandidatename_type_this_639"></a>descriptor.resolveCandidate(name, type, this))</h3> 
<p>将指定的Bean名称解析为给定工厂的Bean实例，作为对此依赖项的匹配算法的候选结果</p> 
<pre><code class="prism language-java"><span class="token comment">/**
	 * Resolve the specified bean name, as a candidate result of the matching
	 * algorithm for this dependency, to a bean instance from the given factory.
	 * &lt;p&gt;将指定的Bean名称解析为给定工厂的Bean实例，作为对此依赖项的匹配算法的候选结果&lt;/p&gt;
	 * &lt;p&gt;The default implementation calls {@link BeanFactory#getBean(String)}.
	 * Subclasses may provide additional arguments or other customizations.
	 * &lt;p&gt;默认实现调用BeanFactory.getBean(String).子类可以提供其他参数或其他自定义&lt;/p&gt;
	 * @param beanName the bean name, as a candidate result for this dependency
	 *                 -- bean名，作为此依赖项的候选结果
	 * @param requiredType the expected type of the bean (as an assertion)
	 *                     -- bean的预期类型（作为断言）
	 * @param beanFactory the associated factory -- 相关工厂
	 * @return the bean instance (never {@code null}) -- bean实例(永远不为 null)
	 * @throws BeansException if the bean could not be obtained -- 如果无法获取bean
	 * @since 4.3.2
	 * @see BeanFactory#getBean(String)
	 */</span>
	<span class="token keyword">public</span> Object <span class="token function">resolveCandidate</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> requiredType<span class="token punctuation">,</span> BeanFactory beanFactory<span class="token punctuation">)</span>
			<span class="token keyword">throws</span> BeansException <span class="token punctuation">{<!-- --></span>

		<span class="token keyword">return</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="adaptOrderComparatormatchingBeans_665"></a>adaptOrderComparator(matchingBeans)</h3> 
<p>构建排序比较器,用于对matchingBean的所有bean对象进行优先级排序</p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/qq_30321211/article/details/108363974">Spring 5 DefaultListableBeanFactory-- adaptOrderComparator源码分析</a></p> 
</blockquote> 
<h3><a id="ResolvableType_669"></a>ResolvableType</h3> 
<p>可以看作是封装JavaType的元信息类</p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/qq_30321211/article/details/108363974">Spring 5 ResolvableType 源码注释</a></p> 
</blockquote> 
<h3><a id="TypeConverter_673"></a>TypeConverter</h3> 
<p>定义类型转换方法的接口。通常(但不一定)与PropertyEditorRegistry接口一起实现。</p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/qq_30321211/article/details/108361731">Spring 5 SimpleTypeConverter 源码注释</a></p> 
</blockquote> 
<h3><a id="matchingBeanbean_677"></a>构建依赖比较器,用于对matchingBean的所有bean对象进行优先级排序</h3> 
<ol><li>获取此BeanFactory的依赖关系比较器【变量 comparator】</li><li>如果comparator是OrderComparator实例,创建工厂感知排序源提供者实例 【FactoryAwareOrderSourceProvider】并让comparator引用它,然后返回出去</li><li>返回此BeanFactory的依赖关系比较器【comparator】</li></ol> 
<pre><code class="prism language-java"><span class="token comment">/**
	 * 构建依赖比较器,用于对matchingBean的所有bean对象进行优先级排序
	 * @param matchingBeans 要排序的Bean对象Map，key=Bean名,value=Bean对象
	 * @return 依赖比较器,可能是 {@link OrderComparator} 实例
	 */</span>
	<span class="token annotation punctuation">@Nullable</span>
	<span class="token keyword">private</span> Comparator<span class="token generics function"><span class="token punctuation">&lt;</span>Object<span class="token punctuation">&gt;</span></span> <span class="token function">adaptDependencyComparator</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">&gt;</span> matchingBeans<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//获取此BeanFactory的依赖关系比较器</span>
		Comparator<span class="token generics function"><span class="token punctuation">&lt;</span>Object<span class="token punctuation">&gt;</span></span> comparator <span class="token operator">=</span> <span class="token function">getDependencyComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//如果comparator是OrderComparator实例</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>comparator <span class="token keyword">instanceof</span> <span class="token class-name">OrderComparator</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//创建工厂感知排序源提供者实例【FactoryAwareOrderSourceProvider】并让comparator引用它,然后返回出去</span>
			<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>OrderComparator<span class="token punctuation">)</span> comparator<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withSourceProvider</span><span class="token punctuation">(</span>
					<span class="token function">createFactoryAwareOrderSourceProvider</span><span class="token punctuation">(</span>matchingBeans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//返回此BeanFactory的依赖关系比较器</span>
			<span class="token keyword">return</span> comparator<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><a href="https://blog.csdn.net/qq_30321211/article/details/108363974">Spring 5 DefaultListableBeanFactory-- adaptOrderComparator源码分析</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dc90f4c1cc3f6151343e074cbbd96078/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构顺序查找中对“哨兵“理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e0e87753b94c6951be755ab32f6a54c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">hive函数大全详细解释&#43;简单运用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>