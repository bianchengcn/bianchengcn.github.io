<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python后台——asyncio，多进程&#43;asyncio - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python后台——asyncio，多进程&#43;asyncio" />
<meta property="og:description" content="全栈工程师开发手册 （作者：栾鹏）
架构系列文章
注意: python的异步返回有时是通过异常expection向上冒泡的, 在异步函数中使用try catch有时无法捕获某些异常的, 异常会作为返回结果直接返回给上一层
很多朋友对异步编程都处于“听说很强大”的认知状态。鲜有在生产项目中使用它。而使用它的同学，则大多数都停留在知道如何使用 Tornado、Twisted、Gevent 这类异步框架上，出现各种古怪的问题难以解决。而且使用了异步框架的部分同学，由于用法不对，感觉它并没牛逼到哪里去，所以很多同学做 Web 后端服务时还是采用 Flask、Django等传统的非异步框架。
从上两届 PyCon 技术大会看来，异步编程已经成了 Python 生态下一阶段的主旋律。如新兴的 Go、Rust、Elixir 等编程语言都将其支持异步和高并发作为主要“卖点”，技术变化趋势如此。Python 生态为不落人后，从2013年起由 Python 之父 Guido 亲自操刀主持了Tulip(asyncio)项目的开发。
异步io的好处在于避免的线程的开销和切换，而且我们都知道python其实是没有多线程的，只是通过底层线层锁实现的多线程。另一个好处在于避免io操作（包含网络传输）的堵塞时间。
asyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把asyncio用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程&#43;coroutine实现多用户的高并发支持。
asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。
对于异步io你需要知道的重点，要注意的是，await语法只能出现在通过async修饰的函数中，否则会报SyntaxError错误。而且await后面的对象需要是一个Awaitable，或者实现了相关的协议。
注意：
所有需要异步执行的函数，都需要asyncio中的轮训器去轮训执行，如果函数阻塞，轮训器就会去执行下一个函数。所以所有需要异步执行的函数都需要加入到这个轮训器中。
asyncio demo：
import requests import time import asyncio # 创建一个异步函数 async def task_func(): await asyncio.sleep(1) resp = requests.get(&#39;http://192.168.2.177:5002/&#39;) print(&#39;2222222&#39;,time.time(),resp.text) async def main(loop): loop=asyncio.get_event_loop() # 获取全局轮训器 task = loop.create_task(task_func()) # 在全局轮训器加入协成，只有加入全局轮训器才能被监督执行 await asyncio.sleep(2) # 等待两秒为了不要立即执行event_loop.close()，项目中event_loop应该是永不停歇的 print(&#39;11111111111&#39;,time.time()) event_loop = asyncio." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/4b0373c0a260b34117f3b6bd361d7ceb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-27T16:47:54+08:00" />
<meta property="article:modified_time" content="2022-03-27T16:47:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python后台——asyncio，多进程&#43;asyncio</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <a href="http://39.105.187.122/csdn" rel="nofollow"> <img border="0" src="https://images2.imgbox.com/08/02/6Au79WDL_o.jpg"> </a> 
<blockquote> 
 <p><strong>全栈工程师开发手册 （作者：栾鹏）</strong><br> <strong><a href="https://blog.csdn.net/luanpeng825485697/article/details/83830968"> 架构系列文章</a></strong></p> 
</blockquote> 
<p><strong>注意: python的异步返回有时是通过异常expection向上冒泡的, 在异步函数中使用try catch有时无法捕获某些异常的, 异常会作为返回结果直接返回给上一层</strong></p> 
<p>很多朋友对异步编程都处于“听说很强大”的认知状态。鲜有在生产项目中使用它。而使用它的同学，则大多数都停留在知道如何使用 Tornado、Twisted、Gevent 这类异步框架上，出现各种古怪的问题难以解决。而且使用了异步框架的部分同学，由于用法不对，感觉它并没牛逼到哪里去，所以很多同学做 Web 后端服务时还是采用 Flask、Django等传统的非异步框架。</p> 
<p>从上两届 PyCon 技术大会看来，异步编程已经成了 Python 生态下一阶段的主旋律。如新兴的 Go、Rust、Elixir 等编程语言都将其支持异步和高并发作为主要“卖点”，技术变化趋势如此。Python 生态为不落人后，从2013年起由 Python 之父 Guido 亲自操刀主持了Tulip(asyncio)项目的开发。</p> 
<p>异步io的好处在于避免的线程的开销和切换，而且我们都知道python其实是没有多线程的，只是通过底层线层锁实现的多线程。另一个好处在于避免io操作（包含网络传输）的堵塞时间。</p> 
<p>asyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把asyncio用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发支持。</p> 
<p>asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。</p> 
<blockquote> 
 <p>对于异步io你需要知道的重点，要注意的是，await语法只能出现在通过async修饰的函数中，否则会报SyntaxError错误。而且await后面的对象需要是一个Awaitable，或者实现了相关的协议。</p> 
</blockquote> 
<p>注意：</p> 
<blockquote> 
 <p>所有需要异步执行的函数，都需要asyncio中的轮训器去轮训执行，如果函数阻塞，轮训器就会去执行下一个函数。所以所有需要异步执行的函数都需要加入到这个轮训器中。</p> 
</blockquote> 
<h2><a id="asyncio_29"></a>asyncio</h2> 
<p>demo：</p> 
<pre><code>import requests
import time
import asyncio

# 创建一个异步函数
async def task_func():
    await asyncio.sleep(1)
    resp = requests.get('http://192.168.2.177:5002/')
    print('2222222',time.time(),resp.text)


async def main(loop):
    loop=asyncio.get_event_loop()   # 获取全局轮训器
    task = loop.create_task(task_func())  # 在全局轮训器加入协成，只有加入全局轮训器才能被监督执行
    await asyncio.sleep(2)   # 等待两秒为了不要立即执行event_loop.close()，项目中event_loop应该是永不停歇的
    print('11111111111',time.time())


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main(event_loop))
finally:
    event_loop.close()    # 当轮训器关闭以后，所有没有执行完成的协成将全部关闭
</code></pre> 
<p>所谓「异步 IO」，就是你发起一个 IO 操作，却不用等它结束，你可以继续做其他事情，当它结束时，你会得到通知。</p> 
<p>Asyncio 是并发（concurrency）的一种方式。对 Python 来说，并发还可以通过线程（threading）和多进程（multiprocessing）来实现。</p> 
<p>Asyncio 并不能带来真正的并行（parallelism）。当然，因为 GIL（全局解释器锁）的存在，Python 的多线程也不能带来真正的并行。</p> 
<p>可交给 asyncio 执行的任务，称为协程（coroutine）。一个协程可以放弃执行，把机会让给其它协程（即 <code>yield from</code> 或 <code>await</code>）。`</p> 
<h3><a id="_68"></a>定义协程</h3> 
<p>协程的定义，需要使用 <code>async def</code> 语句。</p> 
<pre><code>async def do_some_work(x): pass
</code></pre> 
<p><code>do_some_work</code> 便是一个协程。<br> 准确来说，<code>do_some_work</code> 是一个协程函数，可以通过 <code>asyncio.iscoroutinefunction</code> 来验证：</p> 
<pre><code>print(asyncio.iscoroutinefunction(do_some_work))  # True
</code></pre> 
<p>这个协程什么都没做，我们让它睡眠几秒，以模拟实际的工作量 ：</p> 
<pre><code>async def do_some_work(x):
    print("Waiting " + str(x))
    await asyncio.sleep(x)
</code></pre> 
<p>在解释 <code>await</code> 之前，有必要说明一下协程可以做哪些事。协程可以：</p> 
<ul><li>等待一个 future 结束</li><li>等待另一个协程（产生一个结果，或引发一个异常）</li><li>产生一个结果给正在等它的协程</li><li>引发一个异常给正在等它的协程</li></ul> 
<p><code>asyncio.sleep</code> 也是一个协程，所以 <code>await asyncio.sleep(x)</code> 就是等待另一个协程。可参见 <code>asyncio.sleep</code> 的文档：</p> 
<pre><code>sleep(delay, result=None, *, loop=None)
Coroutine that completes after a given time (in seconds).
</code></pre> 
<h3><a id="_118"></a>运行协程</h3> 
<p>调用协程函数，协程并不会开始运行，只是返回一个协程对象，可以通过 <code>asyncio.iscoroutine</code> 来验证：</p> 
<pre><code>print(asyncio.iscoroutine(do_some_work(3)))  # True
</code></pre> 
<p>此处还会引发一条警告：</p> 
<pre><code>async1.py:16: RuntimeWarning: coroutine 'do_some_work' was never awaited
  print(asyncio.iscoroutine(do_some_work(3)))
</code></pre> 
<p>要让这个协程对象运行的话，有两种方式：</p> 
<ul><li>在另一个已经运行的协程中用 <code>await</code> 等待它</li><li>通过 <code>ensure_future</code> 函数计划它的执行</li></ul> 
<p>简单来说，只有 loop 运行了，协程才可能运行。<br> 下面先拿到当前线程缺省的 loop ，然后把协程对象交给 <code>loop.run_until_complete</code>，协程对象随后会在 loop 里得到运行。</p> 
<pre><code>loop = asyncio.get_event_loop()
loop.run_until_complete(do_some_work(3))
</code></pre> 
<p><code>run_until_complete</code> 是一个阻塞（blocking）调用，直到协程运行结束，它才返回。这一点从函数名不难看出。<br> <code>run_until_complete</code> 的参数是一个 future，但是我们这里传给它的却是协程对象，之所以能这样，是因为它在内部做了检查，通过 <code>ensure_future</code> 函数把协程对象包装（wrap）成了 future。所以，我们可以写得更明显一些：</p> 
<pre><code>loop.run_until_complete(asyncio.ensure_future(do_some_work(3)))
</code></pre> 
<p>完整代码：</p> 
<pre><code>import asyncio

async def do_some_work(x):
    print("Waiting " + str(x))
    await asyncio.sleep(x)

loop = asyncio.get_event_loop()
loop.run_until_complete(do_some_work(3))
</code></pre> 
<p>运行结果：</p> 
<pre><code>Waiting 3
&lt;三秒钟后程序结束&gt;
</code></pre> 
<h3><a id="_189"></a>回调</h3> 
<p>假如协程是一个 IO 的读操作，等它读完数据后，我们希望得到通知，以便下一步数据的处理。这一需求可以通过往 future 添加回调来实现。</p> 
<pre><code>def done_callback(futu):
    print('Done')

futu = asyncio.ensure_future(do_some_work(3))
futu.add_done_callback(done_callback)

loop.run_until_complete(futu)
</code></pre> 
<h3><a id="_206"></a>多个协程</h3> 
<p>实际项目中，往往有多个协程，同时在一个 loop 里运行。为了把多个协程交给 loop，需要借助 <code>asyncio.gather</code> 函数。</p> 
<pre><code>loop.run_until_complete(asyncio.gather(do_some_work(1), do_some_work(3)))
</code></pre> 
<p>或者先把协程存在列表里：</p> 
<pre><code>coros = [do_some_work(1), do_some_work(3)]
loop.run_until_complete(asyncio.gather(*coros))
</code></pre> 
<p>运行结果：</p> 
<pre><code>Waiting 3
Waiting 1
&lt;等待三秒钟&gt;
Done
</code></pre> 
<p>这两个协程是并发运行的，所以等待的时间不是1 + 3 = 4 秒，而是以耗时较长的那个协程为准。</p> 
<p>参考函数 <code>gather</code> 的文档：</p> 
<pre><code>gather(*coros_or_futures, loop=None, return_exceptions=False)
	Return 各协程协成的合并结果

</code></pre> 
<p>发现也可以传futures给它：</p> 
<pre><code>futus = [asyncio.ensure_future(do_some_work(1)),
             asyncio.ensure_future(do_some_work(3))]

loop.run_until_complete(asyncio.gather(*futus))

如果进程中已经有了loop,   则可以直接等待这几个异步的结果
results = await asyncio.gather(*futus)
返回结果results是一个列表,每个元素是每个异步的返回内容
print(str(results))
</code></pre> 
<p><code>gather</code> 起聚合的作用，把多个 futures 包装成单个 future，因为 <code>loop.run_until_complete</code> 只接受单个 future。</p> 
<h3><a id="run_until_complete__run_forever_265"></a>run_until_complete 和 run_forever</h3> 
<p>我们一直通过 <code>run_until_complete</code> 来运行 loop ，等到 future 完成，<code>run_until_complete</code> 也就返回了。</p> 
<pre><code>async def do_some_work(x):
    print('Waiting ' + str(x))
    await asyncio.sleep(x)
    print('Done')

loop = asyncio.get_event_loop()

coro = do_some_work(3)
loop.run_until_complete(coro)
</code></pre> 
<p>输出：</p> 
<pre><code>Waiting 3
&lt;等待三秒钟&gt;
Done
&lt;程序退出&gt;
</code></pre> 
<p>现在改用 <code>run_forever</code>：</p> 
<pre><code>async def do_some_work(x):
    print('Waiting ' + str(x))
    await asyncio.sleep(x)
    print('Done')

loop = asyncio.get_event_loop()

coro = do_some_work(3)
asyncio.ensure_future(coro)

loop.run_forever()
</code></pre> 
<p>输出：</p> 
<pre><code>Waiting 3
&lt;等待三秒钟&gt;
Done
&lt;程序没有退出&gt;
</code></pre> 
<p>三秒钟过后，future 结束，但是程序并不会退出。<code>run_forever</code> 会一直运行，直到 <code>stop</code> 被调用，但是你不能像下面这样调 <code>stop</code>：</p> 
<pre><code>loop.run_forever()
loop.stop()
</code></pre> 
<p><code>run_forever</code> 不返回，<code>stop</code> 永远也不会被调用。所以，只能在协程中调 <code>stop</code>：</p> 
<pre><code>async def do_some_work(loop, x):
    print('Waiting ' + str(x))
    await asyncio.sleep(x)
    print('Done')
    loop.stop()
</code></pre> 
<p>这样并非没有问题，假如有多个协程在 loop 里运行：</p> 
<pre><code>asyncio.ensure_future(do_some_work(loop, 1))
asyncio.ensure_future(do_some_work(loop, 3))

loop.run_forever()
</code></pre> 
<p>第二个协程没结束，loop 就停止了——被先结束的那个协程给停掉的。<br> 要解决这个问题，可以用 <code>gather</code> 把多个协程合并成一个 future，并添加回调，然后在回调里再去停止 loop。</p> 
<pre><code>async def do_some_work(loop, x):
    print('Waiting ' + str(x))
    await asyncio.sleep(x)
    print('Done')

def done_callback(loop, futu):
    loop.stop()

loop = asyncio.get_event_loop()

futus = asyncio.gather(do_some_work(loop, 1), do_some_work(loop, 3))
futus.add_done_callback(functools.partial(done_callback, loop))

loop.run_forever()
</code></pre> 
<p>其实这基本上就是 <code>run_until_complete</code> 的实现了，<code>run_until_complete</code> 在内部也是调用 <code>run_forever</code>。</p> 
<h3><a id="Close_Loop_380"></a>Close Loop?</h3> 
<p>以上示例都没有调用 <code>loop.close</code>，好像也没有什么问题。所以到底要不要调 <code>loop.close</code> 呢？<br> 简单来说，loop 只要不关闭，就还可以再运行。：</p> 
<pre><code>loop.run_until_complete(do_some_work(loop, 1))
loop.run_until_complete(do_some_work(loop, 3))
loop.close()
</code></pre> 
<p>但是如果关闭了，就不能再运行了：</p> 
<pre><code>loop.run_until_complete(do_some_work(loop, 1))
loop.close()
loop.run_until_complete(do_some_work(loop, 3))  # 此处异常
</code></pre> 
<p>建议调用 <code>loop.close</code>，以彻底清理 loop 对象防止误用。</p> 
<h3><a id="gather_vs_wait_406"></a>gather vs. wait</h3> 
<p><code>asyncio.gather</code> 和 <code>asyncio.wait</code> 功能相似。</p> 
<pre><code>coros = [do_some_work(loop, 1), do_some_work(loop, 3)]
loop.run_until_complete(asyncio.wait(coros))
</code></pre> 
<p>具体差别可请参见 StackOverflow 的讨论：<a href="http://stackoverflow.com/questions/42231161/asyncio-gather-vs-asyncio-wait" rel="nofollow">Asyncio.gather vs asyncio.wait</a>。</p> 
<h3><a id="Timer_420"></a>Timer</h3> 
<p>C++ Boost.Asio 提供了 IO 对象 timer，但是 Python 并没有原生支持 timer，不过可以用 <code>asyncio.sleep</code> 模拟。</p> 
<pre><code>async def timer(x, cb):
    futu = asyncio.ensure_future(asyncio.sleep(x))
    futu.add_done_callback(cb)
    await futu

t = timer(3, lambda futu: print('Done'))
loop.run_until_complete(t)
</code></pre> 
<h2><a id="_435"></a>将阻塞操作定义为协成</h2> 
<p>在协成中，如果有一个操作阻塞了，会影响其他的一串协成组中的其他协成，我们可以把容易产生阻塞的协成定义为可调出协成</p> 
<p>例如：</p> 
<pre><code>import asyncio
import requests
import time,datetime


def my_fun():
    time.sleep(4)
    return datetime.datetime.now()

async def fetch_async(func, *args):
    print('begin')
    loop = asyncio.get_event_loop()
    future = loop.run_in_executor(None, func, *args)
    result = await future
    return result

tasks = [
    fetch_async(my_fun),
    fetch_async(my_fun)
]

loop = asyncio.get_event_loop()
results = loop.run_until_complete(asyncio.gather(*tasks))
print(results)
loop.close()

</code></pre> 
<p>这两个time.sleep相互不影响</p> 
<h2><a id="asyncio_472"></a>多进程+asyncio</h2> 
<p>由于python本身只能单线程，所以所谓的线程是通过线程锁实现的。现在必须要通过多进程实现更多的并发。</p> 
<p>现在demo实现了使用多进程，每个进程都有一个asyncio</p> 
<pre><code>import asyncio
import threading
import multiprocessing
from multiprocessing import Queue ,Pool,Process
#import aiohttp
import os

async def hello(name):
    print('hello {}   {}**********{}'.format(name,os.getpid(),threading.current_thread()))
    #await asyncio.sleep(int(name))
    await asyncio.sleep(1)
    print('end:{}  {}'.format(name,os.getpid()))


def process_start(*namelist):
    tasks=[]
    loop=asyncio.get_event_loop()
    for name in namelist:
        tasks.append(asyncio.ensure_future(hello(name)))
    loop.run_until_complete(asyncio.wait(tasks))

def task_start(namelist):
    i=0
    lst=[]
    flag=10
    while namelist:
        i+=1
        l=namelist.pop()
        lst.append(l)
        if i==flag:
            p=Process(target=process_start,args=lst)
            p.start()
            #p.join()
            lst=[]
            i=0
    if namelist!=[]:
        p=Process(target=process_start,args=lst)
        p.start()
        #p.join()

if __name__=='__main__':
    # 测试使用多个进程来实现函数
    namelist=list('0123456789'*10)
    print(namelist)
    task_start(namelist)

# 测试使用一个异步io来实现全部函数
# loop=asyncio.get_event_loop()
# tasks=[]
# namelist=list('0123456789'*10)
# for i in namelist:
#     tasks.append(asyncio.ensure_future(hello(i)))
# loop.run_until_complete(asyncio.wait(tasks))

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27f83cd4f4b2e5bcbd6f402a446bae5b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">详解僵尸进程与孤儿进程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b5474fc332dc3393dae5d3d3199a136c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">github上传大文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>