<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>什么是列存储？一文秒懂 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="什么是列存储？一文秒懂" />
<meta property="og:description" content="导读：在讲《Apache Druid 底层存储设计》时就说过要讲一讲列式存储。现在来了，通过本文你可以了解到行存储模式、列存储模式、它们的优缺点以及列存储模式的优化等知识。
今日格言：不要局限于单向思维，多对比了解更多不同维度的东西。
从数据存储讲起 我们最先接触的数据库系统，大部分都是行存储系统。大学的时候学数据库，老师让我们将数据库想象成一张表格，每条数据记录就是一行数据，每行数据包含若干列。所以我们对大部分数据存储的思维也就是一个复杂一点的表格管理系统。我们在一行一行地写入数据，然后按查询条件查询过滤出我们想要的行记录。
大部分传统的关系型数据库，都是面向行来组织数据的。如 Mysql，Postgresql。近几年，也越来越多传统数据库加入了列存储的能力。虽然列存储的技术在十几年前就已经出现，却从来没有像现在这样成为一种流行的存储组织方式。
行存储和列存储，是数据库底层组织数据的方式。（和文档型、K-V 型，时序型等概念不在一个层次）
行存储 行存储系统以行的方式来组织数据。假设现在有以下 blog 数据(大学时老师布置系统课题作业总是让我们做一个博客系统，大概因为他们最先接触的互联网就是 BBS 吧)：
[ { &#34;title&#34;: &#34;Oriented Column Store&#34;, &#34;author&#34;: &#34;Alex&#34;, &#34;publish_time&#34;: 1508423456, &#34;like_num&#34;: 1024 },{ &#34;title&#34;: &#34;Apache Druid&#34;, &#34;author&#34;: &#34;Bob&#34;, &#34;publish_time&#34;: 1504423069, &#34;like_num&#34;: 10 },{ &#34;title&#34;: &#34;Algorithm&#34;, &#34;author&#34;: &#34;Casey&#34;, &#34;publish_time&#34;: 1512523069, &#34;like_num&#34;: 16 } ] 行存储将会以下列方式将数据存储在磁盘上。我们可以思考一下，这样的方式利于什么样的存储？（此处停顿 5 秒思考一下）它利于数据一行一行的写入，写入一条数据记录时，只需要将数据追加到已有数据记录后面即可。
行模式存储适合 OLTP(Online Transaction Processing)系统。因为数据基于行存储，所以数据的写入会更快。对按记录查询数据也更简单。
大部分同学会问，我们的做的系统不就是在为了这个吗？所以我为什么还需要列式存储，而列式存储又是什么？
让我们想象一种场景，现在不是想查询 Bob 的博客，我想统计 Bob 发表的博客数，或是整个系统今天的博客点赞数。如果是行存储系统，数据库将怎样操作？（停顿思考 10 秒）
如图，想统计所有点赞数，首先需要将所有行数据读入内存，然后对 like_num 列做 sum 操作，从而得到结果。我们假设磁盘一次可以读取图中 3 个方框的数据(实际需要按 byte 来读取)，那么这个聚合计算需要 N(N=数据量)次磁盘访问。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/90938dd225aeba2531e18bd68bdb1645/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-09T10:50:00+08:00" />
<meta property="article:modified_time" content="2020-04-09T10:50:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">什么是列存储？一文秒懂</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>导读：在讲《Apache Druid 底层存储设计》时就说过要讲一讲列式存储。现在来了，通过本文你可以了解到行存储模式、列存储模式、它们的优缺点以及列存储模式的优化等知识。</p> 
</blockquote> 
<blockquote> 
 <p>今日格言：不要局限于单向思维，多对比了解更多不同维度的东西。</p> 
</blockquote> 
<h3><a id="_4"></a>从数据存储讲起</h3> 
<p>我们最先接触的数据库系统，大部分都是行存储系统。大学的时候学数据库，老师让我们将数据库想象成一张表格，每条数据记录就是一行数据，每行数据包含若干列。所以我们对大部分数据存储的思维也就是一个复杂一点的表格管理系统。我们在一行一行地写入数据，然后按查询条件查询过滤出我们想要的行记录。</p> 
<p>大部分传统的关系型数据库，都是面向行来组织数据的。如 Mysql，Postgresql。近几年，也越来越多传统数据库加入了列存储的能力。虽然列存储的技术在十几年前就已经出现，却从来没有像现在这样成为一种流行的存储组织方式。</p> 
<p>行存储和列存储，是数据库底层组织数据的方式。（和文档型、K-V 型，时序型等概念不在一个层次）</p> 
<h3><a id="_12"></a>行存储</h3> 
<p>行存储系统<strong>以行的方式来组织数据</strong>。假设现在有以下 blog 数据(大学时老师布置系统课题作业总是让我们做一个博客系统，大概因为他们最先接触的互联网就是 BBS 吧)：</p> 
<pre><code class="prism language-json"><span class="token punctuation">[</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"Oriented Column Store"</span><span class="token punctuation">,</span>
    <span class="token string">"author"</span><span class="token punctuation">:</span> <span class="token string">"Alex"</span><span class="token punctuation">,</span>
    <span class="token string">"publish_time"</span><span class="token punctuation">:</span> <span class="token number">1508423456</span><span class="token punctuation">,</span>
    <span class="token string">"like_num"</span><span class="token punctuation">:</span> <span class="token number">1024</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span>
    <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"Apache Druid"</span><span class="token punctuation">,</span>
    <span class="token string">"author"</span><span class="token punctuation">:</span> <span class="token string">"Bob"</span><span class="token punctuation">,</span>
    <span class="token string">"publish_time"</span><span class="token punctuation">:</span> <span class="token number">1504423069</span><span class="token punctuation">,</span>
    <span class="token string">"like_num"</span><span class="token punctuation">:</span> <span class="token number">10</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span>
    <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"Algorithm"</span><span class="token punctuation">,</span>
    <span class="token string">"author"</span><span class="token punctuation">:</span> <span class="token string">"Casey"</span><span class="token punctuation">,</span>
    <span class="token string">"publish_time"</span><span class="token punctuation">:</span> <span class="token number">1512523069</span><span class="token punctuation">,</span>
    <span class="token string">"like_num"</span><span class="token punctuation">:</span> <span class="token number">16</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0f/8d/hmsqBn3t_o.png" alt=""></p> 
<p>行存储将会以下列方式将数据存储在磁盘上。我们可以思考一下，这样的方式利于什么样的存储？（<strong>此处停顿 5 秒思考一下</strong>）它利于数据一行一行的写入，写入一条数据记录时，只需要将数据追加到已有数据记录后面即可。</p> 
<p>行模式存储适合 OLTP(Online Transaction Processing)系统。因为数据基于行存储，所以数据的写入会更快。对按记录查询数据也更简单。</p> 
<p>大部分同学会问，我们的做的系统不就是在为了这个吗？所以我为什么还需要列式存储，而列式存储又是什么？</p> 
<p>让我们想象一种场景，现在不是想查询 Bob 的博客，我想统计 Bob 发表的博客数，或是整个系统今天的博客点赞数。如果是行存储系统，数据库将怎样操作？（<strong>停顿思考 10 秒</strong>）</p> 
<p><img src="https://images2.imgbox.com/75/b7/yvsxzRap_o.png" alt=""></p> 
<p>如图，想统计所有点赞数，首先需要将所有行数据读入内存，然后对 like_num 列做 sum 操作，从而得到结果。我们假设磁盘一次可以读取图中 3 个方框的数据(实际需要按 byte 来读取)，那么这个聚合计算需要 N(N=数据量)次磁盘访问。</p> 
<p>这种经常需要通过大量数据集来聚合统计数据的需求其实是 OLAP 系统的常见行为。基于这个需求我们也可以明白为什么这几年列式存储开始流行。因为数据，大数据，数据分析，也就是 OLAP(Online Analytical Processing)在线分析系统的需求增多了，数据写入的事务和按记录查询数据都不是它的关注点，它关注的是数据过滤，统计。</p> 
<h3><a id="_53"></a>列存储</h3> 
<p>同样是上面的示例数据，我们来看列式存储是怎样组织数据的。</p> 
<pre><code class="prism language-json"><span class="token punctuation">[</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"Oriented Column Store"</span><span class="token punctuation">,</span>
    <span class="token string">"author"</span><span class="token punctuation">:</span> <span class="token string">"Alex"</span><span class="token punctuation">,</span>
    <span class="token string">"publish_time"</span><span class="token punctuation">:</span> <span class="token number">1508423456</span><span class="token punctuation">,</span>
    <span class="token string">"like_num"</span><span class="token punctuation">:</span> <span class="token number">1024</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span>
    <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"Apache Druid"</span><span class="token punctuation">,</span>
    <span class="token string">"author"</span><span class="token punctuation">:</span> <span class="token string">"Bob"</span><span class="token punctuation">,</span>
    <span class="token string">"publish_time"</span><span class="token punctuation">:</span> <span class="token number">1504423069</span><span class="token punctuation">,</span>
    <span class="token string">"like_num"</span><span class="token punctuation">:</span> <span class="token number">10</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span>
    <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"Algorithm"</span><span class="token punctuation">,</span>
    <span class="token string">"author"</span><span class="token punctuation">:</span> <span class="token string">"Casey"</span><span class="token punctuation">,</span>
    <span class="token string">"publish_time"</span><span class="token punctuation">:</span> <span class="token number">1512523069</span><span class="token punctuation">,</span>
    <span class="token string">"like_num"</span><span class="token punctuation">:</span> <span class="token number">16</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d8/ed/BQ09GHxf_o.png" alt=""></p> 
<p>如图所示，列式存储将每一列的数据组织在一起。可以思考一下这样利于什么呢？（<strong>停顿 5 秒</strong>）</p> 
<p>是的，利于对于列的操作，如上面我们说到的统计所有 like_num 之和。其过程将如下：</p> 
<p><img src="https://images2.imgbox.com/20/3e/o0adMbVi_o.png" alt=""></p> 
<p>依然假设磁盘一次可以读取 3 个方框的数据(实际按 byte 读取)。可以看出按列存储组织数据的方式，只需要 1 次磁盘操作就可以完成。</p> 
<p>在程序的世界里，我们学会了，任何的选择和倾向都是有代价的。空间换时间，时间换空间，一致性可用性相互平衡等。选择列式存储必然也有不利的一面。首先就表现在数据写入上。</p> 
<p><img src="https://images2.imgbox.com/ad/65/af7HmOzo_o.png" alt=""></p> 
<p>当一条新数据到来，需要将每一列存储到对应的位置。这样就需要多次写磁盘操作。（当然真实的数据库不会出现图中”挤一挤“、”挪一挪“的情况，数据库会将不同列数据组织在不同的地方；对于多次写操作的问题，大部分存储系统会通过缓冲来降低这种情况带来的不足）</p> 
<h3><a id="_94"></a>对比</h3> 
<table><thead><tr><th align="left">Row-Store</th><th align="left">Column-Store</th></tr></thead><tbody><tr><td align="left">因为按一行一行写和读取数据，因此读取数据时往往需要读取那些不必要的列</td><td align="left">可以只读取必要的列</td></tr><tr><td align="left">易于按记录读写数据</td><td align="left">对一个一个记录的数据写入和读取都较慢</td></tr><tr><td align="left">适合 OLTP 系统</td><td align="left">适合 OLAP 系统</td></tr><tr><td align="left">不利于大数据集的聚合统计操作</td><td align="left">利于大数据集的数据聚合操作</td></tr><tr><td align="left">不利于压缩数据</td><td align="left">利于压缩数据</td></tr></tbody></table> 
<h3><a id="_104"></a>列存储优势</h3> 
<p>基于列模式的存储，天然就会具备以下几个优点：</p> 
<ul><li> <p>自动索引</p> <p>因为基于列存储，所以每一列本身就相当于索引。所以在做一些需要索引的操作时，就不需要额外的数据结构来为此列创建合适的索引。</p> </li><li> <p>利于数据压缩</p> <p>利于压缩有两个原因。一来你会发现大部分列数据基数其实是重复的，拿上面的数据来说，因为同一个 author 会发表多篇博客，所以 author 列出现的所有值的基数肯定是小于博客数量的，因此在 author 列的存储上其实是不需要存储博客数量这么大的数据量的；二来相同的列数据类型一致，这样利于数据结构填充的优化和压缩，而且对于数字列这种数据类型可以采取更多有利的算法去压缩存储。</p> </li></ul> 
<h3><a id="_116"></a>最后</h3> 
<p>目前列存储模式在很多分析型数据库中都很常见。而且因为大数据分析型需求的增多，越来越多传统的行存储数据库也加入了列存储的模式，比如 Oracle 和 Sql Server 都有了列存储的特性。</p> 
<p>之前讲的 Apache Druid 底层数据存储就是基于列模式。有兴趣的可以回顾一下。另外 HBase 是一个比较有代表性的列存储模式数据库。有时间可以来聊一聊 HBase 底层是如何存储数据的。也可以讲一讲数字列的压缩方式（大家也可以先思考一下可以如何压缩数字列）。</p> 
<p><strong>系列文章：</strong></p> 
<p><a href="https://mp.weixin.qq.com/s/9ckUy3Lz9GHTNPauNlpV0w" rel="nofollow">时间序列数据库(TSDB)初识与选择</a><br> <a href="https://mp.weixin.qq.com/s/dGBfQdmD7niW32BXWb2B0g" rel="nofollow">十分钟了解 Apache Druid</a><br> <a href="http://mp.weixin.qq.com/s?__biz=MzU3NDkwMjAyOQ==&amp;mid=2247483996&amp;idx=1&amp;sn=23ce4763ce44d6813e434196a53daf4f&amp;chksm=fd2a183eca5d9128f016009ee838725c51700d718bc75a4129d8ebb3bd113745d997d6b451aa#rd" rel="nofollow">Apache Druid 底层存储设计</a><br> <a href="http://mp.weixin.qq.com/s?__biz=MzU3NDkwMjAyOQ==&amp;mid=2247483941&amp;idx=1&amp;sn=a73b5c703b6a257c179bab0fa07683a4&amp;chksm=fd2a1847ca5d9151024be79c5fdbbe5b8bd6f36f82453d04571c9d7f41eb87e08cbbbee32aec#rd" rel="nofollow">Apache Druid 的集群设计与工作流程</a></p> 
<p><strong>参考文章：</strong></p> 
<p>https://towardsdatascience.com/the-beauty-of-column-oriented-data-2945c0c9f560<br> https://dataschool.com/data-modeling-101/row-vs-column-oriented-databases/</p> 
<blockquote> 
 <p>想了解更多数据存储相关知识，请关注我的公众号。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/20/1a/fQl3HOoW_o.png" alt="MageByte"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1779a278228c33d8909460fe7b74c235/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Stm32 中RTC秒中断的使用方法及例子</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/74e3956f01b1b41f3caedb452e2b2848/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CMake Error at /usr/src/gmock/CMakeLists.txt:51 (add_subdirectory):   add_subdirectory given source</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>