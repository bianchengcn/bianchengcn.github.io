<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>nodeJs--fs模块 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="nodeJs--fs模块" />
<meta property="og:description" content="文章目录 一、fs模块是什么二、常用方法fs.read和fs.readFile方法的比较fs.writeFilefs.statfs.mkdirfs.appendFilefs.readdirfs.renamefs.rmdirfs.unlinkfs.copyFile 一、fs模块是什么 跟http模块一样，fs模块也是node的核心模块之一，主要用于对系统文件及目录进行读写操作。
二、常用方法 操作方法打开文件fs.open(path, flags[, mode], callback)文件信息fs.stat(path[, options], callback)新建文件fs.appendFile(path, data[, options], callback)写入文件fs.writeFile(file, data[, options], callback)读取文件fs.read(fd, buffer, offset, length, position, callback)读取文件fs.readFile(path[, options], callback)重命名文件fs.rename(oldPath, newPath, callback)关闭文件fs.close(fd, callback)截取文件fs.ftruncate(fd[, len], callback)删除文件fs.unlink(path, callback)文件存在fs.stat() / fs.access()监听文件fs.watchFile(filename[, options], listener)停止监听fs.unwatchFile(filename[, listener])打开大文件fs.createReadStream(path[, options])写入大文件fs.createWriteStream(path[, options])创建目录fs.mkdir(path[, options], callback)读取目录fs.readdir(path[, options], callback)删除目录fs.rmdir(path, callback) fs.read和fs.readFile方法的比较 fs.read()读取文件数据
语法格式：
fs.read(fd, buffer, offset, length, position, callback)
从文件描述符fd中读取文件数据。
fd - 通过 fs.open() 方法返回的文件描述符。
buffer - 数据写入的缓冲区。
offset - 缓冲区写入的写入偏移量。
length - 要从文件中读取的字节数。
position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8d18f1706ddbb68d9e3f7617e471c8d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-29T23:43:13+08:00" />
<meta property="article:modified_time" content="2022-07-29T23:43:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">nodeJs--fs模块</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#fs_5" rel="nofollow">一、fs模块是什么</a></li><li><a href="#_7" rel="nofollow">二、常用方法</a></li><li><ul><li><a href="#fsreadfsreadFile_29" rel="nofollow">fs.read和fs.readFile方法的比较</a></li><li><a href="#fswriteFile_92" rel="nofollow">fs.writeFile</a></li><li><a href="#fsstat_111" rel="nofollow">fs.stat</a></li><li><a href="#fsmkdir_126" rel="nofollow">fs.mkdir</a></li><li><a href="#fsappendFile_141" rel="nofollow">fs.appendFile</a></li><li><a href="#fsreaddir_157" rel="nofollow">fs.readdir</a></li><li><a href="#fsrename_170" rel="nofollow">fs.rename</a></li><li><a href="#fsrmdir_190" rel="nofollow">fs.rmdir</a></li><li><a href="#fsunlink_203" rel="nofollow">fs.unlink</a></li><li><a href="#fscopyFile_216" rel="nofollow">fs.copyFile</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="fs_5"></a>一、fs模块是什么</h2> 
<p>跟http模块一样，fs模块也是node的核心模块之一，主要用于对系统文件及目录进行读写操作。</p> 
<h2><a id="_7"></a>二、常用方法</h2> 
<table><thead><tr><th>操作</th><th>方法</th></tr></thead><tbody><tr><td>打开文件</td><td>fs.open(path, flags[, mode], callback)</td></tr><tr><td>文件信息</td><td>fs.stat(path[, options], callback)</td></tr><tr><td>新建文件</td><td>fs.appendFile(path, data[, options], callback)</td></tr><tr><td>写入文件</td><td>fs.writeFile(file, data[, options], callback)</td></tr><tr><td>读取文件</td><td>fs.read(fd, buffer, offset, length, position, callback)</td></tr><tr><td>读取文件</td><td>fs.readFile(path[, options], callback)</td></tr><tr><td>重命名文件</td><td>fs.rename(oldPath, newPath, callback)</td></tr><tr><td>关闭文件</td><td>fs.close(fd, callback)</td></tr><tr><td>截取文件</td><td>fs.ftruncate(fd[, len], callback)</td></tr><tr><td>删除文件</td><td>fs.unlink(path, callback)</td></tr><tr><td>文件存在</td><td>fs.stat() / fs.access()</td></tr><tr><td>监听文件</td><td>fs.watchFile(filename[, options], listener)</td></tr><tr><td>停止监听</td><td>fs.unwatchFile(filename[, listener])</td></tr><tr><td>打开大文件</td><td>fs.createReadStream(path[, options])</td></tr><tr><td>写入大文件</td><td>fs.createWriteStream(path[, options])</td></tr><tr><td>创建目录</td><td>fs.mkdir(path[, options], callback)</td></tr><tr><td>读取目录</td><td>fs.readdir(path[, options], callback)</td></tr><tr><td>删除目录</td><td>fs.rmdir(path, callback)</td></tr></tbody></table> 
<h3><a id="fsreadfsreadFile_29"></a>fs.read和fs.readFile方法的比较</h3> 
<p><strong>fs.read()读取文件数据</strong><br> 语法格式：<br> fs.read(fd, buffer, offset, length, position, callback)<br> 从文件描述符fd中读取文件数据。<br> fd - 通过 fs.open() 方法返回的文件描述符。<br> buffer - 数据写入的缓冲区。<br> offset - 缓冲区写入的写入偏移量。<br> length - 要从文件中读取的字节数。<br> position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。<br> callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</p> 
<p>使用fs.read()方法读取文件内容时，首先需要一个文件描述符fd,fs.read()方法可以实现部分文件内容的读取。通过length和position参数可以指定读取文件内容的长度和读取内容的起始位置。</p> 
<pre><code>var fs = require("fs");
var buf = new Buffer.alloc(1024);

console.log("准备打开已存在的文件！");
fs.open('./2.html', 'r+', function(err, fd) { 
   if (err) {
       return console.error(err);
   }
   console.log("文件打开成功！");
   console.log("准备读取文件：");
   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){
      if (err){
         console.log(err);
      }
      console.log(bytes + "  字节被读取");
      
      // 仅输出读取的字节
      if(bytes &gt; 0){
         console.log(buf.slice(0, bytes).toString());
      }
   });
});
</code></pre> 
<p><img src="https://images2.imgbox.com/79/40/ZBGvUCnI_o.png" alt="在这里插入图片描述"></p> 
<p><strong>fs.readFile()读取文件内容</strong><br> fs.readFile(filename[, options], callback)<br> 读取文件的全部内容<br> filename表示要读取的文件<br> callback回调函数有2个参数 (err, data)，参数 data 是文件的内容。如果没有指定参数encoding, 则返回值为Buffer。注意:res.end()方法接受 字符串或者buffer<br> fs.readFile()方法能且只能读取文件的全部内容，通过设置编码方式可以以字符串或Buffer的形式返回读结果。</p> 
<pre><code>var http=require("http")
var fs=require("fs")
http.createServer((req,res)=&gt;{
	fs.readFile("./1.html",(err,data)=&gt;{
		if(!err){
			console.log(data)
		}else{
			console.log(err)
		}
	})
}).listen(8081)
</code></pre> 
<p><img src="https://images2.imgbox.com/35/5b/KC4z7aRC_o.png" alt="在这里插入图片描述"></p> 
<p>小结：fs.readFile()方法是对fs.read()方法的进一步封装，fs.readFile()方法可以方便的读取文件的全部内容。相比fs.readFile()方法，使用fs.read()方法读取文件的全部内容可操作性要强很多。首先要用fs.stat判断文件的大小，然后使用fs.open()创建文件描述符，最后再使用fs.read()方法读取文件内容。</p> 
<h3><a id="fswriteFile_92"></a>fs.writeFile</h3> 
<p>格式：fs.writeFile(path ,data,callback(err))<br> 如果文件存在，该方法写入的内容会覆盖旧的文件内容,不存在就创建一个新的文件<br> path - 文件路径<br> data - 要写入文件的数据，可以是 String(字符串)<br> callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</p> 
<pre><code>var fs = require("fs");
fs.writeFile("./test.txt","ljy666",(err)=&gt;{ //没有这个文件就创建
	if(err){
		console.log(err)
	}else{
		console.log("执行成功")
	}
})
</code></pre> 
<p><img src="https://images2.imgbox.com/b8/62/rA9NDAVK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/50/e9/TxkaApNI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d7/6a/xZfnNoCs_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="fsstat_111"></a>fs.stat</h3> 
<p>fs.stat可以用来判断是文件还是目录：stats.isFile()用于检测是否是文件，stats.isDirectory()用于检测是否是目录，两个都返回布尔值。</p> 
<pre><code>var fs = require("fs");
fs.stat("./test.txt",(err,stats)=&gt;{
	if(err){
		console.log(err)
	}else if(stats.isFile()){
		console.log("test.txt是文件")
	}else if(stats.isDirectory()){
		console.log("test.txt是目录")
	}
})
</code></pre> 
<p><img src="https://images2.imgbox.com/1a/00/d2aBj25f_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="fsmkdir_126"></a>fs.mkdir</h3> 
<p>fs.mkdir可以用来创建目录，该方法能接受sane参数：path(将创建的目录路径)，mode(读写权限，默认0777)，callback(异常回调)</p> 
<pre><code>var fs = require("fs");
fs.mkdir("img",(err)=&gt;{
	if(err){
		console.log(err)
	}else {
        console.log('创建成功')
	}
})
</code></pre> 
<p><img src="https://images2.imgbox.com/35/44/1Nidm6AK_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/2f/dc/WREL1oTN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="fsappendFile_141"></a>fs.appendFile</h3> 
<p>fs.appendFile用于向文件内追加内容。<br> 在进行内容追加的时候，如果目标文件不存在，会先创建文件，然后添加内容。</p> 
<pre><code>var fs = require("fs");
fs.writeFile("test1","666666",(err)=&gt;{
	if(err){
		console.log(err)
	}else {
        console.log('创建成功')
	}
})
</code></pre> 
<p><img src="https://images2.imgbox.com/01/bc/rf0MNA6s_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/de/d0/Rya3KGfK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/97/eb/axxRpjdi_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="fsreaddir_157"></a>fs.readdir</h3> 
<p>fs.readdir用于读取目录，能够同时获取目录下的文件和文件夹，返回一个包含文件名和文件夹名称的数组。</p> 
<pre><code>var fs = require("fs");
fs.readdir("../练习",(err,files)=&gt;{
	if(err){
		console.log(err)
	}else {
        console.log(files)
	}
})
</code></pre> 
<p><img src="https://images2.imgbox.com/08/0d/YHxLWYvG_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="fsrename_170"></a>fs.rename</h3> 
<p>移动/重命名文件或目录:整个功能相当于重命名一个文件/文件夹路径<br> 语法格式：<br> fs.rename(oldPath, newPath, callback);<br> oldPath, 原目录/文件的完整路径及名；<br> newPath, 新目录/文件的完整路径及名；如果新路径与原路径相同，而只文件名不同，则是重命名<br> callback(err), 操作完成回调函数；err操作失败对象<br> 移动文件有一个bug:新路径和旧路径必须是同一个根盘</p> 
<pre><code>var fs = require("fs");
fs.rename("1.html","img/3.html",(err)=&gt;{
	if(err){
		console.log(err)
	}else{
		console.log("移动成功")
	}
})
</code></pre> 
<p><img src="https://images2.imgbox.com/9b/7c/CoQWZByi_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/19/89/bcz6IYn8_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="fsrmdir_190"></a>fs.rmdir</h3> 
<p>fs.rmdir用于删除文件夹。用该方法来删除文件或者不存在的文件夹的时候会报错。如果文件夹下面有文件或文件夹则也会报错。</p> 
<pre><code>var fs = require("fs");
fs.rmdir("img",(err)=&gt;{
	if(err){
		console.log(err)
	}else{
		console.log("文件夹删除成功")
	}
})
</code></pre> 
<p><img src="https://images2.imgbox.com/2d/0c/PewxDIhY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="fsunlink_203"></a>fs.unlink</h3> 
<p>fs.unlink用于删除文件。如果使用该方法删除文件夹或者不存在的文件的时候，也会报错。</p> 
<pre><code>var fs = require("fs");
fs.unlink("test1",(err)=&gt;{
	if(err){
		console.log(err)
	}else{
		console.log("文件夹删除成功")
	}
})
</code></pre> 
<p><img src="https://images2.imgbox.com/2c/07/MPvdmEVr_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="fscopyFile_216"></a>fs.copyFile</h3> 
<p>用来拷贝文件<br> 语法：<br> fs.copyFile(oldPath, newPath, callback);<br> oldPath, 原文件的完整路径；<br> newPath, 新文件的完整路径；<br> callback(err), 操作完成回调函数；err操作失败对象<br> 拷贝文件以后两个文件都会存在磁盘中</p> 
<pre><code>var fs=require("fs")
fs.copyFile("test.txt","img/test.txt",(err)=&gt;{
        if(err){
			console.log(err)
		}else{
			console.log('复制成功')
		}
})
</code></pre> 
<p><img src="https://images2.imgbox.com/11/5d/QLNZg9BF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a4/12/psXa3v27_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/382ce30306c9de56b2791261c37e9e14/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python数据库sqlite3详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/181028f7e52003b19441743a1922e69d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用bat批量启动多个软件/程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>