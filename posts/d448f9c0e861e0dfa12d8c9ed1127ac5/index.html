<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker build 命令后 . 号的意思 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker build 命令后 . 号的意思" />
<meta property="og:description" content="点击在我的博客 xuxusheng.com 中查看，有更好的排版哦~ 参考文章: https://yeasy.gitbooks.io/docker_practice/content/image/build.html
我们在使用 docker build 命令去构建镜像时，往往会看到命令最后会有一个 . 号。
比如：
docker build -t xxx . 那么这里的 . 号代表什么意思呢？
在跟后端小悦悦同学交流的过程中，就发现小悦悦同学对 . 号的理解有所偏差，以为是用来指定 Dockerfile 文件所在的位置的，但其实 -f 参数才是用来指定 Dockerfile 的路径的，那么 . 号究竟是用来做什么的呢？
Docker 在运行时分为 Docker引擎（服务端守护进程） 以及 客户端工具，我们日常使用各种 docker 命令，其实就是在使用客户端工具与 Docker 引擎 进行交互。
那么当我们使用 docker build 命令来构建镜像时，这个构建过程其实是在 Docker引擎 中完成的，而不是在本机环境。
那么如果在 Dockerfile 中使用了一些 COPY 等指令来操作文件，如何让 Docker引擎 获取到这些文件呢？
这里就有了一个 镜像构建上下文 的概念，当构建的时候，由用户指定构建镜像的上下文路径，而 docker build 会将这个路径下所有的文件都打包上传给 Docker 引擎，引擎内将这些内容展开后，就能获取到所有指定上下文中的文件了。
比如说 dockerfile 中的 COPY ./package.json /project，其实拷贝的并不是本机目录下的 package.json 文件，而是 docker引擎 中展开的构建上下文中的文件，所以如果拷贝的文件超出了构建上下文的范围，Docker引擎 是找不到那些文件的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/d448f9c0e861e0dfa12d8c9ed1127ac5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-09T19:46:59+08:00" />
<meta property="article:modified_time" content="2018-03-09T19:46:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker build 命令后 . 号的意思</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_xuxushengcom_httpswwwxuxushengcompostdockerbuildE591BDE4BBA4E5908EE58FB7E79A84E6848FE6809D_0"></a><strong><a href="https://www.xuxusheng.com/post/docker-build%E5%91%BD%E4%BB%A4%E5%90%8E-%E5%8F%B7%E7%9A%84%E6%84%8F%E6%80%9D" rel="nofollow">点击在我的博客 xuxusheng.com 中查看，有更好的排版哦~</a></strong></h2> 
<blockquote> 
 <p>参考文章: <a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" rel="nofollow">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a></p> 
</blockquote> 
<p>我们在使用 <code>docker build</code> 命令去构建镜像时，往往会看到命令最后会有一个 <code>.</code> 号。</p> 
<p>比如：</p> 
<pre><code>docker build -t xxx .
</code></pre> 
<p>那么这里的 <code>.</code> 号代表什么意思呢？</p> 
<p>在跟后端小悦悦同学交流的过程中，就发现小悦悦同学对 <code>.</code> 号的理解有所偏差，以为是用来指定 <code>Dockerfile</code> 文件所在的位置的，但其实 <code>-f</code> 参数才是用来指定 <code>Dockerfile</code> 的路径的，那么 <code>.</code> 号究竟是用来做什么的呢？</p> 
<hr> 
<p><code>Docker</code> 在运行时分为 <code>Docker引擎（服务端守护进程）</code> 以及 <code>客户端工具</code>，我们日常使用各种 <code>docker 命令</code>，其实就是在使用客户端工具与 <code>Docker 引擎</code> 进行交互。</p> 
<p>那么当我们使用 <code>docker build</code> 命令来构建镜像时，这个构建过程其实是在 <code>Docker引擎</code> 中完成的，而不是在本机环境。</p> 
<p>那么如果在 <code>Dockerfile</code> 中使用了一些 <code>COPY</code> 等指令来操作文件，如何让 <code>Docker引擎</code> 获取到这些文件呢？</p> 
<p>这里就有了一个 <code>镜像构建上下文</code> 的概念，当构建的时候，由用户指定构建镜像的上下文路径，而 <code>docker build</code> 会将这个路径下所有的文件都打包上传给 <code>Docker 引擎</code>，引擎内将这些内容展开后，就能获取到所有指定上下文中的文件了。</p> 
<p>比如说 <code>dockerfile</code> 中的 <code>COPY ./package.json /project</code>，其实拷贝的并不是本机目录下的 <code>package.json</code> 文件，而是 <code>docker引擎</code> 中展开的构建上下文中的文件，所以如果拷贝的文件超出了构建上下文的范围，<code>Docker引擎</code> 是找不到那些文件的。</p> 
<hr> 
<p>所以 <code>docker build</code> 最后的 <code>.</code> 号，其实是在指定镜像构建过程中的上下文环境的目录。</p> 
<p>理解了上面的这些概念，就更方便的去理解 <code>.dockerignore</code> 文件的作用了。</p> 
<p>关于 <code>.dockerignore</code> 的使用参见另一篇博文：<a href="http://blog.csdn.net/xs20691718/article/details/79502406">.dockerignore 文件的作用</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fde3f79268897542f04afad7bc49cbf6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决JavaFX Scene Builder打不开.fxml文件的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5def5c7982b61976969cc80007459dec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">链表：调换相邻元素</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>