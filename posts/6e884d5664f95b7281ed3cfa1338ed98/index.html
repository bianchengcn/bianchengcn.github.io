<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软流水的方法--国科大体系结构 期末必考题 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软流水的方法--国科大体系结构 期末必考题" />
<meta property="og:description" content="软流水的概念 软流水是通过重组循环体使得不同循环体指令并行执行，新循环体的每个操作来自不同的循环体，以分开数据相关的指令。
软流水后，循环体会变成装入、主体循环、排空三个部分。
在软流水后循环执行时，主要是主体循环部分在执行，装入和排空仅执行一次。因而可以通俗理解为：装入是为了让主体循环可以正确执行的预处理阶段，排空是保证主体循环执行后结果正确的收尾阶段。
之后会对这些概念有更深入的介绍。不想理解就直接看解题方法。
软流水的方法 写在前面，我会在指令前加序号，同时在分析时直接用序号来描述指令。
先看一个简单例子。
假设我们需要执行如下循环：
for(i = 1; i &lt;= 100; i&#43;&#43;)	x[i] = x[i] &#43; s;	假设 s 是一个常量,存在寄存器 F0 中，数组首地址在 R1 中，数组每个元素占 8 字节。且 R2 = R1 &#43; 800。同时我们假设 R1 地址初始是0，在之后会用到这一点。
于是有如下指令段：
// 注： L.D S.D 有时候写成 LDC1 SDC1 L1: 1 L.D F2, 0(R1) // 取X[i] 2 ADD.D F4, F2, F0 // 计算X[i] &#43; s 3 S.D F4, 0(R1)	// 存X[i] 4 DADDIU R1, R1, 8 // X的下标&#43;1 5 BNE R1, R2, L1 // R1不等于R2，程序跳转到L1处继续执行 流水线延迟为：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/6e884d5664f95b7281ed3cfa1338ed98/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-25T13:24:03+08:00" />
<meta property="article:modified_time" content="2022-12-25T13:24:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软流水的方法--国科大体系结构 期末必考题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>软流水的概念</h2> 
<p>软流水是通过重组循环体使得不同循环体指令并行执行，新循环体的每个操作来自不同的循环体，以分开数据相关的指令。<br> 软流水后，循环体会变成<strong>装入、主体循环、排空</strong>三个部分。<br> 在软流水后循环执行时，主要是主体循环部分在执行，装入和排空仅执行一次。因而可以通俗理解为：装入是为了让主体循环可以正确执行的<strong>预处理</strong>阶段，排空是保证主体循环执行后结果正确的<strong>收尾</strong>阶段。</p> 
<p>之后会对这些概念有更深入的介绍。不想理解就直接看<a href="https://blog.csdn.net/csdn_muxin/article/details/114491152?spm=1001.2014.3001.5502#t5">解题方法</a>。</p> 
<h2><a id="_8"></a>软流水的方法</h2> 
<p><em>写在前面，我会在指令前加序号，同时在分析时直接用序号来描述指令。</em></p> 
<p>先看一个简单例子。</p> 
<p>假设我们需要执行如下循环：</p> 
<pre><code class="prism language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>	x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">;</span>	
</code></pre> 
<p>假设 s 是一个常量,存在寄存器 F0 中，数组首地址在 R1 中，数组每个元素占 8 字节。且 R2 = R1 + 800。同时我们假设 R1 地址初始是0，在之后会用到这一点。<br> 于是有如下指令段：</p> 
<pre><code class="prism language-c"><span class="token comment">// 注： L.D  S.D 有时候写成 LDC1 SDC1</span>
L1<span class="token operator">:</span>
	<span class="token number">1</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i]</span>
	<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算X[i] + s</span>
	<span class="token number">3</span>  S<span class="token punctuation">.</span>D    F4<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span>		 <span class="token comment">// 存X[i]</span>
	<span class="token number">4</span>  DADDIU R1<span class="token punctuation">,</span> R1<span class="token punctuation">,</span> <span class="token number">8</span> 	 <span class="token comment">// X的下标+1</span>
	<span class="token number">5</span>  BNE    R1<span class="token punctuation">,</span> R2<span class="token punctuation">,</span> L1 	 <span class="token comment">// R1不等于R2，程序跳转到L1处继续执行</span>
</code></pre> 
<p>流水线延迟为：<br> <img src="https://images2.imgbox.com/3f/fc/3OmSjicM_o.png" alt="流水线延迟"><br> 那么分析可知，<br> 1 和 2 延迟为2，之间需要加上 1 条不相关指令<br> 2 和 3 延迟为3，之间需要加上 2 条不相关指令</p> 
<p>接下来我们要通过软流水来消除延迟。</p> 
<h3><a id="_38"></a>主体循环</h3> 
<p>对于刚刚的指令段，我们可以看到前三条指令存在两组数据相关：第 2 条和第 1 条，第 3 条和第 2 条。可以看到它们之间是顺序相关的，那么，如果改变指令的顺序怎么样？<br> 于是我们可以将这三条指令想象成三个独立的模块（不要着急为什么，先往下看）。然后将它们的顺序倒过来，如下</p> 
<pre><code class="prism language-c"><span class="token number">1</span>  S<span class="token punctuation">.</span>D    F4<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span>		 <span class="token comment">// 存X[i]</span>
<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算X[i] + s</span>
<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i]</span>
</code></pre> 
<p>这样先存后取显然不合理。但如果改变一下下标呢？如下：</p> 
<pre><code class="prism language-c"><span class="token number">1</span>  S<span class="token punctuation">.</span>D    F4<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span>		 <span class="token comment">// 存X[i]</span>
<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算X[i+1] + s</span>
<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i+2]</span>
</code></pre> 
<p>这样显然是合理的，即第 1 条指令存的是上一轮循环算出的值，只是放在这一轮循环存了而已。<br> 而且可以看到，这样是没有流水线等待的。为什么？</p> 
<p>1 存的是 X[i] 的值，是<strong>上一轮</strong>计算出的，而两轮循环中间的间隔是大于流水线延迟的（之后会计算）。<br> 2 计算的是<strong>下一轮</strong>要存的值，也就是 X[i+1]，而取数是上一轮取得，而两轮循环中间的间隔是大于流水线延迟的（之后会计算）。<br> 3 取的是<strong>下一轮</strong>要计算的值，也就是 X[(i+1)+1]。 取数指令明显没有数据相关，同样寄存器 F2 的值也已经使用过了，可以更新。</p> 
<p>那么，每次循环像刚刚这样写就可以避免相关消除延迟了。<br> 怎么写？且往下看。<br> 首先，写下这三个模块的三轮循环。</p> 
<pre><code class="prism language-c">一、
	<span class="token number">1</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i]</span>
	<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算X[i] + s</span>
	<span class="token number">3</span>  S<span class="token punctuation">.</span>D    F4<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span>		 <span class="token comment">// 存X[i]</span>
二、
	<span class="token number">1</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i+1]</span>
	<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算X[i+1] + s</span>
	<span class="token number">3</span>  S<span class="token punctuation">.</span>D    F4<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span>		 <span class="token comment">// 存X[i+1]</span>
三、
	<span class="token number">1</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i+2]</span>
	<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算X[i+2] + s</span>
	<span class="token number">3</span>  S<span class="token punctuation">.</span>D    F4<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span>	 <span class="token comment">// 存X[i+2]</span>
</code></pre> 
<p>可以看到，在第二次和第三次循环中 Load/Store 的偏移量跟着做了改变，这是因为在这三次循环里 R1 的值并没有改变，为了正确存取需要改变偏移量。<br> 然后，依次倒着从每轮循环取每个模块。<br> 第一轮取第三个模块，第二轮取第二个模块，第三轮取第一个模块，就变成下面这样：</p> 
<pre><code class="prism language-c"><span class="token number">1</span>  S<span class="token punctuation">.</span>D    F4<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span>		 <span class="token comment">// 存X[i]</span>
<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算X[i+1] + s</span>
<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i+2]</span>
</code></pre> 
<p>这不就是刚刚分析出的循环体嘛。<br> 然后我们补全循环体，一个循环之所以叫循环，总得有循环结束条件吧。<br> 如下：</p> 
<pre><code class="prism language-c"><span class="token number">1</span>  S<span class="token punctuation">.</span>D    F4<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span>		 <span class="token comment">// 存X[i]</span>
<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算X[i+1] + s</span>
<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i+2]</span>
<span class="token number">4</span>  BNE    R1<span class="token punctuation">,</span> R2<span class="token punctuation">,</span> L1     <span class="token comment">// R1不等于R2，程序跳转到L1处继续执行</span>
<span class="token number">5</span>  DADDIU R1<span class="token punctuation">,</span> R1<span class="token punctuation">,</span> <span class="token number">8</span>		 <span class="token comment">// X的下标+1</span>
</code></pre> 
<p>这里将 <em><strong>X的下标+1</strong></em> 放在延迟槽中。</p> 
<p>现在开始分析这样重排指令是否还存在延迟问题。<br> （延迟为n，两条相关指令中需要间隔 n-1 条不相关的指令）<br> 1 是存储上一轮循环计算出的值，也就是从上一轮的 2 到这一轮的 1，延迟为 3，中间有 3 条指令，满足。<br> 2 是计算下一轮要存储的值，刚刚分析过了。<br> 3 是取下一轮要计算的值，也就是从这一轮的 3 到下一轮的 2 ，延迟为 2，中间有 3 条指令， 满足。</p> 
<p>同时，可以注意到，因为<strong>循环结束条件没变</strong>，所以当我们执行到第 100 轮循环时，第 2 条指令是计算的第 101 轮要存的数，第 3 条指令取的是第 101 轮要计算的数（且这个数要在第 102 轮存），显然没有 101 轮的数组元素，通俗地说就是<strong>数组越界</strong>。况且，由于 <em><strong>X的下标+1</strong></em> 放在延迟槽中，程序是<strong>先判断循环是否结束</strong>，再进行 下标+1 的操作，之前题目已经声明 R2 = R1 + 800，且 R1 初始为 0，即 R2 = 800，那么<strong>第 100 轮的主体循环在指令 4 判断循环是否结束时，R1=792 ≠ R2=800</strong>。所以还会有第 101 轮循环，造成越界。<br> <em><strong>注：如果将下标+1指令放在循环判断前，就没有这个额外的判断了，这样的话循环会在第100轮结束</strong></em></p> 
<p>为了防止这种情况，有两种解决方法，一种简单，就是<strong>修改一下主体循环的偏移量</strong>（按照刚刚 <em><strong>X的下标+1</strong></em> 放在延迟槽中最后一轮的例子，之前分析可知正确情况下最后一轮 R1 = R2 = 800，但<strong>最后一位数组元素地址是 792</strong>，所以取数指令的偏移量需要为 -8）；另一种是<strong>修改循环结束条件</strong>，让它在第 98 轮就结束。</p> 
<p>这里就使用第一种方法。先将第3条指令的偏移量修改成 -8，这样最后一轮循环就是取的最后一位数组元素（循环结束时 R1 = R2 = 800，<strong>最后一位数组元素地址是 792</strong>），不会访问越界，其他的同幅度调整即可，如第 1 条之前是 0，第 3 条之前是 16，都减 24 （16 - 24 = -8）即可。<br> 为了方便理解，修改了注释的下标，修改如下：</p> 
<pre><code class="prism language-c"><span class="token number">1</span>  S<span class="token punctuation">.</span>D    F4<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">24</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span>	 <span class="token comment">// 存X[i-3]</span>
<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算X[i-2] + s</span>
<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i-1]</span>
<span class="token number">4</span>  BNE    R1<span class="token punctuation">,</span> R2<span class="token punctuation">,</span> L1     <span class="token comment">// R1不等于R2，程序跳转到L1处继续执行</span>
<span class="token number">5</span>  DADDIU R1<span class="token punctuation">,</span> R1<span class="token punctuation">,</span> #<span class="token number">8</span>		 <span class="token comment">// X的下标+1</span>
</code></pre> 
<p>这样就不会有数组越界的情况发生。（这道题因为指令少，不用修改寄存器就是正确的）</p> 
<p>到这里我们就完成了主体循环的指令段，还差装入和排空两个阶段。这两个阶段可以不考虑指令相关。</p> 
<h3><a id="_126"></a>装入</h3> 
<p>之前提到过，装入就是预处理。那么看刚刚完成的主体循环，可以看到当<strong>第一次执行</strong>时，就要<strong>存数组首位元素</strong>的计算结果，以及要<strong>对数组第二位元素进行计算</strong>。<br> 所以，我们在装入阶段就要把<strong>数组首位元素取出并且结算</strong>，把<strong>第二位取出</strong>。同时，<strong>注意Store偏移量</strong>是 -24，那么在装入还要对下标进行 +24 处理。如下：</p> 
<pre><code class="prism language-c"><span class="token number">1</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[0]</span>
<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算X[0] + s</span>
<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span>		 <span class="token comment">// 取X[1]</span>
<span class="token number">4</span>  ADDIU  R1<span class="token punctuation">,</span> R1<span class="token punctuation">,</span> #<span class="token number">24</span> 	 <span class="token comment">// X的下标+3</span>
</code></pre> 
<p>这样就完成了装入的指令段。</p> 
<h3><a id="_139"></a>排空</h3> 
<p>同样，之前也提过，排空就是收尾。那么看之前的主题循环部分，可以知道最后一轮循环执行时，存的是倒数第三个数组元素，计算的是倒数第二个数组元素，取出的是末尾数组元素。<br> 所以，在排空阶段我们要<strong>存储倒数第二个数组元素</strong>，<strong>计算并存储末尾数组元素</strong>。同时注意判断循环结束时R2 =800，那么在这之后又执行了延迟槽指令，即主体循环结束时又对下标进行了+1，这时候R1 = 808。倒数第二个数组元素地址为784 = 808 - 24 ，倒数一个数组元素地址为792 = 808 -16。修改如下：</p> 
<pre><code class="prism language-c"><span class="token number">1</span>  S<span class="token punctuation">.</span>D    F4<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">24</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span>	 <span class="token comment">// 存倒数第二个</span>
<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算末尾元素</span>
<span class="token number">3</span>  S<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 存末尾元素</span>
</code></pre> 
<p>如果让算平均多少拍一次，那就是<br> <strong>{（循环次数-模块数+1）× 主体循环指令条数 + 装入的拍数 + 排空的拍数 } ÷ 循环次数</strong><br> 装入排空的拍数因为存在延迟所以不等于指令数。<br> 到此即结束，如果还不懂请看解题方法。</p> 
<h2><a id="_152"></a>解题方法</h2> 
<blockquote> 
 <p>高斯消元法的核心操作是一个循环，可以概括为 Y = a*X +<br> Y，我们假设循环共100次，循环变量每次增加8位，假设从0位开始，到800结束（<strong>792是末尾数组元素地址</strong>）。且假设R1、R2存放数组X、Y的首地址，F0存储浮点常量a的值。</p> 
</blockquote> 
<p>指令如下，进行软流水处理。</p> 
<pre><code class="prism language-c">bar：
	<span class="token number">1</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i]</span>
	<span class="token number">2</span>  MUL<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算a*X[i]</span>
	<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F6<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span>		 <span class="token comment">// 取Y[i]</span>
	<span class="token number">4</span>  ADD<span class="token punctuation">.</span>D  F6<span class="token punctuation">,</span> F4<span class="token punctuation">,</span> F6 	 <span class="token comment">// a*X[i] + Y[i]</span>
	<span class="token number">5</span>  S<span class="token punctuation">.</span>D    <span class="token number">0</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">,</span> F6	 	 <span class="token comment">// 存Y[i]</span>
	<span class="token number">6</span>  DADDIU R1<span class="token punctuation">,</span> R1<span class="token punctuation">,</span> #<span class="token number">8</span>	 <span class="token comment">// X的下标+1</span>
	<span class="token number">7</span>  DADDIU R2<span class="token punctuation">,</span> R2<span class="token punctuation">,</span> #<span class="token number">8</span>	 <span class="token comment">// Y的下标+1</span>
	<span class="token number">8</span>  DSGEIU R3<span class="token punctuation">,</span> R1<span class="token punctuation">,</span> #<span class="token number">800</span>	 <span class="token comment">// 测试循环是否结束</span>
	<span class="token number">9</span>  BEQZ   R3<span class="token punctuation">,</span> bar		 <span class="token comment">// 如果循环没有结束，程序跳转到bar位置</span>
	<span class="token number">10</span> NOP
</code></pre> 
<p>首先看循环主体（<strong>取数、计算、存数</strong>），去掉下标变换和循环结束的判断。为：</p> 
<pre><code class="prism language-c"><span class="token number">1</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i]</span>
<span class="token number">2</span>  MUL<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算a*X[i]</span>
<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F6<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span>		 <span class="token comment">// 取Y[i]</span>
<span class="token number">4</span>  ADD<span class="token punctuation">.</span>D  F6<span class="token punctuation">,</span> F4<span class="token punctuation">,</span> F6 	 <span class="token comment">// a*X[i] + Y[i]</span>
<span class="token number">5</span>  S<span class="token punctuation">.</span>D    <span class="token number">0</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">,</span> F6	 	 <span class="token comment">// 存Y[i]</span>
</code></pre> 
<p>按照顺序看相关性<br> 1 和 2 有相关<br> 2 和 3 没有相关<br> 3 和 4 有相关<br> 4 和 5 有相关<br> 其中2 和 3没有相关，那么根据是否有相关性将这<strong>五条指令分成四个模块</strong>，分别是<br> 1、 2和3、 4、 5<br> 有四个模块，于是将这<strong>四个模块写四轮</strong>，偏移量从0开始每轮 +8 递增，如下</p> 
<pre><code class="prism language-c">一、
	<span class="token number">1</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i]</span>
	<span class="token number">2</span>  MUL<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算a*X[i]</span>
	<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F6<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span>		 <span class="token comment">// 取Y[i]</span>
	<span class="token number">4</span>  ADD<span class="token punctuation">.</span>D  F6<span class="token punctuation">,</span> F4<span class="token punctuation">,</span> F6 	 <span class="token comment">// a*X[i] + Y[i]</span>
	<span class="token number">5</span>  S<span class="token punctuation">.</span>D    <span class="token number">0</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">,</span> F6	 	 <span class="token comment">// 存Y[i]</span>
二、
	<span class="token number">1</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i+1]</span>
	<span class="token number">2</span>  MUL<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算a*X[i+1]</span>
	<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F6<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span>		 <span class="token comment">// 取Y[i+1]</span>
	<span class="token number">4</span>  ADD<span class="token punctuation">.</span>D  F6<span class="token punctuation">,</span> F4<span class="token punctuation">,</span> F6 	 <span class="token comment">// a*X[i+1] + Y[i+1]</span>
	<span class="token number">5</span>  S<span class="token punctuation">.</span>D    <span class="token number">8</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">,</span> F6	 	 <span class="token comment">// 存Y[i+1]</span>
三、
	<span class="token number">1</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i+2]</span>
	<span class="token number">2</span>  MUL<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算a*X[i+2]</span>
	<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F6<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span>	 <span class="token comment">// 取Y[i+2]</span>
	<span class="token number">4</span>  ADD<span class="token punctuation">.</span>D  F6<span class="token punctuation">,</span> F4<span class="token punctuation">,</span> F6 	 <span class="token comment">// a*X[i+2] + Y[i+2]</span>
	<span class="token number">5</span>  S<span class="token punctuation">.</span>D    <span class="token number">16</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">,</span> F6 	 <span class="token comment">// 存Y[i+2]</span>
四、
	<span class="token number">1</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i+3]</span>
	<span class="token number">2</span>  MUL<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算a*X[i+3]</span>
	<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F6<span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span>	 <span class="token comment">// 取Y[i+3]</span>
	<span class="token number">4</span>  ADD<span class="token punctuation">.</span>D  F6<span class="token punctuation">,</span> F4<span class="token punctuation">,</span> F6 	 <span class="token comment">// a*X[i+3] + Y[i+3]</span>
	<span class="token number">5</span>  S<span class="token punctuation">.</span>D    <span class="token number">24</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">,</span> F6 	 <span class="token comment">// 存Y[i+3]</span>
</code></pre> 
<p>然后，<strong>依次倒着从每轮循环取每个模块</strong>。<br> 第一轮取第四个模块，第二轮取第三个模块，第三轮取第二个模块，第四轮取第一个，并将<strong>最后一个取数指令的偏移量减去一个值变为0</strong>，同时将<strong>其它所有偏移量也减去这个值</strong>。就变成下面这样：</p> 
<pre><code class="prism language-c"><span class="token number">1</span>  S<span class="token punctuation">.</span>D    <span class="token operator">-</span><span class="token number">24</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">,</span> F6	 <span class="token comment">// 存Y[i-3]</span>
<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F6<span class="token punctuation">,</span> F4<span class="token punctuation">,</span> F6 	 <span class="token comment">// a*X[i-2] + Y[i-2]</span>
<span class="token number">3</span>  MUL<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算a*X[i-1]</span>
<span class="token number">4</span>  L<span class="token punctuation">.</span>D    F6<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span>	 <span class="token comment">// 取Y[i-1]</span>
<span class="token number">5</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i]</span>
</code></pre> 
<p>可以看到，第二条指令的运算结果存在 F6 中，第 4 条Load指令取的数也在 F6，显然不合理，将 4 的寄存器修改为 F8，同时将相关的寄存器也修改(也就是第二条指令的后一个 F6 改为 F8 )。<br> 然后补上下标+1的指令，以及循环结束条件。（<em><strong>这里因为 下标+1 的指令放在循环结束条件判断语句之前，所以最后一条取数指令的偏移量为0，其它同幅度减少，结合上个例子体会</strong></em>）</p> 
<pre><code class="prism language-c"><span class="token number">1</span>  S<span class="token punctuation">.</span>D    <span class="token operator">-</span><span class="token number">24</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">,</span> F6	 <span class="token comment">// 存Y[i-3]</span>
<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F6<span class="token punctuation">,</span> F4<span class="token punctuation">,</span> F8 	 <span class="token comment">// a*X[i-2] + Y[i-2]</span>
<span class="token number">3</span>  MUL<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算a*X[i-1]</span>
<span class="token number">4</span>  L<span class="token punctuation">.</span>D    F8<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span>	 <span class="token comment">// 取Y[i-1]</span>
<span class="token number">5</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[i]</span>
<span class="token number">6</span>  DADDIU R1<span class="token punctuation">,</span> R1<span class="token punctuation">,</span> #<span class="token number">8</span>	 <span class="token comment">// X下标+1</span>
<span class="token number">7</span>  DADDIU R2<span class="token punctuation">,</span> R2<span class="token punctuation">,</span> #<span class="token number">8</span>	 <span class="token comment">// Y下标+1</span>
<span class="token number">8</span>  DSGEIU R3<span class="token punctuation">,</span> R1<span class="token punctuation">,</span> #<span class="token number">800</span>	 <span class="token comment">// 测试循环是否结束</span>
<span class="token number">9</span>  BEQZ   R3<span class="token punctuation">,</span> bar		 <span class="token comment">// 如果循环没有结束，程序跳转到bar位置</span>
<span class="token number">10</span> NOP
</code></pre> 
<p>以上就是主体循环部分，接下来写装入部分。</p> 
<hr> 
<p>装入部分是预处理，可知主体循环部分的第一轮就要：存储数组首位计算结果 <strong>Y[0]</strong>、计算数组第二位的 <strong>Y[1]</strong>、计算数组第三位 <strong>aX[2]</strong>。（取第四位和之前没有关系）<br> 因此，我们需要在装入部分完成：取出并计算数组首位 <strong>Y[0]</strong>、取出并计算数组第二位的 **aX[1]**以及取出 <strong>初始Y[1]</strong>，取出数组第三位的 <strong>X[2]</strong>。同时要根据主体循环部分处理下标，以及要将寄存器的值正确对应（ 取Y 和 加法 的后一个Y 改为F8）。如下：</p> 
<pre><code class="prism language-c"><span class="token number">1</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[0]</span>
<span class="token number">2</span>  MUL<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span>F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算a*X[0]</span>
<span class="token number">3</span>  L<span class="token punctuation">.</span>D    F8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span>		 <span class="token comment">// 取Y[0]</span>
<span class="token number">4</span>  ADD<span class="token punctuation">.</span>D  F6<span class="token punctuation">,</span> F4<span class="token punctuation">,</span> F8 	 <span class="token comment">// a*X[0] + Y[0]</span>
<span class="token number">5</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[1]</span>
<span class="token number">6</span>  MUL<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算a*X[1]</span>
<span class="token number">7</span>  L<span class="token punctuation">.</span>D    F8<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span>		 <span class="token comment">// 取Y[1]</span>
<span class="token number">8</span>  L<span class="token punctuation">.</span>D    F2<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span> 	 <span class="token comment">// 取X[2]</span>
<span class="token number">9</span>  DADDIU R1<span class="token punctuation">,</span> R1<span class="token punctuation">,</span> #<span class="token number">24</span> 	 <span class="token comment">// 下标 +3</span>
<span class="token number">10</span> DADDIU R2<span class="token punctuation">,</span> R2<span class="token punctuation">,</span> #<span class="token number">24</span> 	 <span class="token comment">// 下标 +3</span>
</code></pre> 
<p>这样就完成了装入。</p> 
<hr> 
<p>排空部分就是收尾，可知主体循环部分的最后一轮完成的操作：存了倒数第四位 <strong>Y[97]</strong>（那这一位已经不用管了）、计算了倒数第三位 <strong>Y[98]</strong>、计算了倒数第二位 aX[99]并且取了 <strong>初始Y[99]</strong>、取出了最后一位 <strong>X[100]</strong>。<br> 那么，我们将要做的就是：存倒数第三位 <strong>Y[98]</strong>、计算并存储倒数第二位 <strong>Y[99]</strong>、计算最后一位的 **aX[100]**并且取出并计算 <strong>Y[100]</strong>。同时注意，循环结束时R1和R2的地址是800，最后一位是792，以此类推写偏移量。如下：</p> 
<pre><code class="prism language-c"><span class="token number">1</span>  S<span class="token punctuation">.</span>D    <span class="token operator">-</span><span class="token number">24</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">,</span> F6	 <span class="token comment">// 存Y[98]</span>
<span class="token number">2</span>  ADD<span class="token punctuation">.</span>D  F6<span class="token punctuation">,</span> F4<span class="token punctuation">,</span> F8 	 <span class="token comment">// a*X[99] + Y[99]</span>
<span class="token number">3</span>  S<span class="token punctuation">.</span>D    <span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">,</span> F6	 <span class="token comment">// 存Y[99]</span>
<span class="token number">4</span>  MUL<span class="token punctuation">.</span>D  F4<span class="token punctuation">,</span> F2<span class="token punctuation">,</span> F0 	 <span class="token comment">// 计算a*X[100]</span>
<span class="token number">5</span>  L<span class="token punctuation">.</span>D    F8<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span>	 <span class="token comment">// 取Y[100]</span>
<span class="token number">6</span>  ADD<span class="token punctuation">.</span>D  F6<span class="token punctuation">,</span> F4<span class="token punctuation">,</span> F8	 <span class="token comment">// 计算Y[100]</span>
<span class="token number">7</span>  S<span class="token punctuation">.</span>D    <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">,</span> F6	 <span class="token comment">// 存Y[100]</span>
</code></pre> 
<p>至此全部完成。<br> 如果让算平均多少拍一次，那就是<br> <strong>{（循环次数-模块数+1）× 主体循环指令条数 + 装入的拍数 + 排空的拍数 } ÷ 循环次数</strong><br> 装入排空的拍数因为存在延迟所以不等于指令数。</p> 
<h2><a id="_279"></a>解题步骤秘诀</h2> 
<ol><li>先确定循环主体（<strong>取数、计算、存数</strong>）</li><li>根据顺序看相关，根据相关分模块</li><li>几个模块写几轮，偏移量要跟着变</li><li>每个循环倒着取，一个循环取一块</li><li>末尾偏移要变零，其它偏移减同数</li><li>寄存相同变其一，补上下标和判断</li><li>装入就是预处理，排空就是收个尾</li><li>写完再查越界否</li></ol> 
<p>最后，<strong>写完了一定要检查最后一轮是否越界、偏移量是否合理</strong></p> 
<p>我也有写<a href="https://blog.csdn.net/csdn_muxin/article/details/112284481">循环展开</a><br> 考试题的话软流水基本上不会因为修改延迟有变化，只会因为指令本身变化而变化。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/43697f2bdc6fd24db6d9957e55b3629c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">区块链北大肖老师学习笔记5</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/824beabda36787c8c8d14b9eef3c9797/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【由浅入深 - Java笔记】玩转List：List过滤和筛选</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>