<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言strcpy函数的使用 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言strcpy函数的使用" />
<meta property="og:description" content="strcpy简单使用： #include &lt;stdio.h&gt; #include &lt;string.h&gt; struct Student { int sid; char name[20]; int age; } st; //此处分号不可省略 int main(void) { struct Student st = {1000,&#34;zhangsan&#34;,20}; printf(&#34;%d %s %d\n&#34;, st.sid, st.name, st.age); st.sid = 500; // st.name=&#34;lisi&#34; //error strcpy(st.name,&#34;lisi&#34;); st.age=20; while(true){} } 头文件：#include &lt;string.h&gt; 和 #include &lt;stdio.h&gt;
功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间
说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。返回指向dest的指针。
//C语言标准库函数strcpy的一种典型的工业级的最简实现。 //返回值：目标串的地址。 //对于出现异常的情况ANSI-C99标准并未定义，故由实现者决定返回值，通常为NULL。 //参数：des为目标字符串，source为原字符串。 char* strcpy(char* des,const char* source) {　char* r=des; assert((des != NULL) &amp;&amp; (source != NULL)); while((*r&#43;&#43; = *source&#43;&#43;)!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/1994a1d64b8f48d3ad29bc6baf567321/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-19T11:00:53+08:00" />
<meta property="article:modified_time" content="2020-04-19T11:00:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言strcpy函数的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>strcpy简单使用： </p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct Student {
	int sid;
	char name[20];
	int age;

} st;  //此处分号不可省略

int main(void) {

	struct Student st = {1000,"zhangsan",20};

	printf("%d  %s  %d\n", st.sid, st.name, st.age);

	st.sid = 500;
	// st.name="lisi"  //error
	strcpy(st.name,"lisi");
	st.age=20;

	while(true){}

}</code></pre> 
<p> </p> 
<p>头文件：#include &lt;<a href="https://baike.baidu.com/item/string.h" rel="nofollow">string.h</a>&gt; 和 #include &lt;stdio.h&gt;</p> 
<p>功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4" rel="nofollow">地址空间</a></p> 
<p>说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。返回指向dest的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" rel="nofollow">指针</a>。</p> 
<pre><code>//C语言标准库函数strcpy的一种典型的工业级的最简实现。 
//返回值：目标串的地址。
//对于出现异常的情况ANSI-C99标准并未定义，故由实现者决定返回值，通常为NULL。
//参数：des为目标字符串，source为原字符串。
char* strcpy(char* des,const char* source) {　
 char* r=des;    
 assert((des != NULL) &amp;&amp; (source != NULL));
while((*r++ = *source++)!='\0');　
  return des;　
}
//while((*des++=*source++));的解释：赋值表达式返回左操作数，所以在赋值'\0'后，循环停止。</code></pre> 
<p>举例： </p> 
<pre><code>char a[10],b[]={"COPY"};
//定义字符数组a,b
strcpy(a,b);
//将b中的COPY复制到a中</code></pre> 
<h3>Strcpy函数中的缓冲区溢出问题和防范</h3> 
<p>C 语言和 C++语言风格轻松、灵活，语法限制宽松，因而受到各类程序员的欢迎，是比较通用的编程语言，同时也是各大院校计算机专业的基本语言课程。strcpy 函数由于不对数组边界进行检查，而非常容易造成各种缓冲区溢出的漏洞。这些漏洞很容易被利用，而造成严重的系统问题。在使用 strcpy 函数时，要小心谨慎。<br> 以下就 Strcpy 函数中的缓冲区溢出问题和防范进行讨论。 [1]<a name="ref_%5B1%5D_1026861"> </a></p> 
<p><a name="3_1"></a><a name="sub1026861_3_1"></a><a name="%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98"></a><a name="3-1"></a></p> 
<h4>缓冲区溢出问题</h4> 
<p>缓冲区的溢出就是程序在动态分配的缓冲区中写入了太多的数据，使这个分配区发生了溢出。一旦一个缓冲区利用程序能将运行的指令放在有 root权限的内存中，运行这些指令，就可以利用 root 权限来控制计算机了。 [1] </p> 
<p><a name="3_2"></a><a name="sub1026861_3_2"></a><a name="Strcpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81"></a><a name="3-2"></a></p> 
<h4>Strcpy函数的安全编码</h4> 
<p>在编程时，加入错误检查，就可及时发现错误，并且对出现的异常进行处理。在编写 strcpy 函数时，首先尽量使目的缓冲区长度足够长，另外要检测目的缓冲区和源缓冲区。如果目的缓冲区或源缓冲区是空，就要在异常处理中结束程序。如果，源字符串比目的缓冲区长度不长，也要在异常处理中结束程序，以防止出现溢出情况。任何程序都很难说是绝对安全，只能以尽可能安全的方式来处理 strcpy 函数。只要输入的字符串不以空字符结束，函数就会随时终止。这种检测容易实现。但是这样的检测也并不能确定函数一定安全。 [1] </p> 
<p>另外，每添加一个错误检查，就会使程序更复杂，而且可能产生很多的 bug，增加很多的工作量。最重要的是，即使设计程序时非常仔细，也有可能会忽略一些细节问题，导致不可弥补的错误。所以，在编写程序时，最安全的方法，就是尽可能不去使用 strcpy 函数。可以在程序的开头加上 #define strcpy Unsafe_strcpy。这样，就会使 strcpy 函数在编译时产生错误，从而使我们在编程时可以完全摒弃strcpy 函数。在完全丢弃 strcpy 函数的同时，也就丢掉了众多依附于 strcpy 函数的 bug。 [1]</p> 
<h3>特例说明</h3> 
<p>已知strcpy函数的原型是：</p> 
<p>char * strcpy(char * strDest,const char * strSrc);</p> 
<p>1.不调用<a href="https://baike.baidu.com/item/%E5%BA%93%E5%87%BD%E6%95%B0" rel="nofollow">库函数</a>，实现strcpy函数。</p> 
<p>2.解释为什么要返回char *。</p> 
<p><a name="4_1"></a><a name="sub1026861_4_1"></a><a name="%E4%B8%8D%E8%B0%83%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0strcpy%E5%87%BD%E6%95%B0"></a><a name="4-1"></a></p> 
<h4>不调用库函数如何实现strcpy函数</h4> 
<p>strcpy的实现代码</p> 
<pre><code>char * strcpy(char * strDest,const char * strSrc){
if ((NULL==strDest) || (NULL==strSrc)) 
  //[1]
  throw "Invalid argument(s)"; 
  //[2]
  char * strDestCopy = strDest; 
  //[3]
  while ((*strDest++=*strSrc++)!='\0'); 
  //[4]
  return strDestCopy;
}</code></pre> 
<p><strong>错误的做法[1]：</strong></p> 
<p>(A）不检查<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" rel="nofollow">指针</a>的有效性，说明答题者不注重代码的健壮性。</p> 
<p>（B）检查指针的有效性时使用（（！strDest)||(!strSrc））或（！（strDest&amp;&amp;strSrc）），说明答题者对C语言中类型的隐式转换没有深刻认识。在本例中char *转换为bool即是类型隐式转换，这种功能虽然灵活，但更多的是导致出错概率增大和维护成本升高。所以C++专门增加了bool、true、false三个<a href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">关键字</a>以提供更安全的<a href="https://baike.baidu.com/item/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">条件表达式</a>。</p> 
<p>（C）检查指针的有效性时使用（（strDest==0)||(strSrc==0）），说明答题者不知道使用<a href="https://baike.baidu.com/item/%E5%B8%B8%E9%87%8F" rel="nofollow">常量</a>的好处。直接使用字面常量（如本例中的0）会减少程序的可维护性。0虽然简单，但程序中可能出现很多处对指针的检查，万一出现笔误，<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8" rel="nofollow">编译器</a>不能发现，生成的程序内含逻辑错误，很难排除。而使用NULL代替0，如果出现拼写错误，编译器就会检查出来。</p> 
<p><strong>错误的做法[2]：</strong></p> 
<p>（A)return new string("Invalid argument(s)")；，说明答题者根本不知道返回值的用途，并且他对<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" rel="nofollow">内存泄漏</a>也没有警惕心。从函数中返回函数体内分配的内存是十分危险的做法，他把释放内存的义务抛给不知情的调用者，绝大多数情况下，调用者不会<a href="https://baike.baidu.com/item/%E9%87%8A%E6%94%BE/84934" rel="nofollow">释放</a>内存，这导致内存泄漏。</p> 
<p>（B)return 0；，说明答题者没有掌握异常机制。调用者有可能忘记检查返回值，调用者还可能无法检查返回值（见后面的链式表达式）。妄想让返回值肩负返回正确值和异常值的双重功能，其结果往往是两种功能都失效。应该以<a href="https://baike.baidu.com/item/%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8" rel="nofollow">抛出异常</a>来代替<a href="https://baike.baidu.com/item/%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow">返回值</a>，这样可以减轻调用者的负担、使错误不会被忽略、增强程序的可维护性。</p> 
<p><strong>错误的做法[3]：</strong></p> 
<p>（A）忘记保存原始的strDest值，说明答题者逻辑思维不严密。</p> 
<p><strong>错误的做法[4]：</strong></p> 
<p>（A）循环写成while (*strDestCopy++=*strSrc++）；，同[1]（B）。</p> 
<p>（B）循环写成while (*strSrc!='\0') *strDest++=*strSrc++；，说明答题者对边界条件的检查不力。循环体结束后，strDest字符串的末尾没有正确地加上'\0'。</p> 
<p><a name="4_2"></a><a name="sub1026861_4_2"></a><a name="4-2"></a></p> 
<h4>解释为什么要返回char *</h4> 
<p>返回strDest的原始值使函数能够支持链式<a href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">表达式</a>，增加了函数的“附加值”。同样功能的函数，如果能合理地提高的可用性，自然就更加理想。</p> 
<p>链式表达式的形式如：</p> 
<p>int iLength=strlen(strcpy(strA,strB));</p> 
<p>又如：</p> 
<p>char * strA=strcpy(new char[10],strB);</p> 
<p>返回strSrc的原始值是错误的。其一，源字符串肯定是已知的，返回它没有意义。其二，不能支持形如第二例的表达式。其三，为了保护源字符串，<a href="https://baike.baidu.com/item/%E5%BD%A2%E5%8F%82" rel="nofollow">形参</a>用const限定strSrc所指的内容，把const char *作为char *返回，类型不符，编译报错。</p> 
<p>在上面的语句中，<a href="https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5" rel="nofollow">循环语句</a></p> 
<p>while ((*strDestCopy++=*strSrc++)!='\0'）;</p> 
<p>较难理解，可以把这句理解为以下操作。</p> 
<p>第一种：</p> 
<pre><code>while( 1 ){    
  char temp;    
  *strDestCopy = *strSrc;  
  temp = *strSrc; 
  strDestCopy++;    
  strSrc++;   
  if( '\0' == temp )      
  break;
}</code></pre> 
<p> 第二种：</p> 
<pre><code>while ( *strSrc != '\0' ){
   *strDestCopy = *strSrc;
   strDestCopy++;
   strSrc++;
}
 
*strDestCopy = *strSrc;
   
也即：
 
while ( *strSrc != '\0' ){
   *strDestCopy++ = *strSrc++; 
}
 
*strDestCopy=‘\0’;</code></pre> 
<h4>使用实例</h4> 
<p><strong>//实例1：将一个字符串拷贝到一个足够长的字符数组中。本例中字符数组为a，长度为20。</strong></p> 
<p><strong>//缺点：若数组长度不足以容纳整个字符串，则程序运行崩溃。</strong></p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;stdlib.h&gt; 

using namespace std; 
char * strcpy( char * strDest, const char * strSrc ){  
  char * strDestCopy = strDest;  
  if ((NULL==strDest)||(NULL==strSrc))throw "Invalid argument";
    while ( (*strDest++=*strSrc++) != '\0' );
    return strDestCopy; 
}
  
int main( int argc, char * argv[] ){   
  char a[20], c[] = "i am teacher!";  
  try{   
       strcpy(a,c);
  }catch(char* strInfo){
       cout &lt;&lt; strInfo &lt;&lt; endl;
     exit(-1);
  }
   
  cout &lt;&lt; a &lt;&lt; endl;
  return 0;
 
}</code></pre> 
<p><strong>//实例2：预设两个字符指针，一个指向字符串，另一个为NULL，在程序运行过程中拷贝。</strong></p> 
<pre><code>#include&lt;iostream&gt; 
using namespace std;
 
char *strcpy(char *strDes, const char *strSrc);
//函数声明
 
int main(){   
  const char *strSrc="helloworld";
  char *strDes=NULL;   
  strDes=strcpy(strDes,strSrc);   
  cout&lt;&lt;"strSrc="&lt;&lt;strSrc&lt;&lt;endl;   
  cout&lt;&lt;"strDes="&lt;&lt;strDes&lt;&lt;endl;   
  if(strDes!=NULL) { 
     free(strDes);
     strDes=NULL; 
  }    
  return 0; 
}
 
char *strcpy(char *strDes, const char *strSrc){   
  assert(strSrc!=NULL); 
  //若strSrc为NULL，则抛出异常。  
  strDes=(char *)malloc(strlen(strSrc)+1);
  //多一个空间用来存储字符串结束符'\0'   
  char *p=strDes;   
  while(*strSrc!='\0'){    
    *p++=*strSrc++;
  }
    
  *p='\0';  
 return strDes;
 
}</code></pre> 
<pre><code>还有一种模拟算法：
 
char * strcpy(char *dest ,const char *src){
    char *p=dest;
    while (*src != '\0'){
        *dest = *src;
        dest++;src++;
    }
    *dest = '\0';
    return p;
}</code></pre> 
<h4>与strncpy的区别</h4> 
<p>第一种情况：</p> 
<pre><code>char* p="how are you ?";   
char name[20]="ABCDEFGHIJKLMNOPQRS";  
    strcpy(name,p);
    //name改变为"how are you ? "====&gt;正确！
    strncpy(name,p, sizeof(name));
    //name改变为"how are you ?" =====&gt;正确！后续的字符将置为NULL</code></pre> 
<p>第二种情况：</p> 
<pre><code>  char* p="how are you ?";
    char name[10];
    strcpy(name,p);
    //目标串长度小于源串,错误！
    name[sizeof(name)-1]='\0';
    //和上一步组合，弥补结果，但是这种做法并不可取，因为上一步出错处理方式并不确定
    strncpy(name,p,sizeof(name));
    //源串长度大于指定拷贝的长度sizeof(name)，注意在这种情况下不会自动在目标串后面加'\0'
    name[sizeof(name)-1]='\0'; 
    //和上一步组合，弥补结果</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51de55025624a302cd00eeb4e3e76bf8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">最简单的Shiro免密登陆（springboot）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/97d648e557f9699a82a75a10a54cc489/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c语言 * 和 **型指针</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>