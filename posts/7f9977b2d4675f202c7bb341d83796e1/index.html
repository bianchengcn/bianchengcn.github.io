<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Netty客户端发送消息并同步获取结果 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Netty客户端发送消息并同步获取结果" />
<meta property="og:description" content="客户端发送消息并同步获取结果，其实是违背Netty的设计原则的，但是有时候不得不这么做的话，那么建议进行如下的设计：
比如我们的具体用法如下：
NettyRequest request = new NettyRequest(); request.setRequestId(UUID.randomUUID().toString()); request.setClassName(method.getDeclaringClass().getName()); request.setMethodName(method.getName()); request.setParameterTypes(method.getParameterTypes()); request.setParameterValues(args); NettyMessage nettyMessage = new NettyMessage(); nettyMessage.setType(MessageType.SERVICE_REQ.value()); nettyMessage.setBody(request); if (serviceDiscovery != null) { serverAddress = serviceDiscovery.discover(); } String[] array = serverAddress.split(&#34;:&#34;); String host = array[0]; int port = Integer.parseInt(array[1]); NettyClient client = new NettyClient(host, port); NettyMessage nettyResponse = client.send(nettyMessage); if (nettyResponse != null) { return JSON.toJSONString(nettyResponse.getBody()); } else { return null; } 先来看看NettyClient的写法 和 send方法的写法：
public class NettyClient { /** * 日志记录 */ private static final Logger logger = LoggerFactory." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/7f9977b2d4675f202c7bb341d83796e1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-17T10:07:00+08:00" />
<meta property="article:modified_time" content="2019-04-17T10:07:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Netty客户端发送消息并同步获取结果</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>客户端发送消息并同步获取结果，其实是违背Netty的设计原则的，但是有时候不得不这么做的话，那么建议进行如下的设计：</p> 
 <p>比如我们的具体用法如下：</p> 
 <pre><code class="language-csharp">  NettyRequest request = <span class="kwrd">new</span> NettyRequest();
                request.setRequestId(UUID.randomUUID().toString());
                request.setClassName(method.getDeclaringClass().getName());
                request.setMethodName(method.getName());
                request.setParameterTypes(method.getParameterTypes());
                request.setParameterValues(args);

                NettyMessage nettyMessage = <span class="kwrd">new</span> NettyMessage();
                nettyMessage.setType(MessageType.SERVICE_REQ.<span class="kwrd">value</span>());
                nettyMessage.setBody(request);

                <span class="kwrd">if</span> (serviceDiscovery != <span class="kwrd">null</span>) {
                    serverAddress = serviceDiscovery.discover();
                }
                String[] array = serverAddress.split(<span class="str">":"</span>);
                String host = array[0];
                <span class="kwrd">int</span> port = Integer.parseInt(array[1]);

                NettyClient client = <span class="kwrd">new</span> NettyClient(host, port);
                NettyMessage nettyResponse = client.send(nettyMessage);
                <span class="kwrd">if</span> (nettyResponse != <span class="kwrd">null</span>) {
                    <span class="kwrd">return</span> JSON.toJSONString(nettyResponse.getBody());
                } <span class="kwrd">else</span> {
                    <span class="kwrd">return</span> <span class="kwrd">null</span>;
                }</code></pre> 
 <p> </p> 
 <p>先来看看NettyClient的写法 和 send方法的写法：</p> 
 <pre><code class="language-csharp"><span class="kwrd">public</span> <span class="kwrd">class</span> NettyClient {

    <span class="rem">/**</span>
<span class="rem">     * 日志记录</span>
<span class="rem">     */</span>
    <span class="kwrd">private</span> <span class="kwrd">static</span> final Logger logger = LoggerFactory.getLogger(NettyClient.<span class="kwrd">class</span>);

    <span class="rem">/**</span>
<span class="rem">     * 客户端业务处理handler</span>
<span class="rem">     */</span>
    <span class="kwrd">private</span> ClientHandler clientHandler = <span class="kwrd">new</span> ClientHandler();

    <span class="rem">/**</span>
<span class="rem">     * 事件池</span>
<span class="rem">     */</span>
    <span class="kwrd">private</span> EventLoopGroup group = <span class="kwrd">new</span> NioEventLoopGroup();

    <span class="rem">/**</span>
<span class="rem">     * 启动器</span>
<span class="rem">     */</span>
    <span class="kwrd">private</span> Bootstrap bootstrap = <span class="kwrd">new</span> Bootstrap();

    <span class="rem">/**</span>
<span class="rem">     * 客户端通道</span>
<span class="rem">     */</span>
    <span class="kwrd">private</span> Channel clientChannel;

    <span class="rem">/**</span>
<span class="rem">     * 客户端连接</span>
<span class="rem">     * @param host</span>
<span class="rem">     * @param port</span>
<span class="rem">     * @throws InterruptedException</span>
<span class="rem">     */</span>
    <span class="kwrd">public</span> NettyClient(String host, <span class="kwrd">int</span> port) throws InterruptedException {
        bootstrap.group(group)
                .channel(NioSocketChannel.<span class="kwrd">class</span>)
                .option(ChannelOption.TCP_NODELAY, <span class="kwrd">true</span>)
                .handler(<span class="kwrd">new</span> ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    <span class="kwrd">protected</span> <span class="kwrd">void</span> initChannel(SocketChannel channel) throws Exception {
                        channel.pipeline().addLast(<span class="str">"idleStateHandler"</span>, <span class="kwrd">new</span> IdleStateHandler(5, 5, 12));
                        channel.pipeline().addLast(<span class="str">"nettyMessageDecoder"</span>, <span class="kwrd">new</span> NettyMessageDecoder(1024 * 1024, 4, 4));
                        channel.pipeline().addLast(<span class="str">"nettyMessageEncoder"</span>, <span class="kwrd">new</span> NettyMessageEncoder());
                        channel.pipeline().addLast(<span class="str">"heartBeatHandler"</span>, <span class="kwrd">new</span> HeartBeatRequestHandler());
                        channel.pipeline().addLast(<span class="str">"clientHandler"</span>, clientHandler);
                        channel.pipeline().addLast(<span class="str">"loginAuthHandler"</span>, <span class="kwrd">new</span> LoginAuthRequestHandler());
                    }
                });

        <span class="rem">//发起同步连接操作</span>
        ChannelFuture channelFuture = bootstrap.connect(host, port);

        <span class="rem">//注册连接事件</span>
        channelFuture.addListener((ChannelFutureListener)future -&gt; {
            <span class="rem">//如果连接成功</span>
            <span class="kwrd">if</span> (future.isSuccess()) {
                logger.info(<span class="str">"客户端["</span> + channelFuture.channel().localAddress().toString() + <span class="str">"]已连接..."</span>);
                clientChannel = channelFuture.channel();
            }
            <span class="rem">//如果连接失败，尝试重新连接</span>
            <span class="kwrd">else</span>{
                logger.info(<span class="str">"客户端["</span> + channelFuture.channel().localAddress().toString() + <span class="str">"]连接失败，重新连接中..."</span>);
                future.channel().close();
                bootstrap.connect(host, port);
            }
        });

        <span class="rem">//注册关闭事件</span>
        channelFuture.channel().closeFuture().addListener(cfl -&gt; {
            close();
            logger.info(<span class="str">"客户端["</span> + channelFuture.channel().localAddress().toString() + <span class="str">"]已断开..."</span>);
        });
    }

    <span class="rem">/**</span>
<span class="rem">     * 客户端关闭</span>
<span class="rem">     */</span>
    <span class="kwrd">private</span> <span class="kwrd">void</span> close() {
        <span class="rem">//关闭客户端套接字</span>
        <span class="kwrd">if</span>(clientChannel!=<span class="kwrd">null</span>){
            clientChannel.close();
        }
        <span class="rem">//关闭客户端线程组</span>
        <span class="kwrd">if</span> (group != <span class="kwrd">null</span>) {
            group.shutdownGracefully();
        }
    }

    <span class="rem">/**</span>
<span class="rem">     * 客户端发送消息</span>
<span class="rem">     * @param message</span>
<span class="rem">     * @return</span>
<span class="rem">     * @throws InterruptedException</span>
<span class="rem">     * @throws ExecutionException</span>
<span class="rem">     */</span>
    <span class="kwrd">public</span> NettyMessage send(NettyMessage message) throws InterruptedException, ExecutionException {
        ChannelPromise promise = clientHandler.sendMessage(message);
        promise.await(3, TimeUnit.SECONDS);
        <span class="kwrd">return</span> clientHandler.getResponse();
    }
}</code></pre> 
 <p> </p> 
 <p>可以看出，我们使用了clientHandler来进行消息发送行为，通过promise阻塞来同步获取返回结果，接下来看看sendMessage的写法：</p> 
 <pre><code class="language-csharp"><span class="kwrd">public</span> <span class="kwrd">class</span> ClientHandler extends ChannelInboundHandlerAdapter {

    <span class="kwrd">private</span> <span class="kwrd">static</span> final Logger logger = LoggerFactory.getLogger(ClientHandler.<span class="kwrd">class</span>);

    <span class="kwrd">private</span> ChannelHandlerContext ctx;
    <span class="kwrd">private</span> ChannelPromise promise;
    <span class="kwrd">private</span> NettyMessage response;

    @Override
    <span class="kwrd">public</span> <span class="kwrd">void</span> channelActive(ChannelHandlerContext ctx) throws Exception {
        super.channelActive(ctx);
        <span class="kwrd">this</span>.ctx = ctx;
    }

    @Override
    <span class="kwrd">public</span> <span class="kwrd">void</span> channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        NettyMessage message = (NettyMessage) msg;
        <span class="kwrd">if</span> (message != <span class="kwrd">null</span> &amp;&amp; message.getType() == MessageType.SERVICE_RESP.<span class="kwrd">value</span>()) {
            response = message;
            promise.setSuccess();
        } <span class="kwrd">else</span> {
            ctx.fireChannelRead(msg);
        }
    }

    <span class="kwrd">public</span> synchronized ChannelPromise sendMessage(Object message) {
        <span class="kwrd">while</span> (ctx == <span class="kwrd">null</span>) {
            <span class="kwrd">try</span> {
                TimeUnit.MILLISECONDS.sleep(1);
                <span class="rem">//logger.error("等待ChannelHandlerContext实例化");</span>
            } <span class="kwrd">catch</span> (InterruptedException e) {
                logger.error(<span class="str">"等待ChannelHandlerContext实例化过程中出错"</span>,e);
            }
        }
        promise = ctx.newPromise();
        ctx.writeAndFlush(message);
        <span class="kwrd">return</span> promise;
    }

    <span class="kwrd">public</span> NettyMessage getResponse(){
        <span class="kwrd">return</span> response;
    }

}</code></pre> 
 <p> </p> 
 <p>可以看到，在利用ChannelHanderContext进行发送消息前，我们先创建了一个promise并返回给send方法，那么send方法此时就会阻塞等待；当我们收到服务端消息后，promise.setSuccess就会解除send方法的等待行为，这样我们就能获取结果了。</p> 
 <p> </p> 
 <p>此法针对真正需要同步等待获取结果的场景，如非必要，还是建议利用future来改造。</p> 
 <p> </p> 
 <p>benchmark测试表明，此种同步获取结果的行为，表现挺稳定的，但是ops 在 150 左右， 真是性能太差了。高性能场合禁用此法。</p> 
</div> 
<p>转载于:https://www.cnblogs.com/scy251147/p/10721736.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e1f6650269b86e391433bb2fd9e667b8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于python传参引发的一些思考</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2281b13e60ff281befb4341c1d6fea16/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue.js 动态文字向上滚动广播中奖信息代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>