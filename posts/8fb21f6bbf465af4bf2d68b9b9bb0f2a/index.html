<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Shiro免密登录 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Shiro免密登录" />
<meta property="og:description" content="目录
1.千篇一律
2.点睛之笔
所做项目与第三方合作，系统间存在接口调用，需要做授权登录。我们的项目整体使用SSM框架，认证登陆采用了shiro框架，密码在数据库中经过盐值(salt）&#43;Md5加密，外部无法获知密码明文，导致无法验证通过，所以想到了免密登录的方式解决。
在网上查阅了一些贴子，套路基本一样，照搬了全部代码，发现在强转AuthenticationToken为自定义Token时报错，父类无法强转为子类。经过研究源码，只需要再多复写一个类就可以解决。具体过程如下：
1.千篇一律 1)创建枚举类LoginType
/** * 登录类型 */ public enum LoginType { PASSWORD(&#34;password&#34;), // 密码登录 NOPASSWD(&#34;nopassword&#34;); // 免密登录 private String code;// 状态值 private LoginType(String code) { this.code = code; } public String getCode() { return code; } } 2)自定义token类CustomeToken，继承UsernamePasswordToken类,通过构造方法区分密码登录和免密登录。
/** * 自定义token 继承UsernamePasswordToken, * 账号密码登陆（password） 和 免密登陆（nopassword） */ public class CustomeToken extends UsernamePasswordToken { private static final long serialVersionUID = -2564928913725078138L; private LoginType type; public CustomeToken() { super(); } public CustomeToken(String username, String password, LoginType type, boolean rememberMe, String host) { super(username, password, rememberMe, host); this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8fb21f6bbf465af4bf2d68b9b9bb0f2a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-21T15:56:00+08:00" />
<meta property="article:modified_time" content="2019-06-21T15:56:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Shiro免密登录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="1.%E5%8D%83%E7%AF%87%E4%B8%80%E5%BE%8B-toc" style="margin-left:0px;"><a href="#1.%E5%8D%83%E7%AF%87%E4%B8%80%E5%BE%8B" rel="nofollow">1.千篇一律</a></p> 
 <p id="2.%E7%82%B9%E7%9D%9B%E4%B9%8B%E7%AC%94-toc" style="margin-left:0px;"><a href="#2.%E7%82%B9%E7%9D%9B%E4%B9%8B%E7%AC%94" rel="nofollow">2.点睛之笔</a></p> 
 <hr id="hr-toc"> 
</blockquote> 
<p>所做项目与第三方合作，系统间存在接口调用，需要做授权登录。我们的项目整体使用SSM框架，认证登陆采用了shiro框架，密码在数据库中经过盐值(salt）+Md5加密，外部无法获知密码明文，导致无法验证通过，所以想到了免密登录的方式解决。</p> 
<p>在网上查阅了一些贴子，套路基本一样，照搬了全部代码，发现在强转AuthenticationToken为自定义Token时报错，父类无法强转为子类。经过研究源码，只需要再多复写一个类就可以解决。具体过程如下：</p> 
<h2 id="1.%E5%8D%83%E7%AF%87%E4%B8%80%E5%BE%8B">1.千篇一律</h2> 
<p><strong>1)创建枚举类LoginType</strong></p> 
<pre class="has"><code class="language-java">/**
 * 登录类型
 */
public enum LoginType {
    PASSWORD("password"), // 密码登录
    NOPASSWD("nopassword"); // 免密登录
    private String code;// 状态值

    private LoginType(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }
}</code></pre> 
<p><strong>2)自定义token类CustomeToken，继承UsernamePasswordToken类,通过构造方法区分密码登录和免密登录。</strong></p> 
<pre class="has"><code class="language-java">/**
 * 自定义token 继承UsernamePasswordToken,
 *  账号密码登陆（password） 和 免密登陆（nopassword）
 */
public class CustomeToken extends UsernamePasswordToken {
    private static final long serialVersionUID = -2564928913725078138L;

    private LoginType type;


    public CustomeToken() {
        super();
    }


    public CustomeToken(String username, String password, LoginType type, boolean rememberMe, String host) {
        super(username, password, rememberMe, host);
        this.type = type;
    }

    /**
     * 免密登录
     */
    public CustomeToken(String username) {
        super(username, "", false, null);
        this.type = LoginType.NOPASSWD;
    }

    /**
     * 账号密码登录
     */
    public CustomeToken(String username, String password) {
        super(username, password, false, null);
        this.type = LoginType.PASSWORD;
    }

    public LoginType getType() {
        return type;
    }


    public void setType(LoginType type) {
        this.type = type;
    }
}</code></pre> 
<p><strong> 3）修改自定义的UserRealm，这个类继承了AuthorizingRealm类。将UsernamePasswordToken usertoken = (UsernamePasswordToken)token;修改为CostomToken usertoken = (CostomToken)token;</strong></p> 
<pre class="has"><code class="language-java">public class UserRealm extends AuthorizingRealm {

    @Autowired
    private UserService userService;

    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(
			PrincipalCollection principals) {

	String loginId = (String)principals.getPrimaryPrincipal();
	SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();
            return authorizationInfo;
	}

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(
			AuthenticationToken authcToken) throws AuthenticationException {

	//增加免密登录功能，使用自定义token
	CostomToken token = (CostomToken) authcToken;

	String loginId = (String)token.getPrincipal();

        User user = userService.findUserByLoginId(loginId);

        if(user == null) {
            throw new UnknownAccountException();
        }

        if(user.getState() != 0) {
            throw new LockedAccountException(); 
        }

        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(
                user.getLoginId(),
                user.getPassword(), 
                ByteSource.Util.bytes(user.getLoginId() + user.getSalt()),//salt=username+salt
                getName()  //realm name
        );
        return authenticationInfo;
	//	return null;
	}

}</code></pre> 
<p>4）自定义CostomCredentialsMatch类继承HashedCredentialsMatcher类，覆写其中的doCredentialsMatch方法，将token强转为自定义token,若loginType是免密登录，则直接返回true，否则执行父类比对。</p> 
<pre class="has"><code>public class CustomCredentialsMatch extends HashedCredentialsMatcher {
    private Cache&lt;String, AtomicInteger&gt; passwordRetryCache;

    public CustomCredentialsMatch (CacheManager cacheManager) {
        this.passwordRetryCache = cacheManager.getCache("passwordRetryCache");
    }

    @Override
    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {
        //增加免密登录功能，使用自定义token
        CustomToken usertoken = (CustomToken) token;

        //免密登录,不验证密码
        if (LoginType.NOPASSWD.equals(usertoken.getType())){
            return true;
        }

        String loginID = usertoken.getUsername();

        AtomicInteger retryTimes = passwordRetryCache.get(loginID);
        if (retryTimes == null) {
            retryTimes = new AtomicInteger(0);
            passwordRetryCache.put(loginID, retryTimes);
        }
        if (retryTimes.incrementAndGet() &gt; 5) {
            throw new ExcessiveAttemptsException();
        }
        boolean matches = super.doCredentialsMatch(token, info);
        if (matches)
            passwordRetryCache.remove(loginID);

        return matches;
    }
}</code></pre> 
<p><strong>5)LoginContoller调用 </strong></p> 
<ul><li><strong>密码登录</strong></li></ul> 
<pre class="has"><code class="language-java">Subject subject = SecurityUtils.getSubject();
UsernamePasswordToken token = new UsernamePasswordToken(username,password);
subject.login(token);
</code></pre> 
<ul><li><strong>免密登录</strong></li></ul> 
<pre class="has"><code>Subject subject = SecurityUtils.getSubject();
//增加免密登录功能，使用自定义token
CustomToken token = new CustomToken(username);
subject.login(token);</code></pre> 
<p>6)SSM框架下的配置文件spring/spring-client-shiro.xml的部分调整</p> 
<pre class="has"><code>&lt;bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"&gt;
   &lt;property name="cacheManagerConfigFile" value="classpath:ehcache/ehcache-shiro.xml"/&gt;
&lt;/bean&gt;

&lt;bean id="credentialsMatcher"
    class="com.xxfamly.service.security.credentials.CustomCredentialsMatch"&gt;
    &lt;constructor-arg ref="cacheManager" /&gt;
    &lt;property name="hashAlgorithmName" value="md5" /&gt;
    &lt;property name="hashIterations" value="3" /&gt;
    &lt;property name="storedCredentialsHexEncoded" value="true" /&gt;
&lt;/bean&gt;
    
&lt;!-- Realm实现 --&gt;
&lt;bean id="userRealm" class="com.xxfamly.service.security.UserRealm"&gt;
     &lt;property name="credentialsMatcher" ref="credentialsMatcher"/&gt;
     &lt;property name="cachingEnabled" value="false"/&gt;
&lt;/bean&gt;</code></pre> 
<p>到这为止，网上的贴子基本如此，有人可能成功实现免密登录了，但是我没有成功，在认证的时候报强转失败，那么我们来看接下来怎么做。</p> 
<h2 id="2.%E7%82%B9%E7%9D%9B%E4%B9%8B%E7%AC%94">2.点睛之笔</h2> 
<p><strong>1）分析源码</strong></p> 
<p>shiro集成到springMVC中的方法，大家可以去百度中查阅，其中几个关键点这里提一下。</p> 
<p><strong>1.1）web.xml中配置拦截器</strong></p> 
<p><img alt="" class="has" height="307" src="https://images2.imgbox.com/f1/1d/IdqpQuKm_o.png" width="1086"></p> 
<p><strong>1.2）spring/spring-client-shiro.xml中配置各种过滤器</strong></p> 
<p><img alt="" class="has" height="375" src="https://images2.imgbox.com/b8/df/pdgJaS7T_o.png" width="1078"></p> 
<p><img alt="" class="has" height="146" src="https://images2.imgbox.com/27/e6/EZsuniHg_o.png" width="1200"></p> 
<p><strong>1.3）看FormAuthenticationFilter类源码</strong></p> 
<p><img alt="" class="has" height="601" src="https://images2.imgbox.com/cb/fe/H9N2V0Uz_o.png" width="1200"></p> 
<p><strong>2）覆写FormAuthenticationFilter类的父类AuthenticatingFilter中的createToken方法</strong></p> 
<ul><li>原写法</li></ul> 
<p><img alt="" class="has" height="139" src="https://images2.imgbox.com/4e/09/km3VpnNK_o.png" width="953"></p> 
<ul><li>新方法</li></ul> 
<pre class="has"><code class="language-java">public class CustomFormAuthenticationFilter extends FormAuthenticationFilter {
    @Override
    protected AuthenticationToken createToken(String username, String password,
                                              boolean rememberMe, String host) {
        //增加免密登录功能，使用自定义token
        return new CustomToken(username, password, LoginType.PASSWORD, rememberMe, host);
    }
}</code></pre> 
<p><strong>3)配置文件修改</strong></p> 
<pre class="has"><code class="language-java">&lt;!--增加免密登录功能，使用自定义token--&gt;
    &lt;!--&lt;bean id="formAuthenticationFilter" class="org.apache.shiro.web.filter.authc.FormAuthenticationFilter"&gt;--&gt;
    &lt;bean id="formAuthenticationFilter" class="com.xxfamly.service.security.filter.CustomFormAuthenticationFilter"&gt;
        &lt;property name="usernameParam" value="username"/&gt;
        &lt;property name="passwordParam" value="password"/&gt;
        &lt;property name="rememberMeParam" value="rememberMe"/&gt;
    &lt;/bean&gt;</code></pre> 
<p>至此，彻底完成了免密登录的改造。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0e0b9ef3dd3fc27799c5d903eba52c58/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity网格变形开源库测评</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/89b506c3bf1551fc6060c40f543bf299/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PCL学习笔记——利用kdtree计算点云点距均值</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>