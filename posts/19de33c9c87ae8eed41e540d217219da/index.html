<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java二进制和位运算，这一万字准能喂饱你 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java二进制和位运算，这一万字准能喂饱你" />
<meta property="og:description" content="点击上方“BAT的乌托邦”，选择“设为星标”
后台回复“专栏”，开启专栏模式学习
✍前言 你好，我是YourBatman。
本号正在连载Jackson深度解析系列，虽然目前还只讲到了其「流式API」层面，但已接触到其多个Feature特征。更为重要的是我在文章里赞其设计精妙，处理优雅，因此就有小伙伴私信给我问这样的话：题外话：Jackson这个话题本就非常小众，看着阅读量我自己都快没信心写下去。但自己说过的话就是「欠下的债」，熬夜也得把承诺的付费内容给公开完了，毕竟还有那么几个人在白嫖不是????。
❝ 话外音：以后闷头做事，少吹牛逼┭┮﹏┭┮
❞ 虽然小众，竟然还有想深入了解一波的小伙伴，确实让我为之振奋了那么三秒。既然如此那就干吧，本文就先行来认识认识「Java中的位运算」。位运算在Java中很少被使用，那么为何Jackson里爱不释手呢？一切就为两字：「性能」/「高效」。用计算机能直接看懂的语言跟它打交道，你说快不快，不用多想嘛。
✍正文 提及位运算，对绝大多数Java程序员来说，是一种「既熟悉又陌生」的感觉。熟悉是因为你在学JavaSE时肯定学过，并且在看一些开源框架（特别是JDK源码）时都能看到它的身影；陌生是因为大概率我们不会去使用它。当然，不能“流行”起来是有原因的：不好理解，不符合人类的思维，阅读性差…...
❝ 小贴士：一般来说，程序让人看懂远比被机器看懂来得更重要些
❞ 位运算它在low-level的语言里使用得比较多，但是对于Java这种高级语言它就很少被提及了。虽然我们使用得很少但Java也是支持的，毕竟很多时候使用位运算才是「最佳实践」。
位运算在日常开发中使用得较少，但是巧妙的使用位运算可以大量减少运行开销，优化算法。「一条语句可能对代码没什么影响，但是在高重复，大数据量的情况下将会节省很多开销。」
二进制 在了解什么是位运算之前，十分有必要先科普下二进制的概念。
二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是「逢二进一」，借位规则是「借一当二」。因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。
❝ 小贴士：半导体开代表1，关代表0，这也就是CPU计算的最底层原理????
❞ 先看一个例子：
求 1011（二进制）&#43; 11（二进制） 的和？ 结果为：1110（二进制） 二进制理解起来非常非常的简单，比10进制简单多了。你可能还会思考二进制怎么和十进制互转呢？毕竟1110这个也看不到啊。有或者往深了继续思考：如何转为八进制、十六进制、三十二进制......进制转换并非本文所想讲述的内容，请有兴趣者自行度娘。
二进制与编码 这个虽然和本文内容关联系并不是很大，但顺带捞一捞，毕竟编码问题在开发中还是比较常见的。
计算机能识别的只有1和0，也就是二进制，1和0可以表达出全世界的「所有」文字和语言符号。那如何表达文字和符号呢？这就涉及到「字符编码」了。字符编码强行将每一个字符对应一个十进制数字（请注意字符和数字的区别，比如0字符对应的十进制数字是48），再将十进制数字转换成计算机理解的二进制，而计算机读到这些1和0之后就会显示出对应的文字或符号。
一般对「英文字符」而言，一个字节表示一个字符，但是对汉字而言，由于低位的编码已经被使用(早期计算机并不支持中文，因此为了扩展支持，唯一的办法就是采用更多的字节数)只好向高位扩展
字符集编码的范围utf-8&gt;gbk&gt;iso-8859-1(latin1)&gt;ascll。ascll编码是美国标准信息交换码的英文缩写，包含了常用的字符，如阿拉伯数字，英文字母和一些打印符号共255个（一般说成共128个字符问题也不大）
❝ UTF-8：一套以 8 位为一个编码单位的「可变长」编码，会将一个码位（Unicode）编码为1到4个字节（英文1字节，大部分汉字3字节）。
❞ Java中的二进制 在Java7版本以前，Java是不支持直接书写除十进制以外的其它进制字面量。但这在Java7以及以后版本就允许了：
二进制：前置0b/0B
八进制：前置0
十进制：默认的，无需前置
十六进制：前置0x/0X
@Test public void test1() { //二进制 int i = 0B101; System.out.println(i); //5 System.out.println(Integer.toBinaryString(i)); //八进制 i = 0101; System.out.println(i); //65 System.out.println(Integer.toBinaryString(i)); //十进制 i = 101; System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/19de33c9c87ae8eed41e540d217219da/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-08T14:10:00+08:00" />
<meta property="article:modified_time" content="2020-11-08T14:10:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java二进制和位运算，这一万字准能喂饱你</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align: left"><img src="https://images2.imgbox.com/33/05/CjN19qDw_o.png"></p> 
 <p style="text-align: center">点击上方“BAT的乌托邦”，选择“设为星标”<br></p> 
 <p style="text-align: center">后台回复“专栏”，开启<strong>专栏模式</strong>学习</p> 
 <h2>✍前言</h2> 
 <p>你好，我是YourBatman。</p> 
 <p>本号正在连载Jackson深度解析系列，虽然目前还只讲到了其<strong>「流式API」</strong>层面，但已接触到其多个<code>Feature</code>特征。更为重要的是我在文章里赞其设计精妙，处理优雅，因此就有小伙伴私信给我问这样的话：<img src="https://images2.imgbox.com/e5/f2/anAUTLqt_o.png">题外话：Jackson这个话题本就非常小众，看着阅读量我自己都快没信心写下去。但自己说过的话就是<strong>「欠下的债」</strong>，熬夜也得把承诺的付费内容给公开完了，毕竟还有那么几个人在白嫖不是????。</p> 
 <blockquote> 
  ❝ 
  <p>话外音：以后闷头做事，少吹牛逼┭┮﹏┭┮</p> 
  ❞ 
 </blockquote> 
 <p>虽然小众，竟然还有想深入了解一波的小伙伴，确实让我为之振奋了那么三秒。既然如此那就干吧，本文就先行来认识认识<strong>「Java中的位运算」</strong>。位运算在Java中很少被使用，那么为何Jackson里爱不释手呢？一切就为两字：<strong>「性能」</strong>/<strong>「高效」</strong>。用计算机能直接看懂的语言跟它打交道，你说快不快，不用多想嘛。<img src="https://images2.imgbox.com/95/4f/jbVOwyYS_o.png"></p> 
 <h2>✍正文</h2> 
 <p>提及位运算，对绝大多数Java程序员来说，是一种<strong>「既熟悉又陌生」</strong>的感觉。熟悉是因为你在学JavaSE时肯定学过，并且在看一些开源框架（特别是JDK源码）时都能看到它的身影；陌生是因为大概率我们不会去使用它。当然，不能“流行”起来是有原因的：不好理解，不符合人类的思维，阅读性差…...</p> 
 <blockquote> 
  ❝ 
  <p>小贴士：一般来说，程序让人看懂远比被机器看懂来得更重要些</p> 
  ❞ 
 </blockquote> 
 <p>位运算它在<code>low-level</code>的语言里使用得比较多，但是对于Java这种高级语言它就很少被提及了。虽然我们使用得很少但Java也是支持的，毕竟很多时候使用位运算才是<strong>「最佳实践」</strong>。</p> 
 <p>位运算在日常开发中使用得较少，但是巧妙的使用位运算可以大量减少运行开销，优化算法。<strong>「一条语句可能对代码没什么影响，但是在高重复，大数据量的情况下将会节省很多开销。」</strong></p> 
 <h3>二进制</h3> 
 <p>在了解什么是位运算之前，十分有必要先科普下二进制的概念。</p> 
 <p>二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是<strong>「逢二进一」</strong>，借位规则是<strong>「借一当二」</strong>。因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。</p> 
 <blockquote> 
  ❝ 
  <p>小贴士：半导体开代表1，关代表0，这也就是CPU计算的最底层原理????</p> 
  ❞ 
 </blockquote> 
 <p>先看一个例子：</p> 
 <pre class="has"><code class="language-go">求 1011（二进制）+ 11（二进制） 的和？
结果为：1110（二进制）
</code></pre> 
 <p>二进制理解起来非常非常的简单，比10进制简单多了。你可能还会思考二进制怎么和十进制互转呢？毕竟1110这个也看不到啊。有或者往深了继续思考：如何转为八进制、十六进制、三十二进制......进制转换并非本文所想讲述的内容，请有兴趣者自行度娘。</p> 
 <h4>二进制与编码</h4> 
 <p>这个虽然和本文内容关联系并不是很大，但顺带捞一捞，毕竟编码问题在开发中还是比较常见的。</p> 
 <p>计算机能识别的只有1和0，也就是二进制，1和0可以表达出全世界的<strong>「所有」</strong>文字和语言符号。那如何表达文字和符号呢？这就涉及到<strong>「字符编码」</strong>了。字符编码强行将每一个字符对应一个十进制数字（请注意字符和数字的区别，比如<code>0</code>字符对应的十进制数字是<code>48</code>），再将十进制数字转换成计算机理解的二进制，而计算机读到这些1和0之后就会显示出对应的文字或符号。</p> 
 <ul><li><p>一般对<strong>「英文字符」</strong>而言，一个字节表示一个字符，但是对汉字而言，由于低位的编码已经被使用(早期计算机并不支持中文，因此为了扩展支持，唯一的办法就是采用更多的字节数)只好向高位扩展</p></li><li><p>字符集编码的范围<code>utf-8&gt;gbk&gt;iso-8859-1(latin1)&gt;ascll</code>。ascll编码是美国标准信息交换码的英文缩写，包含了常用的字符，如阿拉伯数字，英文字母和一些打印符号共255个（一般说成共128个字符问题也不大）</p></li></ul> 
 <blockquote> 
  ❝ 
  <p><code>UTF-8</code>：一套以 8 位为一个编码单位的<strong>「可变长」</strong>编码，会将一个码位（Unicode）编码为1到4个字节（英文1字节，大部分汉字3字节）。</p> 
  ❞ 
 </blockquote> 
 <h3>Java中的二进制</h3> 
 <p>在Java7版本以前，Java是不支持直接书写除十进制以外的其它进制字面量。但这在Java7以及以后版本就允许了：</p> 
 <ul><li><p>二进制：前置0b/0B</p></li><li><p>八进制：前置0</p></li><li><p>十进制：默认的，无需前置</p></li><li><p>十六进制：前置0x/0X</p></li></ul> 
 <pre class="has"><code class="language-go">@Test
public void test1() {
    //二进制
    int i = 0B101;
    System.out.println(i); //5
    System.out.println(Integer.toBinaryString(i));
    //八进制
    i = 0101;
    System.out.println(i); //65
    System.out.println(Integer.toBinaryString(i));
    //十进制
    i = 101;
    System.out.println(i); //101
    System.out.println(Integer.toBinaryString(i));
    //十六进制
    i = 0x101;
    System.out.println(i); //257
    System.out.println(Integer.toBinaryString(i));
}
</code></pre> 
 <p>结果程序，输出：</p> 
 <pre class="has"><code class="language-go">5
101
65
1000001
101
1100101
257
100000001
</code></pre> 
 <p>说明：<code>System.out.println()</code>会先自动转为10进制后再输出的；<code>toBinaryString()</code>表示转换为二进制进行<strong>「字符串」</strong>进行输出。</p> 
 <h4>便捷的进制转换API</h4> 
 <p>JDK自<code>1.0</code>开始便提供了非常便捷的进制转换的API，这在我们有需要时非常有用。</p> 
 <pre class="has"><code class="language-go">@Test
public void test2() {
    int i = 192;
    System.out.println("---------------------------------");
    System.out.println("十进制转二进制：" + Integer.toBinaryString(i)); //11000000
    System.out.println("十进制转八进制：" + Integer.toOctalString(i)); //300
    System.out.println("十进制转十六进制：" + Integer.toHexString(i)); //c0
    System.out.println("---------------------------------");
    // 统一利用的为Integer的valueOf()方法,parseInt方法也是ok的
    System.out.println("二进制转十进制：" + Integer.valueOf("11000000", 2).toString()); //192
    System.out.println("八进制转十进制：" + Integer.valueOf("300", 8).toString()); //192
    System.out.println("十六进制转十进制：" + Integer.valueOf("c0", 16).toString()); //192
    System.out.println("---------------------------------");
}
</code></pre> 
 <p>运行程序，输出：</p> 
 <pre class="has"><code class="language-go">---------------------------------
十进制转二进制：11000000
十进制转八进制：300
十进制转十六进制：c0
---------------------------------
二进制转十进制：192
八进制转十进制：192
十六进制转十进制：192
---------------------------------
</code></pre> 
 <h4>如何证明Long是64位的？</h4> 
 <p>我相信每个Javaer都知道Java中的Long类型占8个字节（64位），那如何证明呢？</p> 
 <blockquote> 
  ❝ 
  <p>小贴士：这算是一道经典面试题，至少我提问过多次~</p> 
  ❞ 
 </blockquote> 
 <p>有个最简单的方法：拿到Long类型的<strong>「最大值」</strong>，用2进制表示转换成字符串看看长度就行了，代码如下：</p> 
 <pre class="has"><code class="language-go">@Test
public void test3() {
    long l = 100L;
    //如果不是最大值 前面都是0  输出的时候就不会有那么长了（所以下面使用最大/最小值示例）
    System.out.println(Long.toBinaryString(l)); //1100100
    System.out.println(Long.toBinaryString(l).length()); //7

    System.out.println("---------------------------------------");

    l = Long.MAX_VALUE; // 2的63次方 - 1
    //正数长度为63为（首位为符号位，0代表正数，省略了所以长度是63）
    //111111111111111111111111111111111111111111111111111111111111111
    System.out.println(Long.toBinaryString(l));
    System.out.println(Long.toBinaryString(l).length()); //63

    System.out.println("---------------------------------------");

    l = Long.MIN_VALUE; // -2的63次方
    //负数长度为64位（首位为符号位，1代表负数）
    //1000000000000000000000000000000000000000000000000000000000000000
    System.out.println(Long.toBinaryString(l));
    System.out.println(Long.toBinaryString(l).length()); //64
}
</code></pre> 
 <p>运行程序，输出：</p> 
 <pre class="has"><code class="language-go">1100100
7
---------------------------------------
111111111111111111111111111111111111111111111111111111111111111
63
---------------------------------------
1000000000000000000000000000000000000000000000000000000000000000
64
</code></pre> 
 <p>说明：在计算机中，负数以其正值的<strong>「补码」</strong>的形式表达。因此，用同样的方法你可以自行证明Integer类型是32位的（占4个字节）。</p> 
 <h3>Java中的位运算</h3> 
 <img src="https://images2.imgbox.com/5b/a8/NKgrTsqs_o.png"> 
 <p>Java语言支持的位运算符还是非常多的，列出如下：</p> 
 <ul><li><p><code>&amp;</code>：按位与</p></li><li><p><code>|</code>：按位或</p></li><li><p><code>~</code>：按位非</p></li><li><p><code>^</code>：按位异或</p></li><li><p><code>&lt;&lt;</code>：左位移运算符</p></li><li><p><code>&gt;&gt;</code>：右位移运算符</p></li><li><p><code>&gt;&gt;&gt;</code>：无符号右移运算符</p></li></ul> 
 <p>除<code>～</code>以 外，其余均为<strong>「二元」</strong>运算符，操作的数据只能是整型（长短均可）或者char字符型。针对这些运算类型，下面分别给出示例，一目了然。</p> 
 <p>既然是运算，依旧可以分为简单运算和复合运算两大类进行归类和讲解。</p> 
 <blockquote> 
  ❝ 
  <p>小贴士：为了便于理解，字面量例子我就都使用二进制表示了，使用十进制（任何进制）不影响运算结果</p> 
  ❞ 
 </blockquote> 
 <h4>简单运算</h4> 
 <p>简单运算，顾名思义，一次只用一个运算符。</p> 
 <h5>&amp;：按位与</h5> 
 <p>操作规则：<strong>「同为1则1，否则为0」</strong>。仅当两个操作数都为1时，输出结果才为1，否则为0。</p> 
 <blockquote> 
  ❝ 
  <p>说明：1、本示例（下同）中所有的字面值使用的都是十进制表示的，理解的时候请用二进制思维去理解；2、关于负数之间的位运算本文章统一不做讲述</p> 
  ❞ 
 </blockquote> 
 <pre class="has"><code class="language-go">@Test
public void test() {
    int i = 0B100; // 十进制为4
    int j = 0B101; // 十进制为5

    // 二进制结果：100
    // 十进制结果：4
    System.out.println("二进制结果：" + Integer.toBinaryString(i &amp; j));
    System.out.println("十进制结果：" + (i &amp; j));
}
</code></pre> 
 <h5>|：按位或</h5> 
 <p>操作规则：<strong>「同为0则0，否则为1」</strong>。仅当两个操作数都为0时，输出的结果才为0。</p> 
 <pre class="has"><code class="language-go">@Test
public void test() {
    int i = 0B100; // 十进制为4
    int j = 0B101; // 十进制为5

    // 二进制结果：101
    // 十进制结果：5
    System.out.println("二进制结果：" + Integer.toBinaryString(i | j));
    System.out.println("十进制结果：" + (i | j));
}
</code></pre> 
 <h5>~：按位非</h5> 
 <p>操作规则：<strong>「0为1，1为0」</strong>。全部的0置为1，1置为0。</p> 
 <blockquote> 
  ❝ 
  <p>小贴士：请务必注意是全部的，别忽略了正数前面的那些0哦~</p> 
  ❞ 
 </blockquote> 
 <pre class="has"><code class="language-go">@Test
public void test() {
    int i = 0B100; // 十进制为4

    // 二进制结果：11111111111111111111111111111011
    // 十进制结果：-5
    System.out.println("二进制结果：" + Integer.toBinaryString(~i));
    System.out.println("十进制结果：" + (~i));
}
</code></pre> 
 <h5>^：按位异或</h5> 
 <p>操作规则：<strong>「相同为0，不同为1」</strong>。操作数不同时（1遇上0，0遇上1）对应的输出结果才为1，否则为0。</p> 
 <pre class="has"><code class="language-go">@Test
public void test() {
    int i = 0B100; // 十进制为4
    int j = 0B101; // 十进制为5

    // 二进制结果：1
    // 十进制结果：1
    System.out.println("二进制结果：" + Integer.toBinaryString(i ^ j));
    System.out.println("十进制结果：" + (i ^ j));
}
</code></pre> 
 <h5>&lt;&lt;：按位左移</h5> 
 <p>操作规则：把一个数的<strong>「全部位数」</strong>都向左移动若干位。</p> 
 <pre class="has"><code class="language-go">@Test
public void test() {
    int i = 0B100; // 十进制为4

    // 二进制结果：100000
    // 十进制结果：32 = 4 * (2的3次方)
    System.out.println("二进制结果：" + Integer.toBinaryString(i &lt;&lt; 2));
    System.out.println("十进制结果：" + (i &lt;&lt; 3));
}
</code></pre> 
 <p>左移<strong>「用得非常多」</strong>，理解起来并不费劲。x左移N位，效果同十进制里直接乘以2的N次方就行了，但是需要注意值<strong>「溢出」</strong>的情况，使用时稍加注意。</p> 
 <h5>&gt;&gt;：按位右移</h5> 
 <p>操作规则：把一个数的<strong>「全部位数」</strong>都向右移动若干位。</p> 
 <pre class="has"><code class="language-go">@Test
public void test() {
    int i = 0B100; // 十进制为4

    // 二进制结果：10
    // 十进制结果：2
    System.out.println("二进制结果：" + Integer.toBinaryString(i &gt;&gt; 1));
    System.out.println("十进制结果：" + (i &gt;&gt; 1));
}
</code></pre> 
 <p>负数右移：</p> 
 <pre class="has"><code class="language-go">@Test
public void test() {
    int i = -0B100; // 十进制为-4

    // 二进制结果：11111111111111111111111111111110
    // 十进制结果：-2
    System.out.println("二进制结果：" + Integer.toBinaryString(i &gt;&gt; 1));
    System.out.println("十进制结果：" + (i &gt;&gt; 1));
}
</code></pre> 
 <p>右移用得也比较多，也比较理解：操作其实就是把二进制数<strong>「右边的N位」</strong>直接<strong>「砍掉」</strong>，然后<code>正数右移高位补0，负数右移高位补1</code>。</p> 
 <h5>&gt;&gt;&gt;：无符号右移</h5> 
 <blockquote> 
  ❝ 
  <p>注意：没有无符号左移，并没有<code>&lt;&lt;&lt;</code>这个符号的</p> 
  ❞ 
 </blockquote> 
 <p>它和<code>&gt;&gt;</code>有符号右移的区别是：无论是正数还是负数，<strong>「高位通通补0」</strong>。所以说对于正数而言，没有区别；那么看看对于负数的表现：</p> 
 <pre class="has"><code class="language-go">@Test
public void test() {
    int i = -0B100; // 十进制为-4

    // 二进制结果：11111111111111111111111111111110（&gt;&gt;的结果）
 // 二进制结果：1111111111111111111111111111110（&gt;&gt;&gt;的结果）
    // 十进制结果：2147483646
    System.out.println("二进制结果：" + Integer.toBinaryString(i &gt;&gt;&gt; 1));
    System.out.println("十进制结果：" + (i &gt;&gt;&gt; 1));
}
</code></pre> 
 <p>我特意把&gt;&gt;的结果放上面了，方便你对比。因为高位补的是0，所以就没有显示啦，但是你心里应该清楚是怎么回事。</p> 
 <h4>复合运算</h4> 
 <p>广义上的复合运算指的是多个运算<strong>「嵌套起来」</strong>，通常这些运算都是同种类型的。这里指的复合运算指的就是和=号一起来使用，类似于<code>+= -=</code>。本来这属于基础常识不用做单独解释，但谁让A哥管生管养，管杀管埋呢????。</p> 
 <blockquote> 
  ❝ 
  <p>混合运算：指同一个算式里包含了bai多种运算符，如加减乘除乘方开du方等。</p> 
  ❞ 
 </blockquote> 
 <p>以&amp;与运算为例，其它类同：</p> 
 <pre class="has"><code class="language-go">@Test
public void test() {
    int i = 0B110; // 十进制为6
    i &amp;= 0B11; // 效果同：i = i &amp; 3

 // 二进制结果：10
 // 十进制结果：2
    System.out.println("二进制结果：" + Integer.toBinaryString(i));
    System.out.println("十进制结果：" + (i));
}
</code></pre> 
 <p>复习一下<code>&amp;</code>的运算规则是：<strong>「同为1则1，否则为0」</strong>。</p> 
 <h3>位运算使用场景示例</h3> 
 <p>位运算除了<strong>「高效」</strong>的特点，还有一个特点在应用场景下不容忽视：<strong>「计算的可逆性」</strong>。通过这个特点我们可以用来达到<strong>「隐蔽数据」</strong>的效果，并且还保证了效率。</p> 
 <p>在JDK的原码中。有很多初始值都是通过位运算计算的。最典型的如HashMap：</p> 
 <pre class="has"><code class="language-go">HashMap:
 
 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
</code></pre> 
 <p>位运算有很多优良特性，能够在<strong>「线性增长」</strong>的数据中起到作用。且对于一些运算，位运算是最直接、最简便的方法。下面我安排一些具体示例（一般都是面试题），感受一把。</p> 
 <h4>判断两个数字符号是否相同</h4> 
 <p>同为正数or同为负数都表示相同，否则为不同。像这种小小case用十进制加上<code>&gt;/&lt;</code>比较符当然可以做，但用位运算符处理来得更加直接（效率最高）：</p> 
 <pre class="has"><code class="language-go">@Test
public void test4() {
    int i = 100;
    int j = -2;

    System.out.println(((i &gt;&gt; 31) ^ (j &gt;&gt; 31)) == 0);

    j = 10;
    System.out.println(((i &gt;&gt; 31) ^ (j &gt;&gt; 31)) == 0);
}
</code></pre> 
 <p>运行程序，输出：</p> 
 <pre class="has"><code class="language-go">false
true
</code></pre> 
 <p>int类型共32bit，右移31位那么就只剩下1个符号位了（因为是<strong>「带符号右移动」</strong>，所以正数剩0负数剩1），再对两个符号位做<code>^</code>异或操作结果为0就表明二者一致。</p> 
 <blockquote> 
  ❝ 
  <p>复习一下<code>^</code>异或操作规则：<strong>「相同为0，不同为1」</strong>。</p> 
  ❞ 
 </blockquote> 
 <h4>判断一个数的奇偶性</h4> 
 <p>在十进制数中可以通过和2取余来做，对于位运算有一个更为<strong>「高效」</strong>的方式：</p> 
 <pre class="has"><code class="language-go">@Test
public void test5() {
    System.out.println(isEvenNum(1)); //false
    System.out.println(isEvenNum(2)); //true
    System.out.println(isEvenNum(3)); //false
    System.out.println(isEvenNum(4)); //true
    System.out.println(isEvenNum(5)); //false
}

/**
 * 是否为偶数
 */
private static boolean isEvenNum(int n) {
    return (n &amp; 1) == 0;
}
</code></pre> 
 <p>为何<code>&amp;1</code>能判断基偶性？因为在二进制下<strong>「偶数的末位肯定是0，奇数的最低位肯定是1」</strong>。而二进制的1它的前31位均为0，所以在和其它数字的前31位<strong>「与运算」</strong>后肯定所有位数都是0（无论是1&amp;0还是0&amp;0结果都是0），那么唯一区别就是看最低位和1进行与运算的结果喽：结果为1表示奇数，反则结果为0就表示偶数。</p> 
 <h4>交换两个数的值（不借助第三方变量）</h4> 
 <p>这是一个很古老的面试题了，交换A和B的值。本题如果没有括号里那几个字，是一道大家都会的题目，可以这么来解：</p> 
 <pre class="has"><code class="language-go">@Test
public void test6() {
    int a = 3, b = 5;
    System.out.println(a + "-------" + b);
    a = a + b;
    b = a - b;
    a = a - b;
    System.out.println(a + "-------" + b);
}
</code></pre> 
 <p>运行程序，输出（成功交换）：</p> 
 <pre class="has"><code class="language-go">3-------5
5-------3
</code></pre> 
 <p>使用这种方式最大的好处是：容易理解。最大的坏处是：<strong>「a+b,可能会超出int型的最大范围，造成精度丢失导致错误，造成非常隐蔽的bug」</strong>。所以若你这样运用在生产环境的话，是有比较大的安全隐患的。</p> 
 <blockquote> 
  ❝ 
  <p>小贴士：如果你们评估数字<strong>「绝无可能」</strong>超过最大值，这种做法尚可。当然如果你是字符串类型，请当我没说</p> 
  ❞ 
 </blockquote> 
 <p>因为这种方式既引入了第三方变量，又存在重大安全隐患。所以本文介绍一种安全的替代方式，借助位运算的<strong>「可逆性」</strong>来完成操作：</p> 
 <pre class="has"><code class="language-go">@Test
public void test7() {
    // 这里使用最大值演示，以证明这样方式是不会溢出的
    int a = Integer.MAX_VALUE, b = Integer.MAX_VALUE - 10;
    System.out.println(a + "-------" + b);
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
    System.out.println(a + "-------" + b);
}
</code></pre> 
 <p>运行程序，输出（成功完成交换）：</p> 
 <pre class="has"><code class="language-go">2147483647-------2147483637
2147483637-------2147483647
</code></pre> 
 <p>由于全文都没有对a/b做加法运算，因此不能出现溢出现象，所以是安全的。这种做法的核心原理依据是：<strong>「位运算的可逆性」</strong>，使用异或来达成目的。</p> 
 <h4>位运算用在数据库字段上（重要）</h4> 
 <p>这个使用case是<strong>「极具」</strong>实际应用意义的，因为在生产上我以用过多次，感觉不是一般的好。</p> 
 <p>业务系统中数据库设计的尴尬现象：通常我们的数据表中可能会包含各种状态属性， 例如 blog表中，我们需要有字段表示其是否公开，是否有设置密码，是否被管理员封锁，是否被置顶等等。<strong>「也会遇到在后期运维中，策划要求增加新的功能而造成你需要增加新的字段」</strong>，这样会造成后期的维护困难，字段过多，索引增大的情况， 这时使用位运算就可以<strong>「巧妙的」</strong>解决。</p> 
 <p>举个例子：我们在网站上进行认证授权的时候，一般支持多种授权方式，比如：</p> 
 <ul><li><p>个人认证  0001 -&gt; 1</p></li><li><p>邮箱认证  0010 -&gt; 2</p></li><li><p>微信认证  0100 -&gt; 4</p></li><li><p>超管认证  1000 -&gt; 8</p></li></ul> 
 <p>这样我们就可以使用<code>1111</code>这四位来表达各自位置的认证与否。要查询通过微信认证的条件语句如下：</p> 
 <pre class="has"><code class="language-go">select * from xxx where status = status &amp; 4;
</code></pre> 
 <p>要查询既通过了个人认证，又通过了微信认证的：</p> 
 <pre class="has"><code class="language-go">select * from xxx where status = status &amp; 5;
</code></pre> 
 <p>当然你也可能有排序需求，形如这样：</p> 
 <pre class="has"><code class="language-go">select * from xxx order by status &amp; 1 desc
</code></pre> 
 <p>这种case和每个人都熟悉的Linux权限控制一样，它就是使用位运算来控制的：权限分为 r 读, w 写, x 执行,其中它们的权值分别为4，2，1，你可以随意组合授权。比如 <code>chomd 7</code>，即7=4+2+1表明这个用户具有<strong>「rwx」</strong>权限，</p> 
 <h5>注意事项</h5> 
 <ol><li><p>需要你的DB存储支持位运算，比如MySql是支持的</p></li><li><p>请确保你的字段类型不是char字符类型，而应该是<strong>「数字类型」</strong></p></li><li><p>这种方式它会导致<strong>「索引失效」</strong>，但是一般情况下状态值是不需要索引的</p></li><li><p>具体业务具体分析，别一味地为了show而用，若用错了容易遭对有喷的</p></li></ol> 
 <h4>流水号生成器（订单号生成器）</h4> 
 <p>生成订单流水号，当然这其实这并不是一个很难的功能，最直接的方式就是日期+主机Id+随机字符串来拼接一个流水号，甚至看到非常多的地方直接使用UUID，当然这是非常不推荐的。</p> 
 <blockquote> 
  ❝ 
  <p>UUID是字符串，太长，无序，不能承载有效的信息从而不能给定位问题提供有效帮助，因此一般属于备选方案</p> 
  ❞ 
 </blockquote> 
 <p>今天学了位运算，有个我认为比较优雅方式来实现。什么叫优雅：可以参考淘宝、京东的订单号，<strong>「看似有规律，实则没规律」</strong>：</p> 
 <ul><li><p>不想把相关信息直接暴露出去。</p></li><li><p>通过流水号可以快速得到相关业务信息，快速定位问题（这点非常重要，这是UUID不建议使用的最重要原因）。</p></li><li><p>使用AtomicInteger可提高并发量，降低了冲突（这是不使用UUID另一重要原因，因为数字的效率比字符串高）</p></li></ul> 
 <img src="https://images2.imgbox.com/4a/d7/hpExFttt_o.png"> 
 <h5>实现原理简介</h5> 
 <p>此流水号构成：日期+Long类型的值 组成的一个一长串数字，形如<code>2020010419492195304210432</code>。很显然前面是日期数据，后面的一长串就蕴含了不少的含义：当前秒数、商家ID（也可以是你其余的业务数据）、机器ID、一串随机码等等。</p> 
 <p>各部分介绍：</p> 
 <ol><li><p>第一部分为当前时间的毫秒值。最大999，所以占10位</p></li><li><p>第二部分为：serviceType表示业务类型。比如订单号、操作流水号、消费流水号等等。最大值定为30，<strong>「足够用了吧」</strong>。占5位</p></li><li><p>第三部分为：shortParam，表示用户自定义的短参数。可以放置比如订单类型、操作类型等等类别参数。最大值定为30，肯定也是足够用了的。占5位</p></li><li><p>第四部分为：longParam，同上。用户一般可放置id参数，如用户id、商家id等等，最大支持9.9999亿。绝大多数足够用了，占30位</p></li><li><p>第五部分：剩余的位数交给随机数，随机生成一个数，占满剩余位数。一般至少有15位剩余（<strong>「此部分位数是浮动的」</strong>），所以能支持2的15次方的并发，也是足够用了的</p></li><li><p>最后，在上面的long值前面加上日期时间（年月日时分秒）</p></li></ol> 
 <p>这是A哥编写的一个基于位运算实现的流水号生成工具，已用于生产环境。考虑到源码较长（一个文件，共200行左右，无任何其它依赖）就不贴了，若有需要，<strong>「请到公众号后台回复<code>流水号生成器</code>免费获取」</strong>。</p> 
 <h2>✍总结</h2> 
 <p>位运算在<strong>「工程的角度」</strong>里缺点还是蛮多的，在实际工作中，如果只是为了数字的计算，是不建议使用位运算符的，只有一些比较特殊的场景，使用位运算去做会给你柳暗花明的感觉，如：</p> 
 <ul><li><p>N多状态的控制，需要兼具扩展性。比如数据库<strong>「是否状态」</strong>的字段设计</p></li><li><p>对效率有极致要求。比如JDK</p></li><li><p>场景非常适合。比如Jackson的Feature特针值</p></li></ul> 
 <p>切忌为了炫（zhuang）技（bi）而使用，炫技一时爽，掉坑火葬场；小伙还年轻，还望你谨慎。代码在大多情况下，<strong>「人能容易读懂比机器能读懂来得更重要」</strong>。</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/b0/dc/tguvgwDD_o.png"></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/06bcb029c431093193b138a6f2652d2c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Boot 微服务框架 Part1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dd1985b81ff5c0358c092a0893d53c72/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win10控制面板快捷键_Win10开启最强隐藏模式，电脑性能直线飙升</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>