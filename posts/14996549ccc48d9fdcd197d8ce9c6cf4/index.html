<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第五章-丛林跳跃（平台） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第五章-丛林跳跃（平台）" />
<meta property="og:description" content="目录
丛林跳跃（平台）
项目设置
介绍运动学物体
碰撞响应
Player场景
碰撞层/遮罩
Sprite
碰撞形状
动画
完成场景树
玩家状态
Player脚本
Player移动
Player生命值
收藏品
Collectible场景
Collectible脚本
设计关卡
TileSet配置
基础关卡设计
设计第一关卡
滚动背景
危险物品
敌人
场景设置
脚本
伤害敌人
HUD
场景设置
脚本
附加HUD
标题画面
场景设置
主场景
关卡过渡
收尾工作
音效
无限跌落
二段跳
灰尘粒子
蹲伏状态
爬梯子
移动平台
总结
丛林跳跃（平台） 在本章中，你将以《超级马里奥兄弟》的传统构建一个经典的平台、风格游戏。 平台游戏是一种非常流行的类型，了解它们的工作原理可以帮助你做出各种不同的游戏风格。平台游戏的物理学可能会非常复杂，你会看到Godot的KinematicBody2D物理节点的功能如何帮助你实现你所需要的角色控制器功能，以获得满意的体验。请看下面的截图。
在这个项目中，你将了解：
使用KinematicBody2D物理节点。将动画和用户输入结合起来，产生复杂的角色行为。使用ParallaxLayers创建无限滚动的背景组织你的项目和规划扩展 项目设置 创建一个新项目。在从下面的链接下载资产之前，你需要准备游戏美术的导入设置。这个项目的美术资产使用的是像素艺术风格，这意味着它们在没有过滤的情况下看起来最好，这是Godot对纹理的默认设置。Filtering 是一种对图像的像素进行平滑处理的方法。它可以改善一些艺术的外观，但不是基于像素的图像。
必须为每张图片禁用这个功能很不方便，所以Godot允许你自定义默认的导入设置。点击 FileSystem dock中的icon.png文件，然后点击右侧Scene 选项卡旁边的Import选项卡。这个窗口可以让你改变你选择的文件的导入设置。取消选中Filter 属性，然后点击Preset ，并选择Set as Default for &#39;Texture&#39;。这样一来，所有的图片在导入时都会禁用过滤功能。请参考下面的截图。
如果你已经导入了图片，它们的导入设置不会自动更新。更改默认值后，您必须重新导入任何现有图像。您可以在FileSystem dock中选择多个文件，然后单击 &#34;Reimport &#34;按钮，一次将设置应用于多个文件。
现在，你可以从下面的链接下载游戏资产，并解压到你的项目文件夹中。Godot会用新的默认设置导入所有图片，https:// github.com/PacktPublishing/Godot-Game-Engine-Projects/releases" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/14996549ccc48d9fdcd197d8ce9c6cf4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-02T14:52:43+08:00" />
<meta property="article:modified_time" content="2021-03-02T14:52:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第五章-丛林跳跃（平台）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%C2%A0%E4%B8%9B%E6%9E%97%E8%B7%B3%E8%B7%83%EF%BC%88%E5%B9%B3%E5%8F%B0%EF%BC%89-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%9B%E6%9E%97%E8%B7%B3%E8%B7%83%EF%BC%88%E5%B9%B3%E5%8F%B0%EF%BC%89" rel="nofollow"> 丛林跳跃（平台）</a></p> 
 <p id="%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE-toc" style="margin-left:40px;"><a href="#%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE" rel="nofollow">项目设置</a></p> 
 <p id="%E4%BB%8B%E7%BB%8D%E8%BF%90%E5%8A%A8%E5%AD%A6%E7%89%A9%E4%BD%93-toc" style="margin-left:40px;"><a href="#%E4%BB%8B%E7%BB%8D%E8%BF%90%E5%8A%A8%E5%AD%A6%E7%89%A9%E4%BD%93" rel="nofollow">介绍运动学物体</a></p> 
 <p id="%E7%A2%B0%E6%92%9E%E5%93%8D%E5%BA%94-toc" style="margin-left:80px;"><a href="#%E7%A2%B0%E6%92%9E%E5%93%8D%E5%BA%94" rel="nofollow">碰撞响应</a></p> 
 <p id="Player%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#Player%E5%9C%BA%E6%99%AF" rel="nofollow">Player场景</a></p> 
 <p id="%E7%A2%B0%E6%92%9E%E5%B1%82%2F%E9%81%AE%E7%BD%A9-toc" style="margin-left:80px;"><a href="#%E7%A2%B0%E6%92%9E%E5%B1%82%2F%E9%81%AE%E7%BD%A9" rel="nofollow">碰撞层/遮罩</a></p> 
 <p id="Sprite-toc" style="margin-left:80px;"><a href="#Sprite" rel="nofollow">Sprite</a></p> 
 <p id="%E7%A2%B0%E6%92%9E%E5%BD%A2%E7%8A%B6-toc" style="margin-left:80px;"><a href="#%E7%A2%B0%E6%92%9E%E5%BD%A2%E7%8A%B6" rel="nofollow">碰撞形状</a></p> 
 <p id="%E5%8A%A8%E7%94%BB-toc" style="margin-left:80px;"><a href="#%E5%8A%A8%E7%94%BB" rel="nofollow">动画</a></p> 
 <p id="%E5%AE%8C%E6%88%90%E5%9C%BA%E6%99%AF%E6%A0%91-toc" style="margin-left:80px;"><a href="#%E5%AE%8C%E6%88%90%E5%9C%BA%E6%99%AF%E6%A0%91" rel="nofollow">完成场景树</a></p> 
 <p id="%E7%8E%A9%E5%AE%B6%E7%8A%B6%E6%80%81-toc" style="margin-left:80px;"><a href="#%E7%8E%A9%E5%AE%B6%E7%8A%B6%E6%80%81" rel="nofollow">玩家状态</a></p> 
 <p id="Player%E8%84%9A%E6%9C%AC-toc" style="margin-left:80px;"><a href="#Player%E8%84%9A%E6%9C%AC" rel="nofollow">Player脚本</a></p> 
 <p id="Player%E7%A7%BB%E5%8A%A8-toc" style="margin-left:80px;"><a href="#Player%E7%A7%BB%E5%8A%A8" rel="nofollow">Player移动</a></p> 
 <p id="Player%E7%94%9F%E5%91%BD%E5%80%BC-toc" style="margin-left:80px;"><a href="#Player%E7%94%9F%E5%91%BD%E5%80%BC" rel="nofollow">Player生命值</a></p> 
 <p id="%E6%94%B6%E8%97%8F%E5%93%81-toc" style="margin-left:40px;"><a href="#%E6%94%B6%E8%97%8F%E5%93%81" rel="nofollow">收藏品</a></p> 
 <p id="Collectible%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><a href="#Collectible%E5%9C%BA%E6%99%AF" rel="nofollow">Collectible场景</a></p> 
 <p id="Collectible%E8%84%9A%E6%9C%AC-toc" style="margin-left:80px;"><a href="#Collectible%E8%84%9A%E6%9C%AC" rel="nofollow">Collectible脚本</a></p> 
 <p id="%E8%AE%BE%E8%AE%A1%E5%85%B3%E5%8D%A1-toc" style="margin-left:40px;"><a href="#%E8%AE%BE%E8%AE%A1%E5%85%B3%E5%8D%A1" rel="nofollow">设计关卡</a></p> 
 <p id="TileSet%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#TileSet%E9%85%8D%E7%BD%AE" rel="nofollow">TileSet配置</a></p> 
 <p id="%E5%9F%BA%E7%A1%80%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E7%A1%80%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1" rel="nofollow">基础关卡设计</a></p> 
 <p id="%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E5%85%B3%E5%8D%A1-toc" style="margin-left:80px;"><a href="#%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E5%85%B3%E5%8D%A1" rel="nofollow">设计第一关卡</a></p> 
 <p id="%E6%BB%9A%E5%8A%A8%E8%83%8C%E6%99%AF-toc" style="margin-left:80px;"><a href="#%E6%BB%9A%E5%8A%A8%E8%83%8C%E6%99%AF" rel="nofollow">滚动背景</a></p> 
 <p id="-toc" style="margin-left:80px;"><a href="#%E5%8D%B1%E9%99%A9%E7%89%A9%E5%93%81" rel="nofollow">危险物品</a></p> 
 <p id="%E6%95%8C%E4%BA%BA-toc" style="margin-left:40px;"><a href="#%E6%95%8C%E4%BA%BA" rel="nofollow">敌人</a></p> 
 <p id="%E5%9C%BA%E6%99%AF%E8%AE%BE%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%E5%9C%BA%E6%99%AF%E8%AE%BE%E7%BD%AE" rel="nofollow">场景设置</a></p> 
 <p id="%E8%84%9A%E6%9C%AC-toc" style="margin-left:80px;"><a href="#%E8%84%9A%E6%9C%AC" rel="nofollow">脚本</a></p> 
 <p id="%E4%BC%A4%E5%AE%B3%E6%95%8C%E4%BA%BA-toc" style="margin-left:80px;"><a href="#%E4%BC%A4%E5%AE%B3%E6%95%8C%E4%BA%BA" rel="nofollow">伤害敌人</a></p> 
 <p id="HUD-toc" style="margin-left:40px;"><a href="#HUD" rel="nofollow">HUD</a></p> 
 <p style="margin-left:80px;"><a href="#%E5%9C%BA%E6%99%AF%E8%AE%BE%E7%BD%AE" rel="nofollow">场景设置</a></p> 
 <p style="margin-left:80px;"><a href="#%E8%84%9A%E6%9C%AC" rel="nofollow">脚本</a></p> 
 <p id="%E9%99%84%E5%8A%A0HUD-toc" style="margin-left:80px;"><a href="#%E9%99%84%E5%8A%A0HUD" rel="nofollow">附加HUD</a></p> 
 <p id="%E6%A0%87%E9%A2%98%E7%94%BB%E9%9D%A2-toc" style="margin-left:40px;"><a href="#%E6%A0%87%E9%A2%98%E7%94%BB%E9%9D%A2" rel="nofollow">标题画面</a></p> 
 <p style="margin-left:80px;"><a href="#%E5%9C%BA%E6%99%AF%E8%AE%BE%E7%BD%AE" rel="nofollow">场景设置</a></p> 
 <p id="%E4%B8%BB%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E4%B8%BB%E5%9C%BA%E6%99%AF" rel="nofollow">主场景</a></p> 
 <p id="%E5%85%B3%E5%8D%A1%E8%BF%87%E6%B8%A1-toc" style="margin-left:80px;"><a href="#%E5%85%B3%E5%8D%A1%E8%BF%87%E6%B8%A1" rel="nofollow">关卡过渡</a></p> 
 <p id="%E6%94%B6%E5%B0%BE%E5%B7%A5%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%E6%94%B6%E5%B0%BE%E5%B7%A5%E4%BD%9C" rel="nofollow">收尾工作</a></p> 
 <p id="%E9%9F%B3%E6%95%88-toc" style="margin-left:80px;"><a href="#%E9%9F%B3%E6%95%88" rel="nofollow">音效</a></p> 
 <p id="%E6%97%A0%E9%99%90%E8%B7%8C%E8%90%BD-toc" style="margin-left:80px;"><a href="#%E6%97%A0%E9%99%90%E8%B7%8C%E8%90%BD" rel="nofollow">无限跌落</a></p> 
 <p id="%E4%BA%8C%E6%AE%B5%E8%B7%B3-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E6%AE%B5%E8%B7%B3" rel="nofollow">二段跳</a></p> 
 <p id="%E7%81%B0%E5%B0%98%E7%B2%92%E5%AD%90-toc" style="margin-left:80px;"><a href="#%E7%81%B0%E5%B0%98%E7%B2%92%E5%AD%90" rel="nofollow">灰尘粒子</a></p> 
 <p id="%E8%B9%B2%E4%BC%8F%E7%8A%B6%E6%80%81-toc" style="margin-left:80px;"><a href="#%E8%B9%B2%E4%BC%8F%E7%8A%B6%E6%80%81" rel="nofollow">蹲伏状态</a></p> 
 <p id="%E7%88%AC%E6%A2%AF%E5%AD%90-toc" style="margin-left:80px;"><a href="#%E7%88%AC%E6%A2%AF%E5%AD%90" rel="nofollow">爬梯子</a></p> 
 <p id="%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0-toc" style="margin-left:80px;"><a href="#%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0" rel="nofollow">移动平台</a></p> 
 <p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
 <hr id="hr-toc"> 
 <h2 style="margin-left:0pt;"> <a name="_bookmark266"></a><a name="_bookmark267"></a>丛林跳跃（平台）</h2> 
 <p style="margin-left:0pt;">在本章中，你将以《超级马里奥兄弟》的传统构建一个经典的平台、风格游戏。 平台游戏是一种非常流行的类型，了解它们的工作原理可以帮助你做出各种不同的游戏风格。平台游戏的物理学可能会非常复杂，你会看到Godot的KinematicBody2D物理节点的功能如何帮助你实现你所需要的角色控制器功能，以获得满意的体验。请看下面的截图。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d9/36/Cuwn7v5n_o.png"></p> 
 <p> </p> 
</div> 
<p>在这个项目中，你将了解：</p> 
<div> 
 <ul><li style="margin-left:0pt;">使用KinematicBody2D物理节点。</li><li style="margin-left:0pt;">将动画和用户输入结合起来，产生复杂的角色行为。</li><li style="margin-left:0pt;">使用ParallaxLayers创建无限滚动的背景</li><li style="margin-left:0pt;">组织你的项目和规划扩展</li></ul> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h3 id="%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE" style="margin-left:5.65pt;">项目设置</h3> 
 <p style="margin-left:0pt;">创建一个新项目。在从下面的链接下载资产之前，你需要准备游戏美术的导入设置。这个项目的美术资产使用的是像素艺术风格，这意味着它们在没有过滤的情况下看起来最好，这是Godot对纹理的默认设置。<strong><strong>Filtering </strong></strong>是一种对图像的像素进行平滑处理的方法。它可以改善一些艺术的外观，但不是基于像素的图像。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="text-align:center;"><img alt="" height="173" src="https://images2.imgbox.com/14/9c/sgO372g8_o.png" width="223"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">必须为每张图片禁用这个功能很不方便，所以Godot允许你自定义默认的导入设置。点击 <strong><strong>FileSystem dock</strong></strong>中的icon.png文件，然后点击右侧<strong><strong>Scene </strong></strong>选项卡旁边的<strong><strong>Impor</strong></strong>t选项卡。这个窗口可以让你改变你选择的文件的导入设置。取消选中<strong><strong>Filter </strong></strong>属性，然后点击<strong><strong>Preset </strong></strong>，并选择<strong><strong>Set as Default for 'Texture'</strong></strong>。这样一来，所有的图片在导入时都会禁用过滤功能。请参考下面的截图。</p> 
 <p style="text-align:center;"><img alt="" height="321" src="https://images2.imgbox.com/61/29/atv80sQI_o.png" width="154"></p> 
 <p style="margin-left:0pt;"> </p> 
 <blockquote> 
  <p style="margin-left:0pt;">如果你已经导入了图片，它们的导入设置不会自动更新。更改默认值后，您必须重新导入任何现有图像。您可以在FileSystem dock中选择多个文件，然后单击 "<strong><strong>Reimport "</strong></strong>按钮，一次将设置应用于多个文件。</p> 
 </blockquote> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">现在，你可以从下面的链接下载游戏资产，并解压到你的项目文件夹中。Godot会用新的默认设置导入所有图片，<a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases">https:/</a><a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases">/</a> <a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases">github.</a><a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases">com/</a><a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases">PacktPublishing/</a><a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases">Godot-</a><a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases">Game-</a><a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases">Engine-</a><a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases">Projects/</a><a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases">releases</a></p> 
 <p style="margin-left:0pt;">接下来，打开<strong><strong>Project </strong></strong>| <strong><strong>Project Settings</strong></strong>，在 <strong><strong>Rendering</strong></strong>/<strong><strong>Quality</strong></strong>下，将 <strong><strong>Use Pixel Snap</strong></strong>设置为 "开启"。这将确保所有图像都能正确对齐--这在你设计游戏关卡时非常重要。</p> 
 <p style="margin-left:0pt;">当你打开设置窗口时，进入 <strong><strong>Display</strong></strong>/<strong><strong>Window</strong></strong>部分，将 <strong><strong>Stretch</strong></strong>/<strong><strong>Mode</strong></strong>改为2d，将 <strong><strong>Aspect</strong></strong>改为展开。这些设置将允许用户调整游戏窗口的大小，同时保留图像的质量。项目完成后，你就可以看到这个设置的效果了。</p> 
 <p style="margin-left:0pt;"><a name="_bookmark270"></a>Next, set up the collision layer names so that it will be more convenient to set up collisions between different types of objects. Go to <strong><strong>Layer Names</strong></strong>/<strong><strong>2d Physics </strong></strong>and name the first four layers like this:</p> 
 <p style="margin-left:0pt;">接下来，设置碰撞层的名称，这样可以更方便地设置不同类型物体之间的碰撞。进入<strong><strong>Layer Names</strong></strong>/<strong><strong>2d Physics</strong></strong>，将前四个图层这样命名。</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/36/ba/Qn6Kfqvj_o.png"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">最后，在 <strong><strong>Project </strong></strong>| <strong><strong>Project Settings</strong></strong>下的 "<strong><strong>Input Map</strong></strong> "选项卡中为player控制添加以下操作。</p> 
 <table border="1" cellspacing="0" style="margin-left:12.05pt;width:425.85pt;"><tbody><tr><td style="vertical-align:top;width:247.1pt;"> <p><strong><strong>Action Name</strong></strong></p> </td><td style="vertical-align:top;width:178.75pt;"> <p style="margin-left:1.15pt;"><strong><strong>Key(s)</strong></strong></p> </td></tr><tr><td style="vertical-align:top;width:247.1pt;"> <p>right</p> </td><td style="vertical-align:top;width:178.75pt;"> <p style="margin-left:1.15pt;">D, →</p> </td></tr><tr><td style="vertical-align:top;width:247.1pt;"> <p>left</p> </td><td style="vertical-align:top;width:178.75pt;"> <p style="margin-left:1.15pt;">A, ←</p> </td></tr><tr><td style="vertical-align:top;width:247.1pt;"> <p>jump</p> </td><td style="vertical-align:top;width:178.75pt;"> <p style="margin-left:1.15pt;">Space</p> </td></tr><tr><td style="vertical-align:top;width:247.1pt;"> <p>crouch</p> </td><td style="vertical-align:top;width:178.75pt;"> <p style="margin-left:1.15pt;">S, ↓</p> </td></tr><tr><td style="vertical-align:top;width:247.1pt;"> <p>climb</p> </td><td style="vertical-align:top;width:178.75pt;"> <p style="margin-left:1.15pt;">W, ↑</p> </td></tr></tbody></table> 
 <p style="margin-left:0pt;"> </p> 
 <h3 id="%E4%BB%8B%E7%BB%8D%E8%BF%90%E5%8A%A8%E5%AD%A6%E7%89%A9%E4%BD%93" style="margin-left:5.65pt;"><strong><strong><strong>介绍</strong></strong></strong>运动学物体</h3> 
 <p style="margin-left:0pt;">一个平台游戏需要重力、碰撞、跳跃等物理行为，所以你可能会认为RigidBody2D是实现角色运动的最佳选择。但在实际操作中，你会发现，对于一个平台角色来说，刚体的真实物理行为并不可取。对于玩家来说，真实感不如响应式控制和动作感重要。因此，作为开发者，你希望能精确控制角色的动作和碰撞反应。因此，运动体通常是平台角色的较好选择。</p> 
 <p style="margin-left:0pt;"><a name="move_and_slide"></a>KinematicBody2D节点设计用于实现由用户直接控制或通过代码控制的体。这些节点在移动时检测与其他体的碰撞，但不受全局物理属性的影响，如重力或摩擦。这并不意味着运动体不能受到重力和其他力的影响，只是你必须在代码中计算这些力及其影响，引擎不会自动移动运动体。</p> 
 <p style="margin-left:0pt;">当移动KinematicBody2D时，和移动RigidBody2D一样，你不应该直接设置它的位置。相反，你可以使用move_and_collide()或move_and_slide()方法。这些方法沿着给定的向量移动体，如果检测到与另一个体发生碰撞，则立即停止。在KinematicBody2D发生碰撞后，任何碰撞响应必须手动编码。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E7%A2%B0%E6%92%9E%E5%93%8D%E5%BA%94" style="margin-left:5.65pt;"><strong><a name="_bookmark273"></a></strong>碰撞响应</h4> 
 <p style="margin-left:0pt;">碰撞后，你可能希望物体弹跳，沿着墙壁滑动，或者改变它所撞到的物体的属性。你处理碰撞响应的方式取决于你用哪种方法来移动物体。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p><strong><a name="_bookmark274"></a><strong><strong>move_and_collide</strong></strong></strong></p> 
 <p style="margin-left:0pt;">当使用move_and_collide()时，函数在碰撞时返回一个KinematicCollision2D对象。这个对象包含了关于碰撞和碰撞体的信息。你可以使用这些信息来确定响应。注意，当移动成功完成，没有碰撞时，函数返回null。</p> 
 <p style="margin-left:0pt;">例如，如果你想让身体从碰撞的物体上反弹，你可以使用以下脚本。</p> 
 <p style="margin-left:0pt;"> </p> 
 <pre><code>extends KinematicBody2D

var velocity = Vector2(250, 250) 

func _physics_process(delta):
    var collide = move_and_collide(velocity * delta) 
    if collide:
        velocity = velocity.bounce(collide.normal)</code></pre> 
 <p> </p> 
</div> 
<div> 
 <p style="margin-left:0pt;"> </p> 
 <p><strong><a name="_bookmark276"></a><strong><strong>move_and_slide</strong></strong></strong></p> 
 <p style="margin-left:0pt;">滑动是一种非常常见的碰撞响应选项。想象一下，在一个自上而下的游戏中，玩家沿着墙壁移动，或者在一个平台游戏中沿着斜坡跑上跑下。虽然在使用move_and_collide()之后可以自己编写这种响应的代码，但move_and_slide()提供了一种实现滑动运动的便捷方法。当使用这个方法时，身体会自动沿着碰撞表面滑动。此外，滑动碰撞允许你使用is_on_floor()等方法来检测碰撞表面的方向。</p> 
 <p style="margin-left:0pt;">由于这个项目不仅需要沿着地面移动，而且还需要在斜坡上和斜坡下奔跑，所以move_and_slide()将在你的player的移动中扮演重要角色。当你创建玩家对象时，你会看到它是如何工作的。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h3 id="Player%E5%9C%BA%E6%99%AF" style="margin-left:5.65pt;"><strong><a name="_bookmark277"></a><strong><strong>Player场景</strong></strong></strong></h3> 
 <p style="margin-left:0pt;">打开一个新的场景，并添加一个名为Player的KinematicBody2D对象作为根节点，然后保存场景（别忘了点击<strong><strong>Make children unselectable</strong></strong>按钮）。当保存Player场景时，您还应该创建一个新的文件夹来包含它。当您添加更多的场景和脚本时，这将有助于保持您的项目文件夹有序。</p> 
 <p style="margin-left:0pt;">正如你在其他项目中所做的那样，你将在玩家场景中包含玩家角色所需的所有节点来发挥作用。对于这个游戏来说，这意味着处理与各种游戏对象的碰撞，包括平台、敌人和收藏品；显示动作的动画，如奔跑或跳跃；以及跟随玩家在关卡中移动的相机。</p> 
 <p style="margin-left:0pt;">编写各种动画的脚本会很快变得难以管理，所以你会使用有限状态机来管理和跟踪玩家的状态。请参阅第3章 "逃离迷宫 "来回顾简化的有限状态机是如何构建的。你将在这个项目中遵循类似的模式。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E7%A2%B0%E6%92%9E%E5%B1%82%2F%E9%81%AE%E7%BD%A9" style="margin-left:5.65pt;"><strong><a name="_bookmark278"></a></strong>碰撞层/遮罩</h4> 
 <p> </p> 
 <p style="margin-left:0pt;">物体的碰撞层属性设置了物体所在的层。player需要分配到您在<strong><strong>Project Settings</strong></strong>中命名的player层。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"><a name="_bookmark279"></a>The <strong><strong>Collision</strong></strong>/<strong><strong>Mask </strong></strong>property allows you to set what types of objects the body will detect. Set the <strong><strong>Player </strong></strong>layer to player and its mask to <strong><strong>environment</strong></strong>, <strong><strong>enemies</strong></strong>, and <strong><strong>collectibles </strong></strong>(1, 3, and 4):</p> 
 <p style="margin-left:0pt;"><strong><strong>Collision</strong></strong>/<strong><strong>Mask</strong></strong>属性允许你设置哪些类型的物体将检测。将 "<strong><strong>Player </strong></strong>"层设置为玩家，将其遮罩设置为<strong><strong>environment</strong></strong>, <strong><strong>enemies</strong></strong>, 和<strong><strong>collectibles</strong></strong>（1、3和4）。</p> 
 <p style="text-align:center;"><img alt="" height="79" src="https://images2.imgbox.com/75/51/keXg5IPv_o.png" width="147"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="Sprite" style="margin-left:5.65pt;"><strong><strong><strong><a name="_bookmark280"></a>Sprite</strong></strong></strong></h4> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">为Player添加一个Sprite节点。从FileSystem码头拖动res://assets/player_sheet.png文件，并将其放到Sprite的Texture属性中。玩家动画以sprite sheet的形式保存。</p> 
 <p style="text-align:center;"><img alt="" height="32" src="https://images2.imgbox.com/f6/a7/zmBxPzYY_o.png" width="569"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">你将使用AnimationPlayer来处理动画，所以在Sprite的<strong><strong>Animation </strong></strong>属性中，设置<strong><strong>Vframes </strong></strong>为1，<strong><strong>Hframes </strong></strong>为19。设置<strong><strong>Frame </strong></strong>为7开始，因为这是显示角色静止不动的那一帧（这是闲置动画的第一帧）。</p> 
 <p style="text-align:center;"><img alt="" height="82" src="https://images2.imgbox.com/f8/46/P27rj923_o.png" width="151"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E7%A2%B0%E6%92%9E%E5%BD%A2%E7%8A%B6" style="margin-left:5.65pt;"><strong><a name="_bookmark281"></a><strong><strong>碰撞形状</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">与其他物理体一样，KinematicBody2D需要分配一个形状来定义其碰撞边界。添加一个CollisionShape2D对象，并在其内部创建一个新的RectangleShape2D对象。在确定矩形的大小时，你希望它能到达图像的底部，但不要太宽。一般来说，把碰撞形状做得比图像小一点，会使游戏时的感觉更好，避免打到一些看起来不会产生碰撞的东西的体验。</p> 
 <p style="margin-left:0pt;"><a name="_bookmark282"></a>你还需要将形状偏移一小部分，使其适合。将位置设置为(0,5)效果很好。当你完成后，它应该大约是这样的。</p> 
 <p style="text-align:center;"><img alt="" height="255" src="https://images2.imgbox.com/5a/61/TXfhmP0S_o.png" width="181"></p> 
 <p><strong><a name="Shapes"></a><strong><strong><a name="_bookmark283"></a></strong></strong></strong></p> 
 <p><strong><strong><strong>形状</strong></strong></strong></p> 
 <p style="margin-left:0pt;">有些开发者喜欢用胶囊形状而不是矩形形状来制作侧滚角色。胶囊是一个两端都是圆形的丸状碰撞。</p> 
 <p style="text-align:center;"><img alt="" height="171" src="https://images2.imgbox.com/89/5b/zDbYAzfV_o.png" width="135"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">然而，虽然这种形状看起来似乎能更好地覆盖精灵，但在实现平台式移动时可能会导致困难。例如，当站在太靠近平台边缘的时候，角色可能会因为底部的圆形而滑落，这对玩家来说会非常沮丧。</p> 
</div> 
<p>在某些情况下，根据你的角色的复杂性和它与其他对象的互动，你可能想在同一个对象上添加多个形状。你可能会在角色的脚下有一个形状来检测地面碰撞，在其身上有另一个形状来检测伤害（有时被称为hurtbox），还有另一个形状覆盖在玩家的前面来检测与墙壁的接触。</p> 
<div> 
 <p style="margin-left:0pt;">建议你对这个角色坚持使用RectangleShape2D，如前面的截图所示。然而，一旦你完成了这个项目，你应该尝试将玩家的碰撞形状改为CapsuleShape2D，并观察由此产生的行为。如果你更喜欢它，欢迎使用它来代替。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E5%8A%A8%E7%94%BB" style="margin-left:5.65pt;"><strong><a name="_bookmark285"></a></strong>动画</h4> 
 <p style="margin-left:0pt;">在Player场景中添加一个AnimationPlayer节点。你将使用这个节点来改变Sprite上的Frame属性来显示角色的动画。首先制作一个名为idle的新动画。</p> 
 <p style="text-align:center;"><img alt="" height="182" src="https://images2.imgbox.com/9f/ad/HC6MyNLi_o.png" width="545"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">设置<strong><strong>Length </strong></strong>为0.4秒，<strong><strong>Step </strong></strong>保持在0.1秒。将Sprite的<strong><strong>Frame </strong></strong>改为7，然后点击<strong><strong>Frame </strong></strong>属性旁边的<strong><strong>Add keyframe</strong></strong>按钮，创建一个新的动画轨道，然后再按一下，注意会自动递增<strong><strong>Frame </strong></strong>属性。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="text-align:center;"><img alt="" height="71" src="https://images2.imgbox.com/3a/6c/Qh2a2YBt_o.png" width="130"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"><a name="_bookmark286"></a>继续按下它，直到你有第7到10帧。最后，点击<strong><strong>Enable</strong></strong>/<strong><strong>Disable looping</strong></strong>按钮来启用循环，然后按 <strong><strong>Play </strong></strong>来查看你的动画。你的动画设置应该是这样的。</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/28/3e/T3mIHYRx_o.png"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">现在你需要为其他动画重复这个过程。请参阅下表的设置列表。</p> 
 <p style="margin-left:0pt;"> </p> 
 <table border="1" cellspacing="0" style="margin-left:12.05pt;width:425.95pt;"><tbody><tr><td style="vertical-align:top;width:104.05pt;"> <p><strong><strong>name</strong></strong></p> </td><td style="vertical-align:top;width:60.4pt;"> <p><strong><strong>length</strong></strong></p> </td><td style="vertical-align:top;width:203.35pt;"> <p><strong><strong>frames</strong></strong></p> </td><td style="vertical-align:top;width:58.15pt;"> <p style="margin-left:1.05pt;"><strong><strong>looping</strong></strong></p> </td></tr><tr><td style="vertical-align:top;width:104.05pt;"> <p>idle</p> </td><td style="vertical-align:top;width:60.4pt;"> <p>0.4</p> </td><td style="vertical-align:top;width:203.35pt;"> <p>7, 8, 9 ,10</p> </td><td style="vertical-align:top;width:58.15pt;"> <p style="margin-left:1.05pt;">on</p> </td></tr><tr><td style="vertical-align:top;width:104.05pt;"> <p>run</p> </td><td style="vertical-align:top;width:60.4pt;"> <p>0.5</p> </td><td style="vertical-align:top;width:203.35pt;"> <p>13, 14, 15, 16, 17, 18</p> </td><td style="vertical-align:top;width:58.15pt;"> <p style="margin-left:1.05pt;">on</p> </td></tr><tr><td style="vertical-align:top;width:104.05pt;"> <p>hurt</p> </td><td style="vertical-align:top;width:60.4pt;"> <p>0.2</p> </td><td style="vertical-align:top;width:203.35pt;"> <p>5, 6</p> </td><td style="vertical-align:top;width:58.15pt;"> <p style="margin-left:1.05pt;">on</p> </td></tr><tr><td style="vertical-align:top;width:104.05pt;"> <p>jump_up</p> </td><td style="vertical-align:top;width:60.4pt;"> <p>0.1</p> </td><td style="vertical-align:top;width:203.35pt;"> <p>11</p> </td><td style="vertical-align:top;width:58.15pt;"> <p style="margin-left:1.05pt;">off</p> </td></tr><tr><td style="vertical-align:top;width:104.05pt;"> <p>jump_down</p> </td><td style="vertical-align:top;width:60.4pt;"> <p>0.1</p> </td><td style="vertical-align:top;width:203.35pt;"> <p>12</p> </td><td style="vertical-align:top;width:58.15pt;"> <p style="margin-left:1.05pt;">0ff</p> </td></tr><tr><td style="vertical-align:top;width:104.05pt;"> <p> </p> <p> </p> </td><td style="vertical-align:top;width:60.4pt;"> <p> </p> </td><td style="vertical-align:top;width:203.35pt;"> <p> </p> </td><td style="vertical-align:top;width:58.15pt;"> <p style="margin-left:1.05pt;"> </p> </td></tr></tbody></table> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E5%AE%8C%E6%88%90%E5%9C%BA%E6%99%AF%E6%A0%91" style="margin-left:5.65pt;"><strong><strong><strong><a name="_bookmark287"></a></strong></strong></strong>完成场景树</h4> 
 <p style="margin-left:0pt;">在玩家场景中添加Camera2D。当玩家在关卡中移动时，这个节点将使游戏窗口以玩家为中心。你也可以用它来放大玩家，因为像素艺术比较小。记住，由于你在导入设置中设置了过滤关闭，所以当放大时，玩家的贴图将保持像素化和块状。</p> 
 <p style="margin-left:0pt;">要启用摄像机，请将<strong><strong>Current </strong></strong>属性单击为开，然后将<strong><strong>Zoom </strong></strong>属性设置为 (0.4, 0.4)。小于1的值将摄像机放大，大于1的值将摄像机缩小。</p> 
 <h4 id="%E7%8E%A9%E5%AE%B6%E7%8A%B6%E6%80%81" style="margin-left:5.65pt;"><strong><strong><strong><a name="_bookmark288"></a><a name="_bookmark289"></a></strong></strong></strong>玩家状态</h4> 
 <p style="margin-left:0pt;">玩家角色有各种各样的行为，比如跳跃、奔跑和蹲下。对这些行为进行编码可能会变得非常复杂和难以管理。一种解决方案是使用布尔变量（例如is_jumping或is_running），但这可能会导致混乱的状态（如果is_crouching和is_jumping都是真呢？），并很快导致意大利面条代码。</p> 
 <p style="margin-left:0pt;">解决这个问题的较好办法是使用状态机来处理玩家的当前状态，并控制向其他状态的转换。有限状态机在第三章《逃离迷宫》中讨论过。</p> 
 <p style="margin-left:0pt;">这里是玩家的状态和它们之间的转换图。</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/de/db/psvbP9xa_o.png"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">正如你所看到的，即使是相对较少的状态，状态机图也会变得相当复杂。</p> 
</div> 
<blockquote> 
 <p style="margin-left:0pt;">请注意，虽然spriteheet包含了它们的动画，但CROUCH和CLIMB的动画并不包含在这里。这是为了在项目开始时保持状态的数量可控。以后，你将有机会把它们添加到玩家的状态机中。</p> 
</blockquote> 
<div> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="Player%E8%84%9A%E6%9C%AC" style="margin-left:5.65pt;"><strong><strong><strong>Player脚本</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">将一个新的脚本附加到Player 节点上。添加以下代码来创建player 的状态机。</p> 
 <pre><code>extends KinematicBody2D
enum {IDLE, RUN, JUMP, HURT, DEAD}
var state var anim
var new_anim

func ready():
    change_state(IDLE)

func change_state(new_state): 
    state = new_state
    match state:
        IDLE:
            new_anim = 'idle'
        RUN:
            new_anim = 'run' 
        HURT:
            new_anim = 'hurt' 
        JUMP:
            new_anim = 'jump_up' 
        DEAD:
            hide()

func _physics_process(delta): 
    if new_anim != anim:
        anim = new_anim
        $AnimationPlayer.play(anim)</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">再一次，你使用enum来列出系统允许的状态。当你想改变玩家的状态时，你将调用change_state()，例如：change_state(IDLE)。现在，这个脚本只改变了动画值，但你以后会添加更多的状态功能。</p> 
 <p style="margin-left:0pt;"><a name="_bookmark292"></a>你可能会问，为什么不在状态变化时直接播放动画？为什么要做new_anim这个事呢？这是因为当你在AnimationPlayer上调用play()时，它会从头开始播放动画。比如说，如果你在运行的时候这么做，你就只能看到运行动画的第一帧，因为它每一帧都会重新开始。通过使用new_anim变量，你可以让当前的动画继续顺利播放，直到你想让它改变。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="Player%E7%A7%BB%E5%8A%A8" style="margin-left:5.65pt;"><strong><a name="_bookmark293"></a><strong><strong>Player移动</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">玩家需要三个控制--左、右、跳。如果状态规则允许转换的话，当前状态加上按下哪个键的组合将触发状态变化。增加get_input()函数来处理输入并确定结果。</p> 
 <pre><code>extends KinematicBody2D

export (int) var run_speed 
export (int) var jump_speed 
export (int) var gravity

enum {IDLE, RUN, JUMP, HURT, DEAD}
var state var anim
var new_anim
var velocity = Vector2()

func get_input():
    if state == HURT:
        return # don't allow movement during hurt state 
    var right = Input.is_action_pressed('right')
    var left = Input.is_action_pressed('left')
    var jump = Input.is_action_just_pressed('jump')

    # movement occurs in all states velocity.x = 0
    if right:
        velocity.x += run_speed
        $Sprite.flip_h = false 
    if left:
        velocity.x -= run_speed
        $Sprite.flip_h = true
    # only allow jumping when on the ground 
    if jump and is_on_floor():
        change_state(JUMP) 
        velocity.y = jump_speed
    # IDLE transitions to RUN when moving 
    if state == IDLE and velocity.x != 0:
        change_state(RUN)
    # RUN transitions to IDLE when standing still 
    if state == RUN and velocity.x == 0:
        change_state(IDLE)
    # transition to JUMP when falling off an edge 
    if state in [IDLE, RUN] and !is_on_floor():
        change_state(JUMP)</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">请注意，跳转检查使用的是is_action_just_pressed()而不是is_action_pressed()。后者只要键被按住就总是返回真，而前者只有在键被按下后的帧中才是真。这意味着玩家每次想要跳跃时都必须按下跳跃键。</p> 
 <p style="margin-left:0pt;">现在，从_physics_process()调用这个函数，将重力的拉力加到玩家的velocity上，然后调用move_and_slide()方法来移动身体。</p> 
 <pre><code>func _physics_process(delta): 
    velocity.y += gravity * delta 
    get_input()
    if new_anim != anim: 
        anim = new_anim
        $AnimationPlayer.play(anim) # move the player
    velocity = move_and_slide(velocity, Vector2(0, -1))</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">The second parameter of move_and_slide() is a <em><em>normal </em></em>vector, indicating what surface direction the engine should consider to be the ground. In physics and geometry, a <em><em>normal </em></em>is a vector perpendicular to a surface, defining the direction a surface is facing. Using (0,</p> 
 <p style="margin-left:0pt;">-1), which is a vector pointing upwards, the top of a horizontal surface will be considered as ground. Refer to the following screenshot:</p> 
 <p style="margin-left:0pt;">move_and_slide()的第二个参数是一个法线向量，表示什么方向平面引擎认为是平面。在物理学和几何学中，法线是一个垂直于平面的向量，定义了一个平面所面对的方向。使用(0,-1)，这是一个指向上方的向量，水平面的顶部将被视为地面。请参考下面的截图。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="text-align:center;"><img alt="" height="120" src="https://images2.imgbox.com/6b/57/psCIMaLd_o.png" width="155"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">在使用move_and_slide()移动后，物理引擎会使用这个信息来设置is_on_floor()、is_on_wall()和is_on_ceiling方法的值。你可以使用这个事实来检测跳跃何时结束，在move后添加这个。</p> 
 <pre><code>if state == JUMP and is_on_floor(): 
    change_state(IDLE)</code></pre> 
 <p style="margin-left:0pt;">最后，如果落下时动画从jump_up切换到jump_down会更好看。</p> 
 <p style="margin-left:0pt;"> </p> 
 <pre><code>if state == JUMP and velocity.y &gt; 0:	
    new_anim = 'jump_down'Testing the moves</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">此时，最好是测试一下运动，确保一切正常。不过你不能只运行玩家场景，因为玩家会在没有平面站立的情况下就开始坠落。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">创建一个新的场景，并添加一个名为Main的Node（稍后，这将成为你真正的主场景）。添加一个Player的实例，然后添加一个StaticBody2D与一个矩形的CollisionShape2D。水平拉伸碰撞形状，使其足够宽，可以在上面来回走动（就像一个平台），并将其放置在角色下方。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="text-align:center;"><img alt="" height="176" src="https://images2.imgbox.com/c9/de/tIFEXwZo_o.png" width="363"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">按<strong><strong>Play Scene</strong></strong>，你应该会看到玩家停止坠落，并在撞到静态物体时运行idle动画。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">在继续之前，确保所有的运动和动画都能正常工作。在各个方向上跑和跳跃，并检查每当状态变化时，是否播放了正确的动画。如果你发现任何问题，请回顾前面的章节，并确保你没有错过一个步骤。</p> 
 <p style="margin-left:0pt;"><a name="_bookmark296"></a>之后，一旦关卡完成，玩家将被传递一个出生位置。要处理这个问题，请在Player.gd脚本中添加这个函数。</p> 
 <pre><code>func start(pos): 
    position = pos show() 
    change_state(IDLE)</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="Player%E7%94%9F%E5%91%BD%E5%80%BC" style="margin-left:5.65pt;"><strong><strong><strong><a name="_bookmark297"></a>Player生命值</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">最终，玩家会遇到危险，所以你应该增加一个伤害系统。玩家一开始会有三颗心，每次受到伤害都会失去一颗心。</p> 
 <p style="margin-left:0pt;">在脚本的顶部添加以下内容。</p> 
 <pre><code>signal life_changed 
signal dead

var life</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">每当生命值发生变化时，就会发出life_changed信号，通知显示器更新。 当生命值达到0时，就会发出dead信号。 在start()函数中加入这两行。</p> 
 <pre><code>life = 3 
emit_signal('life_changed', life)</code></pre> 
 <p style="margin-left:0pt;">玩家有两种可能的受伤方式：撞上环境中的尖刺物体，或者被敌人击中。在这两种情况下，都可以调用以下函数。</p> 
 <pre><code>func hurt():
    if state != HURT: 
        change_state(HURT)</code></pre> 
 <p style="margin-left:0pt;">这是对玩家来说是友善：如果他们已经受伤了，就不能再受伤了（至少在伤害动画停止播放之前的短暂时间内）。</p> 
 <p style="margin-left:0pt;">在change_state()中，当状态变为HURT时，有几件事要做。</p> 
 <p style="margin-left:0pt;"> </p> 
 <pre><code>HURT:
    new_anim = 'hurt' 
    velocity.y = -200
    velocity.x = -100 * sign(velocity.x) 
    life -= 1

    emit_signal('life_changed', life) 
    yield(get_tree().create_timer(0.5), 'timeout') 
    change_state(IDLE)
    if life &lt;= 0:
        change_state(DEAD)
DEAD:
    emit_signal('dead') hide()</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">玩家不仅会失去一条生命，还会被弹起，远离破坏性物体。短时间后，状态变回IDLE。</p> 
 <p style="margin-left:0pt;">另外，当玩家处于HURT状态时，输入将被禁用。在get_input()的开头加上这个。</p> 
 <pre><code>if state == HURT: 
    return</code></pre> 
 <p style="margin-left:0pt;">现在，玩家准备好了其他的游戏设置后，就可以承受伤害了。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h3 id="%E6%94%B6%E8%97%8F%E5%93%81" style="margin-left:5.65pt;"><strong><a name="_bookmark299"></a></strong>收藏品</h3> 
 <p style="margin-left:0pt;">在开始制作关卡之前，你需要创建一些拾取物供玩家收集，因为这些也将是关卡的一部分。assets/sprites文件夹中包含了两种类型的拾取物的精灵表：樱桃和宝石。</p> 
 <p style="margin-left:0pt;">与其为每种类型的物品制作单独的场景，不如使用单一场景，仅仅是交换精灵片贴图。这两种物品将具有相同的行为：在原地动画，当玩家接触到它们时，它们会消失（也就是被收集）。你也可以为拾取物添加一个Tween动画（见第1章介绍中的例子）。</p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="Collectible%E5%9C%BA%E6%99%AF" style="margin-left:5.65pt;"><strong><strong><strong>Collectible场景</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">用一个Area2D开始新的场景，并将其命名为Collectible。对于这些对象来说，一个区域是一个很好的选择，因为你想在玩家接触它们时进行检测（使用body_entered信号），但你不需要它们的碰撞响应。在<strong><strong>Inspector</strong></strong>中，将<strong><strong>Collision</strong></strong>/<strong><strong>Layer</strong></strong>设置为<strong><strong>collectibles </strong></strong>（层4）， <strong><strong>Collision</strong></strong>/<strong><strong>Mask</strong></strong>设置为<strong><strong>player </strong></strong>（层2）。这将确保只有玩家节点能够收集物品，而敌人将直接通过。</p> 
 <p style="margin-left:0pt;"><a name="_bookmark301"></a>添加三个子节点。Sprite、CollisionShape2D和AnimationPlayer，然后将res://assets/cherry.png Sprite sheet拖入Sprite的<strong><strong>Texture</strong></strong>中。设置<strong><strong>Vframes </strong></strong>为1，<strong><strong>Hframes </strong></strong>为5。在CollisionShape2D中添加一个矩形形状，并适当调整其大小。</p> 
 <blockquote> 
  <p style="margin-left:0pt;">作为一般规则，你应该调整物体碰撞形状的大小，使其有利于玩家。这意味着，敌人的hitboxs一般应该比图像小一点，而有益物品的撞箱应该略微过大。这样可以减少玩家的挫败感，并带来更好的游戏体验。</p> 
 </blockquote> 
 <p style="margin-left:0pt;">在AnimationPlayer中添加一个新的动画（你只需要一个，所以可以直接命名为anim）。将<strong><strong>Length </strong></strong>设置为1.6秒，<strong><strong>Step </strong></strong>设置为0.2秒。</p> 
 <p style="margin-left:0pt;">将Sprite的<strong><strong>Frame </strong></strong>属性设置为0，然后点击关键帧按钮来创建轨道。当你到达第四帧时，开始将顺序倒退到1，完整的关键帧序列应该是：</p> 
 <p style="margin-left:0pt;">0 → 1 → 2 → 3 → 4 → 3 → 2 → 1</p> 
 <p style="margin-left:0pt;">启用循环并按下<strong><strong>Play </strong></strong>按钮。现在，你已经有了一个很好的动画樱桃了！将res://assets/gem.png拖入纹理中，并检查它是否也有动画。将res://assets/gem.png拖入贴图中，并检查它是否也会产生动画。最后，点击 "<strong><strong>Autoplay on Load</strong></strong>加载时自动播放 "按钮，确保动画在场景开始时自动播放。参考下面的截图。</p> 
 <p style="text-align:center;"><img alt="" height="116" src="https://images2.imgbox.com/6b/d1/Dowt16Ln_o.png" width="431"></p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="Collectible%E8%84%9A%E6%9C%AC" style="margin-left:5.65pt;"><strong><a name="_bookmark302"></a><strong><strong>Collectible脚本</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">收藏脚本需要做两件事。</p> 
 <p style="margin-left:0pt;">设置开始条件（纹理和位置 )</p> 
 <p style="margin-left:0pt;">检测玩家何时进入该区域</p> 
 <p style="margin-left:0pt;">第一部分，在新脚本中添加以下代码。</p> 
</div> 
<div> 
 <pre><code>extends Area2D 

signal pickup

var textures = {
    'cherry': 'res://assets/sprites/cherry.png', 
    'gem': 'res://assets/sprites/gem.png'
    }

func init(type, pos):
    $Sprite.texture = load(textures[type]) 
    position = pos</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">当玩家收集物品时，会发出拾取信号。在textures 字典中，你有一个物品类型的列表和它们对应的纹理位置。需要注意的是，你可以通过在<strong><strong>FileSystem</strong></strong> dock中右击文件并选择<strong><strong>Copy Path</strong></strong>来快速粘贴这些文件路径。</p> 
 <p style="text-align:center;"><img alt="" height="241" src="https://images2.imgbox.com/a5/7a/uim2d0xL_o.png" width="249"></p> 
 <p style="margin-left:0pt;">接下来，你有一个init()函数，将纹理和位置设置为给定值。关卡脚本将使用这个函数来生成所有你添加到关卡地图中的收藏品。</p> 
 <p style="margin-left:0pt;">最后，你需要对象检测它何时被拾取。点击Area2D并连接其body_entered信号。在创建的函数中添加以下代码。</p> 
 <pre><code>func _on_Collectible_body_entered(body): 
    emit_signal('pickup')
    queue_free()</code></pre> 
 <p style="margin-left:0pt;">发出信号会让游戏的脚本对物品的拾取做出适当的反应。它可以增加分数，增加玩家的速度，或者任何其他你希望物品应用的效果。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h3 id="%E8%AE%BE%E8%AE%A1%E5%85%B3%E5%8D%A1" style="margin-left:5.65pt;"><strong><a name="_bookmark305"></a><strong><strong>设计关卡</strong></strong></strong></h3> 
 <p style="margin-left:0pt;">没有跳跃就不是平台游戏了。对于大多数读者来说，这部分会占用最大的时间。一旦你开始设计一个关卡，你会发现把所有的部分都布置好，创造出具有挑战性的跳跃、秘密的路径和危险的遭遇，是一件非常有趣的事情。</p> 
 <p style="margin-left:0pt;">首先，你将创建一个通用的关卡场景，其中包含所有关卡通用的节点和代码。然后你可以创建任何数量的从这个主关卡继承的关卡场景。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="TileSet%E9%85%8D%E7%BD%AE" style="margin-left:5.65pt;"><strong><a name="_bookmark306"></a><strong><strong>TileSet配置</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">在你在项目开始时下载的assets文件夹中，有一个tilesets文件夹。它包含了三个现成的TileSet资源，使用了游戏的16x16艺术。</p> 
 <ul><li style="margin-left:0pt;">tiles_world.tres:地面和平台瓦片</li><li style="margin-left:0pt;">tiles_items.tres:装饰品、前景物体和收藏品；</li><li style="margin-left:0pt;">tiles_spikes.tres:危险物品</li></ul> 
 <p style="margin-left:0pt;">建议你使用这些瓦片集来创建这个项目的关卡。但是，如果你想自己制作，原图在res://assets/environment/layers中。参见第2章Coin Dash，了解如何创建TileSet资源。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E5%9F%BA%E7%A1%80%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1" style="margin-left:5.65pt;"><strong><strong><strong><a name="_bookmark307"></a>基础关卡设计</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">创建一个新场景，并添加一个名为Level的Node2D。将场景保存在一个名为Level.tscn的新文件夹中。在继承Level.tscn后，你将在这里保存你创建的任何其他关卡。所有关卡的节点层次结构都是一样的，只是布局不同。</p> 
 <p style="margin-left:0pt;"><a name="_bookmark308"></a>接下来，添加一个TileMap，并将其<strong><strong>Cell</strong></strong>/<strong><strong>Size</strong></strong>设置为(16, 16)，然后将其复制三次(按Ctrl + D复制一个节点)。这些将是你关卡的图层，存放不同的瓷砖和布局信息。命名四个 TileMap 实例如下，并将相应的 TileSet 拖放到每个<strong><strong>Tile Set</strong></strong>属性中。请参考下表。</p> 
 <p style="margin-left:0pt;"> </p> 
 <table border="1" cellspacing="0" style="margin-left:12.05pt;width:425.85pt;"><tbody><tr><td style="vertical-align:top;width:131.25pt;"> <p><strong><strong>TileMap</strong></strong></p> </td><td style="vertical-align:top;width:294.6pt;"> <p style="margin-left:1.15pt;"><strong><strong>Tile Set</strong></strong></p> </td></tr><tr><td style="vertical-align:top;width:131.25pt;"> <p>World</p> </td><td style="vertical-align:top;width:294.6pt;"> <p style="margin-left:1.15pt;">tiles_world.tres</p> </td></tr><tr><td style="vertical-align:top;width:131.25pt;"> <p>Objects</p> </td><td style="vertical-align:top;width:294.6pt;"> <p style="margin-left:1.15pt;">tiles_items.tres</p> </td></tr><tr><td style="vertical-align:top;width:131.25pt;"> <p>Pickups</p> </td><td style="vertical-align:top;width:294.6pt;"> <p style="margin-left:1.15pt;">tiles_items.tres</p> </td></tr><tr><td style="vertical-align:top;width:131.25pt;"> <p>Danger</p> </td><td style="vertical-align:top;width:294.6pt;"> <p style="margin-left:1.15pt;">tiles_spikes.tres</p> </td></tr></tbody></table> 
 <p style="margin-left:0pt;"> </p> 
 <blockquote> 
  <p style="margin-left:0pt;">最好是在TileMap节点上按下锁定按钮，以防止你在地图上工作时意外地移动它们</p> 
 </blockquote> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">接下来，添加一个Player场景的实例和一个名为PlayerSpawn的Position2D。点击播放器上的隐藏按钮--你将在关卡脚本中使用show()使播放器在启动时出现。现在你的场景树应该是这样的。</p> 
 <p style="text-align:center;"><img alt="" height="171" src="https://images2.imgbox.com/12/a4/EwSjYZyM_o.png" width="158"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">给Level节点附加一个脚本。</p> 
 <pre><code>extends Node2D
onready var pickups = $Pickups 

func _ready():
    pickups.hide()
    $Player.start($PlayerSpawn.position)</code></pre> 
 <p> </p> 
</div> 
<div> 
 <p style="margin-left:0pt;">稍后，你将会扫描Pickups地图，在指定地点产生可收集的物品。这个地图层本身不应该被看到，但与其在场景树中设置为隐藏，这样很容易在运行游戏前忘记，不如在_ready()中这样做，以确保在游戏过程中始终隐藏。因为会有很多对节点的引用，所以将$Pickups的结果存储在pickups变量中，会缓存结果。(记住，$NodeName和写get_node("NodeName")是一样的。)</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E5%85%B3%E5%8D%A1" style="margin-left:5.65pt;"><strong><strong><strong><a name="_bookmark310"></a>设计第一关卡</strong></strong></strong></h4> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">现在，你已经准备好开始绘制关卡了！点击<strong><strong>Scene </strong></strong>| <strong><strong>New Inherited Scene</strong></strong>，选择Level.tscn。将新节点命名为Level01并保存（仍在关卡文件夹中）。</p> 
 <p style="margin-left:0pt;">从世界图层开始，发挥创意。你喜欢大量的跳跃，还是曲折的隧道探索？长跑，还是小心翼翼的向上攀爬？</p> 
 <p style="margin-left:0pt;">在你的设计中走得太远之前，先试验一下跳跃距离。你可以改变玩家的jump_speed、run_speed和重力属性来改变他们能跳多高和多远。设置一些不同的间隙大小，并运行场景来尝试它们。不要忘了把PlayerSpawn节点拖到你想要角色开始的地方。</p> 
 <p style="margin-left:0pt;">比如说，玩家能不能进行这种跳跃呢？看看下面的截图吧。</p> 
 <p style="text-align:center;"><img alt="" height="143" src="https://images2.imgbox.com/32/e4/6zqPOZpq_o.png" width="371"></p> 
 <p style="margin-left:0pt;">如何设置玩家的移动属性将对你的关卡应该如何布局产生很大影响。在花太多时间在完整的设计之前，请确保你对你的设置满意。</p> 
 <p style="margin-left:0pt;">一旦你设置好了世界图层，就可以使用对象图层来放置植物、岩石和藤蔓等装饰物。</p> 
 <p style="margin-left:0pt;"><a name="_bookmark311"></a>使用拾取层来标记你将产生可收集物品的位置。有两种:宝石和樱桃。产生它们的瓷砖用洋红色背景绘制，以使它们突出。请记住，它们将在运行时被实际的项目替换，而tile本身将不会被看到。。</p> 
 <p style="margin-left:0pt;">一旦你布置好了关卡，你就可以限制玩家摄像头的水平滚动，使其与地图的大小相匹配（加上两端的5张瓷砖缓冲区）。</p> 
 <pre><code>signal score_changed
var score

func _ready():
    score = 0
    emit_signal('score_changed', score)
    pickups.hide()
    $Player.start($PlayerSpawn.position)
    set_camera_limits()

func set_camera_limits():
    var map_size = $World.get_used_rect()
    var cell_size = $World.cell_size
    $Player/Camera2D.limit_left = (map_size.position.x - 5) * cell_size.x
    $Player/Camera2D.limit_right = (map_size.end.x + 5) * cell_size.x

#该脚本还需要扫描Pickups图层并查找项目标记：

func spawn_pickups():
    for cell in pickups.get_used_cells():
        var id = pickups.get_cellv(cell)
        var type = pickups.tile_set.tile_get_name(id)
        if type in ['gem', 'cherry']:
            var c = Collectible.instance()
            var pos = pickups.map_to_world(cell)
            c.init(type, pos + pickups.cell_size/2)
            add_child(c)
            c.connect('pickup', self, '_on_Collectible_pickup')

func _on_Collectible_pickup():
    score += 1
    emit_signal('score_changed', score)

func _on_Player_dead():
    pass</code></pre> 
 <p style="margin-left:0pt;">这个函数使用get_used_cells()来获取Pickups地图上正在使用的瓦片数组。TileMap将每个瓦片的值设置为一个id，这个id引用了TileSet中的各个瓦片对象。然后你可以使用 tile_set.tile_get_name()来查询 TileSet 的名称。</p> 
 <p style="margin-left:0pt;">在_ready()中加入 spawn_pickups()，并在脚本顶部加入以下内容。</p> 
 <pre><code>var Collectible = preload('res://items/Collectible.tscn')</code></pre> 
 <p style="margin-left:0pt;">尝试运行你的关卡，你应该看到你的宝石和/或樱桃出现在你放置的地方。同时检查当你碰到它们时，它们是否会消失。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E6%BB%9A%E5%8A%A8%E8%83%8C%E6%99%AF" style="margin-left:5.65pt;"><strong><a name="_bookmark313"></a><strong><strong>滚动背景</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">在res://assets/environment/layers文件夹中有两张背景图片：back.png和middle.png，分别用于远处和近处的背景。通过将这两张图片放置在瓦片图的后面，并以相对于摄像机的不同速度滚动，你可以在背景中创造一种有吸引力的深度错觉。</p> 
 <p style="margin-left:0pt;">首先，在关卡场景中添加一个ParallaxBackground节点。这个节点与摄像机一起自动工作以创建滚动效果。把这个节点拖到场景树的顶部，这样它就会被画在其他节点的后面。接下来，添加一个ParallaxLayer节点作为子节点-ParallaxBackground可以有任意数量的ParallaxLayer作为子节点，允许你制作许多独立的滚动层。将一个Sprite节点添加为ParallaxLayer的子节点，并将res://assets/environment/layers/back.png图片拖入到<strong><strong>Texture</strong></strong>。重要--选中<strong><strong>Sprite</strong></strong>的<strong><strong>Centered </strong></strong>属性旁边的方框。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">背景图片有点小，所以将精灵的<strong><strong>Scale</strong></strong>设置为（1.5，1.5）。</p> 
 <p style="margin-left:0pt;">在ParallaxLayer上，将<strong><strong>Motion</strong></strong>/<strong><strong>Scale</strong></strong>设置为(0.2，1)。这个设置控制了背景相对于摄像机滚动的速度。通过将其设置为一个较低的数字，当玩家向左和向右移动时，背景将只移动一小部分。</p> 
 <p style="margin-left:0pt;">接下来，如果你的关卡很宽，你要确保图像重复，所以将<strong><strong>Mirroring</strong></strong>设置为（576，0）。这正好是图像的宽度（384乘以1.5），所以当图像移动了该数量时，图像将被重复。</p> 
 <p style="margin-left:0pt;">注意，这个背景最适合宽而不高的关卡。如果你跳得太高，你会到达背景图像的顶部，突然又看到灰色的空白。你可以通过设置相机的上限来解决这个问题。如果你没有移动它，图像的左上角会在(0，0)，所以你可以将相机的<strong><strong>Top </strong></strong>limit设置为0，如果你已经移动了ParallaxLayer，你可以通过查看节点的<strong><strong>Position</strong></strong>的y值来找到正确的值。</p> 
 <p style="margin-left:0pt;">现在，为中间背景层添加另一个ParallaxLayer（作为第一个的兄弟），并给它一个子节点Sprite。这一次，使用res://assets/environment/layers/middle.png纹理。这个纹理比cloud/sky图像要窄得多，所以你需要做一点额外的调整来使它正确地重复。这是因为ParallaxBackground需要有至少和视口区域一样大的图像。</p> 
 <p style="margin-left:0pt;">首先，点击<strong><strong>FileSystem </strong></strong>dock中的纹理，并选择 "<strong><strong>Import </strong></strong>"选项卡。将<strong><strong>Repeat </strong></strong>属性更改为<strong><strong>Mirrored</strong></strong>，并为<strong><strong>Mipmaps</strong></strong>勾选On。按 "<strong><strong>Reimport</strong></strong>"。现在，纹理可以重复填满屏幕（之后视差系统也会重复）。</p> 
 <p style="text-align:center;"><img alt="" height="391" src="https://images2.imgbox.com/6a/a4/HJORn5bo_o.png" width="234"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">图片的原始尺寸是176x368，需要水平重复。在Sprite属性中，点击 "<strong><strong>On </strong></strong>"进行<strong><strong>Region Enabled</strong></strong>。接下来，将<strong><strong>Rect </strong></strong>属性设置为(0，0，880，368)(880是176乘以5，所以你现在应该看到图像的五个重复)。移动ParallaxLayer，使图像与ocean/cloud图像的下半部分重叠。</p> 
 <p style="margin-left:0pt;">Set the ParallaxLayer <strong><strong>Motion</strong></strong>/<strong><strong>Scale</strong></strong><strong> </strong>to (0.6, 1) and the <strong><strong>Mirroring</strong></strong><strong> </strong>to (880, 0). Using a higher scale factor means this layer will scroll a little faster than the cloud layer behind it, giving a satisfying effect of depth, as shown in the following screenshot:</p> 
 <p style="margin-left:0pt;">设置ParallaxLayer <strong><strong>Motion</strong></strong>/<strong><strong>Scale</strong></strong><strong> </strong>为（0.6，1），<strong><strong>Mirroring</strong></strong><strong> </strong>为（880，0）。使用较高的比例系数意味着这个图层会比后面的云层滚动得更快一些，从而产生令人满意的深度效果，如下截图所示。</p> 
 <p style="text-align:center;"><img alt="" height="357" src="https://images2.imgbox.com/59/35/uPg7O3rz_o.png" width="366"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">一旦你确定一切正常，尝试调整两个图层的<strong><strong>Scale </strong></strong>值，看看它的变化。例如，尝试在中间层上使用(1.2，1)的值，以获得截然不同的视觉效果。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">你的主场景的树现在应该是这样的。</p> 
 <p style="text-align:center;"><img alt="" height="381" src="https://images2.imgbox.com/e4/3e/F9zNoJDy_o.png" width="228"></p> 
 <h4 style="margin-left:5.65pt;"><strong><a name="_bookmark317"></a><strong><strong><a name="_bookmark316"></a></strong></strong></strong></h4> 
 <h4 id="%E5%8D%B1%E9%99%A9%E7%89%A9%E5%93%81" style="margin-left:5.65pt;">危险物品</h4> 
 <p style="margin-left:0pt;"><strong><strong>Danger 地图</strong></strong>层是用来放置尖刺物体的，这些物体如果被碰触到会对玩家造成伤害。试着在你的地图上放置一些它们，你可以很容易地测试碰到它们。需要注意的是，由于TileMaps的工作方式，与这一层上的任何瓦片碰撞都会对玩家造成伤害!</p> 
 <p style="margin-left:0pt;"> </p> 
 <p><strong><a name="_bookmark318"></a></strong>关于滑动碰撞</p> 
 <p style="margin-left:0pt;">当一个KinematicBody2D用move_and_slide()移动时，它可能会在一个给定的帧中与多个对象发生碰撞。例如，当跑到一个角落时，角色可能会同时撞到墙上和地上。你可以使用get_slide_count()方法找出发生了多少次碰撞，然后使用get_slide_collision()获取每次碰撞的信息。</p> 
 <p style="margin-left:0pt;">在Player的情况下，你想检测当碰撞发生在Danger TileMap对象上时，你可以在使用Player.gd中的move_and_slide()之后进行检测。你可以在使用Player.gd中的move_and_slide()之后进行检测。</p> 
 <pre><code>velocity = move_and_slide(velocity, Vector2(0, -1))
if state == HURT:
    return
for idx in range(get_slide_count()):
    var collision = get_slide_collision(idx)
    if collision.collider.name == 'Danger':
        hurt()</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">在检查Danger的碰撞之前，你可以检查玩家是否已经处于HURT状态，如果是，则跳过检查。接下来，你必须使用get_slide_count()来迭代任何可能发生的碰撞。对于每个，你可以检查collider.name是否为Danger。</p> 
 <p style="margin-left:0pt;">运行场景并尝试运行到其中一个尖刺对象。就像你之前在hurt()函数中写的那样，你应该会看到玩家在回到IDLE之前，短暂地变为HURT状态。三次命中后，玩家会进入dead状态，当前将可见性设置为隐藏。</p> 
</div> 
<p> </p> 
<div> 
 <p style="margin-left:0pt;"> </p> 
 <h3 id="%E6%95%8C%E4%BA%BA" style="margin-left:5.65pt;"><strong><a name="Enemies"></a><strong><strong><a name="_bookmark320"></a><a name="_bookmark319"></a>敌人</strong></strong></strong></h3> 
 <p style="margin-left:0pt;">目前，这个地图非常孤单，所以是时候增加一些敌人来活跃一下气氛了。</p> 
 <p style="margin-left:0pt;">你可以为敌人创建许多不同的行为。在这个项目中，敌人会沿着一个平台直线行走，当遇到障碍物时，会反方向行走。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E5%9C%BA%E6%99%AF%E8%AE%BE%E7%BD%AE" style="margin-left:5.65pt;"><strong><a name="_bookmark321"></a><strong><strong>场景设置</strong></strong></strong></h4> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">从KinematicBody2D开始，有三个子节点：Sprite、AnimationPlayer和CollisionShape2D。将场景保存为Enemy.tscn，放在一个名为enemies的新文件夹中。如果你决定在游戏中添加更多的敌人类型，你可以将它们全部保存在这里。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">将物体的碰撞层设置为enemies，将其碰撞掩模设置为environment、player和enemies。对敌人进行分组也是很有用的，所以点击 "<strong><strong>Node </strong></strong>"选项卡，将物体添加到一个名为 "enemies"的组中。</p> 
 <p style="margin-left:0pt;">将res://assets/opossum.png sprite sheet添加到Sprite的<strong><strong>Texture</strong></strong>中。设置<strong><strong>Vframes </strong></strong>为1，<strong><strong>Hframes </strong></strong>为6。添加一个覆盖大部分（但不是全部）图像的矩形碰撞形状，确保碰撞形状的底部与图像脚的底部对齐。</p> 
 <p style="text-align:center;"><img alt="" height="254" src="https://images2.imgbox.com/1a/f4/kL3dQlIq_o.png" width="384"></p> 
 <p style="margin-left:0pt;">在AnimationPlayer中添加一个名为walk的新动画。设置<strong><strong>Length </strong></strong>为0.6秒，<strong><strong>Step </strong></strong>为0.1秒。开启<strong><strong>Looping </strong></strong>和<strong><strong>Autoplay</strong></strong>功能。</p> 
 <p style="margin-left:0pt;"><a name="_bookmark322"></a>走路动画将有两个轨道：一个是设置<strong><strong>Texture</strong></strong>属性，一个是改变<strong><strong>Frame </strong></strong>属性。点击<strong><strong>Texture </strong></strong>旁边的 <strong><strong>Add keyframe</strong></strong>按钮一次，添加第一个轨道，然后点击<strong><strong>Frame </strong></strong>旁边的按钮，重复操作，直到你有0帧到5. 按 "<strong><strong>Play </strong></strong>"键，验证行走路动画是否正确播放。<strong><strong>Animation</strong></strong>面板应该是这样的。</p> 
 <p style="text-align:center;"><img alt="" height="189" src="https://images2.imgbox.com/d2/cf/TKUATofh_o.png" width="721"></p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E8%84%9A%E6%9C%AC" style="margin-left:5.65pt;"><strong><a name="_bookmark323"></a><strong><strong><a name="Script"></a>脚本</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">添加以下脚本：</p> 
 <pre><code>extends KinematicBody2D

export (int) var speed
export (int) var gravity

var velocity = Vector2()
var facing = 1

func _physics_process(delta):
    $Sprite.flip_h = velocity.x &gt; 0
    velocity.y += gravity * delta
    velocity.x = facing * speed

    velocity = move_and_slide(velocity, Vector2(0, -1))
    for idx in range(get_slide_count()):
        var collision = get_slide_collision(idx)
        if collision.collider.name == 'Player':
            collision.collider.hurt()
        if collision.normal.x != 0:
            facing = sign(collision.normal.x)
            velocity.y = -100

    if position.y &gt; 1000:
        queue_free()</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">在这个脚本中，Facing变量跟踪移动的方向（1或-1）。和player一样，当移动时，你会迭代滑动碰撞。如果碰撞的对象是Player，你可以调用它的 hurt()函数。</p> 
 <p style="margin-left:0pt;">接下来，你可以检查碰撞体的法线向量的x分量是否不为0，这意味着它指向左边或右边（即它是一堵墙、一个箱子或其他障碍物）。法线的方向被用来设置新的面向。最后，给身体一个小的上升速度会让反向过渡看起来更吸引人。</p> 
 <p style="margin-left:0pt;">最后，如果因为某些原因，敌人真的从平台上掉下来了，你不希望游戏要永远追踪它掉下来，所以删除任何y坐标变得太大的敌人。</p> 
 <p style="margin-left:0pt;">在 "<strong><strong>Inspector</strong></strong>"中把<strong><strong>Speed </strong></strong>调到50，<strong><strong>Gravity </strong></strong>调到900，然后在你的关卡场景中创建一个敌人。确保它的两边有障碍物，然后播放场景。检查敌人是否在障碍物之间来回走动。试着把玩家放在它的路径上，并验证玩家的hurt()方法是否被调用。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E4%BC%A4%E5%AE%B3%E6%95%8C%E4%BA%BA" style="margin-left:5.65pt;"><strong><a name="_bookmark325"></a></strong>伤害敌人</h4> 
 <p style="margin-left:0pt;">如果玩家不能反击，那是不公平的，所以秉承《超级马里奥兄弟》的传统，跳到敌人身上就能打败它。</p> 
 <p style="margin-left:0pt;">首先在敌人的AnimationPlayer中添加一个新的动画，并将其命名为死亡。设置<strong><strong>Length </strong></strong>为0.3秒，<strong><strong>Step </strong></strong>为0.05。不要为这个动画开启循环。</p> 
 <p style="margin-left:0pt;">这个动画也会设置<strong><strong>Texture </strong></strong>和<strong><strong>Frame</strong></strong>。这次，在为该属性添加关键帧之前，将res://assets/enemy-death.png图片拖入Sprite的<strong><strong>Texture </strong></strong>中。和之前一样，将所有Frame值从0到5进行关键帧。按 "播放 "键查看死亡动画的运行。</p> 
 <p style="margin-left:0pt;">在敌人的脚本中加入以下代码。</p> 
 <pre><code>func take_damage():
    $AnimationPlayer.play('death')
    $CollisionShape2D.disabled = true
    set_physics_process(false)</code></pre> 
 <p style="margin-left:0pt;">当玩家在合适的条件下击中敌人时，它会调用take_damage()，播放死亡动画。它还会在动画播放期间禁用碰撞和移动。</p> 
 <p style="margin-left:0pt;">当死亡动画结束后，就可以删除敌人了，所以要连接AnimationPlayer的animation_finished()信号。这个信号在每次动画结束时都会被调用，所以你需要检查它是否正确。</p> 
 <pre><code>func _on_AnimationPlayer_animation_finished(anim_name):
    if anim_name == 'death':
        queue_free()</code></pre> 
 <p style="margin-left:0pt;">要完成这个过程，请进入Player.gd脚本，并在_physics_process()方法的碰撞检查中添加以下内容。</p> 
 <pre><code>for idx in range(get_slide_count()):
    var collision = get_slide_collision(idx)
    if collision.collider.name == 'Danger':
        hurt()
    if collision.collider.is_in_group('enemies'):
        var player_feet = (position + $CollisionShape2D.shape.extents).y
        if player_feet &lt; collision.collider.position.y:
            collision.collider.take_damage()
            velocity.y = -200
        else:
            hurt()</code></pre> 
 <p style="margin-left:0pt;">这段代码检查玩家脚的y坐标（即其碰撞形状的底部）与敌人的y坐标。如果玩家较高，则敌人受伤；否则，玩家受伤。</p> 
 <p style="margin-left:0pt;"><a name="HUD"></a>运行关卡，并尝试在敌人身上跳跃，以确保所有的工作是预期。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h3 style="margin-left:5.65pt;"><strong><a name="_bookmark327"></a><strong><strong>HUD</strong></strong></strong></h3> 
 <p style="margin-left:0pt;">HUD的目的是显示玩家在游戏过程中需要了解的信息。收集物品会增加玩家的分数，所以需要显示这些信息。玩家还需要看到自己的剩余生命值，这些生命值将以一连串的心形显示。</p> 
 <h4 style="margin-left:5.65pt;"><strong><strong><strong><a name="_bookmark328"></a><a name="_bookmark329"></a>场景设置</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">用MarginContainer节点创建一个新场景。将其命名为HUD并保存在ui文件夹中。将<strong><strong>Layout</strong></strong>设置为<strong><strong>Top Wide</strong></strong>。在<strong><strong>Inspector</strong></strong>的<strong><strong>Custom Constants</strong></strong>部分，设置以下值。</p> 
 <ul><li style="margin-left:0pt;"> <strong><strong>Margin Right</strong></strong>: 50</li><li style="margin-left:0pt;"> <strong><strong>Margin Top</strong></strong>: 20</li><li style="margin-left:0pt;"> <strong><strong>Margin Left</strong></strong>: 50</li><li style="margin-left:0pt;"> <strong><strong>Margin Bottom</strong></strong>: 20</li></ul> 
 <p style="margin-left:0pt;">添加一个HBoxContainer。这个节点将包含所有的UI元素，并保持它们的对齐。它将有两个子节点。</p> 
 <ul><li style="margin-left:0pt;">  Label: ScoreLabel</li><li style="margin-left:0pt;">HBoxContainer: LifeCounter</li></ul> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">在 ScoreLabel 上，设置 <strong><strong>Text </strong></strong>属性为 1，在 <strong><strong>Size Flags</strong></strong> 下，设置 <strong><strong>Horizontal </strong></strong>为 <strong><strong>Fill</strong></strong> 和 <strong><strong>Expand</strong></strong>。使用assets文件夹中的res://assets/Kenney Thick.ttf添加一个自定义DynamicFont，字体大小为48。在<strong><strong>Custom Colors</strong></strong>部分，将<strong><strong>Font </strong></strong><strong><strong>Color</strong></strong>设置为白色，<strong><strong>Font Color Shadow</strong></strong>设置为黑色。最后，在 "<strong><strong>Custom Constants</strong></strong>"下，将 "<strong><strong>Shadow Offset X</strong></strong>"、"<strong><strong>Shadow Offset Y</strong></strong> "和 "<strong><strong>Shadow As Outline</strong></strong>"都设置为5，你应该会看到一个大的白色<strong><strong>1</strong></strong>和一个黑色的轮廓。</p> 
 <p style="margin-left:0pt;">对于LifeCounter，添加一个TextureRect并命名为L1。将res://assets/heart.png拖入其Texture中，并将拉伸模式设置为保持Aspect居中。点击节点，按Ctrl+D键四次，这样你就有了一排五颗心。</p> 
 <p style="text-align:center;"><img alt="" height="308" src="https://images2.imgbox.com/0a/d8/IJSFGnGM_o.png" width="231"></p> 
 <p style="margin-left:0pt;"><a name="_bookmark330"></a></p> 
 <p style="margin-left:0pt;">完成后，你的HUD应该是这样的。</p> 
 <p style="text-align:center;"><img alt="" height="75" src="https://images2.imgbox.com/49/20/GudrCduJ_o.png" width="628"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 style="margin-left:5.65pt;"><strong><strong><strong><a name="_bookmark331"></a>脚本</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">下面是HUD的脚本。</p> 
 <pre><code>extends MarginContainer

onready var life_counter = [$HBoxContainer/LifeCounter/L1,
    $HBoxContainer/LifeCounter/L2,
    $HBoxContainer/LifeCounter/L3,
    $HBoxContainer/LifeCounter/L4,
    $HBoxContainer/LifeCounter/L5
    ]

func _on_Player_life_changed(value):
    for heart in range(life_counter.size()):
        life_counter[heart].visible = value &gt; heart

func _on_score_changed(value):
    $HBoxContainer/ScoreLabel.text = str(value)</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">首先，您需要对五个心指标进行一系列引用。 然后，在_on_Player_life_changed（）中（当玩家受伤或被治愈时会调用它），如果心的数量少于生命值，则可以通过将visible设置为false来计算要显示的心数量。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">_on_score_changed()类似，调用时改变 ScoreLabel 的值。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E9%99%84%E5%8A%A0HUD" style="margin-left:5.65pt;"><strong><a name="_bookmark332"></a><strong><strong>附加HUD</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">打开Level.tscn(基础关卡场景，不是你的Level01场景)并添加一个CanvasLayer节点。将HUD场景作为CanvasLayer的一个子节点。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">点击Player节点，并将其life_changed信号连接到HUD的_on_Player_life_changed()方法:</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="text-align:center;"><img alt="" height="514" src="https://images2.imgbox.com/fc/a1/6gXtm6B3_o.png" width="764"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">接下来，对Level节点的score_changed信号做同样的处理，将其连接到HUD的_on_score_changed。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">替代方法：请注意，如果你不想使用场景树来连接信号，或者你觉得信号连接窗口很混乱，你可以通过在Level.gd的_ready()函数中添加这两行代码来完成同样的事情。</p> 
 <pre><code>$Player.connect('life_changed', $CanvasLayer/HUD,'_on_Player_life_changed')

$Player.connect('dead', self, '_on_Player_dead')

connect('score_changed', $CanvasLayer/HUD, '_on_score_changed')</code></pre> 
 <p style="margin-left:0pt;">运行你的关卡，验证你收集物品时获得积分，受伤时失去心。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h3 id="%E6%A0%87%E9%A2%98%E7%94%BB%E9%9D%A2" style="margin-left:5.65pt;"><strong><a name="_bookmark334"></a></strong>标题画面</h3> 
 <p style="margin-left:0pt;">标题画面是玩家看到的第一个场景。当玩家死亡后，游戏会回到这个场景，让你重新开始。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 style="margin-left:5.65pt;"><strong><a name="_bookmark335"></a><strong><strong><a name="_bookmark336"></a>场景设置</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">从Control节点开始，将<strong><strong>Layout</strong></strong>设置为<strong><strong>Full Rect</strong></strong>。</p> 
 <p style="margin-left:0pt;">添加一个TextureRect。设置它的<strong><strong>Texture </strong></strong>为res://assets/environment/layers/back.png，<strong><strong>Layout </strong></strong>为<strong><strong>Full Rect</strong></strong>，<strong><strong>Stretch</strong></strong><strong> </strong><strong><strong>Mode</strong></strong>为<strong><strong>Keep Aspect</strong></strong><strong> </strong><strong><strong>Covered</strong></strong>。</p> 
 <p style="margin-left:0pt;">添加另一个TextureRect，这次的<strong><strong>Texture </strong></strong>使用res://assets/environment/layers/middle.png，<strong><strong>Stretch Mode</strong></strong>设置为<strong><strong>Tile</strong></strong>。拖动矩形的宽度，直到它比屏幕宽，并将其排列，使其覆盖屏幕的下半部分。</p> 
 <p style="margin-left:0pt;">接下来，添加两个Label节点（Title和Message），并使用前面用于分数标签的相同选项设置它们的<strong><strong>Custom</strong></strong><strong> </strong><strong><strong>Font</strong></strong>设置。将它们的<strong><strong>Tex</strong></strong>t 属性分别设置为<strong><strong>Jungle Jump</strong></strong>和<strong><strong>Press Space to Play</strong></strong>。当你完成后，屏幕应该是这样的。</p> 
 <p style="text-align:center;"><img alt="" height="259" src="https://images2.imgbox.com/c0/13/aYyPCBcy_o.png" width="444"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">为了让标题屏幕更有趣，添加一个AnimationPlayer节点并创建一个新的动画。将其命名为anim并设置为自动播放。在这个动画中，你可以对屏幕上的各个组件进行动画处理，使它们移动、出现、淡入或其他任何你喜欢的效果。</p> 
 <p style="margin-left:0pt;">将<strong><strong>Title </strong></strong>标签拖到屏幕上方的位置，并添加一个关键帧。然后，将其拖回（或在<strong><strong>Position</strong></strong>中手动输入数值），并在0.5秒左右设置另一个关键帧。可以随意添加动画其他节点属性的轨道。</p> 
 <p style="margin-left:0pt;"><a name="_bookmark337"></a>例如，这里有一个动画，它将标题降下来，淡入两个纹理，然后使信息出现（注意每个轨道修改的属性名称）:</p> 
 <p style="text-align:center;"><img alt="" height="230" src="https://images2.imgbox.com/5e/d9/IeOARAc3_o.png" width="806"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h3 id="%E4%B8%BB%E5%9C%BA%E6%99%AF" style="margin-left:5.65pt;"><strong><a name="_bookmark338"></a><strong><strong>主场景</strong></strong></strong></h3> 
 <p style="margin-left:0pt;">删除你添加到临时Main.tscn中的额外节点（Player实例和test StaticBody2D）。现在这个场景将负责加载当前关卡。然而，在它加载之前，你需要一个自动加载脚本来跟踪游戏状态：变量如current_level和其他需要从一个场景到另一个场景的数据。</p> 
 <p style="margin-left:0pt;">在脚本编辑器中添加一个名为GameState.gd的新脚本，并添加以下代码。</p> 
 <pre><code>extends Node

var num_levels = 2
var current_level = 1
var game_scene = 'res://Main.tscn'
var title_screen = 'res://ui/TitleScreen.tscn'

func restart():
    get_tree().change_scene(title_screen)

func next_level():
    current_level += 1
    if current_level &lt;= num_levels:
    get_tree().reload_current_scene()</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">注意，你应该将num_levels设置为你在关卡文件夹中的关卡数量。确保它们的名称一致（Level01.tscn，Level02.tscn，以此类推），然后你就可以自动加载下一个序列。</p> 
 <p style="margin-left:0pt;">在 "<strong><strong>Project Settings</strong></strong> "的 "<strong><strong>AutoLoad </strong></strong> "选项卡中添加此脚本，并将此脚本添加到Main中。</p> 
 <pre><code>extends Node

func _ready():
    # make sure your level numbers are 2 digits ("01", etc.)
    var level_num = str(GameState.current_level).pad_zeros(2)
    var path = 'res://levels/Level%s.tscn' % level_num
    var map = load(path).instance()
    add_child(map)</code></pre> 
 <p>现在，每当加载主场景时，它将加载对应于GameState.current_level。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">标题画面需要过渡到游戏场景，所以将这个脚本附加到TitleScreen节点。</p> 
 <pre><code>extends Control

func _input(event):
    if event.is_action_pressed('ui_select'):
        get_tree().change_scene(GameState.game_scene)</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">你也可以通过在Level.gd中添加方法，在玩家死亡时调用重启函数。</p> 
 <pre><code>func _on_Player_dead():
    GameState.restart()</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E5%85%B3%E5%8D%A1%E8%BF%87%E6%B8%A1" style="margin-left:5.65pt;"><strong><strong><strong><a name="_bookmark340"></a>关卡过渡</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">你的关卡现在需要一种方法来从一个关卡过渡到下一个关卡。在res://assets/environment/layers/props.png sprite sheet中，有一扇门的图像，你可以用它来作为你关卡的出口。找到并走进这扇门会导致玩家进入下一关。</p> 
</div> 
<p> </p> 
<div> 
 <p style="margin-left:0pt;"><strong><strong><strong>门场景</strong></strong></strong></p> 
 <p style="margin-left:0pt;">新建一个名为Door的Area2D场景，并将其保存在物品文件夹中。添加一个Sprite并使用res://assets/environment/layers/props.png sprite sheet以及Region设置来选择门的图像，然后附加一个矩形的CollisionShape2D。这个场景不需要脚本，因为你只是要使用区域的body_entered信号。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">将门放在 collectibles层，并将其遮罩设置为只扫描 player层。</p> 
 <p style="margin-left:0pt;">在你的第一个关卡中实例化这个门的场景，并把它放在玩家可以到达的地方。点击Door节点，将body_entered信号连接到Level.gd脚本中，在这里你可以添加这段代码。</p> 
 <p style="margin-left:0pt;"> </p> 
 <pre><code>func _on_Door_body_entered(body):
    GameState.next_level()</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">运行游戏，试着跑进门里检查一下，会不会马上转移到下一关。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h3 id="%E6%94%B6%E5%B0%BE%E5%B7%A5%E4%BD%9C" style="margin-left:5.65pt;"><strong><a name="_bookmark343"></a></strong>收尾工作</h3> 
 <p style="margin-left:0pt;">现在你已经完成了游戏的结构，你可以考虑一些补充，这样你就可以添加更多的游戏功能，更多的视觉效果，额外的敌人，或者其他你可能有的想法。在本节中，有一些建议的功能--可以按原样添加，也可以根据自己的喜好进行调整。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E9%9F%B3%E6%95%88" style="margin-left:5.65pt;"><strong><a name="_bookmark344"></a></strong>音效</h4> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">与之前的项目一样，你可以添加音频效果和音乐来改善游戏体验。在res://assets/audio文件夹中，你会发现一些文件，你可以用于各种游戏事件，如玩家跳跃、敌人击杀和拾取。还有两个音乐文件:标题屏幕的介绍主题和关卡场景的草原主题。</p> 
 <p style="margin-left:0pt;">将这些添加到游戏中，将留给你，但这里有一些提示。</p> 
 <p style="margin-left:0pt;">确保在 "<strong><strong>Import </strong></strong> "选项卡中，音效的<strong><strong>Loop </strong></strong>设置为 "<strong><strong>Off </strong></strong>"，而音乐文件的循环设置为 "<strong><strong>On</strong></strong>"。</p> 
 <p style="margin-left:0pt;">您可能会发现调整单个声音的音量很有帮助。这可以用音量 Db 属性来设置。设置负值会降低声音的音量。</p> 
 <p style="margin-left:0pt;">您可以将音乐附加到主Level.tscn，该音乐将用于所有关卡（将 AudioStreamPlayer 设置为<strong><strong>Autoplay</strong></strong>）。</p> 
 <p style="margin-left:0pt;">如果您想设置某种心情，您还可以将单独的音乐附加到各个关卡。</p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E6%97%A0%E9%99%90%E8%B7%8C%E8%90%BD" style="margin-left:5.65pt;"><strong><strong><strong>无限跌落</strong></strong></strong></h4> 
 <p style="margin-left:0pt;">根据你设计关卡的方式，玩家有可能完全从关卡上掉下来。通常情况下，你希望通过使用太高而无法跳跃的墙壁、坑底的尖刺等来设计一些东西，使这种情况不可能发生。不过，万一真的发生了，在玩家的_physics_process()方法中加入以下代码。</p> 
 <p style="margin-left:0pt;"> </p> 
 <pre><code>if position.y &gt; 1000:
    change_state(DEAD)</code></pre> 
 <p style="margin-left:0pt;">需要注意的是，如果你设计的关卡延伸的y值在1000下面，你就需要增加这个值来防止意外死亡。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E4%BA%8C%E6%AE%B5%E8%B7%B3" style="margin-left:5.65pt;"><strong><a name="_bookmark347"></a></strong>二段跳</h4> 
 <p style="margin-left:0pt;">二段跳是一种流行的平台功能。如果玩家在空中第二次按下跳跃键，就会获得第二次，通常是较小的向上提升。要实现这个功能，你需要在玩家脚本中添加一些东西。</p> 
 <p style="margin-left:0pt;">首先，你需要两个变量来跟踪状态。</p> 
 <pre><code>var max_jumps = 2
var jump_count = 0</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">进入JUMP状态时，重新设置跳跃次数。</p> 
 <pre><code>JUMP:
    new_anim = 'jump_up'
    jump_count = 1</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">最后，在get_input()中，如果符合条件，允许跳转。</p> 
 <pre><code>if jump and state == JUMP and jump_count &lt; max_jumps:
    new_anim = 'jump_up'
    velocity.y = jump_speed / 1.5
    jump_count += 1</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">请注意，这使得第二次跳跃的上升速度是正常跳跃的2/3。你可以根据自己的喜好来调整这个速度。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E7%81%B0%E5%B0%98%E7%B2%92%E5%AD%90" style="margin-left:5.65pt;"><strong><a name="_bookmark349"></a></strong>灰尘粒子</h4> 
 <p style="margin-left:0pt;">角色脚下的尘埃粒子是一种低能耗的效果，可以为玩家的动作增加很多特色。在本节中，你将在玩家的脚下添加一小团尘埃，每当玩家落地时就会发出。这样可以给玩家的跳跃增加重量感和冲击力。</p> 
 <p style="margin-left:0pt;">添加一个Particles2D节点，并将其命名为Dust。注意警告，必须添加一个过程材料。不过，首先要设置Dust节点的属性。</p> 
 <p style="margin-left:0pt;"> </p> 
 <table border="1" cellspacing="0" style="margin-left:12.05pt;width:425.9pt;"><tbody><tr><td style="vertical-align:top;width:265.65pt;"> <p><strong><strong>Property</strong></strong></p> </td><td style="vertical-align:top;width:160.25pt;"> <p><strong><strong>Value</strong></strong></p> </td></tr><tr><td style="vertical-align:top;width:265.65pt;"> <p>Amount</p> </td><td style="vertical-align:top;width:160.25pt;"> <p>20</p> </td></tr><tr><td style="vertical-align:top;width:265.65pt;"> <p>Lifetime</p> </td><td style="vertical-align:top;width:160.25pt;"> <p>0.45</p> </td></tr><tr><td style="vertical-align:top;width:265.65pt;"> <p>One Shot</p> </td><td style="vertical-align:top;width:160.25pt;"> <p>On</p> </td></tr><tr><td style="vertical-align:top;width:265.65pt;"> <p>Speed Scale</p> </td><td style="vertical-align:top;width:160.25pt;"> <p>2</p> </td></tr><tr><td style="vertical-align:top;width:265.65pt;"> <p>Explosiveness</p> </td><td style="vertical-align:top;width:160.25pt;"> <p>0.7</p> </td></tr><tr><td style="vertical-align:top;width:265.65pt;"> <p>Local Coords</p> </td><td style="vertical-align:top;width:160.25pt;"> <p>Off</p> </td></tr><tr><td style="vertical-align:top;width:265.65pt;"> <p>Position</p> </td><td style="vertical-align:top;width:160.25pt;"> <p>(-2, 15)</p> </td></tr><tr><td style="vertical-align:top;width:265.65pt;"> <p>Rotation</p> </td><td style="vertical-align:top;width:160.25pt;"> <p>-90</p> </td></tr></tbody></table> 
 <p style="margin-left:0pt;">现在，在<strong><strong>Process Material</strong></strong>下，添加一个新的ParticlesMaterial。点击它，你会看到所有的粒子设置。这里是你需要的尘埃效果。</p> 
 <p style="margin-left:0pt;"> </p> 
 <table border="1" cellspacing="0" style="margin-left:12.05pt;width:425.9pt;"><tbody><tr><td style="vertical-align:top;width:274.45pt;"> <p><strong><strong>Particle Property</strong></strong></p> </td><td style="vertical-align:top;width:151.45pt;"> <p><strong><strong>Value</strong></strong></p> </td></tr><tr><td style="vertical-align:top;width:274.45pt;"> <p>Emission Shape</p> </td><td style="vertical-align:top;width:151.45pt;"> <p>Box</p> </td></tr><tr><td style="vertical-align:top;width:274.45pt;"> <p>Box Extents</p> </td><td style="vertical-align:top;width:151.45pt;"> <p>(1, 6, 1)</p> </td></tr><tr><td style="vertical-align:top;width:274.45pt;"> <p>Gravity</p> </td><td style="vertical-align:top;width:151.45pt;"> <p>(0, 0, 0)</p> </td></tr><tr><td style="vertical-align:top;width:274.45pt;"> <p>Initial Velocity</p> </td><td style="vertical-align:top;width:151.45pt;"> <p>10</p> </td></tr><tr><td style="vertical-align:top;width:274.45pt;"> <p>Velocity Random</p> </td><td style="vertical-align:top;width:151.45pt;"> <p>1</p> </td></tr></tbody></table> 
</div> 
<div> 
 <table border="1" cellspacing="0" style="margin-left:12.05pt;width:425.9pt;"><tbody><tr><td style="vertical-align:top;width:274.45pt;"> <p><a name="_bookmark350"></a>Scale</p> </td><td style="vertical-align:top;width:151.45pt;"> <p>5</p> </td></tr><tr><td style="vertical-align:top;width:274.45pt;"> <p>Scale Random</p> </td><td style="vertical-align:top;width:151.45pt;"> <p style="margin-left:3.35pt;">1</p> </td></tr></tbody></table> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">默认的粒子颜色是白色的，但尘埃效果作为棕黄色的阴影会更好看。它还应该渐渐消失，使其看起来消散。这可以通过<strong><strong>Color Ramp</strong></strong>来实现。在 "<strong><strong>Color Ramp</strong></strong>"旁边，点击 "<strong><strong>New GradientTexture</strong></strong>"。在GradientTexture属性中，选择一个新的Gradient。</p> 
 <p style="margin-left:0pt;">渐变有两种颜色：左边是开始颜色，右边是结束颜色。这些颜色由渐变两端的小矩形来选择。点击右边的方块可以设置颜色。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="text-align:center;"><img alt="" height="351" src="https://images2.imgbox.com/8c/61/AGJnmSwl_o.png" width="237"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">将开始颜色设置为棕黄色，将结束颜色设置为相同的颜色，但alpha值设置为0（透明）。您可以通过勾选 "<strong><strong>Inspector</strong></strong>"中的 "<strong><strong>Emitting </strong></strong> "框来测试它的外观。因为节点设置为<strong><strong>One Shot</strong></strong>，所以只会有一团的粒子，你必须再次勾选该框才能发射它们。</p> 
 <p style="margin-left:0pt;">可以随意更改这里列出的属性。实验Particles2D的设置是非常有趣的，往往你会通过修补而发现一个非常好的效果。一旦你对外观感到满意，在播放器的_physics_process()代码中添加以下内容。</p> 
 <pre><code>if state == JUMP and is_on_floor():
    change_state(IDLE)
    $Dust.emitting = true # add this line</code></pre> 
 <p style="margin-left:0pt;">运行游戏，每当你的角色落地时，就会出现一阵小灰尘。</p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E8%B9%B2%E4%BC%8F%E7%8A%B6%E6%80%81" style="margin-left:5.65pt;"><strong><a name="_bookmark351"></a><strong><strong><a name="_bookmark352"></a></strong></strong></strong>蹲伏状态</h4> 
 <p style="margin-left:0pt;">如果你有敌人或弹丸，而玩家需要通过躲在他们下面来躲避，那么蹲下状态就很有用。精灵表包含了这个状态的两帧动画。</p> 
 <p style="text-align:center;"><img alt="" height="111" src="https://images2.imgbox.com/63/76/mdoLKdwc_o.png" width="103"></p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">在玩家的AnimationPlayer中添加一个名为crouch的新动画。将其<strong><strong>Length </strong></strong>设置为0.2，并为<strong><strong>Frame </strong></strong>属性添加一个轨道，将值从3改为4。 将动画设置为循环。</p> 
 <p style="margin-left:0pt;">在玩家的脚本中，将新的状态添加到枚举和状态变化中。</p> 
 <pre><code>enum {IDLE, RUN, JUMP, HURT, DEAD, CROUCH}

CROUCH:
    new_anim = 'crouch'</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">在get_input()方法中，你需要处理各种状态转换。当在地面上时，向下输入应该过渡到CROUCH。当处于CROUCH状态时，释放向下输入应该过渡到IDLE。最后，如果在CROUCH状态下，按下左键或右键，状态应该转变为RUN。</p> 
 <pre><code>var down = Input.is_action_pressed('crouch')

if down and is_on_floor():
    change_state(CROUCH)
if !down and state == CROUCH:
    change_state(IDLE)</code></pre> 
 <p style="margin-left:0pt;">您还需要更改此行：</p> 
 <pre><code>if state == IDLE and velocity.x != 0:
    change_state(RUN)</code></pre> 
 <p style="margin-left:0pt;">对此：</p> 
 <pre><code>if state in [IDLE, CROUCH] and velocity.x != 0:
    change_state(RUN)</code></pre> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;">就是这样！运行游戏并尝试你的新动画状态。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p style="margin-left:0pt;"> </p> 
 <h4 id="%E7%88%AC%E6%A2%AF%E5%AD%90" style="margin-left:5.65pt;"><strong><a name="_bookmark354"></a></strong>爬梯子</h4> 
 <p style="margin-left:0pt;">玩家动画中还包含了攀爬动作的帧，瓦片集包含了梯子。目前，梯子瓦片没有任何作用：在<strong><strong>TileSet</strong></strong>中，它们没有分配任何碰撞形状。这很好，因为你不希望玩家与梯子发生碰撞，你希望能够在梯子上上下移动。</p> 
 <p style="margin-left:0pt;"> </p> 
 <p><strong><a name="_bookmark355"></a><strong><strong>玩家代码</strong></strong></strong></p> 
 <p style="margin-left:0pt;">首先点击播放器的AnimationPlayer，然后添加一个新的动画，命名为climb。它的<strong><strong>Length</strong></strong>要设置为0.4秒，Sprite的<strong><strong>Frame </strong></strong>值为0、1、0、2，将动画设置为循环。</p> 
 <p style="margin-left:0pt;">现在，进入Player.gd，在状态枚举中添加一个新的状态，CLIMB。此外，在顶部的声明中添加两个新变量。</p> 
 <pre><code>export (int) var climb_speed

var is_on_ladder = false</code></pre> 
 <p style="margin-left:0pt;">is_on_ladder将用来判断玩家是否在梯子上。使用它，你可以决定向上的箭头是否应该有任何效果。在<strong><strong>Inspector</strong></strong>中，将 "<strong><strong>Climb Speed</strong></strong> "设置为50。</p> 
 <p style="margin-left:0pt;">在change_state()中，为新状态添加一个条件。</p> 
 <pre><code>CLIMB:
    new_anim = 'climb'</code></pre> 
 <p style="margin-left:0pt;">接下来，在_get_input()中，你需要添加攀爬输入动作，并添加代码来决定何时触发新的状态。添加以下内容。</p> 
 <p style="margin-left:0pt;"> </p> 
</div> 
<pre><code>var climb = Input.is_action_pressed('climb')

if climb and state != CLIMB and is_on_ladder:
    change_state(CLIMB)
if state == CLIMB:
    if climb:
        velocity.y = -climb_speed
    elif down:
        velocity.y = climb_speed
    else:
        velocity.y = 0
        $AnimationPlayer.play("climb")

if state == CLIMB and not is_on_ladder:
    change_state(IDLE)</code></pre> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">这里，你有三个新的条件需要检查。首先，如果玩家不是在CLIMB状态，而是在梯子上，那么按上键应该开始使玩家开始攀爬。其次，如果玩家正在攀爬，那么向上和向下应该使他们相应地移动，但如果没有按下按键，则停止移动。最后，如果玩家在攀爬时离开梯子，则会离开CLIMB状态。</p> 
<p style="margin-left:0pt;">剩下的一个问题是你需要重力在攀爬时停止将玩家往下拉。在_physics_process()的重力代码中添加以下条件。</p> 
<pre><code>if state != CLIMB:
    velocity.y += gravity * delta</code></pre> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">现在，玩家已经准备好了，你可以给你的关卡地图添加一些梯子。</p> 
<p style="margin-left:0pt;"> </p> 
<p><strong><a name="_bookmark357"></a><strong><strong>关卡代码</strong></strong></strong></p> 
<p style="margin-left:0pt;">在地图上的某个地方放置一些梯子瓦片，然后在关卡场景中添加一个梯子区域2D。给这个节点一个矩形的CollisionShape2D。调整区域大小的最好方法是使用网格捕捉。通过菜单打开这个功能，并使用<strong><strong>Configure Snap</strong></strong>...将网格步长设置为（4，4）。</p> 
<p style="text-align:center;"><img alt="" height="181" src="https://images2.imgbox.com/0a/fb/7H7rL8J4_o.png" width="201"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">调整碰撞形状，使其从上到下覆盖梯子的中心部分。如果你把形状做得和梯子完全一样宽，那么玩家即使挂在边上，也会被算作攀爬。你可能会发现这看起来有点奇怪，所以把形状做得比梯子的宽度小一点就可以避免这种情况。</p> 
<p style="margin-left:0pt;">连接梯子的body_entered和body_exited信号，并添加以下代码，让它们设置玩家的梯子变量。</p> 
<pre><code>func _on_Ladder_body_entered(body):
    if body.name == "Player":
        body.is_on_ladder = true

func _on_Ladder_body_exited(body):
    if body.name == "Player":
        body.is_on_ladder = false</code></pre> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">现在你可以试一试了。你应该可以走到梯子上，然后爬上去和下来。请注意，如果你在梯子的顶部，并踏上梯子，你会掉到底部，而不是爬下来（尽管在你掉下来的时候向上按会抓住梯子）。如果你喜欢自动过渡到攀爬状态，你可以在_physics_process()中添加一个额外的下降检查。</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"> </p> 
<h4 id="%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0" style="margin-left:5.65pt;"><strong><a name="_bookmark359"></a><strong><strong>移动平台</strong></strong></strong></h4> 
<p style="margin-left:0pt;">用KinematicBody2D根节点创建一个新场景。添加一个Sprite子节点，使用res://assets/environment/layers/tileset.png sprite sheet作为<strong><strong>Texture</strong></strong>，并启用<strong><strong>Region </strong></strong>，这样你就可以选择一个特定的瓦片。你可能希望你的平台比一个瓦片更宽，所以只要你喜欢，就可以多次复制sprite。打开网格捕捉，这样就可以将精灵排列成一行。</p> 
<p style="text-align:center;"><img alt="" height="181" src="https://images2.imgbox.com/3c/ea/XchOaa8p_o.png" width="201"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"><a name="_bookmark360"></a>网格设置为（8，8）可以很好地对齐瓷砖。添加一个矩形CollisionShape2D，覆盖图像。</p> 
<p style="margin-left:0pt;"> </p> 
<p style="text-align:center;"><img alt="" height="163" src="https://images2.imgbox.com/79/46/6mDYTQYv_o.png" width="361"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">平台移动可以做得非常复杂（跟随路径、改变速度等），但本例将坚持使用一个在两个物体之间水平来回移动的平台。</p> 
<p style="margin-left:0pt;">这是平台的脚本：</p> 
<pre><code>extends KinematicBody2D
export (Vector2) var velocity

func _physics_process(delta):
    var collision = move_and_collide(velocity * delta)
        if collision:
            velocity = velocity.bounce(collision.normal)</code></pre> 
<p style="margin-left:0pt;">这一次，你使用move_and_collide()来移动运动体。这是一个更好的选择，因为当平台与另一堵墙碰撞时，它不应该滑动。相反，它会从碰撞体上反弹。只要你的碰撞形状是矩形的(就像TileMap物体一样)，这个方法就可以正常工作。如果你有一个圆形的物体，反弹可能会让平台向一个奇怪的方向偏离，在这种情况下，你应该使用类似下面的方法来保持运动水平。</p> 
<pre><code>func _physics_process(delta):
    var collision = move_and_collide(velocity * delta)
    if collision:
        velocity.x *= -1</code></pre> 
<p style="margin-left:0pt;">在 "Inspector "中设置 "速度 "为(50，0)，然后进入关卡场景，在关卡中的某个地方实例其中一个对象。确保它在两个物体之间，这样它就可以在它们之间来回移动。</p> 
<p style="margin-left:0pt;"><a name="_bookmark361"></a>运行场景并尝试跳到移动的平台上。由于玩家使用的是move_and_slide()，所以如果你站在平台上，他们会随着平台自动移动。</p> 
<p style="margin-left:0pt;">根据需要将任意数量的这些对象添加到您的关卡中。 它们甚至会相互反弹，因此您可以制作移动平台的链条，覆盖很远的距离，并且需要仔细考虑Player的跳跃时间。</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"> </p> 
<h3 id="%E6%80%BB%E7%BB%93" style="margin-left:5.65pt;"><strong><a name="_bookmark362"></a><strong><strong>总结</strong></strong></strong></h3> 
<p style="margin-left:0pt;">在本章中，您学习了如何使用 KinematicBody2D 节点来创建街机风格的物理。您还使用AnimationPlayer为角色行为创建了各种动画，并广泛使用了您在先前项目中所学到的知识来将所有内容联系在一起。希望到这里，你已经很好地掌握了场景系统和Godot项目的结构。</p> 
<p style="margin-left:0pt;">还记得一开始在 "<strong><strong>Project Settings</strong></strong> "中设置的 "<strong><strong>Stretch Mode</strong></strong> "和 "<strong><strong>Aspect </strong></strong> "属性吗？运行游戏并观察当你调整游戏窗口的大小时会发生什么。这些设置对于这种风格的游戏来说是最好的，但可以尝试将拉伸模式改为视口，然后让你的游戏窗口变得非常宽或高。用其他设置进行实验，看看不同的调整大小选项的效果。</p> 
<p style="margin-left:0pt;">再次，在继续之前，花点时间玩玩你的游戏，看看它的各种场景和脚本，回顾一下你是如何构建它的。回顾本章中任何你觉得特别棘手的部分。</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7a2ac75230d1c0eae4197ec4328de6c3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【LeetCode  剑指offer 06】输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7792555ef9268a931a616032981e18a2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL进阶(三)——索引优化分析(性能分析)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>