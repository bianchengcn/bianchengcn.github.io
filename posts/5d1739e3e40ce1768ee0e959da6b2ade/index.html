<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java基础知识汇总 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java基础知识汇总" />
<meta property="og:description" content="目录
1、Java基础语法
1、类型转换问题
1. 运算符
1.1 算术运算符（理解）
1.2 赋值运算符（应用）
1.3 自增自减运算符（理解）
1.4 关系运算符（应用）
1.5 逻辑运算符（应用）
1.6 三元运算符（理解）
2. 数据输入（应用）
3、流程控制语句（应用）
1.1 流程控制语句分类
1.2 顺序结构
1.3 分支结构：if语句
1.4 分支结构：switch语句
1.5 循环结构：for循环
1.6 循环结构： while循环
1.7 循环结构：do-while循环
1.8 三种循环的区别（理解）
1.9 跳转控制语句（掌握）
1.10 循环嵌套（理解）
1.11 Random
4.数组
1.1什么是数组【理解】
1.2数组定义格式【记忆】
1.3数组动态初始化【应用】
1.4数组元素访问【应用】
1.5内存分配【理解】
1.6单个数组的内存图【理解】
1.7多个数组的内存图【理解】
1.8多个数组指向相同内存图【理解】
1.9数组静态初始化【应用】
1.10数组操作的两个常见小问题【应用】
1.11数组遍历【应用】
1.12数组最值【应用】
5. 方法概述
1.1 方法的概念（理解）
2. 方法的定义和调用
2.1 无参数方法定义和调用（掌握）
2.2 方法调用过程图解（理解）
2.3 无参数方法的练习（应用）
3. 带参数方法定义和调用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5d1739e3e40ce1768ee0e959da6b2ade/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-03T16:18:42+08:00" />
<meta property="article:modified_time" content="2023-04-03T16:18:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java基础知识汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-toc" style="margin-left:0px;"><a href="#1%E3%80%81Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95" rel="nofollow">1、Java基础语法</a></p> 
<p id="0%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#0%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98" rel="nofollow">1、类型转换问题</a></p> 
<p id="1.%20%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#1.%20%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">1. 运算符</a></p> 
<p id="1.1%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.1%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89" rel="nofollow">1.1 算术运算符（理解）</a></p> 
<p id="1.2%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.2%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89" rel="nofollow">1.2 赋值运算符（应用）</a></p> 
<p id="1.3%20%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.3%20%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89" rel="nofollow">1.3 自增自减运算符（理解）</a></p> 
<p id="1.4%20%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.4%20%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89" rel="nofollow">1.4 关系运算符（应用）</a></p> 
<p id="1.5%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.5%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89" rel="nofollow">1.5 逻辑运算符（应用）</a></p> 
<p id="1.6%20%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.6%20%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89" rel="nofollow">1.6 三元运算符（理解）</a></p> 
<p id="2.%20%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.%20%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89" rel="nofollow">2. 数据输入（应用）</a></p> 
<p id="1%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89" rel="nofollow">3、流程控制语句（应用）</a></p> 
<p id="1.1%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E5%88%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1.1%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E5%88%86%E7%B1%BB" rel="nofollow">1.1 流程控制语句分类</a></p> 
<p id="1.2%20%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#1.2%20%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84" rel="nofollow">1.2 顺序结构</a></p> 
<p id="1.3%20%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%EF%BC%9Aif%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px;"><a href="#1.3%20%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%EF%BC%9Aif%E8%AF%AD%E5%8F%A5" rel="nofollow">1.3 分支结构：if语句</a></p> 
<p id="1.4%20%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%EF%BC%9Aswitch%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px;"><a href="#1.4%20%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%EF%BC%9Aswitch%E8%AF%AD%E5%8F%A5" rel="nofollow">1.4 分支结构：switch语句</a></p> 
<p id="1.5%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%9Afor%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px;"><a href="#1.5%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%9Afor%E5%BE%AA%E7%8E%AF" rel="nofollow">1.5 循环结构：for循环</a></p> 
<p id="1.6%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%9A%20while%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px;"><a href="#1.6%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%9A%20while%E5%BE%AA%E7%8E%AF" rel="nofollow">1.6 循环结构： while循环</a></p> 
<p id="1.7%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%9Ado-while%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px;"><a href="#1.7%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%9Ado-while%E5%BE%AA%E7%8E%AF" rel="nofollow">1.7 循环结构：do-while循环</a></p> 
<p id="1.8%20%E4%B8%89%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.8%20%E4%B8%89%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89" rel="nofollow">1.8 三种循环的区别（理解）</a></p> 
<p id="1.9%20%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.9%20%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89" rel="nofollow">1.9 跳转控制语句（掌握）</a></p> 
<p id="1.10%20%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.10%20%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89" rel="nofollow">1.10 循环嵌套（理解）</a></p> 
<p id="1.11%20Random-toc" style="margin-left:80px;"><a href="#1.11%20Random" rel="nofollow">1.11 Random</a></p> 
<p id="1.%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#1.%E6%95%B0%E7%BB%84" rel="nofollow">4.数组</a></p> 
<p id="1.1%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E7%BB%84%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91-toc" style="margin-left:80px;"><a href="#1.1%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E7%BB%84%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91" rel="nofollow">1.1什么是数组【理解】</a></p> 
<p id="1.2%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%E3%80%90%E8%AE%B0%E5%BF%86%E3%80%91-toc" style="margin-left:80px;"><a href="#1.2%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%E3%80%90%E8%AE%B0%E5%BF%86%E3%80%91" rel="nofollow">1.2数组定义格式【记忆】</a></p> 
<p id="1.3%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91-toc" style="margin-left:80px;"><a href="#1.3%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91" rel="nofollow">1.3数组动态初始化【应用】</a></p> 
<p id="1.4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91-toc" style="margin-left:80px;"><a href="#1.4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91" rel="nofollow">1.4数组元素访问【应用】</a></p> 
<p id="1.5%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91-toc" style="margin-left:80px;"><a href="#1.5%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91" rel="nofollow">1.5内存分配【理解】</a></p> 
<p id="1.6%E5%8D%95%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91-toc" style="margin-left:80px;"><a href="#1.6%E5%8D%95%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91" rel="nofollow">1.6单个数组的内存图【理解】</a></p> 
<p id="1.7%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91-toc" style="margin-left:80px;"><a href="#1.7%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91" rel="nofollow">1.7多个数组的内存图【理解】</a></p> 
<p id="1.8%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E7%9B%B8%E5%90%8C%E5%86%85%E5%AD%98%E5%9B%BE%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91-toc" style="margin-left:80px;"><a href="#1.8%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E7%9B%B8%E5%90%8C%E5%86%85%E5%AD%98%E5%9B%BE%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91" rel="nofollow">1.8多个数组指向相同内存图【理解】</a></p> 
<p id="1.9%E6%95%B0%E7%BB%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91-toc" style="margin-left:80px;"><a href="#1.9%E6%95%B0%E7%BB%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91" rel="nofollow">1.9数组静态初始化【应用】</a></p> 
<p id="1.10%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E5%B0%8F%E9%97%AE%E9%A2%98%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91-toc" style="margin-left:80px;"><a href="#1.10%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E5%B0%8F%E9%97%AE%E9%A2%98%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91" rel="nofollow">1.10数组操作的两个常见小问题【应用】</a></p> 
<p id="1.11%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91-toc" style="margin-left:80px;"><a href="#1.11%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91" rel="nofollow">1.11数组遍历【应用】</a></p> 
<p id="1.12%E6%95%B0%E7%BB%84%E6%9C%80%E5%80%BC%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91-toc" style="margin-left:80px;"><a href="#1.12%E6%95%B0%E7%BB%84%E6%9C%80%E5%80%BC%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91" rel="nofollow">1.12数组最值【应用】</a></p> 
<p id="1.%20%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1.%20%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0" rel="nofollow">5. 方法概述</a></p> 
<p id="1.1%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.1%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89" rel="nofollow">1.1 方法的概念（理解）</a></p> 
<p id="2.%20%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.%20%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8" rel="nofollow">2. 方法的定义和调用</a></p> 
<p id="2.1%20%E6%97%A0%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.1%20%E6%97%A0%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89" rel="nofollow">2.1 无参数方法定义和调用（掌握）</a></p> 
<p id="2.2%20%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.2%20%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89" rel="nofollow">2.2 方法调用过程图解（理解）</a></p> 
<p id="2.3%20%E6%97%A0%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%83%E4%B9%A0%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.3%20%E6%97%A0%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%83%E4%B9%A0%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89" rel="nofollow">2.3 无参数方法的练习（应用）</a></p> 
<p id="3.%20%E5%B8%A6%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#3.%20%E5%B8%A6%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8" rel="nofollow">3. 带参数方法定义和调用</a></p> 
<p id="3.1%20%E5%B8%A6%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89-toc" style="margin-left:80px;"><a href="#3.1%20%E5%B8%A6%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89" rel="nofollow">3.1 带参数方法定义和调用（掌握）</a></p> 
<p id="3.2%20%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#3.2%20%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89" rel="nofollow">3.2 形参和实参（理解）</a></p> 
<p id="3.3%20%E5%B8%A6%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E7%BB%83%E4%B9%A0%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#3.3%20%E5%B8%A6%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E7%BB%83%E4%B9%A0%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89" rel="nofollow">3.3 带参数方法练习（应用）</a></p> 
<p id="4.%20%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#4.%20%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8" rel="nofollow">4. 带返回值方法的定义和调用</a></p> 
<p id="4.1%20%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89-toc" style="margin-left:80px;"><a href="#4.1%20%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89" rel="nofollow">4.1 带返回值方法定义和调用（掌握）</a></p> 
<p id="4.2%20%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E6%96%B9%E6%B3%95%E7%BB%83%E4%B9%A0%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#4.2%20%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E6%96%B9%E6%B3%95%E7%BB%83%E4%B9%A0%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89" rel="nofollow">4.2 带返回值方法练习（应用）</a></p> 
<p id="5.%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:40px;"><a href="#5.%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">5. 方法的注意事项</a></p> 
<p id="5.1%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89-toc" style="margin-left:80px;"><a href="#5.1%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89" rel="nofollow">5.1 方法的注意事项（掌握）</a></p> 
<p id="5.2%20%E6%96%B9%E6%B3%95%E7%9A%84%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89-toc" style="margin-left:80px;"><a href="#5.2%20%E6%96%B9%E6%B3%95%E7%9A%84%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89" rel="nofollow">5.2 方法的通用格式（掌握）</a></p> 
<p id="6.%20%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#6.%20%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD" rel="nofollow">6. 方法重载</a></p> 
<p id="6.1%20%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#6.1%20%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89" rel="nofollow">6.1 方法重载（理解）</a></p> 
<p id="6.2%20%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E7%BB%83%E4%B9%A0%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89-toc" style="margin-left:80px;"><a href="#6.2%20%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E7%BB%83%E4%B9%A0%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89" rel="nofollow">6.2 方法重载练习（掌握）</a></p> 
<p id="7.%20%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-toc" style="margin-left:40px;"><a href="#7.%20%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92" rel="nofollow">7. 方法的参数传递</a></p> 
<p id="7.1%20%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#7.1%20%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89" rel="nofollow">7.1 方法参数传递基本类型（理解）</a></p> 
<p id="7.2%20%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#7.2%20%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89" rel="nofollow">7.2 方法参数传递引用类型（理解）</a></p> 
<p id="7.3%20%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#7.3%20%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89" rel="nofollow">7.3 数组遍历（应用）</a></p> 
<p id="7.4%20%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#7.4%20%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89" rel="nofollow">7.4 数组最大值（应用）</a></p> 
<p id="1.%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#1.%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1" rel="nofollow">8. 类和对象</a></p> 
<p id="1.1%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:80px;"><a href="#1.1%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">1.1 类和对象的理解</a></p> 
<p id="1.2%20%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#1.2%20%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">1.2 类的定义</a></p> 
<p id="1.3%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.3%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">1.3 对象的使用</a></p> 
<p id="1.4%20%E5%AD%A6%E7%94%9F%E5%AF%B9%E8%B1%A1-%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#1.4%20%E5%AD%A6%E7%94%9F%E5%AF%B9%E8%B1%A1-%E7%BB%83%E4%B9%A0" rel="nofollow">1.4 学生对象-练习</a></p> 
<p id="2.%20%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE-toc" style="margin-left:40px;"><a href="#2.%20%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE" rel="nofollow">9. 对象内存图</a></p> 
<p id="2.1%20%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE-toc" style="margin-left:80px;"><a href="#2.1%20%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE" rel="nofollow">2.1 单个对象内存图</a></p> 
<p id="2.2%20%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE-toc" style="margin-left:80px;"><a href="#2.2%20%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE" rel="nofollow">2.2 多个对象内存图</a></p> 
<p id="2.3%20%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%8C%87%E5%90%91%E7%9B%B8%E5%90%8C%E5%86%85%E5%AD%98%E5%9B%BE-toc" style="margin-left:80px;"><a href="#2.3%20%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%8C%87%E5%90%91%E7%9B%B8%E5%90%8C%E5%86%85%E5%AD%98%E5%9B%BE" rel="nofollow">2.3 多个对象指向相同内存图</a></p> 
<p id="3.%20%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#3.%20%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" rel="nofollow">10. 成员变量和局部变量</a></p> 
<p id="3.1%20%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#3.1%20%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">3.1 成员变量和局部变量的区别</a></p> 
<p id="4.%20%E5%B0%81%E8%A3%85-toc" style="margin-left:40px;"><a href="#4.%20%E5%B0%81%E8%A3%85" rel="nofollow">11. 封装</a></p> 
<p id="4.1%20private%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:80px;"><a href="#4.1%20private%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">4.1 private关键字</a></p> 
<p id="4.2%20private%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#4.2%20private%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">4.2 private的使用</a></p> 
<p id="4.3%20this%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:80px;"><a href="#4.3%20this%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">4.3 this关键字</a></p> 
<p id="4.4%20this%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#4.4%20this%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86" rel="nofollow">4.4 this内存原理</a></p> 
<p id="4.5%20%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#4.5%20%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3" rel="nofollow">4.5 封装思想</a></p> 
<p id="5.%20%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#5.%20%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">12. 构造方法</a></p> 
<p id="5.1%20%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0-toc" style="margin-left:80px;"><a href="#5.1%20%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0" rel="nofollow">5.1 构造方法概述</a></p> 
<p id="5.2%20%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:80px;"><a href="#5.2%20%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">5.2 构造方法的注意事项</a></p> 
<p id="5.3%20%E6%A0%87%E5%87%86%E7%B1%BB%E5%88%B6%E4%BD%9C-toc" style="margin-left:80px;"><a href="#5.3%20%E6%A0%87%E5%87%86%E7%B1%BB%E5%88%B6%E4%BD%9C" rel="nofollow">5.3 标准类制作</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">1、Java基础语法</h2> 
<p></p> 
<h3 id="0%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98">1、类型转换问题</h3> 
<p>类型转换（理解）</p> 
<p>在Java中，会存在不同类型的数据需要一起参与运算，所以这些数据类型之间是需要相互转换的，分为两种情况：自动类型转换和强制类型转换。</p> 
<p>自动类型转换</p> 
<p>*类型范围小<strong>的变量，可以</strong>直接赋值<strong>给</strong>类型范围大**的变量。</p> 
<p><img alt="" height="95" src="https://images2.imgbox.com/43/09/6ETQbX1H_o.png" width="783"></p> 
<p> </p> 
<p></p> 
<p>把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。例如：</p> 
<pre>double num = 10; // 将int类型的10直接赋值给double类型
System.out.println(num); // 输出10.0
​
byte a = 12 ;
int b = a;
System.out.println(b); // 12
​</pre> 
<p></p> 
<p><strong>表达式的自动类型转换</strong></p> 
<p>在表达式中，小范围类型的变量会自动转换成当前较大范围的类型再运算。</p> 
<p><img alt="" height="46" src="https://images2.imgbox.com/b3/a0/s0R11B8q_o.png" width="710"></p> 
<p> </p> 
<p></p> 
<p><strong>注意事项：</strong></p> 
<p>表达式的最终结果类型由表达式中的最高类型决定。</p> 
<p>在表达式中，byte、short、char 是直接转换成int类型参与运算的。</p> 
<p>强制类型转换</p> 
<p>类型范围大的数据或者变量，不能直接<strong>赋值</strong>给<strong>类型范围小</strong>的变量，会报错，把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量必须进行强制类型转换。</p> 
<p>强制类型转换格式：目标数据类型 变量名 = (目标数据类型)值或者变量;</p> 
<p>例如：</p> 
<pre>double num1 = 5.5;
int num2 = (int) num1; // 将double类型的num1强制转换为int类型
System.out.println(num2); // 输出5（小数位直接舍弃）</pre> 
<p>说明：</p> 
<ol><li> <p>char类型的数据转换为int类型是按照码表中对应的int值进行计算的。比如在ASCII码表中，'a'对应97。</p> </li></ol> 
<pre>int a = 'a';
System.out.println(a); // 将输出97</pre> 
<ol><li> <p>整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。</p> </li></ol> 
<pre>byte b1 = 10;
byte b2 = 20;
byte b3 = b1 + b2; 
// 第三行代码会报错，b1和b2会自动转换为int类型，计算结果为int，int赋值给byte需要强制类型转换。
// 修改为:
int num = b1 + b2;
// 或者：
byte b3 = (byte) (b1 + b2);</pre> 
<ol><li> <p>boolean类型不能与其他基本数据类型相互转换。</p> </li></ol> 
<p></p> 
<h3 id="1.%20%E8%BF%90%E7%AE%97%E7%AC%A6">1. 运算符</h3> 
<h4 id="1.1%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89">1.1 算术运算符（理解）</h4> 
<p>1.1.1 运算符和表达式</p> 
<p>运算符：对常量或者变量进行操作的符号</p> 
<p>表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。</p> 
<p>不同运算符连接的表达式体现的是不同类型的表达式。</p> 
<p>举例说明：</p> 
<pre>int a = 10;
int b = 20;
int c = a + b;</pre> 
<p>+：是运算符，并且是算术运算符。</p> 
<p>a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。</p> 
<p>1.1.2 算术运算符</p> 
<table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>参看小学一年级</td></tr><tr><td>-</td><td>减</td><td>参看小学一年级</td></tr><tr><td>*</td><td>乘</td><td>参看小学二年级，与“×”相同</td></tr><tr><td>/</td><td>除</td><td>参看小学二年级，与“÷”相同</td></tr><tr><td>%</td><td>取余</td><td>获取的是两个数据做除法的余数</td></tr></tbody></table> 
<p>注意：</p> 
<p>/和%的区别：两个数据做除法，/取结果的商，%取结果的余数。</p> 
<p>整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。</p> 
<pre>int a = 10;
int b = 3;
System.out.println(a / b); // 输出结果3
System.out.println(a % b); // 输出结果1</pre> 
<p>1.1.3 字符的“+”操作</p> 
<p>char类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：</p> 
<p>'a' -- 97 a-z是连续的，所以'b'对应的数值是98，'c'是99，依次递加</p> 
<p>'A' -- 65 A-Z是连续的，所以'B'对应的数值是66，'C'是67，依次递加</p> 
<p>'0' -- 48 0-9是连续的，所以'1'对应的数值是49，'2'是50，依次递加</p> 
<pre>// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少
char ch1 = 'a';
System.out.println(ch1 + 1); // 输出98，97 + 1 = 98
​
char ch2 = 'A';
System.out.println(ch2 + 1); // 输出66，65 + 1 = 66
​
char ch3 = '0';
System.out.println(ch3 + 1); // 输出49，48 + 1 = 49</pre> 
<p>算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。</p> 
<p>提升规则：</p> 
<p>byte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。</p> 
<p>整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型</p> 
<p>等级顺序：byte,short,char --&gt; int --&gt; long --&gt; float --&gt; double</p> 
<p>例如：</p> 
<pre>byte b1 = 10;
byte b2 = 20;
// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度
int i3 = b1 + b2; // 应该使用int接收
byte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型
-------------------------------
int num1 = 10;
double num2 = 20.0;
double num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型</pre> 
<p>tips：正是由于上述原因，所以在程序开发中我们很少使用byte或者short类型定义整数。也很少会使用char类型定义字符，而使用字符串类型，更不会使用char类型做算术运算。</p> 
<p></p> 
<p>1.1.4 字符串的“+”操作</p> 
<p>当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。</p> 
<pre>System.out.println("itheima"+ 666); // 输出：itheima666</pre> 
<p>在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。</p> 
<pre>System.out.println(1 + 99 + "年黑马"); // 输出：199年黑马
System.out.println(1 + 2 + "itheima" + 3 + 4); // 输出：3itheima34
// 可以使用小括号改变运算的优先级 
System.out.println(1 + 2 + "itheima" + (3 + 4)); // 输出：3itheima7</pre> 
<h4 id="1.2%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89">1.2 赋值运算符（应用）</h4> 
<p>赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。</p> 
<table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>赋值</td><td>a=10，将10赋值给变量a</td></tr><tr><td>+=</td><td>加后赋值</td><td>a+=b，将a+b的值给a</td></tr><tr><td>-=</td><td>减后赋值</td><td>a-=b，将a-b的值给a</td></tr><tr><td>*=</td><td>乘后赋值</td><td>a*=b，将a×b的值给a</td></tr><tr><td>/=</td><td>除后赋值</td><td>a/=b，将a÷b的商给a</td></tr><tr><td>%=</td><td>取余后赋值</td><td>a%=b，将a÷b的余数给a</td></tr></tbody></table> 
<p>注意：</p> 
<p>扩展的赋值运算符隐含了强制类型转换。</p> 
<pre>short s = 10;
s = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度
​
s += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10);</pre> 
<h4 id="1.3%20%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89">1.3 自增自减运算符（理解）</h4> 
<table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>++</td><td>自增</td><td>变量的值加1</td></tr><tr><td>--</td><td>自减</td><td>变量的值减1</td></tr></tbody></table> 
<p>注意事项：</p> 
<p>++和-- 既可以放在变量的后边，也可以放在变量的前边。</p> 
<p>单独使用的时候， ++和-- 无论是放在变量的前边还是后边，结果是一样的。</p> 
<p>参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者--。</p> 
<p>参与操作的时候，如果放在变量的前边，先拿变量做++或者--，后拿变量参与操作。</p> 
<p>最常见的用法：单独使用。</p> 
<pre>int i = 10;
i++; // 单独使用
System.out.println("i:" + i); // i:11
​
int j = 10;
++j; // 单独使用
System.out.println("j:" + j); // j:11
​
int x = 10;
int y = x++; // 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1
System.out.println("x:" + x + ", y:" + y); // x:11，y:10
​
int m = 10;
int n = ++m; // 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1
System.out.println("m:" + m + ", m:" + m); // m:11，m:11</pre> 
<p>练习：</p> 
<pre>int x = 10;
int y = x++ + x++ + x++;
System.out.println(y); // y的值是多少？
/*
解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增。。。
所以整个式子应该是：int y = 10 + 11 + 12;
输出结果为33。
*/
注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！</pre> 
<h4 id="1.4%20%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89">1.4 关系运算符（应用）</h4> 
<p>关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。</p> 
<table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>==</td><td>a==b，判断a和b的值是否相等，成立为true，不成立为false</td></tr><tr><td>!=</td><td>a!=b，判断a和b的值是否不相等，成立为true，不成立为false</td></tr><tr><td>&gt;</td><td>a&gt;b，判断a是否大于b，成立为true，不成立为false</td></tr><tr><td>&gt;=</td><td>a&gt;=b，判断a是否大于等于b，成立为true，不成立为false</td></tr><tr><td>&lt;</td><td>a&lt;b，判断a是否小于b，成立为true，不成立为false</td></tr><tr><td>&lt;=</td><td>a&lt;=b，判断a是否小于等于b，成立为true，不成立为false</td></tr></tbody></table> 
<p>注意事项：</p> 
<p>关系运算符的结果都是boolean类型，要么是true，要么是false。</p> 
<p>千万不要把“==”误写成“=”，"=="是判断是否相等的关系，"="是赋值。</p> 
<pre>int a = 10;
int b = 20;
System.out.println(a == b); // false
System.out.println(a != b); // true
System.out.println(a &gt; b); // false
System.out.println(a &gt;= b); // false
System.out.println(a &lt; b); // true
System.out.println(a &lt;= b); // true
​
// 关系运算的结果肯定是boolean类型，所以也可以将运算结果赋值给boolean类型的变量
boolean flag = a &gt; b;
System.out.println(flag); // 输出false</pre> 
<h4 id="1.5%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89">1.5 逻辑运算符（应用）</h4> 
<p>逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。</p> 
<table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>逻辑与</td><td>a&amp;b，a和b都是true，结果为true，否则为false</td></tr><tr><td>|</td><td>逻辑或</td><td>a|b，a和b都是false，结果为false，否则为true</td></tr><tr><td>^</td><td>逻辑异或</td><td>a^b，a和b结果不同为true，相同为false</td></tr><tr><td>!</td><td>逻辑非</td><td>!a，结果和a的结果正好相反</td></tr></tbody></table> 
<pre>//定义变量
int i = 10;
int j = 20;
int k = 30;
​
//&amp; “与”，并且的关系，只要表达式中有一个值为false，结果即为false
System.out.println((i &gt; j) &amp; (i &gt; k)); //false &amp; false,输出false
System.out.println((i &lt; j) &amp; (i &gt; k)); //true &amp; false,输出false
System.out.println((i &gt; j) &amp; (i &lt; k)); //false &amp; true,输出false
System.out.println((i &lt; j) &amp; (i &lt; k)); //true &amp; true,输出true
System.out.println("--------");
​
//| “或”，或者的关系，只要表达式中有一个值为true，结果即为true
System.out.println((i &gt; j) | (i &gt; k)); //false | false,输出false
System.out.println((i &lt; j) | (i &gt; k)); //true | false,输出true
System.out.println((i &gt; j) | (i &lt; k)); //false | true,输出true
System.out.println((i &lt; j) | (i &lt; k)); //true | true,输出true
System.out.println("--------");
​
//^ “异或”，相同为false，不同为true
System.out.println((i &gt; j) ^ (i &gt; k)); //false ^ false,输出false
System.out.println((i &lt; j) ^ (i &gt; k)); //true ^ false,输出true
System.out.println((i &gt; j) ^ (i &lt; k)); //false ^ true,输出true
System.out.println((i &lt; j) ^ (i &lt; k)); //true ^ true,输出false
System.out.println("--------");
​
//! “非”，取反
System.out.println((i &gt; j)); //false
System.out.println(!(i &gt; j)); //!false，,输出true</pre> 
<p>短路逻辑运算符</p> 
<table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>短路与</td><td>作用和&amp;相同，但是有短路效果</td></tr><tr><td>||</td><td>短路或</td><td>作用和|相同，但是有短路效果</td></tr></tbody></table> 
<p>在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。</p> 
<ul><li> <p>逻辑与&amp;，无论左边真假，右边都要执行。</p> </li><li> <p>短路与&amp;&amp;，如果左边为真，右边执行；如果左边为假，右边不执行。</p> </li><li> <p>逻辑或|，无论左边真假，右边都要执行。</p> </li><li> <p>短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。</p> </li></ul> 
<pre>int x = 3;
int y = 4;
System.out.println((x++ &gt; 4) &amp; (y++ &gt; 5)); // 两个表达都会运算
System.out.println(x); // 4
System.out.println(y); // 5
​
System.out.println((x++ &gt; 4) &amp;&amp; (y++ &gt; 5)); // 左边已经可以确定结果为false，右边不参与运算
System.out.println(x); // 4
System.out.println(y); // 4</pre> 
<h4 id="1.6%20%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89">1.6 三元运算符（理解）</h4> 
<p>三元运算符语法格式：</p> 
<pre>关系表达式 ? 表达式1 : 表达式2;</pre> 
<p>解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。</p> 
<p>举例：</p> 
<pre>int a = 10;
int b = 20;
int c = a &gt; b ? a : b; // 判断 a&gt;b 是否为真，如果为真取a的值，如果为假，取b的值</pre> 
<p>三元运算符案例：</p> 
<p>1、需求：动物园里有两只老虎，已知两只老虎的体重分别为180kg、200kg，请用程序实现判断两只老虎的体重是否相同。</p> 
<pre>public class OperatorTest01 {
    public static void main(String[] args) {
        //1：定义两个变量用于保存老虎的体重，单位为kg，这里仅仅体现数值即可。
        int weight1 = 180;
        int weight2 = 200;  
        //2：用三元运算符实现老虎体重的判断，体重相同，返回true，否则，返回false。
        boolean b = weight1 == weight2 ? true : false;  
        //3：输出结果
        System.out.println("b:" + b);
    }
}</pre> 
<p>2、需求：一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。</p> 
<pre>public class OperatorTest02 {
    public static void main(String[] args) {
        //1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。
        int height1 = 150;
        int height2 = 210;
        int height3 = 165;  
        //2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。
        int tempHeight = height1 &gt; height2 ? height1 : height2;     
        //3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。
        int maxHeight = tempHeight &gt; height3 ? tempHeight : height3;    
        //4：输出结果
        System.out.println("maxHeight:" + maxHeight);
    }
}</pre> 
<h3 id="2.%20%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89">2. 数据输入（应用）</h3> 
<p>我们可以通过 Scanner 类来获取用户的输入。使用步骤如下：</p> 
<p>1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。</p> 
<pre>import java.util.Scanner; </pre> 
<p>2、创建Scanner对象。</p> 
<pre>Scanner sc = new Scanner(System.in);// 创建Scanner对象，sc表示变量名，其他均不可变</pre> 
<p>3、接收数据</p> 
<pre>int i = sc.nextInt(); // 表示将键盘录入的值作为int数返回。</pre> 
<p>示例：</p> 
<pre>import java.util.Scanner;
public class ScannerDemo {
    public static void main(String[] args) {
        //创建对象
        Scanner sc = new Scanner(System.in);
        //接收数据
        int x = sc.nextInt();
        //输出数据
        System.out.println("x:" + x);
    }
}</pre> 
<p>改写三个和尚案例，数据使用键盘录入。</p> 
<pre>import java.util.Scanner;
public class ScannerTest {
    public static void main(String[] args) {
        //身高未知，采用键盘录入实现。首先导包，然后创建对象。
        Scanner sc = new Scanner(System.in);
        //键盘录入三个身高分别赋值给三个变量。
        System.out.println("请输入第一个和尚的身高：");
        int height1 = sc.nextInt();
        System.out.println("请输入第二个和尚的身高：");
        int height2 = sc.nextInt();
        System.out.println("请输入第三个和尚的身高：");
        int height3 = sc.nextInt();
        //用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。
        int tempHeight = height1 &gt; height2 ? height1 : height2;
        //用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。
        int maxHeight = tempHeight &gt; height3 ? tempHeight : height3;
        //输出结果。
        System.out.println("这三个和尚中身高最高的是：" + maxHeight +"cm");
    }
}</pre> 
<p></p> 
<pre>import java.util.Scanner;
public class IfTest02 {
    public static void main(String[] args) {
        //小明的考试成绩未知，可以使用键盘录入的方式获取值
        Scanner sc = new Scanner(System.in);    
        System.out.println("请输入一个分数：");
        int score = sc.nextInt();
        //由于奖励种类较多，属于多种判断，采用if...else...if格式实现
        //为每种判断设置对应的条件
        //为每种判断设置对应的奖励  
        //数据测试：正确数据，边界数据，错误数据
        if(score&gt;100 || score&lt;0) {
            System.out.println("你输入的分数有误");
        } else if(score&gt;=95 &amp;&amp; score&lt;=100) {
            System.out.println("山地自行车一辆");
        } else if(score&gt;=90 &amp;&amp; score&lt;=94) {
            System.out.println("游乐场玩一次");
        } else if(score&gt;=80 &amp;&amp; score&lt;=89) {
            System.out.println("变形金刚玩具一个");
        } else {
            System.out.println("胖揍一顿");
        }
    }
}
</pre> 
<p></p> 
<h3 id="1%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89">3、流程控制语句（应用）</h3> 
<p>在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。</p> 
<h4 id="1.1%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E5%88%86%E7%B1%BB">1.1 流程控制语句分类</h4> 
<p>顺序结构</p> 
<p>分支结构(if, switch)</p> 
<p>循环结构(for, while, do…while)</p> 
<h4 id="1.2%20%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84">1.2 顺序结构</h4> 
<p>顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p> 
<p>顺序结构执行流程图：</p> 
<p><img alt="" height="245" src="https://images2.imgbox.com/13/9c/Y9mUfLIL_o.png" width="105"></p> 
<p> </p> 
<p></p> 
<h4 id="1.3%20%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%EF%BC%9Aif%E8%AF%AD%E5%8F%A5">1.3 分支结构：if语句</h4> 
<p>if语句格式1</p> 
<pre>格式：
if (关系表达式) {
    语句体;    
}</pre> 
<p>执行流程：</p> 
<p>①首先计算关系表达式的值</p> 
<p>②如果关系表达式的值为true就执行语句体</p> 
<p>③如果关系表达式的值为false就不执行语句体</p> 
<p>④继续执行后面的语句内容</p> 
<p><img alt="" height="213" src="https://images2.imgbox.com/7c/a1/fQkB4JAB_o.png" width="180"></p> 
<p> </p> 
<p></p> 
<p>示例：</p> 
<pre>public class IfDemo {
    public static void main(String[] args) {
        System.out.println("开始");   
        //定义两个变量
        int a = 10;
        int b = 20; 
        //需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b
        if(a == b) {
            System.out.println("a等于b");
        }       
        //需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c
        int c = 10;
        if(a == c) {
            System.out.println("a等于c");
        }       
        System.out.println("结束");
    }
}</pre> 
<p>if语句格式2</p> 
<pre>格式：
if (关系表达式) {
    语句体1;   
} else {
    语句体2;   
}</pre> 
<p>执行流程：</p> 
<p>①首先计算关系表达式的值</p> 
<p>②如果关系表达式的值为true就执行语句体1</p> 
<p>③如果关系表达式的值为false就执行语句体2</p> 
<p>④继续执行后面的语句内容</p> 
<p><img alt="" height="221" src="https://images2.imgbox.com/ab/ae/TUv3h0Tq_o.png" width="257"></p> 
<p> </p> 
<p></p> 
<p>示例：</p> 
<pre>public class IfDemo02 {
    public static void main(String[] args) {
        System.out.println("开始");       
        //定义两个变量
        int a = 10;
        int b = 20;
        b = 5;  
        //需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b
        if(a &gt; b) {
            System.out.println("a的值大于b");
        } else {
            System.out.println("a的值不大于b");
        }       
        System.out.println("结束");
    }
}</pre> 
<p>if语句案例：奇偶数</p> 
<p>需求：任意给出一个整数，请用程序实现判断该整数是奇数还是偶数，并在控制台输出该整数是奇数还是偶数。</p> 
<p>分析：</p> 
<p>①为了体现任意给出一个整数，采用键盘录入一个数据</p> 
<p>②判断整数是偶数还是奇数要分两种情况进行判断，使用if..else结构</p> 
<p>③判断是否偶数需要使用取余运算符实现该功能 number % 2 == 0</p> 
<p>④根据判定情况，在控制台输出对应的内容</p> 
<pre>import java.util.Scanner;
public class IfTest01 {
    public static void main(String[] args) {
        //为了体现任意给出一个整数，采用键盘录入一个数据。(导包，创建对象，接收数据)
        Scanner sc = new Scanner(System.in);        
        System.out.println("请输入一个整数：");
        int number = sc.nextInt();  
        //判断整数是偶数还是奇数要分两种情况进行判断，使用if..else结构        
        //判断是否偶数需要使用取余运算符实现该功能 number % 2 == 0
        //根据判定情况，在控制台输出对应的内容
        if(number%2 == 0) {
            System.out.println(number + "是偶数");
        } else {
            System.out.println(number + "是奇数");
        }   
    }
}</pre> 
<p>if语句格式3</p> 
<pre>格式：
if (关系表达式1) {
    语句体1;   
} else if (关系表达式2) {
    语句体2;   
} 
…
else {
    语句体n+1;
}</pre> 
<p>执行流程：</p> 
<p>①首先计算关系表达式1的值</p> 
<p>②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值</p> 
<p>③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值</p> 
<p>④…</p> 
<p>⑤如果没有任何关系表达式为true，就执行语句体n+1。</p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/53/dc/n4b5lm7n_o.png" width="564"></p> 
<p> </p> 
<p></p> 
<p>示例：键盘录入一个星期数(1,2,...7)，输出对应的星期一，星期二，...星期日</p> 
<pre>import java.util.Scanner;
public class IfDemo03 {
    public static void main(String[] args) {
        System.out.println("开始");
        // 需求：键盘录入一个星期数(1,2,...7)，输出对应的星期一，星期二，...星期日
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个星期数(1-7)：");
        int week = sc.nextInt();
        if(week == 1) {
            System.out.println("星期一");
        } else if(week == 2) {
            System.out.println("星期二");
        } else if(week == 3) {
            System.out.println("星期三");
        } else if(week == 4) {
            System.out.println("星期四");
        } else if(week == 5) {
            System.out.println("星期五");
        } else if(week == 6) {
            System.out.println("星期六");
        } else {
            System.out.println("星期日");
        }   
        System.out.println("结束");
    }
}</pre> 
<p>if语句格式3案例：</p> 
<p>需求：小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。</p> 
<p>分析：</p> 
<p>①小明的考试成绩未知，可以使用键盘录入的方式获取值</p> 
<p>②由于奖励种类较多，属于多种判断，采用if...else...if格式实现</p> 
<p>③为每种判断设置对应的条件</p> 
<p>④为每种判断设置对应的奖励</p> 
<h4 id="1.4%20%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%EF%BC%9Aswitch%E8%AF%AD%E5%8F%A5">1.4 分支结构：switch语句</h4> 
<p>switch语句结构（掌握）</p> 
<ul><li> <p>格式</p> <pre>switch (表达式) {
    case 1:
        语句体1;
        break;
    case 2:
        语句体2;
        break;
    ...
    default:
        语句体n+1;
        break;
}</pre> </li><li> <p>执行流程：</p> 
  <ul><li> <p>首先计算出表达式的值</p> </li><li> <p>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。</p> </li><li> <p>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。</p> </li></ul></li></ul> 
<p>switch语句练习-春夏秋冬（应用）</p> 
<ul><li> <p>需求：一年有12个月，分属于春夏秋冬4个季节，键盘录入一个月份，请用程序实现判断该月份属于哪个季节，并输出。</p> </li><li> <p>运行结果：</p> </li></ul> 
<pre>春：3、4、5
夏：6、7、8
秋：9、10、11
冬：1、2、12</pre> 
<ul><li> <p>示例代码：</p> </li></ul> 
<pre>public class Demo1 {
    public static void main(String[] args) {
        //键盘录入月份数据，使用变量接收
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个月份：");
        int month = sc.nextInt();
        //case穿透
        switch(month) {
            case 1:
            case 2:
            case 12:
                System.out.println("冬季");
                break;
            case 3:
            case 4:
            case 5:
                System.out.println("春季");
                break;
            case 6:
            case 7:
            case 8:
                System.out.println("夏季");
                break;
            case 9:
            case 10:
            case 11:
                System.out.println("秋季");
                break;
            default:
                System.out.println("你输入的月份有误");
        }
    }
}</pre> 
<ul><li> <p>注意：如果switch中得case，没有对应break的话，则会出现case穿透的现象。</p> </li></ul> 
<h4 id="1.5%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%9Afor%E5%BE%AA%E7%8E%AF">1.5 循环结构：for循环</h4> 
<p>for循环结构（掌握）</p> 
<ul><li> <p>循环：</p> <p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。</p> </li><li> <p>for循环格式：</p> </li></ul> 
<pre>for (初始化语句;条件判断语句;条件控制语句) {
	循环体语句;
}</pre> 
<ul><li> <p>格式解释：</p> 
  <ul><li> <p>初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样</p> </li><li> <p>条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去</p> </li><li> <p>循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情</p> </li><li> <p>条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去</p> </li></ul></li><li> <p>执行流程：</p> <p>①执行初始化语句</p> <p>②执行条件判断语句，看其结果是true还是false</p> <p>如果是false，循环结束</p> <p>如果是true，继续执行</p> <p>③执行循环体语句</p> <p>④执行条件控制语句</p> <p>⑤回到②继续</p> </li></ul> 
<p>for循环练习-输出数据（应用）</p> 
<ul><li> <p>需求：在控制台输出1-5和5-1的数据</p> </li><li> <p>示例代码：</p> </li></ul> 
<pre>public class ForTest01 {
    public static void main(String[] args) {
		//需求：输出数据1-5
        for(int i=1; i&lt;=5; i++) {
			System.out.println(i);
		}
		System.out.println("--------");
		//需求：输出数据5-1
		for(int i=5; i&gt;=1; i--) {
			System.out.println(i);
		}
    }
}</pre> 
<p>for循环练习-求和（应用）</p> 
<ul><li> <p>需求：求1-5之间的数据和，并把求和结果在控制台输出</p> </li><li> <p>示例代码：</p> </li></ul> 
<pre>public class ForTest02 {
    public static void main(String[] args) {
		//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0
		int sum = 0;
		//从1开始到5结束的数据，使用循环结构完成
		for(int i=1; i&lt;=5; i++) {
			//将反复进行的事情写入循环结构内部
             // 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中
			sum += i;
			/*
				sum += i;	sum = sum + i;
				第一次：sum = sum + i = 0 + 1 = 1;
				第二次：sum = sum + i = 1 + 2 = 3;
				第三次：sum = sum + i = 3 + 3 = 6;
				第四次：sum = sum + i = 6 + 4 = 10;
				第五次：sum = sum + i = 10 + 5 = 15;
			*/
		}
		//当循环执行完毕时，将最终数据打印出来
		System.out.println("1-5之间的数据和是：" + sum);
    }
}</pre> 
<ul><li> <p>本题要点：</p> 
  <ul><li> <p>今后遇到的需求中，如果带有求和二字，请立即联想到求和变量</p> </li><li> <p>求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的</p> </li></ul></li></ul> 
<p>for循环练习-求偶数和（应用）</p> 
<ul><li> <p>需求：求1-100之间的偶数和，并把求和结果在控制台输出 }</p> </li><li> <p>示例代码：</p> </li></ul> 
<pre>public class ForTest03 {
    public static void main(String[] args) {
		//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0
		int sum = 0;
		//对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同
		for(int i=1; i&lt;=100; i++) {
			//对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数
			if(i%2 == 0) {
				sum += i;
			}
		}
		//当循环执行完毕时，将最终数据打印出来
		System.out.println("1-100之间的偶数和是：" + sum);
    }
}</pre> 
<p>for循环练习-水仙花（应用）</p> 
<ul><li> <p>需求：在控制台输出所有的“水仙花数”</p> </li><li> <p>解释：什么是水仙花数？</p> 
  <ul><li> <p>水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数</p> 
    <ul><li> <p>例如<code>153 3*3*3 + 5*5*5 + 1*1*1 = 153</code></p> </li></ul></li></ul></li><li> <p>思路：</p> 
  <ol><li> <p>获取所有的三位数，准备进行筛选，最小的三位数为100，最大的三位数为999，使用for循环获取</p> </li><li> <p>获取每一个三位数的个位，十位，百位，做if语句判断是否是水仙花数</p> </li></ol></li><li> <p>示例代码</p> </li></ul> 
<pre>public class ForTest04 {
    public static void main(String[] args) {
		//输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束
		for(int i=100; i&lt;1000; i++) {
			//在计算之前获取三位数中每个位上的值
			int ge = i%10;
			int shi = i/10%10;
			int bai = i/10/10%10;
			
			//判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等
			if(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) {
				//输出满足条件的数字就是水仙花数
				System.out.println(i);
			}
		}
    }
}</pre> 
<p>for循环练习-统计水仙花数个数（应用）</p> 
<ul><li> <p>需求：统计“水仙花数”一共有多少个，并在控制台输出个数</p> </li><li> <p>示例代码：</p> </li></ul> 
<pre>public class ForTest05 {
    public static void main(String[] args) {
		//定义变量count，用于保存“水仙花数”的数量，初始值为0
		int count = 0;
		//输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束
		for(int i=100; i&lt;1000; i++) {
			//在计算之前获取三位数中每个位上的值
			int ge = i%10;
			int shi = i/10%10;
			int bai = i/10/10%10;
			//在判定水仙花数的过程中，满足条件不再输出，更改为修改count的值，使count+1
			if(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) {
				count++;
			}
		}
		//打印输出最终结果
		System.out.println("水仙花共有：" + count + "个");
    }
}</pre> 
<ul><li> <p>本题要点：</p> 
  <ul><li> <p>今后如果需求带有统计xxx，请先想到计数器变量</p> </li><li> <p>计数器变量定义的位置，必须在循环外部</p> </li></ul></li></ul> 
<h4 id="1.6%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%9A%20while%E5%BE%AA%E7%8E%AF">1.6 循环结构： while循环</h4> 
<p>while结构（掌握）</p> 
<ul><li> <p>while循环完整格式：</p> <pre>初始化语句;
while (条件判断语句) {
	循环体语句;
    条件控制语句;
}</pre> </li><li> <p>while循环执行流程：</p> <p>①执行初始化语句</p> <p>②执行条件判断语句，看其结果是true还是false</p> <p>如果是false，循环结束</p> <p>如果是true，继续执行</p> <p>③执行循环体语句</p> <p>④执行条件控制语句</p> <p>⑤回到②继续</p> </li><li> <p>示例代码：</p> </li></ul> 
<pre>public class WhileDemo {
    public static void main(String[] args) {
        //需求：在控制台输出5次"HelloWorld"
		//for循环实现
		for(int i=1; i&lt;=5; i++) {
			System.out.println("HelloWorld");
		}
		System.out.println("--------");
		//while循环实现
		int j = 1;
		while(j&lt;=5) {
			System.out.println("HelloWorld");
			j++;
		}
    }
}</pre> 
<p>while循环练习-珠穆朗玛峰（应用）</p> 
<ul><li> <p>需求：世界最高山峰是珠穆朗玛峰(8844.43米=8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度?</p> </li><li> <p>示例代码：</p> </li></ul> 
<pre>public class WhileTest {
    public static void main(String[] args) {
		//定义一个计数器，初始值为0
		int count = 0;
		//定义纸张厚度
		double paper = 0.1;
		//定义珠穆朗玛峰的高度
		int zf = 8844430;
		//因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环
		//折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度
		while(paper &lt;= zf) {
			//循环的执行过程中每次纸张折叠，纸张的厚度要加倍
			paper *= 2;
			//在循环中执行累加，对应折叠了多少次
			count++;
		}
		//打印计数器的值
		System.out.println("需要折叠：" + count + "次");
    }
}</pre> 
<h4 id="1.7%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%9Ado-while%E5%BE%AA%E7%8E%AF">1.7 循环结构：do-while循环</h4> 
<p>do...while循环结构（掌握）</p> 
<ul><li> <p>完整格式：</p> <pre>初始化语句;
do {
	循环体语句;
	条件控制语句;
}while(条件判断语句);</pre> </li><li> <p>执行流程：</p> <p>① 执行初始化语句</p> <p>② 执行循环体语句</p> <p>③ 执行条件控制语句</p> <p>④ 执行条件判断语句，看其结果是true还是false</p> <p>如果是false，循环结束</p> <p>如果是true，继续执行</p> <p>⑤ 回到②继续</p> </li><li> <p>示例代码：</p> </li></ul> 
<pre>public class DoWhileDemo {
    public static void main(String[] args) {
        //需求：在控制台输出5次"HelloWorld"
		//for循环实现
		for(int i=1; i&lt;=5; i++) {
			System.out.println("HelloWorld");
		}
		System.out.println("--------");
		//do...while循环实现
		int j = 1;
		do {
			System.out.println("HelloWorld");
			j++;
		}while(j&lt;=5);
    }
}</pre> 
<h4 id="1.8%20%E4%B8%89%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89">1.8 三种循环的区别（理解）</h4> 
<ul><li> <p>三种循环的区别</p> 
  <ul><li> <p>for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）</p> </li><li> <p>do...while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）</p> </li></ul></li><li> <p>for循环和while的区别</p> 
  <ul><li> <p>条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了</p> </li><li> <p>条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用</p> </li></ul></li><li> <p>死循环（无限循环）的三种格式</p> 
  <ol><li> <p>for(;;){}</p> </li><li> <p>while(true){}</p> </li><li> <p>do {} while(true);</p> </li></ol></li></ul> 
<h4 id="1.9%20%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89">1.9 跳转控制语句（掌握）</h4> 
<ul><li> <p>跳转控制语句（break）</p> 
  <ul><li> <p>跳出循环，结束循环</p> </li></ul></li><li> <p>跳转控制语句（continue）</p> 
  <ul><li> <p>跳过本次循环，继续下次循环</p> </li></ul></li><li> <p>注意： continue只能在循环中进行使用！</p> </li></ul> 
<h4 id="1.10%20%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89">1.10 循环嵌套（理解）</h4> 
<ul><li> <p>循环嵌套概述：在循环中，继续定义循环</p> </li><li> <p>示例代码：</p> <pre>	public static void main(String[] args) {
        //外循环控制小时的范围，内循环控制分钟的范围
        for (int hour = 0; hour &lt; 24; hour++) {
            for (int minute = 0; minute &lt; 60; minute++) {
                System.out.println(hour + "时" + minute + "分");
            }
            System.out.println("--------");
        }
    }</pre> </li><li> <p>理解：</p> 
  <ul><li> <p>请反复理解这句话（整个内循环，就是外循环的一个循环体，内部循环体没有执行完毕，外循环是不会继续向下执行的）</p> </li></ul></li><li> <p>结论：</p> 
  <ul><li> <p>外循环执行一次，内循环执行一圈</p> </li></ul></li></ul> 
<h4 id="1.11%20Random">1.11 Random</h4> 
<p>Random产生随机数（掌握）</p> 
<ul><li> <p>概述：</p> 
  <ul><li> <p>Random类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能</p> 
    <ul><li> <p>API后续课程详细讲解，现在可以简单理解为Java已经写好的代码</p> </li></ul></li></ul></li><li> <p>使用步骤：</p> 
  <ol><li> <p>导入包</p> <p>import java.util.Random;</p> </li><li> <p>创建对象</p> <p>Random r = new Random();</p> </li><li> <p>产生随机数</p> <p>int num = r.nextInt(10);</p> <p>解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19</p> </li></ol></li><li> <p>示例代码：</p> </li></ul> 
<pre>import java.util.Random;
public class RandomDemo {
	public static void main(String[] args) {
		//创建对象
		Random r = new Random();
		//用循环获取10个随机数
		for(int i=0; i&lt;10; i++) {
			//获取随机数
			int number = r.nextInt(10);
			System.out.println("number:" + number);
		}
		//需求：获取一个1-100之间的随机数
		int x = r.nextInt(100) + 1;
		System.out.println(x);
	}
}</pre> 
<p>Random练习-猜数字（应用）</p> 
<ul><li> <p>需求：</p> <p>程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？</p> <p>当猜错的时候根据不同情况给出相应的提示</p> <p>A. 如果猜的数字比真实数字大，提示你猜的数据大了</p> <p>B. 如果猜的数字比真实数字小，提示你猜的数据小了</p> <p>C. 如果猜的数字与真实数字相等，提示恭喜你猜中了</p> </li><li> <p>示例代码：</p> </li></ul> 
<pre>import java.util.Random;
import java.util.Scanner;

public class RandomTest {
	public static void main(String[] args) {
		//要完成猜数字的游戏，首先需要有一个要猜的数字，使用随机数生成该数字，范围1到100
		Random r = new Random();
		int number = r.nextInt(100) + 1;
		
		while(true) {
			//使用程序实现猜数字，每次均要输入猜测的数字值，需要使用键盘录入实现
			Scanner sc = new Scanner(System.in);
			
			System.out.println("请输入你要猜的数字：");
			int guessNumber = sc.nextInt();
			
			//比较输入的数字和系统产生的数据，需要使用分支语句。
             //这里使用if..else..if..格式，根据不同情况进行猜测结果显示
			if(guessNumber &gt; number) {
				System.out.println("你猜的数字" + guessNumber + "大了");
			} else if(guessNumber &lt; number) {
				System.out.println("你猜的数字" + guessNumber + "小了");
			} else {
				System.out.println("恭喜你猜中了");
				break;
			}
		}
		
	}
}</pre> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="1.%E6%95%B0%E7%BB%84">4.数组</h3> 
<h4 id="1.1%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E7%BB%84%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91">1.1什么是数组【理解】</h4> 
<p>数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。</p> 
<h4 id="1.2%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%E3%80%90%E8%AE%B0%E5%BF%86%E3%80%91">1.2数组定义格式【记忆】</h4> 
<p>1.2.1第一种</p> 
<p>数据类型[] 数组名</p> 
<p>示例：</p> 
<pre>int[] arr;        
double[] arr;      
char[] arr;</pre> 
<p>1.2.2第二种</p> 
<p>数据类型 数组名[]</p> 
<p>示例：</p> 
<pre>int arr[];
double arr[];
char arr[];</pre> 
<h4 id="1.3%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91">1.3数组动态初始化【应用】</h4> 
<p>1.3.1什么是动态初始化</p> 
<p>数组动态初始化就是只给定数组的长度，由系统给出默认初始化值。</p> 
<p>1.3.2动态初始化格式</p> 
<pre>数据类型[] 数组名 = new 数据类型[数组长度];</pre> 
<pre>int[] arr = new int[3];</pre> 
<p>1.3.3动态初始化格式详解</p> 
<ul><li> <p>等号左边：</p> 
  <ul><li> <p>int:数组的数据类型</p> </li><li> <p>[]:代表这是一个数组</p> </li><li> <p>arr:代表数组的名称</p> </li></ul></li><li> <p>等号右边：</p> 
  <ul><li> <p>new:为数组开辟内存空间</p> </li><li> <p>int:数组的数据类型</p> </li><li> <p>[]:代表这是一个数组</p> </li><li> <p>5:代表数组的长度</p> </li></ul></li></ul> 
<h4 id="1.4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91">1.4数组元素访问【应用】</h4> 
<p>1.4.1什么是索引</p> 
<p>每一个存储到数组的元素，都会自动的拥有一个编号，从0开始。</p> 
<p>这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。</p> 
<p>1.4.2访问数组元素格式</p> 
<pre>数组名[索引];</pre> 
<p>1.4.3示例代码</p> 
<pre>public class ArrayDemo {
    public static void main(String[] args) {
        int[] arr = new int[3];
​
        //输出数组名
        System.out.println(arr); //[I@880ec60
​
        //输出数组中的元素
        System.out.println(arr[0]);
        System.out.println(arr[1]);
        System.out.println(arr[2]);
    }
}</pre> 
<h4 id="1.5%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91">1.5内存分配【理解】</h4> 
<p>1.5.1内存概述</p> 
<p>内存是计算机中的重要原件，临时存储区域，作用是运行程序。</p> 
<p>我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的。</p> 
<p>必须放进内存中才能运行，运行完毕后会清空内存。</p> 
<p>Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p> 
<p>1.5.2java中的内存分配</p> 
<ul><li> <p>目前我们只需要记住两个内存，分别是：栈内存和堆内存</p> </li></ul> 
<table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器</td><td>给CPU使用，和我们开发无关。</td></tr><tr><td>本地方法栈</td><td>JVM在使用操作系统功能的时候使用，和我们开发无关。</td></tr><tr><td>方法区</td><td>存储可以运行的class文件。</td></tr><tr><td>堆内存</td><td>存储对象或者数组，new来创建的，都存储在堆内存。</td></tr><tr><td>方法栈</td><td>方法运行时使用的内存，比如main方法运行，进入方法栈中执行。</td></tr></tbody></table> 
<h4 id="1.6%E5%8D%95%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91">1.6单个数组的内存图【理解】</h4> 
<h4 id="1.7%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91">1.7多个数组的内存图【理解】</h4> 
<h4 id="1.8%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E7%9B%B8%E5%90%8C%E5%86%85%E5%AD%98%E5%9B%BE%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91">1.8多个数组指向相同内存图【理解】</h4> 
<h4 id="1.9%E6%95%B0%E7%BB%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91">1.9数组静态初始化【应用】</h4> 
<p>1.9.1什么是静态初始化</p> 
<p>在创建数组时，直接将元素确定</p> 
<p>1.9.2静态初始化格式</p> 
<ul><li> <p>完整版格式</p> <pre>数据类型[] 数组名 = new 数据类型[]{元素1,元素2,...};</pre> </li><li> <p>简化版格式</p> <pre>数据类型[] 数组名 = {元素1,元素2,...};</pre> </li></ul> 
<p>1.9.3示例代码</p> 
<pre>public class ArrayDemo {
    public static void main(String[] args) {
        //定义数组
        int[] arr = {1, 2, 3};

        //输出数组名
        System.out.println(arr);

        //输出数组中的元素
        System.out.println(arr[0]);
        System.out.println(arr[1]);
        System.out.println(arr[2]);
    }
}</pre> 
<h4 id="1.10%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E5%B0%8F%E9%97%AE%E9%A2%98%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91">1.10数组操作的两个常见小问题【应用】</h4> 
<p>1.10.1索引越界异常</p> 
<ul><li> <p>出现原因</p> <pre>public class ArrayDemo {
    public static void main(String[] args) {
        int[] arr = new int[3];
        System.out.println(arr[3]);
    }
}</pre> <p>数组长度为3，索引范围是0~2，但是我们却访问了一个3的索引。</p> <p>程序运行后，将会抛出ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。</p> </li><li> <p>解决方案</p> <p>将错误的索引修改为正确的索引范围即可！</p> </li></ul> 
<p>1.10.2空指针异常</p> 
<ul><li> <p>出现原因</p> <pre>public class ArrayDemo {
    public static void main(String[] args) {
        int[] arr = new int[3];

        //把null赋值给数组
        arr = null;
        System.out.println(arr[0]);
    }
}</pre> <p>arr = null 这行代码，意味着变量arr将不会再保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。</p> </li><li> <p>解决方案</p> <p>给数组一个真正的堆内存空间引用即可！</p> </li></ul> 
<h4 id="1.11%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91">1.11数组遍历【应用】</h4> 
<ul><li> <p>数组遍历：就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。</p> <pre>public class ArrayTest01 {
	public static void main(String[] args) {
		int[] arr = { 1, 2, 3, 4, 5 };
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		System.out.println(arr[2]);
		System.out.println(arr[3]);
		System.out.println(arr[4]);
	}
}</pre> <p>以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是 0 到 lenght-1 ，可以作为循环的条件出现。</p> <pre>public class ArrayTest01 {
    public static void main(String[] args) {
        //定义数组
        int[] arr = {11, 22, 33, 44, 55};

        //使用通用的遍历格式
        for(int x = 0; x &lt; arr.length; x++) {
            System.out.println(arr[x]);
        }
    }
}</pre> </li></ul> 
<h4 id="1.12%E6%95%B0%E7%BB%84%E6%9C%80%E5%80%BC%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91">1.12数组最值【应用】</h4> 
<ul><li> <p>最大值获取：从数组的所有元素中找出最大值。</p> </li><li> <p>实现思路：</p> 
  <ul><li> <p>定义变量，保存数组0索引上的元素</p> </li><li> <p>遍历数组，获取出数组中的每个元素</p> </li><li> <p>将遍历到的元素和保存数组0索引上值的变量进行比较</p> </li><li> <p>如果数组元素的值大于了变量的值，变量记录住新的值</p> </li><li> <p>数组循环遍历结束，变量保存的就是数组中的最大值</p> </li></ul></li><li> <p>代码实现：</p> <pre>public class ArrayTest02 {
    public static void main(String[] args) {
        //定义数组
        int[] arr = {12, 45, 98, 73, 60};
        //定义一个变量，用于保存最大值
        //取数组中第一个数据作为变量的初始值
        int max = arr[0];
        //与数组中剩余的数据逐个比对，每次比对将最大值保存到变量中
        for(int x=1; x&lt;arr.length; x++) {
            if(arr[x] &gt; max) {
                max = arr[x];
            }
        }
        //循环结束后打印变量的值
        System.out.println("max:" + max);
    }
}</pre> </li></ul> 
<p></p> 
<p></p> 
<h3 id="1.%20%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0">5. 方法概述</h3> 
<h4 id="1.1%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89">1.1 方法的概念（理解）</h4> 
<p>方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p> 
<ul><li> <p>注意：</p> 
  <ul><li> <p>方法必须先创建才可以使用，该过程成为方法定义</p> </li><li> <p>方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用</p> </li></ul></li></ul> 
<h3 id="2.%20%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8">2. 方法的定义和调用</h3> 
<h4 id="2.1%20%E6%97%A0%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89">2.1 无参数方法定义和调用（掌握）</h4> 
<ul><li> <p>定义格式：</p> <pre>public static void 方法名 (   ) {
    // 方法体;
}</pre> </li><li> <p>范例：</p> <pre>public static void method (    ) {
    // 方法体;
}</pre> </li><li> <p>调用格式：</p> <pre>方法名();</pre> </li><li> <p>范例：</p> <pre>method();</pre> </li><li> <p>注意：</p> <p>方法必须先定义，后调用，否则程序将报错</p> </li></ul> 
<h4 id="2.2%20%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89">2.2 方法调用过程图解（理解）</h4> 
<p><img alt="" height="570" src="https://images2.imgbox.com/6a/87/dbzVuPg9_o.png" width="823"></p> 
<p> </p> 
<p></p> 
<ul><li> <p>总结：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。</p> </li></ul> 
<h4 id="2.3%20%E6%97%A0%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%83%E4%B9%A0%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89">2.3 无参数方法的练习（应用）</h4> 
<ul><li> <p>需求：设计一个方法用于打印两个数中的较大数</p> </li><li> <p>思路：</p> 
  <ul><li> <p>①定义一个方法，用于打印两个数字中的较大数，例如getMax()</p> </li><li> <p>②方法中定义两个变量，用于保存两个数字</p> </li><li> <p>③使用分支语句分两种情况对两个数字的大小关系进行处理</p> </li><li> <p>④在main()方法中调用定义好的方法</p> </li></ul></li><li> <p>代码：</p> </li></ul> 
<pre>public class MethodTest {
    public static void main(String[] args) {
        //在main()方法中调用定义好的方法
        getMax();
    }
​
    //定义一个方法，用于打印两个数字中的较大数，例如getMax()
    public static void getMax() {
        //方法中定义两个变量，用于保存两个数字
        int a = 10;
        int b = 20;
​
        //使用分支语句分两种情况对两个数字的大小关系进行处理
        if(a &gt; b) {
            System.out.println(a);
        } else {
            System.out.println(b);
        }
    }
}</pre> 
<h3 id="3.%20%E5%B8%A6%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8">3. 带参数方法定义和调用</h3> 
<h4 id="3.1%20%E5%B8%A6%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89">3.1 带参数方法定义和调用（掌握）</h4> 
<ul><li> <p>定义格式：</p> <p>参数：由数据类型和变量名组成 - 数据类型 变量名</p> <p>参数范例：int a</p> <pre>public static void 方法名 (参数1) {
    方法体;
}
​
public static void 方法名 (参数1, 参数2, 参数3...) {
    方法体;
}</pre> </li><li> <p>范例：</p> <pre>public static void isEvenNumber(int number){
    ...
}
public static void getMax(int num1, int num2){
    ...
}</pre> 
  <ul><li> <p>注意：</p> <pre>方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错
​
方法定义时，多个参数之间使用逗号( ，)分隔</pre> </li></ul></li><li> <p>调用格式：</p> <pre>方法名(参数)；

方法名(参数1,参数2);</pre> </li><li> <p>范例：</p> <pre>isEvenNumber(10);

getMax(10,20);</pre> 
  <ul><li> <p>方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错</p> </li></ul></li></ul> 
<h4 id="3.2%20%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89">3.2 形参和实参（理解）</h4> 
<ol><li> <p>形参：方法定义中的参数</p> </li></ol> 
<p>等同于变量定义格式，例如：int number</p> 
<ol><li> <p>实参：方法调用中的参数</p> </li></ol> 
<p>等同于使用变量或常量，例如： 10 number</p> 
<h4 id="3.3%20%E5%B8%A6%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E7%BB%83%E4%B9%A0%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89">3.3 带参数方法练习（应用）</h4> 
<ul><li> <p>需求：设计一个方法用于打印两个数中的较大数，数据来自于方法参数 }</p> </li><li> <p>思路：</p> 
  <ul><li> <p>①定义一个方法，用于打印两个数字中的较大数，例如getMax()</p> </li><li> <p>②为方法定义两个参数，用于接收两个数字</p> </li><li> <p>③使用分支语句分两种情况对两个数字的大小关系进行处理</p> </li><li> <p>④在main()方法中调用定义好的方法（使用常量）</p> </li><li> <p>⑤在main()方法中调用定义好的方法（使用变量）</p> </li></ul></li><li> <p>代码：</p> </li></ul> 
<pre>public class MethodTest {
    public static void main(String[] args) {
        //在main()方法中调用定义好的方法（使用常量）
        getMax(10,20);
        //调用方法的时候，人家要几个，你就给几个，人家要什么类型的，你就给什么类型的
        //getMax(30);
        //getMax(10.0,20.0);

        //在main()方法中调用定义好的方法（使用变量）
        int a = 10;
        int b = 20;
        getMax(a, b);
    }

    //定义一个方法，用于打印两个数字中的较大数，例如getMax()
    //为方法定义两个参数，用于接收两个数字
    public static void getMax(int a, int b) {
        //使用分支语句分两种情况对两个数字的大小关系进行处理
        if(a &gt; b) {
            System.out.println(a);
        } else {
            System.out.println(b);
        }
    }
}</pre> 
<h3 id="4.%20%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8">4. 带返回值方法的定义和调用</h3> 
<h4 id="4.1%20%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89">4.1 带返回值方法定义和调用（掌握）</h4> 
<ul><li> <p>定义格式</p> <pre>public static 数据类型 方法名 ( 参数 ) { 
	return 数据 ;
}</pre> </li><li> <p>范例</p> <pre>public static boolean isEvenNumber( int number ) {           
	return true ;
}
public static int getMax( int a, int b ) {
	return  100 ;
}</pre> 
  <ul><li> <p>注意：</p> 
    <ul><li> <p>方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错</p> </li></ul></li></ul></li><li> <p>调用格式</p> <pre>方法名 ( 参数 ) ;
数据类型 变量名 = 方法名 ( 参数 ) ;</pre> </li><li> <p>范例</p> <pre>isEvenNumber ( 5 ) ;
boolean  flag =  isEvenNumber ( 5 ); </pre> 
  <ul><li> <p>注意：</p> 
    <ul><li> <p>方法的返回值通常会使用变量接收，否则该返回值将无意义</p> </li></ul></li></ul></li></ul> 
<h4 id="4.2%20%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E6%96%B9%E6%B3%95%E7%BB%83%E4%B9%A0%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89">4.2 带返回值方法练习（应用）</h4> 
<ul><li> <p>需求：设计一个方法可以获取两个数的较大值，数据来自于参数</p> </li><li> <p>思路：</p> 
  <ul><li> <p>①定义一个方法，用于获取两个数字中的较大数</p> </li><li> <p>②使用分支语句分两种情况对两个数字的大小关系进行处理</p> </li><li> <p>③根据题设分别设置两种情况下对应的返回结果</p> </li><li> <p>④在main()方法中调用定义好的方法并使用变量保存</p> </li><li> <p>⑤在main()方法中调用定义好的方法并直接打印结果</p> </li></ul></li><li> <p>代码：</p> <pre>public class MethodTest {
    public static void main(String[] args) {
        //在main()方法中调用定义好的方法并使用变量保存
        int result = getMax(10,20);
        System.out.println(result);

        //在main()方法中调用定义好的方法并直接打印结果
        System.out.println(getMax(10,20));
    }

    //定义一个方法，用于获取两个数字中的较大数
    public static int getMax(int a, int b) {
        //使用分支语句分两种情况对两个数字的大小关系进行处理
        //根据题设分别设置两种情况下对应的返回结果
        if(a &gt; b) {
            return a;
        } else {
            return b;
        }
    }
}</pre> </li></ul> 
<h3 id="5.%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5. 方法的注意事项</h3> 
<h4 id="5.1%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89">5.1 方法的注意事项（掌握）</h4> 
<ul><li> <p>方法不能嵌套定义</p> 
  <ul><li> <p>示例代码：</p> <pre>public class MethodDemo {
    public static void main(String[] args) {

    }

    public static void methodOne() {
		public static void methodTwo() {
       		// 这里会引发编译错误!!!
    	}
    }
}</pre> </li></ul></li><li> <p>void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据</p> 
  <ul><li> <p>示例代码：</p> <pre>public class MethodDemo {
    public static void main(String[] args) {

    }
    public static void methodTwo() {
        //return 100; 编译错误，因为没有具体返回值类型
        return;	
        //System.out.println(100); return语句后面不能跟数据或代码
    }
}</pre> </li></ul></li></ul> 
<h4 id="5.2%20%E6%96%B9%E6%B3%95%E7%9A%84%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89">5.2 方法的通用格式（掌握）</h4> 
<ul><li> <p>格式：</p> <pre>public static 返回值类型 方法名(参数) {
   方法体; 
   return 数据 ;
}</pre> </li><li> <p>解释：</p> 
  <ul><li> <p>public static 修饰符，目前先记住这个格式</p> <p>返回值类型 方法操作完毕之后返回的数据的数据类型</p> <p>如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return</p> <p>方法名 调用方法时候使用的标识</p> <p>参数 由数据类型和变量名组成，多个参数之间用逗号隔开</p> <p>方法体 完成功能的代码块</p> <p>return 如果方法操作完毕，有数据返回，用于把数据返回给调用者</p> </li></ul></li><li> <p>定义方法时，要做到两个明确</p> 
  <ul><li> <p>明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型</p> </li><li> <p>明确参数：主要是明确参数的类型和数量</p> </li></ul></li><li> <p>调用方法时的注意：</p> 
  <ul><li> <p>void类型的方法，直接调用即可</p> </li><li> <p>非void类型的方法，推荐用变量接收调用</p> </li></ul></li></ul> 
<h3 id="6.%20%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD">6. 方法重载</h3> 
<h4 id="6.1%20%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89">6.1 方法重载（理解）</h4> 
<ul><li> <p>方法重载概念</p> <p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载</p> 
  <ul><li> <p>多个方法在同一个类中</p> </li><li> <p>多个方法具有相同的方法名</p> </li><li> <p>多个方法的参数不相同，类型不同或者数量不同</p> </li></ul></li><li> <p>注意：</p> 
  <ul><li> <p>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</p> </li><li> <p>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载</p> </li></ul></li><li> <p>正确范例：</p> <pre>public class MethodDemo {
	public static void fn(int a) {
    	//方法体
    }
    public static int fn(double a) {
    	//方法体
    }
}

public class MethodDemo {
	public static float fn(int a) {
    	//方法体
    }
    public static int fn(int a , int b) {
    	//方法体
    }
}</pre> </li><li> <p>错误范例：</p> <pre>public class MethodDemo {
	public static void fn(int a) {
    	//方法体
    }
    public static int fn(int a) { 	/*错误原因：重载与返回值无关*/
    	//方法体
    }
}

public class MethodDemo01 {
    public static void fn(int a) {
        //方法体
    }
} 
public class MethodDemo02 {
    public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/
        //方法体
    }
}</pre> </li></ul> 
<h4 id="6.2%20%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E7%BB%83%E4%B9%A0%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89">6.2 方法重载练习（掌握）</h4> 
<ul><li> <p>需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long）</p> </li><li> <p>思路：</p> 
  <ul><li> <p>①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数</p> </li><li> <p>②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数</p> </li><li> <p>③定义所有的重载方法，两个byte类型与两个short类型参数</p> </li><li> <p>④完成方法的调用，测试运行结果</p> </li></ul></li><li> <p>代码：</p> <pre>public class MethodTest {
    public static void main(String[] args) {
        //调用方法
        System.out.println(compare(10, 20));
        System.out.println(compare((byte) 10, (byte) 20));
        System.out.println(compare((short) 10, (short) 20));
        System.out.println(compare(10L, 20L));
    }

    //int
    public static boolean compare(int a, int b) {
        System.out.println("int");
        return a == b;
    }

    //byte
    public static boolean compare(byte a, byte b) {
        System.out.println("byte");
        return a == b;
    }

    //short
    public static boolean compare(short a, short b) {
        System.out.println("short");
        return a == b;
    }

    //long
    public static boolean compare(long a, long b) {
        System.out.println("long");
        return a == b;
    }

}</pre> </li></ul> 
<h3 id="7.%20%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">7. 方法的参数传递</h3> 
<h4 id="7.1%20%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89">7.1 方法参数传递基本类型（理解）</h4> 
<ul><li> <p>测试代码：</p> <pre>public class ArgsDemo01 {
    public static void main(String[] args) {
        int number = 100;
        System.out.println("调用change方法前：" + number);
        change(number);
        System.out.println("调用change方法后：" + number);
    }

    public static void change(int number) {
        number = 200;
    }
}
</pre> </li><li> <p>结论：</p> 
  <ul><li> <p>基本数据类型的参数，形式参数的改变，不影响实际参数</p> </li></ul></li><li> <p>结论依据：</p> 
  <ul><li> <p>每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失</p> </li><li> <p></p> <p><img alt="" height="305" src="https://images2.imgbox.com/47/00/4RgGwoLq_o.png" width="885"></p> <p> </p> </li></ul></li></ul> 
<h4 id="7.2%20%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89">7.2 方法参数传递引用类型（理解）</h4> 
<ul><li> <p>测试代码：</p> <pre>public class ArgsDemo02 {
    public static void main(String[] args) {
        int[] arr = {10, 20, 30};
        System.out.println("调用change方法前：" + arr[1]);
        change(arr);
        System.out.println("调用change方法后：" + arr[1]);
    }

    public static void change(int[] arr) {
        arr[1] = 200;
    }
}
</pre> </li><li> <p>结论：</p> 
  <ul><li> <p>对于引用类型的参数，形式参数的改变，影响实际参数的值</p> </li></ul></li><li> <p>结论依据：</p> 
  <ul><li> <p>引用数据类型的传参，传入的是地址值，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果</p> </li><li> <p></p> <p><img alt="" height="300" src="https://images2.imgbox.com/19/0c/dl8B4lJ8_o.png" width="875"></p> <p> </p> </li></ul></li></ul> 
<h4 id="7.3%20%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89">7.3 数组遍历（应用）</h4> 
<ul><li> <p>需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55]</p> </li><li> <p>思路：</p> 
  <ul><li> <p>①因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”);</p> <p>System.out.println(“内容”); 输出内容并换行</p> <p>System.out.print(“内容”); 输出内容不换行</p> <p>System.out.println(); 起到换行的作用</p> </li><li> <p>②定义一个数组，用静态初始化完成数组元素初始化</p> </li><li> <p>③定义一个方法，用数组遍历通用格式对数组进行遍历</p> </li><li> <p>④用新的输出语句修改遍历操作</p> </li><li> <p>⑤调用遍历方法</p> </li></ul></li><li> <p>代码：</p> <pre>public class MethodTest01 {
    public static void main(String[] args) {
        //定义一个数组，用静态初始化完成数组元素初始化
        int[] arr = {11, 22, 33, 44, 55};

        //调用方法
        printArray(arr);
    }

    //定义一个方法，用数组遍历通用格式对数组进行遍历
    /*
        两个明确：
            返回值类型：void
            参数：int[] arr
     */
    public static void printArray(int[] arr) {
        System.out.print("[");
        for(int x=0; x&lt;arr.length; x++) {
            if(x == arr.length-1) {
                System.out.print(arr[x]);
            } else {
                System.out.print(arr[x]+", ");
            }
        }
        System.out.println("]");
    }
}</pre> </li></ul> 
<h4 id="7.4%20%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89">7.4 数组最大值（应用）</h4> 
<ul><li> <p>需求：设计一个方法用于获取数组中元素的最大值</p> </li><li> <p>思路：</p> 
  <ul><li> <p>①定义一个数组，用静态初始化完成数组元素初始化</p> </li><li> <p>②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了</p> </li><li> <p>③调用获取最大值方法，用变量接收返回结果</p> </li><li> <p>④把结果输出在控制台</p> </li></ul></li><li> <p>代码：</p> <pre>public class MethodTest02 {
    public static void main(String[] args) {
        //定义一个数组，用静态初始化完成数组元素初始化
        int[] arr = {12, 45, 98, 73, 60};

        //调用获取最大值方法，用变量接收返回结果
        int number = getMax(arr);

        //把结果输出在控制台
        System.out.println("number:" + number);
    }

    //定义一个方法，用来获取数组中的最大值
    /*
        两个明确：
            返回值类型：int
            参数：int[] arr
     */
    public static int getMax(int[] arr) {
        int max = arr[0];

        for(int x=1; x&lt;arr.length; x++) {
            if(arr[x] &gt; max) {
                max = arr[x];
            }
        }
        return max;
    }
}</pre> </li></ul> 
<h3 id="1.%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">8. 类和对象</h3> 
<h4 id="1.1%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3">1.1 类和对象的理解</h4> 
<p>客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。</p> 
<ul><li> <p>类</p> 
  <ul><li> <p>类的理解</p> 
    <ul><li> <p>类是对现实生活中一类具有共同属性和行为的事物的抽象</p> </li><li> <p>类是对象的数据类型，类是具有相同属性和行为的一组对象的集合</p> </li><li> <p>简单理解：类就是对现实事物的一种描述</p> </li></ul></li><li> <p>类的组成</p> 
    <ul><li> <p>属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）</p> </li><li> <p>行为：指事物能执行的操作，例如：手机事物（打电话，发短信）</p> </li></ul></li></ul></li><li> <p>类和对象的关系</p> 
  <ul><li> <p>类：类是对现实生活中一类具有共同属性和行为的事物的抽象</p> </li><li> <p>对象：是能够看得到摸的着的真实存在的实体</p> </li><li> <p>简单理解：<strong>类是对事物的一种描述，对象则为具体存在的事物</strong></p> </li></ul></li></ul> 
<h4 id="1.2%20%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89">1.2 类的定义</h4> 
<p>类的组成是由属性和行为两部分组成</p> 
<ul><li> <p>属性：在类中通过成员变量来体现（类中方法外的变量）</p> </li><li> <p>行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）</p> </li></ul> 
<p>类的定义步骤：</p> 
<p>①定义类</p> 
<p>②编写类的成员变量</p> 
<p>③编写类的成员方法</p> 
<pre>public class 类名 {
    // 成员变量
    变量1的数据类型 变量1；
    变量2的数据类型 变量2;
    …
    // 成员方法
    方法1;
    方法2;    
}</pre> 
<p>示例代码：</p> 
<pre>/*
    手机类：
        类名：
        手机(Phone)
​
        成员变量：
        品牌(brand)
        价格(price)
​
        成员方法：
        打电话(call)
        发短信(sendMessage)
 */
public class Phone {
    //成员变量
    String brand;
    int price;
​
    //成员方法
    public void call() {
        System.out.println("打电话");
    }
​
    public void sendMessage() {
        System.out.println("发短信");
    }
}
​</pre> 
<h4 id="1.3%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8">1.3 对象的使用</h4> 
<ul><li> <p>创建对象的格式：</p> 
  <ul><li> <p>类名 对象名 = new 类名();</p> </li></ul></li><li> <p>调用成员的格式：</p> 
  <ul><li> <p>对象名.成员变量</p> </li><li> <p>对象名.成员方法();</p> </li></ul></li><li> <p>示例代码</p> </li></ul> 
<pre>/*
    创建对象
        格式：类名 对象名 = new 类名();
        范例：Phone p = new Phone();
​
    使用对象
        1：使用成员变量
            格式：对象名.变量名
            范例：p.brand
        2：使用成员方法
            格式：对象名.方法名()
            范例：p.call()
 */
public class PhoneDemo {
    public static void main(String[] args) {
        //创建对象
        Phone p = new Phone();
​
        //使用成员变量
        System.out.println(p.brand);
        System.out.println(p.price);
​
        p.brand = "小米";
        p.price = 2999;
​
        System.out.println(p.brand);
        System.out.println(p.price);
​
        //使用成员方法
        p.call();
        p.sendMessage();
    }
}</pre> 
<h4 id="1.4%20%E5%AD%A6%E7%94%9F%E5%AF%B9%E8%B1%A1-%E7%BB%83%E4%B9%A0">1.4 学生对象-练习</h4> 
<ul><li> <p>需求：首先定义一个学生类，然后定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法的使用</p> </li><li> <p>分析：</p> 
  <ul><li> <p>成员变量：姓名，年龄…</p> </li><li> <p>成员方法：学习，做作业…</p> </li></ul></li><li> <p>示例代码：</p> </li></ul> 
<pre>![1](C:\TeachRes\Java2019\JavaSe01\day07\4-笔记\笔记图片资源包\1.png)class Student {
    //成员变量
    String name;
    int age;
​
    //成员方法
    public void study() {
        System.out.println("好好学习，天天向上");
    }
​
    public void doHomework() {
        System.out.println("键盘敲烂，月薪过万");
    }
}
/*
    学生测试类
 */
public class StudentDemo {
    public static void main(String[] args) {
        //创建对象
        Student s = new Student();
​
        //使用对象
        System.out.println(s.name + "," + s.age);
​
        s.name = "林青霞";
        s.age = 30;
​
        System.out.println(s.name + "," + s.age);
​
        s.study();
        s.doHomework();
    }
}</pre> 
<h3 id="2.%20%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE">9. 对象内存图</h3> 
<h4 id="2.1%20%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE">2.1 单个对象内存图</h4> 
<ul><li> <p>成员变量使用过程</p> </li><li> <p><img alt="" height="352" src="https://images2.imgbox.com/7b/bb/8S4dcwym_o.png" width="888"></p> <p> </p> </li></ul> 
<p></p> 
<ul><li> <p>成员方法调用过程</p> </li><li> <p><img alt="" height="416" src="https://images2.imgbox.com/92/b6/qmLZy8Fb_o.png" width="887"></p> <p> </p> </li></ul> 
<p></p> 
<h4 id="2.2%20%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE">2.2 多个对象内存图</h4> 
<ul><li> <p>成员变量使用过程</p> </li><li> <p><img alt="" height="350" src="https://images2.imgbox.com/71/d6/kiSAkTLN_o.png" width="882"></p> <p> </p> </li></ul> 
<p></p> 
<ul><li> <p>成员方法调用过程</p> </li><li> <p><img alt="" height="355" src="https://images2.imgbox.com/ee/61/OuSN0JXY_o.png" width="889"></p> <p> </p> </li></ul> 
<p></p> 
<ul><li> <p>总结：</p> <p>多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份</p> </li></ul> 
<h4 id="2.3%20%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%8C%87%E5%90%91%E7%9B%B8%E5%90%8C%E5%86%85%E5%AD%98%E5%9B%BE">2.3 多个对象指向相同内存图</h4> 
<p><img alt="" height="336" src="https://images2.imgbox.com/e1/96/LjwbK55M_o.png" width="893"></p> 
<p> </p> 
<p></p> 
<ul><li> <p>总结</p> <p>当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）</p> <p>只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。</p> </li></ul> 
<h3 id="3.%20%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">10. 成员变量和局部变量</h3> 
<h4 id="3.1%20%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">3.1 成员变量和局部变量的区别</h4> 
<ul><li> <p>类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）</p> </li><li> <p>内存中位置不同：成员变量（堆内存）局部变量（栈内存）</p> </li><li> <p>生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）</p> </li><li> <p>初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）</p> </li></ul> 
<h3 id="4.%20%E5%B0%81%E8%A3%85">11. 封装</h3> 
<h4 id="4.1%20private%E5%85%B3%E9%94%AE%E5%AD%97">4.1 private关键字</h4> 
<p>private是一个修饰符，可以用来修饰成员（成员变量，成员方法）</p> 
<ul><li> <p>被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作</p> 
  <ul><li> <p>提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰</p> </li><li> <p>提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰</p> </li></ul></li><li> <p>示例代码：</p> <pre>/*
    学生类
 */
class Student {
    //成员变量
    String name;
    private int age;
​
    //提供get/set方法
    public void setAge(int a) {
        if(a&lt;0 || a&gt;120) {
            System.out.println("你给的年龄有误");
        } else {
            age = a;
        }
    }
​
    public int getAge() {
        return age;
    }
​
    //成员方法
    public void show() {
        System.out.println(name + "," + age);
    }
}
/*
    学生测试类
 */
public class StudentDemo {
    public static void main(String[] args) {
        //创建对象
        Student s = new Student();
        //给成员变量赋值
        s.name = "林青霞";
        s.setAge(30);
        //调用show方法
        s.show();
    }
}</pre> </li></ul> 
<h4 id="4.2%20private%E7%9A%84%E4%BD%BF%E7%94%A8">4.2 private的使用</h4> 
<ul><li> <p>需求：定义标准的学生类，要求name和age使用private修饰，并提供set和get方法以及便于显示数据的show方法，测试类中创建对象并使用，最终控制台输出  林青霞，30</p> </li><li> <p>示例代码：</p> <pre>/*
    学生类
 */
class Student {
    //成员变量
    private String name;
    private int age;
​
    //get/set方法
    public void setName(String n) {
        name = n;
    }
​
    public String getName() {
        return name;
    }
​
    public void setAge(int a) {
        age = a;
    }
​
    public int getAge() {
        return age;
    }
​
    public void show() {
        System.out.println(name + "," + age);
    }
}
/*
    学生测试类
 */
public class StudentDemo {
    public static void main(String[] args) {
        //创建对象
        Student s = new Student();
​
        //使用set方法给成员变量赋值
        s.setName("林青霞");
        s.setAge(30);
​
        s.show();
​
        //使用get方法获取成员变量的值
        System.out.println(s.getName() + "---" + s.getAge());
        System.out.println(s.getName() + "," + s.getAge());
​
    }
}</pre> </li></ul> 
<h4 id="4.3%20this%E5%85%B3%E9%94%AE%E5%AD%97">4.3 this关键字</h4> 
<ul><li> <p>this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）</p> 
  <ul><li> <p>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量</p> </li><li> <p>方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</p> </li></ul></li></ul> 
<pre>public class Student {
    private String name;
    private int age;
​
    public void setName(String name) {
        this.name = name;
    }
​
    public String getName() {
        return name;
    }
​
    public void setAge(int age) {
        this.age = age;
    }
​
    public int getAge() {
        return age;
    }
​
    public void show() {
        System.out.println(name + "," + age);
    }
}</pre> 
<h4 id="4.4%20this%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86">4.4 this内存原理</h4> 
<ul><li> <p>this代表当前调用方法的引用，哪个对象调用的方法，this就代表哪一个对象</p> </li><li> <p>示例代码：</p> <pre>public class StudentDemo {
    public static void main(String[] args) {
        Student s1 = new Student();
        s1.setName("林青霞");
        Student s2 = new Student();
        s2.setName("张曼玉");
    }
}</pre> </li></ul> 
<p><img alt="" height="345" src="https://images2.imgbox.com/b8/22/xvQfEtlK_o.png" width="877"></p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/81/23/U7QyUpiM_o.png" width="387"> </p> 
<p> </p> 
<h4 id="4.5%20%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3">4.5 封装思想</h4> 
<ol><li> <p>封装概述 是面向对象三大特征之一（封装，继承，多态） 是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的</p> </li><li> <p>封装原则 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getXxx()/setXxx()方法</p> </li><li> <p>封装好处 通过方法来控制成员变量的操作，提高了代码的安全性 把代码用方法进行封装，提高了代码的复用性</p> </li></ol> 
<h3 id="5.%20%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">12. 构造方法</h3> 
<h4 id="5.1%20%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0">5.1 构造方法概述</h4> 
<p>构造方法是一种特殊的方法</p> 
<ul><li> <p>作用：创建对象 Student stu = <strong>new Student();</strong></p> </li><li> <p>格式：</p> <p>public class 类名{<!-- --></p> <p>修饰符 类名( 参数 ) {<!-- --></p> <p>}</p> <p>}</p> </li><li> <p>功能：主要是完成对象数据的初始化</p> </li><li> <p>示例代码：</p> </li></ul> 
<pre>class Student {
    private String name;
    private int age;

    //构造方法
    public Student() {
        System.out.println("无参构造方法");
    }

    public void show() {
        System.out.println(name + "," + age);
    }
}
/*
    测试类
 */
public class StudentDemo {
    public static void main(String[] args) {
        //创建对象
        Student s = new Student();
        s.show();
    }
}</pre> 
<h4 id="5.2%20%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.2 构造方法的注意事项</h4> 
<ul><li> <p>构造方法的创建</p> </li></ul> 
<p>如果没有定义构造方法，系统将给出一个默认的无参数构造方法 如果定义了构造方法，系统将不再提供默认的构造方法</p> 
<ul><li> <p>构造方法的重载</p> </li></ul> 
<p>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法</p> 
<ul><li> <p>推荐的使用方式</p> </li></ul> 
<p>无论是否使用，都手工书写无参数构造方法</p> 
<ul><li> <p>重要功能！</p> </li></ul> 
<p>可以使用带参构造，为成员变量进行初始化</p> 
<ul><li> <p>示例代码</p> </li></ul> 
<pre>/*
    学生类
 */
class Student {
    private String name;
    private int age;

    public Student() {}

    public Student(String name) {
        this.name = name;
    }

    public Student(int age) {
        this.age = age;
    }

    public Student(String name,int age) {
        this.name = name;
        this.age = age;
    }

    public void show() {
        System.out.println(name + "," + age);
    }
}
/*
    测试类
 */
public class StudentDemo {
    public static void main(String[] args) {
        //创建对象
        Student s1 = new Student();
        s1.show();

        //public Student(String name)
        Student s2 = new Student("林青霞");
        s2.show();

        //public Student(int age)
        Student s3 = new Student(30);
        s3.show();

        //public Student(String name,int age)
        Student s4 = new Student("林青霞",30);
        s4.show();
    }
}</pre> 
<h4 id="5.3%20%E6%A0%87%E5%87%86%E7%B1%BB%E5%88%B6%E4%BD%9C">5.3 标准类制作</h4> 
<ul><li> <p>需求：定义标准学生类，要求分别使用空参和有参构造方法创建对象，空参创建的对象通过setXxx赋值，有参创建的对象直接赋值，并通过show方法展示数据。</p> </li><li> <p>示例代码：</p> </li></ul> 
<pre>class Student {
    //成员变量
    private String name;
    private int age;

    //构造方法
    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    //成员方法
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void show() {
        System.out.println(name + "," + age);
    }
}
/*
    创建对象并为其成员变量赋值的两种方式
        1:无参构造方法创建对象后使用setXxx()赋值
        2:使用带参构造方法直接创建带有属性值的对象
*/
public class StudentDemo {
    public static void main(String[] args) {
        //无参构造方法创建对象后使用setXxx()赋值
        Student s1 = new Student();
        s1.setName("林青霞");
        s1.setAge(30);
        s1.show();

        //使用带参构造方法直接创建带有属性值的对象
        Student s2 = new Student("林青霞",30);
        s2.show();
    }
}</pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df738878f3d82158dde534b05edba84a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity 中的 DrawCall</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9b003daf5da3305a90d3a03e9d44575f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Markdown是什么意思</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>