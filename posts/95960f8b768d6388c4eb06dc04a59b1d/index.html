<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2021年vmware安装archlinux - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2021年vmware安装archlinux" />
<meta property="og:description" content="前言 在看文章或者一些视频中偶尔能看到archlinux的身影。本人就比较好奇这个发行版本，好奇就安装试试吧。本文记录一下我自己的安装过程。
补充：
过程中我发现一个UP做的视频非常细致，有需要的去看这个视频就能搞定啦。《保姆级ArchLinux安装教程》
下载 下载导航页面如下：
https://archlinux.org/download/
我最终下载的是http://mirrors.163.com/archlinux/iso/2021.03.01/
下载完成后，建议比较一下文件的md5值。mac下载是：
~/Downloads $ md5 archlinux-2021.03.01-x86_64.iso [10:35:00] MD5 (archlinux-2021.03.01-x86_64.iso) = 954ccc00409d564938433611e3a81ae9 创建虚拟机 虚拟机配置，我设置内存1G 硬盘20G仅供参考。
启动虚拟机 等待加载，很快就进行了如下界面。
根据提示，我进下面地址看一下如何安装。
https://wiki.archlinux.org/index.php/Installation_guide
确保是否为 UEFI 模式 ls /sys/firmware/efi/efivars 如果输出一堆东西，说明就是UEFI模式的了。
测试网络 ping www.baidu.com 若能看到数据返回，即说明已经联网，ctrl&#43;c 终止退出当前命令。
我的是直接可以连接，如果遇到网络不通的话自己百度解决。
启用SSH（可选） 此项为补充内容，第一次安装时候所有命令都是直接在vmware中敲的。vmware中命令行无法复制，粘贴纯手打效率不高。所以我就想能不能ssh远程安装方便粘贴命令？答案是可以的而且很简单。
查ip 执行 ip addr 我这里查到的ip 是 172.16.184.11设置root密码 passwd root客户端连接ssh 命令如下：ssh root@172.16.184.11
简单的3步就可以粘贴命令了，复制粘贴要程序员的本能。 禁用 reflector 2020 年新版 archliveiso 加入了 reflector 服务，它会自己更新
mirrorlist。在特定情况下，它会误删某些有用的源信息。这里联网后的第一件事就是将其禁用。也许它是一个好用的工具，但是很明显，它并不适合在安装的时候启用。
systemctl stop reflector.service 更新系统时钟 timedatectl set-ntp true #将系统时间与网络时间进行同步 timedatectl status #检查服务状态 更换国内镜像源加快下载速度 这一步很关键，我第一次安装，根据官方文档一步步安装，后来在安装步骤等待了1个多小时，还没成功，被迫放弃重新来一遍。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/95960f8b768d6388c4eb06dc04a59b1d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-01T08:10:21+08:00" />
<meta property="article:modified_time" content="2022-05-01T08:10:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2021年vmware安装archlinux</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<p>在看文章或者一些视频中偶尔能看到archlinux的身影。本人就比较好奇这个发行版本，好奇就安装试试吧。本文记录一下我自己的安装过程。</p> 
<blockquote> 
 <p>补充：<br> 过程中我发现一个UP做的视频非常细致，有需要的去看这个视频就能搞定啦。<a href="https://www.bilibili.com/video/BV1qf4y1D7Da?share_source=copy_web" rel="nofollow">《保姆级ArchLinux安装教程》</a></p> 
</blockquote> 
<h2><a id="_7"></a>下载</h2> 
<p>下载导航页面如下：<br> <a href="https://archlinux.org/download/" rel="nofollow">https://archlinux.org/download/</a></p> 
<p>我最终下载的是<a href="http://mirrors.163.com/archlinux/iso/2021.03.01/" rel="nofollow">http://mirrors.163.com/archlinux/iso/2021.03.01/</a></p> 
<p>下载完成后，建议比较一下文件的md5值。mac下载是：</p> 
<pre><code class="prism language-bash">~/Downloads $ md5 archlinux-2021.03.01-x86_64.iso                                        <span class="token punctuation">[</span><span class="token number">10</span>:35:00<span class="token punctuation">]</span>
MD5 <span class="token punctuation">(</span>archlinux-2021.03.01-x86_64.iso<span class="token punctuation">)</span> <span class="token operator">=</span> 954ccc00409d564938433611e3a81ae9
</code></pre> 
<h2><a id="_19"></a>创建虚拟机</h2> 
<p><img src="https://images2.imgbox.com/ae/89/k6Fuv8IS_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/46/c3/AGfmMJGo_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f4/ea/vZ6VjXBJ_o.png" alt="在这里插入图片描述"><br> 虚拟机配置，我设置内存1G 硬盘20G仅供参考。</p> 
<h2><a id="_27"></a>启动虚拟机</h2> 
<p><img src="https://images2.imgbox.com/d0/98/oFOW725O_o.png" alt="在这里插入图片描述"><br> 等待加载，很快就进行了如下界面。<br> <img src="https://images2.imgbox.com/5f/31/sLE3FfiG_o.png" alt="在这里插入图片描述"><br> 根据提示，我进下面地址看一下如何安装。<br> <a href="https://wiki.archlinux.org/index.php/Installation_guide" rel="nofollow">https://wiki.archlinux.org/index.php/Installation_guide</a></p> 
<h3><a id="_UEFI__34"></a>确保是否为 UEFI 模式</h3> 
<pre><code class="prism language-bash"><span class="token function">ls</span> /sys/firmware/efi/efivars
</code></pre> 
<p>如果输出一堆东西，说明就是UEFI模式的了。</p> 
<h3><a id="_40"></a>测试网络</h3> 
<pre><code class="prism language-bash"><span class="token function">ping</span> www.baidu.com
</code></pre> 
<p>若能看到数据返回，即说明已经联网，ctrl+c 终止退出当前命令。<br> 我的是直接可以连接，如果遇到网络不通的话自己百度解决。</p> 
<h3><a id="SSH_48"></a>启用SSH（可选）</h3> 
<p>此项为补充内容，第一次安装时候所有命令都是直接在vmware中敲的。vmware中命令行无法复制，粘贴纯手打效率不高。所以我就想能不能ssh远程安装方便粘贴命令？答案是可以的而且很简单。</p> 
<ol><li>查ip 执行 <code>ip addr</code> 我这里查到的ip 是 <code>172.16.184.11</code></li><li>设置root密码 <code>passwd root</code></li><li>客户端连接ssh 命令如下：<code>ssh root@172.16.184.11</code><br> 简单的3步就可以粘贴命令了，复制粘贴要程序员的本能。</li></ol> 
<h3><a id="_reflector_54"></a>禁用 reflector</h3> 
<blockquote> 
 <p>2020 年新版 archliveiso 加入了 reflector 服务，它会自己更新<br> mirrorlist。在特定情况下，它会误删某些有用的源信息。这里联网后的第一件事就是将其禁用。也许它是一个好用的工具，但是很明显，它并不适合在安装的时候启用。</p> 
</blockquote> 
<pre><code class="prism language-bash">systemctl stop reflector.service
</code></pre> 
<h3><a id="_62"></a>更新系统时钟</h3> 
<pre><code class="prism language-bash">timedatectl set-ntp <span class="token boolean">true</span>    <span class="token comment">#将系统时间与网络时间进行同步</span>
timedatectl status          <span class="token comment">#检查服务状态</span>
</code></pre> 
<h3><a id="_68"></a>更换国内镜像源加快下载速度</h3> 
<p>这一步很关键，我第一次安装，根据<a href="https://wiki.archlinux.org/index.php/Installation_guide" rel="nofollow">官方文档</a>一步步安装，后来在安装步骤等待了1个多小时，还没成功，被迫放弃重新来一遍。<br> 后来在<a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/basic_install" rel="nofollow">https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/basic_install</a>看到设置源的内容。</p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> /etc/pacman.d/mirrorlist
</code></pre> 
<p><img src="https://images2.imgbox.com/14/51/maZK07cZ_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">Server <span class="token operator">=</span> https://mirrors.ustc.edu.cn/archlinux/<span class="token variable">$repo</span>/os/<span class="token variable">$arch</span>
Server <span class="token operator">=</span> https://mirrors.hit.edu.cn/archlinux/<span class="token variable">$repo</span>/os/<span class="token variable">$arch</span>
</code></pre> 
<p>在上面放上国内的源。</p> 
<h3><a id="_84"></a>分区</h3> 
<p>ArchLinux官方文档参考：UEFI with GPT</p> 
<table><thead><tr><th>挂在点</th><th>分区</th><th>分区类型</th><th>推荐尺寸</th></tr></thead><tbody><tr><td>/mnt/boot or /mnt/efi</td><td>/dev/efi_system_partition</td><td>EFI system partition</td><td>至少260 MiB</td></tr><tr><td>[SWAP]</td><td>/dev/swap_partition</td><td>Linux swap</td><td>超过 512 MiB</td></tr><tr><td>/mnt</td><td>/dev/root_partition</td><td>Linux x86-64 root (/)</td><td>磁盘的剩余空间</td></tr></tbody></table> 
<p>我实际的分区：</p> 
<table><thead><tr><th>挂在点</th><th>分区</th><th>分区类型</th><th>尺寸</th></tr></thead><tbody><tr><td>/mnt/boot or /mnt/efi</td><td>/dev/efi_system_partition</td><td>EFI system partition</td><td>300 MiB</td></tr><tr><td>[SWAP]</td><td>/dev/swap_partition</td><td>Linux swap</td><td>超过 2048 MiB</td></tr><tr><td>/</td><td>/dev/root_partition</td><td>Linux x86-64 root (/)</td><td>8G</td></tr><tr><td>/home</td><td>/dev/root_partition</td><td>Linux x86-64 root (/)</td><td>磁盘的剩余空间</td></tr><tr><td>先查一下磁盘情况。</td><td></td><td></td><td></td></tr></tbody></table> 
<pre><code class="prism language-bash"><span class="token function">fdisk</span> -l
</code></pre> 
<p><img src="https://images2.imgbox.com/d0/dd/TL5yZIm6_o.png" alt="在这里插入图片描述"><br> <strong>开始分区了</strong> 如果你磁盘里有数据请注意备份！ 因为我这个新建的虚拟机所以不用考虑备份的事情。</p> 
<pre><code class="prism language-bash"><span class="token function">fdisk</span> /dev/sda
</code></pre> 
<h4><a id="_109"></a>创建分区表</h4> 
<p>我们要创建一个 GUID Partition Table (GPT) 分区表，所以这里按<code>g</code><br> <img src="https://images2.imgbox.com/7f/03/vGWwHNJl_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_113"></a>创建分区</h4> 
<p>使用<code>n</code>命令创建一个新分区。您输入分区类型，分区号，起始扇区和终止扇区。<br> 出现提示时，请指定分区类型，然后键入<code>p</code>以创建主分区或<code>e</code>创建扩展分区。最多可以有四个主分区。<br> 全部操作如下：<br> <img src="https://images2.imgbox.com/8b/c7/BMOapVq1_o.png" alt="在这里插入图片描述"><br> 上面是我设置的分区大小，仅供参考，可以根据你的需要自行调整。</p> 
<blockquote> 
 <p>使用说明：<br> <strong>列出分区类型</strong> 按下<code>l</code>以列出可用的分区类型。 查询完需要返回就按<code>q</code><br> <strong>更改分区类型</strong> 每个分区都与Type关联。按<code>t</code>更改分区的类型。默认值，Linux filesystem对于大多数使用来说应该没问题。<br> <strong>使分区可启动。</strong> 您可以通过键入使分区可启动<code>a</code>。</p> 
 <p><strong>将更改写入磁盘</strong> 将表写入磁盘，然后通过<code>w</code>命令退出。</p> 
</blockquote> 
<p><strong>将第一个300MB的分区的分区类型设置为<code>EFI System</code></strong><br> <img src="https://images2.imgbox.com/b2/a9/QRuxgQRn_o.png" alt="在这里插入图片描述"></p> 
<p><strong>将第2个2GB的分区的分区类型设置为<code>Linux Swap</code></strong><br> <img src="https://images2.imgbox.com/61/60/d9Tyv43C_o.png" alt="在这里插入图片描述"></p> 
<p>将更改写入磁盘 将表写入磁盘，然后通过<code>w</code>命令退出。<br> <img src="https://images2.imgbox.com/2a/cd/WqTJ3IeR_o.png" alt="在这里插入图片描述"><br> 这时已经分区成功了，现在来查一下分区结构：<br> <img src="https://images2.imgbox.com/d7/b7/Q5zfkqTN_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>疑问： 我EFI分区对应的是<code>/dev/sda1</code> 官方文档中写的路径是<code>/dev/efi_system_partition</code><br> 这样的设备路径是怎么创建的？知道的朋友麻烦评论告诉我。我找了一圈，还是不知道如何做。暂时先不官这个了，继续做吧。</p> 
</blockquote> 
<h4><a id="_143"></a>格式化分区</h4> 
<p>创建分区后，必须使用适当的文件系统格式化每个新创建的分区。例如，要在创建一个Ext4文件系统。<br> 用于<code>/</code> 和 <code>/home</code>的分区格式化成ext4类型。</p> 
<pre><code class="prism language-bash">mkfs.ext4 /dev/sda3
mkfs.ext4 /dev/sda4
</code></pre> 
<p>EFI分区格式化成vfat</p> 
<pre><code class="prism language-bash">mkfs.vfat /dev/sda1
</code></pre> 
<p>如果您创建了交换分区，请使用mkswap（8）对其进行初始化：</p> 
<pre><code class="prism language-bash"><span class="token function">mkswap</span> -f /dev/sda2
</code></pre> 
<h4><a id="_162"></a>挂载</h4> 
<p><img src="https://images2.imgbox.com/73/86/XguTq1GM_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token comment"># 挂载swap</span>
<span class="token function">swapon</span> /dev/sda2
<span class="token function">mount</span> /dev/sda3 /mnt
<span class="token function">mkdir</span> /mnt/home
<span class="token function">mount</span> /dev/sda4 /mnt/home
<span class="token function">mkdir</span> /mnt/boot
<span class="token function">mkdir</span> /mnt/boot/EFI
<span class="token function">mount</span> /dev/sda1 /mnt/boot/EFI
</code></pre> 
<blockquote> 
 <p>分区总结：fdisk分区虽然没有图形化的直观，用过一次感觉很爽，甚至比图形化的更爽！</p> 
</blockquote> 
<h3><a id="_181"></a>安装</h3> 
<p>基础包</p> 
<pre><code class="prism language-bash">pacstrap /mnt base base-devel linux linux-firmware  <span class="token comment">#base-devel在AUR包的安装是必须的</span>
</code></pre> 
<p>如果你这一步特别久，请检查一下是不是国内镜像源设置的有问题。我一开始没设置特别慢，等待了1个多小时，实在等不下去，又重新安装的。速度如下：<br> <img src="https://images2.imgbox.com/27/85/KuYkZfFq_o.png" alt="在这里插入图片描述"></p> 
<p>功能性软件</p> 
<pre><code class="prism language-bash">pacstrap /mnt dhcpcd  iwd <span class="token function">vim</span> <span class="token function">sudo</span> bash-completion   <span class="token comment">#一个有线所需 一个无线所需 一个编辑器  一个提权工具 一个补全工具 iwd也需要dhcpcd</span>
</code></pre> 
<p>wifi相关<br> 虚拟机种一般不用，物理机可能需要安装。</p> 
<pre><code class="prism language-bash">pacstrap /mnt dhcpcd  wireless_tools wpa_supplicant
</code></pre> 
<h3><a id="_202"></a>配置系统</h3> 
<h4><a id="Fstab_203"></a>Fstab</h4> 
<p>生成一个fstab文件（分别使用-U或-L定义UUID或标签）：</p> 
<pre><code class="prism language-bash">genfstab -U /mnt <span class="token operator">&gt;&gt;</span> /mnt/etc/fstab
</code></pre> 
<p>检查生成的<code>/mnt/etc/fstab</code>文件，并在出现错误的情况下对其进行编辑。</p> 
<h4><a id="Chroot_212"></a>Chroot</h4> 
<p>将root更改为新系统：</p> 
<pre><code class="prism language-bash">arch-chroot /mnt
</code></pre> 
<h4><a id="_219"></a>设置时区</h4> 
<p><img src="https://images2.imgbox.com/52/c3/VfsLpWCS_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token function">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</code></pre> 
<h4><a id="_225"></a>将系统时间同步到硬件时间</h4> 
<pre><code class="prism language-bash">hwclock --systohc
</code></pre> 
<h4><a id="_Locale_230"></a>设置 Locale</h4> 
<pre><code class="prism language-bash"><span class="token function">vim</span> /etc/locale.gen
</code></pre> 
<p>，去掉 en_US.UTF-8 行以及 zh_CN.UTF-8 的注释符号（#）。<br> <img src="https://images2.imgbox.com/7f/1c/1AZ2hsCT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d1/6c/Et5qjooQ_o.png" alt="在这里插入图片描述"><br> 配置完成以后运行：</p> 
<pre><code class="prism language-bash">locale-gen
</code></pre> 
<p>生成 locale。<br> 向 /etc/locale.conf 输入内容</p> 
<p>根据自己需要选择环境，二选一。我更喜欢中文的。<br> 英文环境：</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'LANG=en_US.UTF-8'</span>  <span class="token operator">&gt;</span> /etc/locale.conf
</code></pre> 
<p>中文环境：</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'LANG=zh_CN.UTF-8'</span>  <span class="token operator">&gt;</span> /etc/locale.conf
</code></pre> 
<h3><a id="_255"></a>安装微码</h3> 
<pre><code class="prism language-bash">pacman -S intel-ucode   <span class="token comment">#Intel</span>
pacman -S amd-ucode     <span class="token comment">#AMD</span>
</code></pre> 
<h3><a id="_262"></a>安装引导程序</h3> 
<pre><code class="prism language-bash">pacman -S grub efibootmgr   <span class="token comment">#grub是启动引导器，efibootmgr被 grub 脚本用来将启动项写入 NVRAM。</span>
grub-install --target<span class="token operator">=</span>x86_64-efi --efi-directory<span class="token operator">=</span>/boot/EFI --bootloader-id<span class="token operator">=</span>GRUB <span class="token comment">#取名为GRUB 并将grubx64.efi安装到之前的指定位置</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/15/8e/KRSueCQU_o.png" alt="在这里插入图片描述"><br> 最后生成 GRUB 所需的配置文件</p> 
<pre><code class="prism language-bash"><span class="token function">grub-mkconfig</span> -o /boot/grub/grub.cfg
</code></pre> 
<p><img src="https://images2.imgbox.com/af/19/QDqh1UhT_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_276"></a>完成安装</h3> 
<p>设置root的密码!!! 不能忘记这一步，否则重启无法登录啦。</p> 
<pre><code class="prism language-bash"><span class="token function">passwd</span> root
</code></pre> 
<pre><code class="prism language-bash"><span class="token builtin class-name">exit</span>                <span class="token comment"># 退回安装环境#</span>
<span class="token function">umount</span> -R  /mnt     <span class="token comment"># 卸载新分区</span>
<span class="token function">reboot</span>              <span class="token comment"># 重启</span>
</code></pre> 
<p>重启以后就可以正常启动了，安装完成。</p> 
<h3><a id="_291"></a>网络</h3> 
<p>安装完成后，发现网络不通。</p> 
<pre><code class="prism language-bash">systemctl <span class="token builtin class-name">enable</span> dhcpcd  <span class="token comment">#设置开机启动</span>
systemctl start dhcpcd  <span class="token comment">#立即启动dhcp</span>
</code></pre> 
<p>等待一会儿，<code>ping www.baidu.com</code> 发现网络已经通了。</p> 
<pre><code class="prism language-bash">pacman -S neofetch
neofetch
</code></pre> 
<p><img src="https://images2.imgbox.com/8e/6b/uZsoIStX_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_305"></a>图形化安装</h2> 
<h3><a id="_306"></a>系统更新</h3> 
<pre><code class="prism language-bash">pacman -Syyu
</code></pre> 
<h3><a id="_311"></a>创建用户</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 创建用户</span>
<span class="token function">useradd</span> -m -g <span class="token function">users</span> -G wheel -s /bin/bash itkey
<span class="token comment"># 修改密码</span>
<span class="token function">passwd</span> itkey
</code></pre> 
<p>让刚创建的用户拥有sudo 权限。</p> 
<pre><code class="prism language-bash"><span class="token assign-left variable">EDITOR</span><span class="token operator">=</span>vim visudo
</code></pre> 
<p><img src="https://images2.imgbox.com/40/c8/htKALfox_o.png" alt="在这里插入图片描述"><br> 把约82行的 %wheel ALL=(ALL) ALL 前面的#去掉</p> 
<h3><a id="ssh_328"></a>安装ssh</h3> 
<p>直接在vmware中写命令复制粘贴不太方便，个人喜欢ssh远程控制执行命令。</p> 
<h4><a id="openssh_330"></a>安装openssh</h4> 
<pre><code class="prism language-bash">pacman -S 	openssh
</code></pre> 
<h4><a id="rootroot_335"></a>默认不支持root登录，如果需要root登录。</h4> 
<pre><code class="prism language-bash"><span class="token function">vim</span> /etc/ssh/sshd_config
</code></pre> 
<p>增加如下配置（如果已经有则在此基础上修改）：</p> 
<pre><code class="prism language-bash">PermitRootLogin <span class="token function">yes</span>
</code></pre> 
<h4><a id="ssh_345"></a>设置ssh开机启动</h4> 
<pre><code class="prism language-bash">systemctl <span class="token builtin class-name">enable</span> sshd.service
<span class="token comment">#立即运行</span>
systemctl start sshd.service
</code></pre> 
<h4><a id="ip_352"></a>查ip地址</h4> 
<pre><code class="prism language-bash"><span class="token function">ip</span> addr
</code></pre> 
<p><img src="https://images2.imgbox.com/35/f7/MGvOzOXv_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_357"></a>客户端连接</h4> 
<pre><code class="prism language-bash"><span class="token function">ssh</span> root@172.16.184.10
</code></pre> 
<h3><a id="_363"></a>安装图形界面相关的软件</h3> 
<pre><code class="prism language-bash">pacman -S plasma-meta konsole dolphin bash-completion
</code></pre> 
<h4><a id="sddm_369"></a>设置sddm开机自启动</h4> 
<pre><code class="prism language-bash"> systemctl <span class="token builtin class-name">enable</span> sddm
</code></pre> 
<h4><a id="_32__ArchLinuxCN__373"></a>开启 32 位支持库与 ArchLinuxCN 支持库</h4> 
<pre><code class="prism language-bash"><span class="token function">vim</span> /etc/pacman.conf
</code></pre> 
<p>去掉[multilib]一节中两行的注释，来开启 32 位库支持。<br> 在文档结尾处加入下面的文字，来开启 ArchLinuxCN 源。</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>archlinuxcn<span class="token punctuation">]</span>
Server <span class="token operator">=</span> https://mirrors.ustc.edu.cn/archlinuxcn/<span class="token variable">$arch</span>
</code></pre> 
<p>修改后的文件末尾如下：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>multilib<span class="token punctuation">]</span>
Include <span class="token operator">=</span> /etc/pacman.d/mirrorlist
<span class="token punctuation">[</span>archlinuxcn<span class="token punctuation">]</span>
SigLevel <span class="token operator">=</span> Optional TrustAll
Server <span class="token operator">=</span> https://mirrors.ustc.edu.cn/archlinuxcn/<span class="token variable">$arch</span>
</code></pre> 
<p>最后<code>:wq</code> 保存退出，刷新 pacman 数据库。</p> 
<pre><code class="prism language-bash">pacman -Syyu
</code></pre> 
<p>重启电脑，即可看到欢迎界面，输入新用户的密码即可登录桌面。<br> <img src="https://images2.imgbox.com/14/a8/uwYrqoxE_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_401"></a>安装基础功能包</h3> 
<p>进入桌面后，搜索 konsole。它是 KDE 桌面环境默认的命令行终端。<br> 接下来我们进行网络配置与连接，并安装一些基础功能包。</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> pacman -S ntfs-3g                                                      <span class="token comment">#识别NTFS格式的硬盘</span>
<span class="token function">sudo</span> pacman -S adobe-source-han-serif-cn-fonts wqy-zenhei                   <span class="token comment">#安装几个开源中文字体 一般装上文泉驿就能解决大多wine应用中文方块的问题</span>
<span class="token function">sudo</span> pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra  <span class="token comment">#安装谷歌开源字体及表情</span>
<span class="token function">sudo</span> pacman -S firefox chromium                                             <span class="token comment">#安装常用的火狐、谷歌浏览器</span>
</code></pre> 
<p>接下来要安装 archlinuxcn 源的相关步骤，<br> GnuPG-2.1 与 pacman 密钥环</p> 
<p>由于升级到了 gnupg-2.1，pacman 上游更新了密钥环的格式，这使得本地的主密钥无法签署其它密钥。这不会出问题，除非你想自定义 pacman 密钥环。不过，我们推荐所有用户都生成一个新的密钥环以解决潜在问题。</p> 
<p>此外，我们建议您安装 haveged，这是一个用来生成系统熵值的守护进程，它能加快加密软件（如 gnupg，包括生成新的密钥环）关键操作的速度。</p> 
<p>要完成这些操作，请以 root 权限运行：</p> 
<pre><code class="prism language-bash">pacman -Syu haveged
systemctl start haveged
systemctl <span class="token builtin class-name">enable</span> haveged

<span class="token function">rm</span> -fr /etc/pacman.d/gnupg
pacman-key --init
pacman-key --populate archlinux
pacman-key --populate archlinuxcn
</code></pre> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> pacman -S archlinuxcn-keyring                                          <span class="token comment">#cn源中的签名(archlinuxcn-keyring在archLinuxCn)</span>
<span class="token function">sudo</span> pacman -S yay                                                          <span class="token comment">#yay命令可以让用户安装AUR中的软件(yay在archLinuxCn)</span>
</code></pre> 
<h3><a id="_436"></a>安装中文输入法</h3> 
<p>中文及日文输入法均体验良好。</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> pacman -S fcitx5-im <span class="token comment">#基础包组</span>
<span class="token function">sudo</span> pacman -S fcitx5-chinese-addons <span class="token comment">#官方中文输入引擎</span>
<span class="token function">sudo</span> pacman -S fcitx5-anthy <span class="token comment">#日文输入引擎</span>
<span class="token function">sudo</span> pacman -S fcitx5-pinyin-moegirl <span class="token comment">#萌娘百科词库 二刺猿必备(ArchLinuxCn)</span>
<span class="token function">sudo</span> pacman -S fcitx5-material-color <span class="token comment">#主题</span>
</code></pre> 
<p>设置环境变量 编辑文件 vim ~/.pam_environment 加入以下内容。konsole 以及 dophin 都需要这些环境变量，倒是 chrome 和 firefox 都不需要就可以输入中文</p> 
<pre><code class="prism language-bash">INPUT_METHOD <span class="token assign-left variable">DEFAULT</span><span class="token operator">=</span>fcitx5
GTK_IM_MODULE <span class="token assign-left variable">DEFAULT</span><span class="token operator">=</span>fcitx5
QT_IM_MODULE <span class="token assign-left variable">DEFAULT</span><span class="token operator">=</span>fcitx5
<span class="token environment constant">XMODIFIERS</span> <span class="token assign-left variable">DEFAULT</span><span class="token operator">=</span><span class="token punctuation">\</span>@im<span class="token operator">=</span>fcitx5
SDL_IM_MODULE <span class="token assign-left variable">DEFAULT</span><span class="token operator">=</span>fcitx
</code></pre> 
<p>打开 系统设置 &gt; 区域设置 &gt; 输入法</p> 
<p>点击添加输入法，找到简体中文下的 Pinyin ，点击添加</p> 
<p>找到 配置附加组件 拉到下面找到 Pinyin 点选云拼音和在程序中显示预编辑文本 最后应用<br> 找到 classic user interface 在主题里选择一个你喜欢的颜色 最后应用</p> 
<p>注销，重新登陆，就可以发现已经可以在各个软件中输入中文了</p> 
<h3><a id="_464"></a>总结</h3> 
<p>这是我目前安装过的linux中，最难安装的一个发行版本。在安装的过程中学到了不少东西。后面使用下来看看与CentOS有什么区别吧。</p> 
<h2><a id="_466"></a>参考</h2> 
<p><a href="https://www.bilibili.com/video/BV1qf4y1D7Da?share_source=copy_web" rel="nofollow">https://www.bilibili.com/video/BV1qf4y1D7Da?share_source=copy_web</a></p> 
<p><a href="https://wiki.archlinux.org/index.php/Installation_guide" rel="nofollow">https://wiki.archlinux.org/index.php/Installation_guide</a></p> 
<p><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/basic_install" rel="nofollow">https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/basic_install</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7de6019c246e1017132b26aff2cec6d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">超长指令字、软流水</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/790cb0a24d0b53cd550348353e130c7c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Makefile学习笔记12|自定义makefile函数调用实现中的install</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>