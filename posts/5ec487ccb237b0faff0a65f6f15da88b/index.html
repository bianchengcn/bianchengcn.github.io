<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>堆排序实现优先队列（Priority queue） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="堆排序实现优先队列（Priority queue）" />
<meta property="og:description" content="1.大体思路 队列内使用最大堆排序，将最大值放在根节点，出队操即每次取出堆顶值，并将队列长度减1；入队操作则是在队列末尾加入待入队的数字，并使用之前函数BuildMaxHeap(Arr, Len)重新建立最大堆；获得队首值则直接返回Arr[0]即可，每次操作前检查队列是否为空。 2.代码如下
#include &lt;iostream&gt; #include &lt;ctime&gt; #include &lt;windows.h&gt; using namespace std; int Len; int Arr[100]; //struct HeapStruct { // int Capacity; // int Size; // int *Element; //}; //HeapStruct* Initialize(int MaxNum) { //} void Swape(int *p, int *q) { int tmp = *p; *p = *q; *q = tmp; } void RandomSort(int *nArr, int nLen) { srand(time(NULL)); for(int i = 0; i &lt; nLen; &#43;&#43;i) { int nIndex = rand() % nLen; Swape(&amp;nArr[i], &amp;nArr[nIndex]); //Sleep(2000); //等待2s，更新随机种子 } } void InitArr(int *nArr, int nLen) { //初始化数组 srand(time(NULL)); for(int i = 0; i &lt; nLen; &#43;&#43;i) { //nArr[i] = rand() % 100; nArr[i] = i; } } void PrintArr(int *nArr, int nLen) { //打印数组 for(int i = 0; i &lt; nLen; &#43;&#43;i) { cout &lt;&lt; nArr[i] &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5ec487ccb237b0faff0a65f6f15da88b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-05T16:19:49+08:00" />
<meta property="article:modified_time" content="2017-12-05T16:19:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">堆排序实现优先队列（Priority queue）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1.大体思路 <br> 队列内使用最大堆排序，将最大值放在根节点，出队操即每次取出堆顶值，并将队列长度减1；入队操作则是在队列末尾加入待入队的数字，并使用之前函数BuildMaxHeap(Arr, Len)重新建立最大堆；获得队首值则直接返回Arr[0]即可，每次操作前检查队列是否为空。 <br> 2.代码如下</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;ctime&gt;</span>
<span class="hljs-preprocessor">#include &lt;windows.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> Len;
<span class="hljs-keyword">int</span> Arr[<span class="hljs-number">100</span>];

<span class="hljs-comment">//struct HeapStruct {<!-- --></span>
<span class="hljs-comment">//    int Capacity;</span>
<span class="hljs-comment">//    int Size;</span>
<span class="hljs-comment">//    int *Element;</span>
<span class="hljs-comment">//};</span>

<span class="hljs-comment">//HeapStruct* Initialize(int MaxNum) {<!-- --></span>

<span class="hljs-comment">//}</span>

<span class="hljs-keyword">void</span> Swape(<span class="hljs-keyword">int</span> *p, <span class="hljs-keyword">int</span> *q) {
    <span class="hljs-keyword">int</span> tmp = *p;
    *p = *q;
    *q = tmp;
}

<span class="hljs-keyword">void</span> RandomSort(<span class="hljs-keyword">int</span> *nArr, <span class="hljs-keyword">int</span> nLen) {
    srand(time(NULL));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nLen; ++i) {
        <span class="hljs-keyword">int</span> nIndex = rand() % nLen;
        Swape(&amp;nArr[i], &amp;nArr[nIndex]);
        <span class="hljs-comment">//Sleep(2000);                       //等待2s，更新随机种子</span>
    }
}

<span class="hljs-keyword">void</span> InitArr(<span class="hljs-keyword">int</span> *nArr, <span class="hljs-keyword">int</span> nLen) {     <span class="hljs-comment">//初始化数组</span>
    srand(time(NULL));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nLen; ++i) {
        <span class="hljs-comment">//nArr[i] = rand() % 100;</span>
        nArr[i] = i;
    }
}

<span class="hljs-keyword">void</span> PrintArr(<span class="hljs-keyword">int</span> *nArr, <span class="hljs-keyword">int</span> nLen) {   <span class="hljs-comment">//打印数组</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nLen; ++i) {
        <span class="hljs-built_in">cout</span> &lt;&lt; nArr[i] &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;
}

<span class="hljs-comment">//返回父节点下标</span>
<span class="hljs-keyword">int</span> Parent(<span class="hljs-keyword">int</span> i) {
    <span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
}

<span class="hljs-comment">//返回i左节点下标</span>
<span class="hljs-keyword">int</span> LeftChild(<span class="hljs-keyword">int</span> i) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;
}

<span class="hljs-comment">//返回i右节点下标</span>
<span class="hljs-keyword">int</span> RightChild(<span class="hljs-keyword">int</span> i) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;
}

<span class="hljs-comment">//最大堆化，保证每个父节点都比子节点大</span>
<span class="hljs-keyword">void</span> MaxHeapify(<span class="hljs-keyword">int</span> *nArr, <span class="hljs-keyword">int</span> nLen, <span class="hljs-keyword">int</span> i) {
    <span class="hljs-keyword">int</span> LC = LeftChild(i);
    <span class="hljs-keyword">int</span> RC = RightChild(i);
    <span class="hljs-keyword">int</span> nMaxPos;
    <span class="hljs-keyword">if</span>(LC &lt; nLen &amp;&amp; nArr[LC] &gt; nArr[i]) {
        nMaxPos = LC;
    } <span class="hljs-keyword">else</span> {
        nMaxPos = i;
    }
    <span class="hljs-keyword">if</span>(RC &lt; nLen &amp;&amp; nArr[RC] &gt; nArr[nMaxPos]) {
        nMaxPos = RC;
    }

    <span class="hljs-keyword">if</span>(nMaxPos != i) {
        Swape(&amp;nArr[nMaxPos], &amp;nArr[i]);
        MaxHeapify(nArr, nLen, nMaxPos);
    }
}

<span class="hljs-comment">//将最大值移动到树的根节点，即数组头</span>
<span class="hljs-keyword">void</span> BuildMaxHeap(<span class="hljs-keyword">int</span> *nArr, <span class="hljs-keyword">int</span> nLen) {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = Parent(nLen - <span class="hljs-number">1</span>); i &gt;= <span class="hljs-number">0</span>; --i) {
        MaxHeapify(nArr, nLen, i);
    }
}

<span class="hljs-comment">//最大堆排序</span>
<span class="hljs-keyword">void</span> HeapSort(<span class="hljs-keyword">int</span> *nArr, <span class="hljs-keyword">int</span> nLen) {
    BuildMaxHeap(nArr, nLen);                <span class="hljs-comment">//将最大值移动至堆顶</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nLen - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) {
        Swape(&amp;nArr[i], &amp;nArr[<span class="hljs-number">0</span>]);           <span class="hljs-comment">//将堆顶的最大值放在数组最末尾nArr[nLen - 1]处</span>
        --nLen;                              <span class="hljs-comment">//在堆中去除末尾元素（因为已经排好序，最后一位是最大值）</span>
        MaxHeapify(nArr, nLen, <span class="hljs-number">0</span>);           <span class="hljs-comment">//从堆顶开始，将刚刚交换上来的nArr[i]往下移动，直至满足其父节点大于其本身的值</span>
    }
}

<span class="hljs-keyword">int</span> HeadQueue() {                  <span class="hljs-comment">//取队头元素</span>
    <span class="hljs-keyword">if</span>(Arr == <span class="hljs-keyword">nullptr</span> || Len == <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"queue empty"</span> &lt;&lt; endl;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> Arr[<span class="hljs-number">0</span>];
}

<span class="hljs-keyword">int</span> PopQueue() {                    <span class="hljs-comment">//出队</span>
    <span class="hljs-keyword">if</span>(Arr == <span class="hljs-keyword">nullptr</span> || Len == <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"queue empty"</span> &lt;&lt; endl;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">int</span> res = Arr[<span class="hljs-number">0</span>];
    Swape(&amp;Arr[Len - <span class="hljs-number">1</span>], &amp;Arr[<span class="hljs-number">0</span>]);
    --Len;
    BuildMaxHeap(Arr, Len);
    <span class="hljs-keyword">return</span> res;
}

<span class="hljs-keyword">void</span> PushQueue(<span class="hljs-keyword">int</span> element) {      <span class="hljs-comment">//入队</span>
    ++Len;
    Arr[Len - <span class="hljs-number">1</span>] = element;
    BuildMaxHeap(Arr, Len);
}




<span class="hljs-keyword">int</span> main() {
    Len = <span class="hljs-number">0</span>;

<span class="hljs-comment">//    InitArr(nArr, Len);</span>
<span class="hljs-comment">//    RandomSort(nArr, Len);</span>
<span class="hljs-comment">//    PrintArr(Arr, Len);</span>
<span class="hljs-comment">//    cout &lt;&lt; endl;</span>

    <span class="hljs-comment">//HeapSort(nArr, Len);</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"push 5"</span> &lt;&lt; endl;
    PushQueue(<span class="hljs-number">5</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"push 9"</span> &lt;&lt; endl;
    PushQueue(<span class="hljs-number">9</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"push 3"</span> &lt;&lt; endl;
    PushQueue(<span class="hljs-number">3</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"push 15"</span> &lt;&lt; endl;
    PushQueue(<span class="hljs-number">15</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"push -4"</span> &lt;&lt; endl;
    PushQueue(-<span class="hljs-number">4</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"HeadQueue is "</span> &lt;&lt; HeadQueue() &lt;&lt; endl;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"now queue is "</span> &lt;&lt; endl;
    PrintArr(Arr, Len);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"pop "</span> &lt;&lt; PopQueue() &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"pop "</span> &lt;&lt; PopQueue() &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"pop "</span> &lt;&lt; PopQueue() &lt;&lt; endl;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"push 20"</span> &lt;&lt; endl;
    PushQueue(<span class="hljs-number">20</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"push 6"</span> &lt;&lt; endl;
    PushQueue(<span class="hljs-number">6</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"now queue is "</span> &lt;&lt; endl;
    PrintArr(Arr, Len);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"pop "</span> &lt;&lt; PopQueue() &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"pop "</span> &lt;&lt; PopQueue() &lt;&lt; endl;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"HeadQueue is "</span> &lt;&lt; HeadQueue() &lt;&lt; endl;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"now queue is "</span> &lt;&lt; endl;
    PrintArr(Arr, Len);
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre> 
<p>3.运行结果 <br> <img src="https://images2.imgbox.com/e6/a5/T04LO6we_o.png" alt="这里写图片描述" title=""> <br> 4.总结 <br> 需要注意的是，堆排序与二叉搜索树不同，二叉堆只保证了父节点大于子节点，因此在上面输出结果中，Arr数组并不能保证是降序排列的，但可以确保堆顶元素为队内最大值，即可以实现优先队列。出于性能考虑，优先队列用堆来实现，具有O(log n)时间复杂度的插入和提取元素性能，O(n)的初始化构造的时间复杂度。如果使用自平衡二叉查找树，插入与删除的时间复杂度为O(log n)，构造二叉树的时间复杂度为O(n log n)。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d94d06aa6c12d91a1b5057aabefdc5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">西门子plc s7-200 读取plc内部时间的方法详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/15f266735ddd8e93c5316baacde7c1e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【操作系统】页式储存方式，页，页表，页表项</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>