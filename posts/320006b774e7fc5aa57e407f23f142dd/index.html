<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【计组】第七章：输入输出系统 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【计组】第七章：输入输出系统" />
<meta property="og:description" content="7.1.1 输入输出系统和I/O控制方式 主机如何与I/O设备进行交互？ **I/O接口：**又称I/O控制器、设备控制器，负责协调主机与外部设备之间的数据传输。其实就是一块芯片。
I/O控制方式简介 scanf(&#34;%d&#34;,&amp;c)这个输入语句具体是如何执行的呢？
首先CPU会通过控制总线发送一个读命令，告诉键盘我要读一个数据，然后通过地址总线指明要使用哪个I/O设备。键盘接受到数据后，会将数据放到数据寄存器中。但是CPU怎么知道键盘是否已经工作结束了呢，键盘输入结束后会将结束信号卸载状态寄存器中，表明自己已经输入完成了，然后CPU去查询这个状态寄存器，就能够知道结束了没，然后就去数据寄存器中取数据然后赋值给c这个变量。
CPU如何控制键盘I/O的完成？
程序查询方式：CPU不断轮询检查I/O控制器中的状态寄存器，检查到状态为”已完成“之后，再从数据寄存器取出输入数据。不难得知，这种方式会极大地浪费CPU的资源，如果键盘一直不输入，CPU就会一直等待键盘输入而不能去做其他事情。**程序中断方式：**等待键盘I/O时CPU可以先去执行其他程序，键盘I/O完成后I/O控制器向CPU发出中断请求，CPU响应中断请求，并取走输入数据。这种方式就解决了CPU忙等的问题。 数据流：键盘-&gt; I/O接口的数据寄存器-&gt;数据总线-&gt;CPU某寄存器-&gt;主存（变量的地址）
但是如果数据量很大的时候，没输入一个数据都会产生一次中断，这样CPU的大量时间都用来处理中断了，造成CPU的利用下降。
DMA控制方式 DMA控制方式：主存与高速I/O设备之间有一条直接数据通路（DMA总线）。CPU向DMA接口发出&#34;读/写”命令，并指明主存地址、磁盘地址、读写数据量等参数。
DMA控制器自动控制键盘与主存的数据读写，没完成一整块数据读写，才向CPU发出一次中断请求。
主存地址：读/写的数据存在内存中什么位置
磁盘地址：从磁盘的什么位置开始读/写
读写数据量：要读/写多少信息。
通道控制方式 有的商用中、大型机可能会街上超多的I/O设备，如果都让CPU来管理，那么CPU就太累了。
所以为了出现了通道控制方式。
通道：是一种特殊的处理器，通道可以识别并执行一系列通道指令。
通道控制方式的执行：
CPU向通道发出I/O指令。指明通道程序在内存中的位置，并指明要操作的是哪个I/O设备。CPU就可以去做其他事情。通道执行内存中的通道程序，控制I/O设备完成一系列任务。通道执行完规定的任务后，向CPU发出中断请求，之后CPU对中断进行处理。 DMA是每处理完一次数据块后就执行一次中断，而通道是全部数据处理完后才向CPU发出中断。
I/O系统基本组成 一般来说，I/O系统由I/O软件和I/O硬件两部分组成。
I/O硬件：包括外部设备、I/O接口、I/O总线等。
7.2 I/O接口 I/O接口的功能 数据缓冲：匹配CPU与外部设备的速度差距。状态检测：反映外部设备的工作状态。格式转换：实现数据格式转换或逻辑电平信号转换。设备寻址：接收来自总线的地址信息，经过译码电路，选择对应外部设备中的寄存器或存储器。数据交互：实现外部设备、主存与CPU之间的数据交换。设备控制：传送CPU命令。 I/O接口的结构 **数据缓冲寄存器：**用于缓冲数据，以匹配CPU与外部设备之间的速度差异。
**设备状态寄存器：**用于反馈设备状态，常见的状态信息入设备忙、设备就绪、设备错误等。供CPU查用。
**设备命令寄存器：**用于接收CPU发送的设备控制命令
I/O接口的工作原理 发命令：发送命令字到I/O控制寄存器，像设备发送命令（需要驱动程序的协助）读状态：从状态寄存器读取状态字，获得设备或I/O控制器的状态信息读写数据：从数据缓冲寄存器发送或读取数据，完成主机与外设的数据交换。 设备控制器中的每个寄存器可以称为一个端口，
I/O端口及其编址 统一编址：把I/O端口当作存储器的单元进行地址分配，用统一的访存指令就可以访问I/O端口，又称 存储器映射方式。
靠不同的地址码区分内存和I/O设备，I/O地址要求相对固定在地址的某部分。
优点：不需要专门的输入/输出指令，所有访存指令都可直接访问端口，程序设计灵活性高。端口有较大的编址空间。读写控制逻辑电路简单。
缺点：端口占用了主存地址空间，使主存地址空间变小，外设寻址时间长（地址位数多，地址译码速度慢）
独立编址：I/O端口地址与存储器地址无关，独立编址CPU需要设置专门的输入/输出指令，又称I/O映射方式。是靠不同的指令区分内存和I/O设备。
7.3.1 程序查询方式 模拟：打印三个字符
先将要打印的数据存放到CPU的寄存器中，然后去查询打印设备的IO控制器中的状态寄存器，检查该设备此时是否准备就绪，如果不是则继续查询，否则就启动设备，然后将打印设备的地址通过地址线传送到地址译码器，然后将写命令通过控制线传送到I/O逻辑中，I/O逻辑会将该命令存到控制寄存器中。然后再将字符通过数据线传送到数据缓冲寄存器中，然后CPU的工作就完成了，但是他要一直查询状态寄存器的状态，查看设备是否已经打印完成，如果打印完成就继续下一个操作。I/O控制器将控制寄存器中的命令告诉打印设备，然后将数据缓冲寄存器中的数据送到该设备，设备完成之后就会将打印完成的状态告诉I/O逻辑。这样打印一个字符就算完成了。
慢速设备（比如鼠标）：使用程序查询方式对CPU的工作影响不大
快速设备（比如硬盘）：使用程序查询方式对CPU影响极大，CPU需要花费大量的时间去检查。
程序查询方式分为两种：
定时查询：每个一段时间去查询一次独占查询：一直不停地查询 7.3.2 中断的作用和原理 请解释一下中断（Interrupt）。
中断是一种计算机机制，用于在计算机执行期间暂停当前任务并转而处理某个特定事件。它可以是硬件引发的（如输入输出请求）或软件引发的（如异常处理）。 程序中断是指在计算机执行现行程序的过程中，出现某些继续处理的异常情况或特殊请求。CPU暂时中止现行程序，而转去对这些异常清理或特殊请进行处理，在处理完毕后CPU又自动返回到现行程序的断点处，继续执行原程序。
中断流程：
中断请求：中断源向CPU发送中断请求信号中断响应：响应中断的条件。中断判优：如果有多个中断，还要看优先处理哪一个。中断处理：中断隐指令。中断服务程序。 CPU执行完一条指令后，会去判断是否有中断信号，如果此时处于关中断，则不会去处理那些中断信号。那CPU是如何判断是否处于关中断呢？
关中断会被存放在CPU的状态寄存器中。
中断请求标记 CPU检测到了中断，那又是如何判断是哪个设备发来的中断信号？
每个中断源向CPU发出中断请求的时间是随机的。
为了记录中断时间并区分不同的中断源，中断系统需对每个中断源设置 中断请求标记触发器。
当其状态为 1 时，标识中断源有请求。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/320006b774e7fc5aa57e407f23f142dd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-21T17:28:27+08:00" />
<meta property="article:modified_time" content="2023-07-21T17:28:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【计组】第七章：输入输出系统</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="711_IO_1"></a>7.1.1 输入输出系统和I/O控制方式</h3> 
<h4><a id="IO_3"></a>主机如何与I/O设备进行交互？</h4> 
<p>**I/O接口：**又称I/O控制器、设备控制器，负责协调主机与外部设备之间的数据传输。其实就是一块芯片。<br> <img src="https://images2.imgbox.com/7f/b7/HzNbTens_o.png" alt="image.png"></p> 
<h4><a id="IO_8"></a>I/O控制方式简介</h4> 
<p><code>scanf("%d",&amp;c)</code>这个输入语句具体是如何执行的呢？<br> 首先CPU会通过控制总线发送一个读命令，告诉键盘我要读一个数据，然后通过地址总线指明要使用哪个I/O设备。键盘接受到数据后，会将数据放到数据寄存器中。但是CPU怎么知道键盘是否已经工作结束了呢，键盘输入结束后会将结束信号卸载状态寄存器中，表明自己已经输入完成了，然后CPU去查询这个状态寄存器，就能够知道结束了没，然后就去数据寄存器中取数据然后赋值给c这个变量。</p> 
<p>CPU如何控制键盘I/O的完成？</p> 
<ol><li><strong>程序查询方式</strong>：CPU不断轮询检查I/O控制器中的状态寄存器，检查到状态为”已完成“之后，再从数据寄存器取出输入数据。不难得知，这种方式会极大地浪费CPU的资源，如果键盘一直不输入，CPU就会一直等待键盘输入而不能去做其他事情。</li><li>**程序中断方式：**等待键盘I/O时CPU可以先去执行其他程序，键盘I/O完成后I/O控制器向CPU发出中断请求，CPU响应中断请求，并取走输入数据。这种方式就解决了CPU忙等的问题。</li></ol> 
<p>数据流：键盘-&gt; I/O接口的数据寄存器-&gt;数据总线-&gt;CPU某寄存器-&gt;主存（变量的地址）<br> <img src="https://images2.imgbox.com/dc/82/aNU2vkiD_o.png" alt="image.png"></p> 
<p>但是如果数据量很大的时候，没输入一个数据都会产生一次中断，这样CPU的大量时间都用来处理中断了，造成CPU的利用下降。<br> <img src="https://images2.imgbox.com/a3/b8/ReaMfztW_o.png" alt="image.png"></p> 
<h4><a id="DMA_24"></a>DMA控制方式</h4> 
<p>DMA控制方式：主存与高速I/O设备之间有一条直接数据通路（DMA总线）。CPU向DMA接口发出"读/写”命令，并指明主存地址、磁盘地址、读写数据量等参数。<br> DMA控制器自动控制键盘与主存的数据读写，没完成<strong>一整块数据读写，才向CPU发出一次中断请求。</strong><br> 主存地址：读/写的数据存在内存中什么位置<br> 磁盘地址：从磁盘的什么位置开始读/写<br> 读写数据量：要读/写多少信息。<br> <img src="https://images2.imgbox.com/ed/1b/xoFZ7bXv_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/be/19/PTrmyCsE_o.png" alt="image.png"></p> 
<h4><a id="_34"></a>通道控制方式</h4> 
<p>有的商用中、大型机可能会街上超多的I/O设备，如果都让CPU来管理，那么CPU就太累了。<br> 所以为了出现了通道控制方式。</p> 
<p>通道：是一种特殊的处理器，通道可以识别并执行一系列通道指令。<br> 通道控制方式的执行：</p> 
<ol><li>CPU向通道发出I/O指令。指明通道程序在内存中的位置，并指明要操作的是哪个I/O设备。CPU就可以去做其他事情。</li><li>通道执行内存中的通道程序，控制I/O设备完成一系列任务。</li><li>通道执行完规定的任务后，向CPU发出中断请求，之后CPU对中断进行处理。</li></ol> 
<p>DMA是每处理完一次数据块后就执行一次中断，而通道是全部数据处理完后才向CPU发出中断。<br> <img src="https://images2.imgbox.com/16/7a/C0KrePap_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/e4/53/9SFwtiLS_o.png" alt="image.png"></p> 
<h4><a id="IO_50"></a>I/O系统基本组成</h4> 
<p>一般来说，I/O系统由I/O软件和I/O硬件两部分组成。<br> I/O硬件：包括外部设备、I/O接口、I/O总线等。<br> <img src="https://images2.imgbox.com/72/c9/MWsl1eH5_o.png" alt="image.png"></p> 
<h3><a id="72_IO_56"></a>7.2 I/O接口</h3> 
<h4><a id="IO_58"></a>I/O接口的功能</h4> 
<ul><li>数据缓冲：匹配CPU与外部设备的速度差距。</li><li>状态检测：反映外部设备的工作状态。</li><li>格式转换：实现数据格式转换或逻辑电平信号转换。</li><li>设备寻址：接收来自总线的地址信息，经过译码电路，选择对应外部设备中的寄存器或存储器。</li><li>数据交互：实现外部设备、主存与CPU之间的数据交换。</li><li>设备控制：传送CPU命令。</li></ul> 
<p><img src="https://images2.imgbox.com/f0/7d/BPWVjdc4_o.png" alt="image.png"></p> 
<h4><a id="IO_69"></a>I/O接口的结构</h4> 
<p>**数据缓冲寄存器：**用于缓冲数据，以匹配CPU与外部设备之间的速度差异。<br> **设备状态寄存器：**用于反馈设备状态，常见的状态信息入设备忙、设备就绪、设备错误等。供CPU查用。<br> **设备命令寄存器：**用于接收CPU发送的设备控制命令</p> 
<h4><a id="IO_75"></a>I/O接口的工作原理</h4> 
<ol><li>发命令：发送命令字到I/O控制寄存器，像设备发送命令（需要驱动程序的协助）</li><li>读状态：从状态寄存器读取状态字，获得设备或I/O控制器的状态信息</li><li>读写数据：从数据缓冲寄存器发送或读取数据，完成主机与外设的数据交换。</li></ol> 
<p><img src="https://images2.imgbox.com/2e/79/xtShhHBf_o.png" alt="image.png"><br> 设备控制器中的每个寄存器可以称为一个端口，</p> 
<h4><a id="IO_84"></a>I/O端口及其编址</h4> 
<p><img src="https://images2.imgbox.com/09/0b/ae73JJ8f_o.png" alt="image.png"></p> 
<p><strong>统一编址：<strong>把I/O端口当作存储器的单元进行地址分配，用</strong>统一的访存指令</strong>就可以访问I/O端口，又称 <strong>存储器映射方式</strong>。<br> 靠不同的地址码区分内存和I/O设备，I/O地址要求相对固定在地址的某部分。<br> 优点：不需要专门的输入/输出指令，所有访存指令都可直接访问端口，程序设计灵活性高。端口有较大的编址空间。读写控制逻辑电路简单。<br> 缺点：端口占用了主存地址空间，使主存地址空间变小，外设寻址时间长（地址位数多，地址译码速度慢）</p> 
<p><strong>独立编址：<strong>I/O端口地址与存储器地址无关，独立编址CPU需要设置专门的输入/输出指令，又称</strong>I/O映射方式</strong>。是靠<strong>不同的指令区分内存和I/O设备</strong>。</p> 
<p><img src="https://images2.imgbox.com/03/68/Yp2smrIR_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/3e/45/qJFJ7nzT_o.png" alt="image.png"></p> 
<h3><a id="731__98"></a>7.3.1 程序查询方式</h3> 
<p><img src="https://images2.imgbox.com/c8/38/WYaiBs0K_o.png" alt="image.png"><br> 模拟：打印三个字符<br> 先将要打印的数据存放到CPU的寄存器中，然后去查询打印设备的IO控制器中的状态寄存器，检查该设备此时是否准备就绪，如果不是则继续查询，否则就启动设备，然后将打印设备的地址通过地址线传送到地址译码器，然后将写命令通过控制线传送到I/O逻辑中，I/O逻辑会将该命令存到控制寄存器中。然后再将字符通过数据线传送到数据缓冲寄存器中，然后CPU的工作就完成了，但是他要一直查询状态寄存器的状态，查看设备是否已经打印完成，如果打印完成就继续下一个操作。I/O控制器将控制寄存器中的命令告诉打印设备，然后将数据缓冲寄存器中的数据送到该设备，设备完成之后就会将打印完成的状态告诉I/O逻辑。这样打印一个字符就算完成了。<br> <img src="https://images2.imgbox.com/27/a1/GPZxJvdk_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/14/d9/3g4mIof5_o.png" alt="image.png"></p> 
<p>慢速设备（比如鼠标）：使用程序查询方式对CPU的工作影响不大<br> 快速设备（比如硬盘）：使用程序查询方式对CPU影响极大，CPU需要花费大量的时间去检查。</p> 
<p>程序查询方式分为两种：</p> 
<ol><li>定时查询：每个一段时间去查询一次</li><li>独占查询：一直不停地查询</li></ol> 
<p><img src="https://images2.imgbox.com/69/47/OPAluUHj_o.png" alt="image.png"></p> 
<h3><a id="732__116"></a>7.3.2 中断的作用和原理</h3> 
<p>请解释一下中断（Interrupt）。</p> 
<ul><li>中断是一种计算机机制，用于在计算机执行期间暂停当前任务并转而处理某个特定事件。它可以是硬件引发的（如输入输出请求）或软件引发的（如异常处理）。</li></ul> 
<p>程序中断是指在计算机执行现行程序的过程中，出现某些继续处理的异常情况或特殊请求。CPU暂时中止现行程序，而转去对这些异常清理或特殊请进行处理，在处理完毕后CPU又自动返回到现行程序的断点处，继续执行原程序。<br> 中断流程：</p> 
<ol><li>中断请求：中断源向CPU发送中断请求信号</li><li>中断响应：响应中断的条件。中断判优：如果有多个中断，还要看优先处理哪一个。</li><li>中断处理：中断隐指令。中断服务程序。</li></ol> 
<p>CPU执行完一条指令后，会去判断是否有中断信号，如果此时处于关中断，则不会去处理那些中断信号。那CPU是如何判断是否处于关中断呢？<br> 关中断会被存放在CPU的状态寄存器中。<br> <img src="https://images2.imgbox.com/91/01/ICJcsPDF_o.png" alt="image.png"></p> 
<h4><a id="_133"></a>中断请求标记</h4> 
<p>CPU检测到了中断，那又是如何判断是哪个设备发来的中断信号？</p> 
<p>每个中断源向CPU发出中断请求的时间是随机的。<br> 为了记录中断时间并区分不同的中断源，中断系统需对每个中断源设置 中断请求标记触发器。<br> 当其状态为 1 时，标识中断源有请求。<br> 这些触发器可以组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。</p> 
<p>对于外中断，CPU实在统一的时刻即每条指令执行阶段结束时向接口发出中断查询信号。以获取I/O的中断请求，也就是说，CPU响应中断的时间实在每条指令执行阶段的结束时刻。<br> CPU响应中断必须满足以下3个条件：</p> 
<ol><li>中断源有中断请求</li><li>CPU允许中断即开中断</li><li>一条指令执行完毕，且没有更紧迫的任务。</li></ol> 
<p><img src="https://images2.imgbox.com/c4/60/8uZyTu2O_o.png" alt="image.png"></p> 
<h4><a id="_151"></a>中断判优-实现</h4> 
<p>如果有多个中断源发来的信号，那么应该先执行哪一个呢？<br> 中断判优既可以用硬件实现，也可以用软件实现；<br> 硬件实现是通过硬件排队器实现的，它既可以设置在CPU中，也可以分散在各个中断源中。<br> <img src="https://images2.imgbox.com/4c/81/v7XMLRLH_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/91/30/wUGdgWcs_o.png" alt="image.png"></p> 
<h4><a id="_159"></a>中断处理过程</h4> 
<p>中断隐指令：保存原程序的PC值，并让PC指向终端服务程序的第一条指令<br> 进入中断服务程序的方法是把该程序第一条指令的地址放入PC<br> 回到主程序的方法是把K+1放入PC</p> 
<p><img src="https://images2.imgbox.com/e1/d7/V7FPXIwj_o.png" alt="image.png"></p> 
<h4><a id="_167"></a>中断处理过程-中断隐指令</h4> 
<ol><li>关中断。在中断服务程序中，为了保护中断现场（即CPU主要寄存器中的内容）期间不被新的中断所打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。</li><li>保存断点。为了保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断电（即程序计数器的内容）保存下来。可以存入堆栈，也可以存入指定单元。</li><li>引出中断服务程序。引出中断服务程序 的实质就是取出中断服务程序的入口地址并传送给程序计计数器。</li></ol> 
<p><img src="https://images2.imgbox.com/fb/5c/BPFQtS3K_o.png" alt="image.png"></p> 
<h4><a id="_175"></a>中断处理过程-硬件向量法</h4> 
<p>如何判断一个中断信号所对应的中断服务程序在内存中的什么地方？</p> 
<p>硬件向量法：由中断向量地址形成部件产生向量地址，向量地址中存储着中断处理程序的起始地址。<br> 那为什么不直接指向中断处理程序的地址呢？<br> 如果中断处理程序在内存中的地址发生变化的话，那么修改中断向量地址形成部件很麻烦，可以直接修改对应的中断向量就可以了，主要为了方便操作。</p> 
<p><img src="https://images2.imgbox.com/a8/d9/ntHprNnx_o.png" alt="image.png"></p> 
<h4><a id="_185"></a>中断处理过程-中断服务程序</h4> 
<p>中断服务程序的主要任务：</p> 
<ol><li>保护现场：保存通用寄存器和状态寄存器的内容，以便返回原程序后可以恢复CPU环境。可使用堆栈，也可以使用特定存储单元。</li><li>中断服务：主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲寄存器中。</li><li>恢复现场：通过出栈指令或取数指令把之前保存的信息送回寄存器中</li><li>中断返回：通过中断返回指令回到原程序断点处。</li></ol> 
<p><img src="https://images2.imgbox.com/25/1d/zikS4NU4_o.png" alt="image.png"></p> 
<p><img src="https://images2.imgbox.com/db/87/n1fWjaXq_o.png" alt="image.png"></p> 
<h3><a id="733__198"></a>7.3.3 多重中断</h3> 
<h4><a id="_200"></a>单重中断和多重中断</h4> 
<p>单重中断：执行中断服务程序时不响应新的中断请求。<br> 多重中断：执行中断服务程序时可响应新的中断请求。</p> 
<p>为什么开中断要在保护现场之后呢？<br> 如果在之前的话，那么原程序中寄存器的值就有可能丢失，就没办法回到原程序了，所以必须要保护完现场之后才能开中断。<br> <img src="https://images2.imgbox.com/5b/d0/tVGgaIlr_o.png" alt="image.png"></p> 
<h4><a id="_209"></a>中断屏蔽技术</h4> 
<p>屏蔽字：为了屏蔽比当前中断优先级低的中断。<br> <img src="https://images2.imgbox.com/3c/4b/4mfNQMzi_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/96/ff/5G2LqRlU_o.png" alt="image.png"></p> 
<h3><a id="734__215"></a>7.3.4 程序中断方式</h3> 
<p><img src="https://images2.imgbox.com/c2/de/AI79jaQw_o.png" alt="image.png"></p> 
<h4><a id="735_DMA_219"></a>7.3.5 DMA方式</h4> 
<h4><a id="DMA_221"></a>DMA控制器</h4> 
<p>CPU向DMA控制器指明要输入还是输出；要传送多少个数据；数据在主存、外设中的地址。</p> 
<ol><li>DMA控制器接收外设发出的DMA请求，并向CPU发出总线请求。</li><li>CPU响应总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期。</li><li>确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数。</li><li>规定数据在主存和外设之间传送方向，发出读写等控制信号，执行数据传送操作。</li><li>向CPU报告DMA操作的结束（发起一个中断）。</li></ol> 
<p>DMA控制器相当于是CPU的外包，CPU把任务告诉DMA控制器，然后把使用总线的权力分配给它，剩下就让它自己处理，等结束之后告诉CPU。</p> 
<p><img src="https://images2.imgbox.com/6c/76/NObFtT0Y_o.png" alt="image.png"></p> 
<p><img src="https://images2.imgbox.com/ad/8b/7wGo38rY_o.png" alt="image.png"></p> 
<h4><a id="DMA_237"></a>DMA传送过程</h4> 
<p>预处理：</p> 
<ol><li>将主存的起始地址传送到 主存地址计数器中</li><li>将I/O设备地址传送到设备选择</li><li>传送数据个数到 传送长度计数器中</li><li>启动I/O设备</li></ol> 
<p>数据传送：</p> 
<ol><li>CPU继续执行主程序</li><li>设备将数据写入数据缓冲寄存器中</li><li>写满后向DMA控制器发送DMA请求</li><li>DMA控制器向总线发送总线请求</li><li>CPU将总线控制权交给DMA控制器。</li><li>DMA控制器将数据传送到主存</li><li>当数据传送结束后会产生一个溢出信号传送到中断机构，然后向CPU发送中断信号。</li></ol> 
<p>后处理：</p> 
<ol><li>CPU执行中断服务程序，做DMA结束处理</li></ol> 
<p><img src="https://images2.imgbox.com/cd/f9/ETBJa7Jm_o.png" alt="image.png"></p> 
<h4><a id="DMA_262"></a>DMA方式的特点</h4> 
<p>三总线的连接方式<br> <img src="https://images2.imgbox.com/93/64/Efu1Ft27_o.png" alt="image.png"></p> 
<h4><a id="DMA_267"></a>DMA传送方式</h4> 
<p>主存和DMA控制器之间有一条数据通路，因此主存和I/O设备之间交换信息时，不通过CPU。但当I/O设备和CPU同时访问主存时，可能发送冲突，为了有效地使用主存，有山中方法使用：</p> 
<ol><li>停止CPU访问注册呢</li><li>DMA与CPU交替访存</li><li>周期挪用</li></ol> 
<p><img src="https://images2.imgbox.com/0a/b0/SrZB5nxG_o.png" alt="image.png"></p> 
<h4><a id="DMA_277"></a>DMA方式与中断方式</h4> 
<p><img src="https://images2.imgbox.com/18/d1/Bu40uvWR_o.png" alt="image.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a1b4268519f54984ce45ac02e0f374a7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">layui踩坑记录之form表单下的button按钮默认自动提交</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26cb3e2fcb71d9dbba85552000876f94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安装nuxt3报错 Error: Failed to download template from registry</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>