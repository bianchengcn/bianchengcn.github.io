<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java单链表交换相邻元素_数据结构:单向链表系列6--交换相邻两个节点1（交换数据域）... - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java单链表交换相邻元素_数据结构:单向链表系列6--交换相邻两个节点1（交换数据域）..." />
<meta property="og:description" content="给定一个单向链表,编写函数交换相邻 两个元素
输入: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7
输出: 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 6 -&gt; 5 -&gt; 7
输入: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6
输出: 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 6 -&gt; 5
通过观察发现:当输入的与元素个数是单数的时候，最后一位不参与交换。
方法1(迭代)
从头节点开始遍历列表，遍历过程中使用每个节点的下一个节点和当前节点的数据进行交换。
时间复杂度：O(n)
实现过程：
c语言
/*C Program to pairwise swap elements in a given linked list*/#include#include" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c84051cc2e23c083bfd42787bfff00e3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-25T10:24:17+08:00" />
<meta property="article:modified_time" content="2021-02-25T10:24:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java单链表交换相邻元素_数据结构:单向链表系列6--交换相邻两个节点1（交换数据域）...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>给定一个单向链表,编写函数交换相邻 两个元素</p> 
 <p>输入: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7</p> 
 <p>输出: 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 6 -&gt; 5 -&gt; 7</p> 
 <p>输入: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6</p> 
 <p>输出: 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 6 -&gt; 5</p> 
 <p>通过观察发现:当输入的与元素个数是单数的时候，最后一位不参与交换。</p> 
 <p>方法1(迭代)</p> 
 <p>从头节点开始遍历列表，遍历过程中使用每个节点的下一个节点和当前节点的数据进行交换。</p> 
 <p>时间复杂度：O(n)</p> 
 <p>实现过程：</p> 
 <p>c语言</p> 
 <p>/*C Program to pairwise swap elements in a given linked list*/#include#include</p> 
 <p>/*A linked list node*/</p> 
 <p>structNode {intdata;struct Node*next;</p> 
 <p>};/*Function to swap two integers at addresses a and b*/</p> 
 <p>void swap(int *a, int *b);/*Function to pairwise swap elements of a linked list*/</p> 
 <p>void pairWiseSwap(struct Node*head)</p> 
 <p>{struct Node* temp =head;/*Traverse further only if there are at-least two nodes left*/</p> 
 <p>while( temp != NULL &amp;&amp; temp-&gt;next !=NULL)</p> 
 <p>{/*Swap data of node with its next node's data*/swap(&amp;temp-&gt;data, &amp;temp-&gt;next-&gt;data);/*Move temp by 2 for the next pair*/temp= temp-&gt;next-&gt;next;</p> 
 <p>}</p> 
 <p>}/*Utility functions*/</p> 
 <p>/*function to swap two integers*/</p> 
 <p>void swap(int *a, int *b)</p> 
 <p>{inttemp;</p> 
 <p>temp= *a;*a = *b;*b =temp;</p> 
 <p>}/*Funtion to add a node at the beginning of Linked List*/</p> 
 <p>void push(struct Node** head_ref, intnew_data)</p> 
 <p>{/*allocate node*/</p> 
 <p>struct Node* new_node = (struct Node*)malloc(sizeof(structNode));/*put in the data*/new_node-&gt;data =new_data;/*link the old list off the new node*/new_node-&gt;next = (*head_ref);/*move the head to point to the new node*/(*head_ref) =new_node;</p> 
 <p>}/*function to print nodes in a given linked list*/</p> 
 <p>void printList(struct Node*node)</p> 
 <p>{while( node !=NULL )</p> 
 <p>{<!-- --></p> 
 <p>printf("%d", node-&gt;data);</p> 
 <p>node= node-&gt;next;</p> 
 <p>}</p> 
 <p>printf("\n");</p> 
 <p>}/*driver program to test above function*/</p> 
 <p>intmain() {struct Node* start =NULL;/*the constructed linked list is:</p> 
 <p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5*/push(&amp;start ,5);</p> 
 <p>push(&amp;start, 4);</p> 
 <p>push(&amp;start, 3);</p> 
 <p>push(&amp;start, 2);</p> 
 <p>push(&amp;start, 1) ;</p> 
 <p>printf("Linked list before calling pairwise swap function\n");</p> 
 <p>printList(start);</p> 
 <p>pairWiseSwap(start);</p> 
 <p>printf("Linked list after calling pairwise swap function\n");</p> 
 <p>printList(start);return 0;</p> 
 <p>}</p> 
 <p>结果</p> 
 <p align="center"><img src="https://images2.imgbox.com/ea/ff/y7YSmixs_o.png" alt="8bfcb58b96833b4c9cceae16bde2169d.png"></p> 
 <p>java代码：</p> 
 <p>//Java program to pairwise swap elements of a linked list</p> 
 <p>classLinkedList {<!-- --></p> 
 <p>Node head;//head of list</p> 
 <p>/*Linked list Node*/</p> 
 <p>classNode {intdata;</p> 
 <p>Node next;</p> 
 <p>Node(intd)</p> 
 <p>{<!-- --></p> 
 <p>data=d;</p> 
 <p>next= null;</p> 
 <p>}</p> 
 <p>}voidpairWiseSwap()</p> 
 <p>{<!-- --></p> 
 <p>Node temp=head;/*Traverse only till there are atleast 2 nodes left*/</p> 
 <p>while (temp != null &amp;&amp; temp.next != null) {/*Swap the data*/</p> 
 <p>int k =temp.data;</p> 
 <p>temp.data=temp.next.data;</p> 
 <p>temp.next.data=k;</p> 
 <p>temp=temp.next.next;</p> 
 <p>}</p> 
 <p>}/*Utility functions*/</p> 
 <p>/*Inserts a new Node at front of the list.*/</p> 
 <p>public void push(intnew_data)</p> 
 <p>{/*1 &amp; 2: Allocate the Node &amp;</p> 
 <p>Put in the data*/Node new_node= newNode(new_data);/*3. Make next of new Node as head*/new_node.next=head;/*4. Move the head to point to new Node*/head=new_node;</p> 
 <p>}/*Function to print linked list*/</p> 
 <p>voidprintList()</p> 
 <p>{<!-- --></p> 
 <p>Node temp=head;while (temp != null) {<!-- --></p> 
 <p>System.out.print(temp.data+ " ");</p> 
 <p>temp=temp.next;</p> 
 <p>}</p> 
 <p>System.out.println();</p> 
 <p>}/*Driver program to test above functions*/</p> 
 <p>public static voidmain(String args[])</p> 
 <p>{<!-- --></p> 
 <p>LinkedList llist= newLinkedList();/*Created Linked List 1-&gt;2-&gt;3-&gt;4-&gt;5*/llist.push(5);</p> 
 <p>llist.push(4);</p> 
 <p>llist.push(3);</p> 
 <p>llist.push(2);</p> 
 <p>llist.push(1);</p> 
 <p>System.out.println("Linked List before calling pairWiseSwap() ");</p> 
 <p>llist.printList();</p> 
 <p>llist.pairWiseSwap();</p> 
 <p>System.out.println("Linked List after calling pairWiseSwap() ");</p> 
 <p>llist.printList();</p> 
 <p>}</p> 
 <p>}/*This code is contributed by Rajat Mishra*/</p> 
 <p>c#代码</p> 
 <p>//C# program to pairwise swap elements of a linked list</p> 
 <p>usingSystem;classLinkedList {<!-- --></p> 
 <p>Node head;//head of list</p> 
 <p>/*Linked list Node*/</p> 
 <p>public classNode {public intdata;publicNode next;public Node(intd)</p> 
 <p>{<!-- --></p> 
 <p>data=d;</p> 
 <p>next= null;</p> 
 <p>}</p> 
 <p>}voidpairWiseSwap()</p> 
 <p>{<!-- --></p> 
 <p>Node temp=head;/*Traverse only till there are atleast 2 nodes left*/</p> 
 <p>while (temp != null &amp;&amp; temp.next != null) {/*Swap the data*/</p> 
 <p>int k =temp.data;</p> 
 <p>temp.data=temp.next.data;</p> 
 <p>temp.next.data=k;</p> 
 <p>temp=temp.next.next;</p> 
 <p>}</p> 
 <p>}/*Utility functions*/</p> 
 <p>/*Inserts a new Node at front of the list.*/</p> 
 <p>public void push(intnew_data)</p> 
 <p>{/*1 &amp; 2: Allocate the Node &amp;</p> 
 <p>Put in the data*/Node new_node= newNode(new_data);/*3. Make next of new Node as head*/new_node.next=head;/*4. Move the head to point to new Node*/head=new_node;</p> 
 <p>}/*Function to print linked list*/</p> 
 <p>voidprintList()</p> 
 <p>{<!-- --></p> 
 <p>Node temp=head;while (temp != null) {<!-- --></p> 
 <p>Console.Write(temp.data+ " ");</p> 
 <p>temp=temp.next;</p> 
 <p>}</p> 
 <p>Console.WriteLine();</p> 
 <p>}/*Driver program to test above functions*/</p> 
 <p>public static voidMain(String[] args)</p> 
 <p>{<!-- --></p> 
 <p>LinkedList llist= newLinkedList();/*Created Linked List 1-&gt;2-&gt;3-&gt;4-&gt;5*/llist.push(5);</p> 
 <p>llist.push(4);</p> 
 <p>llist.push(3);</p> 
 <p>llist.push(2);</p> 
 <p>llist.push(1);</p> 
 <p>Console.WriteLine("Linked List before calling pairWiseSwap()");</p> 
 <p>llist.printList();</p> 
 <p>llist.pairWiseSwap();</p> 
 <p>Console.WriteLine("Linked List after calling pairWiseSwap()");</p> 
 <p>llist.printList();</p> 
 <p>}</p> 
 <p>}//This code is contributed by Arnab Kundu</p> 
 <p>方法2(递归)</p> 
 <p>如果链表中含有两个以上节点,先交换前两个节点,然后递归调用剩下的节点</p> 
 <p>时间复杂度:O(n)</p> 
 <p align="center"><img src="https://images2.imgbox.com/b2/3b/dWCb2eyy_o.png" alt="1886086879d16cf4d31a9d336da9acda.png"></p> 
 <p>算法主要部分代码</p> 
 <p>/*Recursive function to pairwise swap elements</p> 
 <p>of a linked list*/</p> 
 <p>void pairWiseSwap(struct node*head)</p> 
 <p>{/*There must be at-least two nodes in the list*/</p> 
 <p>if (head != NULL &amp;&amp; head-&gt;next !=NULL) {/*Swap the node's data with data of next node*/swap(&amp;head-&gt;data, &amp;head-&gt;next-&gt;data);/*Call pairWiseSwap() for rest of the list*/pairWiseSwap(head-&gt;next-&gt;next);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>以上代码只是交换数据域部分的指针，如果一个节点含有很多字段，将会产生频繁的交换动作。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c53c0e23148208e1dfda4e31ea584000/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java 建模工具_哪一个uml建模工具好用？6款好用的uml建模工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1c0b884ce7d896b009ddf957ce15ee08/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java怎么开发图形界面_Java Swing 图形界面开发简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>