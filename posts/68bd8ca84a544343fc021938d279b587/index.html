<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STARTUP-STM32F10X_HD.S文件说明 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STARTUP-STM32F10X_HD.S文件说明" />
<meta property="og:description" content=";******************** (C) COPYRIGHT 2011 STMicroelectronics ******************** ;* File Name : startup_stm32f10x_hd.s ;* Author : MCD Application Team ;* Version : V3.5.0 ;* Date : 11-March-2011 ;* Description : STM32F10x High Density Devices vector table for MDK-ARM ;* toolchain. ;* This module performs: ;* - Set the initial SP ;* - Set the initial PC == Reset_Handler ;* - Set the vector table entries with the exceptions ISR address ;* - Configure the clock system and also configure the external ;* SRAM mounted on STM3210E-EVAL board to be used as data ;* memory (optional, to be enabled by user) ;* - Branches to __main in the C library (which eventually ;* calls main())." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/68bd8ca84a544343fc021938d279b587/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-15T10:10:25+08:00" />
<meta property="article:modified_time" content="2023-09-15T10:10:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STARTUP-STM32F10X_HD.S文件说明</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre><code>;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
;* File Name          : startup_stm32f10x_hd.s
;* Author             : MCD Application Team
;* Version            : V3.5.0
;* Date               : 11-March-2011
;* Description        : STM32F10x High Density Devices vector table for MDK-ARM 
;*                      toolchain. 
;*                      This module performs:
;*                      - Set the initial SP
;*                      - Set the initial PC == Reset_Handler
;*                      - Set the vector table entries with the exceptions ISR address
;*                      - Configure the clock system and also configure the external 
;*                        SRAM mounted on STM3210E-EVAL board to be used as data 
;*                        memory (optional, to be enabled by user)
;*                      - Branches to __main in the C library (which eventually
;*                        calls main()).
;*                      After Reset the CortexM3 processor is in Thread mode,
;*                      priority is Privileged, and the Stack is set to Main.
;* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt;   
;*******************************************************************************
; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
;*******************************************************************************

; Amount of memory (in bytes) allocated for Stack
; Tailor this value to your application needs
; &lt;h&gt; Stack Configuration
;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;
; &lt;/h&gt;

;Stack_Size EQU 0x00000400 表示工程中的栈大小为1024字节，即局部变量不能超过1024字节。
;如果函数中出现局部变量例如u8 temp[4000];，
;那么启动文件的栈应该修改为Stack_Size EQU 0x00001000，此时栈大小为4096字节。另外，
;引用中定义的Stack_Size EQU 0x00000200表示堆栈大小为512字节。
;所以，Stack_Size EQU 0x00000400表示栈大小是1024字节。
Stack_Size      EQU     0x00000400

;AREA STACK, NOINIT, READWRITE, ALIGN=3是一个定义栈空间的语句。
;它创建了一个命名为STACK的栈空间，其中NOINIT表示不初始化，READWRITE表示可读可写，
;	ALIGN=3表示2的3次方(8个字节)对齐开辟。
                AREA    STACK, NOINIT, READWRITE, ALIGN=3
					
;Stack_Mem SPACE Stack_Size是一个汇编语言中的指令，用于分配连续的存储单元来作为堆栈空间，
;并初始化为0。

;在实际应用中，可以使用类似以下的代码来定义Stack_Mem和Stack_Size：
;Stack_Size EQU 0x00002000
;AREA STACK, NOINIT, READWRITE, ALIGN=3
;Stack_Mem SPACE Stack_Size
;这段代码将分配0x00002000大小的存储单元作为堆栈空间，并且将其命名为Stack_Mem。

;因此，Stack_Mem SPACE Stack_Size是用来定义堆栈空间的，其中Stack_Mem是堆栈的名称，
Stack_Size是堆栈空间的大小。
Stack_Mem       SPACE   Stack_Size
	
	
;__initial_sp是一个标号，用于表示栈顶地址。在给出的引用中，__initial_sp在汇编代码
;中被定义为栈顶指针的值，即0x200007a0。
;栈顶指针指向栈的最高地址，用于管理函数调用和局部变量的内存分配。在C语言中，栈顶地
;址也可以表示为变量、数组或函数的地址。
;所以，在给定的代码中，__initial_sp标号表示了栈顶地址的位置。	
__initial_sp
                                                  
; &lt;h&gt; Heap Configuration
;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;
; &lt;/h&gt;


;Heap_Size EQU 0X00000200 是一个宏定义，它将0x00000200赋值给了Heap_Size这个符号名。
;在这个例程中，它表示堆的大小是512字节。
Heap_Size       EQU     0x00000200

;AREA HEAP, NOINIT, READWRITE, ALIGN=3是一种用于定义数据段的指令。
;它将堆空间分配给程序的变量和数据，同时要求以8字节对齐方式存储数据。
;这样可以提高内存的访问效率。
                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
					
					
					
;__heap_base是表示堆的起始地址的变量。它的值在引用和引用中都有提到，用于堆的初始化和管理。					
__heap_base




;保留Heap_Size的堆空间
Heap_Mem        SPACE   Heap_Size
	
	
	
	
;标号，代表堆末尾地址，后面有用
__heap_limit

                PRESERVE8  ;指示编译器8字节对齐
                THUMB  ;指示编译器为THUMB指令


; Vector Table Mapped to Address 0 at Reset
                AREA    RESET, DATA, READONLY;定义只读数据段，其实放在CODE区，位于0地址?
					
;EXPORT __Vectors是一个使用了EXPORT关键字的符号。根据引用中的示例，EXPORT关键字用于声明一
;个可供其他代码引用的全局符号。在这个例子中，__Vectors是一个全局符号，
;可能是一个存储器向量表的地址。这个符号被声明为WEAK，这意味着其他同名的符号可以优先于它被引用。
;所以，EXPORT __Vectors [WEAK]表示声明了一个可供其他代码引用的全局符号__Vectors，并且该符号
	可能被其他同名符号覆盖。
                EXPORT  __Vectors

;在引用和引用中，EXPORT __Vectors_End是STM32启动文件中的一个导出变量。它指向向量表的末尾，
;向量表是在复位时映射到地址0处的一个表格。向量表中包含了中断和异常处理程序的地址。
;EXPORT __Vectors_End用于指示向量表的结束位置。在引用中，__Vectors_End也被声明为一个外部可
;访问的变量，并且在该文件中进行了使用和赋值。因此，EXPORT __Vectors_End是用于指示向量表结
;束位置的一个变量。
                EXPORT  __Vectors_End
					
;EXPORT __Vectors_Size 是在STM32的启动文件中定义的一个可被外部调用的变量。
;它用来表示向量表的大小，即__Vectors_End与__Vectors之间的字节数。
;它的值可以通过计算__Vectors_End与__Vectors的差值得到。
                EXPORT  __Vectors_Size

;在引用和引用中，__Vectors DCD __initial_sp ; Top of Stack 是向量表的一部分。
;__Vectors代表向量表的起始地址，而__initial_sp代表的是堆栈的顶部地址。
;这个向量表用于存储中断处理程序和异常处理程序的入口地址。
;在引用中，Stack_Mem SPACE Stack_Size ; 
;表示为堆栈分配了一定大小的存储空间，并将其初始化为0。
;所以，__Vectors DCD __initial_sp ; Top of Stack 是将堆栈的顶部地址存储在向量表中的一条指令。
__Vectors       DCD     __initial_sp               ; Top of Stack
                DCD     Reset_Handler              ; Reset Handler
                DCD     NMI_Handler                ; NMI Handler
                DCD     HardFault_Handler          ; Hard Fault Handler
                DCD     MemManage_Handler          ; MPU Fault Handler
                DCD     BusFault_Handler           ; Bus Fault Handler
                DCD     UsageFault_Handler         ; Usage Fault Handler
                DCD     0                          ; Reserved
                DCD     0                          ; Reserved
                DCD     0                          ; Reserved
                DCD     0                          ; Reserved
                DCD     SVC_Handler                ; SVCall Handler
                DCD     DebugMon_Handler           ; Debug Monitor Handler
                DCD     0                          ; Reserved
                DCD     PendSV_Handler             ; PendSV Handler
                DCD     SysTick_Handler            ; SysTick Handler

                ; External Interrupts
                DCD     WWDG_IRQHandler            ; Window Watchdog
                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect
                DCD     TAMPER_IRQHandler          ; Tamper
                DCD     RTC_IRQHandler             ; RTC
                DCD     FLASH_IRQHandler           ; Flash
                DCD     RCC_IRQHandler             ; RCC
                DCD     EXTI0_IRQHandler           ; EXTI Line 0
                DCD     EXTI1_IRQHandler           ; EXTI Line 1
                DCD     EXTI2_IRQHandler           ; EXTI Line 2
                DCD     EXTI3_IRQHandler           ; EXTI Line 3
                DCD     EXTI4_IRQHandler           ; EXTI Line 4
                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1
                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2
                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3
                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4
                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5
                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6
                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7
                DCD     ADC1_2_IRQHandler          ; ADC1 &amp; ADC2
                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX
                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0
                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1
                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE
                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5
                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break
                DCD     TIM1_UP_IRQHandler         ; TIM1 Update
                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation
                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare
                DCD     TIM2_IRQHandler            ; TIM2
                DCD     TIM3_IRQHandler            ; TIM3
                DCD     TIM4_IRQHandler            ; TIM4
                DCD     I2C1_EV_IRQHandler         ; I2C1 Event
                DCD     I2C1_ER_IRQHandler         ; I2C1 Error
                DCD     I2C2_EV_IRQHandler         ; I2C2 Event
                DCD     I2C2_ER_IRQHandler         ; I2C2 Error
                DCD     SPI1_IRQHandler            ; SPI1
                DCD     SPI2_IRQHandler            ; SPI2
                DCD     USART1_IRQHandler          ; USART1
                DCD     USART2_IRQHandler          ; USART2
                DCD     USART3_IRQHandler          ; USART3
                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10
                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line
                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend
                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break
                DCD     TIM8_UP_IRQHandler         ; TIM8 Update
                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation
                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare
                DCD     ADC3_IRQHandler            ; ADC3
                DCD     FSMC_IRQHandler            ; FSMC
                DCD     SDIO_IRQHandler            ; SDIO
                DCD     TIM5_IRQHandler            ; TIM5
                DCD     SPI3_IRQHandler            ; SPI3
                DCD     UART4_IRQHandler           ; UART4
                DCD     UART5_IRQHandler           ; UART5
                DCD     TIM6_IRQHandler            ; TIM6
                DCD     TIM7_IRQHandler            ; TIM7
                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1
                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2
                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3
                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 &amp; Channel5
__Vectors_End


;__Vectors_Size EQU __Vectors_End - __Vectors 表示__Vectors_Size等于
;__Vectors_End减去__Vectors的值。具体值可以通过计算得到。根据引用的信息，
;__Vectors_End的值为0x200013A4，而__Vectors的值为0x20003608。
;所以，__Vectors_Size的值可以计算得到为0x000000EC。

__Vectors_Size  EQU  __Vectors_End - __Vectors


;在汇编语言中，AREA是一个伪指令，用于定义一个代码段或数据段。在你提供的引用中，
;AREA |.text|, CODE, READONLY用于定义一个名为.text的代码段，
;该代码段是只读的。这个指令告诉编译器将接下来的代码放入名为.text的代码段中，
;并指定该代码段的属性为CODE（表示代码段）和READONLY（表示只读）。
                AREA    |.text|, CODE, READONLY
                
; Reset handler


;引用中描述了Reset_Handler PROC的作用是设置初始SP、设置初始PC为Reset_Handler、
;设置向量表入口地址并初始化向量表等。Reset_Handler是一个子程序，
;它定义了Reset_Handler PROC和ENDP之间的一段代码。在这段代码中，首先调用
;SystemInit函数将系统时钟配置为72M，然后跳转到标号__main处，最终进入C程序文件执行。
;引用中解释了PROC是子程序定义的伪指令，用于定义一个子程序。它的一般用法是在子
;程序名后面加上PROC关键字，然后在ENDP之前编写子程序的代码。
;PROC指令可用NEAR或FAR属性来指定子程序的调用方式。NEAR属性表示子程序只能被同一代码段中
Reset_Handler   PROC
	
;在这个问题中，EXPORT Reset_Handler [WEAK]是指在汇编代码中定义了一个名为
;Reset_Handler的过程，并将其导出为可供外部使用的符号。 
;在这个代码段中，提到了Reset_Handler的前导部分，其中导入了SystemInit和__main两个符号。
;这个代码段的目的是在启动时执行SystemInit函数，然后跳转到__main函数。
;通过这种方式，可以在程序启动后执行一些初始化操作，并将控制权交给主程序。
;对于EXPORT Reset_Handler [WEAK]的具体含义，我无法提供更多细节，因为这取决于代码中的其他部分。	
                EXPORT  Reset_Handler             [WEAK]
				
;import __main__是Python中的一个特殊模块，它代表当前执行的脚本文件。
;当我们在一个脚本中使用import __main__语句时，它不会导入其他模块或对象，
;而是触发当前脚本文件的执行。这在某些情况下可以用于检查脚本是否被直接执行，而不是作为模块被导入。				
                IMPORT  __main
                IMPORT  SystemInit
					
;LDR R0, =SystemInit 是一条汇编指令，它的作用是将 SystemInit 
;的地址加载到寄存器 R0 中。 在这个上下文中，
;它可能是用来执行系统初始化函数 SystemInit 的。具体来说，它将 SystemInit 的地址加载到 
;R0 后，通过 BLX R0 执行 SystemInit 函数。这个函数可能包含了一些对系统进行初始化的操作。
                LDR     R0, =SystemInit
				
;BLX R0是一条ARM汇编指令，它用于跳转到存储在寄存器R0中的地址处执行子程序。
;在给定的引用内容中没有找到关于BLX R0的具体信息。
                BLX     R0   


;LDR R0, =__main这条指令是将__main的地址加载到寄存器R0中。

;这个指令的作用是将__main的地址存储在寄存器R0中，以便后续的操作可以使用这个地址。
;这里的__main通常是指程序的入口点，也就是程序开始执行的地方。根据上下文来看，
;这个指令很可能是用于跳转到程序的入口点，开始执行主程序的逻辑。
                LDR     R0, =__main
				
;在ARM汇编中，BX指令用于跳转到寄存器所存储的地址。比如，BX R0表示将程序的控
;制权跳转到R0寄存器所存储的地址上。 在给定的引用中，bx r0指令是一个示例，
;用来展示BX指令的用法
                BX      R0
                ENDP
                
; Dummy Exception Handlers (infinite loops which can be modified)

;NMI_Handler是一个过程（Procedure），也可以理解为一个中断服务程序。
;当在使用某个外设的时候，开启了某个中断，但忘记编写配套的中断服务程序或者函数名写错时，
;当中断到来时，程序就会跳转到启动文件预先写好的空的中断服务程序NMI_Handler中，
;然后在这个空函数中无限循环，即程序就死在这里。
NMI_Handler     PROC
	
;EXPORT和[WEAK]是用来定义符号弱化标识的。EXPORT表示将该符号导出，使得其他
;模块可以引用该符号。而[WEAK]标识表示该符号被弱化处理，在链接时如果遇到名
;称相同的符号，将使用未被弱化定义的符号，而与弱化符号相关的代码将被丢弃。

;在的引用中，可以看到NMI_Handler PROC EXPORT NMI_Handler [WEAK] B . ENDP这段代码。
;其中的EXPORT和[WEAK]用来定义NMI_Handler这个符号，并将其导出和标记为弱化处理。
                EXPORT  NMI_Handler                [WEAK]
                B       .
                ENDP
					
;HardFault_Handler故障的原因主要有两个方面。首先，内存溢出或者访问越界可能导致此故障。
;这可以通过规范代码并逐步排查来解决。其次，堆栈溢出也可能引发此故障，可以通过增加堆栈的大小
;来解决[1]。

;另外，在调试程序时，有时需要将掉电前的数据存储到flash中，然后在下次初始化时将数据读入。
;关于STM32的flash操作，有些资料可能过于冗长而没有实质性内容可用，
;但可以自行调试和编写flash读写代码来实现存储和读取。

;值得一提的是，内存中还有不同的区域，包括栈区、堆区和全局区。栈区是由系统自动分配和释放的，
;通常用于存储局部变量和函数调用过程中的数据。

;综上所述，对于HardFault_Handler故障，需要注意内存溢出或访问越界的问题，并可以通过增加
;堆栈大小来解决。同时，在调试过程中，可以使用flash存储数据，并编写相应的读写代码。
;此外，了解不同内存区域的特点也有助于理解和排查故障。
HardFault_Handler\
                PROC
                EXPORT  HardFault_Handler          [WEAK]
                B       .
                ENDP
					
					
;MemManage_Handler是一个用来处理内存管理异常的函数。在引用中提到，当访问了内存管理单元
;定义的不合法的内存区域时，就会触发内存管理异常。而MemManage_Handler函数的作用就是在发生
;内存管理异常时，
;让程序进入一个无限循环，以防止程序继续执行下去导致更严重的错误。在引用中提到了一种解决
;报错的方法，即将stm32f4xx_it.c文件中的MemManage_Handler()函数注释掉。
;这个方法的效果是当发生内存管理异常时，程序将不会进入无限循环，而是继续执行后面的代码。
;这样可能会导致程序继续运行，但是可能会出现其他问题。所以，在解决报错时，需要确保对内存管理
;异常的处理是正确的，并不是简单地注释掉MemManage_Handler()函数。
MemManage_Handler\
                PROC
                EXPORT  MemManage_Handler          [WEAK]
                B       .
                ENDP
					
					

;BusFault_Handler是一个中断处理程序，用来处理在内存访问过程中产生的错误。
;当在fetch指令、数据读写、fetch中断向量或中断时存储恢复寄存器栈的情况下，
;检测到内存访问错误时，就会触发BusFault。

;在gd32f10x_it.c文件中，有一个名为SysTick_Handler的中断处理函数，它的作用是在
;每个SysTick定时器中断发生时执行一段代码，其中包含了一个名为delay_decrement()的函数调用。

;在某些情况下，我们可能需要启用Usage Fault、Bus Fault和MMU Fault这些故障的检测。
;在代码中，通过将SCB-&gt;SHCSR寄存器的相应位设置为1，来启用这些故障的检测。
;例如，通过执行SCB-&gt;SHCSR |= 0x00007000;，
;可以启用Usage Fault、Bus Fault和MMU Fault的检测。					
BusFault_Handler\
                PROC
                EXPORT  BusFault_Handler           [WEAK]
                B       .
                ENDP
					
					
;UsageFault_Handler是一个函数，在中断处理程序文件stm32f10x_it.c中定义。
;它是处理Usage Fault异常的中断处理程序。当发生Usage Fault异常时，代码
;将进入这个中断处理程序，并通过进入无限循环的方式停止运行。 
;Usage Fault异常是指在执行指令或访问数据时发生的错误，可能产生的原因
;包括指令集不匹配、未对齐的数据访问、执行未定义指令等。 通过编写UsageFault_Handler函数，
;可以对Usage Fault异常进行自定义处理，以满足特定应用的需求。
UsageFault_Handler\
                PROC
                EXPORT  UsageFault_Handler         [WEAK]
                B       .
                ENDP
					
;SVC_Handler是一个处理特殊异常的函数，它通常被嵌入式系统中的操作系统或实时操作系统使用。
;在引用的代码示例中，SVC_Handler函数是用来处理特殊异常的函数。
;它通过调用相应的函数指针来处理特殊的系统调用。在给定的代码中，SVC_Handler函数通过检索
;传递给它的参数并将其作为参数传递给相应的函数指针来实现这一功能。具体来说，
;它使用栈中的寄存器r0~r3作为参数，并将返回值存储在调用者栈中的r0位置。
SVC_Handler     PROC
                EXPORT  SVC_Handler                [WEAK]
                B       .
                ENDP
					
					

;DebugMon_Handler是一个异常处理函数，是用来处理调试监视器异常的。
;当出现调试监视器相关的异常时，这个函数会被调用。在上面的引用中，
;可以看到DebugMon_Handler函数被定义，并在其中打印了一条异常信息
;"Exception: Debug Monitor." 。

;调试监视器异常通常与调试相关的功能有关，如断点调试、单步跟踪等。当出现相关异常时，
;可以通过这个函数来处理和记录异常信息，便于调试和排查问题。

;需要注意的是，DebugMon_Handler函数是针对特定的硬件平台和开发环境定义的，具体的异
;常处理逻辑可能因平台和环境的不同而有所差异。在STM32的开发中，
;它通常与CMSIS（Cortex Microcontroller Software Interface Standard）一起使用。					
					
DebugMon_Handler\
                PROC
                EXPORT  DebugMon_Handler           [WEAK]
                B       .
                ENDP
					
					
;PendSV_Handler是一个中断服务函数，也被称为可悬起的系统调用。它与SVC中断有所不同，
;SVC中断要求立即响应，而PendSV中断可以延迟响应，也就是说PendSV中断可以先被"悬起"，
;待其他重要中断执行完毕后再处理它。PendSV中断的主要作用是在需要进行任务切换时，
;如果当前正在执行一个中断，则等待该中断执行完毕后再进行任务切换，不允许中断来打断
;任务切换的过程。悬起PendSV的方法是通过向NVIC的PendSV悬起寄存器中写1来实现。

;在FreeRTOS中，PendSV_Handler是任务切换最终发生的地方。在该中断服务函数中，
;主要进行了以下几个操作：首先比较关心的是改变pxCurrentTCB，这个变量是记录当前
;正在运行的任务的指针；
:;然后调用函数vTaskSwitchContext()，它的作用是切换任务的上下文;接着调用
;taskSELECT_HIGHEST_PRIORITY_TASK()、portGET_HIGHEST_PRIORITY()和
;listGET_OWNER_OF_NEXT_ENTRY()等函数来选择最高优先级的任务，
;并将其设置为当前任务。这样就完成了任务的切换。					
PendSV_Handler  PROC
                EXPORT  PendSV_Handler             [WEAK]
                B       .
                ENDP
					
:;SysTick_Handler是一个中断服务函数，用于处理SysTick定时器中断。根据引用和引用的内容，
;SysTick_Handler函数主要执行了两个操作：调用了HAL_IncTick()函数和HAL_SYSTICK_IRQHandler()
;函数（或osSystickHandler()函数）。
:;HAL_IncTick()函数用于增加系统的滴答计数器，而HAL_SYSTICK_IRQHandler()函数或
;osSystickHandler()函数用于处理SysTick定时器的中断事件。根据引用，HAL_SYSTICK_IRQHandler()
;函数实际上是一个空函数，需要用户自己实现。
:;因此，在SysTick_Handler函数中，主要的操作就是调用HAL_IncTick()函数来增加系统的滴答计数器。					
					
SysTick_Handler PROC
                EXPORT  SysTick_Handler            [WEAK]
                B       .
                ENDP


:;STM32 Default_Handler 是 STM32 微控制器中的默认中断处理函数。当发生一个未被显式定义处
;理函数的中断时，Default_Handler 会被调用。根据引用和引用的描述，
;Default_Handler 可能是导致程序卡死的原因之一。
;:在调试过程中，如果程序卡死在 Default_Handler 处，原因可能是中断处理函数被遗漏或者中断向
;量表没有正确配置。请检查中断处理函数是否正确定义，并确保中断向量表正确配置。
Default_Handler PROC

                EXPORT  WWDG_IRQHandler            [WEAK]
                EXPORT  PVD_IRQHandler             [WEAK]
                EXPORT  TAMPER_IRQHandler          [WEAK]
                EXPORT  RTC_IRQHandler             [WEAK]
                EXPORT  FLASH_IRQHandler           [WEAK]
                EXPORT  RCC_IRQHandler             [WEAK]
                EXPORT  EXTI0_IRQHandler           [WEAK]
                EXPORT  EXTI1_IRQHandler           [WEAK]
                EXPORT  EXTI2_IRQHandler           [WEAK]
                EXPORT  EXTI3_IRQHandler           [WEAK]
                EXPORT  EXTI4_IRQHandler           [WEAK]
                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]
                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]
                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]
                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]
                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]
                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]
                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]
                EXPORT  ADC1_2_IRQHandler          [WEAK]
                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]
                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]
                EXPORT  CAN1_RX1_IRQHandler        [WEAK]
                EXPORT  CAN1_SCE_IRQHandler        [WEAK]
                EXPORT  EXTI9_5_IRQHandler         [WEAK]
                EXPORT  TIM1_BRK_IRQHandler        [WEAK]
                EXPORT  TIM1_UP_IRQHandler         [WEAK]
                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]
                EXPORT  TIM1_CC_IRQHandler         [WEAK]
                EXPORT  TIM2_IRQHandler            [WEAK]
                EXPORT  TIM3_IRQHandler            [WEAK]
                EXPORT  TIM4_IRQHandler            [WEAK]
                EXPORT  I2C1_EV_IRQHandler         [WEAK]
                EXPORT  I2C1_ER_IRQHandler         [WEAK]
                EXPORT  I2C2_EV_IRQHandler         [WEAK]
                EXPORT  I2C2_ER_IRQHandler         [WEAK]
                EXPORT  SPI1_IRQHandler            [WEAK]
                EXPORT  SPI2_IRQHandler            [WEAK]
                EXPORT  USART1_IRQHandler          [WEAK]
                EXPORT  USART2_IRQHandler          [WEAK]
                EXPORT  USART3_IRQHandler          [WEAK]
                EXPORT  EXTI15_10_IRQHandler       [WEAK]
                EXPORT  RTCAlarm_IRQHandler        [WEAK]
                EXPORT  USBWakeUp_IRQHandler       [WEAK]
                EXPORT  TIM8_BRK_IRQHandler        [WEAK]
                EXPORT  TIM8_UP_IRQHandler         [WEAK]
                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK]
                EXPORT  TIM8_CC_IRQHandler         [WEAK]
                EXPORT  ADC3_IRQHandler            [WEAK]
                EXPORT  FSMC_IRQHandler            [WEAK]
                EXPORT  SDIO_IRQHandler            [WEAK]
                EXPORT  TIM5_IRQHandler            [WEAK]
                EXPORT  SPI3_IRQHandler            [WEAK]
                EXPORT  UART4_IRQHandler           [WEAK]
                EXPORT  UART5_IRQHandler           [WEAK]
                EXPORT  TIM6_IRQHandler            [WEAK]
                EXPORT  TIM7_IRQHandler            [WEAK]
                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]
                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]
                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]
                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK]

WWDG_IRQHandler
PVD_IRQHandler
TAMPER_IRQHandler
RTC_IRQHandler
FLASH_IRQHandler
RCC_IRQHandler
EXTI0_IRQHandler
EXTI1_IRQHandler
EXTI2_IRQHandler
EXTI3_IRQHandler
EXTI4_IRQHandler
DMA1_Channel1_IRQHandler
DMA1_Channel2_IRQHandler
DMA1_Channel3_IRQHandler
DMA1_Channel4_IRQHandler
DMA1_Channel5_IRQHandler
DMA1_Channel6_IRQHandler
DMA1_Channel7_IRQHandler
ADC1_2_IRQHandler
USB_HP_CAN1_TX_IRQHandler
USB_LP_CAN1_RX0_IRQHandler
CAN1_RX1_IRQHandler
CAN1_SCE_IRQHandler
EXTI9_5_IRQHandler
TIM1_BRK_IRQHandler
TIM1_UP_IRQHandler
TIM1_TRG_COM_IRQHandler
TIM1_CC_IRQHandler
TIM2_IRQHandler
TIM3_IRQHandler
TIM4_IRQHandler
I2C1_EV_IRQHandler
I2C1_ER_IRQHandler
I2C2_EV_IRQHandler
I2C2_ER_IRQHandler
SPI1_IRQHandler
SPI2_IRQHandler
USART1_IRQHandler
USART2_IRQHandler
USART3_IRQHandler
EXTI15_10_IRQHandler
RTCAlarm_IRQHandler
USBWakeUp_IRQHandler
TIM8_BRK_IRQHandler
TIM8_UP_IRQHandler
TIM8_TRG_COM_IRQHandler
TIM8_CC_IRQHandler
ADC3_IRQHandler
FSMC_IRQHandler
SDIO_IRQHandler
TIM5_IRQHandler
SPI3_IRQHandler
UART4_IRQHandler
UART5_IRQHandler
TIM6_IRQHandler
TIM7_IRQHandler
DMA2_Channel1_IRQHandler
DMA2_Channel2_IRQHandler
DMA2_Channel3_IRQHandler
DMA2_Channel4_5_IRQHandler
                B       .

                ENDP

                ALIGN

;*******************************************************************************
; User Stack and Heap initialization
;*******************************************************************************
                 IF      :DEF:__MICROLIB
                
                 EXPORT  __initial_sp
                 EXPORT  __heap_base
                 EXPORT  __heap_limit
                
                 ELSE
                
                 IMPORT  __use_two_region_memory
                 EXPORT  __user_initial_stackheap


;在STM32中，__user_initial_stackheap是指用户自定义的堆栈和堆空间的起始地址。
;具体来说，__user_initial_stackheap是用来定义堆栈和堆空间大小的。
;在引用中，堆栈大小通过定义Stack_Size来指定，而在引用中，通过使用SPACE命令
;来分配一定大小的内存空间，其中Stack_Size被指定为0x00000400。
;最后，在引用中，通过定义__initial_sp来初始化堆栈和堆空间的起始地址。
;因此，__user_initial_stackheap表示用户定义的堆栈和堆空间的起始地址。
__user_initial_stackheap

                 LDR     R0, =  Heap_Mem
                 LDR     R1, =(Stack_Mem + Stack_Size)
                 LDR     R2, = (Heap_Mem +  Heap_Size)
                 LDR     R3, = Stack_Mem
                 BX      LR

                 ALIGN

                 ENDIF

                 END

;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ac2745a6ded1d3cb16333ffc14b32a96/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PoeAI：免费使用GPT-4的AI聊天机器人平台</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bb575c12dce8e658f163a754c4b7df35/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NRF52832外设blinky添加静态密码绑定</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>