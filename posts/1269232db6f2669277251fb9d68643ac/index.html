<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>运维，关于监控的那些事，你有必要了解一下 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="运维，关于监控的那些事，你有必要了解一下" />
<meta property="og:description" content="作者 | 乔克
来源 | 运维开发故事
监控是整个运维以及产品整个生命周期最重要的一环，它旨在事前能够及时预警发现故障，事中能够结合监控数据定位问题，事后能够提供数据用于分析问题。
一、监控的目的 监控贯穿应用的整个生命周期。即从程序设计、开发、部署、下线。其主要的服务对象有：
技术
业务
技术通过监控系统可以了解技术的环境状态，可以帮助检测、诊断、解决技术环境中的故障和问题。然而监控系统的最终目标是业务，是为了更好的支持业务运行，确保业务的持续开展。
所以监控的目的可以简单归纳如下：1、能够对系统进行7*24小时的实时监控 2、能够及时反馈系统状态 3、保证平台的稳定运行 3、保证服务的安全可靠 4、保证业务的持续运行
二、监控的模式 监控由上至下可以分为：
业务监控
应用监控
操作系统
其中业务监控主要是研发提供一些业务指标、业务数据，对其增长率、错误率等进行告警或者展示，需要提前定义规范甚至埋点。
应用程序的监控主要有探针和内省。其中探针主要是从外部探测应用程序的特征，比如监听端口是否有响应。内省主要是查看应用程序内部的内容，应用程序通过检测并返回其内部的状态，内部的组件，事务和性能等度量，它可以直接将事件、日志和指标直接发送给监控工具。
操作系统主要是监控主要组件的使用率、饱和度以及错误，比如CPU的使用率、CPU的负载等。
三、监控的方式 监控的主要方式有:
健康检查。健康检查是对应用本身健康状况的监控，检查服务是否还正常存活。
日志。日志是排查问题的主要方式，日志可以提供丰富的信息用于定位和解决问题。
调用链监控。调用链监控可以完整的呈现出一次请求的全部信息，包括服务调用链路、所耗时间等。
指标监控。指标是一些基于时间序列的离散数据点，通过聚合和计算后能反映出一些重要指标的趋势。
在上述4中监控方式中，健康检查是云平台等基础设施提供的能力，日志则一般有单独的日志中心进行日志的采集、存储、计算和查询，调用链监控一般也有独立的解决方案进行服务调用的埋点、采集、计算和查询，指标监控则是通过一些 exporter 抓取目标暴露的指标，然后对这些指标数据进行清理、聚合，我们通过聚合出来的数据进行展示、告警等。
说明：该方案主要是针对指标监控
四、监控选型 4.1、健康检查 云平台提供健康检查能力，直接在云平台中配置。
4.2、日志 成熟的开源日志解决方案是ELK。
4.3、调用链监控 调用链健康使用第三方的健康软件，常用的有 skywalking、zikpin、pinpoint、elastic APM、Cat。
其中 zikpin 和 cat 对代码有一定的侵入性，而 skywalking、pinpoint、elastic APM 是基于字节码注入技术，对代码没有侵入性，而且改动最小。
pinpoint 的 agent 仅支持 java 和 php，而 skywalking 和 elastic APM 都支持多种语言，比如 Java/Node.js/Go 等。
在云原生环境下，skywalking 和 elastic APM 更适合。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/1269232db6f2669277251fb9d68643ac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-03T17:02:39+08:00" />
<meta property="article:modified_time" content="2021-03-03T17:02:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">运维，关于监控的那些事，你有必要了解一下</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>作者 | 乔克<br> 来源 | 运维开发故事</p> 
<p>监控是整个运维以及产品整个生命周期最重要的一环，它旨在事前能够及时预警发现故障，事中能够结合监控数据定位问题，事后能够提供数据用于分析问题。</p> 
<h3>一、监控的目的</h3> 
<p>监控贯穿应用的整个生命周期。即从程序设计、开发、部署、下线。其主要的服务对象有：</p> 
<ul><li> <p>技术</p> </li><li> <p>业务</p> </li></ul> 
<p>技术通过监控系统可以了解技术的环境状态，可以帮助检测、诊断、解决技术环境中的故障和问题。然而监控系统的最终目标是业务，是为了更好的支持业务运行，确保业务的持续开展。</p> 
<p>所以监控的目的可以简单归纳如下：1、能够对系统进行7*24小时的实时监控 2、能够及时反馈系统状态 3、保证平台的稳定运行 3、保证服务的安全可靠 4、保证业务的持续运行</p> 
<h3>二、监控的模式</h3> 
<p>监控由上至下可以分为：</p> 
<ul><li> <p>业务监控</p> </li><li> <p>应用监控</p> </li><li> <p>操作系统</p> </li></ul> 
<p>其中业务监控主要是研发提供一些业务指标、业务数据，对其增长率、错误率等进行告警或者展示，需要提前定义规范甚至埋点。</p> 
<p>应用程序的监控主要有探针和内省。其中探针主要是从外部探测应用程序的特征，比如监听端口是否有响应。内省主要是查看应用程序内部的内容，应用程序通过检测并返回其内部的状态，内部的组件，事务和性能等度量，它可以直接将事件、日志和指标直接发送给监控工具。</p> 
<p>操作系统主要是监控主要组件的使用率、饱和度以及错误，比如CPU的使用率、CPU的负载等。</p> 
<h3>三、监控的方式</h3> 
<p>监控的主要方式有:</p> 
<ul><li> <p>健康检查。健康检查是对应用本身健康状况的监控，检查服务是否还正常存活。</p> </li><li> <p>日志。日志是排查问题的主要方式，日志可以提供丰富的信息用于定位和解决问题。</p> </li><li> <p>调用链监控。调用链监控可以完整的呈现出一次请求的全部信息，包括服务调用链路、所耗时间等。</p> </li><li> <p>指标监控。指标是一些基于时间序列的离散数据点，通过聚合和计算后能反映出一些重要指标的趋势。</p> </li></ul> 
<p>在上述4中监控方式中，健康检查是云平台等基础设施提供的能力，日志则一般有单独的日志中心进行日志的采集、存储、计算和查询，调用链监控一般也有独立的解决方案进行服务调用的埋点、采集、计算和查询，指标监控则是通过一些 exporter 抓取目标暴露的指标，然后对这些指标数据进行清理、聚合，我们通过聚合出来的数据进行展示、告警等。</p> 
<blockquote> 
 <p>说明：该方案主要是针对指标监控</p> 
</blockquote> 
<h3>四、监控选型</h3> 
<h4>4.1、健康检查</h4> 
<p>云平台提供健康检查能力，直接在云平台中配置。</p> 
<h4>4.2、日志</h4> 
<p>成熟的开源日志解决方案是ELK。</p> 
<h4>4.3、调用链监控</h4> 
<p>调用链健康使用第三方的健康软件，常用的有 skywalking、zikpin、pinpoint、elastic APM、Cat。</p> 
<p>其中 zikpin 和 cat 对代码有一定的侵入性，而 skywalking、pinpoint、elastic APM 是基于字节码注入技术，对代码没有侵入性，而且改动最小。</p> 
<p>pinpoint 的 agent 仅支持 java 和 php，而 skywalking 和 elastic APM 都支持多种语言，比如 Java/Node.js/Go 等。</p> 
<p>在云原生环境下，skywalking 和 elastic APM 更适合。</p> 
<p>elastic APM 直接使用 es 作为存储，可以在 kibana 上直接看应用信息，但是其关系图是需要产生一定的费用。</p> 
<p>skywalking 是国人开源的一款产品，已经毕业于 Apache 基金会，社区非常活跃，版本迭代很快，专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。</p> 
<p>pinpoint 和 skywalking 的对比可参考：</p> 
<p>http://skywalking.apache.org/zh/blog/2019-02-24-skywalking-pk-pinpoint.html</p> 
<h4>4.4、指标监控</h4> 
<p>在云原生环境、传统的监控方式并不适合，在传统环境，zabbix 无疑是首选，但是在云原生环境，Prometheus 却成为了热门，其主要原因有：</p> 
<ul><li> <p>成熟的社区支撑。Prometheus 是 CNCF 的毕业项目，有许多大厂做背书，社区庞大，是首推的云原生监控解决方案。</p> </li><li> <p>易于部署和运维。Prometheus 核心只有一个二进制文件，没有其他的第三方依赖，部署运维均十分方便。</p> </li><li> <p>采用 Pull 模型，通过 HTTP 的 Pull 方式从各个监控目标拉取监控数据。Push 模型一般通过 Agent 方式去采集信息并推送到收集器中，每个服务的 Agent 都需要配置监控数据项与监控服务端的信息，在大量服务时会加大运维难度；另外，采用Push 模型，在流量高峰期间监控服务端会同时接收到大量请求和数据，会给监控服务端造成很大压力，严重时甚至服务不可用。</p> </li><li> <p>强大的数据模型。Prometheus 采集到的监控数据均以指标的形式存在于内置的时序数据库中，除了基本的指标名称外，还支持自定义的标签。通过标签可以定义出丰富的维度，方便进行监控数据的聚合和计算。</p> </li><li> <p>强大的查询语言 PromQL。通过 PromQL 可以实现对监控数据的查询、聚合、可视化、告警。</p> </li><li> <p>完善的生态。常见的操作系统、数据库、中间件、类库、编程语言，Prometheus都提供了接入方案，并且提供了Java/Golang/Ruby/Python 等语言的客户端SDK，能够快速实现自定义的监控逻辑。</p> </li><li> <p>高性能。Prometheus 单一实例即可处理数以百计的监控指标，每秒处理数十万的数据，在数据采集和查询方面有着优异的性能表现。</p> </li></ul> 
<blockquote> 
 <p>注意：由于采集的数据有可能丢失，Prometheus 并不适合对采集数据要求 100%准确的场景。</p> 
</blockquote> 
<h3>五、Prometheus 监控系统概述</h3> 
<p>监控系统的整体框架如下：</p> 
<p><img alt="图片" src="https://images2.imgbox.com/5b/0b/BmTN5wdQ_o.png"></p> 
<ul><li> <p>Prometheus Server：用于抓取指标、存储时间序列数据</p> </li><li> <p>exporter：暴露指标让任务来抓</p> </li><li> <p>pushgateway：push 的方式将指标数据推送到该网关</p> </li><li> <p>alertmanager：处理报警的报警组件</p> </li><li> <p>adhoc：用于数据查询</p> </li></ul> 
<p>其流程很简单，Prometheus server 端可以直接接收或者通过 pushgateway 获取到数据，存储到 TSDB中，然后对数据进行规则整理，通过 Altermanager 进行报警或者通过 Grafana 等工具进行展示。</p> 
<h3>六、指标监控的对象</h3> 
<p>监控系统一般采用分层的方式划分监控对象。在我们的监控系统中，主要关注以下几种类型的监控对象：</p> 
<ul><li> <p>主机监控，主要指主机节点软、硬件资源的一些监控数据。</p> </li><li> <p>容器环境监控，主要指服务所处运行环境的一些监控数据。</p> </li><li> <p>应用服务监控，主要指服务本身的基础数据指标，提现服务自身的运行状况。</p> </li><li> <p>第三方接口监控，主要指调用其他外部服务接口的情况。</p> </li></ul> 
<p>对于应用服务和第三方接口监控，我们常用的指标包括：响应时间、请求量QPS、成功率。</p> 
<h4>6.1、主机监控</h4> 
<p>6.1.1、为什么需要主机监控</p> 
<p>主机是系统的载体，一切系统应用都运行在主机之上，如果某台或者几台主机宕机，会导致上面运行的所以应用都没办法正常提供服务，严重者导致生产事故。所以对主机的监控与预警是非常有必要的，我们可以在其出故障之前对其进行处理，避免严重的事故发生。</p> 
<p>6.1.2、如何判断资源情况</p> 
<p>主机的监控主要从一下三个方面来综合考虑其状态：</p> 
<ul><li> <p>使用率：资源忙于工作的平均时间，通常是随时间变化的百分比</p> </li><li> <p>饱和度：资源队列的长度</p> </li><li> <p>错误：资源错误事件的计数</p> </li></ul> 
<p>6.1.3、哪些资源需要监控</p> 
<p>主机的主要资源对象有：</p> 
<ul><li> <p>CPU</p> </li><li> <p>内存</p> </li><li> <p>磁盘</p> </li><li> <p>可用性</p> </li><li> <p>服务状态</p> </li><li> <p>网络</p> </li></ul> 
<p>6.1.4、如何进行监控</p> 
<p>在 Prometheus 监控方案中，主机的资源指标是通过 node-exporter 来进行采集，然后存储在 Prometheus 时序数据库里，然后可以通过 PromQL 来查询各个指标的具体情况。</p> 
<p>1、CPU</p> 
<p>CPU主要从使用率和饱和度来进行监控。</p> 
<p>（1）、使用率，指标<code>node_cpu_seconds_total</code>通常会根据CPU使用率超过多少来进行告警，比如当 CPU 使用率大于 80%，则进行告警。</p> 
<p>当然 CPU 是一个 Gauge 类型的，它的数据是会上下增减的，所以我们在判断 CPU 使用率的时候通常是一段时间内 CPU 持续高达多少的时候才进行告警，比如下面的表达式就是统计 5 分钟内 CPU 使用率大于 60% 的主机：</p> 
<pre> </pre> 
<ul><li> </li></ul> 
<pre> </pre> 
<p><code>100-(avg(irate(node_cpu_seconds_total{mode="idle"}[5m])) by(instance)* 100) &gt; 60</code></p> 
<p>CPU 指标还有用户态、内核态的指标数据，这个根据情况来进行监控。</p> 
<p>（2）、饱和度，指标<code>node_load</code>CPU的饱和度通常指的是CPU的负载情况。正常情况下CPU的整体负载不超过CPU的总数，比如2颗CPU，则负载不超过2。</p> 
<p>我们收集到的指标有1分钟、5分钟、15分钟的负载数据，在配置监控的时候选择好统计时间，一般情况下会选择5分钟的负载作为统计，如下表示5分钟的负载大于CPU的总数的2倍：</p> 
<pre> </pre> 
<ul><li> </li></ul> 
<pre> </pre> 
<p><code>node_load5 &gt; on (instance) 2 * count by(instance)(node_cpu_seconds_total{mode="idle"})</code></p> 
<p>2、内存</p> 
<p>内存主要从使用率和饱和度来进行监控。</p> 
<p><strong>（1）、使用率</strong> </p> 
<p>内存的使用率可以直观的看到整体CPU的使用情况，其计算方式使用（free + buffer + cache）/ total。指标主要有：</p> 
<ul><li> <p>node_memory_MemTotal_bytes：主机上的总内存</p> </li><li> <p>node_memory_MemFree_bytes：主机上的可用内存</p> </li><li> <p>node_memory_Buffers_bytes：缓冲缓存中的内存</p> </li><li> <p>node_memory_Cached_bytes：页面缓存中的内存</p> </li></ul> 
<p>比如下面的表达式是用于统计内存使用率大于 80%：</p> 
<pre> </pre> 
<ul><li> </li></ul> 
<pre> </pre> 
<p><code>100 - sum(node_memory_MemFree_bytes{job="node-exporter"} + node_memory_Buffers_bytes{job="node-exporter"} + node_memory_Cached_bytes{job="node-exporter"})by (instance) / sum(node_memory_MemTotal_bytes{job="node-exporter"})by(instance)*100 &gt; 80</code></p> 
<p><strong>（2）、饱和度</strong> </p> 
<p>内存的饱和度是指内存和磁盘的读写情况来监控。指标有：</p> 
<ul><li> <p>node_vmstat_pswpin：系统每秒从磁盘读到内存的字节数，单位KB</p> </li><li> <p>node_vmstat_pswpout：系统每秒从内存写到磁盘的字节数，单位KB</p> </li></ul> 
<p>3、磁盘</p> 
<p>磁盘的监控有点特殊，我们不按着 USE 的方法去测量。如果单考虑其使用率并没有多大的效果，因为 10G 剩余 20% 和 1T剩余 20% 对我们的影响是不一样的，所以我们可以监控其增长趋势以及方向。</p> 
<p>比如：根据前面 1h 的磁盘增长情况来预测在 4h 内是否会把磁盘用完。</p> 
<pre> </pre> 
<ul><li> </li></ul> 
<pre> </pre> 
<p><code>predict_linear(node_filesystem_free_bytes{job="node-exporter",mountpoint!=""}[1h], 4*3600)</code></p> 
<p>当然，如果仅仅这样预测也会产生很多垃圾告警，因为在某一小时的增长速度可能很快，这样算下来预测会在接下来的4小时内使用完，但是我们登上主机一看，才用了40%，这时候就算有告警我们也不会处理。</p> 
<p>所以我们还可以再加一个条件，比如磁盘使用率大于80%并且在接下来的4小时内会使用完。如下：</p> 
<pre> </pre> 
<ul><li> </li></ul> 
<pre> </pre> 
<p><code>(100 - (node_filesystem_avail_bytes{fstype!="",job="node-exporter"} / node_filesystem_size_bytes{fstype!="",job="node-exporter"} * 100)&gt;80) and (predict_linear(node_filesystem_free_bytes{job="node-exporter",mountpoint!="",device!="rootfs"}[1h],4 * 3600) &lt; 0)</code></p> 
<p>除此之外，我们还需要监控磁盘的IO，不论是云主机磁盘还是物理磁盘，每块盘都有其对应的 IOPS，如果某个主机的 IO 很高，也会导致其他的问题，比如系统繁忙、负载很高等情况。</p> 
<p>node-exporter 中定义了其指标，仅需要对其进行聚合，然后对聚合后的数据进行页面展示或者告警处理。其聚合公式如下：</p> 
<pre> </pre> 
<ul><li> </li></ul> 
<pre> </pre> 
<p><code>100-(avg(irate(node_disk_io_time_seconds_total[1m])) by(instance)* 100)</code></p> 
<p>4、可用性</p> 
<p>可用性是指的主机可用性，我们可以通过<code>up</code>指标来判断主机是否可用，如果其值等于0表示宕机，等于1表示存活。比如下面即可表示主机不可用：</p> 
<pre> </pre> 
<ul><li> </li></ul> 
<pre> </pre> 
<p><code>up{job="node-exporter"}==0</code></p> 
<p>5、服务状态</p> 
<p>服务状态旨在监控关键服务，比如 docker.service，ssh.service，kubelet.service 等。指标为：</p> 
<ul><li> <p>node_systemd_unit_state</p> </li></ul> 
<p>比如监听 docker.service 的服务状态为存活：</p> 
<pre> </pre> 
<ul><li> </li></ul> 
<pre> </pre> 
<p><code>node_systemd_unit_state{name="docker.service",state="active"} == 1</code></p> 
<p>监控主要服务，以便于我们能在服务出问题的第一时间收到消息进行处理。</p> 
<p>6、网络</p> 
<p>网络主要是监控其在每台主机上的出入流量，还有 TCP 连接状态。</p> 
<p>prometheus 的 node-exporter 会抓取每台主机的网卡以及其出入网卡的流量，还有每台主机的 TCP 状态，我们可以将需要的指标进行聚合，根据聚合后的指标数据再进行页面展示或者告警处理。</p> 
<p>比如统计流入的流量：</p> 
<pre> </pre> 
<ul><li> </li></ul> 
<pre> </pre> 
<p><code>((sum(rate (node_network_receive_bytes_total{device!~'tap.*|veth.*|br.*|docker.*|virbr*|lo*'}[5m])) by (instance)) / 100)</code></p> 
<p>统计流出的流量:</p> 
<pre> </pre> 
<ul><li> </li></ul> 
<pre> </pre> 
<p><code>((sum(rate (node_network_transmit_bytes_total{device!~'tap.*|veth.*|br.*|docker.*|virbr*|lo*'}[5m])) by (instance)) / 100)</code></p> 
<p>以及统计 TCP 状态为 ESTABLISHED 的数量：</p> 
<pre> </pre> 
<ul><li> </li></ul> 
<pre> </pre> 
<p><code>node_netstat_Tcp_CurrEstab</code></p> 
<p>我们可以根据每个指标做对应的监控以及告警。</p> 
<h4>6.2、容器监控</h4> 
<p>6.2.1、为什么需要容器监控</p> 
<p>在云原生时代，容器是我们应用的载体，它相当于应用的基础设施，所以对其的监控是很有必要的。我们在创建一个容器的时候往往会给其cpu和内存一个限制值，特别是内存，如果其使用达到了限制值，就会导致OOM，这时候我们就会做升级配置或查找原因处理。</p> 
<p>6.2.2、监控的指标对象主要有哪些</p> 
<p>监控对象主要有一下：</p> 
<ul><li> <p>cpu</p> </li><li> <p>memory</p> </li><li> <p>事件</p> </li></ul> 
<p>6.2.3、如何进行监控</p> 
<p>我们使用cAdvisor来获取容器指标（kubelet已经集成了这个服务）。</p> 
<p>1、CPU</p> 
<p>在容器中，就简单通过其使用率来监控其状态，我们通过其（使用量/limit）来得到其使用率。如下：</p> 
<pre> </pre> 
<ul><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li></ul> 
<pre><code>sum(</code><code>          node_namespace_pod_container:container_cpu_usage_seconds_total:sum_rate</code><code>        * on(namespace,pod)</code><code>          group_left(workload, workload_type) mixin_pod_workload</code><code>        ) by (workload, workload_type,namespace,pod)</code><code>        /sum(</code><code>          kube_pod_container_resource_limits_cpu_cores</code><code>        * on(namespace,pod)</code><code>          group_left(workload, workload_type) mixin_pod_workload</code><code>        ) by (workload, workload_type,namespace,pod) * 100 &gt; 80</code></pre> 
<p>如果 CPU 的使用率持续大于我们设定的阈值，则考虑增加 CPU 的 Limit 值。</p> 
<p>2、memory</p> 
<p>和 CPU 一样，通过其使用率来观察容器的内存是否充足。如下：</p> 
<pre> </pre> 
<ul><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li></ul> 
<pre><code>sum(</code><code>            container_memory_working_set_bytes</code><code>          * on(namespace,pod)</code><code>            group_left(workload, workload_type) mixin_pod_workload</code><code>        ) by (namespace,pod) / sum(</code><code>            kube_pod_container_resource_limits_memory_bytes</code><code>          * on(namespace,pod)</code><code>            group_left(workload, workload_type) mixin_pod_workload</code><code>        ) by (namespace,pod) * 100 / 2 &gt; 80</code></pre> 
<p>如果内存的使用率大于我们设定的阈值，则考虑是否需要增加 Pod 的内存了。</p> 
<p>3、事件</p> 
<p>这里的事件针对的是 kubernetes 的 pod 事件。在 Kubernetes 中，事件分为两种，一种是 Warning 事件，表示产生这个事件的状态转换是在非预期的状态之间产生的；另外一种是 Normal 事件，表示期望到达的状态，和目前达到的状态是一致的。</p> 
<p>我们用一个 Pod 的生命周期进行举例，当创建一个 Pod 的时候，首先 Pod 会进入Pending 的状态，等待镜像的拉取，当镜像录取完毕并通过健康检查的时候，Pod 的状态就变为 Running。此时会生成 Normal 的事件。</p> 
<p>而如果在运行中，由于 OOM 或者其他原因造成 Pod 宕掉，进入 Failed 的状态，而这种状态是非预期的，那么此时会在 Kubernetes 中产生 Warning 的事件。</p> 
<p>针对这种场景而言，如果我们能够通过监控事件的产生就可以非常及时的查看到一些容易被资源监控忽略的问题。</p> 
<p>在 kubernetes 中通过 kube-eventer 来进行事件监控，然后针对不同的事件来进行告警通知。</p> 
<h4>6.3、应用服务监控</h4> 
<p>6.3.1、为什么需要应用服务监控</p> 
<p>应用是业务的载体，也是用户最直观的体验，应用的状态与否直接关系到业务的优良以及用户的体验。如果没有对其做好一定的监控措施，可能会出现以下问题：</p> 
<ul><li> <p>无法识别或诊断故障</p> </li><li> <p>无法衡量应用程序的运行性能</p> </li><li> <p>无法衡量应用程序或组件的业务指标以及成功与否，例如跟踪销售数据或交易价值</p> </li></ul> 
<p>6.3.2、有哪些监控指标</p> 
<p>应用程序监控</p> 
<ul><li> <p>HTTP接口：URL存活、请求量、耗时、异常量</p> 
  <ul><li> <p>JVM ：GC次数、GC耗时、各个内存区域的大小、当前线程数、死锁线程数</p> </li><li> <p>线程池：活跃线程数、任务队列大小、任务执行耗时、拒绝任务数</p> </li><li> <p>连接池：总连接数、活跃连接数</p> </li></ul></li><li> <p>业务指标：视业务来定，比如PV、订单量等</p> </li></ul> 
<p>6.3.3、如何进行监控</p> 
<p>1、应用程序监控</p> 
<p>应用程序指标可以衡量应用程序的性能和状态，包括应用程序最终用户的体验，如延迟和响应时间。在这背后，我们测量了应用程序的吞吐量：请求、请求量、事务和事务时间。</p> 
<p><code>「（1）、HTTP 接口监控」</code>可以使用 prometheus 的 blackbox_exporter 来进行接口存活的监控，可以用于对 http，https，tcp，dns 以及 ICMP 协议进行探测，从而抓取数据进行监控。</p> 
<p><code>「（2）、JVM 监控」</code>通过在应用中埋点来暴露 JVM 数据，使用 Prometheus 监控采集JVM 数据，借助 Prometheus Grafana 大盘来展示 JVM 数据，并创建报警，即可实现利用 Prometheus 监控 JVM 的目的。</p> 
<p>（1）、在 pom.xml 文件中添加 Maven 依赖。</p> 
<pre> </pre> 
<ul><li> </li><li> </li><li> </li><li> </li><li> </li></ul> 
<pre><code>&lt;dependency&gt;</code><code>    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;</code><code>    &lt;artifactId&gt;simpleclient_hotspot&lt;/artifactId&gt;</code><code>    &lt;version&gt;0.6.0&lt;/version&gt;</code><code>&lt;/dependency&gt;</code></pre> 
<p>（2）、在可以执行初始化的位置添加初始化 JVM Exporter 的方法。</p> 
<pre> </pre> 
<ul><li> </li><li> </li><li> </li><li> </li></ul> 
<pre><code>@PostConstruct</code><code>    public void initJvmExporter() {<!-- --></code><code>        io.prometheus.client.hotspot.DefaultExports.initialize();</code><code>    }</code></pre> 
<p>（3）、在 /src/main/resources/application.properties 文件中配置用于 Prometheus 监控的端口（Port）和路径（Path）</p> 
<pre> </pre> 
<ul><li> </li><li> </li></ul> 
<pre><code>management.port: 8081</code><code>endpoints.prometheus.path: prometheus-metrics</code></pre> 
<p>（4）、在 /src/main/java/com/monitise/prometheus_demo/PrometheusDemoApplication.java 文件中打开 HTTP 端口</p> 
<pre> </pre> 
<ul><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li></ul> 
<pre><code>@SpringBootApplication</code><code>// sets up the prometheus endpoint /prometheus-metrics</code><code>@EnablePrometheusEndpoint</code><code>// exports the data at /metrics at a prometheus endpoint</code><code>@EnableSpringBootMetricsCollector</code><code>public class PrometheusDemoApplication {<!-- --></code><code>    public static void main(String[] args) {<!-- --></code><code>        SpringApplication.run(PrometheusDemoApplication.class, args);</code><code>    }</code><code>}</code></pre> 
<p>然后在部署应用的时候暴露接口和数据就可以进行采集了。</p> 
<p>由于应用比较多就可以通过自动发现的方式来做。我们在 service 中加上下面的 annotations，就可以自动发现了。</p> 
<pre> </pre> 
<ul><li> </li><li> </li><li> </li></ul> 
<pre><code>prometheus.io/scrape: 'true'</code><code>prometheus.io/path: '/prometheus-metrics'</code><code>prometheus.io/port: '8081'</code></pre> 
<p>2、业务指标监控</p> 
<p>业务指标是应用程序指标的更进一层，它们通常与应用程序指标同义。如果你考虑将对特定服务的请求数量作为应用程序指标进行测量，那么业务指标通常会对请求的内容执行某些操作。</p> 
<p>一个应用程序指标的示例可能是测量支付交易的延迟，相应的业务指标可能是每个支付交易的价值。业务指标可能包括新用户/客户的数量、销售数量、按价值或位置划分的销售额，或者其他任何有助于衡量业务状况的指标。</p> 
<h4>6.4、第三方接口监控</h4> 
<p>6.4.1、为什么需要第三方接口监控</p> 
<p>第三方接口的优良直接影响自身业务，所以对第三方接口的异常情况监控是非常重要的。主要是其的响应时间、存活性以及成功率。</p> 
<p>6.4.2、有哪些监控指标</p> 
<ul><li> <p>响应时间</p> </li><li> <p>存活性</p> </li><li> <p>成功率</p> </li></ul> 
<p>6.4.3、如何进行监控</p> 
<p>可以使用 prometheus 的 blackbox_exporter 来进行接口的监控。</p> 
<p>通过第三方接口监控的维度，我们可以方便地将自身服务与所使用到的第三方服务关联起来，以统一的视图展示服务用到了哪些第三方服务接口、这些第三方服务接口的响应时间和成功率是多少。</p> 
<p>当服务出现异常时，对于定位问题有很大帮助；同时，一些内部的服务可能监控报警并不全面，第三方监控也能帮助他们提升服务质量。</p> 
<h3>七、告警通知</h3> 
<p>达到什么阈值需要告警？对应的故障等级是多少？不需要处理的告警不是好告警，可见定义合理的阈值有多重要，否则只会降低运维效率或者让监控系统失去它的作用。</p> 
<p>Prometheus 允许基于 PromQL 定义报警的触发条件，Prometheus 周期性的对 PromQL 进行计算，当满足条件时就会向 Alertmanager 发送报警信息。</p> 
<p>在配置告警规则的时候，我们将按组进行分类，这样就可以对相同组下的告警进行聚合，方便配置以及查看。Alertmanager 在接收到报警后，可以对报警进行分组、抑制、静默等额外处理，然后路由到不同的接收器。</p> 
<p>Alertmanager 支持多种报警通知方式，除常用的邮件通知外，还支持钉钉、企业微信等方式，也支持通过 webhook 自定义通知方式。我们可以按轻重缓急定义不同的通知方式，这样就可以根据不同通知方式采取不同的措施。</p> 
<h3>八、故障处理流程</h3> 
<p>收到故障告警后，一定要有相应的处理流程和oncall机制，让故障及时被跟进处理。</p> 
<h4>8.1、故障等级划分</h4> 
<p>在处理故障之前，需要先清晰的认识是什么样的故障，然后再采取什么样的措施。所以我们就需要对故障等级做一个划分。例如将系统故障等级按照《信息系统安全等级保护基本要求》具体划分为四个等级，一级和二级故障为重大故障；三级和四级故障为一般性故障。</p> 
<p>8.1.1、一级故障</p> 
<p>系统发生故障，预计将已经严重影响公司生产业务系统，导致相关生产业务系统中断1小时以上，并预计24小时以内无法恢复的，具备以下一个或几个特征，既定义为一级故障。</p> 
<ol><li> <p>公司机房网络与阿里云VPC网络出现故障，导致工作人员和用户无法访问相关业务系统；</p> </li><li> <p>WEB网站和APP系统等关键服务器宕机或有其他原因导致拒绝提供服务的；</p> </li><li> <p>利用技术手段造成业务数据被修改、假冒、泄漏、窃取的信息系统安全事件；</p> </li><li> <p>由病毒造成关键业务系统不能正常提供服务。</p> </li></ol> 
<p>8.1.2、二级故障</p> 
<p>信息系统发生故障，预计将或已经严重影响公司生产业务系统，导致相关生产业务系统中断1小时以上，并预计24小时以内可以恢复的，具备以下一个或几个特征，即定义为二级故障。</p> 
<ol><li> <p>公司机房网络与阿里云VPC出现线路和设备故障；</p> </li><li> <p>WEB网站和APP系统等关键服务器宕机或有其他原因导致拒绝提供服务的；</p> </li><li> <p>12小时以内无法解决的三级故障。</p> </li></ol> 
<p>8.1.3、三级故障</p> 
<p>满足以下条件之一，即定义为三级故障。</p> 
<ol><li> <p>故障发生后，影响到信息系统的运行效率，速度变慢，但不影响业务系统访问；</p> </li><li> <p>故障发生后预计在12小时以内恢复；</p> </li><li> <p>24小时以内无法解决的四级故障</p> </li></ol> 
<p>8.1.4、四级故障</p> 
<p>满足以下条件之一，即定义为四级故障。</p> 
<ol><li> <p>故障发生后，可随时应急处理，不会影响系统的全面运行；</p> </li><li> <p>生产业务系统设备因病毒攻击等原因，造成网络数据出现偶尔掉包，但不影响系统的正常访问和运行。</p> </li></ol> 
<h4>8.2、故障处理程序</h4> 
<p>8.2.1、故障发现</p> 
<p>工作人员在发现故障或接收到故障报告后，首先要记录故障发生时间和发现时间，及发现部门，发现人及联系电话，对故障的等级进行初步判定，并报告相关人员进行处理。</p> 
<p>8.2.2、故障处理</p> 
<ol><li> <p>发生故障的系统通知到运维人员，运维人员应先询问了解设备和配置近期的变更情况，查清故障的影响范围，从而确定故障的等级和发生故障的可能位置；</p> </li><li> <p>对于一般性故障按照规定的故障升级上报要求进行上报，并在处理过程中及时向主管领导通报故障处理情况；</p> </li><li> <p>对于重大故障按照规定的故障升级上报要求进行上报，并在处理过程中及时向主管领导通报故障处理情况。</p> </li></ol> 
<p>8.2.3、故障上报</p> 
<p>根据故障等级和发生的时限，要对故障的情况进行及时的上报，并对报告人，告知人际时间内容进行记录。重大故障由故障处理组领导负责上报，一般性故障由故障处理人员负责上报。故障升级上报时限如下表所示：</p> 
<p><img alt="图片" src="https://images2.imgbox.com/77/f8/sVilh66E_o.png"></p> 
<h4>8.3、故障处理流程图</h4> 
<p><img alt="图片" src="https://images2.imgbox.com/58/ab/CuO4HbU9_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7792555ef9268a931a616032981e18a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL进阶(三)——索引优化分析(性能分析)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/34b281a65e2a5fba3daba1ea714fb7e9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">论文中如何实现公式居中标号靠右？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>