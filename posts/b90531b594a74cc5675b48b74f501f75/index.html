<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>并发编程之二——synchronized - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="并发编程之二——synchronized" />
<meta property="og:description" content="1、Java中synchronized关键字的使用 synchronized关键字主要用于对java程序对共享资源的访问控制，可以在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized还可以保证一个线程对共享资源的修改被其他线程看到，完全可以替换volatile。
synchronized关键字在Java程序中主要有以下三种应用方式：
(1) 修饰静态方法，相当于对类的class对象加锁。由于静态方法不专属于任何一个实例对象，是类的成员，当线程A访问加锁的静态方法时，线程B就只能等待，具体示例代码如下：
public class SynchronizedForClass { static int i = 0; /* * 此方法是加了synchronized关键字的静态方法 */ public static synchronized void synStatic() { i&#43;&#43;; } /* * 此方法是加了synchronized关键字的普通方法 */ public synchronized void synNoStatic() { i&#43;&#43;; } public static void main(String[] args) throws InterruptedException { // 创建2个线程t1、t2 Thread t1 = new SynClass(new SynchronizedForClass()); Thread t2 = new SynClass(new SynchronizedForClass()); // 启动线程t1、t2 t1.start(); t2.start(); // 主线程等待t1、t2执行完成 t1.join(); t2.join(); // 调用的是静态加锁的方法，因此t1和t2执行完成后，i的值是20000 System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/b90531b594a74cc5675b48b74f501f75/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-28T16:24:04+08:00" />
<meta property="article:modified_time" content="2020-11-28T16:24:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">并发编程之二——synchronized</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1、Java中synchronized关键字的使用</h2> 
<p style="text-indent:33px;">synchronized关键字主要用于对java程序对共享资源的访问控制，可以在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized还可以保证一个线程对共享资源的修改被其他线程看到，完全可以替换volatile。</p> 
<p style="text-indent:33px;">synchronized关键字在Java程序中主要有以下三种应用方式：</p> 
<p style="text-indent:33px;">(1) 修饰静态方法，相当于对类的class对象加锁。由于静态方法不专属于任何一个实例对象，是类的成员，当线程A访问加锁的静态方法时，线程B就只能等待，具体示例代码如下：</p> 
<pre><code class="language-java">public class SynchronizedForClass {

    static int i = 0;

    /*
     * 此方法是加了synchronized关键字的静态方法
     */
    public static synchronized void synStatic() {
        i++;
    }

    /*
     * 此方法是加了synchronized关键字的普通方法
     */
    public synchronized void synNoStatic() {
        i++;
    }


    public static void main(String[] args) throws InterruptedException {
        // 创建2个线程t1、t2
        Thread t1 = new SynClass(new SynchronizedForClass());
        Thread t2 = new SynClass(new SynchronizedForClass());
        // 启动线程t1、t2
        t1.start();
        t2.start();
        // 主线程等待t1、t2执行完成
        t1.join();
        t2.join();
        // 调用的是静态加锁的方法，因此t1和t2执行完成后，i的值是20000
        System.out.println(i);
    }
}

class SynClass extends Thread {
    private SynchronizedForClass synchronizedForClass;

    public SynClass(SynchronizedForClass synchronizedForClass) {
        this.synchronizedForClass = synchronizedForClass;
    }

    @Override
    public void run() {
        for (int j = 0; j &lt; 10000; j++) {
            synchronizedForClass.synStatic();
        }
    }
}</code></pre> 
<p style="text-indent:33px;">上述代码执行完结果是i=20000，这便是synchronized对静态方法加锁的作用，加锁的对象是SynchronizedForClass 类对象。线程t1和线程t2对synStatic()方法访问是互斥的，t1在执行synStatic()方法时，t2只能等待t1执行完，因为t2需要竞争SynchronizedForClass 类对象锁，但t2可以在t1执行synStatic()方法时去执行synNoStatic()方法，因为两个方法执行时加锁的对象不同，但是对共享资源i的执行结果就不会再是绝对的i=20000了，而是10000&lt;i&lt;=20000。代码如下：</p> 
<pre><code class="language-java">public class SynchronizedForClass {

    static int i = 0;

    /*
     * 此方法是加了synchronized关键字的静态方法
     */
    public static synchronized void synStatic(){
        i++;
    }

    /*
     * 此方法是加了synchronized关键字的普通方法
     */
    public synchronized void synNoStatic(){
        i++;
    }

 
    public static void main(String[] args) throws InterruptedException {
        // 创建2个线程t1、t2
        Thread t1 = new SynClass(new SynchronizedForClass());
        Thread t2 = new SynClass(new SynchronizedForClass());
        // 启动线程t1、t2
        t1.start();
        t2.start();
        // 主线程等待t1、t2执行完成
        t1.join();
        t2.join();
        // i的值不固定
        System.out.println(i);
    }
}

class SynClass extends Thread {
    private SynchronizedForClass synchronizedForClass;

    public SynClass(SynchronizedForClass synchronizedForClass) {
        this.synchronizedForClass = synchronizedForClass;
    }

    @Override
    public void run() {
        for (int j = 0; j &lt; 10000; j++) {
            synchronizedForClass.synNoStatic();
        }
    }
}
</code></pre> 
<p style="text-indent:33px;">上述代码t1和t2加锁的对象变了，由原来的共享一个SynchronizedForClass 类对象锁，变成了分别拥有各自的SynchronizedForClass 类实例对象锁，因此对共享资源的操作就不再是互斥的，线程安全就无法保证了。</p> 
<p style="text-indent:33px;">(2) 修饰普通实例方法，相当于对类的实例对象加锁，与类的class对象锁属于不同的锁。</p> 
<p style="text-indent:33px;">(3) 修饰代码块，对指定对象加锁，进入同步代码块前需要获得指定对象的锁。</p> 
<pre><code class="language-java">Object obj = new Object();
synchronized (obj){
	i++;
}</code></pre> 
<p style="text-indent:33px;">同步代码块加锁方式可以减小锁的粒度，对于方法体比较大，且方法体内有比较耗时的代码，耗时的代码与共享资源操作无关时，我们可以使用同步代码块单独对共享资源的操作加锁，从而提升代码执行效率。</p> 
<p style="text-indent:33px;">同步代码块加锁的方式可以替换对普通实例方法加锁和对静态方法加锁，具体代码为：</p> 
<pre><code class="language-java">// 使用同步代码块替换对普通实例方法加锁
public void function1(){
    synchronized(this){
        //执行同步操作
    }
}


// 使用同步代码块替换对静态方法加锁
public void function1(){
    synchronized(Instance.class){
        //执行同步操作
    }
}</code></pre> 
<h2>2、对象头的信息分析</h2> 
<p style="text-indent:33px;">关于对象头的分析可具体参考：《Java对象头详解》<a href="https://www.jianshu.com/p/3d38cba67f8b" rel="nofollow">https://www.jianshu.com/p/3d38cba67f8b</a>这篇博客。</p> 
<p style="text-indent:33px;"><span style="color:#333333;">java的对象头在对象的不同状态下会有不同的表现形式，主要有三种状态，无锁状态、加锁状态、</span><span style="color:#333333;">gc</span><span style="color:#333333;">标记状态。那么我们可以理解</span><span style="color:#333333;">java当中的取锁其实可以理解是给对象上锁，也就是改变对象头的状态，如果上锁成功则进入同步代码块。</span></p> 
<h2>3、synchronized原理</h2> 
<p style="text-indent:33px;"><span style="color:#000000;">Synchronized </span><span style="color:#000000;">在 </span><span style="color:#000000;">JVM </span><span style="color:#000000;">里的实现都是基于进入和退出 Monitor 对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter </span><span style="color:#000000;">和 </span><span style="color:#000000;">MonitorExit 指令来实现。</span></p> 
<p style="text-indent:33px;"><span style="color:#000000;">对同步块，</span><span style="color:#000000;">MonitorEnter 指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象 </span><span style="color:#000000;">Monitor 的所有权，即尝试获得该对象的锁，而monitorExit 指令则插入在方法结束处和异常处，JVM </span><span style="color:#000000;">保证每个 </span><span style="color:#000000;">MonitorEnter 必须有对应的 </span><span style="color:#000000;">MonitorExit</span><span style="color:#000000;">。 </span></p> 
<p style="text-indent:33px;"><span style="color:#000000;">对同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter </span><span style="color:#000000;">和 </span><span style="color:#000000;">monitorexit 来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED 标示符。JVM 就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 </span><span style="color:#000000;">ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取 </span><span style="color:#000000;">monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor</span><span style="color:#000000;">。在方法执行期间，其他任何线程都无法再获得同一个 </span><span style="color:#000000;">monitor </span><span style="color:#000000;">对象。</span></p> 
<h2>4、偏向锁膨胀过程</h2> 
<h3>4.1 锁的状态</h3> 
<p style="text-indent:33px;"><span style="color:#000000;">通过对象头的分析，我们可知锁一共有四种状态，<strong>无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态</strong>，它会随着竞争情况逐渐升级。一般锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。</span></p> 
<p style="text-indent:33px;"><span style="color:#333333;">1、什么叫做无锁？无锁分为两种情况 ①：无锁可偏向（</span><span style="color:#333333;">101</span><span style="color:#333333;">）②：无锁不可偏向（</span><span style="color:#333333;"><strong>0</strong></span><span style="color:#333333;">01）在无锁不可偏向的情况下第一个</span><span style="color:#333333;">0</span><span style="color:#333333;">标识偏向标识不可偏向；但是还有一种情况也是</span><span style="color:#333333;">101这种情况是有锁而且是已经偏向了线程；所以看一把锁（对象）是否有锁不能单纯的看后三位；比如后三位等于</span><span style="color:#333333;">101；他可能是有锁；也有可能是无锁，需要看对象头中的线程id，确定已经偏向了哪个线程；但是后三位如果是</span><span style="color:#333333;">001</span><span style="color:#333333;">那么肯定是无锁；下文中说的无锁基本指的是</span><span style="color:#333333;">001</span><span style="color:#333333;">； </span></p> 
<p style="text-indent:33px;"><span style="color:#333333;">2</span><span style="color:#333333;">、轻量锁：后两位是</span><span style="color:#333333;">00(</span><span style="color:#333333;">一共</span><span style="color:#333333;">64</span><span style="color:#333333;">位前面</span><span style="color:#333333;">62</span><span style="color:#333333;">位都是一个指针；所以轻量锁只需要看后两位</span><span style="color:#333333;">00)</span><span style="color:#333333;">； </span></p> 
<p style="text-indent:33px;"><span style="color:#333333;">3</span><span style="color:#333333;">、重量锁：后两位是</span><span style="color:#333333;">10(</span><span style="color:#333333;">一共</span><span style="color:#333333;">64</span><span style="color:#333333;">位前面</span><span style="color:#333333;">62</span><span style="color:#333333;">位都是一个指针；所以重量锁只需要看后两位</span><span style="color:#333333;">10)</span><span style="color:#333333;">；</span></p> 
<p style="text-indent:33px;"><span style="color:#333333;">4</span><span style="color:#333333;">、比如一个对象锁obj</span><span style="color:#333333;">（在没有加锁的情况下；偏向没有延迟的情况下），</span><span style="color:#333333;">new出来的时候是无锁可偏向也就是后三位是</span><span style="color:#333333;">101</span><span style="color:#333333;">；对象头的结构如下图；其中</span><span style="color:#333333;">bl=1</span><span style="color:#333333;">；</span><span style="color:#333333;">lock=01 </span></p> 
<p style="text-indent:33px;"><img alt="" height="66" src="https://images2.imgbox.com/5c/45/XGSvykn4_o.png" width="867"></p> 
<p style="text-indent:33px;"><span style="color:#333333;">5</span><span style="color:#333333;">、假设现在的场景是</span><span style="color:#333333;">t1线程使用synchronized来对obj加锁，</span><span style="color:#333333;">那么它必然是一个偏向锁；后三位同样还是</span><span style="color:#333333;">101；但是前面的值改了；存了线程</span><span style="color:#333333;">id</span><span style="color:#333333;">和</span><span style="color:#333333;">epoch</span><span style="color:#333333;">等等信息；如下图；其中的</span><span style="color:#333333;">bl=1</span><span style="color:#333333;">；</span><span style="color:#333333;">lock=01</span><span style="color:#333333;">（注意和</span><span style="color:#333333;">3不同的是前面的东西改了；后三位还是</span><span style="color:#333333;">101</span><span style="color:#333333;">）</span></p> 
<p style="text-indent:33px;"><img alt="" height="59" src="https://images2.imgbox.com/ac/d0/VPhiiHK0_o.png" width="889"></p> 
<p style="text-indent:33px;"><span style="color:#333333;">6</span><span style="color:#333333;">、然后</span><span style="color:#333333;">t1</span><span style="color:#333333;">把锁释放了（现在的场景是只有</span><span style="color:#333333;">t1</span><span style="color:#333333;">来加锁）；由于锁是偏向锁；故而就算释放了还是</span><span style="color:#333333;">101；对象头还是和</span><span style="color:#333333;">4一样；</span></p> 
<h3>4.2 偏向锁加锁</h3> 
<p style="text-indent:33px;">1、线程t1使用synchronized对obj对象加锁，<span style="color:#333333;">会走匿名偏向锁的流程；产生一个偏向自己的</span><span style="color:#333333;">mark</span><span style="color:#333333;">；然后cas替换对象头；成功则加锁；失败则撤销偏向并且升级轻量；</span></p> 
<p style="text-indent:33px;"><img alt="" height="484" src="https://images2.imgbox.com/c3/4f/NMf2tK3K_o.png" width="740"></p> 
<p style="text-indent:33px;"><span style="color:#333333;">2、现在</span><span style="color:#333333;">t1</span><span style="color:#333333;">线程执行完了，怎么释放的锁呢？就是从栈当中把那个锁记录</span><span style="color:#333333;">lr给释放，所以偏向锁的锁释放也是很简单的。</span></p> 
<p style="text-indent:33px;"><span style="color:#333333;">3、t1</span><span style="color:#333333;">把锁释放之后，</span><span style="color:#333333;">t1又来了加锁。首先会有一个锁对象，比如 obj，然后会在当前线程栈当中创建一个lockrecord(以下简称lr)，然后代码接着往下执行，判断当前线程是否自己，是否过期，如果不过期那么线程直接拿到锁，执行同步代码块，什么都不用改也不用</span><span style="color:#333333;">CAS，性能是最好的，这就是最简单的偏向锁获取过程。偏向锁第二次之后获取锁的流程与第二次相同。</span></p> 
<p style="text-indent:33px;"><img alt="" height="440" src="https://images2.imgbox.com/14/a3/iiJnZP8Q_o.png" width="846"></p> 
<h3>4.3 偏向锁升级为轻量级锁</h3> 
<p style="text-indent:33px;"><span style="color:#333333;">1、假设一种场景就是现在</span><span style="color:#333333;">t1</span><span style="color:#333333;">释放锁了（偏向锁），然后线程</span><span style="color:#333333;">t2</span><span style="color:#333333;">来了，根据我们的经验可知</span><span style="color:#333333;">t2来加锁需要升级成为轻量锁（也有不升级的情况，这时候要考虑线程id复用的情况），这里需要注意</span><span style="color:#333333;">t2升级的时候需要做偏向撤销，t2加锁成功后，对象的markword中锁状态就变成了00。</span></p> 
<p style="text-indent:33px;"><img alt="" height="393" src="https://images2.imgbox.com/4a/e2/1YStVOGz_o.png" width="870"></p> 
<p style="text-indent:33px;"><span style="color:#333333;">2、线程t2</span><span style="color:#333333;">执行完后，</span><span style="color:#333333;">把锁记录释放并且恢复锁对象里面的</span><span style="color:#333333;">markword，</span><span style="color:#333333;">t2</span><span style="color:#333333;">执行完同步块后的内存如下图，轻量锁撤销的过程需要将锁的状态重置为无锁状态，因此可以认为轻量锁加锁解锁过程比偏向锁还是性能会差一些。</span></p> 
<p style="text-indent:33px;"><img alt="" height="396" src="https://images2.imgbox.com/32/ae/53hR1uaA_o.png" width="819"></p> 
<p style="text-indent:33px;">3、假如<span style="color:#333333;">现在</span><span style="color:#333333;">t2</span><span style="color:#333333;">已经将轻量锁释放了，这个时候线程</span><span style="color:#333333;">t3</span><span style="color:#333333;">来了，那么</span><span style="color:#333333;">t3首先生成一个无锁的</span><span style="color:#333333;">markword </span><span style="color:#333333;">也就是</span><span style="color:#333333;">001</span><span style="color:#333333;">；内存如下图</span></p> 
<p style="text-indent:33px;"><img alt="" height="455" src="https://images2.imgbox.com/01/84/NpsA0eg3_o.png" width="828"></p> 
<p style="text-indent:33px;">4、<span style="color:#333333;">然后把锁记录里面的</span><span style="color:#333333;">displaced word</span><span style="color:#333333;">设置成为这个无锁的红色箭头表示的；内存如下图</span></p> 
<p style="text-indent:33px;"><img alt="" height="418" src="https://images2.imgbox.com/6c/16/AmZa4WLW_o.png" width="765"></p> 
<p style="text-indent:33px;"><span style="color:#333333;">5、接着</span><span style="color:#333333;">CAS </span><span style="color:#333333;">判断当前对象头当中的</span><span style="color:#333333;">markword </span><span style="color:#333333;">是不是和</span><span style="color:#333333;">t3</span><span style="color:#333333;">在</span><span style="color:#333333;">CPU</span><span style="color:#333333;">内存当中产生的</span><span style="color:#333333;">markword相等，如果相等则把对象头当中的</span><span style="color:#333333;">markword</span><span style="color:#333333;">修改成为一根指针指向锁记录，然后再把对象头当中的</span><span style="color:#333333;">markword的后两位改成</span><span style="color:#333333;">00</span><span style="color:#333333;">。内存如下图</span></p> 
<p style="text-indent:33px;"><img alt="" height="443" src="https://images2.imgbox.com/bf/9e/DsmPMyJP_o.png" width="791"></p> 
<h3>4.4 轻量级锁升级为重量级锁</h3> 
<p style="text-indent:33px;"><span style="color:#333333;">如果t3在加锁的过程中</span><span style="color:#333333;">cas</span><span style="color:#333333;">失败，就是另外一种场景了。假如线程</span><span style="color:#333333;">t4</span><span style="color:#333333;">在线程</span><span style="color:#333333;">t3</span><span style="color:#333333;">还没有执行</span><span style="color:#333333;">cas的时候，t4已经把锁持有了改成了</span><span style="color:#333333;">00</span><span style="color:#333333;">（把</span><span style="color:#333333;">t3的事情做完了），由于</span><span style="color:#333333;">t3</span><span style="color:#333333;">产生的是一个无锁的</span><span style="color:#333333;">001</span><span style="color:#333333;">，而对象头现在被</span><span style="color:#333333;">t4改成了轻量（</span><span style="color:#333333;">000</span><span style="color:#333333;">），那么t3 就会cas</span><span style="color:#333333;">失败，因为</span><span style="color:#333333;">cas</span><span style="color:#333333;">是判断当前对象头当中的</span><span style="color:#333333;">markword 是不是和t3</span><span style="color:#333333;">在</span><span style="color:#333333;">CPU</span><span style="color:#333333;">内存当中产生的markword相等。当t3线程cas失败一定次数后，就会升级为重量级锁。</span></p> 
<h3>4.5 批量重偏向</h3> 
<p style="text-indent:33px;"><span style="color:#333333;">如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程</span><span style="color:#333333;"> T1 </span><span style="color:#333333;">的对象仍有机会重新偏向</span><span style="color:#333333;"> T2，重偏向会重置对象的</span><span style="color:#333333;"> Thread ID</span><span style="color:#333333;">，当撤销偏向锁阈值超过</span><span style="color:#333333;"> 20 </span><span style="color:#333333;">次后，</span><span style="color:#333333;">jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至</span><span style="color:#333333;">T2。</span></p> 
<pre><code class="language-java">@Slf4j
public class TestInflate {
    static Thread t1;
    static Thread t2;
    static int loopFlag = 20;

    public static void main(String[] args) throws InterruptedException {
        List&lt;A&gt; list = new ArrayList&lt;&gt;();
        t1 = new Thread() {
            @Override
            public void run() {
                for (int i = 0; i &lt; loopFlag; i++) {
                    A a = new A();
                    list.add(a);
                    synchronized (a) {
                        log.debug(i + " " + ClassLayout.parseInstance(a).toPrintableTest(a));
                    }
                }
                log.debug("============t1 都是偏向锁============="); 
                //防止竞争 执行完后叫醒t2
                LockSupport.unpark(t2);
            }
        };
        
        t2 = new Thread() {
            @Override
            public void run() {
                //防止竞争 先睡眠t2
                LockSupport.park();
                for (int i = 0; i &lt; 30; i++) {
                    A a = list.get(i);
                    //因为从list当中拿出都是偏向t1
                    log.debug("101首先before " + i + " " + ClassLayout.parseInstance(a).toPrintableTest(a));
                    synchronized (a) {
                        //前20撤销偏向t1；然后升级轻量指向t2线程栈当中的锁记录 //后面的发送批量偏向t2
                        log.debug("前20都是000 ing " + i + " " + ClassLayout.parseInstance(a).toPrintableTest(a));
                    }
                    //因为前20是轻量，释放之后为无锁不可偏向
                    // 但是后面的是偏向t2 释放之后依然是偏向t2
                    log.debug("前20都是001 after " + i + " " + ClassLayout.parseInstance(a).toPrintableTest(a));
                }
                log.debug("======t2 执行完后 newA=====================================");
                //默认的A的对象应该是101
                log.debug("新产生的对象" + ClassLayout.parseInstance(new A()).toPrintableTest(new A()));
            }
        };
        t1.start();
        t2.start();
    }
}

class A {
    boolean f;
    byte[] aByte = new byte[1024];
}</code></pre> 
<h3>4.6 批量撤销</h3> 
<p style="text-indent:33px;"><span style="color:#333333;">当一个偏向锁如果撤销次数到达</span><span style="color:#333333;">40</span><span style="color:#333333;">的时候就认为这个对象设计的有问题，那么</span><span style="color:#333333;">JVM会把这个对象所对应的类所有的对象都撤销偏向锁，并且新实例化的对象也是不可偏向的。</span></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/024a54595a6cd5bc0f56582755d766b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">md模板练习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9bc0149e8e4c82aa1af598b3125c41eb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">软件项目试运行报告_EPC模式下，如何做好设计全过程管理？工程总承包项目设计变更...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>