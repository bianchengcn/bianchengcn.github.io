<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>23种设计模式都适用于哪些场景？ - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="23种设计模式都适用于哪些场景？" />
<meta property="og:description" content="根据对设计模式的学习，总结出各类设计模式的使用场景，了解哪些场景下适合使用哪种设计模式来解决该场景的问题，这样才能学而致用，仅仅了解设计模式但不能实践那学了又有什么用呢？下面来看看各种设计模式的使用场景（个人理仅供参考）
一、创建模式
1.工厂方法：一个工厂通过方法创建多个产品
2.抽象工厂方法：多个工厂创建多个产品族
3.建造者模式：分解构建步骤，分步构建
4.原型模式：一个对象需要多次修改部分值，利用克隆实现
5.单例模式：只要一个实例，减少系统开销
二、结构模式
6.适配器模式：重构时，不修改已有模块，增加适配器来协调2个模块工作
7.桥接模式：开发时，jdbc,需要增加桥对象，可切换对接对象，实现不同桥功能
8.组合模式：开发时，组织机构，文档结构
9.装饰器模式：重构时，不修改已有模块，对已有模块功能进行扩展
10.外观模式：开发重构
11.享元模式：开发时，创建对象池，共享对象，减少系统开销
12.代理模式：重构时，代理目标对象执行，主要是控制目标对象方式是否执行
三、行为模式
13.责任链模式：审批流
14.命令模式：浏览器的请求方式，封装请求，分离请求者与接收者
15.解释器模式：表达式解析
16.迭代器模式：迭代器
17.备忘录模式：ghost，保存当前对象状态，用于恢复
18.中介者模式：QQ，多个构件间通信的枢纽
19.观察者模式：消息通知，广播机制，通过注册接收者，观察者发消息给多个接收者
20.状态模式：针对对象切换，将状态封装成对象，通过切换状态来用不同状态对象实现相同方法。
21.策略模式：针对方法切换，对某个方法进行切换，实现不同的实现方式。
22.模板方法模式：sitmesh，tiles,freemarker就是类似装饰模式，只不过如同模板一般，只需要关注变动的地方即可
23.访问者模式：利用多态特性
应用场景总结
设计模式是一种在软件设计中用于解决常见问题的方法。它们提供了一组可重用的设计，可以被用来解决软件设计中的各种问题。下面是23种常见的设计模式，以及它们的适用场景：
🍊1️⃣工厂模式：在这种模式中，一个类用于创建另一个类的实例。这种模式适用于在不知道具体实现细节的情况下创建对象的场景。
🍊2️⃣抽象工厂模式：这种模式提供了一种方法来创建相关或依赖对象的家族，而不需要指定它们的具体类。它适用于需要创建多个不同类型的对象的场景。
🍊3️⃣单例模式：这种模式确保某个类只有一个实例，并提供一个全局访问点来访问它。这种模式适用于需要控制实例数量的场景。
🍊4️⃣建造者模式：这种模式允许将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。它适用于需要生成复杂对象的场景。
🍊5️⃣原型模式：这种模式是通过复制一个现有对象来生成新对象的。它适用于需要快速创建大量同类对象的场景。
🍋6️⃣代理模式：这种模式为另一个对象提供了一个替身或占位符，以便控制对这个对象的访问。它适用于需要在访问某个对象时增加额外控制的场景。
🍋7️⃣适配器模式：这种模式允许将一个类的接口转换成另一个接口，以便于不兼容的类可以一起工作。它适用于需要让两个不兼容的类一起工作的场景。
🍋8️⃣桥接模式：这种模式将抽象部分和实现部分分离，以便它们可以独立变化。它适用于需要将一个类的抽象部分和实现部分独立改变的场景。
🍋9️⃣组合模式：这种模式允许将对象组成树形结构来表现“整体/部分”层次结构。它适用于需要表示树形结构的场景。
🍋1️⃣0️⃣装饰模式：这种模式允许在不改变现有对象的情况下动态地给它们添加新的职责。它适用于需要动态地为对象添加新职责的场景。
🍋1️⃣1️⃣外观模式：这种模式提供了一个统一的接口，用来访问子系统中的一群接口。它适用于需要为一个复杂的子系统提供一个简单的接口的场景。
🍋1️⃣2️⃣享元模式：这种模式允许共享对象，以便最大限度地减少内存占用。它适用于需要在多个地方共享大量细粒度对象的场景。
🍏1️⃣3️⃣策略模式：这种模式定义了一组算法，并将它们封装起来，使它们可以相互替换。它适用于需要在不同情况下使用不同算法的场景。
🍏1️⃣4️⃣模板方法模式：这种模式定义了一个操作中的算法骨架，而将一些步骤延迟到子类中。它适用于需要在不改变算法结构的情况下重定义算法中的某些步骤的场景。
🍏1️⃣5️⃣观察者模式：这种模式定义了对象之间的一对多依赖，以便当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。它适用于需要在对象之间松散耦合的场景。
🍏1️⃣6️⃣迭代器模式：这种模式提供了一种方法来访问一个容器对象中各个元素，而又不暴露该对象的内部细节。它适用于需要为容器对象提供多种遍历方式的场景。
🍏1️⃣7️⃣中介者模式：这种模式用一个中介对象来封装一系列的对象交互，使各对象不需要显式地相互引用，从而使耦合松散，而且可以独立地改变它们之间的交互。它适用于需要在多个对象之间松散耦合的场景。
🍏1️⃣8️⃣解释器模式：这种模式定义了一个语言的文法，并且建立一个解释器来解释该语言中的句子。它适用于需要定义一个语言并为该语言实现一个解释器的场景。
🍏1️⃣9️⃣状态模式：这种模式允许一个对象在其内部状态改变时改变它的行为。它适用于需要根据对象的状态来改变它的行为的场景。
🍏2️⃣0️⃣访问者模式：这种模式把作用于某个对象结构中各元素的操作分离出来封装成独立的类，使其在不改变各元素的类的前提下可以添加作用于这些元素的新操作。它适用于需要在不改变各元素的类的前提下定义对这些元素的新操作的场景。
🍏2️⃣1️⃣命令模式：这种模式将一个请求封装为一个对象，以便使用不同的请求、队列或日志来参数化其他对象。它适用于需要支持命令的撤销和恢复、延迟调用或日志操作的场景。
🍏2️⃣2️⃣责任链模式：这种模式为请求创建了一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，它会把相同的请求传给下一个接收者，依此类推。它适用于需要在多个对象之间松散耦合的场景，并且希望在不明确指定接收者的情况下，向多个对象中的一个提交一个请求的场景。
🍏2️⃣3️⃣备忘录模式：这种模式提供了一种方法来在不破坏封装性的情况下获取一个对象的内部状态，并在需要的时候将对象恢复到先前的状态。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/40fcebeeabf52e08572ca3243c5337cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-15T16:47:22+08:00" />
<meta property="article:modified_time" content="2024-01-15T16:47:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">23种设计模式都适用于哪些场景？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>根据对设计模式的学习，总结出各类设计模式的使用场景，了解哪些场景下适合使用哪种设计模式来解决该场景的问题，这样才能学而致用，仅仅了解设计模式但不能实践那学了又有什么用呢？下面来看看各种设计模式的使用场景（个人理仅供参考）</p> 
<p><strong>一、创建模式</strong><br> 1.工厂方法：一个工厂通过方法创建多个产品<br> 2.抽象工厂方法：多个工厂创建多个产品族<br> 3.建造者模式：分解构建步骤，分步构建<br> 4.原型模式：一个对象需要多次修改部分值，利用克隆实现<br> 5.单例模式：只要一个实例，减少系统开销</p> 
<p><strong>二、结构模式</strong><br> 6.适配器模式：重构时，不修改已有模块，增加适配器来协调2个模块工作<br> 7.桥接模式：开发时，jdbc,需要增加桥对象，可切换对接对象，实现不同桥功能<br> 8.组合模式：开发时，组织机构，文档结构<br> 9.装饰器模式：重构时，不修改已有模块，对已有模块功能进行扩展<br> 10.外观模式：开发重构<br> 11.享元模式：开发时，创建对象池，共享对象，减少系统开销<br> 12.代理模式：重构时，代理目标对象执行，主要是控制目标对象方式是否执行</p> 
<p><strong>三、行为模式</strong><br> 13.责任链模式：审批流<br> 14.命令模式：浏览器的请求方式，封装请求，分离请求者与接收者<br> 15.解释器模式：表达式解析<br> 16.迭代器模式：迭代器<br> 17.备忘录模式：ghost，保存当前对象状态，用于恢复<br> 18.中介者模式：QQ，多个构件间通信的枢纽<br> 19.观察者模式：消息通知，广播机制，通过注册接收者，观察者发消息给多个接收者<br> 20.状态模式：针对对象切换，将状态封装成对象，通过切换状态来用不同状态对象实现相同方法。<br> 21.策略模式：针对方法切换，对某个方法进行切换，实现不同的实现方式。<br> 22.模板方法模式：sitmesh，tiles,freemarker就是类似装饰模式，只不过如同模板一般，只需要关注变动的地方即可<br> 23.访问者模式：利用多态特性</p> 
<p></p> 
<blockquote> 
 <p>应用场景总结<br> 设计模式是一种在软件设计中用于解决常见问题的方法。它们提供了一组可重用的设计，可以被用来解决软件设计中的各种问题。下面是23种常见的设计模式，以及它们的适用场景：</p> 
 <p>🍊1️⃣工厂模式：在这种模式中，一个类用于创建另一个类的实例。这种模式适用于在不知道具体实现细节的情况下创建对象的场景。</p> 
 <p>🍊2️⃣抽象工厂模式：这种模式提供了一种方法来创建相关或依赖对象的家族，而不需要指定它们的具体类。它适用于需要创建多个不同类型的对象的场景。</p> 
 <p>🍊3️⃣单例模式：这种模式确保某个类只有一个实例，并提供一个全局访问点来访问它。这种模式适用于需要控制实例数量的场景。</p> 
 <p>🍊4️⃣建造者模式：这种模式允许将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。它适用于需要生成复杂对象的场景。</p> 
 <p>🍊5️⃣原型模式：这种模式是通过复制一个现有对象来生成新对象的。它适用于需要快速创建大量同类对象的场景。</p> 
 <p>🍋6️⃣代理模式：这种模式为另一个对象提供了一个替身或占位符，以便控制对这个对象的访问。它适用于需要在访问某个对象时增加额外控制的场景。</p> 
 <p>🍋7️⃣适配器模式：这种模式允许将一个类的接口转换成另一个接口，以便于不兼容的类可以一起工作。它适用于需要让两个不兼容的类一起工作的场景。</p> 
 <p>🍋8️⃣桥接模式：这种模式将抽象部分和实现部分分离，以便它们可以独立变化。它适用于需要将一个类的抽象部分和实现部分独立改变的场景。</p> 
 <p>🍋9️⃣组合模式：这种模式允许将对象组成树形结构来表现“整体/部分”层次结构。它适用于需要表示树形结构的场景。</p> 
 <p>🍋1️⃣0️⃣装饰模式：这种模式允许在不改变现有对象的情况下动态地给它们添加新的职责。它适用于需要动态地为对象添加新职责的场景。</p> 
 <p>🍋1️⃣1️⃣外观模式：这种模式提供了一个统一的接口，用来访问子系统中的一群接口。它适用于需要为一个复杂的子系统提供一个简单的接口的场景。</p> 
 <p>🍋1️⃣2️⃣享元模式：这种模式允许共享对象，以便最大限度地减少内存占用。它适用于需要在多个地方共享大量细粒度对象的场景。</p> 
 <p>🍏1️⃣3️⃣策略模式：这种模式定义了一组算法，并将它们封装起来，使它们可以相互替换。它适用于需要在不同情况下使用不同算法的场景。</p> 
 <p>🍏1️⃣4️⃣模板方法模式：这种模式定义了一个操作中的算法骨架，而将一些步骤延迟到子类中。它适用于需要在不改变算法结构的情况下重定义算法中的某些步骤的场景。</p> 
 <p>🍏1️⃣5️⃣观察者模式：这种模式定义了对象之间的一对多依赖，以便当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。它适用于需要在对象之间松散耦合的场景。</p> 
 <p>🍏1️⃣6️⃣迭代器模式：这种模式提供了一种方法来访问一个容器对象中各个元素，而又不暴露该对象的内部细节。它适用于需要为容器对象提供多种遍历方式的场景。</p> 
 <p>🍏1️⃣7️⃣中介者模式：这种模式用一个中介对象来封装一系列的对象交互，使各对象不需要显式地相互引用，从而使耦合松散，而且可以独立地改变它们之间的交互。它适用于需要在多个对象之间松散耦合的场景。</p> 
 <p>🍏1️⃣8️⃣解释器模式：这种模式定义了一个语言的文法，并且建立一个解释器来解释该语言中的句子。它适用于需要定义一个语言并为该语言实现一个解释器的场景。</p> 
 <p>🍏1️⃣9️⃣状态模式：这种模式允许一个对象在其内部状态改变时改变它的行为。它适用于需要根据对象的状态来改变它的行为的场景。</p> 
 <p>🍏2️⃣0️⃣访问者模式：这种模式把作用于某个对象结构中各元素的操作分离出来封装成独立的类，使其在不改变各元素的类的前提下可以添加作用于这些元素的新操作。它适用于需要在不改变各元素的类的前提下定义对这些元素的新操作的场景。</p> 
 <p>🍏2️⃣1️⃣命令模式：这种模式将一个请求封装为一个对象，以便使用不同的请求、队列或日志来参数化其他对象。它适用于需要支持命令的撤销和恢复、延迟调用或日志操作的场景。</p> 
 <p>🍏2️⃣2️⃣责任链模式：这种模式为请求创建了一个接收者对象的链，每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，它会把相同的请求传给下一个接收者，依此类推。它适用于需要在多个对象之间松散耦合的场景，并且希望在不明确指定接收者的情况下，向多个对象中的一个提交一个请求的场景。</p> 
 <p>🍏2️⃣3️⃣备忘录模式：这种模式提供了一种方法来在不破坏封装性的情况下获取一个对象的内部状态，并在需要的时候将对象恢复到先前的状态。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01826f3ea6d8bab50bc841526133bced/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue2实现自定义主题webpack-theme-color-replacer</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/986089ef0b119c5fb5302199287cff59/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">跟着cherno手搓游戏引擎【3】事件系统和预编译头文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>