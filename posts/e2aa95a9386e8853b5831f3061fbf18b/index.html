<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>霍夫曼编码（C&#43;&#43; 优先队列） - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="霍夫曼编码（C&#43;&#43; 优先队列）" />
<meta property="og:description" content="霍夫曼编码 一般采用前缀编码 -- -- 对字符集进行编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀，这种编码称为前缀(编)码。
算法思想: 构造哈夫曼树非常简单，将所有的节点放到一个队列中，用一个节点替换两个频率最低的节点，新节点的频率就是这两个节点的频率之和。这样，
新节点就是两个被替换节点的父节点了。如此循环，直到队列中只剩一个节点（树根）。 其实这就是一个贪心策略，属于贪心算法的典型应用。
例子： 我们直接来看示例，如果我们需要来压缩下面的字符串：
“beep boop beer!” 首先，我们先计算出每个字符出现的次数，我们得到下面这样一张表 :
字符次数‘b’3‘e’4‘p’2‘ ‘2‘o’2‘r’1‘!’1 然后，我把把这些东西放到Priority Queue中（用出现的次数据当 priority），我们可以看到，Priority Queue 是以Prioirry排序一个数组，如果Priority一样，会使用出现的次序排序：下面是我们得到的Priority Queue：
接下来就是我们的算法——把这个Priority Queue 转成二叉树。我们始终从queue的头取两个元素来构造一个二叉树（第一个元素是左结点，第二个是右结点），并把这两个元素的priority相加，并放回Priority中（再次注意，这里的Priority就是字符出现的次数），然后，我们得到下面的数据图表：
同样，我们再把前两个取出来，形成一个Priority为2&#43;2=4的结点，然后再放回Priority Queue中 :
继续我们的算法（我们可以看到，这是一种自底向上的建树的过程）：
最终我们会得到下面这样一棵二叉树：
此时，我们把这个树的左支编码为0，右支编码为1，这样我们就可以遍历这棵树得到字符的编码，比如：‘b’的编码是 00，’p’的编码是101， ‘r’的编码是1000。我们可以看到出现频率越多的会越在上层，编码也越短，出现频率越少的就越在下层，编码也越长。
最终我们可以得到下面这张编码表：
字符编码‘b’00‘e’11‘p’101‘ ‘011‘o’010‘r’1000‘!’1001 这里需要注意一点，当我们encode的时候，我们是按“bit”来encode，decode也是通过bit来完成，比如，如果我们有这样的bitset “1011110111″ 那么其解码后就是 “pepe”。所以，我们需要通过这个二叉树建立我们Huffman编码和解码的字典表。
这里需要注意的一点是，我们的Huffman对各个字符的编码是不会冲突的，也就是说，不会存在某一个编码是另一个编码的前缀，不然的话就会大问题了。因为encode后的编码是没有分隔符的。
于是，对于我们的原始字符串 beep boop beer!
其对就能的二进制为 : 0110 0010 0110 0101 0110 0101 0111 0000 0010 0000 0110 0010 0110 1111 0110 1111 0111 0000 0010 0000 0110 0010 0110 0101 0110 0101 0111 0010 0010 0001" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/e2aa95a9386e8853b5831f3061fbf18b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-12T20:57:51+08:00" />
<meta property="article:modified_time" content="2018-12-12T20:57:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">霍夫曼编码（C&#43;&#43; 优先队列）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>霍夫曼编码 一般采用前缀编码 -- -- 对字符集进行编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀，这种编码称为前缀(编)码。</p> 
<h2>算法思想:</h2> 
<p>构造哈夫曼树非常简单，将所有的节点放到一个队列中，用一个节点替换两个频率最低的节点，新节点的频率就是这两个节点的频率之和。这样，</p> 
<p>新节点就是两个被替换节点的父节点了。如此循环，直到队列中只剩一个节点（树根）。 其实这就是一个贪心策略，属于贪心算法的典型应用。</p> 
<h2>例子：</h2> 
<p>我们直接来看示例，如果我们需要来压缩下面的字符串：</p> 
<p><strong> “beep boop beer!” </strong></p> 
<p>首先，我们先计算出每个字符出现的次数，我们得到下面这样一张表 :</p> 
<p> </p> 
<p> </p> 
<table><tbody><tr><td>字符</td><td>次数</td></tr><tr><td>‘b’</td><td>3</td></tr><tr><td>‘e’</td><td>4</td></tr><tr><td>‘p’</td><td>2</td></tr><tr><td>‘ ‘</td><td>2</td></tr><tr><td>‘o’</td><td>2</td></tr><tr><td>‘r’</td><td>1</td></tr><tr><td>‘!’</td><td>1</td></tr></tbody></table> 
<p> </p> 
<p><br> 然后，我把把这些东西放到Priority Queue中（用出现的次数据当 priority），我们可以看到，Priority Queue 是以Prioirry排序一个数组，如果Priority一样，会使用出现的次序排序：下面是我们得到的Priority Queue：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/d7/aa/WX0PwkIe_o.png"></p> 
<p>接下来就是我们的算法——把这个Priority Queue 转成二叉树。我们始终从queue的头取两个元素来构造一个二叉树（第一个元素是左结点，第二个是右结点），并把这两个元素的priority相加，并放回Priority中（再次注意，这里的Priority就是字符出现的次数），然后，我们得到下面的数据图表：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/67/bd/chpA6dGf_o.png"></p> 
<p>同样，我们再把前两个取出来，形成一个Priority为2+2=4的结点，然后再放回Priority Queue中 :</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/05/1f/S21JZisb_o.png"></p> 
<p>继续我们的算法（我们可以看到，这是一种自底向上的建树的过程）：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/e8/b6/ZTKJ5Biz_o.png"></p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/82/49/8k7lVj3I_o.png"></p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/f6/02/79gvvEQc_o.png"></p> 
<p>最终我们会得到下面这样一棵二叉树：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/3c/ab/jgRaTdd5_o.png"></p> 
<p>此时，我们把这个树的左支编码为0，右支编码为1，这样我们就可以遍历这棵树得到字符的编码，比如：‘b’的编码是 00，’p’的编码是101， ‘r’的编码是1000。<strong>我们可以看到出现频率越多的会越在上层，编码也越短，出现频率越少的就越在下层，编码也越长</strong>。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/75/bc/aOy81rWQ_o.png"></p> 
<p>最终我们可以得到下面这张编码表：</p> 
<p> </p> 
<p> </p> 
<table><tbody><tr><td>字符</td><td>编码</td></tr><tr><td>‘b’</td><td>00</td></tr><tr><td>‘e’</td><td>11</td></tr><tr><td>‘p’</td><td>101</td></tr><tr><td>‘ ‘</td><td>011</td></tr><tr><td>‘o’</td><td>010</td></tr><tr><td>‘r’</td><td>1000</td></tr><tr><td>‘!’</td><td>1001</td></tr></tbody></table> 
<p> </p> 
<p><br> 这里需要注意一点，当我们encode的时候，我们是按“bit”来encode，decode也是通过bit来完成，比如，如果我们有这样的bitset “1011110111″ 那么其解码后就是 “pepe”。所以，我们需要通过这个二叉树建立我们Huffman编码和解码的字典表。</p> 
<p> </p> 
<p>这里需要注意的一点是，我们的Huffman对各个字符的编码是不会冲突的，也就是说，<strong>不会存在某一个编码是另一个编码的前缀</strong>，不然的话就会大问题了。因为encode后的编码是没有分隔符的。</p> 
<p>于是，对于我们的原始字符串  beep boop beer!</p> 
<p>其对就能的二进制为 : 0110 0010 0110 0101 0110 0101 0111 0000 0010 0000 0110 0010 0110 1111 0110 1111 0111 0000 0010 0000 0110 0010 0110 0101 0110 0101 0111 0010 0010 0001</p> 
<p>我们的Huffman的编码为： 0011 1110 1011 0001 0010 1010 1100 1111 1000 1001</p> 
<p>从上面的例子中，我们可以看到被压缩的比例还是很可观的。</p> 
<h2><br> 代码</h2> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

const int M = 6;  // 待编码字符个数

typedef struct Tree
{
    int freq;  // 出现频率，即权重
    char key;
    Tree *left;
    Tree *right;
    Tree(int fr = 0, char k = '\0', Tree *l = nullptr, Tree *r = nullptr):
        freq(fr), key(k), left(l), right(r) {};
}Tree, *pTree;

struct cmp
{
    bool operator() (Tree *a, Tree *b)
    {
        return a-&gt;freq &gt; b-&gt;freq;  // 升序排列
    }
};

priority_queue&lt;pTree, vector&lt;pTree&gt;, cmp&gt; pque;  // 小顶堆

// 利用中序遍历的方法输出霍夫曼编码
// 左0右1，迭代完一次st回退一个字符
void printCode(Tree *proot, string st)
{
    if (proot == nullptr)
    {
        return;
    }

    if (proot-&gt;left)
    {
        st += '0';
    }
    printCode(proot-&gt;left, st);

    if (!proot-&gt;left &amp;&amp; !proot-&gt;right)  // 叶子结点
    {
        printf("%c's code: ", proot-&gt;key);
        for (size_t i = 0; i &lt; st.size(); ++i)
        {
            printf("%c", st[i]);
        }
        printf("\n");
    }
    st.pop_back();  // 退回一个字符

    if (proot-&gt;right)
    {
        st += '1';
    }
    printCode(proot-&gt;right, st);
}

// 清空堆上分配的内存空间
void del(Tree *proot)
{
    if (proot == nullptr)
    {
        return;
    }
    del(proot-&gt;left);
    del(proot-&gt;right);

    delete proot;
}

// 霍夫曼编码
void huffman()
{
    int i;
    char c;
    int fr;

    /* 读入测试数据
     *   a 45
     *   b 13
     *   c 12
     *   d 16
     *   e 9
     *   f 5
     */
    for (i = 0; i &lt; M; ++i)
    {
        Tree *pt = new Tree;
        scanf("%c%d", &amp;c, &amp;fr);
        getchar();
        pt-&gt;key = c;
        pt-&gt;freq = fr;
        pque.push(pt);
    }

    //将森林中最小的两个频度组成树，放回森林。直到森林中只有一棵树。
    while (pque.size() &gt; 1)
    {
        Tree *proot = new Tree;
        pTree pl, pr;
        pl = pque.top(); pque.pop();
        pr = pque.top(); pque.pop();

        proot-&gt;freq = pl-&gt;freq + pr-&gt;freq;
        proot-&gt;left = pl;
        proot-&gt;right = pr;

        pque.push(proot);
    }

    string s = "";
    printCode(pque.top(), s);
    del(pque.top());
}

int main()
{
    huffman();

    return 0;
}
</code></pre> 
<h2>运行结果</h2> 
<p><img alt="" class="has" height="265" src="https://images2.imgbox.com/32/08/pl1TPNbI_o.png" width="302"></p> 
<p>对应的二叉树为：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/7e/fb/cMuKKyOU_o.jpg"></p> 
<p> 算法以freq为键值的优先队列Q用在贪心选择时有效地确定算法当前要合并的2棵具有最小频率的树。一旦2棵具有最小频率的树合并后，产生一棵新的树，</p> 
<p>其频率为合并的2棵树的频率之和，并将新树插入优先队列Q。经过n－1次的合并后，优先队列中只剩下一棵树，即所要求的树proot。算法huffman用最</p> 
<p>小堆实现优先队列Q。初始化优先队列需要O(n)计算时间，由于最小堆的节点删除、插入均需O(logn)时间，n－1次的合并总共需要O(nlogn)计算时间。</p> 
<p>因此，关于n个字符的哈夫曼算法的计算时间为O(nlogn) 。<br>  </p> 
<p>参考资料：</p> 
<p><a href="https://blog.csdn.net/daniel_ustc/article/details/17613359">https://blog.csdn.net/daniel_ustc/article/details/17613359</a></p> 
<p><a href="https://coolshell.cn/articles/7459.html" rel="nofollow">https://coolshell.cn/articles/7459.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/704ddc02d699066b8183d2f1f6b920de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenCv-C&#43;&#43;-ORB特征检测与匹配</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f7e82f26c485e88abff2534a2d636746/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">css input placeholder属性 样式修改 包括颜色 大小 位置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>