<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图的连通性问题及Tarjan算法 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="图的连通性问题及Tarjan算法" />
<meta property="og:description" content="推荐观看视频教程 一、图的连通性 1. 无向图的连通性
在无向图G＝（V，E）中：
①连通：若节点u和v能够互相到达，则称u,v是连通的；
②连通图：若图中任何节点之间都是可互相到达的，则称G是连通图，否则称G是非连通图；
这是一个连通图这不是一个连通图，
③连通分量（连通分支）：我们可以看出上面右图有两个部分连通的图，叫做连通分量（或连通分支）
④无向图的连通性判定：并查集、DFS、BFS、WARSHALL 算法；
⑤非连通的无向图求连通分量：可通过额外设置计数器count（初始值0）统计出图的连通分量，每调用dfs（或bfs）遍历一次，计数器count增1。当遍历完无向图时，若count=1，则图连通，若count&gt;1，图非连通，count的值就是该图的连通分量数。
需要注意的是，连通分量的提出是以&#34;整个无向图不是连通图&#34;为前提的，因为如果无向图是连通图，则其无法分解出多个最大连通子图，因为图中所有的顶点之间都是连通的。
2.有向图的连通性
①强连通：在有向图中，若节点 u 和节点 v 能互相到达（不必是同一路径），则称 u,v 强连通；
节点1可以通过（1，2，3）到达3，节点3可以通过（3，4，1）到达1，所以3和1是强连通；
②强连通图：在有向图 G=(V,E) 中，若对于V 中任意两个不同的顶点 u 和 v，都存在从 u 到 v 以及从 v 到 u 的路径，则称 G是强连通图。
这是一个强连通图
③强连通分量SCC(strongly connected components)：非强连通图的极大强连通子图，称为强连通分量。强连通图只有一个强连通分量，即是其自身；非强连通的有向图有多个强连分量。
这个有向图中有两个强连通分量（2，3，1）和（7，6，4，5）。
小提示：“连通图” 是在无向图 的基础上对图中顶点之间的连通做了更高的要求，而“强连通图” 是在有向图 的基础上对图中顶点的连通做了更高的要求。
④有向图的连通性判定算法：
方法一:可以调用DFS搜索 V 次，V是顶点的个数，就是对每个顶点都做一次DFS搜索，判断是否可达。这样的复杂度为O(V*(V&#43;E))。
方法二:可以参考求解连通分量的算法Tarjan算法，我们可以在O(V&#43;E) 的时间内找到所有的连通分量，如果连通分量的个数为1，则说明该图是强连通的。
⑤有向图求强连通分量算法：Kosaraju 算法和Tarjan算法
二、Tarjan算法 Tarjan（音译为塔扬）算法的核心其实是dfs，主要是通过维护两个数组来完成强连通分量的计算：
dfn[]数组：负责记录每个节点的dfs顺序（简称为dfs序）。
low[]数组：负责记录从每个节点的出发沿可行边所能到达的点中dfs序号最小的序号。
第一个数组好理解：
对于下面左图的有向图进行dfs，并产生dfs序应该是右边的结果
第二个数组费解一点：
P2863 [USACO06JAN]牛的舞会
//P2863 [USACO06JAN]牛的舞会The Cow Prom #include &lt;cstdio&gt; #include &lt;stack&gt; using namespace std; const int maxn=10005; const int maxm=50005; struct Edge{ int v,w,nxt; }edge[maxm]; int n,m,cnt=1,head[maxn],instack[maxn]; int scctot; int index; int dfn[maxn];///节点的dfs序 int low[maxn];///dfs时，节点能到达的最小dfs序 int scc[maxn];///每个节点所属的强连通分量 int num[maxn];///记录每个强连通分量中节点个数 stack&lt;int&gt;s; inline void adedge(int u,int v,int w) { edge[&#43;&#43;cnt]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/53e240f3865f16faf8f8a30f059056de/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-04T20:21:11+08:00" />
<meta property="article:modified_time" content="2020-02-04T20:21:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图的连通性问题及Tarjan算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><a href="https://www.bilibili.com/video/av60380978?p=1" rel="nofollow">推荐观看视频教程</a></h4> 
<h4>一、图的连通性</h4> 
<p id="htIba"><strong>1. 无向图的连通性</strong></p> 
<p>在无向图G＝（V，E）中：</p> 
<p>①<strong>连通：</strong>若节点u和v能够互相到达，则称u,v是连通的；</p> 
<p>②<strong>连通图：</strong>若图中<span style="color:#3399ea;"><strong>任何节点之间都是可互相到达的</strong></span>，则称G是<span style="color:#f33b45;"><strong>连通图，</strong></span>否则称G是非连通图；</p> 
<p><img alt="" class="has" height="165" src="https://images2.imgbox.com/23/66/At3SmD0n_o.png" width="165">这是一个连通图<img alt="" class="has" height="169" src="https://images2.imgbox.com/b9/8e/bE7oVeqc_o.png" width="169">这不是一个连通图，</p> 
<p><strong>③连通分量（连通分支）：</strong>我们可以看出上面右图有两个部分连通的图，叫做<span style="color:#f33b45;"><strong>连通分量（或连通分支）</strong></span></p> 
<p><strong>④无向图的连通性判定：<span style="color:#f33b45;">并查集、DFS、BFS、</span></strong><span style="color:#3399ea;">WARSHALL 算法；</span></p> 
<p><strong>⑤非连通的无向图求连通分量：</strong>可通过额外设置计数器count（初始值0）统计出图的连通分量，每调用dfs（或bfs）遍历一次，计数器count增1。当遍历完无向图时，若count=1，则图连通，若count&gt;1，图非连通，count的值就是该图的连通分量数。</p> 
<p>需要注意的是，连通分量的提出是以"整个无向图不是连通图"为前提的，因为如果无向图是连通图，则其无法分解出多个最大连通子图，因为图中所有的顶点之间都是连通的。</p> 
<p><strong>2.有向图的连通性</strong></p> 
<p><strong>①强连通：</strong>在有向图中，若节点 <em>u </em>和节点 <em>v </em>能互相到达（<strong><span style="color:#f33b45;">不必是同一路径</span></strong>），则称 <em>u</em>,<em>v </em>强连通；</p> 
<p><img alt="" class="has" height="111" src="https://images2.imgbox.com/ba/9e/w82ya3zO_o.png" width="108">节点1可以通过（1，2，3）到达3，节点3可以通过（3，4，1）到达1，所以3和1是强连通；</p> 
<p>②<strong>强连通图：</strong>在有向图 <em>G</em>=(<em>V</em>,<em>E</em>) 中，若对于<em>V </em>中任意两个不同的顶点 <em>u </em>和 <em>v</em>，都存在从 <em>u </em>到 <em>v </em>以及从 <em>v </em>到 <em>u </em>的路径，则称 <em>G</em>是强连通图。</p> 
<p><img alt="" class="has" height="111" src="https://images2.imgbox.com/86/06/U9ExGxiT_o.gif" width="119">这是一个强连通图</p> 
<p>③<strong>强连通分量SCC</strong>(strongly connected components)<strong>：</strong>非强连通图的极大强连通子图，称为强连通分量。强连通图只有一个强连通分量，即是其自身；非强连通的有向图有多个强连分量。</p> 
<p><img alt="" class="has" height="193" src="https://images2.imgbox.com/f6/5f/bBuQ3unv_o.png" width="193">这个有向图中有两个强连通分量（2，3，1）和（7，6，4，5）。</p> 
<p><strong>小提示：<span style="color:#f33b45;"><em>“连通图” </em></span></strong>是在<span style="color:#f33b45;"><em>无向图 </em></span>的基础上对图中顶点之间的连通做了更高的要求，而<em><span style="color:#f33b45;">“</span><strong><span style="color:#f33b45;">强连通图”</span> </strong></em>是在<span style="color:#f33b45;"><em>有向图 </em></span>的基础上对图中顶点的连通做了更高的要求。</p> 
<p><strong>④有向图的连通性判定算法：</strong></p> 
<p><strong>方法一:</strong>可以调用DFS搜索 V 次，V是顶点的个数，就是对每个顶点都做一次DFS搜索，判断是否可达。这样的复杂度为O(V*(V+E))。</p> 
<p><strong>方法二:</strong>可以参考求解连通分量的算法Tarjan算法，我们可以在O(V+E) 的时间内找到所有的连通分量，如果连通分量的个数为1，则说明该图是强连通的。</p> 
<p><strong>⑤有向图求强连通分量算法：</strong><span style="color:#3399ea;">Kosaraju 算法</span><strong>和<span style="color:#f33b45;">Tarjan算法</span></strong></p> 
<h4><strong><span style="color:#f33b45;">二、Tarjan算法</span></strong></h4> 
<p><strong>Tarjan（音译为塔扬）算法的核心其实是dfs，主要是通过维护两个数组来完成强连通分量的计算：</strong></p> 
<p><span style="color:#f33b45;"><strong>dfn[]数组：负责记录每个节点的dfs顺序</strong></span><strong>（</strong>简称为<span style="color:#f33b45;"><strong>dfs序</strong></span><strong>）</strong><span style="color:#f33b45;"><strong>。</strong></span></p> 
<p><span style="color:#f33b45;"><strong>low[]数组：负责记录从每个节点的出发沿可行边所能到达的点中dfs序号最小的序号。</strong></span></p> 
<p><strong>第一个数组好理解：</strong></p> 
<p><strong>对于下面左图的有向图进行dfs，并产生dfs序应该是右边的结果</strong></p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/ca/67/mOzhS3V0_o.png"></p> 
<p><strong>第二个数组费解一点：</strong></p> 
<p> </p> 
<p><strong>P2863 [USACO06JAN]牛的舞会</strong></p> 
<pre class="has"><code>//P2863 [USACO06JAN]牛的舞会The Cow Prom
#include &lt;cstdio&gt;
#include &lt;stack&gt;
using namespace std;
const int maxn=10005;
const int maxm=50005;
struct Edge{
	int v,w,nxt;
}edge[maxm];
int n,m,cnt=1,head[maxn],instack[maxn];
int scctot;
int index;
int dfn[maxn];///节点的dfs序 
int low[maxn];///dfs时，节点能到达的最小dfs序 
int scc[maxn];///每个节点所属的强连通分量 
int num[maxn];///记录每个强连通分量中节点个数 
stack&lt;int&gt;s;
inline void adedge(int u,int v,int w)
{
	edge[++cnt].v=v,edge[cnt].w=w,edge[cnt].nxt=head[u],head[u]=cnt;
}
void tarjan(int u)
{
	if (dfn[u])return;
	index++;
	dfn[u]=low[u]=index;
	instack[u]=1;
	s.push(u);
	for (int i=head[u];i;i=edge[i].nxt)
	{
		int v=edge[i].v;
		if (!dfn[v])///如果没有dfs过，则继续深搜 
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
			///dfs返回后更新当前节点的low值等于当前节点能到达的节点中low值最小的low值 
		}
		if (instack[v])
		///如果v的dfs序已存在，说明从节点u可以回到dfs序更小的节点，或者说已形成了一个环 
		{			
			low[u]=min(low[u],dfn[v]);
			///当前节点u的low值应该等于当前节点能到达的节点中low值最小的low值
		}		
	}
	if (dfn[u]==low[u])///找到一个强连通分量
	{
		scctot++;///强连通分量个数加1 
		while(1)
		{
			int t=s.top();
			scc[t]=scctot;
			num[scctot]++; 
			instack[t]=0;
			s.pop();
			if (t==u)break;
		}
	} 
}
int main()
{
	scanf("%d %d",&amp;n,&amp;m);
	for (int i=1,u,v;i&lt;=m;++i)
	{
		scanf("%d %d",&amp;u,&amp;v);
		adedge(u,v,1);
	}
	for (int i=1;i&lt;=n;++i)
	{
		if (!scc[i])tarjan(i);///如果有节点没有生成所属强连通分量值 
		//if (!dfn[i])tarjan(i);///如果有节点没有dfs访问到 
	}
	int ans=0;
	for (int i=1;i&lt;=scctot;++i)///统计节点个数大于1的强连通分量的个数 
	{
		if (num[i]&gt;1)ans++;
	}
	printf("%d",ans);
	return 0;
}</code></pre> 
<h4><strong>三、 点集和割集</strong></h4> 
<p>对于图的连通性而言，不同节点或边的“重要性”是不同的，比如在通信网络中，有的节点或边出现中断，会对整个连通性的影响到头重要，而有的则不影响全局。另外，也存在一部分节点联合起来，从而对于整个图的连通性起关键作用。</p> 
<p>一句话：点集和割集主要是为了研究，一些点的存在或者删除后对整个图的连通性影响。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0113d9bd9e797ae2181fb27e7739644/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深入Nodejs模块fs - 文件系统操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/617a3af2c05b61cb027c0b4a800c9587/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">10_1、斐波那契数列</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>