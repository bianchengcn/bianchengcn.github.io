<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java基础—Volatile关键字详解 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java基础—Volatile关键字详解" />
<meta property="og:description" content="java基础—Volatile关键字详解 文章目录 java基础—Volatile关键字详解并发编程的三大特性：volatile的作用是什么volatile如何保证有可见性volatile保证可见性在JMM层面原理volatile保证可见性在CPU层面原理可见性问题的例子 volatile如何保证有序性单例模式使用volatile保证有序性的例子 volatile能保证线程安全吗？volatile能保原子性吗？volatile不能保证原子性详细解析 演示内存可见性的5个例子案例1：flag加上volatile关键字案例2：while循环中加上System.out.println(&#34;!!&#34;);案例3：while循环中加上synchronized (TestVolite.class)案例4：while中加上test2()（被synchronized修饰）案例5：while循环中加上test1方法案例总结 happens-before (先行发生)原则—《深入理解Java虚拟机》 并发编程的三大特性： 原子性、可见性和有序性。只要有一条原则没有被保证，就有可能会导致程序运行不正确。volatile关键字 被用来保证可见性，即保证共享变量的内存可见性以解决缓存一致性问题。一旦一个共享变量被 volatile关键字 修饰，那么就具备了两层语义：内存可见性和禁止进行指令重排序。
原子性：就是一个操作或多个操作中，要么全部执行，要么全部不执行。
例如：账户A向账户B转账1000元，这个么过程涉及到两个操作，(1)A账户减去1000元 (2)B账户增加1000元。这么两个操作必须具备原子性。否则A账户钱少了，B账户没增加。
有序性： 程序执行顺序按照代码先后顺序执行。
处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致(指令重排)，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。(此处的结果一致指的是在单线程情况下)
指令重排的理解：单线程侠，如果两个操作更换位置后，对后续操作结果没有影响，可以对这两个操作可以互换顺序。
可见性： 可见性是指多线程共享一个变量，其中一个线程改变了变量值，其他线程能够立即看到修改的值。
//线程1执行的代码 int i = 0; i = 10; //线程2执行的代码 j = i; CPU1执行线程1代码，CPU执行线程2代码。CPU读取i=0到CPU缓存中，修改i=10到自己缓存，还没更新到主存，此时CPU2读取的i还是主存中i=0,此时j会被赋值为0；
volatile的作用是什么 volatile是一个类型修饰符，JDK1.5之后，对其语义进行了增强。
保证了不同线程之间对共享变量操作的可见性。通过禁止编译器、CPU指令重排序和部分hapens-before规则，解决有序性。 volatile如何保证有可见性 volatile保证可见性在JMM层面原理 volatile修饰的共享变量在执行写操作后，会立即刷回到主存，以供其它线程读取到最新的记录。
volatile保证可见性在CPU层面原理 volatile关键字底层通过lock前缀指令，进行缓存一致性的缓存锁定方案，通过总线嗅探和MESI协议来保证多核缓存的一致性问题，保证多个线程读取到最新内容。 lock前缀指令除了具有缓存锁定这样的原子操作，它还具有类似内存屏障的功能，能够保证指令重排的问题。
被volatile修饰的变量在写操作生成汇编指令时，会多出Lock前缀指令，这个指令会引起CPU缓存刷回主存。刷回主存后，导致其他核心缓存了该内存地址的数据无效，通过缓存一致性协议(MESI)保证每个线程的数据是最新的。缓存一致性协议保证每个CPU核心通过嗅探在总线上传播的数据来检查自己的缓存是不是被修改，· 当 CPU 发现自己缓存行对应的内存地址被修改，会将当前 CPU 的缓存行设置成无效状态，重新从内存中把数据读到 CPU 缓存 可见性问题的例子 启动线程1和线程2，线程2设置stop=true。查看线程1是否会停止
public class TestVisibility { //是否停止 变量 private static boolean stop = false; public static void main(String[] args) throws InterruptedException { new Thread(() -&gt; { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/cb7d720cf3b5a9b5e099da22149f50b9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-13T01:06:12+08:00" />
<meta property="article:modified_time" content="2023-02-13T01:06:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java基础—Volatile关键字详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="javaVolatile_0"></a>java基础—Volatile关键字详解</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#javaVolatile_0" rel="nofollow">java基础—Volatile关键字详解</a></li><li><ul><li><ul><li><a href="#_3" rel="nofollow">并发编程的三大特性：</a></li><li><a href="#volatile_32" rel="nofollow">volatile的作用是什么</a></li><li><a href="#volatile_39" rel="nofollow">volatile如何保证有可见性</a></li><li><ul><li><a href="#volatileJMM_42" rel="nofollow">volatile保证可见性在JMM层面原理</a></li><li><a href="#volatileCPU_46" rel="nofollow">volatile保证可见性在CPU层面原理</a></li><li><a href="#_54" rel="nofollow">可见性问题的例子</a></li></ul> 
    </li><li><a href="#volatile_97" rel="nofollow">volatile如何保证有序性</a></li><li><ul><li><a href="#volatile_123" rel="nofollow">单例模式使用volatile保证有序性的例子</a></li></ul> 
    </li><li><a href="#volatile_165" rel="nofollow">volatile能保证线程安全吗？</a></li><li><a href="#volatile_171" rel="nofollow">volatile能保原子性吗？</a></li><li><ul><li><a href="#volatile_213" rel="nofollow">volatile不能保证原子性详细解析</a></li></ul> 
    </li><li><a href="#5_223" rel="nofollow">演示内存可见性的5个例子</a></li><li><ul><li><a href="#1flagvolatile_272" rel="nofollow">案例1：flag加上volatile关键字</a></li><li><a href="#2whileSystemoutprintln_282" rel="nofollow">案例2：while循环中加上System.out.println("!!");</a></li><li><a href="#3whilesynchronized_TestVoliteclass_331" rel="nofollow">案例3：while循环中加上synchronized (TestVolite.class)</a></li><li><a href="#4whiletest2synchronized_341" rel="nofollow">案例4：while中加上test2()（被synchronized修饰）</a></li><li><a href="#5whiletest1_349" rel="nofollow">案例5：while循环中加上test1方法</a></li><li><a href="#_357" rel="nofollow">案例总结</a></li></ul> 
    </li><li><a href="#happensbefore_Java_371" rel="nofollow">happens-before (先行发生)原则—《深入理解Java虚拟机》</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="_3"></a>并发编程的三大特性：</h4> 
<p><mark>原子性、可见性和有序性</mark>。只要有一条原则没有被保证，就有可能会导致程序运行不正确。volatile关键字 被用来保证可见性，即保证共享变量的内存可见性以解决缓存一致性问题。一旦一个共享变量被 volatile关键字 修饰，那么就具备了两层语义：内存可见性和禁止进行指令重排序。</p> 
<ul><li> <p><strong>原子性</strong>：就是一个操作或多个操作中，要么全部执行，要么全部不执行。</p> 
  <blockquote> 
   <p>例如：账户A向账户B转账1000元，这个么过程涉及到两个操作，(1)A账户减去1000元 (2)B账户增加1000元。这么两个操作必须具备原子性。否则A账户钱少了，B账户没增加。</p> 
  </blockquote> </li><li> <p><strong>有序性：</strong> 程序执行顺序按照代码先后顺序执行。</p> 
  <blockquote> 
   <p>处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致(指令重排)，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。(此处的结果一致指的是在单线程情况下)</p> 
   <p>指令重排的理解：单线程侠，如果两个操作更换位置后，对后续操作结果没有影响，可以对这两个操作可以互换顺序。</p> 
  </blockquote> </li><li> <p><strong>可见性：</strong> 可见性是指多线程共享一个变量，其中一个线程改变了变量值，其他线程能够立即看到修改的值。</p> 
  <blockquote> 
   <pre><code class="prism language-java"><span class="token comment">//线程1执行的代码</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">//线程2执行的代码</span>
j <span class="token operator">=</span> i<span class="token punctuation">;</span>

</code></pre> 
   <p>CPU1执行线程1代码，CPU执行线程2代码。CPU读取i=0到CPU缓存中，修改i=10到自己缓存，还没更新到主存，此时CPU2读取的i还是主存中i=0,此时j会被赋值为0；</p> 
  </blockquote> </li></ul> 
<h4><a id="volatile_32"></a>volatile的作用是什么</h4> 
<p>volatile是一个类型修饰符，JDK1.5之后，对其语义进行了增强。</p> 
<ul><li>保证了不同线程之间对共享变量操作的<strong>可见性</strong>。</li><li>通过禁止编译器、CPU指令重排序和部分hapens-before规则，解决<strong>有序性</strong>。</li></ul> 
<h4><a id="volatile_39"></a>volatile如何保证有可见性</h4> 
<br> 
<h5><a id="volatileJMM_42"></a>volatile保证可见性在JMM层面原理</h5> 
<p>volatile修饰的共享变量在执行写操作后，会立即刷回到主存，以供其它线程读取到最新的记录。</p> 
<h5><a id="volatileCPU_46"></a>volatile保证可见性在CPU层面原理</h5> 
<p><mark>volatile关键字底层通过lock前缀指令，进行缓存一致性的缓存锁定方案，通过总线嗅探和MESI协议来保证多核缓存的一致性问题，保证多个线程读取到最新内容。 lock前缀指令除了具有缓存锁定这样的原子操作，它还具有类似内存屏障的功能，能够保证指令重排的问题。</mark></p> 
<ul><li>被volatile修饰的变量在写操作生成汇编指令时，会多出Lock前缀指令，这个指令会引起CPU缓存刷回主存。</li><li>刷回主存后，导致其他核心缓存了该内存地址的数据无效，通过缓存一致性协议(MESI)保证每个线程的数据是最新的。</li><li>缓存一致性协议保证每个CPU核心通过嗅探在总线上传播的数据来检查自己的缓存是不是被修改，· 当 CPU 发现自己缓存行对应的内存地址被修改，会将当前 CPU 的缓存行设置成无效状态，重新从内存中把数据读到 CPU 缓存</li></ul> 
<h5><a id="_54"></a>可见性问题的例子</h5> 
<blockquote> 
 <p>启动线程1和线程2，线程2设置stop=true。查看线程1是否会停止</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestVisibility</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">//是否停止 变量</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> stop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>


        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程 1 正在运行..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stop<span class="token punctuation">)</span> <span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程 1 终止"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//休眠 10 毫秒</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//启动线程 2， 设置 stop = true</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程 2 正在运行..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"设置 stop 变量为 true."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>

</code></pre> 
<blockquote> 
 <p>可见，线程1并不会停止，而是一直循环下去。这就是CPU缓存导致的一致性问题。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8d/c7/JjFuOY5g_o.png" alt="" width="300"></p> 
<p><img src="https://images2.imgbox.com/6e/97/njy182G7_o.png" alt="" width="300"></p> 
<blockquote> 
 <p>给stop加上volatile关键字，并运行，会发现线程1终止了</p> 
 <p><img src="https://images2.imgbox.com/ac/ad/fLCO4ZhG_o.png" alt="" width="300"></p> 
</blockquote> 
<h4><a id="volatile_97"></a>volatile如何保证有序性</h4> 
<ol><li> <p>内存屏障(Memory Barrier 又称内存栅栏，是一个 CPU 指令)禁止重排序</p> 
  <blockquote> 
   <p>Volatile关键字(JMM内存屏障)，内存屏障也成为内存栏杆，是一个CPU指令，volatile修饰的变量，在读写操作前后都会进行屏障的插入来保证执行的顺序不被编译器等优化器锁重排序。</p> 
   <p>内存屏障的功能有两个：（1）阻止屏障两边的指令重排、（2）刷新处理器缓存（保证内存可见性）<img src="https://images2.imgbox.com/15/65/4SdZT7QA_o.png" alt="image-20230204181902182"></p> 
  </blockquote> </li><li> <p>3 个 happens-before 规则实现：</p> 
  <blockquote> 
   <p>Happens-Before<br> SR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下：</p> 
   <ul><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则： 对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile 变量规则： 对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li><li>传递性： 如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li></ul> 
   <p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before 的定义很微妙</p> 
   <img src="https://images2.imgbox.com/44/19/nlkq2pQv_o.png" alt="img"> 
  </blockquote> </li></ol> 
<h5><a id="volatile_123"></a>单例模式使用volatile保证有序性的例子</h5> 
<p>为什么变量singleton之前需要加volatile</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 构造函数私有，禁止外部实例化
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>singleton<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<blockquote> 
 <p>先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p> 
 <ul><li>分配内存空间。</li><li>初始化对象。</li><li>将内存空间的地址赋值给对应的引用。</li></ul> 
 <p>但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：</p> 
 <ul><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ul> 
 <p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量</p> 
</blockquote> 
<h4><a id="volatile_165"></a>volatile能保证线程安全吗？</h4> 
<p><mark>单纯使用 volatile 关键字是不能保证线程安全的</mark></p> 
<ul><li>volatile 只提供了一种弱的同步机制，用来确保将变量的更新操作通知到其他线程</li><li>volatile 语义是禁用 CPU 缓存，直接从主内存读、写变量。表现为：更新 volatile 变量时，JMM 会把线程对应的本地内存中的共享变量值刷新到主内存中；读 volatile 变量时，JMM 会把线程对应的本地内存设置为无效，直接从主内存中读取共享变量</li><li>当把变量声明为 volatile 类型后，JVM 增加内存屏障，禁止 CPU 进行指令重排</li></ul> 
<h4><a id="volatile_171"></a>volatile能保原子性吗？</h4> 
<p><strong>不能</strong>。<mark>volatile 关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是 volatile 没办法保证对变量的操作的原子性</mark></p> 
<pre><code>public class atomiciVolitile {
volatile  int  i = 0;
public void addI(){
    i++;
}

public static void main(String[] args) throws InterruptedException {
    atomiciVolitile a=new atomiciVolitile();
    for (int i = 0; i &lt; 10000; i++) {
        new Thread(() -&gt; {
            try {
                Thread.sleep(10);//执行速度太快，没有起到并发作用，等待10毫秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            a.addI();
        }).start();
    }

    Thread.sleep(5000);

    System.out.println(a.i);

}
</code></pre> 
<p><img src="https://images2.imgbox.com/31/4c/RvRDSp9G_o.png" alt="img"></p> 
<p><strong>原因</strong></p> 
<blockquote> 
 <p>原因：i++其实是一个复合操作，包括三步骤：</p> 
 <ul><li>读取i的值。</li><li>对i加1。</li><li>将i的值写回内存。</li></ul> 
 <p>volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。</p> 
</blockquote> 
<br> 
<h5><a id="volatile_213"></a>volatile不能保证原子性详细解析</h5> 
<blockquote> 
 <ul><li>变量count=10，线程1对变量自增操作，线程1读取主存中count=10后，被<mark>阻塞</mark></li><li>线程1对count自增操作，读取count时，由于线程1还没修改（不会导致线程2的count地址所在的缓存行失效），线程2去主存读取的count=10；接着进行+1操作，<mark>此时线程2进行+1操作后，还没写回主存，就被阻塞</mark>。</li><li>线程1进行+1操作，此时在线程一的缓存中，<mark>count是10</mark></li><li>然后线程2刷回主存，主存中count=11，虽然此时 线程1 能感受到 线程2 对count的修改(<mark>MESI缓存一致性协议</mark>)，但由于线程1只剩下对count的<mark>写操作</mark>了，而不必对count进行<mark>读操作</mark>了，所以此时 线程2 对count的修改并不能影响到 线程1。于是，线程1 也将 11 写入工作内存并刷到主内存。也就是说，两个线程分别进行了一次自增操作后，count 只增加了 1。下图演示了这种情形：</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/0b/1e/ya6g1Eyn_o.png" alt="image-20230213003321016" width="700"></p> 
<h4><a id="5_223"></a>演示内存可见性的5个例子</h4> 
<pre><code class="prism language-java">
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestVolatile</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{<!-- --></span>

            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">}</span>
            flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程 "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 执行完毕： "</span>
                    <span class="token operator">+</span> <span class="token string">"置  flag= "</span> <span class="token operator">+</span> flag <span class="token operator">+</span> <span class="token string">" ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 加上下面三句代码的任意一句，程序都会正常结束：</span>
            <span class="token comment">// System.out.println("!!");                              //...语句1</span>
            <span class="token comment">// synchronized (TestVolatile.class) {}                     //...语句2</span>
            <span class="token comment">//TestVolatile.test2();                                    //...语句3</span>
             <span class="token comment">// 若只加上下面一句代码，程序都会死循环：</span>
            <span class="token comment">//  TestVolatile.test1();                                  //...语句4</span>
            
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程 "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                        <span class="token operator">+</span> <span class="token string">" 即将跳出while循环体... "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><mark>执行结果</mark> ：线程并没有停止，可见，线程1将flag置为true对主线程并不可见。</p> 
<p><img src="https://images2.imgbox.com/ef/c0/YcKnLw57_o.png" alt="image-20230212232012118" width="500"></p> 
<h5><a id="1flagvolatile_272"></a>案例1：flag加上volatile关键字</h5> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">volatile</span>  <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre> 
<p><mark>执行结果</mark>:加上voaltile关键字后，falg对于主线程可见，执行break，结束循环。</p> 
<p><img src="https://images2.imgbox.com/f5/df/8Rup7yNu_o.png" alt="image-20230212232352756" width="500"></p> 
<h5><a id="2whileSystemoutprintln_282"></a>案例2：while循环中加上System.out.println(“!!”);</h5> 
<p><mark>这里只在while循环中加上System.out.println(“!!”); ，没有flag加volatile</mark></p> 
<pre><code class="prism language-java">
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestVolatile</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{<!-- --></span>

            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">}</span>
            flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程 "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 执行完毕： "</span>
                    <span class="token operator">+</span> <span class="token string">"置  flag= "</span> <span class="token operator">+</span> flag <span class="token operator">+</span> <span class="token string">" ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 加上下面三句代码的任意一句，程序都会正常结束：</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">//...语句1</span>
            <span class="token comment">// synchronized (TestVolatile.class) {}                     //...语句2</span>
            <span class="token comment">//TestVolatile.test2();                                    //...语句3  </span>
             <span class="token comment">// 若只加上下面一句代码，程序都会死循环：</span>
            <span class="token comment">//  TestVolatile.test1();                                      //...语句4</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程 "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                        <span class="token operator">+</span> <span class="token string">" 即将跳出while循环体... "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><mark>执行结果</mark> ：在输出无数的"!!"后，程序最终结束。说明main线程也能看到对flag的修改，并跳出while循环。</p> 
<p><img src="https://images2.imgbox.com/0e/1b/z4Y0XzzT_o.png" alt="image-20230212233128541" width="500"></p> 
<h5><a id="3whilesynchronized_TestVoliteclass_331"></a>案例3：while循环中加上synchronized (TestVolite.class)</h5> 
<p>代码不再写贴上来，每个案例只针对讲述的地方更改。</p> 
<p><img src="https://images2.imgbox.com/f5/fb/YuTRSZlC_o.png" alt="image-20230212234830055"></p> 
<p><mark>执行结果</mark> ：线程结束。使用synchronized关键字，加上了synchronized(类锁)后，mian线程看见了flag的修改。结束while循环。</p> 
<p><img src="https://images2.imgbox.com/5a/85/V7veTblI_o.png" alt="image-20230212233730365" width="500"></p> 
<h5><a id="4whiletest2synchronized_341"></a>案例4：while中加上test2()（被synchronized修饰）</h5> 
<p><img src="https://images2.imgbox.com/1c/8b/gRDLOAuy_o.png" alt="image-20230212234845908" width="500"></p> 
<p><mark>执行结果</mark>：线程结束</p> 
<p><img src="https://images2.imgbox.com/c5/2d/77XMyIsv_o.png" alt="image-20230212234601757" width="500"></p> 
<h5><a id="5whiletest1_349"></a>案例5：while循环中加上test1方法</h5> 
<p><img src="https://images2.imgbox.com/7d/1b/6QSlCBWF_o.png" alt="image-20230212234721620" width="500"></p> 
<p><mark>执行结果</mark> ：进入死循环，flag为true对主线程不可见</p> 
<p><img src="https://images2.imgbox.com/a3/16/7kkrjAiH_o.png" alt="image-20230212234918485" width="500"></p> 
<h5><a id="_357"></a>案例总结</h5> 
<p>案例1和案例5很容易理解，就是可见性问题。案例2和案例3是因为加上了synchronized。<strong><mark>synchronized 也可以保证可见性，因为每次运行synchronized块 或者 synchronized方法都会导致线程工作内存与主存的同步，使得其他线程可以取得共享变量的最新值。也就是说，synchronized 语义范围不但包括 volatile 具有的可见性，也包括原子性，但不能禁止指令重排序，这是二者一个功能上的差异。</mark></strong>，那为什么案例2也会可见的效果呢？看一下源码，源码中加了类锁（synchronized）</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>         <span class="token comment">// synchronized 块</span>
        <span class="token function">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre> 
<h4><a id="happensbefore_Java_371"></a>happens-before (先行发生)原则—《深入理解Java虚拟机》</h4> 
<ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。</li><li>锁定原则：一个unlock操作先发生于后面对同一个锁的lock操作。</li><li>volatile变量规则：对一个变量的写操作先发生于后面对同一个变量的读操作。</li><li>传递规则：操作A先发生于操作B，操作B先发生于操作C，由此可得出A先发生于操作C。</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li><li>线程中断规则：线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li><li>对象终结规则：个对象的初始化完成先行发生于他的finalize()方法的开始。</li></ul> 
<p><mark>比较重要的是前4条，讲解一下前四条</mark></p> 
<blockquote> 
 <ul><li><mark>程序次序规则</mark> ：中指的是单个线程，在单线程情况下，程序看起来顺序执行(其中可能发生了重排序)且结果一致。事实上，<strong>这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</strong></li><li><mark>锁定原则</mark> ：无论在单线程还是多线程中，同一个锁出现于被锁定的状态，那么必须先对锁进行释放操作，后面才能继续进行lock操作</li><li><mark>volatile变量规则</mark> ：如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</li><li><mark>传递规则</mark> ：happens-before具有传递性。</li></ul> 
</blockquote> 
<p><mark><strong>想要了解更详细，请看这篇</strong></mark></p> 
<p><a href="https://blog.csdn.net/weixin_45112292/article/details/128884664">java基础—java内存模型(JMM)CPU架构、缓存一致性、重排序、JMM的实现、JMM保证可见性、有序性问题的详解</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0303a8049b85cc876faaef64b04eda3c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">redux的hooks改写步骤</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b7cb7bab7ea92caa43ba93cc5e843f87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">若依微服务版集成滑动验证码AJ-Captcha</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>