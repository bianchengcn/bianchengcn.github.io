<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【操作系统】僵尸进程与孤儿进程总结 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【操作系统】僵尸进程与孤儿进程总结" />
<meta property="og:description" content=" 【操作系统】僵尸进程与孤儿进程总结 参考资料：
什么是僵尸进程，如何找到并杀掉僵尸进程？
孤儿进程与僵尸进程总结
一、僵尸进程与孤儿进程是什么？ 我们知道在unix / linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。
1.1、孤儿进程 孤儿进程：一个父进程退出，此时父进程调用wait()或waitpid()函数等待子进程完成再退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
1.2、僵尸进程 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait()或waitpid()获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
二、僵尸进程有什么危害？ 2.1、Unix 提供的进程退出机制 Unix 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。
这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait()/ waitpid()来取时才释放。
但这样就导致了问题，如果进程不调用wait()/ waitpid()的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。
2.2、僵尸进程有什么危害？ 僵尸进程的 PID 还占据着，意味着海量的子进程会占据满进程表项，导致后来的进程无法 fock()；僵尸进程的内核栈无法被释放掉(1K 或者 2K大小)，为啥会留着它的内核栈，因为在内核栈的最低端，有着thread_info 结构，它包含着 struct_task 结构，这里面包含着一些退出信息。 2.3、为什么孤儿进程没有危害？ 孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。
2.4、如何避免僵尸进程？ 在Linux系统中，避免僵尸进程的方法包括:
使用wait()或waitpid()函数： 在父进程中调用wait()或waitpid()函数，等待子进程结束并返回状态码，这样可以确保子进程退出后，其资源能够被正常回收，避免产生僵尸进程。使用信号处理程程序：在父进程中注册SIGCHLD信号处理程席，当子进程结束时会向父进程发送该信号，父进程可以在信号处理程序中调用wait()或waitpid()函数回收子进程资源。fork() 两次：第一次fork的子进程在fork完成后直接退出，这样第二次fork得到的子进程就没有爸爸了，它会自动被老祖宗 init 进程收养，init会负责释放它的资源，这样就不会有&#34;僵尸”产生了， " />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c00d2b147ab80ed4a93bc624b0e3d225/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-08T07:00:00+08:00" />
<meta property="article:modified_time" content="2023-06-08T07:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【操作系统】僵尸进程与孤儿进程总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>【操作系统】僵尸进程与孤儿进程总结</h2> 
<p>参考资料：</p> 
<blockquote> 
 <p><a href="https://linux.cn/article-9143-1.html" rel="nofollow">什么是僵尸进程，如何找到并杀掉僵尸进程？</a></p> 
 <p><a href="https://www.cnblogs.com/anker/p/3271773.html" rel="nofollow">孤儿进程与僵尸进程总结</a></p> 
</blockquote> 
<h3><a id="_10"></a>一、僵尸进程与孤儿进程是什么？</h3> 
<p>我们知道在<code>unix</code> / <code>linux</code>中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用<code>wait()</code>或者<code>waitpid()</code>系统调用取得子进程的终止状态。</p> 
<h4><a id="11_14"></a>1.1、孤儿进程</h4> 
<p><strong>孤儿进程：一个父进程退出，此时父进程调用<code>wait()</code>或<code>waitpid()</code>函数等待子进程完成再退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被<code>init</code>进程(进程号为1)所收养，并由<code>init</code>进程对它们完成状态收集工作。</strong></p> 
<h4><a id="12_18"></a>1.2、僵尸进程</h4> 
<p><strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用<code>wait()</code>或<code>waitpid()</code>获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p> 
<h3><a id="_24"></a>二、僵尸进程有什么危害？</h3> 
<h4><a id="21Unix__26"></a>2.1、Unix 提供的进程退出机制</h4> 
<p><code>Unix</code> 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。</p> 
<p>这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过<code>wait()</code>/ <code>waitpid()</code>来取时才释放。</p> 
<p>但这样就导致了问题，<strong>如果进程不调用<code>wait()</code>/ <code>waitpid()</code>的话，</strong> <strong>那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p> 
<h4><a id="22_34"></a>2.2、僵尸进程有什么危害？</h4> 
<ul><li>僵尸进程的 PID 还占据着，意味着海量的子进程会占据满进程表项，导致后来的进程无法 <code>fock()</code>；</li><li>僵尸进程的内核栈无法被释放掉(1K 或者 2K大小)，为啥会留着它的内核栈，因为在内核栈的最低端，有着thread_info 结构，它包含着 struct_task 结构，这里面包含着一些退出信息。</li></ul> 
<h4><a id="23_39"></a>2.3、为什么孤儿进程没有危害？</h4> 
<p><strong>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上</strong>，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。<strong>因此孤儿进程并不会有什么危害。</strong></p> 
<h4><a id="24_45"></a>2.4、如何避免僵尸进程？</h4> 
<p>在Linux系统中，避免僵尸进程的方法包括:</p> 
<ul><li><strong>使用<code>wait()</code>或<code>waitpid()</code>函数</strong>： 在父进程中调用wait()或waitpid()函数，等待子进程结束并返回状态码，这样可以确保子进程退出后，其资源能够被正常回收，避免产生僵尸进程。</li><li><strong>使用信号处理程程序</strong>：在父进程中注册SIGCHLD信号处理程席，当子进程结束时会向父进程发送该信号，父进程可以在信号处理程序中调用wait()或waitpid()函数回收子进程资源。</li><li><strong><code>fork()</code> 两次</strong>：第一次fork的子进程在fork完成后直接退出，这样第二次fork得到的子进程就没有爸爸了，它会自动被老祖宗 init 进程收养，init会负责释放它的资源，这样就不会有"僵尸”产生了，</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/59b89ef79bcdf283ca338201fa097f42/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">BAT脚本--一键打开多个应用/微信多开</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d0efb4c0ca58df216883a99ed55ae439/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">kkfileview介绍安装及使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>