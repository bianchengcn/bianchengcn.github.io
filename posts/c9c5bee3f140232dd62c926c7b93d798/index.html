<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>BurpSuite插件 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="BurpSuite插件" />
<meta property="og:description" content="BurpSuite渗透辅助插件Burp Extensions
BurpSuite 相关收集项目，插件主要是非BApp Store（商店）
插件的安装
JAVA编写的插件：
Python编写的插件：
Python编写的插件，需要使用Jython。Jython本质上是一个Java应用程序，Jython允许编码人员使用Java编码调用Python库。也可以使用Python调用Java的库。
Jython下载地址：
https://www.jython.org/download 下载好之后，添加到Burp。
导入Python编写的插件，导入方法和Java相同。
ApiKit
插件地址：
https://github.com/API-Security/APIKit 插件介绍：
APIKit是基于BurpSuite提供的JavaAPI开发的插件。
APIKit可以主动/被动扫描发现应用泄露的API文档，并将API文档解析成BurpSuite中的数据包用于API安全测试。
目前APIKit v1.0支持的API技术的指纹有：
GraphQL OpenAPI-Swagger SpringbootActuator SOAP-WSDL 安装方法：
打开BurpSuite页面,点击Extender然后选择Extensions,添加APIKit.jar。
然后APIKit会对进入到BurpSuite的流量进行被动扫描。解析完成后可以在APIKit面板查看结果，同样Burpsuite的DashBoard也会有issue提示。
配置说明：
默认情况下Request和Cookie都不开启
Auto Request Sending
选择开启Auto Request Sending后，可以对子API进行自动化鉴权测试，快速发现API未授权访问漏洞。
Send with Cookie
开启Cookie，可以把包的Cookie存下来，生成请求的时候保留Cookie。
使用方法：
被动扫描
默认情况下流经BurpSuite的流量都会进行API探测解析和扫描。
主动扫描
在任何一个Burpsuite可以右键打开更多选项的页面中，都可以点击右键，选择Do API scan来发起一次主动扫描。
API漏洞自动扫描
所有与BurpSuite联动的工具均可联动APIKit。比如xray。（具体方法见github）
BurpShiroPassiveScan
插件地址:
https://github.com/pmiaowu/BurpShiroPassiveScan 插件介绍:
一款基于BurpSuite的被动式shiro检测插件
该插件会对BurpSuite传进来的每个不同的域名&#43;端口的流量进行一次shiro检测
目前的功能如下：
shiro框架指纹检测
shiro加密key检测
检测方法：
检测原理: &gt; https://mp.weixin.qq.com/s/do88_4Td1CSeKLmFqhGCuQ
使用方法
正常的访问网站，访问访问完毕以后, 插件就会自动去进行扫描，如果有结果那么插件就会在以下地方显示
·Extender
·Scanner-Issue activity
tag界面查看漏洞情况" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c9c5bee3f140232dd62c926c7b93d798/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-12T11:38:16+08:00" />
<meta property="article:modified_time" content="2022-02-12T11:38:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">BurpSuite插件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>BurpSuite渗透辅助插件<strong>Burp Extensions</strong></p> 
<p>BurpSuite 相关收集项目，插件主要是非BApp Store（商店）</p> 
<p><strong>插件的安装</strong><br> <strong>JAVA编写的插件：</strong><br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211213150114903-221442755.png" rel="nofollow"><img src="https://images2.imgbox.com/1e/fa/rVAPRvUC_o.png" alt="img"></a></p> 
<p><strong>Python编写的插件：</strong><br> Python编写的插件，需要使用Jython。Jython本质上是一个Java应用程序，Jython允许编码人员使用Java编码调用Python库。也可以使用Python调用Java的库。<br> <strong><a href="https://www.jython.org/download" rel="nofollow">Jython下载地址</a>：</strong></p> 
<pre><code class="prism language-avrasm">https://www.jython.org/download
</code></pre> 
<p>下载好之后，添加到Burp。<br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211213152320440-844317708.png" rel="nofollow"><img src="https://images2.imgbox.com/fd/69/dXKugjZ1_o.png" alt="img"></a></p> 
<p>导入Python编写的插件，导入方法和Java相同。<br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211213152645650-445136513.png" rel="nofollow"><img src="https://images2.imgbox.com/53/dc/MeoebBXA_o.png" alt="img"></a></p> 
<p><strong><a href="https://github.com/API-Security/APIKit">ApiKit</a></strong><br> <strong>插件地址：</strong></p> 
<pre><code class="prism language-bash">https://github.com/API-Security/APIKit
</code></pre> 
<p><strong>插件介绍：</strong><br> APIKit是基于BurpSuite提供的JavaAPI开发的插件。<br> APIKit可以主动/被动扫描发现应用泄露的API文档，并将API文档解析成BurpSuite中的数据包用于API安全测试。<br> 目前APIKit v1.0支持的API技术的指纹有：</p> 
<pre><code class="prism language-mipsasm">GraphQL
OpenAPI-Swagger
SpringbootActuator
SOAP-WSDL
</code></pre> 
<p><strong>安装方法：</strong><br> 打开BurpSuite页面,点击Extender然后选择Extensions,添加APIKit.jar。<br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211213153750026-585911351.png" rel="nofollow"><img src="https://images2.imgbox.com/7c/62/ge2Q7kKd_o.png" alt="img"></a><br> 然后APIKit会对进入到BurpSuite的流量进行被动扫描。解析完成后可以在APIKit面板查看结果，同样Burpsuite的DashBoard也会有issue提示。<br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211213153930846-238176628.png" rel="nofollow"><img src="https://images2.imgbox.com/e0/76/WP1CGA6n_o.png" alt="img"></a><br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211213154147880-745559743.png" rel="nofollow"><img src="https://images2.imgbox.com/67/c3/3fD24lAl_o.png" alt="img"></a></p> 
<p><strong>配置说明：</strong><br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211213154424091-840166321.png" rel="nofollow"><img src="https://images2.imgbox.com/01/a9/0t75Chrq_o.png" alt="img"></a><br> 默认情况下Request和Cookie都不开启</p> 
<p>Auto Request Sending<br> 选择开启Auto Request Sending后，可以对子API进行自动化鉴权测试，快速发现API未授权访问漏洞。</p> 
<p>Send with Cookie<br> 开启Cookie，可以把包的Cookie存下来，生成请求的时候保留Cookie。</p> 
<p><strong>使用方法：</strong><br> 被动扫描<br> 默认情况下流经BurpSuite的流量都会进行API探测解析和扫描。</p> 
<p>主动扫描<br> 在任何一个Burpsuite可以右键打开更多选项的页面中，都可以点击右键，选择Do API scan来发起一次主动扫描。<br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211213161545977-849171249.png" rel="nofollow"><img src="https://images2.imgbox.com/a2/5b/YE7hEA43_o.png" alt="img"></a></p> 
<p>API漏洞自动扫描<br> 所有与BurpSuite联动的工具均可联动APIKit。比如xray。（具体方法见github）</p> 
<p><strong><a href="https://github.com/pmiaowu/BurpShiroPassiveScan">BurpShiroPassiveScan</a></strong><br> <strong>插件地址:</strong></p> 
<pre><code class="prism language-bash">https://github.com/pmiaowu/BurpShiroPassiveScan
</code></pre> 
<p><strong>插件介绍:</strong><br> 一款基于BurpSuite的被动式shiro检测插件<br> 该插件会对BurpSuite传进来的每个不同的域名+端口的流量进行一次shiro检测<br> 目前的功能如下：<br> shiro框架指纹检测<br> shiro加密key检测</p> 
<p><strong>检测方法：</strong><br> 检测原理: &gt; https://mp.weixin.qq.com/s/do88_4Td1CSeKLmFqhGCuQ</p> 
<p><strong>使用方法</strong><br> 正常的访问网站，访问访问完毕以后, 插件就会自动去进行扫描，如果有结果那么插件就会在以下地方显示<br> ·Extender<br> ·Scanner-Issue activity<br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211224173123515-792927277.png" rel="nofollow"><img src="https://images2.imgbox.com/e7/43/nXRr7VB2_o.png" alt="img"></a></p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211224173459433-1195002103.png" rel="nofollow"><img src="https://images2.imgbox.com/90/80/9VilF9l0_o.png" alt="img"></a></p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211224173641398-489025356.png" rel="nofollow"><img src="https://images2.imgbox.com/b9/20/TtH0onNA_o.png" alt="img"></a></p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211224173918402-1218750721.png" rel="nofollow"><img src="https://images2.imgbox.com/7e/ca/utKYmBZE_o.png" alt="img"></a></p> 
<p><strong>tag界面查看漏洞情况</strong><br> ·waiting for test results = 扫描shiro key 中<br> ·shiro key scan out of memory error = 扫描shiro key时,发生内存错误<br> ·shiro key scan diff page too many errors = 扫描shiro key时,页面之间的相似度比对失败太多<br> ·shiro key scan task timeout = 扫描shiro key时,任务执行超时<br> ·shiro key scan unknown error = 扫描shiro key时,发生未知错误<br> ·[-] not found shiro key = 没有扫描出 shiro key<br> ·[+] found shiro key: xxxxxx = 扫描出了 shiro key</p> 
<p><strong><a href="https://github.com/potats0/shiroPoc">ShiroScan</a></strong><br> <strong>Github地址：</strong></p> 
<pre><code class="prism language-bash">https://github.com/potats0/shiroPoc
</code></pre> 
<p><strong>插件介绍：</strong><br> 采⽤⽆需利⽤链的检测⽅式(⽆论是否出⽹都可以检测)，被动扫描Shiro框架，并⾃动爆破key，⽀持⾃<br> 定义键。【判断 shiro 的 key ，之前采⽤的逻辑就是 YSO 的 URLDNS 针对 dnslog 进⾏处理或者直接使⽤CC进<br> ⾏盲打或者⼯具⼀把梭（dnslog的⽅式）。这种会存在⼀些⼩问题，⽐如当这个 shiro 不出⽹ ，且 gadget 不是<br> CC的情况下，可能就会漏过⼀些漏洞。】（这里就不细讲了，需要的师傅点上方的github地址自行下载即可）</p> 
<p><strong><a href="https://github.com/pmiaowu/BurpFastJsonScan">FastJsonScan</a></strong><br> <strong>Github地址</strong></p> 
<pre><code class="prism language-bash">https://github.com/pmiaowu/BurpFastJsonScan
</code></pre> 
<p>【扫描⽐较⼈性化，扫没扫到都告诉你⼀声。dnslog.cn进⾏出⽹检查】</p> 
<p><strong>Github地址</strong></p> 
<pre><code class="prism language-ruby">https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>bigsizeme<span class="token operator">/</span>fastjson<span class="token operator">-</span>check<span class="token operator">/</span>releases
</code></pre> 
<p>【在上⾯的基础上改进，增加站点是否出⽹探测，⽀持⼀键⽣成回显POC，但是多个利⽤链，没法确定具体使⽤哪<br> 个利⽤链】<br> 1、增加burp内置BurpCollaborator【Burp内置dnslog】进⾏出⽹探测<br> 2、针对不出⽹payload总结⽀持⼀键⽣成回显payload(15种)</p> 
<p><strong>Github地址</strong></p> 
<pre><code class="prism language-bash">https://github.com/zilong3033/fastjsonScan
</code></pre> 
<p>【只有扫到了才告诉你，⽐如你想检测⼀个站有没有fastjson，你发送到插件扫描，扫了半天，不知道是没洞还是<br> 没扫完】</p> 
<ol><li> <p>在原来的被动扫描上⽀持主动扫描，由于主动扫描发送数据包较多，故会多次扫描。</p> </li><li> <p>在原来的rmi协议上⽀持ldap协议。</p> </li><li> <p>⽀持fastjson&lt;=1.2.24和1.2.33&lt;=fatjson&lt;=1.2.47回显和不出⽹检测⽅案 ,检测后，发送到Repeater<br> 中，便可以利⽤。</p> </li><li> <p>⽀持fastjson&lt;=1.2.24和1.2.33&lt;=fatjson&lt;=1.2.47的延时检测。</p> </li><li> <p>⽀持fastjson&lt;=1.2.68 的DNSlog检测</p> <p><strong>Github地址</strong></p> </li></ol> 
<pre><code class="prism language-bash">https://github.com/pmiaowu/BurpFastJsonScan
</code></pre> 
<p><strong>简介</strong><br> 该插件会对BurpSuite传进来的带有json数据的请求包进行检测<br> 目前的功能如下<br> ·命令回显<br> ·远程命令执行<br> 默认使用jdk1.8编译<br> 在最新版的burp2.x中jdk为1x,会导致插件不可用,请自行下载源码使用当前电脑的jdk1x进行编译</p> 
<p><strong>检测规则</strong><br> ·POST 的内容为json<br> ·GET 的参数内容为json<br> ·POST 的参数内容为json<br> ·Cookie 的参数内容为json</p> 
<pre><code class="prism language-mipsasm">例子:
GET, POST, Cookie 有个参数 json
json = {"aaa":"66666"}
那么就会去检测
json的这种就是请求包的内容直接就是json不带参数的那种, 也会去检测
</code></pre> 
<p><strong>使用方法</strong><br> 我们正常去访问网站, 如果站点的某个请求出现了 json 那么该插件就会去尝试检测<br> 访问完毕以后, 插件就会自动去进行扫描<br> 如果有结果那么插件就会在以下地方显示<br> ·Tag<br> ·Extender<br> ·Scanner-Issue activity</p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211224184033587-1582873160.png" rel="nofollow"><img src="https://images2.imgbox.com/84/44/bEKklnd8_o.png" alt="img"></a></p> 
<p><strong>tag界面查看漏洞情况</strong><br> 分别会返回</p> 
<ul><li>request no json = 请求没有json</li><li>request json no eligible = 请求json不符合条件</li><li>the number of website problems has exceeded = exceeded 超出网站问题的数量</li><li>the number of website scans exceeded = 超出网站可扫描次数</li><li>waiting for test results = 等待测试结果</li><li>[+] found fastJson command execution = 查找到fastJson命令执行</li><li>[-] not found fastJson command execution = 没有查找到fastJson命令执行</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> scan task timed out = 扫描任务超时</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> unknown error = 未知的错误</li></ul> 
<p>当发生 unknown error 的时候,可以尝试在下方中查看错误详情</p> 
<p><strong><a href="https://github.com/c0ny1/chunked-coding-converter">chunked coding converter</a></strong><br> <strong>Github地址：</strong></p> 
<pre><code class="prism language-bash">https://github.com/c0ny1/chunked-coding-converter
</code></pre> 
<p><strong>分块传输简单介绍：</strong><br> 分块传输编码（Chunked transfer encoding）是HTTP中的⼀种数据传输机制，在HTTP/1.1前，数据的发送是<br> 由 Content-Length 去决定的，它规定了⼀个包的⻓度，服务器也是按照这个去进⾏处理的。在HTTP/1.1中，服<br> 务器发送给客户端的数据可以分成多个部分，使⽤分块传输的时候，数据会被分解出⼀个个⼩块，这样服务器就不<br> 需要预先知道总数据的⼤概⻓度，接收到⼀个个块进⾏处理就⾏了。简⽽⾔之，就是把数据包分成⼀块⼀块的发<br> 送，从⽽对WAF进⾏绕过。<br> 在使⽤分块传输时，响应头⾥需要添加 Transfer-Encoding: Chunked ，去表明是要进⾏分块传输内容的。<br> 本插件主要用于分块传输绕WAF，不了解分块传输绕WAF可以参考下列文章<br> ·<a href="https://www.anquanke.com/post/id/169738" rel="nofollow">利用分块传输吊打所有WAF</a><br> ·<a href="https://www.freebuf.com/news/193659.html" rel="nofollow">在HTTP协议层面绕过WAF</a><br> ·<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjA4MTQ1NQ==&amp;mid=2247483787&amp;idx=1&amp;sn=54c33727696f8ee6d67f997acc11ab89&amp;chksm=cf36f9cbf84170dd7da9b48b3365fb05d7ccec6bdeff480d0c38962f712e400a40b2b38dc467&amp;token=360242838&amp;lang=zh_CN#rd" rel="nofollow">编写Burp分块传输插件绕WAF</a><br> ·<a href="https://gv7.me/articles/2021/java-deserialized-data-bypasses-waf-through-sleep-chunked/" rel="nofollow">Java反序列化数据绕WAF之延时分块传输</a></p> 
<p><strong>插件使用</strong><br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211224185828486-2078676114.png" rel="nofollow"><img src="https://images2.imgbox.com/86/c7/6hvm2Y56_o.png" alt="img"></a><br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211224190219578-839783283.png" rel="nofollow"><img src="https://images2.imgbox.com/18/68/3ABTIXbV_o.png" alt="img"></a></p> 
<p>可以和Sqlmap联动，设置用于Proxy模块之后，Sqlmap指定代理：</p> 
<pre><code class="prism language-cpp">sqlmap<span class="token punctuation">.</span>py <span class="token operator">-</span>r post<span class="token punctuation">.</span>txt <span class="token operator">--</span>proxy<span class="token operator">=</span>http<span class="token operator">:</span><span class="token comment">//127.0.0.1:8080 --os-shell</span>
</code></pre> 
<p><strong><a href="https://github.com/d3vilbug/HackBar">HackBar</a></strong><br> <strong>Github地址：</strong></p> 
<pre><code class="prism language-bash">https://github.com/d3vilbug/HackBar
</code></pre> 
<p>将渗透测试过程中用到的浏览器插件集成到了Burp上。<br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211224190945211-506679802.png" rel="nofollow"><img src="https://images2.imgbox.com/6e/9f/A1ClC77x_o.png" alt="img"></a></p> 
<p><strong><a href="https://github.com/bit4woo/U2C">U2C（Unicode To Chinese）</a></strong><br> <strong>Github地址：</strong></p> 
<pre><code class="prism language-bash">https://github.com/bit4woo/U2C
</code></pre> 
<p>Unicode 转中⽂ 的burp suite插件：<br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225011357916-1257572011.png" rel="nofollow"><img src="https://images2.imgbox.com/ee/8a/aFdGzLhy_o.png" alt="img"></a></p> 
<p><strong><a href="https://github.com/ScriptKid-Beta/Unexpected_information">Unexpected information</a></strong><br> <strong>Github地址:</strong></p> 
<pre><code class="prism language-bash">https://github.com/ScriptKid-Beta/Unexpected_information
</code></pre> 
<p>用来标记请求包中的一些敏感信息、JS接口和一些特殊字段，防止我们疏忽了一些数据包，它被命名为“Unexpected information”，使用它可能会有意外的收获信息。</p> 
<p><strong>支持列表</strong><br> ·身份证信息<br> ·手机号信息<br> ·IP信息<br> ·邮箱信息<br> ·JS文件API接口路径<br> ·JS文件URL<br> ·特殊字段(password、method: “post”…#57)<br> ·JSON Web Token<br> ·Shiro(rememberMe=delete)<br> ·双向检测<br> ·高亮显示</p> 
<p><strong>高亮模式</strong><br> ·邮箱 -&gt; 黄色<br> ·内网IP -&gt; 红色<br> ·手机号码 -&gt; 绿色<br> ·身份证号码 -&gt; 绿色<br> ·其他 -&gt; 灰色(v2.3.1+)<br> 当如数据包中存在有相关的对应信息(如手机号码、IP地址、邮箱、身份证号码等)存在时HTTP history标签页中的对应请求中自动标记颜色高亮，并且开启一个新的标签页名为”Unexpected information”显示匹配到的信息。</p> 
<p><strong>使用方法及效果</strong><br> BurpSuite &gt;&gt; Extender &gt;&gt; Extensions &gt;&gt; Add &gt;&gt; Extension type: Java &gt;&gt; Select file …&gt;&gt; 选择对应的插件(Unexpected information.jar)<br> 注意：避免使用中文目录<br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225012504243-1665390557.png" rel="nofollow"><img src="https://images2.imgbox.com/b7/4f/tAYVQcfk_o.png" alt="img"></a></p> 
<p>可以筛选出匹配到的敏感信息：<br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225012913594-1872329810.png" rel="nofollow"><img src="https://images2.imgbox.com/82/6c/2kXPY7Ng_o.png" alt="img"></a></p> 
<p><strong><a href="https://github.com/gh0stkey/HaE">HaE</a></strong><br> <strong>Github地址：</strong></p> 
<pre><code class="prism language-bash">https://github.com/gh0stkey/HaE
</code></pre> 
<p><strong>相关规则</strong></p> 
<pre><code class="prism language-bash">https://gh0st.cn/HaE/
</code></pre> 
<p><strong>插件介绍：</strong><br> HaE是基于 BurpSuite 插件 JavaAPI 开发的请求高亮标记与信息提取的辅助型插件。<br> 该插件可以通过自定义正则的方式匹配响应报文或请求报文，可以自行决定符合该自定义正则匹配的相应请求是否需要高亮标记、信息提取。</p> 
<p><strong>使用方法：</strong><br> 插件装载: Extender——Extensions——Add——Select File——Next<br> 初次装载HaE会初始化配置文件，默认配置文件内置一个正则: Email，初始化的配置文件会放在与BurpSuite Jar包同级目录下。<br> 除了初始化的配置文件外，还有Setting.yml，该文件用于存储配置文件路径；HaE支持自定义配置文件路径，你可以通过点击Select File按钮进行选择自定义配置文件。</p> 
<p><strong>插件优点：</strong><br> 1、多选项自定义控制适配需求<br> 2、多颜色高亮分类，将BurpSuite的所有高亮颜色集成: red, orange, yellow, green, cyan, blue, pink, magenta, gray<br> 3、颜色升级算法: 利用下标的方式进行优先级排序，当满足2个同颜色条件则以优先级顺序上升颜色（例如: 两个正则，颜色为橘黄色，该请求两个正则都匹配到了，那么将升级为红色）<br> 4、配置文件采用YAML格式存储，更加便于阅读和修改<br> 5、内置简单缓存，在“多正则、大数据”的场景下减少卡顿现象<br> 6、支持标签分页，点击…即可添加新的标签页，对着标签页右键即可删除<br> 7、高亮信息添加的同时添加Comment，便于查找请求</p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225013916467-1248936632.png" rel="nofollow"><img src="https://images2.imgbox.com/e3/c2/gN5vaIxG_o.png" alt="img"></a></p> 
<p>Burp也支持仅显示高亮敏感秘文：</p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225014214302-1561581034.png" rel="nofollow"><img src="https://images2.imgbox.com/50/0a/vVfp9mHZ_o.png" alt="img"></a></p> 
<p><strong><a href="https://github.com/TheKingOfDuck/burpFakeIP">FakeIP</a></strong><br> <strong>Github地址：</strong></p> 
<pre><code class="prism language-bash">https://github.com/TheKingOfDuck/burpFakeIP
</code></pre> 
<pre><code class="prism language-bash">https://github.com/c0ny1/HTTPHeadModifer
</code></pre> 
<p><strong>插件介绍：</strong><br> 四个功能<br> 伪造指定IP<br> 伪造本地IP<br> 伪造随机IP<br> 伪造随机ip爆破的先决条件可以伪造ip绕过服务器限制</p> 
<p><strong>伪造指定IP：</strong><br> 在Repeater模块右键选择fakeIp菜单,然后点击inputIP功能,然后输入指定的ip：<br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225015153505-1490518621.png" rel="nofollow"><img src="https://images2.imgbox.com/bf/d6/2D76a9CF_o.png" alt="img"></a></p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225015245746-1552546987.png" rel="nofollow"><img src="https://images2.imgbox.com/f3/15/HG6lovtH_o.png" alt="img"></a></p> 
<p>程序会自动添加所有可伪造得字段到请求头中<br> <a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225015308324-1679135692.png" rel="nofollow"><img src="https://images2.imgbox.com/9f/0a/5zyWYnV6_o.png" alt="img"></a></p> 
<p><strong>伪造本地IP</strong><br> 在Repeater模块右键选择fakeIp菜单,然后点击127.0.0.1功能：</p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225015850630-33342724.png" rel="nofollow"><img src="https://images2.imgbox.com/a8/a0/sbB2wheZ_o.png" alt="img"></a></p> 
<p><strong>伪造随机IP</strong><br> 在Repeater模块右键选择fakeIp菜单,然后点击randomIP功能：</p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225020010972-1208761360.png" rel="nofollow"><img src="https://images2.imgbox.com/db/53/tY1eUitz_o.png" alt="img"></a></p> 
<p><strong>随机IP爆破：</strong><br> 伪造随机ip爆破是本插件最核心的功能。</p> 
<p>将数据包发送到Intruder模块,在Positions中切换Attack type为Pitchfork模式,选择好有效的伪造字段,以及需要爆破的字段:</p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225020119078-1385108122.png" rel="nofollow"><img src="https://images2.imgbox.com/3a/d3/aPsQWjIj_o.png" alt="img"></a></p> 
<p>按照箭头顺序将Payload来源设置为Extensin-generated,并设置负载伪fakeIpPayloads,然后设置第二个变量</p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225020206168-1685058945.png" rel="nofollow"><img src="https://images2.imgbox.com/ab/4f/uST7U0T9_o.png" alt="img"></a></p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225020230236-1723893682.png" rel="nofollow"><img src="https://images2.imgbox.com/bc/76/G9PGtFxH_o.png" alt="img"></a></p> 
<p>点击Start attack开始爆破</p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225020309068-1684050152.png" rel="nofollow"><img src="https://images2.imgbox.com/a6/07/2Irij9yj_o.png" alt="img"></a></p> 
<p>如上图,实现每次爆破都使用不同的伪ip进行,避免被ban</p> 
<p><strong><a href="https://github.com/sting8k/BurpSuite_403Bypasser">403Bypass</a></strong><br> <strong>Github地址：</strong></p> 
<pre><code class="prism language-bash">https://github.com/sting8k/BurpSuite_403Bypasser
</code></pre> 
<p>这个插件主要功能是⽤来bypass403⻚⾯的，举个例⼦，⽐如我们有时候看到很多⽹站限制外部访问，访问的话直接显示403，我们可能改⼀个IP头为本地127.0.0.1我们就能绕过这个限制，这个插件可以全⾃动的来帮我们验证。</p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225020544104-308747779.png" rel="nofollow"><img src="https://images2.imgbox.com/f8/64/CBNwJEBW_o.png" alt="img"></a></p> 
<p><strong><a href="https://github.com/InitRoot/BurpJSLinkFinde">Jslinkfinder</a></strong><br> <strong>Github地址：</strong></p> 
<pre><code class="prism language-bash">https://github.com/InitRoot/BurpJSLinkFinde
</code></pre> 
<p>Burp 扩展，⽤于被动扫描端点链接的 JS ⽂件。<br> ·将结果导出到⽂本⽂件<br> ·排除特定的“js”⽂件，例如 jquery、google-analytics<br> 被动扫描，增加扩展后不⽤管（⼀些渗透测试中，往往需要翻看⽹站的JS⽂件，去找找有没有什么接⼝之类的，⽽看JS⽐较费劲，这款插件就替我们简化了这⼀步骤，直接去看链接就好了）</p> 
<p><a href="https://img2020.cnblogs.com/blog/2309986/202112/2309986-20211225021518083-128633880.png" rel="nofollow"><img src="https://images2.imgbox.com/ae/29/GhlNwAra_o.png" alt="img"></a></p> 
<p><strong><a href="https://github.com/c0ny1/jsEncrypter">JsEncrypter</a></strong><br> <strong>Github地址：</strong></p> 
<pre><code class="prism language-bash">https://github.com/c0ny1/jsEncrypter
</code></pre> 
<p>本插件使用phantomjs启动前端加密函数对数据进行加密，方便对加密数据输入点进行fuzz，比如可以使用于前端加密传输爆破等场景。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f7fbfeb95805365eb5d1bd6a1763cfe5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">centos 安装 RabbitMQ</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba200fa32df2fee0686883b3ace0d404/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Godot】添加菜单按钮</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>