<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python配置管理的几种方式 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python配置管理的几种方式" />
<meta property="og:description" content="一、 为什么要使用配置 如果我们在较复杂的项目中不使用配置文件，我们可能会面临下面的情况：
你决定更改你的项目中数据库的 host， 因为你要将项目从测试环境转移到实际的上产环境中。如果你的项目中多个位置用到了这个 host，那你不得不一个一个找到这些位置再修改成新的 host。花了半天，然后过了一天，你发现项目在生产环境有些问题，需要重新移回测试环境，你得再次修改，这样工作很繁琐很不优雅。你开发了一个很棒的开源项目，你想将其放到版本控制系统例如github上，但是你服务器的主机的地址、账号、密码也都上传上去了，但是你没有意识到，直到有个 bad guy 拿到了你的信息，从你的服务器窃取信息、攻击你的服务器，让你产生了极大的损失。然后你想把程序改动一下，把涉密的信息比如地址密码都删掉，可是由于版本控制的原因，别人依然能看到你以前版本的代码。于是你不得不改掉你的账户、密码等，真的是个悲伤的开源项目经历。 但是，如果你使用了配置管理呢，那会有以下几个优点：
这样就提高了代码的重用性，不再每次都去修改代码内部这意味着其他不太懂你代码内部的人也可以使用你的项目，只用根据需求更改配置即可有利于团队协作有利于安全数据/秘密数据的管理 二、Python 中进行配置管理的几种方式 由于使用 Python 较多，因此基于 Python 进行配置管理的相关说明，当然其他语言也都是大同小异，主要思想还是不变。
2.1 使用 Python 内置的数据结构(如字典) 2.1.1单个文件下的单个配置 我们很自然就能想到这一点，例如以下代码：
# main.py import pymysql DATABASE_CONFIG = { &#39;host&#39;:&#39;localhost&#39;, &#39;dbname&#39;:&#39;db&#39;, &#39;user&#39;:&#39;user&#39;, &#39;password&#39;:&#39;pwd&#39;, &#39;port&#39;:3306 } def connect_db_do_something1(dbname): if dbname != config.DATABASE_CONFIG[&#39;dbname&#39;]: raise ValueError(&#34;Couldn&#39;t not find DB with given name&#34;) conn = pymysql.connect(host=config.DATABASE_CONFIG[&#39;host&#39;], user=config.DATABASE_CONFIG[&#39;user&#39;], password=config.DATABASE_CONFIG[&#39;password&#39;], db=config.DATABASE_CONFIG[&#39;dbname&#39;]) &#39;&#39;&#39; do something 1 &#39;&#39;&#39; def connect_db_do_something2(dbname): if dbname != config." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/4ca244d76a6013510d1c548740f75c67/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-05T18:25:00+08:00" />
<meta property="article:modified_time" content="2019-07-05T18:25:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python配置管理的几种方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"> 
 <h3 id="一-为什么要使用配置">一、 为什么要使用配置</h3> 
 <p>如果我们在较复杂的项目中不使用配置文件，我们可能会面临下面的情况：</p> 
 <ul><li>你决定更改你的项目中数据库的 host， 因为你要将项目从测试环境转移到实际的上产环境中。如果你的项目中多个位置用到了这个 host，那你不得不一个一个找到这些位置再修改成新的 host。花了半天，然后过了一天，你发现项目在生产环境有些问题，需要重新移回测试环境，你得再次修改，这样工作很繁琐很不优雅。</li><li>你开发了一个很棒的开源项目，你想将其放到版本控制系统例如github上，但是你服务器的主机的地址、账号、密码也都上传上去了，但是你没有意识到，直到有个 bad guy 拿到了你的信息，从你的服务器窃取信息、攻击你的服务器，让你产生了极大的损失。然后你想把程序改动一下，把涉密的信息比如地址密码都删掉，可是由于版本控制的原因，别人依然能看到你以前版本的代码。于是你不得不改掉你的账户、密码等，真的是个悲伤的开源项目经历。</li></ul> 
 <p>但是，如果你使用了配置管理呢，那会有以下几个优点：</p> 
 <ul><li>这样就提高了代码的重用性，不再每次都去修改代码内部</li><li>这意味着其他不太懂你代码内部的人也可以使用你的项目，只用根据需求更改配置即可</li><li>有利于团队协作</li><li>有利于安全数据/秘密数据的管理</li></ul> 
 <h3 id="二python-中进行配置管理的几种方式">二、Python 中进行配置管理的几种方式</h3> 
 <p>由于使用 Python 较多，因此基于 Python 进行配置管理的相关说明，当然其他语言也都是大同小异，主要思想还是不变。</p> 
 <h4 id="使用-python-内置的数据结构如字典">2.1 使用 Python 内置的数据结构(如字典)</h4> 
 <h5 id="单个文件下的单个配置">2.1.1单个文件下的单个配置</h5> 
 <p>我们很自然就能想到这一点，例如以下代码：</p> 
 <pre><code class="language-python"><code># main.py

import pymysql

DATABASE_CONFIG  = {
    'host':'localhost',
    'dbname':'db',
    'user':'user',
    'password':'pwd',
    'port':3306
}

def connect_db_do_something1(dbname):
    if dbname != config.DATABASE_CONFIG['dbname']:
        raise ValueError("Couldn't not find DB with given name")
    conn = pymysql.connect(host=config.DATABASE_CONFIG['host'],
                           user=config.DATABASE_CONFIG['user'],
                           password=config.DATABASE_CONFIG['password'],
                           db=config.DATABASE_CONFIG['dbname'])
    '''
    do something 1
    '''

def connect_db_do_something2(dbname):
    if dbname != config.DATABASE_CONFIG['dbname']:
        raise ValueError("Couldn't not find DB with given name")
    conn = pymysql.connect(host=config.DATABASE_CONFIG['host'],
                           user=config.DATABASE_CONFIG['user'],
                           password=config.DATABASE_CONFIG['password'],
                           db=config.DATABASE_CONFIG['dbname'])
    '''
    do something 2
    '''

connect_db_do_something1('db')
connect_db_do_something2('db')</code></code></pre> 
 <p>在上面的代码中，我们可以看到，同一数据库配置，我们反复使用了两次，如果我们需要更改数据库相关的数据如<code>password</code>，我们不需要在两个方法内部修改，而是只用修改<code>DATABASE_CONFIG</code>字典中的相关值即可。和以前没有配置管理的时候相比，减少了太多的工作量了。</p> 
 <h5 id="多个文件下的单个配置">2.1.2多个文件下的单个配置</h5> 
 <p>但是当你的项目开始变得复杂的时候，你的文件就不止一个这么简单了，这时候如果我需要在 <code>main2.py</code> 里面需要用 <code>DATABASE_CONFIG</code> 的时候就不是很方便了，因为如果直接 <code>import main</code> 的时候，虽然能够使用 <code>main.DATABASE_CONFIG</code> ，但同时 <code>mian.py</code> 中的</p> 
 <pre><code class="language-python"><code>connect_db_do_something1('db')
connect_db_do_something2('db')</code></code></pre> 
 <p>也被执行了，这可不是我们想看到的，因此我们有了新的需求，能在同一个项目下的不同文件里简单快速的导入我们的数据库配置 <code>DATABASE_CONFIG</code>，于是我们想出了下面的方法来解决这个问题：</p> 
 <pre><code class="language-python"><code># config.py
DATABASE_CONFIG = {
    'host': 'localhost',
    'dbname': 'db',
    'user': 'user',
    'password': 'pwd',
    'port': 3306
}

# main1.py
import pymysql
import config

def connect_db_do_something1(dbname):
    if dbname != config.DATABASE_CONFIG['dbname']:
        raise ValueError("Couldn't not find DB with given name")
    conn = pymysql.connect(host=config.DATABASE_CONFIG['host'],
                           user=config.DATABASE_CONFIG['user'],
                           password=config.DATABASE_CONFIG['password'],
                           db=config.DATABASE_CONFIG['dbname'])
    '''
    do something 1
    '''
connect_db_do_something1('db')

# main2.py
import pymysql
import config

def connect_db_do_something2(dbname):
    if dbname != config.DATABASE_CONFIG['dbname']:
        raise ValueError("Couldn't not find DB with given name")
    conn = pymysql.connect(host=config.DATABASE_CONFIG['host'],
                           user=config.DATABASE_CONFIG['user'],
                           password=config.DATABASE_CONFIG['password'],
                           db=config.DATABASE_CONFIG['dbname'])
    '''
    do something 2
    '''
connect_db_do_something2('db')</code></code></pre> 
 <p>按照上面的代码，我们可以在两个不同的文件 <code>main1.py</code> 和 <code>main2.py</code> 中分别引用 <code>config.py</code> 中配置了，我们的配置管理看起来更进一步了。</p> 
 <h5 id="单个文件下的多个配置">2.1.3 单个文件下的多个配置</h5> 
 <p>有可能我们的项目需要多个配置文件，比如测试环境和生产环境。先从单个文件讲起，我们可以采用如下解决方案：</p> 
 <pre><code class="language-python"><code># config.py
class Config:
    APP_NAME = 'myapp'
    SECRET_KEY = 'secret-key-of-myapp'
    ADMIN_NAME = 'administrator'

    AWS_DEFAULT_REGION = 'ap-northeast-2'
    
    STATIC_PREFIX_PATH = 'static'
    ALLOWED_IMAGE_FORMATS = ['jpg', 'jpeg', 'png', 'gif']
    MAX_IMAGE_SIZE = 5242880 # 5MB


class DevelopmentConfig(Config):
    DEBUG = True
    
    AWS_ACCESS_KEY_ID = 'aws-access-key-for-dev'
    AWS_SECERT_ACCESS_KEY = 'aws-secret-access-key-for-dev'
    AWS_S3_BUCKET_NAME = 'aws-s3-bucket-name-for-dev'
    
    DATABASE_URI = 'database-uri-for-dev'


class TestConfig(Config):
    DEBUG = True
    TESTING = True
    
    AWS_ACCESS_KEY_ID = 'aws-access-key-for-test'
    AWS_SECERT_ACCESS_KEY = 'aws-secret-access-key-for-test'
    AWS_S3_BUCKET_NAME = 'aws-s3-bucket-name-for-test'
    
    DATABASE_URI = 'database-uri-for-dev'
  

class ProductionConfig(Config):
    DEBUG = False

    AWS_ACCESS_KEY_ID = 'aws-access-key-for-prod'
    AWS_SECERT_ACCESS_KEY = 'aws-secret-access-key-for-prod'
    AWS_S3_BUCKET_NAME = 'aws-s3-bucket-name-for-prod'

    DATABASE_URI = 'database-uri-for-dev'

# main.py
import sys
import config
import sys
import config

'''
do some important things
'''

if __name__ == '__main__':
    env = sys.argv[1] if len(sys.argv) &gt; 2 else 'dev'
    
    if env == 'dev':
        app.config = config.DevelopmentConfig
    elif env == 'test':
        app.config = config.TestConfig
    elif env == 'prod':
        app.config = config.ProductionConfig
    else:
        raise ValueError('Invalid environment name')</code></code></pre> 
 <p>这样我们就可以从一个配置文件中获取不同级别的不同配置了。</p> 
 <h5 id="多个文件下的多个配置">2.1.4 多个文件下的多个配置</h5> 
 <p>和上面类似，只不过换成了从不同的文件中读取同一个配置文件的不同配置：</p> 
 <pre><code class="language-python"><code># config.py
class Config:
    APP_NAME = 'myapp'
    SECRET_KEY = 'secret-key-of-myapp'
    ADMIN_NAME = 'administrator'

    AWS_DEFAULT_REGION = 'ap-northeast-2'
    
    STATIC_PREFIX_PATH = 'static'
    ALLOWED_IMAGE_FORMATS = ['jpg', 'jpeg', 'png', 'gif']
    MAX_IMAGE_SIZE = 5242880 # 5MB

    
class DevelopmentConfig(Config):
    DEBUG = True
    
    AWS_ACCESS_KEY_ID = 'aws-access-key-for-dev'
    AWS_SECERT_ACCESS_KEY = 'aws-secret-access-key-for-dev'
    AWS_S3_BUCKET_NAME = 'aws-s3-bucket-name-for-dev'
    
    DATABASE_URI = 'database-uri-for-dev'
    
class TestConfig(Config):
    DEBUG = True
    TESTING = True
    
    AWS_ACCESS_KEY_ID = 'aws-access-key-for-test'
    AWS_SECERT_ACCESS_KEY = 'aws-secret-access-key-for-test'
    AWS_S3_BUCKET_NAME = 'aws-s3-bucket-name-for-test'
    
    DATABASE_URI = 'database-uri-for-dev'
  

class ProductionConfig(Config):
    DEBUG = False

    AWS_ACCESS_KEY_ID = 'aws-access-key-for-prod'
    AWS_SECERT_ACCESS_KEY = 'aws-secret-access-key-for-prod'
    AWS_S3_BUCKET_NAME = 'aws-s3-bucket-name-for-prod'

    DATABASE_URI = 'database-uri-for-dev'


class CIConfig:
    SERVICE = 'travis-ci'
    HOOK_URL = 'web-hooking-url-from-ci-service'


# main1.py
import config

dev_config = config.DevelopmentConfig
'''
do something
'''

# main2.py
import config

app.ci = config.CIConfig
'''
do otherthing
'''</code></code></pre> 
 <p>这样使用更加灵活了，从不同的文件里读取不同的配置，而我们对于配置的增删改只需要在 <code>config.py</code> 中进行，配置管理技能再次进阶！</p> 
 <h4 id="使用外部配置文件">2.2 使用外部配置文件</h4> 
 <p>比起使用 Python 内建的数据结构，更加通用的方法是使用外部配置文件，因为这些文件只会被视为配置文件，而不会像 <code>config.py</code> 一样有代码的属性。外部配置文件的格式多种多样，我们在使用它的时候会根据文件格式有不同的读取方式。例如：<code>*.yaml</code> 或者 <code>*.yml</code>、<code>*.json</code>、<code>*.cfg</code> 或 <code>*.conf</code> 、<code>*.ini</code> ， 甚至是你自定义的文件 <code>*.yourname</code> 。</p> 
 <h5 id="yaml">2.2.1 YAML</h5> 
 <blockquote> 
  <p>YAML（/ˈjæməl/，尾音类似camel骆驼）是一个可读性高，用来表达数据序列化的格式。YAML参考了其他多种语言，包括：C语言、Python、Perl，并从XML、电子邮件的数据格式（RFC 2822）中获得灵感。Clark Evans在2001年首次发表了这种语言[1]，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者[2]。当前已经有数种编程语言或脚本语言支持（或者说解析）这种语言。<br> ----- 中文维基百科</p> 
 </blockquote> 
 <p>YAML 看起来像下面这种格式：</p> 
 <pre class="yaml"><code>mysql:
    host: localhost
    dbname: db
    user: user
    passwd: pwb
    port: 3306
other:
    host: other_host
    dbname: other_db
    user: other_user
    passwd: other_pwb
    port: 3306</code></pre> 
 <p>可以通过类似下面的代码来读取里面的内容：</p> 
 <pre><code class="language-python"><code>import yaml

with open("config.yml", 'r') as ymlfile:
    cfg = yaml.load(ymlfile)

print(cfg['mysql'])</code></code></pre> 
 <p>将输出以下内容</p> 
 <pre><code class="language-python"><code>{'host': 'localhost',
 'dbname': 'db',
 'user': 'user',
 'password': 'pwd',
 'port': 3306}</code></code></pre> 
 <p>如果需要从 python 写入配置到 YAML 也很容易，只需要使用 <code>yaml.dump(dict)</code> 即可，<code>dict</code> 指的是配置的字典。更加详细的内容可以查看 <a href="https://pyyaml.org/wiki/PyYAMLDocumentation" rel="nofollow">PyYAML Documentation</a></p> 
 <h5 id="ini">2.2.2 INI</h5> 
 <blockquote> 
  <p>INI文件是一个无固定标准格式的配置文件。它以简单的文字与简单的结构组成，常常使用在Windows操作系统，或是其他操作系统上，许多程序也会采用INI文件做为设置程序之用。Windows操作系统后来以注册表的形式取代掉INI档。INI文件的命名来源，是取自英文“初始（Initial）”的首字缩写，正与它的用途——初始化程序相应。有时候，INI文件也会以不同的扩展名，如“.CFG”、“.CONF”、或是“.TXT”代替。<br> ----- 中文维基百科</p> 
 </blockquote> 
 <p>它长的像这样：</p> 
 <pre class="ini"><code>[mysql]
host=localhost
dbname=db
user=user
passwd=pwd
port=3306

[other]
host=other_host
dbname=other_db
user=other_user
passwd=other_pwb
port=3306</code></pre> 
 <p>通过以下代码可以读取它：</p> 
 <pre><code class="language-python"><code>import configparser

config = configparser.ConfigParser()
config.read("config.ini")
host = config['mysql']['host']
print(host)</code></code></pre> 
 <p>这将输出 <code>INI</code> 配置文件中的 <code>mysql</code> section 中的 <code>host</code> 值</p> 
 <p>要写入 <code>INI</code> 配置文件也很简单，参考如下代码即可：</p> 
 <pre><code class="language-python"><code>import configparser
config = configparser.ConfigParser()
config.read("config.ini")
config['mysql']['test_str'] = 'a test string'
config.write(open("ini", "w"))</code></code></pre> 
 <p>现在的配置文件会变成：</p> 
 <pre class="ini"><code>[mysql]
host = localhost
dbname = db
user = user
passwd = pwd
port = 3306
test_str = a test string

[other]
host=other_host
dbname=other_db
user=other_user
passwd=other_pwb
port=3306</code></pre> 
 <h5 id="json">2.2.3 JSON</h5> 
 <p>JSON是JavaScript对象表示法的缩写。它非常广泛，因此对许多编程语言都有很好的支持。它的格式大家也很眼熟，看起来和 Python 中的字典很像：</p> 
 <pre class="json"><code>{
    "mysql":{
        "host": "localhost",
        "dbname": "db",
        "user" : "user",
        "password": "pwd",
        "port": 3306
    },
    "other":{
        "host": "other_host",
        "dbname": "other_db",
        "user": "other_user",
        "passwd": "other_pwb",
        "port": 3306
    }</code></pre> 
 <p>你可以参考以下代码读取：</p> 
 <pre><code class="language-python"><code>import json

with open('config.json') as json_data_file:
    config = json.load(json_data_file)

host = config['mysql']['host']
print(host)

# output: localhost</code></code></pre> 
 <p>要将配置写入json中也很简单，参考以下代码：</p> 
 <pre><code class="language-python"><code>import json

with open('config.json') as json_data_file:
    config = json.load(json_data_file)

config['mysql']['test_str'] = 'a test string'

with open('config.json', 'w') as outfile:
    json.dump(config, outfile)</code></code></pre> 
 <p>这样就会得到增加了配置的json文件了：</p> 
 <pre class="json"><code>{
    "mysql":{
        "host": "localhost",
        "dbname": "db",
        "user" : "user",
        "password": "pwd",
        "port": 3306,
        "test_str" : "a test string"
    },
    "other":{
        "host": "other_host",
        "dbname": "other_db",
        "user": "other_user",
        "passwd": "other_pwb",
        "port": 3306
    }
}</code></pre> 
 <p>其他格式的文件大多如此，就不赘述了。并且外部的配置文件中也可以配置多个配置(mysql, other等)</p> 
 <h4 id="使用环境变量">2.3 使用环境变量</h4> 
 <p>但是，回到我们开篇讲的问题，以上的两种配置管理方案(使用 Python 内置的数据结构、使用外部配置文件) 都忽略了两个问题：</p> 
 <p>其一，我们如何应对安全数据直接曝光于公众的可能问题呢，如果我们需要使用版本控制系统例如 Github，或许我们可以尝试将 <code>config.py</code> 文件放到 <code>.gitignore</code> 里面，但我们如果哪一天修改了仓库，忘了将 <code>config.py</code> 忽略掉而 push 到了GitHub 上，那么我们的安全敏感信息仍然会向公众泄露，由于版本控制的存在，即使你删掉了还会有这条提交记录，处理起来会很麻烦。</p> 
 <p>其二，如果我们要在我们本地新开一个项目，这个项目也需要引用一样的数据库配置文件，或许我们可以找到第一个项目的文件夹，复制出 <code>config.py</code> 到 新的项目文件夹。嗯，看起来可行，但是，如果你要新开十几个项目呢，几百个项目呢？</p> 
 <p>因此我们可以引入下一种配置管理的方式，对解决上面提出的两个问题都是较为友好的解决方案，即使用环境变量，各种开发环境(Win、Mac、Linux)的系统环境变量的设置方式有所不同，可以参考<a href="https://blog.csdn.net/chenweifu365/article/details/79272343">这篇文章</a>。</p> 
 <p>另外 PyCharm 和 VS Code 有更加方便的配置方式，可以为不同的项目分配不同的设置。</p> 
 <p>PyCharm 中，在菜单 <code>Run</code>-&gt;<code>Edit configurations</code> 中，手动设置<code>Environment variables</code></p> 
 <p>VS Code 中，在 <code>Setting</code> 中搜索 <code>env</code> ，在 <code>Terminal</code> 中选择你的操作系统相关的<code>Terminal &gt; Integrated &gt; Env: Your OS</code> ，点进 <code>settings.json</code> 进行添加</p> 
 <p>使用环境变量配置值不用作为单独的文件进行管理，因此有较小的安全风险，它很容易使用，可以在你的开发环境中的任何项目任何代码库中使用，但是它的管理方式可能有些复杂。有些环境无法使用环境变量，比如Apache，Nginx等Web服务器，这时候就需要采用其他的方式。</p> 
 <h4 id="使用动态加载">2.4 使用动态加载</h4> 
 <p>这种方法比利用 Python 内置的数据结构更加先进，内置数据结构的方法要求配置文件必须要在可以直接 import 的路径上。但是动态加载中，配置文件不必在可直接导入的路径上，甚至可以位于其他存储库中，这样的话，配置文件就和项目分隔开了，其他的项目也可以动态加载这个配置文件，例如：</p> 
 <pre><code class="language-python"><code># /opt/settings/config.py
DATABASE_CONFIG = {
    'host': 'localhost',
    'dbname': 'company',
    'user': 'user',
    'password': 'password',
    'port': 3306
}

# main.py
import sys
import pymysql

sys.path.append('/opt/settings')
import config

def connect_db(dbname):
    if dbname != config.DATABASE_CONFIG['dbname']:
        raise ValueError("Couldn't not find DB with given name")
    conn = pymysql.connect(host=config.DATABASE_CONFIG['host'],
                           user=config.DATABASE_CONFIG['user'],
                           password=config.DATABASE_CONFIG['password'],
                           db=config.DATABASE_CONFIG['dbname'])
    return conn

connect_db('company')</code></code></pre> 
 <h3 id="三总结">三、总结</h3> 
 <p>以上归纳了四种配置管理的方式，总体来说没有优劣之分，看个人的需要，甚至上面的几种方法可以混合使用，对于一些软件项目，它自身可能就提供了相关的变量配置入口，比如 airbnb 的 <a href="https://airflow.apache.org/ui.html#variable-view" rel="nofollow"><code>Airflow</code></a> 。而且，当系统规模非常大时，最好使用主要提供配置管理的第三方工具或服务，相关服务可以<a href="https://www.softwaretestinghelp.com/top-5-software-configuration-management-tools/" rel="nofollow">参考这里</a>。</p> 
 <blockquote> 
  <p>Reference</p> 
 </blockquote> 
 <blockquote> 
  <p><a href="https://hackernoon.com/4-ways-to-manage-the-configuration-in-python-4623049e841b" rel="nofollow">4 Ways to manage the configuration in Python</a><br><a href="https://martin-thoma.com/configuration-files-in-python/#yaml" rel="nofollow">Configuration files in Python</a><br><a href="https://airflow.apache.org/ui.html#variable-view" rel="nofollow">Airflow Document</a></p> 
 </blockquote> 
</div> 
<p>转载于:https://www.cnblogs.com/wanglvtao/p/11140025.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1feca550d63c1b9ff0d1556c8d72ff93/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Latex学习（脚注）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4ff74650327bb347be593ce3f9e84871/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flex RichClient Solution by MacroMedia</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>