<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ES2020-23简单易懂又实用的精选特性讲解 ✨✨日常开发必备干货！✨✨ - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ES2020-23简单易懂又实用的精选特性讲解 ✨✨日常开发必备干货！✨✨" />
<meta property="og:description" content="ES6以来，越来越多的新特性被加入到规范当中。有一些特性(如promise、扩展运算符、箭头函数)会在实际的业务开发中起到很大作用，但是也有一些特性(如generator、Symbol、Map)在日常业务开发中并没有很必要的实际作用，徒增开发者的学习成本。针对上述情况，笔者重点挑了ES2020至ES2023中简单实用的一些特性，结合实际业务场景和代码做详细的讲解，帮助开发者利用新特性，实打实的提高日常开发效率。
如果这篇文章能给您带来一点点的帮助的话，麻烦移动下鼠标点个❤️赞❤️吧！您的点赞会给笔者带来更新的持续动力！
Array.at() （更方便地提取数组下标value） 先让我们来看下他的用法：
const array1 = [5, 12, 8, 130, 44]; console.log(array1.at(2)) //8 console.log(array1.at(3)) //130 各位读者可能注意到了，at其实和日常的.或者[]一样，获取数组下标的value值，那他有啥用呢，为什么不直接用.或者[]呢？
答案就是：at可以从末尾倒数获取下标vaule值。
这在不知道数组长度的情况下是非常实用的特性。直接上对比代码：
//`.`或者`[]`方式 const array1 = res.data?.priceList || []; //获取最后一项价格 const lastItemIndex = array1.length - 1; console.log(array1[lastItemIndex]) //at方式 const array1 = res.data?.priceList || []; //获取最后一项价格 console.log(array1.at(-1)) 可以看到，此时at方式可以更快，更方便的取出最后一项，再也不需要计算数组长度了！是不是很实用呢！
空值合并运算符（更优秀的假值判断） 我们从后端接口获取数据时，经常会遇到后端缺字段的情况，导致前端不得不去做空值兼容，防止后端不给字段，例如我们需要获取商品价格时，我们会写：
const price = res.data?.price || &#39;暂无标价&#39; 但是其实这种做法是有问题的，显然易见，如果一个免费商品的价格为0的话，我们这里的||就会产生一个bug。而且习惯了||写法的时候，很容易会忽略这个潜在问题。等到bug产生的时候，我们只能改成：
const price = (res.data?.price === null || res.data?.price === undefined) ? &#39;暂无标价&#39; : res.data?.price 显然这个代码又长，可读性也差。有没有更好的判断字段为空的方式呢，有，那就是空值合并运算符??。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/9ed507a010d7d4d8a5a868bd7e8271a8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-02T09:18:52+08:00" />
<meta property="article:modified_time" content="2022-08-02T09:18:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ES2020-23简单易懂又实用的精选特性讲解 ✨✨日常开发必备干货！✨✨</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>ES6以来，越来越多的新特性被加入到规范当中。有一些特性(如<code>promise</code>、<code>扩展运算符</code>、<code>箭头函数</code>)会在实际的业务开发中起到很大作用，但是也有一些特性(如<code>generator</code>、<code>Symbol</code>、<code>Map</code>)在日常业务开发中并没有很必要的实际作用，<strong>徒增开发者的学习成本</strong>。针对上述情况，笔者重点挑了<code>ES2020</code>至<code>ES2023</code>中<code>简单实用</code>的一些特性，结合实际业务场景和代码做详细的讲解，帮助开发者利用新特性，<code>实打实</code>的提高日常开发效率。</p> 
<blockquote> 
 <p>如果这篇文章能给您带来一点点的帮助的话，麻烦移动下鼠标点个❤️赞❤️吧！您的点赞会给笔者带来更新的持续动力！</p> 
</blockquote> 
<h3><a id="Arrayat_value_4"></a>Array.at() （更方便地提取数组下标value）</h3> 
<p>先让我们来看下他的用法：</p> 
<pre><code>const array1 = [5, 12, 8, 130, 44];
console.log(array1.at(2)) //8
console.log(array1.at(3)) //130 
</code></pre> 
<p>各位读者可能注意到了，<code>at</code>其实和日常的<code>.</code>或者<code>[]</code>一样，获取数组下标的value值，那他有啥用呢，为什么不直接用<code>.</code>或者<code>[]</code>呢？</p> 
<blockquote> 
 <p>答案就是：<code>at</code>可以从末尾倒数获取下标vaule值。</p> 
</blockquote> 
<p>这在<strong>不知道数组长度</strong>的情况下是非常实用的特性。直接上对比代码：</p> 
<pre><code>//`.`或者`[]`方式
const array1 = res.data?.priceList || [];
//获取最后一项价格
const lastItemIndex = array1.length - 1;
console.log(array1[lastItemIndex])

//at方式
const array1 = res.data?.priceList || [];
//获取最后一项价格
console.log(array1.at(-1)) 
</code></pre> 
<p>可以看到，此时<code>at</code>方式可以更快，更方便的取出最后一项，再也不需要计算数组长度了！是不是很实用呢！</p> 
<h3><a id="_36"></a>空值合并运算符（更优秀的假值判断）</h3> 
<p>我们从后端接口获取数据时，经常会遇到后端缺字段的情况，导致前端不得不去做空值兼容，防止后端不给字段，例如我们需要获取商品价格时，我们会写：</p> 
<pre><code>const price = res.data?.price || '暂无标价' 
</code></pre> 
<p>但是其实这种做法是有问题的，显然易见，如果一个免费商品的价格为0的话，我们这里的<code>||</code>就会产生一个<code>bug</code>。而且习惯了<code>||</code>写法的时候，很容易会忽略这个潜在问题。等到<code>bug</code>产生的时候，我们只能改成：</p> 
<pre><code>const price = (res.data?.price === null || res.data?.price === undefined) ? '暂无标价' : res.data?.price 
</code></pre> 
<p>显然这个代码又长，可读性也差。有没有更好的判断字段为空的方式呢，有，那就是空值合并运算符<code>??</code>。</p> 
<pre><code>const price = res.data?.price ?? '暂无标价' 
</code></pre> 
<p>代码一下子变的<code>精简舒服</code>多了！</p> 
<p>可以看到，空值合并操作符（<code>??</code>）是一个逻辑操作符，当左侧的操作数为 <code>null</code> 或者 <code>undefined</code> 时，返回其右侧操作数，否则返回左侧操作数。</p> 
<p>在一些业务场景下，可以取代<code>||</code>，用来规避使用<code>||</code>来为某些变量设置默认值，可能会遇到意料之外的行为。（例如，<code>''</code>或 <code>0</code>）</p> 
<h3><a id="Optional_Chainingkey_63"></a>可选链Optional Chaining(更精简的判断嵌套对象的空值key)</h3> 
<p>还是以后端接口为例，我们经常会遇到后端返回给我们一个多层级嵌套的对象数据，例如:</p> 
<pre><code>{resuslt: {data: {userInfo: {name: ''}}}
} 
</code></pre> 
<p>我们需要像这样获取name的值：</p> 
<pre><code>const name = res.result.data.userInfo.name 
</code></pre> 
<p>随着后端的日常接口崩溃，返回值直接变成了：</p> 
<pre><code>{resuslt: {}
} 
</code></pre> 
<p>于是乎，出现了我们前端的经典报错： <strong>Cannot read properties of undefined</strong>。随着js的进程阻塞，后端开始甩锅前端没有做兼容判断，于是乎，我们背着锅写下了兼容代码：</p> 
<pre><code>const name = ''
if(res.result &amp;&amp; res.result.data &amp;&amp; res.result.data.userInfo &amp;&amp; res.result.data.userInfo.name) {name = res.result.data.userInfo.name
} 
</code></pre> 
<p>代码又长又冗余，接下来，就是<code>可选链Optional Chaining</code>出场了：</p> 
<pre><code>const name = res?.result?.data?.userInfo?.name || '' 
</code></pre> 
<p>上面的代码和之前又长又冗余的代码效果是一样的！是不是非常精简呢？顺着代码我们可以发现，<code>可选链Optional Chaining</code>的含义是：</p> 
<p><code>可选链操作符 ( ?. )</code> 允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。<code>?.</code> 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空 (<code>null</code> 或者 <code>undefined</code>) 的情况下不会引起错误，该表达式短路返回值是<code>undefined</code>。</p> 
<p>而且它还可以和函数结合使用，与函数调用一起使用时，如果给定的函数不存在，则返回<code>undefined</code>。这样我们就可以更好避免日常开发中，变量不是<code>function</code>的情况：</p> 
<pre><code>const name = instance.apiFunc
const res = name?.getResult('param') 
</code></pre> 
<h3><a id="Arraygroupbabel_111"></a>Array.group()快速分类组合数组(需依赖babel)</h3> 
<p>这也是一个非常实用的特性，我们举一个比较常见的实际业务场景为例： 此时我们作为电商公司正值618活动，全国各地有很多人买了我们的商品，后端统计了很多用户的购买信息，包括商品名称、价格、下单所在省份等。于是乎，我们数据库有里有了以下的数据：</p> 
<pre><code>const orderList = [{nickName: 'steven',productName: '西瓜',price: 29,province: 'henan',
},{nickName: '杨超越',productName: '杨梅',price: 22,province: 'shanxi',
},{nickName: '范明',productName: '苹果',price: 19,province: 'dongbei',
},{nickName: '倪虹洁',productName: '桃子',price: 88,province: 'shanxi',
},{nickName: '杨超越2号',productName: '西瓜',price: 29,province: 'henan',
},{nickName: '杨超越3号',productName: '杨梅',price: 22,province: 'shanxi',
},{nickName: '范明2号',productName: '苹果',price: 19,province: 'dongbei',
},{nickName: '倪虹洁2号',productName: '桃子',price: 88,province: 'shanxi',
}] 
</code></pre> 
<p>此时来了一个需求，618快结束了，我们需要统计各个省份的购买力，也就是要从省份角度统计出各个省份的购买人数，比如：shanxi省多少人买了，dongbei省多少人买了。完成这个需求传统模式下我们需要这样做：</p> 
<pre><code>// 参考上面orderList
const orderList = [...]

const provinceObj = {}

for (let index = 0; index &lt; orderList.length; index++) {const element = orderList[index];const provinceKey = element.provinceconsole.log('provinceKey', provinceKey);// key值存在就pushif (provinceObj[provinceKey]) {provinceObj[provinceKey].push(element)} else {// key值不存在就新建一个key和valueprovinceObj[provinceKey] = [element]}
}
//console.log(provinceObj)
{"henan":[{"nickName":"steven","productName":"西瓜","price":29,"province":"henan"},{"nickName":"杨超越2号","productName":"西瓜","price":29,"province":"henan"}],"shanxi":[{"nickName":"杨超越","productName":"杨梅","price":22,"province":"shanxi"},{"nickName":"倪虹洁","productName":"桃子","price":88,"province":"shanxi"},{"nickName":"杨超越3号","productName":"杨梅","price":22,"province":"shanxi"},{"nickName":"倪虹洁2号","productName":"桃子","price":88,"province":"shanxi"}],"dongbei":[{"nickName":"范明","productName":"苹果","price":19,"province":"dongbei"},{"nickName":"范明2号","productName":"苹果","price":19,"province":"dongbei"}]
} 
</code></pre> 
<p>用没有更快更优雅的方法呢，有！那就是 <em><strong>Array.group</strong></em>！！接下来我们再看下最新的做法：</p> 
<pre><code>const provinceObj = orderList.group( ({ province }) =&gt; province ); 
</code></pre> 
<blockquote> 
 <p>一行代码搞定！是不是既优雅又实用呢！</p> 
</blockquote> 
<h3><a id="_151"></a>总结</h3> 
<p>我们此次一共介绍了_<strong>Array.at()</strong>_ 、<em><strong>空值合并运算符</strong></em>、<em><strong>Array.group()</strong></em>、 <em><strong>可选链Optional Chaining</strong></em> 4种实用新特性。</p> 
<blockquote> 
 <p>如果这几个特性能给您带来一点点的帮助的话，麻烦移动下鼠标点个❤️赞❤️吧！您的点赞会给笔者带来更新的持续动力！</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/543568733d6038de43fd2aa5a4fa5e1d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">企业搭建数据中台的意义是什么？_光点科技</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/544c9c8ceee8ac5664eca67cf59f8bb0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux 下孤儿进程与僵尸进程详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>