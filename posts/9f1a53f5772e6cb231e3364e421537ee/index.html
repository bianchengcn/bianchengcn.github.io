<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>matlab练习_基于用户的协同过滤过滤算法 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="matlab练习_基于用户的协同过滤过滤算法" />
<meta property="og:description" content="参考博文链接：【毕业设计算法推荐】基于物品的协同过滤推荐算法（ItemCF）_普通网友的博客-CSDN博客_java基于物品的协同过滤算法
首先，随机生成一些用户行为列表，代码如下：
%%生成用户行为矩阵 function User_Behavior_Matrix = Generate_User_Behavior(user_count, item_count, behavior_sum) %创建一个介于1到user_count的伪随机整数矩阵（behavior_sum行，1列） A = randi(user_count, behavior_sum, 1); B = randi(item_count, behavior_sum, 1); %定义用户行为种类 behavior_type = [1, 3, 5, 10]; %以相应概率生成用户行为，这里（点击 = 0.4，搜索 = 0.3，收藏 = 0.2，付款 = 0.1） C = rand(behavior_sum, 1); for i = 1:behavior_sum if C(i, 1) &lt;= 0.4 C(i, 1) = behavior_type(1,1); elseif C(i, 1) &lt;= 0.7 C(i, 1) = behavior_type(1,2); elseif C(i, 1) &lt;= 0.9 C(i, 1) = behavior_type(1,3); else C(i, 1) = behavior_type(1,4); end end User_Behavior_Matrix = [A B C]; ​​​​​​​" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/9f1a53f5772e6cb231e3364e421537ee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-03T17:45:00+08:00" />
<meta property="article:modified_time" content="2022-12-03T17:45:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">matlab练习_基于用户的协同过滤过滤算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>参考博文链接：<a href="https://blog.csdn.net/weixin_45778960/article/details/117886405" title="【毕业设计算法推荐】基于物品的协同过滤推荐算法（ItemCF）_普通网友的博客-CSDN博客_java基于物品的协同过滤算法">【毕业设计算法推荐】基于物品的协同过滤推荐算法（ItemCF）_普通网友的博客-CSDN博客_java基于物品的协同过滤算法</a></p> 
<p> 首先，随机生成一些用户行为列表，代码如下：</p> 
<pre><code class="hljs">%%生成用户行为矩阵
function User_Behavior_Matrix = Generate_User_Behavior(user_count, item_count, behavior_sum)

%创建一个介于1到user_count的伪随机整数矩阵（behavior_sum行，1列）
A = randi(user_count, behavior_sum, 1);

B = randi(item_count, behavior_sum, 1);

%定义用户行为种类
behavior_type = [1, 3, 5, 10];

%以相应概率生成用户行为，这里（点击 = 0.4，搜索 = 0.3，收藏 = 0.2，付款 = 0.1）
C = rand(behavior_sum, 1);
for i = 1:behavior_sum
    if C(i, 1) &lt;= 0.4
        C(i, 1) = behavior_type(1,1);
    elseif C(i, 1) &lt;= 0.7
        C(i, 1) = behavior_type(1,2);
    elseif C(i, 1) &lt;= 0.9
        C(i, 1) = behavior_type(1,3);
    else
        C(i, 1) = behavior_type(1,4);
    end   
end

User_Behavior_Matrix = [A B C];</code></pre> 
<p>​​​​​​​<img alt="" height="38" src="https://images2.imgbox.com/f9/e9/dCp6I2yb_o.png" width="566"></p> 
<pre><code>%%初始化
clc;
close all;
clear;

%%定义用户行为与权重
% dianji = 1;
% sousu = 3;
% shoucang = 5;
% fukuan = 10;

%%定义用户行为列表
X = [1 1 1;
       3 3 5;
       2 2 3;
       2 5 3;
       2 6 5;
       1 2 10;
       3 3 10;
       3 4 5;
       3 1 5;
       1 1 1;
       1 6 5;
       1 4 3];
   
%参考资料  
% clc;clear;
% x=[1,2,3,3,4,3,5,6,6,7,8];
% tbl = tabulate(x);%返回三列数组，第一列为数值，第二列为重复次数
% Index=find(tbl(:,2)&gt;1);   

%%获取矩阵相关尺寸
item_information = tabulate(X(:, 2));
item_list = item_information(:,1);
item_size = size(item_list, 1);

user_information = tabulate(X(:, 1));
user_list = user_information(:,1);
user_size = size(user_list, 1);

%%根据用户行为列表计算用户，物品的评分矩阵
Y = zeros(item_size, user_size);

[m, n] = size(X);

 jifen = zeros(6, 1);

for i = 1:user_size
    for j = 1:m
        if X(j,1) ~= user_list(i)
            continue
        else
            for k = 1:item_size
                if X(j, 2) ~= item_list(k)
                    continue
                else
                    switch(X(j, 3))
                        case 1
                            jifen(k, 1) = jifen(k, 1)  + 1;
                        case 3
                            jifen(k, 1)  = jifen(k, 1)  + 3;
                        case 5
                            jifen(k, 1)  = jifen(k, 1)  + 5;
                        case 10
                            jifen(k, 1)  = jifen(k, 1)  + 10;
                        otherwise
                            jifen(k, 1)  = jifen(k, 1)  + 0;
                    end
                end
                Y(k, i) = jifen(k, 1);
            end
        end
    end
    jifen = zeros(6, 1);
end
</code></pre> 
<p> step2,3,4</p> 
<p class="img-center"><img alt="" height="81" src="https://images2.imgbox.com/b9/a1/mreNatW5_o.png" width="669"></p> 
<p> </p> 
<pre><code>% 获取矩阵的行向量  % a = Scoring_Matrix(1, :)
% 通过size（A）可以得到【m  n】
%通过size（A，1）可以得到行数m
%通过size（A，2）可以得到列数n

%Scoring_Matrix = [2 0 5; 10 3 0; 0 0 15;  3 0 5; 0 3 0;  5 5 0];

%%初始化
clc;close all;clear;
load Scoring_Matrix;


%%根据物品的评分矩阵计算物品与物品的相似度
n = size(Scoring_Matrix, 1);

A = zeros(n, n);

for i = 1:n
    for j = 1:n
        fenzi = dot(Scoring_Matrix(i, :), Scoring_Matrix(j, :));
        fenmu = sqrt(dot(Scoring_Matrix(i, :), Scoring_Matrix(i, :))) * ...
                        sqrt(dot(Scoring_Matrix(j, :), Scoring_Matrix(j, :)));
        A(i, j) = fenzi /fenmu;
    end
end


%%相似度矩阵 * 评分矩阵 = 推荐矩阵
Recommendation_Matrix = A * Scoring_Matrix;


%%对比评分矩阵，对于已经推荐过的物品进行过滤推荐
%过滤推荐就是置为0，并且选出评分最高的物品，该物品就是应该
%推荐给用户的一个物品
[m, n] = size(Scoring_Matrix);
Result_Matrix = Recommendation_Matrix;

for i = 1:m
    for j = 1:n
        if Scoring_Matrix(i, j) ~= 0 &amp;&amp; Recommendation_Matrix(i, j) ~= 0
            Result_Matrix(i, j) = 0;
        elseif Scoring_Matrix(i, j) == 0 &amp;&amp; Recommendation_Matrix(i, j) ~= 0
            Result_Matrix(i, j) = Recommendation_Matrix(i, j);
        end
    end
end

%%获取最大相似度，并输出推荐列表
[max_a, index] = max(Result_Matrix, [], 1);

%fprintf函数，功能：输出字面文本和数组值
fprintf('用户\t推荐项目\n')
for i = 1: size(Result_Matrix, 2)
   fprintf('用户%d \t 项目%d\n', i, index(i))
end





</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f08a21794c354efcd298f7ac14bc426/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2022年中国研究生数学建模等待成绩的心路历程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e4aa3e8f9dd9fdbd5ab160d7f013c2f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">FFmpeg 快速上手：命令行详解、工具、教程、电子书</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>