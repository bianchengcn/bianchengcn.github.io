<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>机器学习——bp神经网络 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="机器学习——bp神经网络" />
<meta property="og:description" content="目录
一、人工神经网络
1.简介
2.基本特征
3.激活函数简介 二、BP神经网络
正向传播：
反向传播：
更新参数：
三、代码实现
一、人工神经网络 1.简介 人工神经网络（Artificial Neural Network，即ANN ），是20世纪80 年代以来人工智能领域兴起的研究热点。它从信息处理角度对人脑神经元网络进行抽象， 建立某种简单模型，按不同的连接方式组成不同的网络。在工程与学术界也常直接简称为神经网络或类神经网络。神经网络是一种运算模型，由大量的节点（或称神经元）之间相互联接构成。
2.基本特征 人工神经网络是由大量处理单元互联组成的非线性、自适应信息处理系统。它是在现代神经科学研究成果的基础上提出的，试图通过模拟大脑神经网络处理、记忆信息的方式进行信息处理。人工神经网络具有四个基本特征：
非线性：非线性关系是自然界的普遍特性。大脑的智慧就是一种非线性现象。人工神经元处于激活或抑制二种不同的状态，这种行为在数学上表现为一种非线性关系。具有阈值的神经元构成的网络具有更好的性能，可以提高容错性和存储容量。非局限性：一个神经网络通常由多个神经元广泛连接而成。一个系统的整体行为不仅取决于单个神经元的特征，而且可能主要由单元之间的相互作用、相互连接所决定。通过单元之间的大量连接模拟大脑的非局限性。联想记忆是非局限性的典型例子。非常定性：人工神经网络具有自适应、自组织、自学习能力。神经网络不但处理的信息可以有各种变化，而且在处理信息的同时，非线性动力系统本身也在不断变化。经常采用迭代过程描写动力系统的演化过程。非凸性：一个系统的演化方向，在一定条件下将取决于某个特定的状态函数。例如能量函数，它的极值相应于系统比较稳定的状态。非凸性是指这种函数有多个极值，故系统具有多个较稳定的平衡态，这将导致系统演化的多样性。 3.激活函数简介 激活函数的引入为的是增加整个网络的表达能力 (即非线性)，否则，若干线性操作层的堆叠仍然只能起到线性映射的作用，无法形成复杂的函数。因为线性模型的表达能力通常不够，所以我们需要引入非线性因素来增加其表达能力。
激活函数（Activation Function）是一种添加到人工神经网络中的函数，旨在帮助网络学习数据中的复杂模式。类似于人类大脑中基于神经元的模型，激活函数最终决定了要发射给下一个神经元的内容。
激活函数有多种，包括 Sigmoid、Tanh、ReLU、Leaky ReLU、PReLU、ELU、Maxout 等，常用的有Sigmoid,Tach,Relu这三种。
1.Sigmoid函数
2.Tanh函数
3.Relu函数
二、BP神经网络 Bp神经网络可以分为两个部分，bp和神经网络。bp（Back Propagation）的意思是反向传播。
它的学习规则是使用最速下降法，通过反向传播来不断调整网络的权值和阈值，使网络的误差平方和最小。
其主要的特点是：信号是正向传播的，而误差是反向传播的。
算法流程：
输入层：信息的输入端，是读入你输入的数据的
隐藏层：信息的处理端，可以设置这个隐藏层的层数（在这里一层隐藏层，p个神经元）
输出层：信息的输出端，也就是我们要的结果
BP神经网络的过程主要分为两个阶段，第一阶段是信号的正向传播，从输入层经过隐藏层，最后到达输出层；第二阶段是误差的反向传播，从输出层到隐藏层，最后到输入层，依次调节隐藏层到输出层的权重和偏置，输入层到隐含层的权重和偏置。
神经网络的结构：
正向传播： 如图，有一个神经网络，为方便计算，将每个神经元依次命名为n1—n8；权重w也按神经元区分。
现在有两个隐藏层，输入层两个神经元，分别为和，首先要计算第一层隐藏层的输入：
n3的输入：
n4的输入：
n5的输入：
然后就是这层隐藏层的输出，也就是经过激活函数，假设使用的激活函数都为sigmoid函数，第一层隐藏层的输出：
n3的输出：
n4的输出：
n5的输出：
第二层隐藏层的输入：
n6的输入：
n7的输入：
第二层隐藏层的输出：
n6的输出：
n7的输出：
输出层的输入：
n8的输入：
输出层的输出：
n8的输出：
反向传播： 对于输出层的神经元，这个误差可以直接计算。对于隐藏层的神经元，误差是通过将其后一层的神经元的误差加权相加并应用激活函数的导数来计算的。
这个神经网络属于回归问题，所以我们使用均方误差作为损失函数。
损失函数：
输出层误差等于损失函数关于输出层输入的梯度：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5e399da600659f5291cb3c9b8ad8efb8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-14T20:57:28+08:00" />
<meta property="article:modified_time" content="2023-08-14T20:57:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">机器学习——bp神经网络</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C" rel="nofollow">一、人工神经网络</a></p> 
<p id="1.%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#1.%E7%AE%80%E4%BB%8B" rel="nofollow">1.简介</a></p> 
<p id="2.%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81-toc" style="margin-left:40px;"><a href="#2.%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81" rel="nofollow">2.基本特征</a></p> 
<p id="3.%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B%C2%A0-toc" style="margin-left:40px;"><a href="#3.%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B%C2%A0" rel="nofollow">3.激活函数简介 </a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C" rel="nofollow"> 二、BP神经网络</a></p> 
<p id="%E6%AD%A3%E5%90%91%E4%BC%A0%E6%92%AD%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%AD%A3%E5%90%91%E4%BC%A0%E6%92%AD%EF%BC%9A" rel="nofollow">正向传播：</a></p> 
<p id="%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%EF%BC%9A" rel="nofollow">反向传播：</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%E2%80%8B%E6%9B%B4%E6%96%B0%E5%8F%82%E6%95%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%E2%80%8B%E6%9B%B4%E6%96%B0%E5%8F%82%E6%95%B0%EF%BC%9A" rel="nofollow">更新参数：</a></p> 
<p id="%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">三、代码实现</a></p> 
<p></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%E2%80%8B%E6%9B%B4%E6%96%B0%E5%8F%82%E6%95%B0%EF%BC%9A-toc"></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">一、人工神经网络</h2> 
<h3 id="1.%E7%AE%80%E4%BB%8B">1.简介</h3> 
<p>人工神经网络（Artificial Neural Network，即ANN ），是20世纪80 年代以来人工智能领域兴起的研究热点。它从信息处理角度对人脑神经元网络进行抽象， 建立某种简单模型，按不同的连接方式组成不同的网络。在工程与学术界也常直接简称为神经网络或类神经网络。神经网络是一种运算模型，由大量的节点（或称神经元）之间相互联接构成。</p> 
<h3 id="2.%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81">2.基本特征</h3> 
<p>人工神经网络是由大量处理单元互联组成的非线性、自适应信息处理系统。它是在现代神经科学研究成果的基础上提出的，试图通过模拟大脑神经网络处理、记忆信息的方式进行信息处理。人工神经网络具有四个基本特征：</p> 
<ol><li>非线性：非线性关系是自然界的普遍特性。大脑的智慧就是一种非线性现象。人工神经元处于激活或抑制二种不同的状态，这种行为在数学上表现为一种非线性关系。具有阈值的神经元构成的网络具有更好的性能，可以提高容错性和存储容量。</li><li>非局限性：一个神经网络通常由多个神经元广泛连接而成。一个系统的整体行为不仅取决于单个神经元的特征，而且可能主要由单元之间的相互作用、相互连接所决定。通过单元之间的大量连接模拟大脑的非局限性。联想记忆是非局限性的典型例子。</li><li>非常定性：人工神经网络具有自适应、自组织、自学习能力。神经网络不但处理的信息可以有各种变化，而且在处理信息的同时，非线性动力系统本身也在不断变化。经常采用迭代过程描写动力系统的演化过程。</li><li>非凸性：一个系统的演化方向，在一定条件下将取决于某个特定的状态函数。例如能量函数，它的极值相应于系统比较稳定的状态。非凸性是指这种函数有多个极值，故系统具有多个较稳定的平衡态，这将导致系统演化的多样性。</li></ol> 
<h3 id="3.%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B%C2%A0">3.激活函数简介 </h3> 
<p>激活函数的引入为的是增加整个网络的表达能力 (即非线性)，否则，若干线性操作层的堆叠仍然只能起到线性映射的作用，无法形成复杂的函数。因为线性模型的表达能力通常不够，所以我们需要引入非线性因素来增加其表达能力。</p> 
<p><strong>激活函数（Activation Function）</strong>是一种添加到人工神经网络中的函数，旨在帮助网络学习数据中的复杂模式。类似于人类大脑中基于神经元的模型，激活函数最终决定了要发射给下一个神经元的内容。</p> 
<p>激活函数有多种，包括 Sigmoid、Tanh、ReLU、Leaky ReLU、PReLU、ELU、Maxout 等，常用的有Sigmoid,Tach,Relu这三种。</p> 
<p>1.Sigmoid函数</p> 
<p class="img-center"><img alt="f(x)=\frac{1}{1+e^{-x}}" src="https://images2.imgbox.com/4c/df/jpXog1lk_o.png"></p> 
<p class="img-center"><img alt="" height="281" src="https://images2.imgbox.com/d7/31/4bMimAks_o.jpg" width="362"></p> 
<p> 2.Tanh函数</p> 
<p></p> 
<p class="img-center"><img alt="f(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}" src="https://images2.imgbox.com/bf/ba/UzlfwRUm_o.png"></p> 
<p class="img-center"><img alt="" height="232" src="https://images2.imgbox.com/47/59/MXbnuJ8J_o.jpg" width="367"></p> 
<p> 3.Relu函数</p> 
<p class="img-center"><img alt="f(x)=max(0,x)" src="https://images2.imgbox.com/c6/4e/33H39d6L_o.png"></p> 
<p class="img-center"><img alt="" height="374" src="https://images2.imgbox.com/44/2a/Hx1H6ogc_o.jpg" width="437"></p> 
<h2 id="%C2%A0%E4%BA%8C%E3%80%81BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"> 二、BP神经网络</h2> 
<p>Bp神经网络可以分为两个部分，bp和神经网络。bp（Back Propagation）的意思是反向传播。</p> 
<p>它的学习规则是使用最速下降法，通过反向传播来不断调整网络的权值和阈值，使网络的误差平方和最小。</p> 
<p>其主要的特点是：信号是正向传播的，而<strong>误差是反向传播</strong>的。</p> 
<p><strong>算法流程</strong>：</p> 
<p><img alt="" height="210" src="https://images2.imgbox.com/ba/f7/Fvo00Foi_o.png" width="754"></p> 
<p></p> 
<p><strong>输入层</strong>：信息的输入端，是读入你输入的数据的</p> 
<p><strong>隐藏层</strong>：信息的处理端，可以设置这个隐藏层的层数（在这里一层隐藏层，p个神经元）</p> 
<p><strong>输出层</strong>：信息的输出端，也就是我们要的结果</p> 
<p>BP神经网络的过程主要分为两个阶段，第一阶段是信号的正向传播，从输入层经过隐藏层，最后到达输出层；第二阶段是误差的反向传播，从输出层到隐藏层，最后到输入层，依次调节隐藏层到输出层的权重和偏置，输入层到隐含层的权重和偏置。</p> 
<p><strong>神经网络的结构</strong>：</p> 
<p><img alt="" height="981" src="https://images2.imgbox.com/84/25/5ESMOZ47_o.png" width="1200"></p> 
<p></p> 
<h4 id="%E6%AD%A3%E5%90%91%E4%BC%A0%E6%92%AD%EF%BC%9A">正向传播：</h4> 
<p>如图，有一个神经网络，为方便计算，将每个神经元依次命名为n1—n8；权重w也按神经元区分。</p> 
<p>现在有两个隐藏层，输入层两个神经元，分别为<img alt="x_1" src="https://images2.imgbox.com/51/fb/JcjczqcR_o.png">和<img alt="x_2" src="https://images2.imgbox.com/8d/ec/oFu2YtN5_o.png">，首先要计算第一层隐藏层的输入：</p> 
<p>n3的输入：<img alt="z_1=x_1*w_{13}+x_2*w_{23}+b_1" src="https://images2.imgbox.com/2a/40/RW2JWjXM_o.png"></p> 
<p>n4的输入：<img alt="z_2=x_1*w_{14}+x_2*w_{24}+b_2" src="https://images2.imgbox.com/eb/2d/Xpmu3Tmh_o.png"></p> 
<p>n5的输入：<img alt="z_3=x_1*w_{15}+x_2*w_{25}+b_3" src="https://images2.imgbox.com/d4/2e/BGLRIyIW_o.png"></p> 
<p>然后就是这层隐藏层的输出，也就是经过激活函数，假设使用的激活函数都为sigmoid函数，第一层隐藏层的输出：</p> 
<p>n3的输出：<img alt="f(z_1)=sigmoid(z_1)=\frac{1}{1+e^{-z_1}}" src="https://images2.imgbox.com/a5/53/Mf4UPJbR_o.png"></p> 
<p>n4的输出：<img alt="f(z_2)=sigmoid(z_2)=\frac{1}{1+e^{-z_2}}" src="https://images2.imgbox.com/c8/a3/3SRMCzag_o.png"></p> 
<p>n5的输出：<img alt="f(z_3)=sigmoid(z_3)=\frac{1}{1+e^{-z_3}}" src="https://images2.imgbox.com/ad/42/8wtHsSkT_o.png"></p> 
<p>第二层隐藏层的输入：</p> 
<p>n6的输入：<img alt="z_4=f(z_1)*w_{36}+f(z_2)*w_{46}+f(z_3)*w_{56}+b4" src="https://images2.imgbox.com/5b/22/553jQbOF_o.png"></p> 
<p>n7的输入：<img alt="z_5=f(z_1)*w_{37}+f(z_2)*w_{47}+f(z_3)*w_{57}+b5" src="https://images2.imgbox.com/44/6b/X1Jo1qdh_o.png"></p> 
<p>第二层隐藏层的输出：</p> 
<p>n6的输出：<img alt="f(z_4)=sigmoid(z_4)=\frac{1}{1+e^{-z_4}}" src="https://images2.imgbox.com/f9/2c/JzNR7l4u_o.png"></p> 
<p>n7的输出：<img alt="f(z_5)=sigmoid(z_5)=\frac{1}{1+e^{-z_5}}" src="https://images2.imgbox.com/43/9a/ZoerqyiC_o.png"></p> 
<p>输出层的输入：</p> 
<p>n8的输入：<img alt="z_6=f(z_4)*w_{68}+f(z_5)*w_{78}+b_6" src="https://images2.imgbox.com/16/92/P9t0tJbp_o.png"></p> 
<p>输出层的输出：</p> 
<p>n8的输出：<img alt="f(z_6)=sigmoid(z_6)=\frac{1}{1+e^{-z_6}}" src="https://images2.imgbox.com/b9/58/fqFTDXEl_o.png"></p> 
<h4 id="%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%EF%BC%9A">反向传播：</h4> 
<p>对于输出层的神经元，这个误差可以直接计算。对于隐藏层的神经元，误差是通过将其后一层的神经元的误差加权相加并应用激活函数的导数来计算的。</p> 
<p>这个神经网络属于回归问题，所以我们使用均方误差作为损失函数。</p> 
<p>损失函数：<img alt="L(y,\hat{y})=\frac{1}{2}\sum (y-\hat{y})^2" src="https://images2.imgbox.com/9b/2c/Qlq6OCwY_o.png"></p> 
<p>输出层误差等于损失函数关于输出层输入的梯度：</p> 
<p>n8的误差：<img alt="E_{f(z_6)}=\frac{\partial L(y,\hat{y})}{\partial z_6}=\frac{\partial L(y,\hat{y})}{\partial f(z_6)}*\frac{\partial f(z_6)}{\partial z_6}=\frac{\partial L(y,\hat{y})}{\partial f(z_6)}*f'(z_6)=-(y-\hat{y})*f'(z_6)" src="https://images2.imgbox.com/dc/44/otx9Gqk6_o.png"></p> 
<p>而输出层只有一个神经元，所以误差项：<img alt="E_{out}=[E_{f(z_6)}]" src="https://images2.imgbox.com/ab/55/q2PyYiWM_o.png"> </p> 
<p>第二层隐藏层神经元的误差：</p> 
<p>n7的误差：<img alt="E_{f(z_5)}=\frac{\partial L(y,\hat{y})}{\partial z_5}=f'(z_5)*[w_{78}]^T*E_{out}" src="https://images2.imgbox.com/3e/66/qm90EJwJ_o.png"></p> 
<p>n6的误差：<img alt="E_{f(z_4)}=\frac{\partial L(y,\hat{y})}{\partial z_4}=f'(z_4)*[w_{68}]^T*E_{out}" src="https://images2.imgbox.com/b2/53/fzFvoBd6_o.png"></p> 
<p>这一层的误差项为：<img alt="E_{hidden2}=\begin{bmatrix} E_{f(z_4)}\\ E_{f(z_5)} \end{bmatrix}" src="https://images2.imgbox.com/10/ee/kP17lPAI_o.png"></p> 
<p>第一层隐藏层神经元的误差：</p> 
<p>n5的误差：<img alt="E_{f(z_3)}=\frac{\partial L(y,\hat{y})}{\partial z_3}=f'(z_3)*\begin{bmatrix} w_{56}\\ w_{57} \end{bmatrix}^T*E_{hidden2}" src="https://images2.imgbox.com/ae/6a/czcFlis8_o.png"></p> 
<p>n4的误差：<img alt="E_{f(z_2)}=\frac{\partial L(y,\hat{y})}{\partial z_2}=f'(z_2)*\begin{bmatrix} w_{46}\\ w_{47} \end{bmatrix}^T*E_{hidden2}" src="https://images2.imgbox.com/5d/1e/cT3DuEV7_o.png"></p> 
<p>n3的误差：<img alt="E_{f(z_1)}=\frac{\partial L(y,\hat{y})}{\partial z_1}=f'(z_1)*\begin{bmatrix} w_{36}\\ w_{37} \end{bmatrix}^T*E_{hidden2}" src="https://images2.imgbox.com/5a/d0/w3RX0NVy_o.png"></p> 
<p>这一层的误差项为：<img alt="E_{hidden1}=\begin{bmatrix} E_{f(z_1)}\\ E_{f(z_2)} \\ E_{f(z_3)} \end{bmatrix}" src="https://images2.imgbox.com/50/ac/FKxdwmci_o.png"></p> 
<p></p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91%E2%80%8B%E6%9B%B4%E6%96%B0%E5%8F%82%E6%95%B0%EF%BC%9A">更新参数：</h4> 
<p>对于每个权重，其梯度等于后一层神经元的误差项乘以前一层神经元的输出。</p> 
<p>权重的更新：</p> 
<p><img alt="W" src="https://images2.imgbox.com/d5/44/m2eFD8py_o.png">是相应权重组成的矩阵。</p> 
<p>第二层隐藏层与输出层之间权重的更新： <img alt="W=W-l(E_{out}*\begin{bmatrix} f(z_4)\\f(z_5) \end{bmatrix}^{T})" class="mathcode" src="https://images2.imgbox.com/7d/fa/Lxl9wH6l_o.png"></p> 
<p>第一层隐藏层与第二层隐藏层之间权重的更新：<img alt="W=W-l(E_{hidden2}*\begin{bmatrix} f(z_1)\\f(z_2) \\f(z_3) \end{bmatrix}^T)" src="https://images2.imgbox.com/97/c0/V8kt5S4J_o.png"></p> 
<p>输入层与第一层隐藏层之间权重更新：<img alt="W=W-l(E_{hidden1}*\begin{bmatrix} x_1\\x_2 \end{bmatrix}^T )" src="https://images2.imgbox.com/45/70/e2g5Blsu_o.png"></p> 
<p>对于每个偏置，其梯度等于相应神经元的误差项。</p> 
<p>第一层的隐藏层的偏置：<img alt="\begin{bmatrix} b_1\\ b_2 \\ b_3 \end{bmatrix}=\begin{bmatrix} b_1\\ b_2 \\ b_3 \end{bmatrix}-l*E_{hidden1}" src="https://images2.imgbox.com/5d/46/IvgtSjTi_o.png"></p> 
<p>第二层的隐藏层的偏置：<img alt="\begin{bmatrix} b_4\\ b_5 \end{bmatrix}=\begin{bmatrix} b_4\\ b_5 \end{bmatrix}-l*E_{hidden2}" src="https://images2.imgbox.com/82/5c/b4WD2AaO_o.png"></p> 
<p>输出层的偏置：<img alt="b_6=b_6-l*E_{out}" src="https://images2.imgbox.com/a5/ee/woTzHYLd_o.png"></p> 
<h2 id="%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">三、代码实现</h2> 
<p>下面是bp神经网络实现手写字识别</p> 
<p>完整代码：</p> 
<pre><code class="language-python">import numpy as np

# 定义sigmoid函数
def sigmoid(x):
    return 1 / (1 + np.exp(-x))

# 定义one-hot编码函数，将类别标签转换为one-hot编码形式
def one_hot_encode(labels, num_classes):
    one_hot = np.zeros((len(labels), num_classes))
    one_hot[np.arange(len(labels)), labels] = 1
    return one_hot

# 读取训练集和测试集
train_data = np.genfromtxt('mnist_train_100.csv', delimiter=',', skip_header=1)
test_data = np.genfromtxt('mnist_test_10.csv', delimiter=',', skip_header=1)

# 分离特征和标签并对特征进行归一化
X_train = train_data[:, 1:] / 255
Y_train = train_data[:, 0]
X_test = test_data[:, 1:] / 255
Y_test = test_data[:, 0]

# 对标签进行one-hot编码
Y_train_onehot = one_hot_encode(Y_train.astype(int), 10)
Y_test_onehot = one_hot_encode(Y_test.astype(int), 10)

# 定义bp神经网络
class NeuralNetwork:#  输入层节点       隐藏层节点      输出层节点       学习率
    def __init__(self, input_nodes, hidden_nodes, output_nodes, learning_rate):
        self.input_nodes = input_nodes
        self.hidden_nodes = hidden_nodes
        self.output_nodes = output_nodes

        # 初始化权重（连接输入层和隐藏层的权重、连接隐藏层和输出层的权重）
        self.weights_input_to_hidden = np.random.normal(0.0, self.input_nodes ** -0.5,(self.input_nodes, self.hidden_nodes))
        self.weights_hidden_to_output = np.random.normal(0.0, self.hidden_nodes ** -0.5,(self.hidden_nodes, self.output_nodes))
        # 初始化偏置项
        self.bias_input_to_hidden = np.zeros(self.hidden_nodes)
        self.bias_hidden_to_output = np.zeros(self.output_nodes)

        self.lr = learning_rate
        self.sigmoid = sigmoid

        # 正向传播
    def forward_pass(self, X):
        hidden_inputs = np.dot(X, self.weights_input_to_hidden) + self.bias_input_to_hidden
        hidden_outputs = self.sigmoid(hidden_inputs)

        final_inputs = np.dot(hidden_outputs, self.weights_hidden_to_output) + self.bias_hidden_to_output
        final_outputs = self.sigmoid(final_inputs)

        return hidden_outputs, final_outputs

        # 反向传播
    def backward_pass(self, X, y, hidden_outputs, final_outputs):
        output_errors = final_outputs - y
        output_grad = output_errors * final_outputs * (1 - final_outputs) # 这里两步才是真正的误差项,这里乘的是sigmoid的导数

        hidden_errors = np.dot(output_grad, self.weights_hidden_to_output.T)
        hidden_grad = hidden_errors * hidden_outputs * (1 - hidden_outputs) # 也是和上面一样

        return output_grad, hidden_grad

        # 权重更新
    def update_weights(self, X, output_grad, hidden_outputs, hidden_grad):
        self.weights_hidden_to_output -= self.lr * np.dot(hidden_outputs.T, output_grad) / X.shape[0]
        self.weights_input_to_hidden -= self.lr * np.dot(X.T, hidden_grad) / X.shape[0]

        # 偏置更新
    def update_bias(self, X, output_grad, hidden_grad):
        self.bias_hidden_to_output -= self.lr * np.mean(output_grad, axis=0)
        self.bias_input_to_hidden -= self.lr * np.mean(hidden_grad, axis=0)

        # 训练模型
    def train(self, X, y):
        hidden_outputs, final_outputs = self.forward_pass(X)
        output_grad, hidden_grad = self.backward_pass(X, y, hidden_outputs, final_outputs)
        self.update_weights(X, output_grad, hidden_outputs, hidden_grad)
        self.update_bias(X, output_grad, hidden_grad)

        # 进行预测
    def predict(self, X):
        _, final_outputs = self.forward_pass(X)
        return np.argmax(final_outputs, axis=1)

#设置参数
input_nodes = 784
hidden_nodes = 128
output_nodes = 10
learning_rate = 0.1

network = NeuralNetwork(input_nodes, hidden_nodes, output_nodes, learning_rate)

# 训练神经网络
for e in range(1000):
    network.train(X_train, Y_train_onehot)

# 进行预测并计算准确率
predictions = network.predict(X_test)
accuracy = np.mean(predictions == Y_test)
print(f"Accuracy: {accuracy}")
</code></pre> 
<p>我首先定义了sigmoid函数作为激活函数，还有将标签转换为one-hot形式，转换为 one-hot 编码可以更好地表达类别之间的差异。</p> 
<p>定义神经网络时，严格按照步骤，为简化代码，只用了一层隐藏层。先进行正向传播，再反向传播误差，更新权重和偏置，然后进行训练、预测。最终输出预测的准确率。</p> 
<p>运行结果：</p> 
<p><img alt="" height="61" src="https://images2.imgbox.com/f0/62/TY8cBWaD_o.png" width="589"></p> 
<p> 由于权重初始化是随机的，在训练次数较少时准确率可能会变低。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c9b5eeb068e9e872abb69b6c88681a83/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络设备（防火墙、路由器、交换机）日志分析监控</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ebace5b28e4f188bc33beda2cbb86383/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">git修改历史commit信息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>