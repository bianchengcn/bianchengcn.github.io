<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>虚函数学习总结 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="虚函数学习总结" />
<meta property="og:description" content="虚函数是针对动态多态性设计的。什么是动态多态性呢？动态多态性是指程序运行时，不在编译时确定用哪个函数，而是在程序在运行过程中才动态地确定操作所针对的对象。这一过程需要通过虚函数来实现。
虚函数，就是在基类中声明此函数是虚拟的，并不是实际存在的函数，在派生类中，需要使用的时候再重新定义此函数。
虚函数的作用就是允许在派生类中重新定义与基类中完全重名的函数，并且允许通过基类指针或引用来访问基类和派生类中的通明函数。
1.虚函数的声明：
virtual void display(){ //virtua关键字 函数类型 函数名 //函数体 } 在基类中定义虚函数后，以此类为基类的派生类中出现与虚函数同名的函数默认为虚函数，可重新定义。
class base1 { public: virtual void display() const; //虚函数 }; void base1::display() const{ cout &lt;&lt; &#34;base1::dispaly()&#34; &lt;&lt; endl; } class base2 :public base1 { public: void display() const; //派生类中，基类中的虚函数根据函数名、参数列表等覆盖派生类的相应函数。 }; void base2::display() const { cout &lt;&lt; &#34;base2::dispaly()&#34; &lt;&lt; endl; } class base3 :public base2 { public: void display() const; //派生类中，基类中的虚函数根据函数名、参数列表等覆盖派生类的相应函数。 }; 2.可以被定义为虚函数的有：普通成员函数、析构函数。注意，构造函数不能是 虚函数，必须是实打实的哈哈哈。
析构函数被定义为虚函数，被称为虚析构函数。这种函数有两个优点：
可以通过基类指针删除派生类对象；可以通过基类指针调用对象的析构函数（利用delete删除动态内存分配的空间）。
base::~base() { cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/304dcab90b68521a3aa16b2202647b7b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-17T14:52:57+08:00" />
<meta property="article:modified_time" content="2020-10-17T14:52:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">虚函数学习总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>虚函数是针对动态多态性设计的。什么是动态多态性呢？动态多态性是指程序运行时，不在编译时确定用哪个函数，而是在程序在运行过程中才动态地确定操作所针对的对象。这一过程需要通过虚函数来实现。</p> 
<p>虚函数，就是在基类中声明此函数是虚拟的，并不是实际存在的函数，在派生类中，需要使用的时候再重新定义此函数。</p> 
<p>虚函数的作用就是<strong>允许在派生类中重新定义与基类中完全重名的函数</strong>，并且<strong>允许通过基类指针或引用来访问基类和派生类中的通明函数。</strong></p> 
<p>1.虚函数的声明：</p> 
<pre><code class="language-cpp">virtual void display(){ //virtua关键字 函数类型 函数名

  //函数体
}</code></pre> 
<p> 在基类中定义虚函数后，以此类为基类的派生类中出现与虚函数同名的函数默认为虚函数，可重新定义。</p> 
<pre><code class="language-cpp">class base1 {
public:
	virtual void display() const;  //虚函数
};
void base1::display() const{
	cout &lt;&lt; "base1::dispaly()" &lt;&lt; endl;
}

class base2 :public base1 {
public:
	void display() const; 
	//派生类中，基类中的虚函数根据函数名、参数列表等覆盖派生类的相应函数。

};
void base2::display() const {
	cout &lt;&lt; "base2::dispaly()" &lt;&lt; endl;
}

class base3 :public base2 {
public:
	void display() const;
	//派生类中，基类中的虚函数根据函数名、参数列表等覆盖派生类的相应函数。

};</code></pre> 
<p>2.可以被定义为虚函数的有：普通成员函数、析构函数。注意，构造函数不能是 虚函数，必须是实打实的哈哈哈。</p> 
<p>析构函数被定义为虚函数，被称为虚析构函数。这种函数有两个优点：</p> 
<p>可以通过基类指针删除派生类对象；可以通过基类指针调用对象的析构函数（利用delete删除动态内存分配的空间）。</p> 
<pre><code class="language-cpp">base::~base() {
	cout &lt;&lt; "Base desconstructor" &lt;&lt; endl;
}
class derived :public base{
public:
	derived();
	virtual ~derived();  //虚析构函数
private:
	int *p;
};
derived::derived() {
	p = new int(0);
}
derived::~derived() {
	cout &lt;&lt; "Derived desconstructor" &lt;&lt; endl;
	delete p;
}

void fun(base *p) {
	delete p;
}

int main() {
	base *b = new derived();
	fun(b);
	return 0;
}</code></pre> 
<p>运行结果：</p> 
<p>Derived desconstructor</p> 
<p>Base desconstructor</p> 
<p>3.当基类中虚函数仅有声明，而没有定义具体的操作内容，为空，要求在派生类中根据自己的实际情况定义自己的版本，这个虚函数为纯虚函数。</p> 
<pre><code class="language-cpp">class 类名{
virtual 类型 函数名（参数表）=0；//纯虚函数
}</code></pre> 
<p>带有纯虚函数的类抽象类。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4d8db6cc414eeb9ff123f7778a68385f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">线性代数初步</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce24afa93f8ebebdf74ea690c96145ab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Makefile中$(SRC:%.c=%.o)的含义</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>