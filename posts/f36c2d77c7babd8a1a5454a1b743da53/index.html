<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常用数字设计仿真工具(Questa,VCS,IUS/Xcelium,Verdi等)使用入门 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常用数字设计仿真工具(Questa,VCS,IUS/Xcelium,Verdi等)使用入门" />
<meta property="og:description" content="目录
1. 前言
2. QuestaSim基本使用方法
2.1 命令行编译
2.2 命令行运行
2.3 启动GUI进行仿真
2.4 从GUI中进行编译运行
2.5 dump波形
2.6 指定随机种子
2.7 命令行指定testcase名
2.8 其它常用选项
2.9 基于Tcl脚本的运行方法
2.10 其它常用命令
3. VCS基本基本使用方法
3.1 编译
3.1.1 基本编译命令
3.1.2 包含路径的指定
3.1.3 其它常用选项
3.1.4 vcs选项一览表
3.2 vcs两步仿真
3.3 vcs三步仿真 3.4 fsdb波形输出选项
3.5 ucli
3.5.1 基础介绍
3.5.2 常见命令
3.5 VCS与VCS_MX的区别
4. IUS/Xcelium基本使用方法
4.0 帮助查询方法
4.1 基本使用方法
4.2 seed与svseed的区别
4.3 Xcelium
5. Verdi基本使用方法
5.1 verdi直接打开代码
5.2 kdb选项
5.3 verdi直接打开波形" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f36c2d77c7babd8a1a5454a1b743da53/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-15T13:40:41+08:00" />
<meta property="article:modified_time" content="2023-06-15T13:40:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常用数字设计仿真工具(Questa,VCS,IUS/Xcelium,Verdi等)使用入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#1.%20%E5%89%8D%E8%A8%80" rel="nofollow">1. 前言</a></p> 
<p id="2.%20QuestaSim%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#2.%20QuestaSim%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow">2. QuestaSim基本使用方法</a></p> 
<p id="2.1%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91-toc" style="margin-left:40px;"><a href="#2.1%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91" rel="nofollow">2.1 命令行编译</a></p> 
<p id="2.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C-toc" style="margin-left:40px;"><a href="#2.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C" rel="nofollow">2.2 命令行运行</a></p> 
<p id="2.3%20%E5%90%AF%E5%8A%A8GUI%E8%BF%9B%E8%A1%8C%E4%BB%BF%E7%9C%9F-toc" style="margin-left:40px;"><a href="#2.3%20%E5%90%AF%E5%8A%A8GUI%E8%BF%9B%E8%A1%8C%E4%BB%BF%E7%9C%9F" rel="nofollow">2.3 启动GUI进行仿真</a></p> 
<p id="2.4%20%E4%BB%8EGUI%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-toc" style="margin-left:40px;"><a href="#2.4%20%E4%BB%8EGUI%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C" rel="nofollow">2.4 从GUI中进行编译运行</a></p> 
<p id="2.5%C2%A0dump%E6%B3%A2%E5%BD%A2-toc" style="margin-left:40px;"><a href="#2.5%C2%A0dump%E6%B3%A2%E5%BD%A2" rel="nofollow">2.5 dump波形</a></p> 
<p id="2.6%20%E6%8C%87%E5%AE%9A%E9%9A%8F%E6%9C%BA%E7%A7%8D%E5%AD%90-toc" style="margin-left:40px;"><a href="#2.6%20%E6%8C%87%E5%AE%9A%E9%9A%8F%E6%9C%BA%E7%A7%8D%E5%AD%90" rel="nofollow">2.6 指定随机种子</a></p> 
<p id="2.7%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8C%87%E5%AE%9Atestcase%E5%90%8D-toc" style="margin-left:40px;"><a href="#2.7%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8C%87%E5%AE%9Atestcase%E5%90%8D" rel="nofollow">2.7 命令行指定testcase名</a></p> 
<p id="2.8%20%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9-toc" style="margin-left:40px;"><a href="#2.8%20%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9" rel="nofollow">2.8 其它常用选项</a></p> 
<p id="2.6%20%E5%9F%BA%E4%BA%8ETcl%E8%84%9A%E6%9C%AC%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.6%20%E5%9F%BA%E4%BA%8ETcl%E8%84%9A%E6%9C%AC%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95" rel="nofollow">2.9 基于Tcl脚本的运行方法</a></p> 
<p id="2.10%20%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-toc" style="margin-left:40px;"><a href="#2.10%20%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" rel="nofollow">2.10 其它常用命令</a></p> 
<p id="3.%20VCS%E5%9F%BA%E6%9C%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#3.%20VCS%E5%9F%BA%E6%9C%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow">3. VCS基本基本使用方法</a></p> 
<p id="3.1%20%E7%BC%96%E8%AF%91-toc" style="margin-left:40px;"><a href="#3.1%20%E7%BC%96%E8%AF%91" rel="nofollow">3.1 编译</a></p> 
<p id="3.1%20%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E4%BB%BF%E7%9C%9F%E5%91%BD%E4%BB%A4%E5%8F%8A%E9%80%89%E9%A1%B9-toc" style="margin-left:80px;"><a href="#3.1%20%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E4%BB%BF%E7%9C%9F%E5%91%BD%E4%BB%A4%E5%8F%8A%E9%80%89%E9%A1%B9" rel="nofollow">3.1.1 基本编译命令</a></p> 
<p id="3.1.2%20%E5%8C%85%E5%90%AB%E8%B7%AF%E5%BE%84%E7%9A%84%E6%8C%87%E5%AE%9A-toc" style="margin-left:80px;"><a href="#3.1.2%20%E5%8C%85%E5%90%AB%E8%B7%AF%E5%BE%84%E7%9A%84%E6%8C%87%E5%AE%9A" rel="nofollow">3.1.2 包含路径的指定</a></p> 
<p id="3.1.3%20%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9-toc" style="margin-left:80px;"><a href="#3.1.3%20%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9" rel="nofollow">3.1.3 其它常用选项</a></p> 
<p id="3.1.4%20vcs%E9%80%89%E9%A1%B9%E4%B8%80%E8%A7%88%E8%A1%A8-toc" style="margin-left:80px;"><a href="#3.1.4%20vcs%E9%80%89%E9%A1%B9%E4%B8%80%E8%A7%88%E8%A1%A8" rel="nofollow">3.1.4 vcs选项一览表</a></p> 
<p id="3.2%20%E4%BB%BF%E7%9C%9F-toc" style="margin-left:40px;"><a href="#3.2%20%E4%BB%BF%E7%9C%9F" rel="nofollow">3.2 vcs两步仿真</a></p> 
<p id="3.3%20vcs%E4%B8%89%E6%AD%A5%E4%BB%BF%E7%9C%9F-toc" style="margin-left:40px;"><a href="#3.3%20vcs%E4%B8%89%E6%AD%A5%E4%BB%BF%E7%9C%9F" rel="nofollow">3.3 vcs三步仿真        </a></p> 
<p id="3.4%C2%A0%20fsdb%E6%B3%A2%E5%BD%A2%E8%BE%93%E5%87%BA%E9%80%89%E9%A1%B9-toc" style="margin-left:40px;"><a href="#3.4%C2%A0%20fsdb%E6%B3%A2%E5%BD%A2%E8%BE%93%E5%87%BA%E9%80%89%E9%A1%B9" rel="nofollow">3.4  fsdb波形输出选项</a></p> 
<p id="3.2%20ucli%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-toc" style="margin-left:40px;"><a href="#3.2%20ucli%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4" rel="nofollow">3.5 ucli</a></p> 
<p id="3.5.1%20%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#3.5.1%20%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D" rel="nofollow">3.5.1 基础介绍</a></p> 
<p id="3.5.2%20%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#3.5.2%20%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4" rel="nofollow">3.5.2 常见命令</a></p> 
<p id="3.4%20VCS%E4%B8%8EVCS_MX%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#3.4%20VCS%E4%B8%8EVCS_MX%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">3.5 VCS与VCS_MX的区别</a></p> 
<p id="4.%20IUS%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#4.%20IUS%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow">4. IUS/Xcelium基本使用方法</a></p> 
<p id="4.0%20%E5%B8%AE%E5%8A%A9%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#4.0%20%E5%B8%AE%E5%8A%A9%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95" rel="nofollow">4.0 帮助查询方法</a></p> 
<p id="4.1%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#4.1%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow">4.1 基本使用方法</a></p> 
<p id="4.2%20seed%E4%B8%8Esvseed%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#4.2%20seed%E4%B8%8Esvseed%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">4.2 seed与svseed的区别</a></p> 
<p id="4.3%20Xcelium-toc" style="margin-left:40px;"><a href="#4.3%20Xcelium" rel="nofollow">4.3 Xcelium</a></p> 
<p id="5.%20Verdi%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#5.%20Verdi%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow">5. Verdi基本使用方法</a></p> 
<p id="5.1%20verdi%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#5.1%20verdi%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%E4%BB%A3%E7%A0%81" rel="nofollow">5.1 verdi直接打开代码</a></p> 
<p id="5.2%20kdb%E9%80%89%E9%A1%B9-toc" style="margin-left:40px;"><a href="#5.2%20kdb%E9%80%89%E9%A1%B9" rel="nofollow">5.2 kdb选项</a></p> 
<p id="5.3%20verdi%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%E6%B3%A2%E5%BD%A2-toc" style="margin-left:40px;"><a href="#5.3%20verdi%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%E6%B3%A2%E5%BD%A2" rel="nofollow">5.3 verdi直接打开波形</a></p> 
<p id="5.4%20verdi%E6%89%93%E5%BC%80%E6%8C%87%E5%AE%9A%E7%9A%84restore%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#5.4%20verdi%E6%89%93%E5%BC%80%E6%8C%87%E5%AE%9A%E7%9A%84restore%E6%96%87%E4%BB%B6" rel="nofollow">5.4 verdi打开指定的restore文件</a></p> 
<p id="5.5%20%E6%B7%BB%E5%8A%A0%E6%B3%A2%E5%BD%A2%E8%A7%82%E6%B5%8B%E4%BF%A1%E5%8F%B7-toc" style="margin-left:40px;"><a href="#5.5%20%E6%B7%BB%E5%8A%A0%E6%B3%A2%E5%BD%A2%E8%A7%82%E6%B5%8B%E4%BF%A1%E5%8F%B7" rel="nofollow">5.5 添加波形观测信号</a></p> 
<p id="5.5.1%20%E6%96%B9%E6%B3%951-toc" style="margin-left:80px;"><a href="#5.5.1%20%E6%96%B9%E6%B3%951" rel="nofollow">5.5.1 方法1</a></p> 
<p id="5.5.2%20%E6%96%B9%E6%B3%952-toc" style="margin-left:80px;"><a href="#5.5.2%20%E6%96%B9%E6%B3%952" rel="nofollow">5.5.2 方法2</a></p> 
<p id="5.5.3%20%E6%96%B9%E6%B3%953-toc" style="margin-left:80px;"><a href="#5.5.3%20%E6%96%B9%E6%B3%953" rel="nofollow">5.5.3 方法3</a></p> 
<p id="5.%20%E6%BA%90%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#5.%20%E6%BA%90%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E6%96%B9%E5%BC%8F" rel="nofollow">6. 编译文件指定方式</a></p> 
<p id="7.%20fsdb%E6%B3%A2%E5%BD%A2dump-toc" style="margin-left:0px;"><a href="#7.%20fsdb%E6%B3%A2%E5%BD%A2dump" rel="nofollow">7. fsdb波形dump</a></p> 
<p id="7.1%20vcs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E5%AE%9A-toc" style="margin-left:40px;"><a href="#7.1%20vcs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E5%AE%9A" rel="nofollow">7.1 vcs环境变量设定</a></p> 
<p id="7.2%20irun%E7%8E%AF%E5%A2%83%E8%AE%BE%E5%AE%9A-toc" style="margin-left:40px;"><a href="#7.2%20irun%E7%8E%AF%E5%A2%83%E8%AE%BE%E5%AE%9A" rel="nofollow">7.2 irun环境设定</a></p> 
<p id="7.3%20Testbench%E4%B8%AD%E6%A4%8D%E5%85%A5%E6%B3%A2%E5%BD%A2dump%E5%91%BD%E4%BB%A4-toc" style="margin-left:40px;"><a href="#7.3%20Testbench%E4%B8%AD%E6%A4%8D%E5%85%A5%E6%B3%A2%E5%BD%A2dump%E5%91%BD%E4%BB%A4" rel="nofollow">7.3 Testbench中植入波形dump命令</a></p> 
<p id="7.4%20%E4%BB%BF%E7%9C%9F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A-toc" style="margin-left:40px;"><a href="#7.4%20%E4%BB%BF%E7%9C%9F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A" rel="nofollow">7.4 仿真命令行参数指定</a></p> 
<p id="7.4.1%20vcs%E4%BB%BF%E7%9C%9F%E5%99%A8-toc" style="margin-left:80px;"><a href="#7.4.1%20vcs%E4%BB%BF%E7%9C%9F%E5%99%A8" rel="nofollow">7.4.1 vcs仿真器</a></p> 
<p id="7.4.2%C2%A0irun%E4%BB%BF%E7%9C%9F%E5%99%A8-toc" style="margin-left:80px;"><a href="#7.4.2%C2%A0irun%E4%BB%BF%E7%9C%9F%E5%99%A8" rel="nofollow">7.4.2 irun仿真器</a></p> 
<p id="7.5%20Memory%20Size%20Limit%20Problem-toc" style="margin-left:40px;"><a href="#7.5%20Memory%20Size%20Limit%20Problem" rel="nofollow">7.5 Memory Size Limit Problem</a></p> 
<p id="6.%20%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84Makefile%E4%BE%8B-toc" style="margin-left:0px;"><a href="#6.%20%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84Makefile%E4%BE%8B" rel="nofollow">8. 基本的Makefile例</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%20%E5%89%8D%E8%A8%80">1. 前言</h2> 
<p>        本文简要介绍一些主流的数字逻辑设计仿真器（比如说VCS, IRUN/Xcelium, ModelSim/QuestaSim等）的最基本用法。或许还会考虑一些设计验证辅助工具，比如说波形观测工具Verdi、Xilinx的Vivado等的基本使用方法。或许对入门者有些参考意义。（持续更新中）</p> 
<h2 id="2.%20QuestaSim%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">2. QuestaSim基本使用方法</h2> 
<p>        以下实验使用版本：Questa Sim -64 10.6c（Windows10）</p> 
<p>        基于以下代码源文件进行实验。</p> 
<pre><code>// hello_systemverilog.sv
`timescale 1ns/1ps
module tb;
	initial begin
	    #100ns;
		$display("@%0t: Hello, welcome to SystemVerilog world!",$time());		
		$finish();
	end
	
endmodule</code></pre> 
<h3 id="2.1%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91">2.1 命令行编译</h3> 
<p>        命令行运行是指在命令行终端（windows cmd, 或windows terminal等）执行。</p> 
<blockquote> 
 <p> &gt;&gt; vlog -sv hello_systemverilog.sv</p> 
</blockquote> 
<p>        vlog是questasim的编译命令。“-sv”是指示vlog按照systemverilog语法进行编译。 编译后会生成一个库，由于以上没有指定，缺省的库名就是work。如果要显式地指定不同的库名，可以追加选项“-work libname”，初学者就不必去纠结这个了。</p> 
<h3 id="2.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C">2.2 命令行运行</h3> 
<blockquote> 
 <p> &gt;&gt; vsim -c -novopt  work.tb</p> 
</blockquote> 
<p>        其中，“-c”表示在命令行运行，即不启动GUI（图形界面）。“-novopt”表示不做优化，在调试时通常使用这个选项，这个会使得仿真速度慢一些。work就是上一节编译生成的库，tb就是其中的仿真模型顶层，对应于以上module的module name。 </p> 
<p>        执行以上命令后，进入VSIM的命令行界面，提示符为“VSIM 1&gt;”。</p> 
<p>        输入命令run -all就可以完成仿真。如下图所示：</p> 
<p class="img-center"><img alt="" height="157" src="https://images2.imgbox.com/2e/1f/Rt4BWp1C_o.png" width="502"></p> 
<p>         也可以在run后面跟一个表示时间长度的参数。比如说“run 1ns”等。由以上源文件中可知，总的仿真时间为100ns，所以run后跟的时间长度参数大于等于100ns时其效果与“run -all”是相同的，都会跑完仿真并从VSIM命令行界面退出（退回到终端命令行）。如果小于100ns，则执行完命令后会继续停留在VSIM的命令行界面等待进一步的命令输入。</p> 
<h3 id="2.3%20%E5%90%AF%E5%8A%A8GUI%E8%BF%9B%E8%A1%8C%E4%BB%BF%E7%9C%9F">2.3 启动GUI进行仿真</h3> 
<p>        上一节的命令中如果去掉“-c”选项，则会启动QuestaSim的图形界面。 当然，也可以显式地加上选项“-gui”</p> 
<blockquote> 
 <p> &gt;&gt; vsim -novopt  work.tb </p> 
</blockquote> 
<p>在弹出的QuestaSim-GUI的transcript窗口的命令行输入“run -all”，同样可以运行，如下图所示。 </p> 
<p><img alt="" height="214" src="https://images2.imgbox.com/6d/22/xfoKslvm_o.png" width="527"></p> 
<p>        注意，在运行弹出的对话框，如果选择“是”会退出GUI，选择“否”则会继续停在GUI中等待下一步指令。</p> 
<p class="img-center"><img alt="" height="177" src="https://images2.imgbox.com/66/86/3MDHkJvM_o.png" width="287"></p> 
<p>        如果停留在GUI中，并且想重新执行一遍仿真，可以执行restart命令，然后运行run -all。注意，不执行restart而运行run -all，不会有任何效果，因为以上仿真已经结束（仿真时间已经前进到100ns处，再执行run也没有什么可运行的了）。restart相当于让仿真时间复位归零。</p> 
<h3 id="2.4%20%E4%BB%8EGUI%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C">2.4 从GUI中进行编译运行</h3> 
<p>        以上是从终端命令行执行QuestaSim编译运行命令启动QuestaSim-GUI。也可以直接先启动QuestaSim-GUI，在GUI中创建project、添加文件、编译、运行等。实际上毋宁说从GUI开始，是初学者最喜欢的方式吧。</p> 
<p>        双击QuestaSim图标启动QuestaSim-GUI，</p> 
<p>        从菜单栏选择File--&gt;New--&gt;Project：</p> 
<p class="img-center"><img alt="" height="301" src="https://images2.imgbox.com/de/50/pJ0rZDWU_o.png" width="348"></p> 
<p class="img-center"><img alt="" height="261" src="https://images2.imgbox.com/c2/d3/lSkeDqhA_o.png" width="291"></p> 
<p>        选择“Add Existing File”并选择上面编辑好的源代码。右键选择文件从下拉菜单选择compile--&gt;selected file：</p> 
<p class="img-center"><img alt="" height="257" src="https://images2.imgbox.com/97/78/lBc2aXdb_o.png" width="420"></p> 
<p>         在library窗口看到编译生成的库work，及其中包含的tb：</p> 
<p class="img-center"><img alt="" height="119" src="https://images2.imgbox.com/0f/0e/jdHRB8zx_o.png" width="579"></p> 
<p>        右键选择tb并下来菜单按如下图所示选择，即可启动仿真：</p> 
<p class="img-center"><img alt="" height="141" src="https://images2.imgbox.com/ca/3d/nbXC84su_o.png" width="599"></p> 
<p>        在下面的Transcript窗口会显示出等价的命令行命令“vsim -novopt work.tb”，然后停留在命令行等待指令，输入run -all执行仿真（与上面描述的相同），如下图所示： </p> 
<p class="img-center"><img alt="" height="225" src="https://images2.imgbox.com/08/78/DLoQmnvX_o.png" width="595"></p> 
<h3 id="2.5%C2%A0dump%E6%B3%A2%E5%BD%A2">2.5 dump波形</h3> 
<p>        在图形界面仿真想dump信号波形观察的话，在执行run -all之前先执行以下命令即可：</p> 
<blockquote> 
 <p>VSIM 1&gt; log -r /*</p> 
</blockquote> 
<p>        这条命令表示对所有信号进行波形dump，对于初学者来说，所接触的设计都比较小，就全部dump即可。以上命令选项就不赘述。当设计到大型设计的话，就要考虑有选择性的进行波形dump（话说回来，大型设计的话通常就应该采用vcs或者ius等了）。 </p> 
<p>        当然，以上例码过于简单，没有波形观测的必要，这里就暂时不演示如何在QuestaSIm-GUI中观察波形了。</p> 
<h3 id="2.6%20%E6%8C%87%E5%AE%9A%E9%9A%8F%E6%9C%BA%E7%A7%8D%E5%AD%90">2.6 指定随机种子</h3> 
<blockquote> 
 <p> &gt;&gt; vsim -c -novopt -sv_seed 0 work.tb</p> 
 <p> &gt;&gt; vsim -c -novopt -sv_seed random work.tb</p> 
</blockquote> 
<p>        可以用-sv_seed选项来指定随机化初始种子。 以上第一条语句是指定0作为种子，而第二条语句是指定每次运行随机生成种子。如果仿真程序中有随机因素，则第一条语句即便重复运行也会产生完全相同的结果，而第二条语句在重复运行时每次会产生不同的结果。随机化以及可控的随机化是仿真验证的一个非常重要的方面，值得仔细学习。</p> 
<h3 id="2.7%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8C%87%E5%AE%9Atestcase%E5%90%8D">2.7 命令行指定testcase名</h3> 
<p>        当一个testbench中存在多个testcase时，在运行仿真时需要指定所需要运行的testcase名，命令行格式如下：</p> 
<pre><code>Vsim [options] +TESTNAME=[testcase]  work.tb 

For example:
vsim work.tb -sv_seed $SEED -l sim.log +TESTNAME=smoke_test</code></pre> 
<p>        其中smoke_test为代表一个testcase的class name。 注意，不需要双引号。</p> 
<h3 id="2.8%20%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9">2.8 其它常用选项</h3> 
<blockquote> 
 <p># 常用<br> -c              # 使vsim运行在命令行模式，不启动图形界面，节省时间<br> -novopt     # 不采用vopt优化，常和+acc配合使用，常用于调试阶段需要跟踪观测所有代码中出现的信号时</p> 
 <p>-voptargs=acc # 采用优化编译，但是保留对所有信号可访问<br> -l &lt;logfile&gt;       # 输出仿真的log文件<br> -do &lt;dofile&gt;     # 开始仿真后运行tcl脚本（控制文件）<br> -L                     # 加载所需要的仿真库文件<br> -sv_seed [n | random] #指定随机种子<br>  <br> # 其它<br> -t                             # &lt;ps or ns&gt; 定义仿真时间精度<br> -g|G&lt;name=value&gt;# 设置VHDL的generic参数值<br> -quiet                      # 关闭loading的信息<br> -coverage        # 在仿真时产生代码覆盖率数据，功能覆盖率数据默认生成，与此项无关 <br> -classdebug     # 更多类调试功能<br> -solvefaileddebug   # 使能输出随机化失败等更多调试信息 </p> 
</blockquote> 
<h3 id="2.6%20%E5%9F%BA%E4%BA%8ETcl%E8%84%9A%E6%9C%AC%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95">2.9 基于Tcl脚本的运行方法</h3> 
<p>        当设计文件比较多，将所有仿真配置、命令、源文件等相关信息都写到一个Tcl文件中，能够大大提高工作效率。类似于windows中的批处理脚本、或者linux下的shell脚本或者Makefile等。以下介绍一个简单的QuestaSim仿真用Tcl脚本，在Windows和Linux下都可以使用。</p> 
<pre><code class="language-bash">set TB   "tb_top" 

set INCDIR "+incdir+../design"

set VCOMP "vlog -cover bst -timescale=1ns/1ps -l comp.log $INCDIR"

# clean the environment and remove trash files
set delfiles [glob work *.log *.ucdb sim.list]

file delete -force {*}$delfiles

# compile the design and dut with a filelist
vlib work
eval $VCOMP     ../src/designfile1.v
eval $VCOMP     ../src/designfile2.v
eval $VCOMP     ../src/designfile3.v
eval $VCOMP -sv  ./dut_pkg1.sv
eval $VCOMP -sv  ./$TB.sv

# run a test
set TEST chnl_burst_test
set SEED [expr int(rand() * 100)]
vsim work.tb -sv_seed $SEED -l sim.log +TESTNAME=$TEST
run -all</code></pre> 
<h3 id="2.10%20%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">2.10 其它常用命令</h3> 
<blockquote> 
 <p>vlog # 编译<br> vlib  # 建立一个新的工作库/逻辑库<br> vmap # 映射逻辑库名到制定的目录<br> add wave # 将信号加入波形<br> run [x | -all] # 执行仿真（x表示仿真时间，-all 执行到结束，不带参数表示仅启动仿真）<br> quit # 退出仿真</p> 
</blockquote> 
<h2 id="3.%20VCS%E5%9F%BA%E6%9C%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">3. VCS基本基本使用方法</h2> 
<p>Reference: VCS® User Guide</p> 
<h3 id="3.1%20%E7%BC%96%E8%AF%91">3.1 编译</h3> 
<h4 id="3.1%20%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E4%BB%BF%E7%9C%9F%E5%91%BD%E4%BB%A4%E5%8F%8A%E9%80%89%E9%A1%B9">3.1.1 基本编译命令</h4> 
<p style="margin-left:.0001pt;text-align:justify;">        verilog file编译基本命令：vcs  top.v</p> 
<p style="margin-left:.0001pt;text-align:justify;">        需要编译多个文件时，可以将所有源文件按必要的顺序列在file.list中，然后调用命令：vcs -f file.list</p> 
<p style="margin-left:.0001pt;text-align:justify;">        对于SystemVerilog源文件的编译，需要加上选项<strong><span style="color:#0d0016;">-sverilog</span></strong>：vcs -sverilog top.sv</p> 
<h4 id="3.1.2%20%E5%8C%85%E5%90%AB%E8%B7%AF%E5%BE%84%E7%9A%84%E6%8C%87%E5%AE%9A" style="margin-left:.0001pt;text-align:left;">3.1.2 包含路径的指定</h4> 
<p style="margin-left:.0001pt;text-align:left;">        通常将一组相关联的类定义文件组成一个package，在package中include各类定义文件。比如说，<span style="background-color:#ffffff;"><span style="color:#000000;">Pkg.sv contains `include “file1.sv” ,`include “file2.sv.”</span></span></p> 
<pre><code>package pkg;

 `include “file1.sv”

 `include “file2.sv”

endpackage</code></pre> 
<p>        可以用以下编译命令进行编译，其中“+incdir”用于指定包含路径：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">vcs -sverilog  +incdir+filespath pkg.sv</span></p> 
</blockquote> 
<h4 id="3.1.3%20%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9" style="margin-left:.0001pt;text-align:justify;">3.1.3 其它常用选项</h4> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">        指定编译log</span><span style="color:#000000;">文件，用“-l”选项：</span></span></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">vcs -sverilog -l compile.log top.sv</span></span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;">        用“<span style="background-color:#ffffff;"><span style="color:#000000;">-timescale_override</span></span>”选项指定全局time scale覆盖代码文件中的<span style="background-color:#ffffff;"><span style="color:#000000;">timescale定义:</span></span></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">vcs -sverilog -timescale =1ns/1ps -l compile.log top.sv #</span></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">vcs -sverilog -timescale_override =1ns/1ps -l compile.log top.sv #</span></span>覆盖源代码中的仿真时间单位和精度，<span style="background-color:#ffffff;"><span style="color:#000000;">不推荐使用</span></span>，会把模型的时间单位覆盖，可能导致模型功能错误</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;">        -timescale与-timescale_override的区别？</p> 
<p style="margin-left:.0001pt;text-align:justify;">        改变参数定义和设置：<span style="color:#000000;">+define+LENGTH=10</span></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">vcs -sverilog  +define+LENGTH=10  -timescale =1ns/1ps -l compile.log top.sv</span></span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">        对于UVM编译使用：<span style="color:#000000;"> -ntb_opts uvm-1.2</span></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">vcs -sverilog  -ntb_opts  uvm-1.2 +define+LENGTH=10  -timescale_override =1ns/1ps -l compile.log top.sv</span></span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">        debug选项：<span style="color:#000000;">-debug_all</span></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">vcs -sverilog  ntb_opts  uvm-1.2  -debug_all +define+LENGTH=10 </span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;"> -timescale_override =1ns/1ps  -l compile.log top.sv</span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;">        代码覆盖率仿真选项：<span style="color:#000000;"> -lca  -cm line+cond+fsm+tgl+assert -cm_tgl mda</span></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">vcs -sverilog  ntb_opts  uvm-1.2  -debug_all +define+LENGTH=10 </span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">-timescale_override =1ns/1ps  -lca  -cm line+cond+fsm+tgl+assert -cm_tgl mda   -l compile.log top.sv</span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;">        如果存在多个top module，可以通过-top指定top module进行仿真。在调试阶段特别方便。</p> 
<blockquote> 
 <p>vcs –sverilog design.sv –top work.tb1 </p> 
</blockquote> 
<ul><li> <p>+warn=noxxx选项：用于禁用特定的警告信息。例如，"+warn=noDNF"将关闭关于DNF表达式的警告。</p> </li></ul> 
<p></p> 
<h4 id="3.1.4%20vcs%E9%80%89%E9%A1%B9%E4%B8%80%E8%A7%88%E8%A1%A8">3.1.4 vcs选项一览表</h4> 
<p>        更全面的vcs选项一览表参见：<a href="https://blog.csdn.net/gsjthxy/article/details/104660557" title="[VCS]VCS常用命令詳解">[VCS]VCS常用命令詳解</a></p> 
<h3 id="3.2%20%E4%BB%BF%E7%9C%9F">3.2 vcs两步仿真</h3> 
<p>        vcs的两步仿真是指，先用vcs命令编译生成一个simv文件（对应于下面三步仿真法中的compile和elaboration两个步骤的处理合二为一），再执行这个sim文件进行仿真。如下所示：</p> 
<blockquote> 
 <p># Two-step Flow<br> # Compilation<br> % vcs [compile_options] Verilog_files</p> 
 <p># Simulation<br> % simv [run_options] </p> 
</blockquote> 
<p>        The two-step flow is supported only for Verilog HDL and SystemVerilog designs.如果设计中还存在VHDL的话，需要使用三步仿真法。主要原因在于，对于VHDL和Verilog所需要的Analyze命令是不同的，分别是vhdlan和vlogan。在两步仿真法中（由于Analyze or Compile和Elaboration合并在一起处理）缺省地是使用vlogan，所以无法支持VHDL仿真。</p> 
<p></p> 
<h3 id="3.3%20vcs%E4%B8%89%E6%AD%A5%E4%BB%BF%E7%9C%9F">3.3 vcs三步仿真        </h3> 
<p>        vcs的三步仿真是指分编译（Compile or Analyze）、elaboration、和执行仿真三步执行。基本使用方法如下所示：</p> 
<blockquote> 
 <p>#Three-step Flow<br> #Analysis<br> #Always analyze Verilog before VHDL.<br> % vlogan [vlogan_options] file1.v file2.v<br> % vhdlan [vhdlan_options] file3.vhd file4.vhd</p> 
 <p>#Elaboration<br> % vcs [elaboration_options] design_unit</p> 
 <p>#Simulation<br> % simv [run_options]</p> 
</blockquote> 
<p>以下是用Makefile（本Makefile取自路科验证课程示例文件）实现的vcs三步仿真flow所示。分别执行make comp, make elab和make run执行三步仿真法的三个步骤。</p> 
<blockquote> 
 <p>#############################<br> # User variables<br> #############################<br> TB       = tb1<br> SEED     = 1<br> DFILES   = ../mcdt/v1/{arbiter.v,slave_fifo.v,mcdt.v}<br> VFILES   = $(TB).v</p> 
 <p><br> #############################<br> # Environment variables<br> #############################<br> VCOMP                = vlogan -full64 -sverilog -timescale=1ps/1ps -nc -l comp.log <br> ELAB                 = vcs -full64 -debug_all -l elab.log -sim_res=1ps -fsdb<br> RUN                  = $(TB).simv -l run.log -sml +ntb_random_seed=$(SEED)</p> 
 <p>comp:<br>     $(VCOMP) $(DFILES) $(VFILES)</p> 
 <p>elab: <br>     $(ELAB) -top $(TB) -o $(TB).simv</p> 
 <p>run:<br>     $(RUN) </p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;">        当然，当一切都调试完毕后，也可以直接一条命令执行完事：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">make comp elab run</p> 
</blockquote> 
<h3 id="3.4%C2%A0%20fsdb%E6%B3%A2%E5%BD%A2%E8%BE%93%E5%87%BA%E9%80%89%E9%A1%B9">3.4  fsdb波形输出选项</h3> 
<p>        vcs仿真中要输出fsdb波形，需要以下两方面的代码和设置。</p> 
<p>        （1）testbench文件中需要追加fsdb波形dump命令，示例如下：</p> 
<pre><code>//6. FSDB Waveform dump. 
initial
begin
    begin
        $fsdbDumpfile("./top.fsdb");
        $fsdbDumpvars(0,tb);
    end 
end</code></pre> 
<p>        (2) 在vcs命令行添加“-fsdb选项”，如以上Makefile中的ELAB命令所示：</p> 
<blockquote> 
 <p>ELAB                 = vcs -full64 -debug_all -l elab.log -sim_res=1ps -fsdb</p> 
</blockquote> 
<p>        当然，这个选项也可以修改一下，改为可以在命令行指定以便于在执行make命令开启和关闭fsdb波形输出。</p> 
<h3 id="3.2%20ucli%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4">3.5 ucli</h3> 
<h4 id="3.5.1%20%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D">3.5.1 基础介绍</h4> 
<p>        Unified Command Line Interface (UCLI) 提供了与VCS交互仿真的控制命令，即与VCS的命令行输入接口。UCLI的命令是基于Tcl脚本语言进行编写的，也就是说可以编写Tcl脚本来实现：</p> 
<ul><li>控制仿真</li><li>dump fsdb或者vpd波形文件</li><li>保存或恢复仿真状态</li><li>force或release某个信号</li><li>使用breakpoints或scope以及内建宏等信息对设计进行调试</li></ul> 
<p>        因此可以很灵活的进行调试和仿真控制。</p> 
<p>        基本使用方法：</p> 
<pre><code>simv -ucli -i xxx.tcl</code></pre> 
<p>        这里我们吃进去一个xxx.tcl文件，其中包含了想要的UCLI命令。</p> 
<h4 id="3.5.2%20%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4">3.5.2 常见命令</h4> 
<p>        VCS有命令行模式和图形模式，图形模式使用的是DVE，命令交互模式使用的是ucli。</p> 
<p>        vcs中要调用ucli接口，执行脚本，必须在compile的时候，加入debug的权限：-debug，-debug_pp，-debug_all，-debug_access，-debug_region。在run的时候，指定vcs -ucli [run_option]，需要在编译时加入参数以开启ucli，否则ucli交互时只能使用简单的 ’run’、 ‘dump’、 'quit’命令。</p> 
<p>        推荐编译时添加参数如下：</p> 
<p>        ‘-debug_access&lt;+option&gt;’ 对系统进行调试</p> 
<p>        ‘-debug_access+classdbg’ 用于测试台调试</p> 
<p>        ‘debug_access+all’</p> 
<p>        ucli提供的命令：</p> 
<blockquote> 
 <p>call，调用verilog或者vhdl中的system task；</p> 
 <p>stop，设置断点；</p> 
 <p>abort (中止评估宏文件)<br> ace (评估模拟模拟器命令)<br> alias 为命令创建别名)<br> assertion 断言（SVA / PSL）相关命令)<br> call 执行Verilog系统任务/功能，Verilog PLI任务/功能或VHDL外部过程)<br> cbug 对C，C ++和SystemC源文件的调试支持)<br> checkpoint 检查点/在当前/给定时间加入仿真设计)<br> config 显示/设置配置变量的当前设置)<br> constraints 显示设计信息，禁用/启用/添加/删除/更改约束，或提取约束的测试用例）<br> debug<br> coverage 评估覆盖命令)<br> detach_sim 从Verdi脱离simv，然后回到UCLI)<br> do 评估一个TCL（宏）脚本； “源” TCL命令的超集)<br> drivers 获取信号/变量的驱动程序信息)<br> dump 创建/操作/关闭转储值更改文件信息)<br> finish 让工具完成，然后将控制权返回给UCLI)<br> force 强制或将值存入信号/变量)<br> fsdb 适用于VCS（-MX）的Debussy FSDB命令集)<br> get 获取信号/变量的值)<br> helpdoc 修改或扩展ucli帮助页面)<br> listing 显示源文本)<br> loaddl 在模拟器空间中加载/卸载用户的动态对象<br> loads 获取信号/变量的负载信息<br> lp_show 本机低功耗（NLP）相关命令<br> memory 从文件加载/写入文件的内存值，或使用给定值初始化内存<br> msglog 设计和测试平台静态和动态数据记录<br> next 推进工具逐步完成任务和功能<br> onbreak 指定在宏到达停止点时运行的脚本<br> onerror 指定在宏遇到错误时运行的脚本<br> onfail 指定在宏遇到故障时运行的脚本<br> pause 暂停执行宏文件<br> power 电源统计相关命令(SAIF)：<br> release 从使用“ force”分配的值中释放变量<br> report_timing 将实例的计时信息报告给指定的文件或控制台<br> report_violations 设置各种与xprop相关的报告违规<br> restart 重新执行工具； UCLI将使用以前的设置返回到零时间<br> restore 恢复保存在文件中的模拟状态<br> esume 恢复执行宏文件<br> run xx 运行xx时间后停止，不推荐使用<br> run 运行仿真直到遇到$stop或者设置的断点<br> run -posedge xx 运行到信号xx的上升沿停止<br> run -change xx 运行到信号xx变化时停止<br> saif 交换活动交换格式相关命令<br> save 将模拟状态保存到文件中<br> scope 显示当前的顶层<br> scope xxx 进入xxx模块<br> scope -up 回到上一层<br> search 搜索名称与指定模式匹配的设计对象<br> senv 显示一个或所有synopsys :: env数组元素<br> sexpr 评估工具中的表达式<br> show 显示当前模块的信号及子模块<br> show xxx -value -radix hex/bin/dec 以特定形式显示信号值<br> stack 显示线程信息或移动调用堆栈<br> start 开始执行工具<br> start_verdi 从UCLI提示符启动Verdi<br> status 显示宏文件堆栈<br> step 推进工具一条语句<br> stop 显示已经设置的断点<br> stop -posedge xx 在信号的上升沿设置断点<br> stop -condition {信号表达式} 在信号表达式为真的地方设置断点<br> stop -delete xx 删除断点xx，xx为断点数字编号<br> tcheck 启用/禁用指定实例/端口的定时检查<br> Tcl Tcl内置命令的帮助<br> thread 显示线程信息或移动当前线程<br> unalias 删除一个或多个别名<br> virtual 创建，删除或显示虚拟对象<br> xprop 设置或查询xprop合并模式</p> 
</blockquote> 
<h3 id="3.4%20VCS%E4%B8%8EVCS_MX%E7%9A%84%E5%8C%BA%E5%88%AB">3.5 VCS与VCS_MX的区别</h3> 
<p>        VCS_MX为mixed hdl仿真器，支持vhdl+verilog+sv的混合仿真。VCS只支持verilog, sv。在feature上唯一的区别在于对vhdl的支持。如果没有vhdl的设计的话或许VCS好些，速度快些。</p> 
<p></p> 
<h2 id="4.%20IUS%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">4. IUS/Xcelium基本使用方法</h2> 
<h3 id="4.0%20%E5%B8%AE%E5%8A%A9%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95">4.0 帮助查询方法</h3> 
<blockquote> 
 <p>irun -helpall | grep "word of interest"</p> 
</blockquote> 
<p>        比如说要查询关于ieee1364的仿真选项，可以输入命令如下：</p> 
<blockquote> 
 <p>$ irun -helpall | grep "ieee1364"</p> 
</blockquote> 
<p>        可以得到以下反馈信息（意思是按照IEEE1364标准报告错误）：</p> 
<p>        -ieee1364                  Report errors according to IEEE 1364 standards </p> 
<p></p> 
<h3 id="4.1%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">4.1 基本使用方法</h3> 
<blockquote> 
 <p>irun +access+rwc helloworld.v -timescale 1ns/10ps  </p> 
 <p>irun -sv +access+rwc helloworld.sv -timescale 1ns/10ps  </p> 
 <p>irun -sv +access+rwc helloworld.sv -timescale 1ns/10ps  -seed 42</p> 
 <p>irun -sv +access+rwc helloworld.sv -timescale 1ns/10ps  -seed random</p> 
 <p>irun -sv +access+rwc helloworld.sv -timescale 1ns/10ps  -svseed 42</p> 
 <p>irun -sv +access+rwc helloworld.sv -timescale 1ns/10ps  -svseed random</p> 
 <p>...</p> 
</blockquote> 
<h3 id="4.2%20seed%E4%B8%8Esvseed%E7%9A%84%E5%8C%BA%E5%88%AB">4.2 seed与svseed的区别</h3> 
<p>        查询irun的帮助信息可以得到：</p> 
<blockquote> 
 <p>  -seed &lt;seed&gt;               Set the seed value for SystemVerilog and Specman<br>   -snseed &lt;seed&gt;             Pass seed value to Specman<br>   -svseed &lt;seed&gt;             Set SystemVerilog default RNG seed </p> 
</blockquote> 
<p>         对于systemverilog testbench，seed和svseed没有差别。都是用于指定初始随机种子。&lt;seed&gt;如果是数字的话，则表示用该数字作为随机种子；如果是random的话，则表示随机生成一个数作为初始随机种子。</p> 
<p>        指定确定的随机种子使得仿真结果可以再现，为调试提供了巨大的遍历。</p> 
<h3 id="4.3%20Xcelium">4.3 Xcelium</h3> 
<p><br>         Xcelium（xrun）是cadence最新的仿真工具，Incisive(irun)的升级版本。</p> 
<p>        【单步仿真】<br>         xrun默认是单步仿真</p> 
<blockquote> 
 <p>&gt;&gt; xrun add.v   //自动完成comp , elab ,sim</p> 
</blockquote> 
<p>        【三步仿真】</p> 
<blockquote> 
 <p>&gt;&gt; xrun -compile add.v   // compile</p> 
 <p>&gt;&gt; xrun -elaborate add.v //elab, 生成可执行代码</p> 
 <p>&gt;&gt; xrun -R                       // 自动识别snapshot并执行</p> 
</blockquote> 
<h2 id="5.%20Verdi%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">5. Verdi基本使用方法</h2> 
<h3 id="5.1%20verdi%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%E4%BB%A3%E7%A0%81">5.1 verdi直接打开代码</h3> 
<blockquote> 
 <p>verdi -f filelist.f -top rtl_top</p> 
</blockquote> 
<p>        verdi可以通过上面指令直接打开没有编译的代码，其中rtl_top表示rtl顶层模块。</p> 
<h3 id="5.2%20kdb%E9%80%89%E9%A1%B9">5.2 kdb选项</h3> 
<p>        kdb选项是vcs选项，在进行vcs仿真时可以加入kdb选项，vcs仿真会生成verdi的库文件，通常库文件为sim.daidir,库文件里面包含相应代码信息；利用库文件verdi可以快捷打开rtl代码而不需要重新编译。verdi利用daidir打开代码办法（以下两种均可打开RTL代码）：</p> 
<blockquote> 
 <p>verdi -dbdir simv.daidir &amp;<br> verdi -simflow -simBin simv &amp;</p> 
</blockquote> 
<h3 id="5.3%20verdi%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%E6%B3%A2%E5%BD%A2">5.3 verdi直接打开波形</h3> 
<blockquote> 
 <p><code>verdi -ssf top.fsdb -arch32 -nologo &amp;</code></p> 
</blockquote> 
<p>        -ssf表示指定波形文件。  </p> 
<h3 id="5.4%20verdi%E6%89%93%E5%BC%80%E6%8C%87%E5%AE%9A%E7%9A%84restore%E6%96%87%E4%BB%B6">5.4 verdi打开指定的restore文件</h3> 
<blockquote> 
 <p>verdi -sswr fliename.rc</p> 
</blockquote> 
<p>        verdi可以通过以上指令，指定波形restore文件，可以将已保存的信号恢复。</p> 
<p>        而restore文件可以在verdi-gui中以如下方式保存：</p> 
<p class="img-center"><img alt="" height="267" src="https://images2.imgbox.com/ed/7d/SwJ58iKM_o.png" width="493"></p> 
<p><br>         当然加载restore文件也可以在这个菜单下进行（“Restore Signal”）。</p> 
<p></p> 
<h3 id="5.5%20%E6%B7%BB%E5%8A%A0%E6%B3%A2%E5%BD%A2%E8%A7%82%E6%B5%8B%E4%BF%A1%E5%8F%B7">5.5 添加波形观测信号</h3> 
<h4 id="5.5.1%20%E6%96%B9%E6%B3%951">5.5.1 方法1</h4> 
<p>        在波形区的左边是有G1, G2，。。。的分组的，方便对信号进行分组观测，双击可以将该组别的信号折叠起来。组名可以修改。如果现有的组中都有信号加入的话，verdi会自动生成一个新的空组。</p> 
<p>        如下图所示的窗口下半部分为波形窗口（假定已经载入了波形），点击波形按钮，然后选择所要观测的信号加入即可。</p> 
<p class="img-center"><img alt="" height="270" src="https://images2.imgbox.com/5e/28/JTGkMr6j_o.png" width="607"></p> 
<p>        如果想在某一组中添加信号，如G1，则单击G1, 然后点击键盘上的G,即可出现下面的对话框。该对话框左边是文件，右边是文件中的信号，可以通过下边的filter选择输入信号还是输出信号等等，这样也可以显示某信号的波形。 <img alt="" height="280" src="https://images2.imgbox.com/ea/65/Mp55Ll2a_o.png" width="868"></p> 
<p></p> 
<h4 id="5.5.2%20%E6%96%B9%E6%B3%952">5.5.2 方法2</h4> 
<p>        在右上代码区选中一个或多个信号，使用<code>Ctrl+w</code>即可将该信号的波形显示在下方的波形区。</p> 
<p><img alt="这里写图片描述" src="https://images2.imgbox.com/7d/f4/5zIU3bXr_o.png"> </p> 
<h4 id="5.5.3%20%E6%96%B9%E6%B3%953">5.5.3 方法3</h4> 
<p>        File--&gt; Restore Signal，然后选择之前已经保存好的*.rc文件即可。</p> 
<h2 id="5.%20%E6%BA%90%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E6%96%B9%E5%BC%8F">6. 编译文件指定方式</h2> 
<p>        参见<a href="https://blog.csdn.net/chenxy_bwave/article/details/130893972" title="https://blog.csdn.net/chenxy_bwave/article/details/130893972">https://blog.csdn.net/chenxy_bwave/article/details/130893972</a></p> 
<p></p> 
<h2 id="7.%20fsdb%E6%B3%A2%E5%BD%A2dump">7. fsdb波形dump</h2> 
<h3 id="7.1%20vcs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E5%AE%9A">7.1 vcs环境变量设定</h3> 
<p>        首先要把FSDB dumper库的路径添加到LD_LIBRARY_PATH环境变量， Shell命令格式如下：</p> 
<pre><code>setenv LD_LIBRARY_PATH ${LD_LIBRARY_PATH}:${NOVAS_HOME}/share/PLI/VCS/LINUX64</code></pre> 
<p>        注意：如果使用的是32位Linux，需要把LINUX64替换成LINUX。</p> 
<p>        然后在vcs的命令行添加 “ -fsdb ” 参数。</p> 
<h3 id="7.2%20irun%E7%8E%AF%E5%A2%83%E8%AE%BE%E5%AE%9A">7.2 irun环境设定</h3> 
<p>        将verdi的PLI库路径加入环境变量LD_LIBRARY_PATH：</p> 
<pre><code>setenv LD_LIBRARY_PATH ${LD_LIBRARY_PATH}:${VERDI_HOME}/share/PLI/IUS/LINUX64</code></pre> 
<p>        注意与vcs的路径的区别在于：VCS的是/share/PLI/VCS/LINUX64，Irun的是 /share/PLI/IUS/LINUX64。</p> 
<h3 id="7.3%20Testbench%E4%B8%AD%E6%A4%8D%E5%85%A5%E6%B3%A2%E5%BD%A2dump%E5%91%BD%E4%BB%A4">7.3 Testbench中植入波形dump命令</h3> 
<p>        这里以fsdb格式波形的dump为例进行说明。</p> 
<p>        首先需要在testbench的顶层植入以下代码块（这个与使用何种仿真器无关）。</p> 
<pre><code>initial begin
	if($test$plusargs("FSDB_ON")) begin
        //记录波形，波形名字.fsdb,也可以用字符串变量的方式设置为以testcase命名的文件名
		$fsdbDumpfile("top.fsdb");  
    		//0: 当前级及其下面所有层级，如top.A, top.A.a，所有在top下面的多维数组均会被dump
	    	//1: 仅仅dump当前组，也就是说，只dump top这一层的多维数组。

        //+all参数，dump SV中的struct结构体
		$fsdbDumpvars("+all");  

        //也可以向以下这样指定某个模块进行波形dump，对于大型系统仿真来说这个很重要
        $fsdbDumpvars(0,tb_top.u_DIGITOP.u_BB_TOP);

		$fsdbDumpSVA();   //将assertion的结果存存储到fsdb中
		$fsdbDumpMDA(0, top);  //dump memory arrays

        //以上仅为fsdbDump family的一些常见用法，其它所有各种用法可以查阅相关手册
	end
end
</code></pre> 
<h3 id="7.4%20%E4%BB%BF%E7%9C%9F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A">7.4 仿真命令行参数指定</h3> 
<p>        以上代码段中，“if($test$plusargs("FSDB_ON"))”表示从命令行读取参数并判断是否开启波形dump处理。如果去掉这个if判断，就表示无条件的波形dump。当然，正式项目开发中通常会加上条件判断，将开关控制权留到实际做仿真时去。因为回归验证由于要做大量的仿真，通常是不会dump波形，只有单个testcase的调试时才会进行仿真验证。</p> 
<h4 id="7.4.1%20vcs%E4%BB%BF%E7%9C%9F%E5%99%A8">7.4.1 vcs仿真器</h4> 
<p>        对应于以上代码中的参数名“FSDB_ON”，VCS仿真时在命令行以如下方式指定参数即表示开启FSDB波形dump：</p> 
<pre><code>vcs ... +FDDB_ON ...</code></pre> 
<h4 id="7.4.2%C2%A0irun%E4%BB%BF%E7%9C%9F%E5%99%A8">7.4.2 irun仿真器</h4> 
<p>        与vcs的命令行格式略有不同，irun命令行不需要“+” 。如下所示：</p> 
<blockquote> 
 <p>irun ... FSDB_ON ...</p> 
</blockquote> 
<p></p> 
<h3 id="7.5%20Memory%20Size%20Limit%20Problem">7.5 Memory Size Limit Problem</h3> 
<p>        在仿真中dump波形经常会碰到如下问题： </p> 
<blockquote> 
 <p>*Verdi* FSDB: For performance reasons, the Memory Size Limit has been increased to 512M. </p> 
</blockquote> 
<p>        to be investigated.</p> 
<p></p> 
<h2 id="6.%20%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84Makefile%E4%BE%8B">8. 基本的Makefile例</h2> 
<p></p> 
<p>irun例子：</p> 
<pre><code>TB       = tb
SEED     = 1

run: tb.v
	irun -sv +access+rwc -f rtl.f -timescale 1ns/10ps
    
.PHONY:clean
clean: 
	rm -rf ./INCA_libs *.log irun.history
</code></pre> 
<p>vcs例子：</p> 
<pre><code>.PHONY:comp sim clean

OUTPUT = adder_top

VCS = vcs -sverilog +v2k -timescale=1ns/1ns                             \
	  -debug_all							\
	  -o ${OUTPUT}							\
	  -l compile.log						\

SIM = ./${OUTPUT} -l run.log

comp:
	${VCS} -f verilog_file.f

sim:
	${SIM}

clean:
	rm -rf ./csrc *.daidir *.log simv* *.key</code></pre> 
<p>参考文献：</p> 
<p>[1] <a href="https://www.cnblogs.com/flymood/p/7100734.html" rel="nofollow" title="vcs/verdi filist - FLYMOOD - 博客园 (cnblogs.com)">vcs/verdi filist - FLYMOOD - 博客园 (cnblogs.com)</a></p> 
<p>[2] VCS® User Guide</p> 
<p>[3] Questa® SIM User's Manual</p> 
<p>[4] <a href="https://support.xilinx.com/s/question/0D52E00006hpTqASAU/support-for-y-libext-incdir-define?language=en_US" rel="nofollow" title="Support for -y +libext +incdir +define? (xilinx.com)">Support for -y +libext +incdir +define? (xilinx.com)</a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d8f58f38e4a91e50fb47a4ebd854721/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32单片机（六）TIM定时器 -＞ 第三节：TIM输出比较</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44e37a3cf6dc5b2234145defaa9efbab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信小程序之 页面跳转</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>