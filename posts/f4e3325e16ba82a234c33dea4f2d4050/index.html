<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>子进程、僵尸进程、孤儿进程(个人总结) - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="子进程、僵尸进程、孤儿进程(个人总结)" />
<meta property="og:description" content="声明: 1. 本文为我的个人复习总结, 并非那种从零基础开始普及知识 内容详细全面, 言辞官方的文章
2. 由于是个人总结, 所以用最精简的话语来写文章
3. 若有错误不当之处, 请指出
子进程:
由fork( )创建, 该函数被调用一次，但返回两次(子进程的返回值是0，而父进程的返回值是子进程id)
子进程得到的只是父进程的拷贝(拷贝其内存空间, 代码空间, 数据空间, 程序计数器pc值)，而不是父进程本身
僵尸进程:
子进程结束了, 但父进程暂未对其资源进行回收; task_struct结构还保存在进程列表中
孤儿进程:
在回收僵尸进程之前, 如果父进程结束了，则僵尸进程变为孤儿进程，进而被init进程接管、回收
注意: ps出来以Z开头的便是僵尸进程, kill -9 并不能直接死僵尸进程
为什么需要僵尸进程(保留task_struct)?
因为task_struct里面保存了进程的pid、退出码、以及一些统计信息, 父进程可能会关心这些信息
如何处理僵尸进程？
三个方案:
父进程调用wait( )/waitpid( )
缺点: wait调用是阻塞的, 如果调用wait时子进程还没有退出, 将阻塞住父进程 影响性能
kill父进程
使僵尸进程变为孤儿进程, 从而被init进程接管、回收
缺点: 父进程可能还有作用, 不该随随便便杀死
通过进程通信的信号机制 异步回调通知进行回收 (最佳)
编写程序时, 子进程退出前向父进程发送SIGCHLD信号; 父进程回调函数收到SIGCHLD信号后 便去调用wait( )/waitpid( ) 回收 子僵尸进程
什么时候会发生 僵尸进程一直不被回收 的情况?
在采用第三种方案时, 如果父进程是一个循环 永久不会结束, 那么子进程就会一直保持僵尸状态" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f4e3325e16ba82a234c33dea4f2d4050/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-05T21:23:44+08:00" />
<meta property="article:modified_time" content="2022-03-05T21:23:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">子进程、僵尸进程、孤儿进程(个人总结)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>    <strong>声明:</strong> 1. 本文为我的个人复习总结, 并<strong>非</strong>那种从零基础开始普及知识 <strong>内容详细全面</strong>, <strong>言辞官方</strong>的文章<br>               2. 由于是个人总结, 所以用最精简的话语来写文章<br>               3. 若有错误不当之处, 请指出</p> 
<p><strong>子进程:</strong></p> 
<p>由fork( )创建, 该函数被调用一次，但返回两次(子进程的返回值是0，而父进程的返回值是子进程id)</p> 
<p>子进程得到的只是父进程的拷贝(拷贝其<strong>内存空间</strong>, 代码空间, 数据空间, 程序计数器<strong>pc</strong>值)，而不是父进程本身</p> 
<p><strong>僵尸进程:</strong></p> 
<p>子进程结束了, 但父进程暂未对其资源进行回收; task_struct结构还保存在进程列表中</p> 
<p><strong>孤儿进程:</strong></p> 
<p>在回收僵尸进程之前, 如果父进程结束了，则僵尸进程变为<strong>孤儿进程</strong>，进而被init进程接管、回收</p> 
<p>注意: ps出来以Z开头的便是僵尸进程, kill -9 并不能直接死僵尸进程</p> 
<p><strong>为什么需要僵尸进程(保留<code>task_struct</code>)?</strong></p> 
<p>因为<code>task_struct</code>里面保存了进程的pid、退出码、以及一些统计信息, 父进程可能会关心这些信息</p> 
<p><strong>如何处理僵尸进程？</strong></p> 
<p>三个方案:</p> 
<ol><li> <p>父进程调用wait( )/waitpid( )</p> <p>缺点: wait调用是<strong>阻塞</strong>的, 如果调用wait时子进程还没有退出, 将阻塞住父进程 影响性能</p> </li><li> <p>kill父进程</p> <p>使僵尸进程变为孤儿进程, 从而被init进程接管、回收</p> <p>缺点: 父进程可能还有作用, 不该随随便便杀死</p> </li><li> <p>通过进程通信的<strong>信号</strong>机制 <strong>异步回调</strong>通知进行回收 (最佳)</p> <p>编写程序时, 子进程退出前向父进程发送<code>SIGCHLD</code>信号; 父进程回调函数收到<code>SIGCHLD</code>信号后 便去调用wait( )/waitpid( ) 回收 子僵尸进程</p> </li></ol> 
<p><strong>什么时候会发生 僵尸进程一直不被回收 的情况?</strong></p> 
<p>在采用第三种方案时, 如果父进程是一个循环 永久不会结束, 那么子进程就会一直保持僵尸状态</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e45220ccef5ff6dca5f152a342dfc1c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">简单自定义协议的封包和解包</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2a35ac24c1253401cd9ed20be141e588/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小菜鸡的学习笔记——sql注入之sqli-lab边学边练</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>