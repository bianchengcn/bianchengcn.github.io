<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《啊哈算法》学习笔记（二）——搜索与图的遍历 - 编程中国的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《啊哈算法》学习笔记（二）——搜索与图的遍历" />
<meta property="og:description" content="搜索与图的遍历 《啊哈算法》在“搜索”前还有两个章节，讲了数据结构中的栈、队列和链表以及枚举算法。这些内容比较浅显，只是简单介绍，这里就不记录了，后续自学数据结构时会提到。这篇把搜索和图的遍历放在一起。
dfs——深度优先搜索 #include &lt;stdio.h&gt; int a[20][20];//用来存储地图，0为路，1为障碍 int book[20][20];//记录某点是否已走过（在路径上） int min = 999, way, top; int n, m; int end_x, end_y; struct Stu { int x; int y; } pos[100]; void dfs(int x, int y, int step) { int i; int next[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};//模拟走向右上左下 if (x == end_x &amp;&amp; y == end_y)判断是否到达终点 { if (step &lt; min) min = step; way&#43;&#43;; if (way == 1) printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8c577a100187aea3c7737d0bd8b607d5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-21T20:02:35+08:00" />
<meta property="article:modified_time" content="2022-04-21T20:02:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程中国的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程中国的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《啊哈算法》学习笔记（二）——搜索与图的遍历</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>搜索与图的遍历</h2> 
<p>《啊哈算法》在“搜索”前还有两个章节，讲了数据结构中的栈、队列和链表以及枚举算法。这些内容比较浅显，只是简单介绍，这里就不记录了，后续自学数据结构时会提到。这篇把搜索和图的遍历放在一起。</p> 
<h3><a id="dfs_4"></a>dfs——深度优先搜索</h3> 
<pre><code class="prism language-C">#include &lt;stdio.h&gt;

int a[20][20];//用来存储地图，0为路，1为障碍
int book[20][20];//记录某点是否已走过（在路径上）
int min = 999, way, top;
int n, m;
int end_x, end_y;

struct Stu
{
    int x;
    int y;
} pos[100];

void dfs(int x, int y, int step)
{
    int i;
    int next[4][2] = {<!-- -->{0, 1}, {1, 0}, {0, -1}, {-1, 0}};//模拟走向右上左下

    if (x == end_x &amp;&amp; y == end_y)判断是否到达终点
    {
        if (step &lt; min)
            min = step;
        way++;
        if (way == 1)
            printf("找到路了！\n");
        for (i = 0; i &lt;= top; i++)//输出路径
        {
            if (i != 0)
                printf("→");
            printf("(%d,%d)", pos[i].x, pos[i].y);
        }
        printf("\n");
    }

    for (i = 0; i &lt; 4; i++)
    {
        int tx = x + next[i][0];
        int ty = y + next[i][1];

        if (tx &lt; 0 || tx &gt;= n || ty &lt; 0 || ty &gt;= m)//是否越界
        {
            continue;
        }
        if (a[tx][ty] == 0 &amp;&amp; book[tx][ty] == 0)//判断是否走过以及是否为路
        {
            book[tx][ty] = 1;
            top++;
            pos[top].x = tx;
            pos[top].y = ty;
            dfs(tx, ty, step + 1);
            top--;
            book[tx][ty] = 0;
        }
    }
}

int main()
{
    int i, j;
    int start_x, start_y;
    printf("请输入地图的行列数：\n");
    scanf("%d %d", &amp;n, &amp;m);

    printf("请输入地图信息：\n");
    for (i = 0; i &lt; n; i++)
        for (j = 0; j &lt; m; j++)
            scanf("%d", &amp;a[i][j]);

    printf("请输入起始点和终点坐标：\n");
    scanf("%d %d %d %d", &amp;start_x, &amp;start_y, &amp;end_x, &amp;end_y);

    pos[0].x = start_x;
    pos[0].y = start_y;
    book[start_x][start_y] = 1;
    dfs(start_x, start_y, 0);

    if (!way)//如果没找到一条路
        printf("死路一条！\n");
    else
        printf("共有%d种走法，最短路径需要走%d步\n", way, min);

    return 0;
}
</code></pre> 
<p>dfs算法巧妙的运用递归思想，每一个递归的尽头都是一条路，再附加栈结构存储走过点的坐标，就可以描述路线。大致流程如下：</p> 
<p><strong>判断（x,y)是否已到达终点→如果没到达，用next数组遍历在该点的基础上右上左下各点是否能走→对每一个“下一步”判断→是否越界→是否走过/可走→若可走，book数组记录→放入栈内→dfs进入下一步的递归→book数组取消标记，位置信息出栈（top–）</strong></p> 
<p>可以输入测试数据得到结果：<br> <img src="https://images2.imgbox.com/a8/02/H5Gil6Lc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="bfs_101"></a>bfs——广度优先搜索</h3> 
<pre><code class="prism language-C">#include &lt;stdio.h&gt;

struct Stu
{
    int x;
    int y;
 //   int f;
    int s;
}; //记录一个点的坐标，并且记录到这个点要多少步，和到该店的父结点要多少步

int main()
{
    int i, j;
    int start_x, start_y, p, q; //起始点后终点的坐标
    struct Stu que[2500];       //构造队列
    int head = 0, tail = 0;

    int a[51][51] = {0};    //地图信息
    int book[51][51] = {0}; //标记已走位置信息
    int m, n;               //地图的行列数

    int next[4][2] = {<!-- -->{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; //对应着走向右上左下
    int tx, ty;                                          //对应着下一步的坐标
    int flag = 0;                                        //判断是否到达终点

    printf("请输入地图的行列数：\n");
    scanf("%d %d", &amp;n, &amp;m);

    printf("请输入地图信息：\n");
    for (i = 0; i &lt; n; i++)
    {
        for (j = 0; j &lt; m; j++)
        {
            scanf("%d", &amp;a[i][j]);
        }
    }

    printf("请输入起始点和终点的坐标：\n");
    scanf("%d %d %d %d", &amp;start_x, &amp;start_y, &amp;p, &amp;q);

    que[tail].x = start_x;
    que[tail].y = start_y;
   // que[tail].f = 0;
    que[tail].s = 0;            //对队列信息初始化
    book[start_x][start_y] = 1; //标记起点已经走过
    tail++;

    while (head &lt; tail)
    {
        for (i = 0; i &lt; 4; i++)
        {
            tx = que[head].x + next[i][0];
            ty = que[head].y + next[i][1];

            if (tx &lt; 0 || tx &gt; n - 1 || ty &lt; 0 || ty &gt; m - 1)
                continue;
            if (a[tx][ty] == 0 &amp;&amp; book[tx][ty] == 0)
            {
                book[tx][ty] = 1; //如果（tx，ty）符合要求，就标记这点为走过
                que[tail].x = tx; //并将它放入队列中
                que[tail].y = ty;
              //  que[tail].f = head;
                que[tail].s = que[head].s + 1;
                tail++;
            }

            if (tx == p &amp;&amp; ty == q)
            {
                flag = 1;
                break;
            }
        }
        if (flag == 1)
            break;
        head++; //当该点能扩展的点都扩展完了head再变化
    }
    printf("最少走%d步到达终点。\n", que[tail - 1].s);

    return 0;
}

</code></pre> 
<p>bfs与dfs不同的是，它每到一个点，并不是先把一条路走到底，而是先把所在点周围所有的点给判断完，才会再扩散。所以bfs的位置信息并不像dfs一样用栈存储，而是用队列存储。前面提到的“每到一个点”这个点我把它叫做起始点，需要判断它上下左右最临近的4个点，而这个起始点往往在队列中head部位。</p> 
<p>判断部分和dfs一样，是否越界，是否为路/已走？如果可走，就把新点放在队尾，并tail++。</p> 
<p><em>图中注释部分，关于que的结构体成员还有一个f，书中说是用f来记录路程信息，如果不输出路线就用不着。但笔者想了半天暂时没有头绪，只觉得有点像链表。另外，如果一个迷宫有多种走法，以上代码并不能输出全部路线，只能输出最简单的那条。而这时我想到一个问题，当碰到一个迷宫问题时，如果有多条路，我们往往就只要最短路径，而上面dfs的代码似乎只能输出全部可行路径，并不能只打印最短路径。</em></p> 
<p>这两个问题暂时搁置，以后碰到再写博客记录。</p> 
<h3><a id="_195"></a>图的遍历</h3> 
<p>这一章的内容基本上就是在上一章两种搜索方法的基础上说明了一下图的概念。图就是由一些结点和一些边组成的。边是连接结点之间的通道，但值得注意的是边有单向和双向之分。所以图也分有向图和无向图。其中，有向指的是一条边只能从甲结点到乙结点，而乙结点返回甲结点需要另一条边。无向指的是相邻两节点之间如果有边，他们就是联通的。</p> 
<p>本章介绍了图的一种存储方式——邻接矩阵。即</p> 
<pre><code class="prism language-C">int e[i][j];
</code></pre> 
<p>这个二维数组的每一个元素为：从左角标到右角标的距离，往往设成一个无穷大的数，说明两者之间无边，而左右角标数值相等时，往往设为0，表示自己到自己零距离。整体框架跟dfs和bfs大同小异，来看一段代码：</p> 
<pre><code class="prism language-C">#include &lt;stdio.h&gt;

int main()
{
    int i, j, n, m, book[101] = {0}, e[101][101]; // book是记录某结点是否走过，e是图的邻接矩阵存储的二维数组
    int cur;
    int que[10001], head, tail;

    printf("请输入图中结点的数量和边的数量：\n");
    scanf("%d %d", &amp;n, &amp;m);

    for (i = 1; i &lt;= n; i++) //初始化二维矩阵
        for (j = 1; j &lt;= n; j++)
        {
            if (i == j)
                e[i][j] = 0;
            else
                e[i][j] = 999;
        }

    int a, b;
    printf("请输入有边的相邻两个结点：\n");
    for (i = 1; i &lt;= m; i++)
    {
        scanf("%d %d", &amp;a, &amp;b);
        e[a][b] = 1;
        e[b][a] = 1;
    }

    //队列初始化
    head = 1;
    tail = 1;

    que[tail] = 1;
    book[1] = 1;
    tail++; // que中的结点信息确定后，tail再++

    while (head &lt; tail &amp;&amp; tail &lt;= n)
    {
        cur = que[head];
        for (i = 1; i &lt;= n; i++)
        {
            if (e[cur][i] == 1 &amp;&amp; book[i] == 0)
            {
                que[tail] = i;
                tail++;
                book[i] = 1;
            }
        }
        if (tail &gt; n)
            break;
        head++;
    }

    // for (i = 1; i &lt;= n;i++)
    //     printf("%d ", que[i]);
    //以上为初次错误写法，不一定能走完全部结点，如果某一个结点没有相邻的边的话
    for (i = 1; i &lt; tail; i++) // i只需要&lt;tail即可，现在的tail是比总结点数多1的
        printf("%d ", que[i]);
    return 0;
}

</code></pre> 
<p>代码是图的广度优先遍历，可以注意到，在输入图的信息（有哪些相邻结点有边）时有：</p> 
<pre><code class="prism language-C">for (i = 1; i &lt;= m; i++)
    {
        scanf("%d %d", &amp;a, &amp;b);
        e[a][b] = 1;
        e[b][a] = 1;
    }
</code></pre> 
<p>这说明该图为无向图，不管是a到b，还是b到a，都是联通的。</p> 
<p>图的遍历只是图的一小个知识点，下一篇博客将介绍图的最短路径算法。</p> 
<p>感谢你能看到这里，希望你能有所收获，祝好！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/de8ec16d1b5c135730cb045e9d758b7a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">对信息断舍离进行时——一段自我反省</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a70c64a3bdfd6be281a4580905204261/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《啊哈算法》学习笔记（三）——最短路径</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程中国的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>